- en: Tooling and Development Experience
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具和开发体验
- en: You are already familiar with all the core concepts of Angular. You know how
    to develop a component-based user interface, taking advantage of all the building
    blocks that the framework provides—directives, components, dependency injections,
    pipes, forms, and the brand new router.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉Angular的所有核心概念。您知道如何开发基于组件的用户界面，利用框架提供的所有构建块——指令、组件、依赖注入、管道、表单以及全新的路由器。
- en: 'This chapter goes one step further, describing how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更进一步，描述了以下内容：
- en: Using web workers for performance-sensitive applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为性能敏感的应用程序使用Web Workers
- en: Building SEO-friendly applications with server-side rendering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器端渲染构建SEO友好的应用程序
- en: Bootstrapping a project as quickly as possible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快启动项目
- en: Enhancing our experience as developers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升我们作为开发者的体验
- en: Understanding what is **ahead-of-time** (**AOT**) compilation and how to use
    it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**即时编译**（**AOT**）是什么以及如何使用它
- en: So, let's begin!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Running an application in a web worker
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web Worker中运行应用程序
- en: When talking about performance in the context of frontend web development, we
    can either mean network, computational, or rendering performance. In this section,
    we'll concentrate on rendering and computational performance, which are very tightly
    related.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当在前端Web开发的上下文中谈论性能时，我们可以指的是网络、计算或渲染性能。在本节中，我们将专注于渲染和计算性能，它们非常紧密相关。
- en: First, let's draw parallels between a web application and a video file, and
    between a browser and a video player. The biggest difference between the web application
    running in the browser and the video file playing in the video player is that
    the web page needs to be generated dynamically, in contrast to the video which
    has been recorded, encoded, and distributed. However, in both cases, the user
    of the application sees a sequence of frames; the core difference is in how these
    frames are generated. In the world of video processing, when we play a video,
    we have it already recorded; it is the responsibility of the video decoder to
    extract the individual frames based on the used compression algorithm. In contrast
    to this, on the web, JavaScript, HTML, and CSS are in charge of producing frames
    that are rendered later by the rendering engine of the browser.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将网络应用与视频文件、浏览器与视频播放器之间的相似之处进行比较。在浏览器中运行的网络应用与在视频播放器中播放的视频文件之间最大的区别在于，网页需要动态生成，而视频则是已经录制、编码和分发的。然而，在这两种情况下，应用程序的用户都会看到一系列的帧；核心区别在于这些帧是如何生成的。在视频处理的世界里，当我们播放视频时，它已经记录好了；视频解码器的责任是根据使用的压缩算法提取单个帧。相比之下，在网络上，JavaScript、HTML和CSS负责生成随后由浏览器渲染引擎渲染的帧。
- en: In the context of the browser, we can think of each frame as a snapshot of the
    web page at a given moment. The different frames are rendered fast, one after
    the other; so, in practice, the end user of the application should see them smoothly
    incorporated together, just like a video played in a video player.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上下文中，我们可以将每一帧视为给定时刻网页的快照。不同的帧快速渲染，一个接一个；因此，在实际操作中，应用程序的最终用户应该看到它们平滑地结合在一起，就像在视频播放器中播放的视频一样。
- en: On the web, we try to reach 60 **frames per second** (**fps**), which means
    that each frame has about 16 milliseconds to be computed and rendered on the screen.
    This duration includes the time required by the browser to make all the necessary
    calculations for the layout and the rendering of the page (the browser's internal
    computations), and the time that our JavaScript needs to execute.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web上，我们试图达到每秒60帧（**fps**），这意味着每一帧大约有16毫秒的时间来计算和渲染到屏幕上。这个时间段包括浏览器进行所有必要的布局和页面渲染计算（浏览器的内部计算）的时间，以及我们的JavaScript需要执行的时间。
- en: In the end, we have less than 16 milliseconds (because of the browser's internal
    computations) for our JavaScript to finish its execution. If it doesn't fit in
    this duration, the frame rate will drop by half. Since JavaScript is a single-threaded
    language, all the calculations need to happen in the main UI thread, which can
    lead to a very poor user experience because of the frame drop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的JavaScript执行时间不到16毫秒（因为浏览器的内部计算）。如果它不能在这个时间段内完成，帧率将减半。由于JavaScript是单线程语言，所有计算都需要在主UI线程中发生，这可能导致由于帧率下降而造成非常差的用户体验。
- en: HTML5 introduced an API called **web workers**, which allows the execution of
    client-side code into multiple threads. For the sake of simplicity, the standard
    doesn't allow shared memory between individual threads, but instead uses communication
    with message passing. The messages exchanged between web workers and the main
    UI thread must be strings, which often require the serialization and deserialization
    of JSON strings.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5引入了一个名为**web workers**的API，它允许客户端代码在多个线程中执行。为了简化，标准不允许各个线程之间共享内存，而是使用消息传递进行通信。Web
    Worker和主UI线程之间交换的消息必须是字符串，这通常需要JSON字符串的序列化和反序列化。
- en: At the time of writing, TC39 is working on a specification for shared memory
    between independent computational units. For further information you can visit [https://github.com/tc39/ecmascript_sharedmem](https://github.com/tc39/ecmascript_sharedmem).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，TC39正在制定独立计算单元之间共享内存的规范。有关更多信息，您可以访问[https://github.com/tc39/ecmascript_sharedmem](https://github.com/tc39/ecmascript_sharedmem)。
- en: 'The lack of shared memory between the individual workers, and the workers and
    the main UI thread brings a couple of limitations, including the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各个工作线程之间以及工作线程和主UI线程之间缺乏共享内存，这带来了一些限制，包括以下内容：
- en: Disabled access to the DOM by the worker threads
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止工作线程访问DOM
- en: Global variables cannot be shared among the individual computational units (that
    is, worker threads and main UI threads and vice versa)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量不能在各个计算单元（即工作线程和主UI线程以及反之）之间共享
- en: Web workers and Angular
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Worker和Angular
- en: On account of the platform agnostic design of Angular, the core team decided
    to take advantage of this API; during the summer of 2015, Google embedded web
    workers support into the framework. This feature allows most of the Angular applications
    to be run on a separate thread, making the main UI thread responsible only for
    rendering. This helps us achieve the goal of 60 fps much more easily than running
    the entire application in a single thread.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular的平台无关设计，核心团队决定利用这个API；在2015年夏天，Google将Web Worker支持嵌入到框架中。这个特性允许大多数Angular应用程序在单独的线程上运行，使得主UI线程只负责渲染。这比在单个线程中运行整个应用程序更容易实现60
    fps的目标。
- en: Web workers support is not enabled by default. When enabling it, we need to
    keep something in mind—in a web worker–ready application, the components will
    not be run in the main UI thread, which does not allow us to directly manipulate
    the DOM. In this case, we need to use APIs on a higher-level of abstraction, provided
    by Angular, for establishing data binding or manipulating the elements properties.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Web Worker的支持没有被启用。当启用它时，我们需要记住一点——在一个准备好的Web Worker应用程序中，组件将不会在主UI线程中运行，这不允许我们直接操作DOM。在这种情况下，我们需要使用Angular提供的更高层次的抽象API来建立数据绑定或操作元素属性。
- en: Bootstrapping an application running in a web worker
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web Worker中引导应用程序
- en: Let's make the to-do application that we developed in [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml),
    *Getting Started with Angular Components and Directives*, work in a web worker.
    You can find the example that we'll explore at `ch9/todo_webworkers/`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们在[第5章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)，*入门Angular组件和指令*中开发的待办事项应用程序在Web
    Worker中运行。您可以在`ch9/todo_webworkers/`找到我们将要探索的示例。
- en: Note that the web worker module is not finalized yet, so its API may change
    in future versions of Angular, or even be deprecated. The conceptual idea and
    the architecture are mature enough, so most likely there will not be any fundamental
    differences.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Web Worker模块尚未最终确定，因此其API可能在Angular的未来版本中发生变化，甚至可能被弃用。概念思想和架构已经足够成熟，所以很可能不会有任何根本性的差异。
- en: First of all, let's discuss the changes that we will need to make. Take a look
    at `ch5/inputs-outputs/app.ts`. Note that inside `app.ts`, we include the `platformBrowserDynamic` function
    from the `@angular/platform-browser-dynamic` module. This is the first thing we
    need to modify. The bootstrap process of an application running in a web worker
    is different.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论我们需要做出的更改。查看`ch5/inputs-outputs/app.ts`。注意在`app.ts`内部，我们包含了来自`@angular/platform-browser-dynamic`模块的`platformBrowserDynamic`函数。这是我们首先需要修改的地方。在Web
    Worker中运行的应用程序的引导过程是不同的。
- en: 'Before refactoring our code, let''s take a look at a diagram that illustrates
    the bootstrap process of a typical Angular application running in web workers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构我们的代码之前，让我们看一下一个图解，它展示了在Web Worker中运行的典型Angular应用程序的引导过程：
- en: '![](img/4518011a-9a73-4dce-a726-e1f03ca94b19.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4518011a-9a73-4dce-a726-e1f03ca94b19.png)'
- en: Figure 1
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: 'This diagram has two parts: **UI** and **web worker**. **UI** shows the actions
    performed during initialization in the main UI thread; the **web worker** part
    of the diagram shows how the application is bootstrapped in the background thread.
    Now, let''s explain the bootstrap process step by step.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此图分为两部分：**UI**和**web worker**。**UI**显示了在主UI线程中初始化期间执行的操作；图中的**web worker**部分显示了应用程序如何在后台线程中启动。现在，让我们一步一步地解释启动过程。
- en: 'First, the user opens the `index.html` page, which triggers the download of
    the following two files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户打开`index.html`页面，这将触发以下两个文件的下载：
- en: The UI bundle of Angular used for applications running in a web worker
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在Web Worker中运行的应用程序的Angular UI包
- en: The `system.js` bundle (we talked about the global object `System` in [Chapter 4](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml),
    *TypeScript Crash Course*. We can think of the `system.js` bundle as a polyfill
    for the module loader.)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.js`包（我们在[第4章](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml)，*TypeScript入门课程*中讨论了全局对象`System`。我们可以将`system.js`包视为模块加载器的polyfill。）'
- en: Using `system.js`, we download the script used for the initialization of the
    part of the application running in the main UI thread (`bootstrap.js`). This script
    starts `loader.js` in a web worker. This is the first script that runs in a background
    thread. Once the worker is started, `loader.js` will download `system.js` and
    the bundle of Angular, which is meant to be run in the background thread. The
    first request will usually hit the cache because `system.js` is already requested
    by the main thread. Using the module loader, we download the script that is responsible
    for bootstrapping the background app, `background_bootstrap.js`, which will finally
    start the functionality of our application in a web worker.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`system.js`，我们下载了用于在主UI线程中运行的应用程序部分初始化的脚本（`bootstrap.js`）。此脚本在Web Worker中启动`loader.js`。这是在后台线程中运行的第一个脚本。一旦启动了工作者，`loader.js`将下载`system.js`和Angular的包，这些包旨在在后台线程中运行。第一次请求通常会命中缓存，因为`system.js`已经被主线程请求。使用模块加载器，我们下载了负责启动后台应用程序的脚本，即`background_bootstrap.js`，它最终将在Web
    Worker中启动我们应用程序的功能。
- en: From now on, the entire application that we built will be run in a web worker
    and will exchange messages with the main UI thread to respond to user events and
    render instructions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们构建的整个应用程序将在Web Worker中运行，并与主UI线程交换消息以响应用户事件和渲染指令。
- en: Now that we are aware of the basic flow of events during initialization when
    using workers, let's refactor our to-do application to take advantage of them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用工作者时初始化期间的基本事件流，让我们重构我们的待办事项应用程序以利用它们。
- en: Migrating an application to web workers
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序迁移到Web Workers
- en: Let's show how we can make an application compatible with web workers. This
    way, we can reduce the frame drop in computationally intensive apps, since we'll free
    the main UI thread and let it be responsible only for rendering.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使应用程序与Web Workers兼容。这样，我们可以在计算密集型应用程序中减少帧率下降，因为我们将释放主UI线程，让它只负责渲染。
- en: 'Inside `index.html`, we will need to add the following scripts:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`内部，我们需要添加以下脚本：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding snippet, we've included references to `system.js`, `zone.js`,
    and `reflect-metadata`. `zone.js` is a polyfill for the zones that Angular exclusively
    uses, which we mentioned earlier in the book. Also, `reflect-metadata` contains
    another polyfill for the Metadata Reflection API, which at the moment of writing
    is not yet available in browsers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们包含了`system.js`、`zone.js`和`reflect-metadata`的引用。`zone.js`是Angular独家使用的区域的polyfill，我们在本书中之前提到过。此外，`reflect-metadata`包含了对Metadata
    Reflection API的另一个polyfill，在撰写本文时，该API在浏览器中尚不可用。
- en: For the next step, we will explicitly import the `bootstrap.js` file, which
    contains the logic used to start the `loader.js` script in a web worker.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将显式导入`bootstrap.js`文件，该文件包含用于在Web Worker中启动`loader.js`脚本的逻辑。
- en: 'Let''s explore `bootstrap.ts`, which is the original TypeScript version of
    the transpiled `bootstrap.js` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`bootstrap.ts`，这是已转换的`bootstrap.js`文件的原始TypeScript版本：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we pass `'loader.js'` to the invocation of `bootstrapWorkerUi`. This way,
    Angular knows that `loader.js` will run in a background thread. The script is
    located in the application's root.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`'loader.js'`传递给`bootstrapWorkerUi`的调用。这样，Angular就知道`loader.js`将在后台线程中运行。该脚本位于应用程序的根目录。
- en: 'Now, we can move to the right-hand side of the diagram shown in the *Bootstrapping
    an application running in a web worker* section. The logic in `loader.ts` (the
    original TypeScript version of `loader.js`) is quite simple:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转向*在Web Worker中启动应用程序*部分中显示的图表的右侧。`loader.ts`（`loader.js`的原始TypeScript版本）中的逻辑非常简单：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As the first step, we import `SystemJS`, the `ReflectMetadata` polyfils, `zone.js`,
    and the configuration for `SystemJS`. As this script is already run in a web worker,
    we have the `importScripts` function, which allows us to load the listed files
    synchronously. As the last step, with `System`, we import the script that contains
    our application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们导入`SystemJS`、`ReflectMetadata` polyfills、`zone.js`以及`SystemJS`的配置。由于这个脚本已经在Web
    Worker中运行，我们有`importScripts`函数，它允许我们同步加载列出的文件。作为最后一步，使用`System`导入包含我们应用程序的脚本。
- en: 'Now, let''s explore how we bootstrap the application inside of the web worker:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何在Web Worker内部启动应用程序：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The process is quite similar to what we do when bootstrapping an Angular application
    running in the main UI thread. We import the `platformWorkerAppDynamic` function
    and invoke the `bootstrapModule` method of the result of its invocation. To `bootstrapModule`,
    we pass the root module of the application as an argument.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与我们启动在主UI线程中运行的Angular应用程序时所做的非常相似。我们导入`platformWorkerAppDynamic`函数，并调用其调用的结果中的`bootstrapModule`方法。我们将应用程序的根模块作为参数传递给`bootstrapModule`。
- en: Making an application compatible with web workers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使应用程序与Web Worker兼容
- en: As we said, the code that runs in the context of web workers does not have access
    to the DOM. Let's see what changes we need to make in order to address this limitation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，在Web Worker上下文中运行的代码无法访问DOM。让我们看看我们需要做出哪些更改来解决这个问题。
- en: 'This is the original implementation of the `InputBox` component:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`InputBox`组件的原始实现：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that, inside the template, we reference the input element with the `todoInput` identifier and
    use the reference within the expression set as the handler of the click event.
    This code will not be able to run in a web worker, since we directly access a
    DOM element inside the template. In order to take care of this, we will need to
    refactor the snippet, so it uses Angular data binding instead of directly touching
    any element. We can either use Angular inputs when a single direction binding
    makes sense or `NgModel` to achieve two-way data binding, which is a bit more
    computationally intensive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在模板内部，我们使用`todoInput`标识符引用输入元素，并在表达式集中使用该引用作为点击事件的处理器。这段代码无法在Web Worker中运行，因为我们直接在模板内部访问DOM元素。为了解决这个问题，我们需要重构代码片段，使其使用Angular数据绑定而不是直接触摸任何元素。我们可以使用Angular输入，当单方向绑定有意义时，或者使用`NgModel`来实现双向数据绑定，这会稍微消耗更多的计算资源。
- en: 'Let''s use `NgModel`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`NgModel`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this version of the `InputBox` component, we create a two-way data binding
    between the input element and the `input` property of the `InputBox` component.
    Once the user clicks on the button, the `emitText` method will be invoked, which
    will trigger a new event emitted by `inputText`, which is an instance of `EventEmitter`.
    In order to reset the value of the input element, we take advantage of the two-way
    data binding mechanism of Angular and set the value of the `input` property to
    the empty string; this will automatically update the UI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`InputBox`组件中，我们在输入元素和`InputBox`组件的`input`属性之间创建了一个双向数据绑定。一旦用户点击按钮，`emitText`方法将被调用，这将触发由`inputText`（`EventEmitter`的一个实例）发出的新事件。为了重置输入元素的值，我们利用Angular的双向数据绑定机制，将`input`属性的值设置为空字符串；这将自动更新UI。
- en: Moving the entire logic from the templates of the components to their controllers
    brings a lot of benefits, such as improved testability, maintainability, code
    reuse, and clarity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个逻辑从组件的模板移动到它们的控制器中带来了很多好处，例如提高了可测试性、可维护性、代码重用和清晰度。
- en: The preceding code is compatible with the web worker environment, as the `NgModel`
    directive is based on an abstraction that does not manipulate the DOM directly. Instead,
    it delegates this responsibility to another abstraction called `Renderer`, whose
    web worker implementation exchanges messages asynchronously with the main UI thread.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与Web Worker环境兼容，因为`NgModel`指令基于一个不直接操作DOM的抽象。相反，它将这个责任委托给另一个名为`Renderer`的抽象，其Web
    Worker实现通过与主UI线程异步交换消息来处理。
- en: 'To recap, we can say that, while running applications in the context of a web
    worker, we need to keep the following two things in mind:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们可以这样说，在 web worker 的上下文中运行应用程序时，我们需要记住以下两点：
- en: We need to use a different bootstrap process
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用不同的引导过程
- en: We should not access the DOM directly
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该直接访问 DOM
- en: 'Typical scenarios that violate the second point are the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 违反第二点的典型场景如下：
- en: Changing the DOM of the page by selecting an element and manipulating it directly
    with the browser's native APIs or with a third-party library
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过选择一个元素并直接使用浏览器的原生 API 或第三方库来操作它，改变页面的 DOM
- en: Accessing native elements injected using `ElementRef`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ElementRef` 注入的本地元素进行访问
- en: Creating a reference to an element in the template and passing it as an argument
    to methods
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中创建一个元素的引用并将其作为参数传递给方法
- en: Directly manipulating an element referenced within the template
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接操作模板中引用的元素
- en: In all these scenarios, we would need to use the higher-level APIs provided
    by Angular. If we build our applications according to this practice, we will benefit
    not only from being able to run them in web workers, but also from increasing
    the code reuse in case we want to use them across different platforms.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些场景中，我们都需要使用 Angular 提供的高级 API。如果我们根据这种做法构建我们的应用程序，我们不仅能从中受益于能够在 web workers
    中运行它们，还能在想要在不同平台上使用它们时，增加代码的重用性。
- en: Keeping this in mind and following best practices will also allow us to take
    advantage of server-side rendering.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点并遵循最佳实践也将使我们能够利用服务器端渲染。
- en: Initial load of a single-page application
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序的初始加载
- en: In this section, we will explore what the concept of server-side rendering is,
    why we need it in our applications, and how we can use it with Angular.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨服务器端渲染的概念，为什么我们需要在我们的应用程序中使用它，以及我们如何使用 Angular 来实现它。
- en: 'For our purpose, we''ll explain the typical flow of events when a user opens
    a single-page application implemented in Angular. First, we''ll trace the events
    with the server-side rendering disabled, and after that, we''ll see how we can
    benefit from this feature by enabling it. Our example will be illustrated in the
    context of HTTP 1.1:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将解释当用户打开一个使用 Angular 实现的单页应用程序时的典型事件流程。首先，我们将跟踪服务器端渲染禁用时的事件，然后我们将看到如何通过启用此功能来从中受益。我们的示例将在
    HTTP 1.1 的上下文中进行说明：
- en: '![](img/e4db1d7c-244f-4e85-af97-561018757759.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4db1d7c-244f-4e85-af97-561018757759.png)'
- en: Figure 2
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2
- en: '*Figure 2* shows the first request by the browser and the response of the corresponding
    server when loading a typical SPA. The result that the client will see initially
    is the content of the HTML page without any rendered components.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2* 展示了浏览器在加载典型 SPA 时的第一次请求以及相应服务器的响应。客户端最初将看到的是 HTML 页面的内容，没有任何渲染的组件。'
- en: Let's suppose that we deploy the to-do application we built in [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml),
    *Getting Started with Angular Components and Directives*, to a web server that
    has the `example.com` domain associated with it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将第 5 章[《使用 Angular 组件和指令入门》](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)中构建的待办事项应用程序部署到一个与
    `example.com` 域关联的 Web 服务器上。
- en: 'Once the user navigates to `https://example.com/`, the browser will initiate
    a new HTTP GET request, fetching the root resource (`/`). When the server receives
    the request, it will respond with an HTML file that, in our case, will look something
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户导航到 `https://example.com/`，浏览器将发起一个新的 HTTP GET 请求，获取根资源（`/`）。当服务器收到请求时，它将响应一个
    HTML 文件，在我们的例子中，它看起来可能像这样：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The browser will receive this content as the body of the response. When the
    markup is rendered onto the screen, all that the user will see is the Loading...
    label.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将把此内容作为响应的主体。当标记渲染到屏幕上时，用户将看到的只是 Loading... 标签。
- en: In the next step, the browser will find all the references in the HTML file's
    external resources, such as styles and scripts, and start to download them. In
    our case, some of them are `bootstrap.css`, `es6-shim.min.js`, `Reflect.js`, `system.src.js`,
    and `angular-polyfills.js`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，浏览器将找到 HTML 文件中所有外部资源的引用，例如样式和脚本，并开始下载它们。在我们的例子中，其中一些是 `bootstrap.css`、`es6-shim.min.js`、`Reflect.js`、`system.src.js`
    和 `angular-polyfills.js`。
- en: Once all the referenced resources are available, there still won't be any significant
    visual progress for the user (except if the styles from the downloaded CSS file
    are applied to the page). This won't change until the JavaScript virtual machine
    processes all the referenced scripts related to the application's implementation.
    At this point, Angular will know which component needs to be rendered based on
    the current URL and configuration.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有引用的资源都可用，用户仍然不会看到任何显著的视觉进展（除非下载的CSS文件中的样式应用到页面上）。这不会改变，直到JavaScript虚拟机处理完与应用程序实现相关的所有引用脚本。到这时，Angular将知道根据当前URL和配置需要渲染哪个组件。
- en: If the component associated with the page is defined in a separate file outside
    of our main application bundle, the framework will need to download it together
    with its entire dependency graph.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与页面关联的组件定义在我们的主应用程序包之外的其他文件中，框架将需要下载它以及它的整个依赖图。
- en: If we're using JIT compilation, in case the template and the styles of the component
    are externalized, Angular will need to download them as well before it is able
    to render the requested page. Right after this, the framework will be able to
    compile the template associated with the target component and render the page.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用JIT编译，在组件的模板和样式外部化时，Angular需要在能够渲染请求的页面之前下载它们。在这之后，框架将能够编译与目标组件相关的模板并渲染页面。
- en: 'In this scenario, these are the two main pitfalls:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，有两个主要的陷阱：
- en: In case of large applications and/or slow internet connection, the user experience
    will be poor
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型应用程序和/或慢速互联网连接的情况下，用户体验将会很差
- en: Search engines are not that good at indexing dynamic content generated by JavaScript;
    this means that the SEO of our SPA will suffer
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索引擎在索引由JavaScript生成的动态内容方面并不出色；这意味着我们的SPA的SEO将会受到影响
- en: In the past, we solved the SEO issue in the applications built with AngularJS
    with different workarounds, such as using a headless browser for rendering the
    requested page, caching it onto the disk, and later providing it to search engines.
    However, there's a more elegant solution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们使用AngularJS构建的应用程序中，通过不同的解决方案解决了SEO问题，例如使用无头浏览器渲染请求的页面，将其缓存到磁盘上，然后提供给搜索引擎。然而，有一个更优雅的解决方案。
- en: Initial load of a single-page application with server-side rendering
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器端渲染的单页应用程序的初始加载
- en: A couple of years ago, libraries such as *Rendr*, *Derby*, and *Meteor* introduced
    the concept of **isomorphic** JavaScript applications, which were later renamed **universal**.
    In essence, universal applications could be run both on the client and on the
    server. Such portability is only possible in the case of low coupling between
    the SPA and the browser's APIs. Great benefits of this paradigm are code reuse
    and being able to render the application on the server before sending it to the
    client.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，像*Rendr*、*Derby*和*Meteor*这样的库引入了**同构**JavaScript应用程序的概念，后来被更名为**通用**。本质上，通用应用程序可以在客户端和服务器上运行。这种可移植性只有在SPA和浏览器API之间耦合度低的情况下才可能实现。这种范例的巨大好处是代码重用，能够在发送到客户端之前在服务器上渲染应用程序。
- en: Universal applications are not framework specific; we can take advantage of
    them in any framework that can be run outside of the environment of the browser.
    Conceptually, the practice of server-side rendering is very similar across platforms
    and libraries; only its implementation details may differ. For instance, the Angular
    Universal module, which implements server-side rendering, supports node.js as
    well as ASP.NET.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通用应用程序不是框架特定的；我们可以在任何可以在浏览器环境之外运行的框架中利用它们。从概念上讲，服务器端渲染的实践在各个平台和库之间非常相似；只有其实现细节可能不同。例如，实现服务器端渲染的Angular
    Universal模块支持node.js以及ASP.NET。
- en: '![](img/21b7cd39-9982-4f5e-bcb2-1db45acff684.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b7cd39-9982-4f5e-bcb2-1db45acff684.png)'
- en: Figure 3
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: '*Figure 3* shows the response by the server to the initial browser GET request.
    This time, in contrast to the typical scenario of loading a SPA, the browser will
    receive the HTML of the rendered page.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3* 显示了服务器对初始浏览器GET请求的响应。这次，与典型的SPA加载场景相反，浏览器将接收到渲染页面的HTML。'
- en: Let's trace the flow of the events in the same application with the server-side
    rendering feature enabled. In this case, once the server receives the HTTP GET
    request by the browser, it will run the SPA on the server in the environment of
    node.js. All the DOM calls will be redirected to a server-side DOM implementation
    and executed in the context of the used platform. Similarly, all the AJAX calls
    with the Angular HTTP module will be handled by the server-side implementation
    of the module. This way, the application will not make any difference, whether
    it is running in the context of the browser or the server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟踪在服务器端渲染功能启用的情况下，同一应用程序中事件流的流程。在这种情况下，一旦服务器接收到浏览器发出的HTTP GET请求，它将在node.js环境中运行SPA。所有的DOM调用都将被重定向到服务器端DOM实现，并在使用平台的上下文中执行。同样，所有使用Angular
    HTTP模块的AJAX调用都将由模块的服务器端实现处理。这样，应用程序在浏览器或服务器上下文中运行时不会有任何区别。
- en: Once the rendered version of the SPA is available, it can be serialized to HTML
    and sent to the browser. This time, during the application's initialization, instead
    of the Loading... label, the user will see the page they requested right away.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦SPA的渲染版本可用，它可以序列化为HTML并发送到浏览器。这次，在应用程序初始化期间，而不是显示“加载中...”标签，用户将立即看到他们请求的页面。
- en: Note that, at this point, the client will have the rendered version of the application,
    but all the referenced external resources, such as scripts and styles, still need
    to be available. This means that, initially, none of the CSS styles declared in
    the external files will be applied and the application will not be responsive
    to any user-related interactions, such as the mouse and keyboard events.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此时，客户端将拥有应用程序的渲染版本，但所有引用的外部资源，如脚本和样式，仍然需要可用。这意味着，最初，外部文件中声明的所有CSS样式都不会应用，并且应用程序不会对任何与用户相关的交互做出响应，例如鼠标和键盘事件。
- en: In case the scripts are inlined on the server-side rendered page, the application
    will be responsive to user events. However, inlining big chunks of JavaScript
    is generally considered a bad practice, as it will increase the page's size dramatically
    and prevent the scripts from caching, which will impact the network performance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本在服务器端渲染的页面上内联，应用程序将响应用户事件。然而，通常认为在内联大量JavaScript是一种不良做法，因为它会极大地增加页面大小，并阻止脚本缓存，这会影响网络性能。
- en: When the JavaScript virtual machine processes the JavaScript associated with
    the page, our SPA will be ready to use.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript虚拟机处理与页面关联的JavaScript时，我们的SPA将准备好使用。
- en: Server-side rendering with Angular
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular进行服务器端渲染
- en: During the first half of 2015, members of the Angular community announced that
    they had started the development of the module, **Universal**. Universal is a
    library that allows us to build universal (also called isomorphic) JavaScript
    applications with Angular; in other words, it provides server-side rendering support.
    Later, the project was moved to Angular core's repository, and currently, it's
    maintained by Google.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年上半年，Angular社区成员宣布他们已经开始开发模块，**Universal**。Universal是一个库，允许我们使用Angular构建通用（也称为同构）JavaScript应用程序；换句话说，它提供了服务器端渲染支持。后来，该项目被转移到Angular核心仓库，目前由Google维护。
- en: Applications using Angular Universal and rendered on the server will not be
    responsive to user interaction until all the JavaScript belonging to the requested
    page has been processed. This is a drawback that we already mentioned, which is
    valid for all server-side rendered applications. To handle this problem, Angular
    Universal introduced **preboot.js**, which is a lightweight library that will
    be inlined on the page rendered by the server and be available in the initial
    response.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular Universal并服务器端渲染的应用程序，在请求页面的所有JavaScript处理完毕之前，不会响应用户交互。这是我们之前提到的一个缺点，适用于所有服务器端渲染的应用程序。为了处理这个问题，Angular
    Universal引入了**preboot.js**，这是一个轻量级的库，它将被内联在服务器渲染的页面上，并在初始响应中可用。
- en: 'Preboot.js has several strategies for the management of the received client
    events before the application is completely initialized; they are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Preboot.js在应用程序完全初始化之前对接收到的客户端事件有几种管理策略；如下所示：
- en: Recording and playing back events
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和回放事件
- en: Responding immediately to events
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即响应用件
- en: Maintaining focus when a page is re-rendered
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面重新渲染时保持焦点
- en: Buffering client-side re-rendering for smoother transition
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存客户端重新渲染以实现更平滑的过渡
- en: Freezing a page until the bootstrap is complete
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引导完成前冻结页面
- en: At the time of writing this book, the Universal module was still being actively
    developed. You can give it a try using the Angular Universal Starter at [https://github.com/angular/universal-starter](https://github.com/angular/universal-starter).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Universal 模块仍在积极开发中。您可以使用 Angular Universal Starter 在 [https://github.com/angular/universal-starter](https://github.com/angular/universal-starter)
    尝试它。
- en: Enhancing our development experience
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升我们的开发体验
- en: Our experience as developers can be enhanced in terms of productivity or by
    making our development experience more enjoyable. This can be achieved with all
    the tools, IDEs, text editors, and more, which we use on a daily basis. In this
    section, we'll take a brief look at popular IDEs and text editors that take advantage
    of the statically analyzable syntax that Angular provides. We'll also mention
    the language service that the Angular team developed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为开发者的经验可以通过提高生产力或使我们的开发体验更加愉快来提升。这可以通过我们每天使用的所有工具、IDE、文本编辑器等实现。在本节中，我们将简要介绍一些流行的
    IDE 和文本编辑器，它们利用了 Angular 提供的可静态分析的语法。我们还将提到 Angular 团队开发的语言服务。
- en: Text editors and IDEs
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本编辑器和 IDE
- en: 'As we have already said at the beginning of the book, the core team put a lot
    of effort into enhancing the tooling support in Angular. First of all, the framework
    is built with TypeScript, which naturally allows us to use static typing during
    our development process. Some of the text editors and IDEs that have great TypeScript
    support are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书开头所说，核心团队在 Angular 中投入了大量精力来增强工具支持。首先，该框架是用 TypeScript 编写的，这自然允许我们在开发过程中使用静态类型。以下是一些具有出色
    TypeScript 支持的文本编辑器和 IDE：
- en: '**IntelliJ Idea**: A general purpose IDE by JetBrains'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ IDEA**：JetBrains 开发的一款通用 IDE'
- en: '**WebStorm**: An IDE specialized for web development by JetBrains'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebStorm**：JetBrains 开发的一款专注于 Web 开发的 IDE'
- en: '**VSCode**: A cross platform text editor written in TypeScript and developed
    by Microsoft'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**：由微软开发的一款跨平台文本编辑器，使用 TypeScript 编写'
- en: '**Sublime Text**: A cross platform text editor'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sublime Text**：一款跨平台文本编辑器'
- en: '**Atom**: A cross platform text editor written in JavaScript, based on Electron'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Atom**：一款基于 Electron 的跨平台文本编辑器，使用 JavaScript 编写'
- en: Although not all the mentioned IDEs and text editors have Angular-specific features at
    the time of writing this book, the framework comes with tooling in mind. It allows
    the development of software that performs advanced static code analysis on the
    application's code, which can provide sophisticated refactoring and productivity
    features. A tool which empowers this feature of Angular and provides a generic
    interface to IDE and text editor developers is the language service.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在撰写本书时，并非所有提到的 IDE 和文本编辑器都具有 Angular 特定功能，但该框架在设计时就考虑了工具支持。它允许对应用程序的代码进行高级静态代码分析，这可以提供复杂的重构和生产率功能。一个能够启用
    Angular 这一功能并为 IDE 和文本编辑器开发者提供通用接口的工具是语言服务。
- en: Angular language service
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 语言服务
- en: Taking advantage of the analyzable nature of Angular, Google developed a **language
    service** for the framework. We can think of this service as a server, which indexes
    our project and provides autocompletion suggestions, type checking in templates,
    and other features, based on requests from a client. This client can be a plugin
    for our text editor or IDE.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Angular 的可分析特性，Google 为该框架开发了一个 **语言服务**。我们可以将此服务视为一个服务器，它索引我们的项目，并根据客户端请求提供自动完成建议、模板中的类型检查和其他功能。这个客户端可以是我们的文本编辑器或
    IDE 的插件。
- en: The language service can keep track of the context of the given component that
    is in focus in the text editor and provide context-specific suggestions. For instance,
    it can provide autocompletion suggestions for directive selectors based on the
    available set of directives at the given part of the component tree.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务可以跟踪文本编辑器中当前聚焦的组件的上下文，并提供上下文相关的建议。例如，它可以基于组件树中给定部分的可用指令集提供自动完成建议。
- en: The best thing about the language service is that it is not coupled to any specific
    text editor or IDE, which means that, with a thin plugin, it can be reused in
    any development environment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 语言服务的最好之处在于它不依赖于任何特定的文本编辑器或 IDE，这意味着，通过一个轻量级的插件，它可以在任何开发环境中重用。
- en: Bootstrapping a project with angular-cli
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 angular-cli 引导项目
- en: During AngularConnect 2015, Brad Green and Igor Minar, part of the Angular team,
    announced `angular-cli`—a **CLI** (**Command-Line Interface**) tool to ease starting
    and managing Angular applications. For those who have used Ruby on Rails, the
    idea behind the CLI tool might be familiar. The basic purpose of the tool is to
    allow the quick setup of new projects and scaffolding of new directives, components,
    pipes, and services.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularConnect 2015期间，Angular团队的部分成员Brad Green和Igor Minar宣布了`angular-cli`——一个**CLI**（**命令行界面**）工具，用于简化Angular应用程序的启动和管理。对于那些使用过Ruby
    on Rails的人来说，CLI工具背后的理念可能很熟悉。该工具的基本目的是允许快速设置新项目和构建新的指令、组件、管道和服务。
- en: At the time of writing, the tool is based on webpack. Let's demonstrate its
    basic usage.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，该工具基于webpack。让我们展示其基本用法。
- en: Using angular-cli
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用angular-cli
- en: 'In order to install the CLI tool, run the following command in your terminal:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装CLI工具，请在您的终端中运行以下命令：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Right after this, the `ng` command will appear as global executable in your
    system. For creating a new Angular project, use the following commands:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，`ng`命令将出现在您的系统中的全局可执行文件中。要创建一个新的Angular项目，请使用以下命令：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding commands will perform the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将执行以下操作：
- en: Create a new Angular project and install all of its `npm` dependencies
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Angular项目并安装其所有的`npm`依赖项
- en: Enter the project's directory
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入项目目录
- en: Start a development web server which will observe the project's directory for
    changes and send the refresh command to the browser when we change any of the
    files there
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个开发Web服务器，该服务器将监视项目目录中的更改，并在我们更改其中的任何文件时向浏览器发送刷新命令
- en: For further reading, take a look at the project's repository, located at [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进一步阅读，请查看位于[https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)的项目仓库。
- en: 'Angular CLI provides a highly encapsulated build, so by default, it doesn''t
    expose any of the tooling used underneath. For more advanced cases, when we want
    to introduce custom logic in the build, we can eject the CLI project using this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI提供了一个高度封装的构建，因此默认情况下，它不会暴露任何底层的工具。对于更高级的情况，当我们想在构建中引入自定义逻辑时，我们可以使用以下方法从CLI项目中退出：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command will export the internal webpack configuration and allow us to
    update it manually.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将导出内部webpack配置，并允许我们手动更新它。
- en: Using Angular CLI for new projects is a good idea unless there are restrictions
    set by the organization or we have different preferences. Although the build that
    Angular CLI provides can be considered as a black box which is not trivial to
    modify, often changes are not necessary since it covers most of the use cases
    for small and medium projects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除非组织设置了限制或我们有不同的偏好，否则使用Angular CLI为新项目是一个好主意。虽然Angular CLI提供的构建可以被视为一个黑盒，修改起来并不简单，但通常不需要修改，因为它涵盖了小型和中型项目的大部分用例。
- en: Angular quick starters
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular快速入门
- en: If you prefer a less encapsulated build, there are a lot of starter projects
    developed by the community that can provide a good starting point for your next
    Angular project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢不那么封装的构建，社区已经开发了许多入门项目，可以为您的下一个Angular项目提供一个良好的起点。
- en: Angular seed
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular种子
- en: If you enjoy static typing, you can give the **Angular Seed** project a try.
    It is hosted on GitHub at [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢静态类型，您可以尝试**Angular Seed**项目。该项目托管在GitHub上，网址为[https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)。
- en: 'Angular Seed provides the following key features:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Seed提供了以下关键特性：
- en: Easy for extend, modular, and statically typed build systems
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展、模块化和静态类型化的构建系统
- en: AOT compilation support
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOT编译支持
- en: Support for multiple Angular applications with a shared code base in a single
    instance of the seed
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个种子实例中支持多个Angular应用程序，具有共享的代码库
- en: Production and development builds
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境和开发构建
- en: Sample unit tests with Jasmine and Karma
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine和Karma的示例单元测试
- en: End-to-end tests with Protractor
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Protractor进行端到端测试
- en: A development server with LiveReload
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有LiveReload的开发服务器
- en: Uses codelyzer for static code analysis, which verifies that the project follows
    practices from the Angular style guide
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用codelyzer进行静态代码分析，这验证了项目遵循Angular风格指南中的实践
- en: Follows best practices for the applications and files organization
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循应用程序和文件组织的最佳实践
- en: Provides full Docker support for both development and production environment
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为开发和生产环境提供完整的Docker支持
- en: The code distributed with the book is based on this seed project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍中分发的代码基于此种子项目。
- en: 'For Angular Seed, you will need to have `node.js`, `npm`, and `git` installed
    on your computer. In order to get the starter project, run the following list
    of commands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Angular Seed，您需要在您的计算机上安装`node.js`、`npm`和`git`。为了获取启动器项目，请运行以下命令列表：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the execution of the commands is completed, your browser will automatically
    open the home page of the seed. Upon the change of any of the files in your project,
    the application will be automatically rebuilt, and your browser will be refreshed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令执行完成，您的浏览器将自动打开种子项目的首页。当您的项目中的任何文件发生变化时，应用程序将自动重新构建，并且您的浏览器将被刷新。
- en: By default, the production build produces a single bundle that contains a minified
    version of the application and all the referenced libraries. Angular Seed also
    supports AOT compilation and extensible build systems.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生产构建生成一个包含应用程序和所有引用库的压缩版本的单一包。Angular Seed还支持AOT编译和可扩展的构建系统。
- en: Angular webpack starter
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular webpack启动器
- en: If you prefer webpack, you can use *angular-starter*. It is a starter project
    developed by *AngularClass* and hosted on GitHub. You can find it at [https://github.com/AngularClass/angular-starter](https://github.com/AngularClass/angular-starter).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢webpack，可以使用*angular-starter*。这是一个由*AngularClass*开发的启动器项目，托管在GitHub上。您可以在[https://github.com/AngularClass/angular-starter](https://github.com/AngularClass/angular-starter)找到它。
- en: 'This starter provides the following features:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此启动器提供了以下功能：
- en: Best practices in file and application organization for Angular
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular在文件和应用程序组织方面的最佳实践
- en: Ready-to-go build system using webpack for working with TypeScript
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack的现成构建系统来处理TypeScript
- en: Testing Angular code with Jasmine and Karma
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine和Karma测试Angular代码
- en: Coverage with Istanbul and Karma
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istanbul和Karma进行覆盖率测试
- en: End-to-end Angular code using Protractor
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Protractor进行端到端Angular代码
- en: 'In order to give it a try, you will need to have `node.js`, `npm`, and `git`
    installed and run the following commands:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试它，您需要在您的计算机上安装`node.js`、`npm`和`git`，并运行以下命令：
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ahead-of-time compilation in Angular
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的预编译
- en: In this section, without going into deep technical details, we'll briefly explain
    what AOT compilation is in the context of Angular and what implication it may
    have on our projects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要解释在Angular的上下文中AOT编译是什么，以及它可能对我们的项目产生什么影响。
- en: The key focus in Angular is its extremely fast change detection mechanism. After
    exploring different options for detecting changes in the view model, the Angular
    team discovered that the change detection mechanism used in AngularJS can be improved
    dramatically using **code generation**. It turned out that it is possible to generate
    well-optimized code for the JavaScript virtual machine, which performs change
    detection and efficient rendering. After a lot of benchmarks, Google found out
    that this strategy is much more performant compared to the traditional (also known
    as dynamic) change detection mechanism.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的关键焦点是其极快的变更检测机制。在探索了在视图模型中检测变更的不同选项之后，Angular团队发现，AngularJS中使用的变更检测机制可以通过**代码生成**进行显著改进。结果是，可以为JavaScript虚拟机生成优化的代码，该虚拟机执行变更检测和高效渲染。经过大量的基准测试，谷歌发现这种策略比传统的（也称为动态的）变更检测机制性能要好得多。
- en: How code generation works
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码生成是如何工作的
- en: The Angular code generator is known as the Angular compiler. It compiles the
    templates of the Angular components to JavaScript or TypeScript (depending on
    the compilation target). When we compile the templates to TypeScript, we allow
    the TypeScript compiler to perform type checking, not only within the imperative
    logic of our components, directives, services, and pipes, but also in the components'
    templates! Performing type checking in the templates helps us find even more potential
    issues in our application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Angular代码生成器被称为Angular编译器。它将Angular组件的模板编译成JavaScript或TypeScript（取决于编译目标）。当我们把模板编译成TypeScript时，我们允许TypeScript编译器执行类型检查，不仅在我们的组件、指令、服务和管道的命令式逻辑中，而且在组件的模板中！在模板中执行类型检查有助于我们在应用程序中找到更多潜在的问题。
- en: On top of code generation for templates, the Angular compiler also generates
    code for the injectors in our application. This improves the performance of the
    dependency injection mechanism even further.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为模板生成代码之外，Angular编译器还为我们应用程序中的注入器生成代码。这进一步提高了依赖注入机制的效率。
- en: Based on the static analysis of the bindings in the templates, the generated
    code for the templates performs the most efficient change detection and most optimal
    update of the DOM tree, depending on the changed values. On top of that, the produced
    code takes advantage of the inline caching mechanism of JavaScript virtual machines,
    which brings an additional performance boost.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对模板中绑定进行的静态分析，生成的模板代码执行了最有效的变更检测和最优化更新DOM树的操作，这取决于变化值。除此之外，生成的代码还利用了JavaScript虚拟机的内联缓存机制，这带来了额外的性能提升。
- en: For further reading about inline caching, take a look at this article: *Explaining
    JavaScript VMs in JavaScript - Inline Caches*, located at [http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内联缓存的进一步阅读，请参阅这篇文章：*在JavaScript中解释JavaScript虚拟机 - 内联缓存*，位于[http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)。
- en: The code generation could be either performed at runtime, known as **just-in-time**
    (**JIT**) compilation or build time, known as AOT compilation. Since the JIT compilation
    involves the evaluation of code at runtime, it is recommended that you use AOT
    in environments with strict **Content Security Policy** (**CSP**), where `eval`
    is not available.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成可以是运行时执行，称为**即时**（**JIT**）编译，或者构建时执行，称为AOT编译。由于JIT编译涉及在运行时评估代码，因此建议你在具有严格**内容安全策略**（**CSP**）且`eval`不可用的环境中使用AOT。
- en: Introducing the concept of ahead-of-time compilation
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍**提前编译**的概念
- en: From AOT, we get a couple of improvements. First, if we compile our Angular
    application as part of the build process, we don't need to compile it at runtime.
    This means that we don't get the runtime performance hit that we get when using
    JIT. This way, AOT offers faster initial rendering of the application because
    Angular has to do less work during initialization.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从AOT中，我们获得了一些改进。首先，如果我们将Angular应用程序作为构建过程的一部分进行编译，我们就不需要在运行时编译它。这意味着我们不会遇到使用JIT时遇到的运行时性能下降。这样，AOT提供了更快的应用程序初始渲染，因为Angular在初始化期间需要做的工作更少。
- en: On top of this, since we don't have to perform compilation at runtime anymore, we
    can drop the entire `@angular/compiler` module out of the final application bundle
    and decrease the bundle size.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们不再需要在运行时执行编译，我们可以将整个`@angular/compiler`模块从最终的应用程序包中删除，从而减小包的大小。
- en: Finally, we can perform much more efficient dead code elimination in terms of
    **tree-shaking**. Tree-shaking means dropping unused exports, which is one of
    the great properties of the static nature of the ES2015 modules. When relaying
    on JIT compilation, we can reference different components by their selectors inside
    the templates. However, the templates are in a HTML-like format, which the modern
    minifiers (such as UglifyJS and Google Closure Compiler) don't understand. This
    means that they cannot eliminate all the unused exports (for instance, unused
    components), since they are not sure what exactly is used within the templates.
    Once at build time, the Angular compiler translates the templates to TypeScript
    or JavaScript; with static ES2015 imports, bundlers can apply traditional dead-code
    elimination techniques, and so reduce the bundle size even further!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过**树摇**进行更高效的无效代码消除。树摇意味着删除未使用的导出，这是ES2015模块静态性质的一个伟大特性。当我们依赖于JIT编译时，我们可以在模板内部通过选择器引用不同的组件。然而，模板是类似HTML的格式，现代的压缩器（如UglifyJS和Google
    Closure Compiler）并不理解。这意味着它们不能消除所有未使用的导出（例如，未使用的组件），因为它们不确定模板中确切使用了什么。一旦在构建时，Angular编译器将模板转换为TypeScript或JavaScript；使用静态ES2015导入，打包器可以应用传统的无效代码消除技术，从而进一步减小包的大小！
- en: If you're interested in further reading, you can take a look at the article
    *Ahead-of-Time Compilation in Angular* at [https://goo.gl/eXieJl](https://goo.gl/eXieJl).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对进一步阅读感兴趣，可以查看位于[https://goo.gl/eXieJl](https://goo.gl/eXieJl)的Angular的*提前编译*文章。
- en: Constraints of the ahead-of-time compilation
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提前编译的限制
- en: Keep in mind that the Angular compiler needs type metadata in order to perform
    the process of compilation. This means that you cannot perform AOT compilation
    if you're not using TypeScript.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Angular编译器需要类型元数据才能执行编译过程。这意味着如果你不使用TypeScript，你将无法执行AOT编译。
- en: AOT compilation is performed by collecting metadata during build time. This
    means that, in some cases, our code may work with JIT, but may not work in AOT
    in case we have dynamic constructs, which cannot be resolved at build time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: AOT编译是在构建时收集元数据来执行的。这意味着在某些情况下，我们的代码可能与JIT一起工作，但如果我们在构建时无法解析动态结构，则可能无法在AOT中工作。
- en: For further details about which syntax constructs may not work with AOT compilation,
    take a look at this repository at [https://goo.gl/F7cV1s](https://goo.gl/F7cV1s).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哪些语法结构可能不适用于AOT编译的更多详细信息，请查看以下存储库[https://goo.gl/F7cV1s](https://goo.gl/F7cV1s)。
- en: Finally, the generated code for the templates is not part of the components
    controllers themselves. This means that we cannot bind to nonpublic fields because,
    during compilation, TypeScript will throw an error.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模板生成的代码不是组件控制器本身的一部分。这意味着我们无法绑定到非公共字段，因为在编译过程中，TypeScript会抛出一个错误。
- en: How to use the ahead-of-time compilation of Angular
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用Angular的即时编译
- en: The Angular's AOT compilation is already supported in the most popular starters
    and the CLI.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的AOT编译已经在最受欢迎的入门项目中得到支持。
- en: 'At the time of writing, Angular CLI performs AOT compilation by default in
    the production build. To get the optimized production assets, run this command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Angular CLI 默认在生产构建中执行 AOT 编译。要获取优化的生产资源，请运行以下命令：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Angular Seed introduced AOT compilation when Angular 2.0.0-rc.5 was released.
    With the seed, you can take advantage of all the benefits that come with it by
    running the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular 2.0.0-rc.5发布时，Angular Seed引入了AOT编译。通过种子，您可以通过运行以下命令来利用它带来的所有好处：
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By executing the preceding commands, you'll get a well-optimized production
    build of your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行前面的命令，您将获得一个优化良好的生产构建。
- en: Since web tooling changes quite frequently, we didn't go into details of how
    Angular Seed or Angular CLI produce the production build. If you're interested
    in further reading on what is going on under the hood, you can take a look at
    an article at [https://goo.gl/kAiJUJ](https://goo.gl/kAiJUJ).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络工具频繁变化，我们没有深入探讨Angular Seed或Angular CLI如何生成生产构建。如果您对底层发生的事情感兴趣，可以查看以下文章[https://goo.gl/kAiJUJ](https://goo.gl/kAiJUJ)。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started our journey by introducing the reasons behind the rewrite of Angular,
    which was followed by a conceptual overview that gave us a general idea about
    the building blocks of the framework. In the next step, we went through [Chapter
    4](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml)*, TypeScript Crash* *course*, that
    prepared us for [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting
    Started with Angular Components and Directives*, where we went deep into Angular's
    directives, components, and change detection.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过介绍Angular重写的背后原因开始了我们的旅程，随后是一个概念概述，它让我们对框架的构建块有了大致的了解。在下一步中，我们学习了[第4章](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml)*TypeScript
    快速入门*课程，为[第5章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)*Angular 组件和指令入门*做好了准备，在那里我们深入探讨了Angular的指令、组件和变更检测。
- en: In [Chapter 6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml), *Dependency Injection
    in Angular*,we explained the dependency injection mechanism and saw how it's related
    to the component hierarchy. In the following chapters, we saw how we can develop
    forms and pipes and take advantage of Angular's router.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml)*Angular 中的依赖注入*中，我们解释了依赖注入机制，并看到了它与组件层次结构的关系。在接下来的章节中，我们看到了如何开发表单和管道，并利用Angular的路由器。
- en: By completing this final chapter, we have finished our journey into the framework.
    At the time of writing, the design decisions and the ideas behind Angular's core
    are solid and finalized. Although the framework is still brand new, in the past
    year, its ecosystem reached a level where we can develop production-ready, high-performance,
    and SEO-friendly applications, and on top of this, have a great development experience
    with static typing and IDE support.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，我们完成了对框架的探索之旅。在撰写本文时，Angular 核心的设计决策和理念已经稳固并最终确定。尽管框架仍然非常新，但在过去一年中，其生态系统已经达到我们可以开发生产就绪、高性能和SEO友好的应用程序的水平，并且在此基础上，我们还可以享受到静态类型和IDE支持的出色开发体验。
