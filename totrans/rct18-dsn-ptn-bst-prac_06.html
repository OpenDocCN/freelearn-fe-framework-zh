<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer031">
<h1 class="chapterNumber">6</h1>
<h1 class="chapterTitle" id="_idParaDest-97">Making Your Components Look Beautiful</h1>
<p class="normal">Our journey into React best practices and design patterns has now reached the point where we want to make our components look beautiful. To do that, we will go through all the reasons why regular CSS may not be the best approach for styling components, and we will check out various alternative solutions.</p>
<p class="normal">Starting with inline styles, then CSS modules, and <code class="inlineCode">styled-components</code>, this chapter will guide you through the magical world of CSS in JavaScript.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Common problems with regular CSS at scale</li>
<li class="bulletList">What it means to use inline styles in React and their downsides</li>
<li class="bulletList">How to set up a project from scratch using Webpack and CSS modules</li>
<li class="bulletList">Features of CSS modules and why they represent a great solution to avoid global CSS</li>
<li class="bulletList"><code class="inlineCode">styled-components</code>, a new library that offers a modern approach to styling React components</li>
</ul>
<h1 class="heading-1" id="_idParaDest-98">Technical requirements</h1>
<p class="normal">To complete this chapter, you will need the following:</p>
<ul>
<li class="bulletList">Node.js 19+</li>
<li class="bulletList">Visual Studio Code</li>
</ul>
<p class="normal">You can find the code for this chapter in the book’s GitHub repository: <a href="https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter06"><span class="url">https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter06</span></a>.<span class="url"> </span></p>
<h1 class="heading-1" id="_idParaDest-99">CSS in JavaScript</h1>
<p class="normal">In November 2014, Christopher Chedeau, also known as <em class="italic">vjeux</em>, gave a talk at the NationJS conference (<a href="https://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.xhtml"><span class="url">https://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.xhtml</span></a>) that sparked a revolution in the way React components are styled. As a contributor to React and an employee of Meta, Christopher outlined the many issues Facebook faced with CSS at scale. Understanding these issues is important because<a id="_idIndexMarker194"/> they are common in web development and will help us introduce concepts such as inline styles and locally scoped class names.</p>
<p class="normal">The following is a list of the issues with CSS, which are basically problems with CSS at scale:</p>
<ul>
<li class="bulletList">Global namespace</li>
<li class="bulletList">Dependencies</li>
<li class="bulletList">Dead code elimination</li>
<li class="bulletList">Minification</li>
<li class="bulletList">Sharing constants</li>
<li class="bulletList">Non-deterministic resolution</li>
<li class="bulletList">Isolation</li>
</ul>
<p class="normal">The first well-known problem of CSS is that all the selectors are global. No matter how organized our styles are by using namespaces or a procedure such as the <strong class="keyWord">Block</strong>, <strong class="keyWord">Element</strong>, <strong class="keyWord">Modifier </strong>(<strong class="keyWord">BEM</strong>) methodology, we<a id="_idIndexMarker195"/> are always polluting the global namespace, which we all know is wrong. It is not only wrong in principle, but it also leads to many errors in big code bases, and it makes maintainability very hard in the long term. Working with big teams, it is non-trivial to know whether a particular class or element has already been styled, and most of the time, we tend to add more classes instead of reusing existing ones.</p>
<p class="normal">The second problem with CSS regards the definition of the dependencies. It is very hard, in fact, to state clearly that a particular component depends on a specific CSS and that the CSS has to be loaded for the style to be applied. Since styles are global, any style from any file can be applied to any element, and losing control is very easy.</p>
<p class="normal">The third is that frontend developers tend to use pre-processors to be able to split their CSS into submodules, but in the end, a big, global CSS bundle is generated for the browser. </p>
<p class="normal">Since CSS code bases tend to become huge quickly, we lose control over them, and the third problem is to do with <strong class="keyWord">dead code elimination</strong>. It is not easy to quickly identify which styles belong to which component, and this makes deleting code incredibly hard. In fact, due to the cascading nature of CSS, removing a selector or a rule can result in an unintended result within the browser.</p>
<p class="normal">Another pain point of working with CSS concerns the minification of the selectors and the class names, both<a id="_idIndexMarker196"/> in the CSS and in the JavaScript application. It might seem an easy task, but it is not, especially when classes are applied on the fly or concatenated in the client; this is the fourth problem.</p>
<p class="normal">Not being able to minify and optimize class names is bad for performance, and it can make a huge difference to the size of the CSS. Another pretty common operation that is non-trivial with regular CSS is sharing constants between the styles and the client application. We often need to know the height of a header, for example, to recalculate the position of other elements that depend on it.</p>
<p class="normal">Usually, we read the value in the client using the JavaScript APIs, but the optimal solution would be to share constants and avoid doing expensive calculations at runtime. This represents the fifth problem that <code class="inlineCode">vjeux</code> and the other developers at Facebook tried to solve.</p>
<p class="normal">The sixth issue concerns the non-deterministic resolution of CSS. In fact, in CSS, the order matters, and if the CSS is loaded on demand, the order is not guaranteed, which leads to the wrong styles being applied to the elements.</p>
<p class="normal">Suppose, for example, that we want to optimize the way we request CSS, loading the CSS related to a particular page only when the users navigate to it. If the CSS related to this last page has some rules that also apply to the elements of different pages, the fact that it has been loaded last could affect the styling of the rest of the app. For example, if the user goes back to the previous page, they might see a page with a UI that is slightly different than the first time they visited it.</p>
<p class="normal">It is incredibly hard to control all the various combinations of styles, rules, and navigation paths, but again, being able to load the CSS when needed could have a critical impact on the performance of a web application.</p>
<p class="normal">Last but not least, the seventh problem of CSS, according to Christopher Chedeau, is related to isolation. In CSS, it is almost impossible to achieve proper isolation between files or <a id="_idIndexMarker197"/>components. Selectors are global, and they can easily be overwritten. It is tricky to predict the final style of an element just by knowing the class names applied to it because styles are not isolated, and other rules in other parts of the application can affect unrelated elements. This can be solved by using inline styles.</p>
<p class="normal">In the following section, we will look at what it means to use inline styles with React and the benefits and downsides of it.</p>
<h1 class="heading-1" id="_idParaDest-100">Understanding and implementing inline styles</h1>
<p class="normal">The official React <a id="_idIndexMarker198"/>documentation suggests developers use <strong class="keyWord">inline styles</strong> to style their React components. This seems odd because we all learned in past years that separating the concerns is important and we should not mix markup and CSS.</p>
<p class="normal">React tries to change the concept of separation of concerns by moving it from the separation of technologies to the separation of components. Separating markup, styling, and logic into different files when they are tightly coupled and where one cannot work without the other is just an illusion. Even if it helps keep the project structure cleaner, it does not give any real benefit.</p>
<p class="normal">In React, we compose components to create applications where components are a fundamental unit of our structure. We should be able to move components across the application, and they should provide the same result regarding both logic and UI, no matter where they get rendered.</p>
<p class="normal">This is one of the reasons why collocating the styles within our components and applying them using inline styles on the elements could make sense in React.</p>
<p class="normal">First, let’s look at an example of what it means to use the <code class="inlineCode">style</code> attribute of the nodes to apply the styling to our components in React. We are going to create a button with the text <code class="inlineCode">Click me!</code> and we are going to apply a color and background color to it:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> style = {
  <span class="hljs-attr">color</span>: <span class="hljs-string">'palevioletred'</span>,
  <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'papayawhip'</span>
}
  
<span class="hljs-keyword">const</span> <span class="hljs-title">Button</span> = () =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{style}</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">As you can see, it is pretty easy to style elements with inline styles in React. We just have to create an object where the attributes are the CSS rules, and the values are the values we would use in a regular CSS file.</p>
<p class="normal">The only differences are that the hyphenated CSS rules must be <code class="inlineCode">camelCased</code> to be JavaScript-compliant, and the values are strings, so they have to be wrapped in quote marks.</p>
<p class="normal">There are some exceptions<a id="_idIndexMarker199"/> regarding the vendor prefixes. For example, if we want to define a transition on <code class="inlineCode">webkit</code>, we should use the <code class="inlineCode">WebkitTransition</code> attribute, where the <code class="inlineCode">webkit</code> prefix begins with a capital letter. This rule applies to all the vendor prefixes, except for <code class="inlineCode">ms</code>, which is lowercase.</p>
<p class="normal">Other use cases are numbers – they can be written without quotes or units of measurement, and by default, they are treated as pixels.</p>
<p class="normal">The following rule applies a height of 100 pixels:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> style = {
  <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>
}
</code></pre>
<p class="normal">By using inline styles, we can also do things that are hard to implement with regular CSS. For example, we can recalculate some CSS values on the client at runtime, which is a very powerful concept, as you will see in the following example.</p>
<p class="normal">Suppose you want to create a form field in which the font size changes according to its value. So, if the value of the field is <code class="inlineCode">24</code>, the font size is going to be 24 pixels. With normal CSS, this behavior is almost impossible to reproduce without putting in a huge effort and duplicated code.</p>
<p class="normal">Let’s look at how easy it is to use inline styles instead, by creating a <code class="inlineCode">FontSize</code> component first and then declaring a value state:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useState, <span class="hljs-title">ChangeEvent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">FontSize</span> = () =&gt; {
  <span class="hljs-keyword">const</span> [value, setValue] = useState&lt;number&gt;(<span class="hljs-number">16</span>)
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">FontSize</span>
</code></pre>
<p class="normal">We implement a simple change handler, where we use the target attribute of the event to retrieve<a id="_idIndexMarker200"/> the current value of the field:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleChange</span> = (<span class="hljs-params">e: ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt; {
  <span class="hljs-title">setValue</span>(<span class="hljs-title">Number</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>))
}
</code></pre>
<p class="normal">Finally, we render the input file of the number type, which is a controlled component because we keep its value updated by using the state. It also has an event handler, which is fired every time the value of the field changes.</p>
<p class="normal">Last but not least, we use the <code class="inlineCode">style</code> attribute of the field to set its font-size value. As you can see, we are using the <code class="inlineCode">camelCased</code> version of the CSS rule to follow the React convention:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span>
<span class="hljs-tag">    </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"number"</span>
<span class="hljs-tag">    </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{value}</span>
<span class="hljs-tag">    </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChange}</span>
<span class="hljs-tag">    </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{{</span><span class="hljs-tag"> </span><span class="hljs-attr">fontSize:</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag"> }}</span>
<span class="hljs-tag">  /&gt;</span>
)
</code></pre>
<p class="normal">Rendering the preceding component, we can see an input field that changes its font size according to its value. The way it works is that when the value changes, we store the new value of the field inside the state. Modifying the state forces the component to re-render, and we use the new state value to set the display value of the field and its font size; it’s easy and powerful.</p>
<p class="normal">Every solution in computer science has its downsides, and it always represents a trade-off. In the case of inline styles, unfortunately, the problems are many.</p>
<p class="normal">For example, with inline styles, it is not possible to use pseudo-selectors (for example, <code class="inlineCode">:hover</code>) and pseudo-elements, which is a pretty significant limitation if you are creating a UI with interactions and animations.</p>
<p class="normal">There are some workarounds, and, for example, you can always create real elements instead of pseudo-elements, but for the pseudo-classes, it is necessary to use JavaScript to simulate the CSS behavior, which is not optimal.</p>
<p class="normal">The same applies to <strong class="keyWord">media queries</strong>, which cannot be defined using inline styles, and it makes it harder to<a id="_idIndexMarker201"/> create responsive web applications. Since styles are declared using JavaScript objects, it is also not possible to use <code class="inlineCode">style</code> fallbacks:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">display</span>: -webkit-flex;
<span class="hljs-attr">display</span>: flex;
</code></pre>
<p class="normal">JavaScript objects cannot have two attributes with the same name. Style fallbacks should be avoided, but it is always good to have the ability to use them if needed.</p>
<p class="normal">Another feature of CSS that it is not possible to emulate using inline styles is <strong class="keyWord">animations</strong>. The workaround here is to define animations globally and use them inside the style attribute of the elements. With inline styles, whenever we need to override a style with regular CSS, we are always forced to use the <code class="inlineCode">!important</code> keyword, which is bad practice because it prevents any other style from being applied to the element.</p>
<p class="normal">The most difficult thing that happens to work with inline styles is debugging. We tend to use class names to find elements in the browser DevTools to debug and check which styles have been applied. With inline styles, all the styles of the items are listed in their <code class="inlineCode">style</code> attribute, which makes it very hard to check and debug the result.</p>
<p class="normal">For example, the button that we created earlier in this section is rendered in the following way:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">"color:palevioletred;background-color:papayawhip;"</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">By itself, it does not seem very hard to read, but if you imagine you have hundreds of elements and hundreds of styles, you realize that the problem becomes very complicated.</p>
<p class="normal">Also, if you are debugging a list where every single item has the same <code class="inlineCode">style</code> attribute, and if you modify one on the fly to check the result in the browser, you will see that you are applying the styles only to it and not to all the other siblings, even if they share the same style.</p>
<p class="normal">Last but not least, if we render our application on the server side (we will cover this topic in <em class="chapterRef">Chapter 12</em>, <em class="italic">Server-Side Rendering</em>), the size of the page is bigger when using inline styles.</p>
<p class="normal">With inline styles, we are putting all the content of the CSS into the markup, which adds an extra number of bytes to the file that we send to the clients and makes the web <a id="_idIndexMarker202"/>application appear slower. Compression algorithms can help with that because they can easily compress similar patterns, and, in some cases, loading the critical path CSS is a good solution; but in general, we should try to avoid it.</p>
<p class="normal">It turns out that inline styles cause more problems than the problems they try to solve. For this reason, the community created different tools to solve the problems of inline styles but keeping the styles inside the components, or local to the components, to get the best of both worlds.</p>
<p class="normal">After Christopher Chedeau’s talk, a lot of developers started talking about inline styles, and many solutions and experiments have been made to find new ways of writing CSS in JavaScript. In the beginning, there were two or three solutions, while today there are more than 40.</p>
<p class="normal">In the next section, we are going to learn how to use the CSS modules.</p>
<h1 class="heading-1" id="_idParaDest-101">Using CSS modules</h1>
<p class="normal">If you feel that inline styles are not a suitable solution for your project and your team, but you still want to keep the styles as close as possible to your components, there is a solution for you, called <strong class="keyWord">CSS modules</strong>. The CSS modules are CSS files in which all class <a id="_idIndexMarker203"/>names and animation names are scoped locally by default. Let’s see how we can use them in our projects; but first, we need to configure <strong class="keyWord">webpack</strong>.</p>
<h2 class="heading-2" id="_idParaDest-102">Webpack 5</h2>
<p class="normal">Before diving into CSS modules and learning how they work, it is important to understand how they were<a id="_idIndexMarker204"/> created and the tools that support them.</p>
<p class="normal">In <em class="chapterRef">Chapter 3</em>, <em class="italic">Cleaning Up Your Code</em>, we looked at how we can write ES6 code and transpile it by using Babel and its presets. As soon as the application grows, you may want to split your code base into modules as well.</p>
<p class="normal">You can use Webpack or Browserify to divide the application into small modules that you can import whenever you need them, while still creating a big bundle for the browser. These tools are called <strong class="keyWord">module bundlers</strong>, and what they do is load all the dependencies of your application<a id="_idIndexMarker205"/> into a single bundle that can be executed in the browser, which does not have any concept of modules (yet).</p>
<p class="normal">In the React world, Webpack is especially popular because it offers many interesting and useful features, with the first one being the concept of loaders. With Webpack, you can potentially load any dependencies other than JavaScript, if there is a loader for<a id="_idIndexMarker206"/> them. For example, you can load JSON files, as well as images and other assets, inside the bundle.</p>
<p class="normal">In May 2015, Mark Dalgleish, one of the creators of CSS modules, figured out that you could import CSS inside a Webpack bundle as well, and he pushed the concept forward. He thought that, since the CSS could be imported locally into a component, all the imported class names could be locally scoped as well, this is great because this will isolate the styles.</p>
<p class="normal">After tracing the conceptual evolution of locally scoped CSS by one of its pioneers, Mark Dalgleish, and understanding how it revolutionized style isolation in Webpack bundles, let us transition into a more practical arena. The next section will guide us in setting up a project that utilizes these principles.</p>
<h1 class="heading-1" id="_idParaDest-103">Setting up a project</h1>
<p class="normal">In this section, we <a id="_idIndexMarker207"/>will look at how to set up a very simple Webpack application, using Babel to transpile the JavaScript and CSS modules to load our locally scoped CSS into the bundle. We will also go through all the features of CSS modules and look at the problems they can solve. The first thing to do is move to an empty folder and run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">npm init
</code></pre>
<p class="normal">This will create a <code class="inlineCode">package.json</code> file with some defaults.</p>
<p class="normal">Now, it is time to install the dependencies, with the first one being Webpack and the second being <code class="inlineCode">webpack-dev-server</code>, which we will use to run the application locally and to create the bundle on the fly:</p>
<pre class="programlisting con"><code class="hljs-con">npm install --save-dev webpack webpack-dev-server webpack-cli
</code></pre>
<p class="normal">Once Webpack is<a id="_idIndexMarker208"/> installed, it is time to install Babel and its loader. Since we are using Webpack to create the bundle, we will use the Babel loader to transpile our ES6 code within Webpack itself:</p>
<pre class="programlisting con"><code class="hljs-con">npm install --save-dev @babel/core @babel/preset-env @babel/preset-react ts-loader
</code></pre>
<p class="normal">Finally, we install <code class="inlineCode">style-loader</code> and the CSS loader, which are the two loaders we need to enable the CSS modules:</p>
<pre class="programlisting con"><code class="hljs-con">npm install --save-dev style-loader css-loader
</code></pre>
<p class="normal">There is one more thing to do to make things easier, and that is to install <code class="inlineCode">html-webpack-plugin</code>, which is a plugin that can create an HTML page to host our JavaScript application on the fly, just by looking into the Webpack configuration and without us needing to create a regular file. Also, we need to install the <code class="inlineCode">fork-ts-checker-webpack-plugin</code> package to make TypeScript work with Webpack:</p>
<pre class="programlisting con"><code class="hljs-con">npm install --save-dev html-webpack-plugin fork-ts-checker-webpack-plugin typescript
</code></pre>
<p class="normal">Last but not least, we install <code class="inlineCode">react</code> and <code class="inlineCode">react-dom</code> to use them in our simple example:</p>
<pre class="programlisting con"><code class="hljs-con">npm install react react-dom
</code></pre>
<p class="normal">Now that all the dependencies are installed, it is time to configure everything to make it work.</p>
<p class="normal">First, you need to create a <code class="inlineCode">.babelrc</code> file in your root path:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"presets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"@babel/preset-env"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"@babel/preset-react"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p class="normal">The first thing to do is add an npm script in <code class="inlineCode">package.json</code> to run the <code class="inlineCode">webpack-dev-server</code>, which will serve the application in development:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"dev"</span>: <span class="hljs-string">"webpack serve --mode development --port 3000"</span>
}
</code></pre>
<div class="packt_tip">
<p class="normal">In Webpack 5, you need to use this way to call webpack instead of <code class="inlineCode">webpack-dev-server</code> but you still need to have this package installed.</p>
</div>
<p class="normal">Webpack needs a configuration file to know how to handle the different types of dependencies we are using in our application, and to do so, we must create a file called <code class="inlineCode">webpack.config.ts</code>, which exports an object:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">module</span>.<span class="hljs-property">exports</span> = {}
</code></pre>
<p class="normal">The object we<a id="_idIndexMarker209"/> export represents the configuration object used by Webpack to create the bundle, and it can have different properties depending on the size and the features of the project.</p>
<p class="normal">We want to keep our example very simple, so we are going to add three attributes. The first one is <code class="inlineCode">entry</code>, which tells Webpack where the main file of our application is:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.tsx'</span>
</code></pre>
<p class="normal">The second one is <code class="inlineCode">module</code>, which is where we tell Webpack how to load the external dependencies. It has an attribute called <code class="inlineCode">rules</code>, where we set a specific loader for each one of the file types:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [
    {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(tsx|ts)$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: {
            <span class="hljs-attr">loader</span>: 'ts-loader',
            <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">transpileOnly</span>: <span class="hljs-literal">true</span>
            }
        }
    },
    {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css/</span>,
        <span class="hljs-attr">use</span>: [
            'style-loader',
            'css-loader?modules=<span class="hljs-literal">true</span>'
        ]
    }
  ]
}
</code></pre>
<p class="normal">We are saying that the files that match the <code class="inlineCode">.ts</code> or <code class="inlineCode">.tsx</code> regular expression are loaded using <code class="inlineCode">ts-loader</code> so that they get transpiled and loaded into the bundle.</p>
<p class="normal">You may also have noticed that we added our presets in the <code class="inlineCode">.babelrc</code> file. As we saw in <em class="chapterRef">Chapter 3</em>, <em class="italic">Cleaning Up Your Code</em>, the presets are sets of configuration options that instruct Babel on how to deal with the different types of syntax (for example, TSX).</p>
<p class="normal">The second entry in the <code class="inlineCode">rules</code> array tells Webpack what to do when a CSS file is imported, and it uses <code class="inlineCode">css-loader</code> with the <code class="inlineCode">modules</code> flag enabled to activate <strong class="keyWord">CSS modules</strong>. The result of the<a id="_idIndexMarker210"/> transformation is then passed to <code class="inlineCode">style-loader</code>, which injects the styles into the header of the page.</p>
<p class="normal">Finally, we enable the HTML plugin to generate the page for us, adding the script tag automatically using the <code class="inlineCode">entry</code> path we specified earlier:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'</span><span class="hljs-string">html-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title">ForkTsCheckerWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fork-ts-checker-webpack-plugin'</span>)
<span class="hljs-attr">plugins</span>: [
  <span class="hljs-keyword">new</span> <span class="hljs-title">ForkTsCheckerWebpackPlugin</span>(),
  <span class="hljs-keyword">new</span> <span class="hljs-title">HtmlWebpackPlugin</span>({
    <span class="hljs-attr">title</span>: <span class="hljs-string">'Your project name'</span>,
    <span class="hljs-attr">template</span>: <span class="hljs-string">'./src/index.xhtml'</span>,
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'./index.xhtml'</span>
  })
]
</code></pre>
<p class="normal">The complete <code class="inlineCode">webpack.config.ts</code> should be as shown in the following code block:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title">ForkTsCheckerWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fork-ts-checker-webpack-plugin'</span>)
<span class="hljs-keyword">const</span> isProduction = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">'production'</span>
<span class="hljs-variable">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">devtool</span>: !isProduction ? <span class="hljs-string">'source-map'</span> : <span class="hljs-literal">false</span>, <span class="hljs-comment">// We generate source maps</span>
  <span class="hljs-comment">// only for development</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.tsx'</span>,
  <span class="hljs-attr">output</span>: { <span class="hljs-comment">// The path where we want to output our bundles</span>
    <span class="hljs-attr">path</span>: path.<span class="hljs-title">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].[hash:8].js'</span>,
    <span class="hljs-attr">sourceMapFilename</span>: <span class="hljs-string">'[name].[hash:8].map'</span>,
    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">'[id].[hash:8].js'</span>,
    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/'</span>
  },
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.ts'</span>, <span class="hljs-string">'.tsx'</span>, <span class="hljs-string">'.js'</span>, <span class="hljs-string">'.json'</span>, <span class="hljs-string">'.css'</span>] <span class="hljs-comment">// Here we add the</span>
    <span class="hljs-comment">// extensions we want to support</span>
  },
  <span class="hljs-attr">target</span>: <span class="hljs-string">'web'</span>,
  <span class="hljs-attr">mode</span>: isProduction ? <span class="hljs-string">'production'</span> : <span class="hljs-string">'development'</span>, <span class="hljs-comment">// production mode</span>
  <span class="hljs-comment">// minifies the code</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
        {
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(tsx|ts)$/</span>,
            <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
            <span class="hljs-attr">use</span>: {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'ts-loader'</span>,
          <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">transpileOnly</span>: <span class="hljs-literal">true</span>
          }
         }
        },
        {
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css/</span>,
            <span class="hljs-attr">use</span>: [
          <span class="hljs-string">'style-loader'</span>,
          <span class="hljs-string">'css-loader?modules=true'</span>
            ]
        }
    ]
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title">ForkTsCheckerWebpackPlugin</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title">HtmlWebpackPlugin</span>({
      <span class="hljs-attr">title</span>: <span class="hljs-string">'Your project name'</span>,
      <span class="hljs-attr">template</span>: <span class="hljs-string">'./src/index.xhtml'</span>,
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'./index.xhtml'</span>
    })
  ],
  <span class="hljs-attr">optimization</span>: { <span class="hljs-comment">// This is to split our bundles into vendor and main</span>
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">cacheGroups</span>: {
          <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">commons</span>: {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'vendor'</span>,
        <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>   
          }
      }
  }
}
}
</code></pre>
<p class="normal">Then, to configure<a id="_idIndexMarker211"/> TypeScript, you need this <code class="inlineCode">tsconfig.json</code> file:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"allowJs"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowSyntheticDefaultImports"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"baseUrl"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"src"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"forceConsistentCasingInFileNames"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"isolatedModules"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"jsx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"react-jsx"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"dom"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"dom.iterable"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"esnext"</span><span class="hljs-punctuation">],</span>
    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"esnext"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"moduleResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"</span><span class="hljs-attr">noEmit"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noFallthroughCasesInSwitch"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noImplicitAny"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"resolveJsonModule"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"skipLibCheck"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"sourceMap"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"esnext"</span>
  <span class="hljs-punctuation">},</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"src/**/*.ts"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"src/**/*.tsx"</span><span class="hljs-punctuation">],</span>
  <span class="hljs-attr">"exclude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"node_modules"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p class="normal">In order to import CSS files using TypeScript, you need to create a declarations file at <code class="inlineCode">src/declarations.d.ts</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">declare</span> <span class="hljs-variable">module</span> <span class="hljs-string">'*.css'</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">content</span>: <span class="hljs-title">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> content
}
</code></pre>
<p class="normal">Then, you need to create the main file at <code class="inlineCode">src/index.tsx</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/client'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">App</span> = () =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Hello World<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
 <span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'</span><span class="hljs-string">root'</span>) <span class="hljs-keyword">as</span> <span class="hljs-title">HTMLElement</span>).<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">React.StrictMode</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">React.StrictMode</span><span class="hljs-tag">&gt;</span>
) 
</code></pre>
<p class="normal">Finally, you need<a id="_idIndexMarker212"/> to create the initial HTML file at <code class="inlineCode">src/index.xhtml</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">&lt;!DOCTYPE </span><span class="hljs-keyword">html</span><span class="hljs-meta">&gt;</span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">html</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">head</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">meta</span><span class="hljs-tag"> </span><span class="hljs-attr">charset</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">UTF-8"</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">meta</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"viewport"</span><span class="hljs-tag"> </span><span class="hljs-attr">content</span><span class="hljs-tag">=</span><span class="hljs-string">"width=device-width, initial-scale=1.0"</span>
<span class="hljs-tag">      /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">meta</span><span class="hljs-tag"> </span><span class="hljs-attr">http-equiv</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">X-UA-Compatible"</span><span class="hljs-tag"> </span><span class="hljs-attr">content</span><span class="hljs-tag">=</span><span class="hljs-string">"ie=edge"</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">title</span><span class="hljs-tag">&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="hljs-tag">&lt;/</span><span class="hljs-name">title</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">head</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">body</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">id</span><span class="hljs-tag">=</span><span class="hljs-string">"root"</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">body</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">html</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">We are done, and if we run the <code class="inlineCode">npm run dev</code> command in the terminal and point the browser to <code class="inlineCode">http://localhost:8080</code>, we should be able to see the following markup being served:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">&lt;!DOCTYPE </span><span class="hljs-keyword">html</span><span class="hljs-meta">&gt;</span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">html</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">head</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">meta</span><span class="hljs-tag"> </span><span class="hljs-attr">charset</span><span class="hljs-tag">=</span><span class="hljs-string">"UTF-8"</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">title</span><span class="hljs-tag">&gt;</span>Your project name<span class="hljs-tag">&lt;/</span><span class="hljs-name">title</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">script</span><span class="hljs-tag"> </span><span class="hljs-attr">defer</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">"/vendor.12472959.js"</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">script</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">script</span><span class="hljs-tag"> </span><span class="hljs-attr">defer</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">"/main.12472959.js"</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">script</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">head</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">body</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">id</span><span class="hljs-tag">=</span><span class="hljs-string">"root"</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">body</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">html</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Perfect – our React application is working! Let’s see now how we can add some CSS to our project.</p>
<h1 class="heading-1" id="_idParaDest-104">Locally scoped CSS</h1>
<p class="normal">Now it is time to create our app, which will consist of a simple button of the same sort we<a id="_idIndexMarker213"/> used in previous examples. We will use it to show all the features of the CSS modules.</p>
<p class="normal">Let’s update the <code class="inlineCode">src/index.tsx</code> file, which is the entry we specified in the Webpack configuration:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/client'</span>
</code></pre>
<p class="normal">We can then create a simple button. As usual, we are going to start with a non-styled button, and we will add the styles step by step:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Button</span> = () =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Finally, we can render the button into the DOM:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">'root'</span>) <span class="hljs-keyword">as</span> <span class="hljs-title">HTMLElement</span>).<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag"> /&gt;</span>)
</code></pre>
<p class="normal">Now, suppose we want to apply some styles to the button – a background color, size, and so on. We create a regular CSS file, called <code class="inlineCode">index.css</code>, and we put the following class into it:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.button</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">outline</span>: none;
}
</code></pre>
<p class="normal">Now, we said that with CSS modules we could import the CSS files into JavaScript; let’s look at how it works.</p>
<p class="normal">Inside our <code class="inlineCode">index.ts</code> file where we defined the <code class="inlineCode">button</code> component, we can add the following line:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.css'</span>
</code></pre>
<p class="normal">The result of this <code class="inlineCode">import</code> statement is a <code class="inlineCode">styles</code> object, where all the attributes are the classes defined in <code class="inlineCode">index.css</code>.</p>
<p class="normal">If we run <code class="inlineCode">console.log(styles)</code>, we can see the following object in the <code class="inlineCode">DevTools</code>:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-selector-tag">button</span>: <span class="hljs-string">"_2wpxM3yizfwbWee6k0UlD4"</span>
}
</code></pre>
<p class="normal">So, we have an object where the attributes are the class names and the values are (apparently) random strings. We will see later that they are non-random, but let’s check what<a id="_idIndexMarker214"/> we can do with that object first.</p>
<p class="normal">We can use the object to set the class name attribute of our button, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Button</span> = () =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.button}</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
<p class="normal">If we go back to the browser, we can now see that the styles we defined in <code class="inlineCode">index.css</code> have been applied to the button. This is not magic, because if we check in <code class="inlineCode">DevTools</code>, the class that has been applied to the element is the same string that’s attached to the <code class="inlineCode">style</code> object we imported inside our code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"_2wpxM3yizfwbWee6k0UlD4"</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">If we look at the header section of the page, we can now see that the same class name has also been injected into the page:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">style</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text/css"</span><span class="hljs-tag">&gt;</span>
  ._2wpxM3yizfwbWee6k0UlD4 {
    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
    <span class="hljs-attribute">border</span>: none;
    <span class="hljs-attribute">outline</span>: none;
  }
<span class="hljs-tag">&lt;/</span><span class="hljs-name">style</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This is how the CSS and the style loaders work. The CSS loader lets you import the CSS files into your JavaScript modules and, when the <code class="inlineCode">module</code> flag is activated, all the class names are locally scoped to the module they are imported into. </p>
<p class="normal">As we mentioned previously, the string we imported was non-random, but it is generated using the hash of the file and some other parameters in a way that is unique within the code base.</p>
<p class="normal">Finally, <code class="inlineCode">style-loader</code> takes the result of the CSS module’s transformation and injects the styles inside the header section of the page. This is very powerful because we have the full power and expressiveness of the CSS, combined with the advantages of having locally scoped class names and explicit dependencies.</p>
<p class="normal">As mentioned at the beginning of this chapter, CSS is global, and that makes it very hard to maintain in large applications. With CSS modules, class names are locally scoped, and they<a id="_idIndexMarker215"/> cannot clash with other class names in different parts of the application, enforcing a deterministic result.</p>
<p class="normal">Moreover, explicitly importing the CSS dependencies inside our components helps us see clearly which components need which CSS. It is also very useful for eliminating dead code because when we delete a component for any reason, we can tell exactly which CSS it was using.</p>
<p class="normal">CSS modules are regular CSS, so we can use pseudo-classes, media queries, and animations.</p>
<p class="normal">For example, we can add CSS rules such as the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;
}
  
<span class="hljs-selector-class">.button</span><span class="hljs-selector-pseudo">:active</span> {
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;
}
  
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) {
  <span class="hljs-selector-class">.button</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">160px</span>;
  }
}
</code></pre>
<p class="normal">This will be transformed into the following code and injected into the document:</p>
<pre class="programlisting code"><code class="hljs-code">._2wpxM3yizfwbWee6k0UlD4<span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;
}
  
._2wpxM3yizfwbWee6k0UlD4<span class="hljs-selector-pseudo">:active</span> {
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;
}
  
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) {
  ._2wpxM3yizfwbWee6k0UlD4 {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">160px</span>;
  }
}
</code></pre>
<p class="normal">The class names get created and they get replaced everywhere the button is used, making it reliable <a id="_idIndexMarker216"/>and local, as expected.</p>
<p class="normal">As you may have noticed, those class names are great, but they make debugging pretty hard because we cannot easily tell which classes generated the hash. What we can do in development mode is add a special configuration parameter, with which we can choose the pattern that’s used to produce the scoped class names.</p>
<p class="normal">For example, we can change the value of the loader as follows:</p>
<pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css/</span>,
  <span class="hljs-attr">use</span>: [
    {
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'style-loader'</span>
    },
    {
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'css-loader'</span>,
        <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">modules</span>: {
          <span class="hljs-attr">localIdentName</span>: <span class="hljs-string">'[local]--[hash:base64:5]'</span>
        }
     }
    }
  ]
}
</code></pre>
<p class="normal">Here, <code class="inlineCode">localIdentName</code> is the parameter, and <code class="inlineCode">[local]</code> and <code class="inlineCode">[hash:base64:5]</code> are placeholders for the original class name value and a five-character hash. Other available placeholders are <code class="inlineCode">[path]</code>, which represents the path of the CSS file, and <code class="inlineCode">[name]</code>, which is the name <a id="_idIndexMarker217"/>of the source CSS file.</p>
<p class="normal">Activating the previous configuration option, the result we have in the browser is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"button--2wpxM"</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This is way more readable and easier to debug.</p>
<p class="normal">In production, we do not need class names like this, and we are more interested in performance, so we may want shorter class names and hashes.</p>
<p class="normal">With Webpack, it is pretty straightforward because we can have multiple configuration files that can be used in the different stages of our application life cycle. Also, in production, we may want to extract the CSS file instead of injecting it into the browser from the bundle so that <a id="_idIndexMarker218"/>we can have a lighter bundle and cache the CSS on a <strong class="keyWord">Content Delivery Network</strong> (<strong class="keyWord">CDN</strong>) for better performance.</p>
<p class="normal">To do that, you need to install another Webpack plugin, called <code class="inlineCode">mini-css-extract-plugin</code>, which can write an actual CSS file, putting in all the scoped classes that were generated from CSS modules.</p>
<p class="normal">There are a couple of features of CSS modules that are worth mentioning.</p>
<p class="normal">The first one is the <code class="inlineCode">global</code> keyword. Prefixing any class with <code class="inlineCode">:global</code>, in fact, means asking CSS modules not to scope the current selector locally.</p>
<p class="normal">For example, let’s say we change our CSS as follows:</p>
<pre class="programlisting code"><code class="hljs-code">:global .button {
  ...
}
</code></pre>
<p class="normal">The output will be as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.button</span> {
  ...
}
</code></pre>
<p class="normal">This is good if you want to apply styles that cannot be scoped locally, such as third-party widgets.</p>
<p class="normal">My favorite feature of CSS<a id="_idIndexMarker219"/> modules is <strong class="keyWord">composition</strong>. With composition, we can extract classes from the same file or external dependencies and get all the styles applied to the element.</p>
<p class="normal">For example, extract <a id="_idIndexMarker220"/>the rule to set the background to red from the rules for the button into a separate block, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.background-red</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
}
</code></pre>
<p class="normal">We can then compose it inside our button in the following way:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.button</span> {
  composes: background-red;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">outline</span>: none;
}
</code></pre>
<p class="normal">The result is that all the rules of the button and all the rules of the <code class="inlineCode">composes</code> declaration are applied to the element.</p>
<p class="normal">This is a very powerful feature, and it works in<a id="_idIndexMarker221"/> a fascinating way. You might expect that all the composed classes are duplicated inside the classes where they are referenced as <strong class="keyWord">SASS @extend</strong> does, but that is not the case. Simply put, all the composed class names are applied one after the other on the component in the DOM.</p>
<p class="normal">In our specific case, we would have the following:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"_2wpxM3yizfwbWee6k0UlD4 Sf8w9cFdQXdRV_i9dgcOq"</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Here, the CSS that is injected into the page is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.Sf8w9cFdQXdRV_i9dgcOq</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
}
  
._2wpxM3yizfwbWee6k0UlD4 {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">outline</span>: none;
}
</code></pre>
<p class="normal">As you can see, our<a id="_idIndexMarker222"/> CSS class names have unique names, which is good to isolate our styles. Now, let’s take a look at the Atomic CSS modules.</p>
<h2 class="heading-2" id="_idParaDest-105">Atomic CSS modules</h2>
<p class="normal">It should be clear how composition works and why it is a very powerful feature of CSS modules. At<a id="_idIndexMarker223"/> Disney, the company where I worked when I started writing this book, we tried to push it a step further, combining the power of <a id="_idIndexMarker224"/>composes with the flexibility of <strong class="keyWord">Atomic CSS</strong> (also <a id="_idIndexMarker225"/>known as <strong class="keyWord">Functional CSS</strong>).</p>
<p class="normal">Atomic CSS is a way to use CSS where every class has a single rule.</p>
<p class="normal">For example, we can create a class to set <code class="inlineCode">margin-bottom</code> to <code class="inlineCode">0</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.mb0</span> {
  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;
}
</code></pre>
<p class="normal">We can use another one to set <code class="inlineCode">font-weight</code> to <code class="inlineCode">600</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.fw6</span> {
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">600</span>;
}
</code></pre>
<p class="normal">Then, we can apply all those Atomic classes to the elements:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"mb0 fw6"</span><span class="hljs-tag">&gt;</span>Hello React<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This technique is controversial and particularly efficient at the same time. It is hard to start using it because you end up having too many classes in your markup, which makes it hard to predict the final result. If you think about it, it is pretty similar to inline styles, because you apply one class per rule, apart from the fact that you are using a shorter class name as a proxy.</p>
<p class="normal">The biggest argument against Atomic CSS is usually that you are moving the styling logic from the CSS to the markup, which is wrong. Classes are defined in CSS files, but they are composed in the views, and every time you have to modify the style of an element, you end up editing the markup.</p>
<p class="normal">On the other hand, we tried using Atomic CSS for a bit and we found that it makes prototyping incredibly fast.</p>
<p class="normal">In fact, when all the base rules <a id="_idIndexMarker226"/>have been generated, applying those classes to the elements and creating new styles is a very quick process, which is good. Second, using Atomic<a id="_idIndexMarker227"/> CSS, we can control the size of the CSS file, because as soon as we create new components with their styles, we are using existing classes and we do not need to create new ones, which is great for performance.</p>
<p class="normal">So, we tried to solve the problems of Atomic CSS using CSS modules and we called the technique <strong class="keyWord">Atomic CSS modules</strong>.</p>
<p class="normal">In essence, you start creating<a id="_idIndexMarker228"/> your base CSS classes (for example, <code class="inlineCode">mb0</code>), and then, instead of applying the class names one by one in the markup, you compose them into placeholder classes using CSS modules.</p>
<p class="normal">Let’s look at an example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.title</span> {
  composes: mb0 fw6;
}
</code></pre>
<p class="normal">Here’s another example:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag"> </span><span class="hljs-attr">className</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.title}</span><span class="hljs-tag">&gt;</span>Hello React<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This is great because you still keep the styling logic inside the CSS, and the CSS module’s <code class="inlineCode">composes</code> does the job for you by applying all the single classes in the markup.</p>
<p class="normal">The result of the preceding code is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"title--3JCJR mb0--21SyP fw6--1JRhZ"</span><span class="hljs-tag">&gt;</span>Hello React<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Here, <code class="inlineCode">title</code>, <code class="inlineCode">mb0</code>, and <code class="inlineCode">fw6</code> are all applied automatically to the element. They are scoped locally as well, so we<a id="_idIndexMarker229"/> have all the advantages of CSS modules.</p>
<h1 class="heading-1" id="_idParaDest-106">Implementing styled-components</h1>
<p class="normal">There is a library that is very promising because it takes into account all the problems other libraries <a id="_idIndexMarker230"/>have encountered in styling components. Different paths have been followed for writing CSS in JavaScript, and many solutions have been tried, so now the time is ripe for a library that takes all the learning and then builds something on top of it.</p>
<p class="normal">The library is conceived and maintained by two popular developers in the JavaScript community: <em class="italic">Glenn Maddern</em> and <em class="italic">Max Stoiber</em>. It represents a very modern approach to the problem, and it uses the edge features of ES2015 and some advanced techniques that have been applied to React to provide a complete solution for styling.</p>
<p class="normal">Let’s look at how it is possible to create the same button we saw in the previous sections and check whether all the CSS features we are interested in (for example, pseudo-classes and media queries) work with <code class="inlineCode">styled-components</code>.</p>
<p class="normal">First, we have to install the library by running the following command:</p>
<pre class="programlisting con"><code class="hljs-con">npm install styled-components
</code></pre>
<p class="normal">Once the library is installed, we have to import it inside our component’s file:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>
</code></pre>
<p class="normal">At that point, we can use the styled function to create any element by using <code class="inlineCode">styled.elementName</code>, where <code class="inlineCode">elementName</code> can be a div, a button, or any other valid DOM element.</p>
<p class="normal">The second thing to do is to define the style of the element we are creating and, to do so, we use an ES6 <a id="_idIndexMarker231"/>feature called <strong class="keyWord">tagged template literals</strong>, which is a way of passing template strings to a function without them being interpolated beforehand.</p>
<p class="normal">This means that the function receives the actual template with all the JavaScript expressions, and this makes the library able to use the full power of JavaScript to apply the styles to the elements.</p>
<p class="normal">Let’s start by creating a simple button with a basic styling:</p>
<pre class="programlisting code"><code class="hljs-code">const <span class="hljs-selector-tag">Button</span> = styled<span class="hljs-selector-class">.button</span>`
  backgroundColor: <span class="hljs-number">#ff0000</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  borderRadius: <span class="hljs-number">5px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">outline</span>: none;
`;
</code></pre>
<p class="normal">This <em class="italic">kind-of-weird</em> syntax returns a proper React component called <code class="inlineCode">Button</code>, which renders a <code class="inlineCode">button</code> element and <a id="_idIndexMarker232"/>applies to it all the styles defined in the template. The way the styles are applied is by creating a unique class name, adding it to the element, and then injecting the corresponding style in the head of the document.</p>
<p class="normal">The following is the component that gets rendered:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"kYvFOg"</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">The style that gets added to the page is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-class">.kYvFOg</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">outline</span>: none;
}
</code></pre>
<p class="normal">The good thing about <code class="inlineCode">styled-components</code> is that it supports almost all the features of CSS, which makes it a good candidate to be used in a real-world application.</p>
<p class="normal">For example, it supports pseudo-classes using a SASS-like syntax:</p>
<pre class="programlisting code"><code class="hljs-code">const <span class="hljs-selector-tag">Button</span> = styled<span class="hljs-selector-class">.button</span>`
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">outline</span>: none;
  &amp;<span class="hljs-selector-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;
  }
  &amp;<span class="hljs-selector-pseudo">:active</span> {
    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;
  }
`
</code></pre>
<p class="normal">It also supports media queries:</p>
<pre class="programlisting code"><code class="hljs-code">const <span class="hljs-selector-tag">Button</span> = styled<span class="hljs-selector-class">.button</span>`
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">outline</span>: none;
  &amp;<span class="hljs-selector-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;
  }
  &amp;<span class="hljs-selector-pseudo">:active</span> {
    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;
  }
  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">160px</span>;
  }
`;
</code></pre>
<p class="normal">There are many other<a id="_idIndexMarker233"/> features that this library can bring to your project.</p>
<p class="normal">For example, once you have created the button, you can easily override its styles and use it multiple times with different properties. Inside the templates, it is also possible to use the props that the component received and change the style accordingly.</p>
<p class="normal">Another great feature is <strong class="keyWord">theming</strong>. By wrapping <a id="_idIndexMarker234"/>your components in a <code class="inlineCode">ThemeProvider</code> component, you can inject a <code class="inlineCode">theme</code> property down to the three component’s children, which makes it extremely easy to create UIs where part of the style is shared between components and some other properties depend on the currently selected theme.</p>
<p class="normal">Without a doubt, the <code class="inlineCode">styled-components</code> library is a game-changer when you are taking your styles to the next level. In the beginning, it could seem weird because it involves implementing<a id="_idIndexMarker235"/> styles with components, but once you get used to it, I guarantee it will be your favorite styles package.</p>
<h1 class="heading-1" id="_idParaDest-107">Summary</h1>
<p class="normal">In this chapter, we explored important topics that aim to help readers navigate the complexities of styling in React. We discussed the challenges of scaling CSS, using Meta’s experiences as examples to highlight the real-world difficulties faced by large organizations. This emphasizes the relevance and applicability of the knowledge we’re sharing.</p>
<p class="normal">To make styling in React more intuitive and efficient, we examined how inline styles work and the benefits of co-locating styles within components. This approach promotes organized and readable code, which is crucial for developers aiming to master React.</p>
<p class="normal">Recognizing the limitations of inline styles, we introduced CSS modules as an alternative. We provided a step-by-step guide to setting up a project, allowing readers to learn through hands-on experimentation.</p>
<p class="normal">Importing CSS files into components was also emphasized as an important practice. This helps clarify dependencies and prevents issues by keeping class names scoped locally, ensuring scalable and conflict-free code.</p>
<p class="normal">Finally, we introduced readers to <code class="inlineCode">styled-components</code>, a library that aligns with our book’s goal of offering innovative ways to style components and optimize development practices in React.</p>
<p class="normal">So far, we have explored various approaches to managing CSS styles in React, each illustrating different aspects of our central proposition. In the next chapter, we will further enhance your understanding of React by delving into the practical implementation and benefits of server-side rendering—a technique that improves application performance and user experience.</p>
<h1 class="heading-1" id="_idParaDest-108">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussion with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/React18DesignPatterns4e"><span class="url">https://packt.link/React18DesignPatterns4e</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code2450023176943770109.png" width="177"/></p>
</div>
</div></body></html>