<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Growing the Skeleton into a Social Media Application</h1>
                </header>
            
            <article>
                
<p>Social media is an integral part of the web these days, and many of the user-centric web applications we build end up requiring a social component <span>down the line </span>to drive user engagement.</p>
<p>For our first real-world MERN application, we will modify the MERN skeleton application we developed in <a href="a9dedbd8-baf6-4ec8-b766-0b370227fbe4.xhtml" target="_blank">Chapter 3</a>, <em>Building a Backend with MongoDB, Express, and Node</em>, and <a href="6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml" target="_blank">C<span>hapter 4</span></a><span>, </span><em>Adding a React Frontend to Complete MERN</em><span>, to build a simple social media application in this chapter. While doing this, you will learn how to extend the integration of the MERN stack technologies and add new features to grow your own full-stack web</span> applications.</p>
<p>In this chapter, we will go over the following topics:</p>
<ul>
<li style="font-weight: 400">Introducing MERN Social</li>
<li style="font-weight: 400">Updating the user profile</li>
<li style="font-weight: 400">Following users in MERN Social</li>
<li style="font-weight: 400">Posting messages with photos</li>
<li style="font-weight: 400">Implementing interactions on posts</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing MERN Social</h1>
                </header>
            
            <article>
                
<p>MERN Social is a social media application with rudimentary features inspired by existing social media platforms such as Facebook and Twitter. The main purpose of this application is to demonstrate how to use the MERN stack technologies to implement features that allow users to connect or follow each other, and interact over shared content. While building out MERN Social in this chapter, <span>we will go over the implementation of the following social media-flavored features:</span></p>
<ul>
<li style="font-weight: 400">User profile with a description and a photo</li>
<li style="font-weight: 400">Users following each other</li>
<li style="font-weight: 400">Who to follow suggestions</li>
<li style="font-weight: 400">Posting messages with photos</li>
<li style="font-weight: 400">Newsfeed with posts from followed users</li>
<li style="font-weight: 400">Listing posts by user</li>
<li style="font-weight: 400">Liking posts</li>
<li style="font-weight: 400">Commenting on posts</li>
</ul>
<p>You can extend these implementations further, as desired, for more complex features. The MERN Social home page looks as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/f5366a8d-d429-400a-96ce-de8f53327195.png" style="width:55.50em;height:39.92em;"/></div>
<div class="packt_tip"><span>The code for the complete MERN Social application is available on GitHub </span><span>at</span> <a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter05/mern-social" target="_blank">https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter05/mern-social</a>. <span>You can</span><span> clone this code and run the application as you go through the code explanations for the rest of this chapter.</span></div>
<p>The views needed for the MERN Social application will be developed by extending and modifying the existing React <span>components</span> in the MERN skeleton application. The following component tree shows all the custom React components that make up the MERN Social frontend and also exposes the composition structure we will use to build out the views in the rest of this chapter:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-955 image-border" src="assets/5355a21c-bde7-47b7-a95d-9a57de794243.png" style="width:33.75em;height:37.67em;"/><span> </span></div>
<p><span>Besides updating the existing components, we will also add new custom components to compose views, including a Newsfeed view where the user can create a new post and also browse a list of all the posts from people they follow on MERN Social. In the next section, we will begin by updating the user profile to demonstrate how to upload a profile photo and add a short bio for each user on the platform.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the user profile</h1>
                </header>
            
            <article>
                
<p>The existing skeleton application only has support for a user's name, email, and password. But in MERN Social, we will allow users to add a description about themselves, as well as upload a profile photo while editing the profile after signing up, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-956 image-border" src="assets/c3572610-108c-4d6f-8239-d62751914893.png" style="width:23.17em;height:23.58em;"/></div>
<p>In order to implement this feature update, we need to modify both the user backend and frontend. In the following sections, we will learn how to update the user model and user update API in the backend, and then the user profile and user profile edit form views in the frontend to add a short description and a profile photo for users in MERN Social. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding an about description</h1>
                </header>
            
            <article>
                
<p>To store the short description that's entered in the <kbd>about</kbd> field by a user, we need to add an <kbd>about</kbd> field to the user model in <kbd>server/models/user.model.js</kbd>:</p>
<pre>about: {<br/>    type: String,<br/>    trim: true<br/>  }</pre>
<p>Then, to get the description as input from the user, we need to add a multiline <kbd>TextField</kbd> to the <kbd>EditProfile</kbd> form and handle the value change the same way we did for the user's name input.</p>
<p><kbd><span>mern-social/client/user/EditProfile.js</span></kbd>:</p>
<pre>  &lt;TextField<br/>     id="multiline-flexible"<br/>     label="About"<br/>     multiline<br/>     rows="2"<br/>     value={values.about}<br/>     onChange={handleChange('about')}<br/>  /&gt;</pre>
<p>Finally, to show the description text that was added to the <kbd>about</kbd> field on the user profile page, we can add it to the existing profile view.</p>
<p><kbd><span>mern-social/</span><span>client/user/Profile.js</span></kbd>:</p>
<pre>&lt;ListItem&gt; &lt;ListItemText primary={this.state.user.about}/&gt; &lt;/ListItem&gt;</pre>
<p>With this modification to the user feature in the MERN skeleton code, users can now add and update a description about themselves to be displayed on their profiles. Next, we will add the ability to upload a photo to complete the user profile.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading a profile photo</h1>
                </header>
            
            <article>
                
<p>Allowing a user to upload a profile photo will require that we store the uploaded image file and retrieve it on request to load it in the view. There are multiple ways of implementing this upload feature while considering the different file storage options:</p>
<ul>
<li><strong>Server filesystem</strong>: Upload and save files to a server filesystem and store the URL in MongoDB.</li>
<li><strong>External file storage</strong>: Save files to external storage such as Amazon S3 and store the URL in MongoDB.</li>
<li><strong>Store as data in MongoDB</strong>: Save files that are small in size (less than 16 MB) to MongoDB as data of the Buffer type.</li>
</ul>
<p>For MERN Social, we will assume that the photo files that are uploaded by the user will be small in size and demonstrate how to store these files in MongoDB for the profile photo upload feature. In <a href="7514f26d-29e1-46e2-ac46-7515b2c3a6d0.xhtml">Chapter 8</a>,<a href="" target="_blank"/> <em>Extending the Marketplace for Orders and Payments</em>, we will discuss how to store larger files in MongoDB using GridFS.</p>
<p>To implement this photo upload feature, in the following sections, we will do the following:</p>
<ul>
<li>Update the user model to store the photo.</li>
<li>Integrate updated frontend views to upload the photo from the client- side.</li>
<li>Modify the user update controller in the backend to process the uploaded photo.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the user model to store a photo in MongoDB</h1>
                </header>
            
            <article>
                
<p>In order to store the uploaded profile photo directly in the database, we will update the user model to add a <kbd>photo</kbd> field that stores the file as data of the <kbd>Buffer</kbd> type, along with the file's <kbd>contentType</kbd>.</p>
<p><kbd><span>mern-social/server/models/user.model.js</span></kbd>:</p>
<pre>photo: {<br/>    data: Buffer,<br/>    contentType: String<br/>}</pre>
<p>An image file that's uploaded by the user from the client- side will be converted into binary data and stored in this <kbd>photo</kbd> field for documents in the Users collection in MongoDB. Next, we will look at how to upload the file from the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading a photo from the edit form</h1>
                </header>
            
            <article>
                
<p>Users will be able to upload an image file from their local files when editing the profile. In order to implement this interaction, we will update the <kbd>EditProfile</kbd> component in <kbd>client/user/EditProfile.js</kbd> with an upload photo option and then attach the user selected file in the form data that's submitted to the server. We will discuss this in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">File input with Material-UI</h1>
                </header>
            
            <article>
                
<p>We will utilize the HTML5 file input type t<span>o let the user select an</span> image from their lo<span>cal files. The file input</span> will return the filename in the change event when the user selects a file. We will add the file input element to the edit profile form as follows:</p>
<p><kbd><span>mern-social/client/user/EditProfile.js</span></kbd>:</p>
<pre>&lt;input accept="image/*" type="file"<br/>       onChange={handleChange('photo')} <br/>       style={{display:'none'}} <br/>       id="icon-button-file" /&gt;</pre>
<p>To integrate this file <kbd>input</kbd> element with Material-UI components, we apply <kbd>display:none</kbd> to hide the <kbd>input</kbd> element from the view, then add a Material-UI button inside the label for this file input. This way, the view displays the Material-UI button instead of the HTML5 file input element. The <kbd>label</kbd> is added as follows:</p>
<p><kbd><span>mern-social/</span><span>client/user/</span><span>EditProfile.js</span></kbd>:</p>
<pre>&lt;label htmlFor="icon-button-file"&gt;<br/>   &lt;Button variant="contained" color="default" component="span"&gt;<br/>      Upload &lt;FileUpload/&gt;<br/>   &lt;/Button&gt;<br/>&lt;/label&gt;</pre>
<p>When the Button's <kbd>component</kbd> prop is set to <kbd>span</kbd>, the <kbd>Button</kbd> component renders as a <kbd>span</kbd> element inside the <kbd>label</kbd> element. A click on the <kbd>Upload</kbd> span or label is registered by the file input with the same ID as the label, and as a result, the file select dialog is opened. Once the user selects a file, we can set it to state in the call to <kbd>handleChange(...)</kbd> and display the name in the view, as shown in the following code.</p>
<p><kbd><span>mern-social/</span><span>client/user/</span><span>EditProfile.js</span></kbd>:</p>
<pre>&lt;span className={classes.filename}&gt;<br/>    {values.photo ? values.photo.name : ''}<br/>&lt;/span&gt;</pre>
<p>This way, the user will see the name of the file they are trying to upload as the profile photo. With the file selected for uploading, next, we have to attach and send this file with the request to the server to update the user information in the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Form submission with the file attached</h1>
                </header>
            
            <article>
                
<p>Uploading files to the server with a form requires a multipart form submission. This is in contrast to the stringified object we sent in previous implementations of fetch. We will modify the <kbd>EditProfile</kbd> component so that it uses the <kbd>FormData</kbd> API to store the form data in the format needed for encoding in the <kbd>multipart/form-data</kbd> type.</p>
<div class="packt_tip"><span>You can learn more about the FormData API at </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank">developer.mozilla.org/en-US/docs/Web/API/FormData</a><span>.</span></div>
<p>First,<span> we will update the input </span><kbd>handleChange</kbd><span> function so that we can store input values for both the text fields and the file input, as shown in the following code.</span></p>
<p><kbd><span>mern-social/</span><span>client/user/</span><span>EditProfile.js</span></kbd>:</p>
<pre>const handleChange = name =&gt; event =&gt; {<br/>  <strong>const value = name === 'photo'</strong><br/><strong>    ? event.target.files[0]</strong><br/><strong>    : event.target.value</strong><br/>  setValues({...values, [name]: value })<br/>}</pre>
<p>Then, on form submission, we need to initialize <kbd>FormData</kbd> and append the values from the fields that were updated, as shown here.</p>
<p><kbd><span>mern-social/</span><span>client/user/</span><span>EditProfile.js</span></kbd>:</p>
<pre>const clickSubmit = () =&gt; {<br/>    let userData = new FormData()<br/>    values.name &amp;&amp; userData.append('name', values.name)<br/>    values.email &amp;&amp; userData.append('email', values.email)<br/>    values.passoword &amp;&amp; userData.append('passoword', values.passoword)<br/>    values.about &amp;&amp; userData.append('about', values.about)<br/>    values.photo &amp;&amp; userData.append('photo', values.photo)<br/>    ...<br/>}</pre>
<p><span>After appending all the fields and values to it, </span><kbd>userData</kbd><span> is sent with the fetch API call to update the user, as shown in the following code.</span></p>
<p><kbd><span>mern-social/</span><span>client/user/</span><span>EditProfile.js</span></kbd><span>:</span></p>
<pre>update({<br/>      userId: match.params.userId<br/>    }, {<br/>      t: jwt.token<br/>    }, <strong>userData</strong>).then((data) =&gt; {<br/>      if (data &amp;&amp; data.error) {<br/>        setValues({...values, error: data.error})<br/>      } else {<br/>        setValues({...values, 'redirectToProfile': true})<br/>      }<br/>})</pre>
<p><span>Since the content type of the data that's sent to the server is no longer</span> <kbd>'application/json'</kbd><span>, we also need to modify the</span> <kbd>update</kbd> <span>fetch method in</span> <kbd>api-user.js</kbd> <span>to remove</span> <kbd>Content-Type</kbd> <span>from the headers in the</span> <kbd>fetch</kbd> <span>call, as shown here.</span></p>
<p><kbd><span>mern-social/</span><span>client/user/</span><span>api-user.js</span></kbd>:</p>
<pre>const update = async (params, credentials, user) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/users/' + params.userId, {<br/>      method: 'PUT',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: user<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }}</pre>
<p>Now, if the user chooses to upload a profile photo when editing the profile, the server will receive a request with the file attached, along with the other field values. Next, we need to modify the server-side code to be able to process this request.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing a request containing a file upload</h1>
                </header>
            
            <article>
                
<p>On the server, to process the request to the update API that may now contain a file, we will use the <kbd>formidable</kbd> Node module. Run the following command from the command line to install <kbd>formidable</kbd>:</p>
<pre><strong>yarn add formidable</strong></pre>
<p>The <kbd>formidable</kbd> will allow the server to read the <kbd>multipart</kbd> form data and give us access to the fields and the file, if there are any. If there is a file, <kbd>formidable</kbd> will store it temporarily in the filesystem. We will read it from the filesystem using the <kbd>fs</kbd> module, which will retrieve the file type and data, and store it in the <kbd>photo</kbd> field in the user model. The <kbd>formidable</kbd> code will go in the <kbd>update</kbd> controller in <kbd><span>user.controller.js</span></kbd>, as follows.</p>
<p><kbd><span>mern-social/server/controllers/user.controller.js</span></kbd>:</p>
<pre><strong>import formidable from 'formidable'</strong><br/><strong>import fs from 'fs'</strong><br/>const update = async (req, res) =&gt; {<br/>  <strong>let form = new formidable.IncomingForm()</strong><br/>  <strong>form.keepExtensions = true</strong><br/>  <strong>form.parse</strong>(req, <strong>async</strong> (err, fields, files) =&gt; {<br/>    if (err) {<br/>      return res.status(400).json({<br/>        error: "Photo could not be uploaded"<br/>      })<br/>    }<br/>    let user = req.profile<br/>    user = extend(user, fields)<br/>    user.updated = Date.now()<br/>    <strong>if(files.photo){</strong><br/><strong>       user.photo.data = fs.readFileSync(files.photo.path)</strong><br/><strong>       user.photo.contentType = files.photo.type</strong><br/><strong>    }</strong><br/>    try {<br/>      await user.save()<br/>      user.hashed_password = undefined<br/>      user.salt = undefined<br/>      res.json(user)<br/>    } catch (err) {<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>    }<br/>  })<br/>}</pre>
<p>This will store the uploaded file as data in the database. Next, <span>we will set up file retrieval so that we can</span> access and display the photo that's uploaded by the user in the frontend views.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving a profile photo</h1>
                </header>
            
            <article>
                
<p>The simplest option to retrieve the image stored in the database and then show it in a view is to set up a route that will fetch the data and return it as an image file to the requesting client. In this section, we will learn how to set up this route to expose a photo URL, as well as how to use this URL to display the photo <span>in the frontend views</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Profile photo URL</h1>
                </header>
            
            <article>
                
<p>We will set up a route to the photo stored in the database for each user, and also add another route that will fetch a default photo if the given user did not upload a profile photo. These routes will be defined as follows.</p>
<p><kbd><span>mern-social/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.route('/api/users/photo/:userId')<br/>  .get(userCtrl.photo, userCtrl.defaultPhoto)<br/>router.route('/api/users/defaultphoto')<br/>  .get(userCtrl.defaultPhoto)</pre>
<p><span>We will look for the photo in the <kbd>photo</kbd> </span>controller <span>method and, if found, send it in the response to the request at the photo route;</span> otherwise, we'll call <kbd>next()</kbd> to return the default photo, as shown in the following code.</p>
<p><kbd><span>mern-social/</span><span>server/controllers/user.controller.js</span></kbd>:</p>
<pre>const photo = (req, res, next) =&gt; {<br/>  if(req.profile.photo.data){<br/>    res.set("Content-Type", req.profile.photo.contentType)<br/>    return res.send(req.profile.photo.data)<br/>  }<br/>  <strong>next()</strong><br/>}</pre>
<p>The default photo is retrieved and sent from the server's file system, as shown here.</p>
<p><kbd><span>mern-social/</span><span>server/controllers/user.controller.js</span></kbd>:</p>
<pre>import profileImage from './../../client/assets/images/profile-pic.png'<br/>const defaultPhoto = (req, res) =&gt; {<br/>  return res.sendFile(process.cwd()+profileImage)<br/>}</pre>
<p>We can use the route defined here to display the photo in the views, as described in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing a photo in a view</h1>
                </header>
            
            <article>
                
<p>With the photo URL routes set up to retrieve the photo, we can simply use these in the <kbd>img</kbd> element's <kbd>src</kbd> attribute to load the photo in the view. For example, in the <kbd>Profile</kbd> component, we use the user ID from the <kbd>values</kbd> in the state to construct the photo URL, as shown in the following code.</p>
<p><kbd><span>mern-social/</span><span>client/user/</span><span>Profile.js</span></kbd>:</p>
<pre>const photoUrl = values.user._id<br/>      ? `/api/users/photo/${values.user._id}?${new Date().getTime()}`<br/>      : '/api/users/defaultphoto'</pre>
<p><span>To ensure the <kbd>img</kbd> element reloads in the <kbd>Profile</kbd> view after the photo is updated, we have to add a time value to the photo URL to bypass the browser's default image caching behavior. </span></p>
<p>Then, we can set the <kbd>photoUrl</kbd><span> to the</span> Material-UI <kbd>Avatar</kbd> <span>component, which renders the linked image in the view:</span></p>
<pre>  &lt;Avatar src={photoUrl}/&gt;</pre>
<p><span>The updated user profile in MERN Social can now display a user uploaded profile photo and an <kbd>about</kbd> description, as shown in the following screenshot:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-957 image-border" src="assets/e2289c32-d165-4502-9c83-7bdd1c779a2e.png" style="width:29.17em;height:11.75em;"/></div>
<p>We have successfully updated the MERN skeleton application code to let users upload a profile photo and add a short bio description to their profiles. In the next section, we will update this further and implement the social media flavored feature that allows users to follow each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Following users in MERN Social</h1>
                </header>
            
            <article>
                
<p>In MERN Social, users will be able to follow each other. Each user will have a list of followers and a list of people they follow. Users will also be able to see a list of users they can follow; in other words, the users in MERN Social they are not already following. In the following sections, we will learn how to update the full-stack code to implement these features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Following and unfollowing</h1>
                </header>
            
            <article>
                
<p>In order to keep track of which user is following which other users, we will have to maintain two lists for each user. When one user follows or unfollows another user, we will update one's <kbd>following</kbd> list and the other's <kbd>followers</kbd> list. First, we will update the backend to store and update these lists, then modify the frontend views to allow users to perform follow and unfollow actions. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the user model</h1>
                </header>
            
            <article>
                
<p>To store the list of <kbd>following</kbd> and <kbd>followers</kbd> in the database, we will need to update the user model with two arrays of user references, as shown in the following code.</p>
<p><kbd><span>mern-social/server/models/user.model.js</span></kbd>:</p>
<pre>following: [{type: mongoose.Schema.ObjectId, ref: 'User'}],<br/>followers: [{type: mongoose.Schema.ObjectId, ref: 'User'}]</pre>
<p>These references will point to the users in the collection being followed by or following the given user. Next, we will update the user controllers to ensure the details of the users that are referenced in these lists are returned in a response to client-side requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the userByID controller method</h1>
                </header>
            
            <article>
                
<p>When a single user is retrieved from the backend, we want the <kbd>user</kbd> object to include the names and IDs of the users referenced in the <kbd>following</kbd> and <kbd>followers</kbd> arrays. To retrieve these details, we need to update the <kbd>userByID</kbd> controller method so that it populates the returned user object, as shown in the highlighted code.</p>
<p><kbd><span>mern-social/server/controllers/user.controller.js</span></kbd>:</p>
<pre>const userByID = async (req, res, next, id) =&gt; {<br/>  try {<br/>    let user = await User.findById(id)<br/>    <strong>.populate('following', '_id name')</strong><br/><strong>    .populate('followers', '_id name')</strong><br/>    .exec()<br/>    if (!user)<br/>      return res.status('400').json({<br/>        error: "User not found"<br/>      })<br/>    req.profile = user<br/>    next()<br/>  } catch (err) {<br/>    return res.status('400').json({<br/>      error: "Could not retrieve user"<br/>    })<br/>  }<br/>}</pre>
<p>We use the Mongoose <kbd>populate</kbd> method to specify that the user object that's returned from the query should contain the name and ID of the users referenced in the <kbd>following</kbd> and <kbd>followers</kbd> lists. This will give us the names and IDs of the user references in the <kbd>followers</kbd> and <kbd>following</kbd> lists when we fetch the user with the read API call.</p>
<p>With the user model updated, we are ready to add API endpoints that will update these lists to either add or remove users from the lists, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding APIs to follow and unfollow</h1>
                </header>
            
            <article>
                
<p>When a user follows or unfollows another user from the view, both users' records in the database will be updated in response to the <kbd>follow</kbd> or <kbd>unfollow</kbd> requests.</p>
<p>Set up <kbd>follow</kbd> and <kbd>unfollow</kbd> routes in <kbd><span>user.routes.js</span></kbd> as follows.</p>
<p><kbd><span>mern-social/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.route('/api/users/follow')<br/>  .put(authCtrl.requireSignin, <br/>       userCtrl.addFollowing, <br/>       userCtrl.addFollower)<br/>router.route('/api/users/unfollow')<br/>  .put(authCtrl.requireSignin, <br/>       userCtrl.removeFollowing, <br/>       userCtrl.removeFollower)</pre>
<p>The <kbd>addFollowing</kbd> controller method in the user controller will update the <kbd>following</kbd> array for the current user by pushing the followed user's reference into the array, as shown in the following code.</p>
<p><kbd><span>mern-social/server</span><span>/controllers/user.controller.js</span></kbd>:</p>
<pre>const addFollowing = async (req, res, next) =&gt; {<br/>  try{<br/>    await User.findByIdAndUpdate(req.body.userId, <br/>                   {<strong>$push</strong>: {following: req.body.followId}}) <br/>    next()<br/>  }catch(err){<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>On successful update of the <kbd>following</kbd> array, <kbd>next()</kbd> is invoked, and as a result, the <kbd>addFollower</kbd> method is executed to add the current user's reference to the followed user's <kbd>followers</kbd> array. The <kbd>addFollower</kbd> method is defined as follows.</p>
<p><kbd><span>mern-social/server</span><span>/controllers/user.controller.js</span></kbd>:</p>
<pre>const addFollower = async (req, res) =&gt; {<br/>  try{<br/>    let result = await User.findByIdAndUpdate(req.body.followId, <br/>                            {<strong>$push</strong>: {followers: req.body.userId}}, <br/>                            {new: true})<br/>                            .populate('following', '_id name')<br/>                            .populate('followers', '_id name')<br/>                            .exec()<br/>      result.hashed_password = undefined<br/>      result.salt = undefined<br/>      res.json(result)<br/>    }catch(err) {<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>    } <br/>}</pre>
<p>For unfollowing, the implementation is similar. The <kbd>removeFollowing</kbd> and <kbd>removeFollower</kbd> controller methods update the respective <kbd>'following'</kbd> and <kbd>'followers'</kbd> arrays by removing the user references with <kbd>$pull</kbd> instead of <kbd>$push</kbd>. <kbd>removeFollowing</kbd><span> and </span><kbd>removeFollower</kbd><span> will look as follows.</span></p>
<p><kbd><span>mern-social/server</span><span>/controllers/user.controller.js</span></kbd>:</p>
<pre>const <strong>removeFollowing</strong> = async (req, res, next) =&gt; {<br/>  try{<br/>    await User.findByIdAndUpdate(req.body.userId, <br/>                   {<strong>$pull</strong>: {following: req.body.unfollowId}}) <br/>    next()<br/>  }catch(err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}<br/>const <strong>removeFollower</strong> = async (req, res) =&gt; {<br/>  try{<br/>    let result = await User.findByIdAndUpdate(req.body.unfollowId, <br/>                                {<strong>$pull</strong>: {followers: req.body.userId}}, <br/>                                {new: true})<br/>                            .populate('following', '_id name')<br/>                            .populate('followers', '_id name')<br/>                            .exec() <br/>    result.hashed_password = undefined<br/>    result.salt = undefined<br/>    res.json(result)<br/>  }catch(err){<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>  }<br/>}</pre>
<p>The user backend on the server-side is ready for the follow and unfollow features. Next, we will update the frontend to utilize these new backend APIs and complete this feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the follow and unfollow APIs in views</h1>
                </header>
            
            <article>
                
<p>In order to access these API calls in the views, we will update <kbd>api-user.js</kbd> with the <kbd>follow</kbd> and <kbd>unfollow</kbd> fetch methods. The <kbd>follow</kbd> and <kbd>unfollow</kbd> methods will be similar, making calls to the respective routes with the current user's ID and credentials, and the followed or unfollowed user's ID. The <kbd>follow</kbd> method will be as follows.</p>
<p><kbd><span>mern-social/client/user/api-user.js</span></kbd>:</p>
<pre>const follow = async (params, credentials, followId) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/users/follow/', {<br/>      method: 'PUT',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: JSON.stringify({userId:params.userId, followId: followId})<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>The <kbd>unfollow</kbd> fetch method is similar; it takes the unfollowed user's ID and calls the <kbd>unfollow</kbd> API, as shown in the following code. </p>
<p><kbd><span>mern-social/</span><span>client/user/api-user.js</span></kbd>:</p>
<pre>const unfollow = async (params, credentials, unfollowId) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/users/unfollow/', {<br/>      method: 'PUT',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: JSON.stringify({userId:params.userId, unfollowId: unfollowId})<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>With the API fetch code implemented, we can use these two methods to integrate the backend updates in the views, as discussed in the next section, which will allow users to follow or unfollow another user in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Follow and unfollow buttons</h1>
                </header>
            
            <article>
                
<p>The button that will allow a user to follow or unfollow another user will appear conditionally, depending on whether the user is already followed or not by the current user, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dbd4cd37-3142-46e9-bcd3-3c129241d59f.png" style="width:12.42em;height:2.75em;"/></div>
<p>In the following sections, we will add this button in a separate React component, integrate it with the existing user profile view, and connect it to the follow and unfollow fetch methods. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FollowProfileButton component</h1>
                </header>
            
            <article>
                
<p>We will create a separate component for the follow button called <kbd>FollowProfileButton</kbd>, which will be added to the <kbd>Profile</kbd> component. This component will show the <kbd>Follow</kbd> or <kbd>Unfollow</kbd> button, depending on whether the current user is already a follower of the user in the profile. The <kbd>FollowProfileButton</kbd> component will look as follows.</p>
<p><kbd><span>mern-social/</span>client/user/FollowProfileButton.js</kbd>:</p>
<pre>export default function FollowProfileButton (props) {<br/><strong>  const followClick = () =&gt; {</strong><br/><strong>    props.onButtonClick(follow)</strong><br/><strong>  }</strong><br/><strong>  const unfollowClick = () =&gt; {</strong><br/><strong>    props.onButtonClick(unfollow)</strong><br/><strong>  }</strong><br/>  return (&lt;div&gt;<br/>    { props.following<br/>       ? (&lt;Button variant="contained" color="secondary" <br/>                  <strong>onClick={unfollowClick}</strong>&gt;Unfollow&lt;/Button&gt;)<br/>       : (&lt;Button variant="contained" color="primary" <br/>                  <strong>onClick={followClick}</strong>&gt;Follow&lt;/Button&gt;)<br/>   }<br/>   &lt;/div&gt;)<br/>}<br/>FollowProfileButton.propTypes = {<br/> following: PropTypes.bool.isRequired,<br/> onButtonClick: PropTypes.func.isRequired<br/>}</pre>
<p>When <span><kbd>FollowProfileButton</kbd> is added to the profile, t</span>he <kbd>following</kbd> value will be determined and sent from the <kbd>Profile</kbd> component as a prop to <kbd>FollowProfileButton</kbd>, along with the click handler that takes the specific <kbd>follow</kbd> or <kbd>unfollow</kbd> fetch API to be called as a parameter. The resulting profile views will look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ccda800f-39dd-4ff2-97e6-457375a33cbb.png" style="width:39.08em;height:9.75em;"/></div>
<p>In order to integrate this <kbd>FollowProfileButton</kbd> component with the profile view, we need to update the existing <kbd>Profile</kbd> component, as discussed next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the Profile component</h1>
                </header>
            
            <article>
                
<p>In the <kbd>Profile</kbd> view, <kbd>FollowProfileButton</kbd> should only be shown when the user views the profile of other users, so we need to modify the condition for showing the <kbd>Edit</kbd> and <kbd>Delete</kbd> buttons when viewing a profile, as follows:</p>
<pre>{auth.isAuthenticated().user &amp;&amp; <br/>      auth.isAuthenticated().user._id == values.user._id <br/>    ? (edit and delete buttons) <br/>    : (follow button)<br/>}</pre>
<p>In the <kbd>Profile</kbd> component, after the user data is successfully fetched in <kbd>useEffect</kbd>, we will check whether the signed-in user is already following the user in the profile or not and set the <kbd>following</kbd> value to the respective state, as shown in the following code.</p>
<p><kbd><span>mern-social/</span><span>client/user/Profile.js</span></kbd>:</p>
<pre class="mce-root">let following = <strong>checkFollow(data)</strong><br/>setValues({...values, user: data, following: following}) </pre>
<p>To determine the value to set in <kbd>following</kbd>, the <kbd>checkFollow</kbd> method will check if the signed-in user exists in the fetched user's <kbd>followers</kbd> list, then return <kbd>match</kbd> if found; otherwise, it will return <kbd>undefined</kbd> if a match is not found. T<span>he </span><kbd>checkFollow</kbd><span> method is defined as follows.</span></p>
<p><kbd><span>mern-social/</span><span>client/user/Profile.js</span></kbd>:</p>
<pre>const <strong>checkFollow</strong> = (user) =&gt; {<br/>    const match = user.followers.some((follower)=&gt; {<br/>      return follower._id == jwt.user._id<br/>    })<br/>    return match<br/>}</pre>
<p>The <kbd>Profile</kbd> component will also define the click handler for <kbd>FollowProfileButton</kbd> so that the state of the <kbd>Profile</kbd> can be updated when the follow or unfollow action completes, as shown in the following code.</p>
<p><kbd><span>mern-social/</span><span>client/user/Profile.js</span></kbd>:</p>
<pre>  const <strong>clickFollowButton</strong> = (callApi) =&gt; {<br/>    callApi({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, values.user._id).then((data) =&gt; {<br/>      if (data.error) {<br/>        setValues({...values, error: data.error})<br/>      } else {<br/>        setValues({...values, user: data, following: !values.following})<br/>      }<br/>    })<br/>  }</pre>
<p>The click handler definition takes the fetch API call as a parameter and is passed as a prop to <kbd>FollowProfileButton</kbd>, along with the <kbd>following</kbd> value when it is added to the <kbd>Profile</kbd> view, as follows.</p>
<p><kbd><span>mern-social/</span><span>client/user/Profile.js</span></kbd>:</p>
<pre>&lt;FollowProfileButton following={this.state.following} onButtonClick={this.<strong>clickFollowButton</strong>}/&gt;</pre>
<p>This will load <kbd>FollowProfileButton</kbd> into the profile view, with all the necessary conditions accounted for, and provide the current user the option to follow or unfollow other users in the MERN Social application. Next, we will extend this feature to allow users to view the list of followings or followers in the user profile view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing followings and followers</h1>
                </header>
            
            <article>
                
<p>In order to give users easy access to the users they are following and the users who are following them on MERN Social, we will add these lists to their profile views. In each user's profile, we will add a list of their followers and the people they are following, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/699fc1d1-f5f6-4a94-bca8-e97269344764.png" style="width:28.58em;height:18.42em;"/></div>
<p>The details of the users referenced in the <kbd>following</kbd> and <kbd>followers</kbd> lists are already in the user object that is fetched using the <kbd>read</kbd> API when the profile is loaded. In order to render these separate lists of followers and followings, we will create a new component called <kbd>FollowGrid</kbd>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making a FollowGrid component</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>FollowGrid</kbd> </span>component will take a list of users as props, display the avatars of the users with their names, and link them to each user's own profile. We can add this component to the <kbd>Profile</kbd> view to display <kbd>followings</kbd> or <kbd>followers</kbd>. The <kbd>FollowGrid</kbd> component is defined as follows.</p>
<p><kbd><span>mern-social/</span><span>client/user/FollowGrid.js</span></kbd>:</p>
<pre>export default function FollowGrid (props) {<br/>  const classes = useStyles()<br/>    return (&lt;div className={classes.root}&gt;<br/>      &lt;GridList cellHeight={160} className={classes.gridList} cols={4}&gt;<br/>        {props.people.map((person, i) =&gt; {<br/>           return &lt;GridListTile style={{'height':120}} key={i}&gt;<br/>              &lt;Link to={"/user/" + person._id}&gt;<br/>                &lt;Avatar src={'/api/users/photo/'+person._id} <br/>                        className={classes.bigAvatar}/&gt;<br/>                &lt;Typography className={classes.tileText}&gt;<br/>                   {person.name}<br/>                &lt;/Typography&gt;<br/>              &lt;/Link&gt;<br/>            &lt;/GridListTile&gt;<br/>        })}<br/>      &lt;/GridList&gt;<br/>    &lt;/div&gt;)<br/>}<br/><br/>FollowGrid.propTypes = {<br/>  people: PropTypes.array.isRequired<br/>}<br/><br/></pre>
<p>To add the <kbd>FollowGrid</kbd> component to the <kbd>Profile</kbd> view, we can place it as desired in the view and pass the list of <kbd>followers</kbd> or <kbd>followings</kbd> as the <kbd>people</kbd> prop:</p>
<pre>&lt;FollowGrid people={props.user.followers}/&gt;<br/>&lt;FollowGrid people={props.user.following}/&gt;</pre>
<p><span>As shown previously, in MERN Social, we chose to display the <kbd>FollowGrid</kbd> components in tabs within the <kbd>Profile</kbd> component. </span>We created a separate <kbd>ProfileTabs</kbd> component using Material-UI tab components and added that to the <kbd>Profile</kbd> component. This <kbd>ProfileTabs</kbd> component contains the two <kbd>FollowGrid</kbd> components with following and followers lists, along with a <kbd>PostList</kbd> component that shows the posts by the user.</p>
<p>This <kbd>PostList</kbd> component will be discussed later in this chapter. In the next section, we will add a feature that will allow a user to discover other users on the platform who they are not following yet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding people to follow</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">Who to follow</span> feature will show the signed-in user a list of people in MERN Social that they are not currently following, thus giving them the option to follow them or view their profiles, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-958 image-border" src="assets/382878d9-dbbd-4454-a09f-5d446469e7b4.png" style="width:25.00em;height:19.58em;"/></div>
<p>To implement this feature, we need to add a backend API that returns the list of users not followed by the currently signed-in user, and then update the frontend by adding a component that loads and displays this list of users.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching users not followed</h1>
                </header>
            
            <article>
                
<p>We will implement a new API on the server to query the database and fetch the list of users the current user is not following. This route will be defined as follows.</p>
<p><kbd><span>mern-social/server/routes/user.routes.js</span></kbd>:</p>
<pre>router.route('/api/users/findpeople/:userId')<br/>   .get(authCtrl.requireSignin, userCtrl.findPeople)</pre>
<p>In the <kbd>findPeople</kbd> controller method, we will query the User collection in the database to find the users that are not in the current user's <kbd>following</kbd> list.</p>
<p><kbd><span>mern-social/server</span><span>/controllers/user.controller.js</span></kbd>:</p>
<pre>const findPeople = async (req, res) =&gt; {<br/>  let following = req.profile.following<br/>  following.push(req.profile._id)<br/>  try {<br/>    let users = await User.find({ _id:{ <strong>$nin</strong> : following }})<br/>                          .select('name')<br/>    res.json(users)<br/>  }catch(err){<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>This query will return an array of users that are not followed by the current user. To use this list of users in the frontend, we will update the <kbd>api-user.js</kbd> file and add a fetch for this API. The <kbd>findPeople</kbd> fetch method is defined as follows.</p>
<p> <kbd><span>mern-social/client/user/api-user.js</span></kbd>:</p>
<pre>const findPeople = async (params, credentials, signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/users/findpeople/' + params.userId, {<br/>      method: 'GET',<br/>      signal: signal,<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      }<br/>    }) <br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>We can use this <kbd>findPeople</kbd> fetch method in the component that will display this list of users. In the next section, we will create the FindPeople component for this purpose.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FindPeople component</h1>
                </header>
            
            <article>
                
<p>To display the <em>who to follow</em> feature, we will create a component called <kbd>FindPeople</kbd>, which can be added to any of the views or rendered on its own. In this component, we will fetch the users not being followed by calling the <kbd>findPeople</kbd> method in <kbd>useEffect</kbd>, as shown in the following code.</p>
<p><kbd>mern-social/client/user/FindPeople.js</kbd>:</p>
<pre> useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>    findPeople({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, signal).then((data) =&gt; {<br/>      if (data &amp;&amp; data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        setValues({...values, users:data})<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/> }, [])</pre>
<p>The fetched list of users will be iterated over and rendered in a Material-UI <kbd>List</kbd> component, with each list item containing the user's avatar, name, a link to the profile page, and a <kbd>Follow</kbd> button, as shown in the following code.</p>
<p><kbd><span>mern-social/client/user/FindPeople.js</span></kbd>:</p>
<pre>&lt;List&gt;<br/>     {values.users.map((item, i) =&gt; {<br/>         return &lt;span key={i}&gt;<br/>            &lt;ListItem&gt;<br/>               &lt;ListItemAvatar className={classes.avatar}&gt;<br/>                  &lt;Avatar src={'/api/users/photo/'+item._id}/&gt;<br/>               &lt;/ListItemAvatar&gt;<br/>               &lt;ListItemText primary={item.name}/&gt;<br/>               &lt;ListItemSecondaryAction className={classes.follow}&gt;<br/>                  &lt;Link to={"/user/" + item._id}&gt;<br/>                    &lt;IconButton variant="contained" color="secondary" <br/>                                className={classes.viewButton}&gt;<br/>                      &lt;ViewIcon/&gt;<br/>                    &lt;/IconButton&gt;<br/>                  &lt;/Link&gt;<br/>                  &lt;Button aria-label="Follow" variant="contained" <br/>                          color="primary" <br/>                          onClick={()=&gt; {clickFollow(item, i)}}&gt;<br/>                      Follow<br/>                  &lt;/Button&gt;<br/>               &lt;/ListItemSecondaryAction&gt;<br/>            &lt;/ListItem&gt;<br/>          &lt;/span&gt;<br/>        })<br/>      }<br/>&lt;/List&gt;</pre>
<p>Clicking the <kbd>Follow</kbd> button will make a call to the follow API and update the list of users to follow by splicing out the newly followed user. The <kbd>clickFollow</kbd> method implements this behavior as follows.</p>
<p><kbd><span>mern-social/client/user/FindPeople.js</span></kbd>:</p>
<pre>const clickFollow = (user, index) =&gt; {<br/>  <strong>follow</strong>({<br/>    userId: jwt.user._id<br/>  }, {<br/>    t: jwt.token<br/>  }, user._id).then((data) =&gt; {<br/>    if (data.error) {<br/>      console.log(data.error)<br/>    } else {<br/>      let toFollow = values.users<br/>      <strong>toFollow.splice(index, 1)</strong><br/>      setValues({...values, users: toFollow, open: true, <br/>                            <strong>followMessage: `Following ${user.name}!`</strong>})<br/>    }<br/>  })<br/>}</pre>
<p>We will also add a Material-UI <kbd>Snackbar</kbd> component that will open temporarily when the user is successfully followed in order to tell the user that they started following this new user. <kbd>Snackbar</kbd> will be added to the view code as follows.</p>
<p><kbd><span>mern-social/client/user/FindPeople.js</span></kbd>:</p>
<pre>&lt;Snackbar<br/>   anchorOrigin={{<br/>        vertical: 'bottom',<br/>        horizontal: 'right',<br/>     }}<br/>   open={values.open}<br/>   onClose={handleRequestClose}<br/>   autoHideDuration={6000}<br/>   message={&lt;span className={classes.snack}&gt;<strong>{values.followMessage}</strong>&lt;/span&gt;}<br/>/&gt;</pre>
<p><span>As shown in the following screenshot,</span> <kbd>Snackbar</kbd> will display the <kbd>message</kbd> containing the followed user's name at the bottom-right corner of the page, and then auto-hide it after the set duration:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-959 image-border" src="assets/75e760a8-de50-4ea1-a1ee-de7baab28315.png" style="width:24.92em;height:4.50em;"/></div>
<p>MERN Social users can now follow each other, view lists of followings and followers for each user, and also see a list of people they can follow. The main purpose of following another user in MERN Social is to see and interact with their shared posts. In the next section, we will look at the implementation of the post feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Posting on MERN Social</h1>
                </header>
            
            <article>
                
<p>The post feature in MERN Social will allow users to share content on the MERN Social application platform and also interact with each other over the content by commenting on or liking a post, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-960 image-border" src="assets/e22285cb-cb09-4f0a-8a38-d1d5317d52fa.png" style="width:27.75em;height:40.25em;"/></div>
<p>For this feature, we will implement a complete full-stack slice containing the post backend and frontend. The post backend will be comprised of a new Mongoose model for structuring the post data to be stored in the database, while the post CRUD API endpoints will allow the frontend to interact with the Post collection in the database. The post frontend will consist of post-related React components that will allow users to view posts, <span>add new posts, </span>interact with posts, and delete their own posts. In the following sections, we will define the data structure for posts in the Post schema, and then learn how to incrementally add the post backend APIs and frontend components according to the specific post-related feature we are implementing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mongoose schema model for Post</h1>
                </header>
            
            <article>
                
<p>To define the structure for storing details about each post and to store each post as a document in a collection in MongoDB, we will define the Mongoose schema for a post in <kbd>server/models/post.model.js</kbd>. The Post schema will store a post's text content, a photo, a reference to the user who posted, time of creation, likes on the post from users, and comments on the post by users. The schema will store these details in the following fields, each defined as shown with the corresponding code.</p>
<ul>
<li><strong>Post text</strong>: <span><kbd>text</kbd> will be a required field that needs to be provided by the user on new post creation from the view:</span></li>
</ul>
<pre style="padding-left: 60px">text: {<br/>  type: String,<br/>  required: 'Text is required'<br/>}</pre>
<ul>
<li><strong>Post photo</strong>: <span><kbd>photo</kbd> will be uploaded from the user's local files during post creation and stored in MongoDB, similar to the user profile photo upload feature. The photo will be optional for each post:</span></li>
</ul>
<pre style="padding-left: 60px">photo: {<br/>  data: Buffer,<br/>  contentType: String<br/>}</pre>
<ul>
<li><strong>Post by</strong>: <span>Creating a post will require a user to be signed-in first so that we can store a reference to the user who is posting in the <kbd>postedBy</kbd> field:</span></li>
</ul>
<pre style="padding-left: 60px">postedBy: {type: mongoose.Schema.ObjectId, ref: 'User'}</pre>
<ul>
<li><strong>Created time</strong>: <span>The <kbd>created</kbd> time will be generated automatically at the time of post creation in the database:</span></li>
</ul>
<pre style="padding-left: 60px">created: { type: Date, default: Date.now }</pre>
<ul>
<li><strong>Likes</strong>: <span>References to the users who liked a specific post will be stored in a <kbd>likes</kbd> array:</span></li>
</ul>
<pre style="padding-left: 60px">likes: [{type: mongoose.Schema.ObjectId, ref: 'User'}]</pre>
<ul>
<li><strong>Comments</strong>: <span>Each comment on a post will contain text content, the time of creation, and a reference to the user who posted the comment. Each post will have an array of <kbd>comments</kbd>:</span></li>
</ul>
<pre style="padding-left: 60px">comments: [{<br/>    text: String,<br/>    created: { type: Date, default: Date.now },<br/>    postedBy: { type: mongoose.Schema.ObjectId, ref: 'User'}<br/>  }]</pre>
<p>This schema definition will enable us to implement all the post-related features in MERN Social. Next, we will start with a discussion of the Newsfeed feature to learn how to compose frontend React components. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Newsfeed component</h1>
                </header>
            
            <article>
                
<p>On MERN Social, each user will see posts that have been shared by people they follow, along with posts that they themselves share, all aggregated in a Newsfeed view. Before delving further into the implementations of the post-related features in MERN Social, we will look at the composition of this <span class="packt_screen">Newsfeed</span> view to showcase a basic example of how to design nested UI components that share state. The <kbd>Newsfeed</kbd> component will contain two main child components <span>– </span>a new post form and a list of posts from followed users, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-961 image-border" src="assets/6f274663-1fc2-41fe-bfaa-ea5fdd7dbe1a.png" style="width:19.58em;height:20.92em;"/></div>
<p>The basic structure of the <kbd>Newsfeed</kbd> component will be as follows, with the <kbd>NewPost</kbd> component and the <kbd>PostList</kbd> component inside it.</p>
<p><kbd><span>mern-social/client/post/Newsfeed.js</span></kbd>:</p>
<pre>&lt;Card&gt;<br/>   &lt;Typography type="title"&gt; Newsfeed &lt;/Typography&gt;<br/>   &lt;Divider/&gt;<br/>   <strong>&lt;NewPost addUpdate={addPost}/&gt;</strong><br/>   &lt;Divider/&gt;<br/>   <strong>&lt;PostList removeUpdate={removePost} posts={posts}/&gt;</strong><br/>&lt;/Card&gt;</pre>
<p>As the parent component, <kbd>Newsfeed</kbd> will control the state of the posts' data that's rendered in the child components. It will provide a way to update the state of posts across the components when the post data is modified within the child components, such as the addition of a new post in the <kbd>NewPost</kbd> component or the removal of a post from the <kbd>PostList</kbd> component.</p>
<p>Here specifically, in the <kbd>Newsfeed</kbd> component we initially make a call to the server to fetch a list of posts from people that the currently signed-in user follows. Then we set this list of posts to the state to be rendered in the <span><kbd>PostList</kbd> </span><span>component.</span><span>. The</span> <kbd>Newsfeed</kbd> <span>component provides the </span><kbd>addPost</kbd> <span>and</span> <kbd>removePost</kbd> <span>functions to</span> <kbd>NewPost</kbd> <span>and</span> <kbd>PostList</kbd><span>, which will be used</span> <span>when a new post is created or an existing post is deleted </span><span>to update the list of posts in the Newsfeed's state and ultimately reflect it in the</span> <kbd>PostList</kbd><span>. </span></p>
<p>The <kbd>addPost</kbd> function defined in the <kbd>Newsfeed</kbd> component will take the new post that was created in the <kbd>NewPost</kbd> component and add it to the posts in the state. The <kbd>addPost</kbd> function will look as follows.</p>
<p><kbd><span>mern-social/</span><span>client/post/Newsfeed.js</span></kbd>:</p>
<pre>const addPost = (post) =&gt; {<br/>    const updatedPosts = [...posts]<br/>    updatedPosts.unshift(post)<br/>    setPosts(updatedPosts)<br/>}</pre>
<p>The <kbd>removePost</kbd> function defined in the <kbd>Newsfeed</kbd> component will take the deleted post from the <kbd>Post</kbd> component in <kbd>PostList</kbd> and remove it from the posts in the state. The <kbd>removePost</kbd><span> function will look as follows.</span></p>
<p><kbd><span>mern-social/</span><span>client/post/Newsfeed.js</span></kbd>:</p>
<pre>const removePost = (post) =&gt; {<br/>    const updatedPosts = [...posts]<br/>    const index = updatedPosts.indexOf(post)<br/>    updatedPosts.splice(index, 1)<br/>    setPosts(updatedPosts)<br/>}</pre>
<p>As the posts are updated in the Newsfeed's state this way, the <kbd>PostList</kbd> will render the changed list of posts to the viewer. This mechanism of relaying state updates from parent to child components and back will be applied across other features, such as comment updates in a post and when a <kbd>PostList</kbd> is rendered for an individual user in the <kbd>Profile</kbd> component.</p>
<p>To begin the complete implementation of the <kbd>Newsfeed</kbd>, we need to be able to fetch a list of posts from the server and display it in the <kbd>PostList</kbd>. In the next section, we will make this <kbd>PostList</kbd> component for the frontend and add PostList API endpoints to the backend. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing posts</h1>
                </header>
            
            <article>
                
<p>In MERN Social, we list posts in the <kbd>Newsfeed</kbd> and in the profile of each user. We will create a generic <kbd>PostList</kbd> component that will render any list of posts provided to it, which we can use in both the <kbd>Newsfeed</kbd> and the <kbd>Profile</kbd> components. The <span><kbd>PostList</kbd> component is defined as follows.</span></p>
<p><kbd><span>mern-social/</span><span>client/post/PostList.js</span></kbd>:</p>
<pre>export default function PostList (props) {<br/>    return (<br/>      &lt;div style={{marginTop: '24px'}}&gt;<br/>        {props.posts.map((item, i) =&gt; {<br/>            return &lt;Post post={item} key={i} <br/>                         onRemove={props.removeUpdate}/&gt;<br/>          })<br/>        }<br/>      &lt;/div&gt;<br/>    )<br/>}<br/>PostList.propTypes = {<br/>  posts: PropTypes.array.isRequired,<br/>  removeUpdate: PropTypes.func.isRequired<br/>}</pre>
<p>The <kbd>PostList</kbd> component will iterate through the list of posts passed to it as props from the <kbd>Newsfeed</kbd> or the <kbd>Profile</kbd>, and pass the data of each post to a <kbd>Post</kbd> component that will render details of the post. <kbd>PostList</kbd> will also pass the <kbd>removeUpdate</kbd> function that was sent as a prop from the parent component to the <kbd>Post</kbd> component so that the state can be updated when a single post is deleted. Next, we will complete the post lists in the Newsfeed view after fetching the relevant posts from the backend. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing posts in Newsfeed</h1>
                </header>
            
            <article>
                
<p>We will set up an API on the server that queries the Post collection and returns a list of posts from the people a specified user is following. Then, to populate the Newsfeed view, these posts will be retrieved in the frontend by calling this API and they will be <span>displaye</span><span>d in the <kbd>PostList</kbd> in <kbd>Newsfeed</kbd></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Newsfeed API for posts</h1>
                </header>
            
            <article>
                
<p>To implement the Newsfeed-specific API, we need to add the route endpoint that will receive <span>the request for Newsfeed posts </span>and respond accordingly to the requesting client-  side.</p>
<p>On the backend, we need to define the route path that will receive the request for retrieving Newsfeed posts for a specific user, as shown in the following code.</p>
<p><kbd>server/routes/post.routes.js</kbd></p>
<pre>router.route('/api/posts/feed/:userId')<br/>  .get(authCtrl.requireSignin, postCtrl.listNewsFeed)</pre>
<p>We are using the <kbd>:userID</kbd> parameter in this route to specify the currently signed-in user. We will utilize the <kbd>userByID</kbd> controller method in <kbd>user.controller</kbd> to fetch the user details, as we did previously, and append these to the request object that is accessed in the <kbd>listNewsFeed</kbd> post controller method. Add the following to <kbd><span>mern-social/server/routes/post.routes.js</span></kbd>:</p>
<pre>router.param('userId', userCtrl.userByID)</pre>
<p>The <kbd>post.routes.js</kbd> file will be very similar to the <kbd>user.routes.js</kbd> file. To load these new routes in the Express app, we need to mount the post routes in <kbd>express.js</kbd>, just like we did for the auth and user routes. The post-related routes are mounted as follows.</p>
<p><kbd>mern-social/server/express.js</kbd>:</p>
<pre>app.use('/', postRoutes)</pre>
<p>The <kbd>listNewsFeed</kbd> controller method in <kbd>post.controller.js</kbd> will query the Post collection in the database to get the matching posts. <span>The </span><kbd>listNewsFeed</kbd><span> controller method is defined as follows.</span></p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const listNewsFeed = async (req, res) =&gt; {<br/>  let following = req.profile.following<br/>  following.push(req.profile._id)<br/>  try {<br/>    let posts = await Post.find({postedBy:{ $in : req.profile.following }})<br/>                          .populate('comments.postedBy', '_id name')<br/>                          .populate('postedBy', '_id name')<br/>                          .sort('-created')<br/>                          .exec()<br/>    res.json(posts)<br/>  } catch(err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>In the query to the Post collection, we find all the posts that have <kbd>postedBy</kbd> user references that match the current user's followings and the current user. The posts that are returned will be sorted by the <kbd>created</kbd> timestamp, with the most recent post listed first. Each post will also contain the <kbd>id</kbd> and <kbd>name</kbd> of the user who created the post and of the users who left comments on the post. Next, we will fetch this API in the frontend <kbd>Newsfeed</kbd> component and render the list details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching Newsfeed posts in the view</h1>
                </header>
            
            <article>
                
<p>We will use the Newsfeed API in the frontend to fetch the related posts and display these posts in the Newsfeed view. First, we will add a fetch method to make a request to the API, as shown in the following code.</p>
<p><kbd>client/post/api-post.js</kbd>:</p>
<pre>const listNewsFeed = async (params, credentials, signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/posts/feed/'+ params.userId, {<br/>      method: 'GET',<br/>      signal: signal,<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      }<br/>    }) <br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This is the fetch method that will load the posts that are rendered in <kbd>PostList</kbd>, which is added as a child component to the <kbd>Newsfeed</kbd> component. So, this fetch needs to be called in the <kbd>useEffect</kbd> hook in the <kbd>Newsfeed</kbd> component, as shown in the following code.</p>
<p><kbd><span>mern-social/client/post/Newsfeed.js</span></kbd>:</p>
<pre>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>    <strong>listNewsFeed</strong>({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, signal).then((data) =&gt; {<br/>      if (data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        setPosts(data)<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/><br/>  }, [])</pre>
<p>This will retrieve the list of posts from the backend and set it to the state of the <kbd>Newsfeed</kbd> component to initially load the posts that are rendered in the <kbd>PostList</kbd> component, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-962 image-border" src="assets/644c9140-8d5b-497a-b6f5-bb399df82d20.png" style="width:31.08em;height:43.33em;"/></div>
<p>The implementation of how the individual post details are rendered in this list will be discussed later in this chapter. In the next section, we will render this same <kbd>PostList</kbd> for the <kbd>Profile</kbd> component and render the posts that are shared by a specific user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing posts by user in Profile</h1>
                </header>
            
            <article>
                
<p>The implementation of getting a list of posts created by a specific user and showing it in <kbd>Profile</kbd> will be similar to what we discussed in the previous section <span>regarding listing posts in the Newsfeed.</span> First, we will set up an API on the server that queries the Post collection and returns posts from a specific user to the <kbd>Profile</kbd> view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API for posts by a user</h1>
                </header>
            
            <article>
                
<p>To retrieve posts that have been shared by a specific user, we need to add a route endpoint that will receive <span>the request for these posts </span>and respond accordingly to the requesting client- side.</p>
<p>On the backend, we will define another post-related route that will receive a query to return posts by a specific user, as follows.</p>
<p><kbd><span>mern-social/server/routes/post.routes.js</span></kbd>:</p>
<pre>router.route('/api/posts/by/:userId')<br/>    .get(authCtrl.requireSignin, postCtrl.listByUser)</pre>
<p>The <kbd>listByUser</kbd> controller method in <kbd>post.controller.js</kbd> will query the Post collection to find posts that have a matching reference in the <kbd>postedBy</kbd> field to the user specified in the <kbd>userId</kbd> param in the route. <span>The </span><kbd>listByUser</kbd><span> controller method will look as follows.</span></p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const listByUser = async (req, res) =&gt; {<br/>  try {<br/>    let posts = await Post.find({postedBy: req.profile._id})<br/>                          .populate('comments.postedBy', '_id name')<br/>                          .populate('postedBy', '_id name')<br/>                          .sort('-created')<br/>                          .exec()<br/>    res.json(posts)<br/>  } catch(err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>This query will return the list of posts that were created by a specific user. We need to call this API from the frontend, which we will do in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching user posts in the view</h1>
                </header>
            
            <article>
                
<p><span>We will use the list-posts-by-user API in the frontend to fetch the related posts and display these posts in the profile view. </span>To use this API, we will add a fetch method to the frontend, as follows.</p>
<p><kbd><span>mern-social/client/post/api-post.js</span></kbd>:</p>
<pre>const listByUser = async (req, res) =&gt; {<br/>  try {<br/>    let posts = await Post.find({postedBy: req.profile._id})<br/>                          .populate('comments.postedBy', '_id name')<br/>                          .populate('postedBy', '_id name')<br/>                          .sort('-created')<br/>                          .exec()<br/>    res.json(posts)<br/>  } catch(err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>This <kbd>fetch</kbd> method will load the required posts for <kbd>PostList</kbd>, which is added to the <kbd>Profile</kbd> view. We will update the <kbd>Profile</kbd> component so that it defines a <kbd>loadPosts</kbd> method that calls the <kbd>listByUser</kbd> fetch method. The <kbd>loadPosts</kbd><span> method will look as follows.</span></p>
<p><kbd>mern-social/client/user/Profile.js</kbd>:</p>
<pre>const loadPosts = (user) =&gt; {<br/>  listByUser({<br/>    userId: user<br/>  }, {<br/>    t: jwt.token<br/>  }).then((data) =&gt; {<br/>    if (data.error) {<br/>      console.log(data.error)<br/>    } else {<br/>      setPosts(data)<br/>    }<br/>    })<br/>}</pre>
<p>In the <kbd>Profile</kbd> component, the <kbd>loadPosts</kbd> method will be called with the user ID of the user whose profile is being loaded, after the user details have been fetched from the server <span>in the</span> <kbd>useEffect()</kbd> hook function. The posts that are loaded for the specific user are set to the state and rendered in the <kbd>PostList</kbd> component that's added to the <kbd>Profile</kbd> component. The <kbd>Profile</kbd> component also provides a <kbd>removePost</kbd> function, similar to the <kbd>Newsfeed</kbd> component, as a prop to the <kbd>PostList</kbd> component so that the list of posts can be updated if a post is removed. The resulting <kbd>PostList</kbd> in the <kbd>Profile</kbd> component will render similar to what can be seen in the following screenshot: </p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-963 image-border" src="assets/7458628a-ba76-41c9-b4da-5c97b802928f.png" style="width:32.58em;height:40.17em;"/></div>
<p>The features that list posts that have been shared on MERN Social are now complete. But before these can be tested out, we need to implement the feature that will allow users to create new posts. We will do this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new post</h1>
                </header>
            
            <article>
                
<p>The create new post feature will allow a signed-in user to post a message and optionally add an image to the post by uploading it from their local files. To implement this feature, in the following sections, we will add a create post API endpoint to the backend that allows uploading an image file, as well as add a <kbd>NewPost</kbd> component to the frontend that will utilize this endpoint to let users create new posts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the post API</h1>
                </header>
            
            <article>
                
<p>On the server, we will define an API to create the post in the database, starting by declaring a route to accept a POST request at <kbd>/api/posts/new/:userId</kbd> in <kbd>mern-social/server/routes/post.routes.js</kbd>:</p>
<pre>router.route('/api/posts/new/:userId')<br/>  .post(authCtrl.requireSignin, postCtrl.create)</pre>
<p>The <kbd>create</kbd> method in <kbd><span>post.controller.js</span></kbd> will use the <kbd>formidable</kbd> module to access the fields and the image file, if any, as we did for the user profile photo update. <span>The </span><kbd>create</kbd><span> controller method will look as follows.</span></p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const create = (req, res, next) =&gt; {<br/>  let form = new formidable.IncomingForm()<br/>  form.keepExtensions = true<br/>  form.parse(req, async (err, fields, files) =&gt; {<br/>    if (err) {<br/>      return res.status(400).json({<br/>        error: "Image could not be uploaded"<br/>      })<br/>    }<br/>    let post = new Post(fields)<br/>    post.postedBy= req.profile<br/>    if(files.photo){<br/>      post.photo.data = fs.readFileSync(files.photo.path)<br/>      post.photo.contentType = files.photo.type<br/>    }<br/>    try {<br/>      let result = await post.save()<br/>      res.json(result)<br/>    } catch (err) {<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>    }<br/>  })<br/>}</pre>
<p>Similar to the profile photo upload, the photo that's uploaded with a new post will be stored in the <kbd>Post</kbd> document in binary format. We need to add a route to retrieve and return this photo to the frontend, which we will do next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving a post's photo</h1>
                </header>
            
            <article>
                
<p>To retrieve the uploaded photo, we will also set up a <kbd>photo</kbd> route endpoint that, on request, will return the photo associated with a specific post. The photo URL route will be defined with the other post-related routes, as follows.</p>
<p><kbd><span>mern-social/server/routes/post.routes.js</span></kbd>:</p>
<pre>router.route('/api/posts/photo/:postId').get(postCtrl.photo)</pre>
<p>The <kbd>photo</kbd> controller will return the <kbd>photo</kbd> data stored in MongoDB as an image file. This is defined as follows.</p>
<p><kbd><span>mern-social/</span><span>server/controllers/post.controller.js</span></kbd>:</p>
<pre>const photo = (req, res, next) =&gt; {<br/>    res.set("Content-Type", req.post.photo.contentType)<br/>    return res.send(req.post.photo.data)<br/>}</pre>
<p>Since the photo route uses the <kbd>:postID</kbd> parameter, we will set up a <kbd>postByID</kbd> controller method to fetch a specific post by its ID before returning it to the photo request. We will add the <kbd>param</kbd> call to <kbd>post.routes.js</kbd>, as shown in the following code.</p>
<p><kbd><span>mern-social/server/routes/post.routes.js</span></kbd>:</p>
<pre>  router.param('postId', postCtrl.postByID)</pre>
<p><kbd>postByID</kbd> will be similar to the <kbd>userByID</kbd> method, and it will attach the post retrieved from the database to the request object so that it can be accessed by the <kbd>next</kbd> method. <span>The </span><kbd>postByID</kbd><span> method is defined as follows.</span></p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const postByID = async (req, res, next, id) =&gt; {<br/>  try{<br/>    let post = await Post.findById(id)<br/>                         .populate('postedBy', '_id name')<br/>                         .exec()<br/>    if (!post)<br/>      return res.status('400').json({<br/>        error: "Post not found"<br/>      })<br/>    req.post = post<br/>    next()<br/>  }catch(err){<br/>    return res.status('400').json({<br/>      error: "Could not retrieve use post"<br/>    })<br/>  }<br/>}</pre>
<p><span>The attached post data in this implementation will also contain the ID and name of the </span><kbd>postedBy</kbd><span> user reference since we are invoking <kbd>populate()</kbd>. In the next section, we will add a fetch method to access this API endpoint in the frontend.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching the create post API in the view</h1>
                </header>
            
            <article>
                
<p>We will update <kbd>api-post.js</kbd> by adding a <kbd>create</kbd> method to make a <kbd>fetch</kbd> call to the create API. The <kbd>create</kbd> fetch method will look as follows.</p>
<p><kbd>mern-social/client/post/api-post.js</kbd>:</p>
<pre>const create = async (params, credentials, post) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/posts/new/'+ params.userId, {<br/>      method: 'POST',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: post<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This method, like the user <kbd>edit</kbd> fetch method, will send a multipart form submission using a <kbd>FormData</kbd> object that will contain the text field and the image file. Finally, we are ready to integrate this create new post feature in the backend with a frontend component that will allow users to compose a post and submit it to the backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making the NewPost component</h1>
                </header>
            
            <article>
                
<p>The <kbd>NewPost</kbd> component that we added in the <kbd>Newsfeed</kbd> component will allow users to compose a new post containing a text message and, optionally, an image, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-964 image-border" src="assets/d1b1fe4e-5e34-411b-9da4-376ab005a012.png" style="width:14.67em;height:11.25em;"/></div>
<p><span>The <kbd>NewPost</kbd> component will be a standard form with a</span> Material-UI <span><kbd>TextField</kbd> and a file upload button, as implemented in <kbd>EditProfile</kbd>, that takes the values and sets them in a <kbd>FormData</kbd> object to be passed in the call to the <kbd>create</kbd> fetch method on post submission. Post submission will invoke the following <kbd>clickPost</kbd> method.</span></p>
<p><kbd>mern-social/client/post/NewPost.js</kbd>:</p>
<pre>const clickPost = () =&gt; {<br/>    let postData = new FormData()<br/>    postData.append('text', values.text)<br/>    postData.append('photo', values.photo)<br/>    create({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, postData).then((data) =&gt; {<br/>      if (data.error) {<br/>        setValues({...values, error: data.error})<br/>      } else {<br/>        setValues({...values, text:'', photo: ''})<br/>        props.addUpdate(data)<br/>      }<br/>    })<br/>}</pre>
<p>The <kbd>NewPost</kbd> component is added as a child component in the <kbd>Newsfeed</kbd> and given the <kbd>addUpdate</kbd> method as a prop, as we discussed earlier. On successful post creation, the form view is emptied and <kbd>addUpdate</kbd> is executed so that the post list in the <kbd>Newsfeed</kbd> is updated with the new post. In the next section, we will add the <kbd>Post</kbd> component in order to display each post and its details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Post component</h1>
                </header>
            
            <article>
                
<p>Post details in each post will be rendered in the <kbd>Post</kbd> component, which will receive the post data as props from the <kbd>PostList</kbd> component, as well as the <kbd>onRemove</kbd> prop, which needs to be applied if a post is deleted. In the following sections, we will look at the different parts of the Post interface and how to implement each.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Layout</h1>
                </header>
            
            <article>
                
<p>The <kbd>Post</kbd> component layout will have a header showing details of the poster, the content of the post, an actions bar with a count of likes and comments, and a comments section, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-965 image-border" src="assets/31db151a-6054-4cf7-8461-a1e8a9f43bd8.png" style="width:26.58em;height:17.58em;"/></div>
<p>Next, we will look into the implementation details of the header, content, actions, and comments sections of this Post component. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Header</h1>
                </header>
            
            <article>
                
<p>The header will contain information such as the name, avatar, and link to the profile of the user who posted, as well as the date the post was created. The code to display these details in the header section will be as follows.</p>
<p><kbd>mern-social/client/post/Post.js</kbd>:</p>
<pre>&lt;CardHeader<br/>   avatar={<br/>      &lt;Avatar src={'/api/users/photo/'+props.post.postedBy._id}/&gt;<br/>   }<br/>   action={ props.post.postedBy._id === auth.isAuthenticated().user._id &amp;&amp;<br/>              &lt;IconButton onClick={deletePost}&gt;<br/>                &lt;DeleteIcon /&gt;<br/>              &lt;/IconButton&gt;<br/>          }<br/>   title={&lt;Link to={"/user/" + props.post.postedBy._id}&gt;{props.post.postedBy.name}&lt;/Link&gt;}<br/>   subheader={(new Date(props.post.created)).toDateString()}<br/>   className={classes.cardHeader}<br/>/&gt;</pre>
<p>The header will also conditionally show a <kbd>delete</kbd> button if the signed-in user is viewing their own post. This header section will be above the main content section, which is discussed next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content</h1>
                </header>
            
            <article>
                
<p>The content section will show the text of the post and the image if the post contains a photo. <span>The code to display these details in the content section will be as follows.</span></p>
<p><kbd><span>mern-social/client/post/Post.js</span></kbd>:</p>
<pre>&lt;CardContent className={classes.cardContent}&gt;<br/>  &lt;Typography component="p" className={classes.text}&gt; <br/>    {props.post.text} <br/>  &lt;/Typography&gt;<br/>  {props.post.photo &amp;&amp; <br/>    (&lt;div className={classes.photo}&gt;<br/>       &lt;img className={classes.media}<br/>            src={'/api/posts/photo/'+ props.post._id}/&gt;<br/>    &lt;/div&gt;)<br/>  }<br/>&lt;/CardContent&gt;</pre>
<p>The image is loaded by adding the photo API to the <kbd>src</kbd> attribute in the <kbd>img</kbd> tag if the given post contains a photo. Followed by this content section is the actions section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Actions</h1>
                </header>
            
            <article>
                
<p>The actions section will contain an interactive <kbd>"like"</kbd> option with a display of the total number of likes on the post and a comment icon with the total number of comments on the post. <span>The code to display these actions will be as follows.</span></p>
<p><kbd><span>mern-social/client/post/Post.js</span></kbd>:</p>
<pre>&lt;CardActions&gt;<br/>   { values.like<br/>       ? &lt;IconButton onClick={clickLike} className={classes.button} <br/>                     aria-label="Like" color="secondary"&gt;<br/>            &lt;FavoriteIcon /&gt;<br/>         &lt;/IconButton&gt;<br/>       : &lt;IconButton onClick={clickLike} className={classes.button} <br/>                     aria-label="Unlike" color="secondary"&gt;<br/>            &lt;FavoriteBorderIcon /&gt;<br/>         &lt;/IconButton&gt; } &lt;span&gt;{values.likes}&lt;/span&gt;<br/>         &lt;IconButton className={classes.button} <br/>                     aria-label="Comment" color="secondary"&gt;<br/>            &lt;CommentIcon/&gt;<br/>         &lt;/IconButton&gt; &lt;span&gt;{values.comments.length}&lt;/span&gt;<br/>&lt;/CardActions&gt;</pre>
<p>We will discuss the implementation of the "like" button later in this chapter. The details of the likes for each post are retrieved within the <kbd>post</kbd> object that's received in the props.</p>
<p>In the Post component, the final section will display the comments that have been left on the given post. We'll discuss this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comments</h1>
                </header>
            
            <article>
                
<p>The comments section will contain all the comment-related elements in the <kbd>Comments</kbd> component and will get <kbd>props</kbd> such as the <kbd>postId</kbd> and the <kbd>comments</kbd> data, along with a <kbd>state</kbd> updating method that can be called when a comment is added or deleted in the <kbd>Comments</kbd> component.</p>
<p>The comments section will be rendered in the view with the following code.</p>
<p><kbd><span>mern-social/client/post/Post.js</span></kbd>:</p>
<pre>&lt;Comments postId={props.post._id} <br/>         comments={values.comments} <br/>          updateComments={updateComments}/&gt;</pre>
<p>The implementation of this <kbd>Comments</kbd> component will be detailed later in this chapter. These four sections make up the individual post view that we implemented in the <kbd>Post</kbd> component, which is rendered in <kbd>PostList</kbd> component. Each post's header also shows a <kbd>delete</kbd> button to the creator of the post. We will implement this remove post functionality next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a post</h1>
                </header>
            
            <article>
                
<p>The <kbd>delete</kbd> button is only visible if the signed-in user and <kbd>postedBy</kbd> user are the same for the specific post being rendered. For the post to be deleted from the database, we will have to set up a delete post API in the backend which will also have a fetch method in the frontend that will be applied when <kbd>delete</kbd> is clicked. The route for the delete post API endpoint will be as follows.</p>
<p><kbd>mern-social/server/routes/post.routes.js</kbd>:</p>
<pre>router.route('/api/posts/:postId')<br/>      .delete(authCtrl.requireSignin, <br/>                postCtrl.isPoster, <br/>                  postCtrl.remove)</pre>
<p><span>The delete route will check for authorization before calling <kbd>remove</kbd> on the post by ensuring the authenticated user and <kbd>postedBy</kbd> user are the same users</span><span>. </span><span>The <kbd>isPoster</kbd> method, which is implemented in the following code, checks whether the signed-in user is the original creator of the post before executing the <kbd>next</kbd> method.</span></p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const isPoster = (req, res, next) =&gt; {<br/>  let isPoster = req.post &amp;&amp; req.auth &amp;&amp;<br/>  req.post.postedBy._id == req.auth._id<br/>  if(!isPoster){<br/>    return res.status('403').json({<br/>      error: "User is not authorized"<br/>    })<br/>  }<br/>  next()<br/>}</pre>
<p>The rest of the implementation for the delete API with a <kbd>remove</kbd> controller method and fetch method for the frontend are the same as for the other API implementations. The important difference here, in the delete post feature, is the call to the <kbd>onRemove</kbd> update method in the <kbd>Post</kbd> component when delete succeeds. The <kbd>onRemove</kbd> method is sent as a prop from either <kbd>Newsfeed</kbd> or <kbd>Profile</kbd> to update the list of posts in the state when the delete is successful.</p>
<p>The following <kbd>deletePost</kbd> method, which is defined in the <kbd>Post</kbd> component, is called when the <kbd>delete</kbd> button is clicked on a post.</p>
<p><kbd><span>mern-social/client/post/Post.js</span></kbd>:</p>
<pre>const deletePost = () =&gt; { <br/>    remove({<br/>      postId: props.post._id<br/>    }, {<br/>      t: jwt.token<br/>    }).then((data) =&gt; {<br/>      if (data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        <strong>props.onRemove(props.post)</strong><br/>      }<br/>    })<br/>}</pre>
<p><span>This method makes a fetch call to the delete post API and on success, updates the list of posts in the state by executing the <kbd>onRemove</kbd> method, which is received as a prop from the parent component.</span></p>
<p>This wraps up the implementation of the Post CRUD features in the backend and the frontend. However, we have not completed the features that will allow MERN Social users to interact with these posts. In the next section, we will add the ability to like posts and comment on posts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with Posts</h1>
                </header>
            
            <article>
                
<p>A core feature of any social media platform is the ability for users to interact with shared content. For the posts that are created in the MERN Social application, we will add the options to like and leave comments on individual posts.</p>
<p>To complete the implementation of this feature, first, we will have to modify the backend so that we can add API endpoints that update an existing post with details of who liked the post and details of comments left on the post.</p>
<p>Then, in the frontend, we will have to modify the UI so that users can like and leave a comment on a post.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Likes</h1>
                </header>
            
            <article>
                
<p>The like option in the <kbd>Post</kbd> component's action bar section will allow the user to like or unlike a post, and also show the total number of likes for the post. To record a "like", we will have to set up like and unlike APIs that can be called in the view when the user interacts with the action bar that's rendered in each post.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Like API</h1>
                </header>
            
            <article>
                
<p>The like API will be a PUT request that will update the <kbd>likes</kbd> array in the <kbd>Post</kbd> document. The request will be received at the <kbd>api/posts/like</kbd> route, which is defined as follows.</p>
<p><kbd><span>mern-social/server/routes/post.routes.js</span></kbd>:</p>
<pre>  router.route('/api/posts/like')<br/>    .put(authCtrl.requireSignin, postCtrl.like)</pre>
<p>In the <kbd>like</kbd> controller method, the post ID that's received in the request body will be used to find the specific <kbd>Post</kbd> document and update it by pushing the current user's ID to the <kbd>likes</kbd> array, as shown in the following code.</p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const like = async (req, res) =&gt; {<br/>  try {<br/>    let result = await Post.findByIdAndUpdate(req.body.postId, <br/>                                {<strong>$push</strong>: {likes: req.body.userId}}, <br/>                                {new: true})<br/>    res.json(result)<br/>  } catch(err) {<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>  }<br/>}</pre>
<p>To use this API, a fetch method called <kbd>like</kbd> will be added to <kbd>api-post.js</kbd>, which will be used when the user clicks the <kbd>like</kbd> button. The <kbd>like</kbd><span> fetch is defined as follows.</span></p>
<p><kbd>mern-social/client/post/api-post.js</kbd>:</p>
<pre>const like = async (params, credentials, postId) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/posts/like/', {<br/>      method: 'PUT',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: JSON.stringify({userId:params.userId, postId: postId})<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>Similarly, in the next section, we will also implement an unlike API endpoint so that a user can unlike a previously liked post.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Unlike API</h1>
                </header>
            
            <article>
                
<p>The <kbd>unlike</kbd> API will be implemented similar to the like API, with its own route. This will be declared as follows.</p>
<p><kbd><span>mern-social/server/routes/post.routes.js</span></kbd>:</p>
<pre>  router.route('/api/posts/unlike')<br/>    .put(authCtrl.requireSignin, postCtrl.unlike)</pre>
<p>The <kbd>unlike</kbd> method in the controller will find the post by its ID and update the <kbd>likes</kbd> array by removing the current user's ID using <kbd>$pull</kbd> instead of <kbd>$push</kbd>. The <kbd>unlike</kbd> controller method will look as follows.</p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const unlike = async (req, res) =&gt; {<br/>  try {<br/>    let result = await Post.findByIdAndUpdate(req.body.postId, <br/>                                {<strong>$pull</strong>: {likes: req.body.userId}}, <br/>                                {new: true})<br/>    res.json(result)<br/>  } catch(err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>The unlike API will also have a corresponding fetch method, similar to the <kbd>like</kbd> method in <kbd>api-post.js</kbd>.</p>
<p>These APIs will be called when the user interacts with the like button in the view. But whether the like button should allow a like or an unlike action needs to be determined first. We will take a look at this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking if a post has been liked and counting likes</h1>
                </header>
            
            <article>
                
<p>When the <kbd>Post</kbd> component is rendered, we need to check if the currently signed-in user has liked the post or not so that the appropriate <kbd>like</kbd> option can be shown. The following <kbd>checkLike</kbd> method <span>checks whether the currently signed-in user is referenced in the post's </span><kbd>likes</kbd><span> array or not.</span></p>
<p><kbd>mern-social/client/post/Post.js</kbd>:</p>
<pre>const checkLike = (likes) =&gt; {<br/>  let match = likes.indexOf(jwt.user._id) !== -1<br/>  return match<br/>}</pre>
<p>This <kbd>checkLike</kbd> function can be called while setting the initial value of the <kbd>like</kbd> state variable, which keeps track of whether the current user liked the given post or not. The following screenshot shows how the like button renders when a post has not been liked versus when it has been liked by the current user:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-966 image-border" src="assets/3f2ad7bd-98ee-4dec-9835-2803d7fb2218.png" style="width:42.25em;height:2.83em;"/></div>
<p>The <kbd>like</kbd> value that's set in the state using the <kbd>checkLike</kbd> method can be used to render a heart outline button or a full heart button. A heart outline button will render if the user has not liked the post; clicking it will make a call to the <kbd>like</kbd> API, show the full heart button, and increment the <kbd>likes</kbd> count. The full heart button will indicate the current user has already liked this post; clicking this will call the <kbd>unlike</kbd> API, render the heart outline button, and decrement the <kbd>likes</kbd> count.</p>
<p>The <kbd>likes</kbd> count is also set initially when the <kbd>Post</kbd> component mounts and props are received by setting the <kbd>likes</kbd> value to the state with <kbd>props.post.likes.length</kbd>, as shown in the following code.</p>
<p><kbd>mern-social/client/post/Post.js</kbd>:</p>
<pre> const [values, setValues] = useState({<br/>    like: checkLike(props.post.likes),<br/>    likes: props.post.likes.length,<br/>    comments: props.post.comments<br/>  })</pre>
<p>The likes-related values are updated again when a "like" or "unlike" action takes place, and the updated post data is returned from the API call. Next, we will look at how to handle these clicks on the like button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling like clicks</h1>
                </header>
            
            <article>
                
<p>To handle clicks on the <kbd>like</kbd> and <kbd>unlike</kbd> buttons, we will set up a <kbd>clickLike</kbd> method that will call the appropriate fetch method based on whether it is a "like" or "unlike" action, and then update the state of the <kbd>like</kbd> and <kbd>likes</kbd> count for the post. This <kbd>clickLike</kbd> method will be defined as follows.</p>
<p><kbd>mern-social/client/post/Post.js</kbd>:</p>
<pre>  const clickLike = () =&gt; {<br/>    let callApi = values.like ? unlike : like<br/>    const jwt = auth.isAuthenticated()<br/>    callApi({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, props.post._id).then((data) =&gt; {<br/>      if (data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        setValues({...values, <strong>like: !values.like</strong>, <br/><strong>                              likes: data.likes.length</strong>})<br/>      }<br/>    })<br/>  }</pre>
<p>Which of the like or unlike API endpoints will be called on a click depends on the value of the <kbd>like</kbd> variable in the state. Once the chosen API endpoint is called successfully, the values are updated in the state so that they can be reflected in the view.</p>
<p>This completes the likes feature implementation, complete with backend APIs integrated with the frontend to enable liking and unliking a given post. Next, we will add the comments feature to complete the social media application features we had set out for MERN Social. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comments</h1>
                </header>
            
            <article>
                
<p>The comments section in each post will allow signed-in users to add comments, see the list of comments, and delete their own comments. Any changes to the comment list, such as a new addition or removal, will update the comments, as well as the comment count in the action bar section of the <kbd>Post</kbd> component. The resulting comments section can be seen in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-967 image-border" src="assets/1f58c1be-b6e1-4aff-acbd-7eb189a20eac.png" style="width:18.00em;height:17.00em;"/></div>
<p>To implement a functional comments section, we will update the backend with the corresponding comment and uncomment API endpoints, and also create this <kbd>Comments</kbd> component so that it integrates with the backend update.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a comment</h1>
                </header>
            
            <article>
                
<p>When a user adds a comment, the <kbd>Post</kbd> document will be updated in the database with the new comment. First, we need to implement an API that receives the comment details from the client- side and updates the <kbd>Post</kbd> document. Then, we need to create the UI in the frontend, which allows us to compose a new comment and submit it to the backend API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Comment API</h1>
                </header>
            
            <article>
                
<p>To implement the add comment API, we will set up a <kbd>PUT</kbd> route as follows to update the post.</p>
<p><kbd><span>mern-social/server/routes/post.routes.js</span></kbd>:</p>
<pre>router.route('/api/posts/comment')<br/>    .put(authCtrl.requireSignin, postCtrl.comment)</pre>
<p>The <kbd>comment</kbd> controller method, which is defined in the following code, will find the relevant post to be updated by its ID and push the comment object that's received in the request body to the <kbd>comments</kbd> array of the post.</p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const comment = async (req, res) =&gt; {<br/>  let comment = req.body.comment<br/>  comment.postedBy = req.body.userId<br/>  try {<br/>    let result = await Post.findByIdAndUpdate(req.body.postId, <br/>                                   {<strong>$push</strong>: {comments: comment}}, <br/>                                   {new: true})<br/>                            .populate('comments.postedBy', '_id name')<br/>                            .populate('postedBy', '_id name')<br/>                            .exec()<br/>    res.json(result)<br/>  } catch(err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>In the response, the updated post object will be sent back with details of the <kbd>postedBy</kbd> users populated in the post and in the comments.</p>
<p>To use this API in the view, we will set up a fetch method in <kbd>api-post.js</kbd>, which takes the current user's ID, the post ID, and the <kbd>comment</kbd> object from the view, and sends it with the add comment request. The <kbd>comment</kbd> fetch method will look as follows.</p>
<p><kbd><span>mern-social/client/post/api-post.js</span></kbd>:</p>
<pre>const comment = async (params, credentials, postId, comment) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/posts/comment/', {<br/>      method: 'PUT',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: JSON.stringify({userId:params.userId, postId: postId, <br/>                            comment: comment})<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>We can use this fetch method in the UI when the user submits a new comment, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing something in the view</h1>
                </header>
            
            <article>
                
<p>The <em>add comment</em> section in the <kbd>Comments</kbd> component will allow the signed-in user to type in the comment text:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-968 image-border" src="assets/df6466bd-209c-469e-b3c4-6533606272c1.png" style="width:14.25em;height:3.17em;"/></div>
<p>This will contain an avatar showing the user's photo and a text field, which will add the comment when the user presses the <em>Enter</em> key. This add comment section will be rendered in the view with the following code.</p>
<p><kbd>mern-social/client/post/Comments.js</kbd>:</p>
<pre>&lt;CardHeader<br/>    avatar={<br/>            &lt;Avatar className={classes.smallAvatar} <br/>               src=  {'/api/users/photo/'<br/>                  +auth.isAuthenticated().user._id}/&gt;<br/>           }<br/>    title={ &lt;TextField<br/>                onKeyDown={addComment}<br/>                multiline<br/>                value={text}<br/>                onChange={handleChange}<br/>                placeholder="Write something ..."<br/>                className={classes.commentField}<br/>                margin="normal"<br/>                /&gt;<br/>          }<br/>              className={classes.cardHeader}<br/>/&gt;</pre>
<p>The text will be stored in the state when the value changes, and on the <kbd>onKeyDown</kbd> event, the <kbd>addComment</kbd> method will call the <kbd>comment</kbd> fetch method if the <em>Enter</em> key is pressed. The <em>Enter</em> key corresponds to <kbd>keyCode</kbd> 13, as shown in the following code.</p>
<p><kbd><span>mern-social/client/post/Comments.js</span></kbd>:</p>
<pre>const addComment = (event) =&gt; {<br/>    if(event.keyCode == 13 &amp;&amp; event.target.value){<br/>      event.preventDefault()<br/>      <strong>comment</strong>({<br/>        userId: jwt.user._id<br/>      }, {<br/>        t: jwt.token<br/>      }, props.postId, {text: text}).then((data) =&gt; {<br/>        if (data.error) {<br/>          console.log(data.error)<br/>        } else {<br/>          setText('')<br/>          props.updateComments(data.comments)<br/>        }<br/>      })<br/>    }<br/>}</pre>
<p>The <kbd>Comments</kbd> component receives the <kbd>updateComments</kbd> method (as discussed in the previous section) as a prop from the <kbd>Post</kbd> component. This will be executed when the new comment is added in order to update the comments list and the comment count in the Post view. The part of <kbd>Comments</kbd> that lists all the comments for the post will be added in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing comments</h1>
                </header>
            
            <article>
                
<p>The <kbd>Comments</kbd> component receives the list of comments for the specific post as props from the <kbd>Post</kbd> component. Then, it iterates over the individual comments to render the details of the commenter and the comment content. This view is implemented with the following code.</p>
<p><kbd><span>mern-social/client/post/Comments.js</span></kbd>:</p>
<pre>{ props.comments.map((item, i) =&gt; {<br/>            return &lt;CardHeader<br/>                      avatar={<br/>                        &lt;Avatar className={classes.smallAvatar} <br/>                          src={'/api/users/photo/'+item.postedBy._id}/&gt;<br/>                      }<br/>                      title={<strong>commentBody(item)</strong>}<br/>                      className={classes.cardHeader}<br/>                      key={i}/&gt;<br/>            })<br/>}</pre>
<p><kbd>commentBody</kbd> renders the content, including the name of the commenter linked to their profile, the comment text, and the date of comment creation. <kbd>commentBody</kbd> is defined as follows.</p>
<p><kbd><span>mern-social/client/post/Comments.js</span></kbd>:</p>
<pre>const commentBody = item =&gt; {<br/>      return (<br/>        &lt;p className={classes.commentText}&gt;<br/>          &lt;Link to={"/user/" + item.postedBy._id}&gt;<br/>              {item.postedBy.name} &lt;/Link&gt;&lt;br/&gt;<br/>          {item.text}<br/>          &lt;span className={classes.commentDate}&gt;<br/>            { (new Date(item.created)).toDateString()} |<br/>            { auth.isAuthenticated().user._id === item.postedBy._id &amp;&amp;<br/>              &lt;Icon onClick={deleteComment(item)} <br/>                    className={classes.commentDelete}&gt;delete&lt;/Icon&gt; }<br/>          &lt;/span&gt;<br/>        &lt;/p&gt;<br/>      )<br/>}</pre>
<p><kbd>commentBody</kbd> will also render a delete option for the comment if the <kbd>postedBy</kbd> reference of the comment matches the currently signed-in user. We will look at the implementation of this comment deletion option in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a comment</h1>
                </header>
            
            <article>
                
<p>Clicking the delete button in a comment will update the post in the database by removing the comment from the <kbd>comments</kbd> array in the corresponding post. The delete button can be seen underneath the comment shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-969 image-border" src="assets/b800d038-e4bb-4704-b12e-ebdc6a44226e.png" style="width:16.00em;height:8.92em;"/></div>
<p>To implement this delete comment feature, we need to add an uncomment API to the backend and then use it in the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Uncomment API</h1>
                </header>
            
            <article>
                
<p>We will implement an <kbd>uncomment</kbd> API at the following PUT route.</p>
<p><kbd><span>mern-social/server/routes/post.routes.js</span></kbd>:</p>
<pre>router.route('/api/posts/uncomment')<br/>    .put(authCtrl.requireSignin, postCtrl.uncomment)</pre>
<p>The <kbd>uncomment</kbd> controller method will find the relevant post by ID and pull the comment with the deleted comment's ID from the <kbd>comments</kbd> array in the post, as implemented in the following code.</p>
<p><kbd><span>mern-social/server</span><span>/controllers/post.controller.js</span></kbd>:</p>
<pre>const uncomment = async (req, res) =&gt; {<br/>  let comment = req.body.comment<br/>  try{<br/>    let result = await Post.findByIdAndUpdate(req.body.postId, <br/>                                  {<strong>$pull</strong>: {comments: {_id: comment._id}}},  <br/>                                  {new: true})<br/>                          .populate('comments.postedBy', '_id name')<br/>                          .populate('postedBy', '_id name')<br/>                          .exec()<br/>    res.json(result)<br/>  } catch(err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>The updated post will be returned in the response, similar to the comment API.</p>
<p>To use this API in the view, we will also set up a fetch method in <kbd>api-post.js</kbd>, similar to the <kbd>addComment</kbd> fetch method, that takes the current user's ID, the post ID, and the deleted <kbd>comment</kbd> object to send with the <kbd>uncomment</kbd> request. Next, we will learn how to use this fetch method when the delete button is clicked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing a comment from the view</h1>
                </header>
            
            <article>
                
<p>When a comment's delete button is clicked by the commenter, the <kbd>Comments</kbd> component will call the <kbd>deleteComment</kbd> method to fetch the <kbd>uncomment</kbd> API and update the comments, along with the comment count, when the comment is successfully removed from the server. T<span>he </span><kbd>deleteComment</kbd><span> method is defined as follows.</span></p>
<p><kbd><span>mern-social/client/post/Comments.js</span></kbd>:</p>
<pre>const deleteComment = comment =&gt; event =&gt; {<br/>    <strong>uncomment</strong>({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, props.postId, comment).then((data) =&gt; {<br/>      if (data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        <strong>props.updateComments(data.comments)</strong><br/>      }<br/>    })<br/>  }</pre>
<p>On successfully removing a comment from the backend, the <kbd>updateComments</kbd> method that's sent in the props from the <kbd>Post</kbd> component will be invoked. This will update the state of the <kbd>Post</kbd> component to update the view. This will be discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comment count update</h1>
                </header>
            
            <article>
                
<p>The <kbd>updateComments</kbd> method, which will allow the <kbd>comments</kbd> and comment count to be updated when a comment is added or deleted, is defined in the <kbd>Post</kbd> component and passed as a prop to the <kbd>Comments</kbd> component. <span>The </span><kbd>updateComments</kbd><span> method will look as follows:</span></p>
<p><kbd><span>mern-social/client/post/Post.js</span></kbd>:</p>
<pre>const updateComments = (comments) =&gt; {<br/>    setValues({...values, comments: comments})<br/>}</pre>
<p>This method takes the updated list of comments as a parameter and updates the state that holds the list of comments rendered in the view. The initial state of comments in the <kbd>Post</kbd> component is set when the <kbd>Post</kbd> component mounts and receives the post data as props. The comments that are set here are sent as props to the <kbd>Comments</kbd> component and used to render the comment count next to the likes action in the action bar of the Post layout, as follows.</p>
<p><kbd><span>mern-social/client/post/Post.js</span></kbd>:</p>
<pre>&lt;IconButton aria-label="Comment" color="secondary"&gt;<br/>  &lt;CommentIcon/&gt;<br/>&lt;/IconButton&gt; &lt;span&gt;{<strong>values.comments.length</strong>}&lt;/span&gt;</pre>
<p>This relationship between the comment count in the <kbd>Post</kbd> component and the comments that are rendered and updated in the <kbd>Comments</kbd> component gives a simple demonstration of how changing data is shared among nested components in React to create dynamic and interactive user interfaces. </p>
<p>The MERN Social application now contains the set of features we defined earlier for the application. Users are able to update their profiles with a photo and description, follow each other on the application, and create posts with photos and text, as well as like and comment on posts. The implementations shown here can be tuned and extended further to add more features in order to utilize the revealed mechanisms of working with the MERN stack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The MERN Social application we developed in this chapter demonstrated how the MERN stack technologies can be used together to build out a fully-featured and functioning web application with social media features. </p>
<p><span>We began by updating the user feature in the skeleton application to allow anyone with an account on MERN Social to add a description about themselves, as well as upload a profile picture from their local files. In the implementation of uploading a profile picture, we explored how to upload multipart form data from the client, then receive it on the server to store the file data directly in the MongoDB database, and then be able to retrieve it back for viewing.</span></p>
<p>Next, we updated the user feature further to allow users to follow each other on the MERN Social platform. In the user model, we added the capability to maintain arrays of user references to represent lists of followers and followings for each user. Extending this capability, we incorporated follow and unfollow options in the view and displayed lists of followers, followings, and even lists of users not followed yet.</p>
<p>Then, we added the ability to allow users to post content and interact over the content by liking or commenting on the post. On the backend, we set up the Post model and corresponding APIs, which are capable of storing the post content that may or may not include an image, as well as maintaining records of likes and comments that are incurred on a post by any user.</p>
<p>Finally, while implementing the views for the posting, liking, and commenting features, we explored how to use component composition and share changing state values across the components <span>to create complex and interactive views</span>.   </p>
<p>By completing this MERN Social application implementation, we learned how to extend and modify the base application code to grow it into a full-fledged web application according to our desired features. You can apply similar strategies to grow the skeleton application into any real-world application of your choosing.</p>
<p>In the next chapter, we will expand further on these abilities <span>in the MERN stack </span>and unlock new possibilities as we develop an online classroom application by extending the skeleton application.</p>


            </article>

            
        </section>
    </body></html>