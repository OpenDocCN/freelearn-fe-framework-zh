- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Unit Tests in Angular with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*“It works on my machine”* is a phrase that won’t lose its beauty with time.
    It is a shield for many engineers and a nightmare for the quality assurance professionals.
    But honestly, what’s a better way for your application’s robustness than writing
    tests? And when it comes to writing unit tests, my personal favorite is **Jest**.
    That is because it is super-fast, lightweight, and has an easy API to write tests.
    More importantly, it is faster than the Karma and Jasmine setup that comes out
    of the box with Angular. In this chapter, you’ll learn how to configure Jest with
    Angular to run these tests in parallel. You’ll learn how to test components, services,
    and pipes with Jest. You’ll also learn how to mock dependencies for these tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests in Angular with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing global mocks for Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking Angular services using stubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spies on an injected service in a unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking child components and directives using the `ng-mocks` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing even easier tests with Angular CDK component harnesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing components with observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing Angular pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter10](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests in Angular with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a new Angular project comes bundled with a lot of goodness, including
    the configuration and tooling in which to run unit tests with Karma and Jasmine.
    While working with Karma is relatively convenient, many developers find that in
    large-scale projects, the whole testing process becomes much slower if there are
    a lot of tests involved. This is mainly because you can’t run tests in parallel.
    In this recipe, we’ll set up Jest for unit testing in an Angular app. Additionally,
    we’ll migrate existing tests from the Karma syntax to the Jest syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with v16, Angular comes with a developer preview for Jest, and the
    process has become much easier. This recipe targets apps up to Angular v15 and
    covers what we can do in v16 at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-jest-setup`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command in *step 2* is different from the rest of the recipes’ commands
    in this book. This is because the project for this recipe is *not* part of the
    NX workspace we have. It is a standalone Angular app itself; hence, it has different
    commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.1: The ng-jest-setup app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, try to run the test and monitor how much time it takes for the entire
    process to run. Run the command `npm run test:ng-jest-setup` from the workspace
    `root`; within a few seconds, a new Chrome window should open, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.2: The tests’ results with Karma and Jasmine'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Looking at the preceding screenshot, you might say *“Pfffttt, Ahsan, it says
    ‘finished in 0.033s (or something close to it)!’ What else do you want?”* Well,
    that time only covers how long it took Karma to run the tests *in the browser
    after the Chrome window was created*. It doesn’t count the time it took to start
    the process, start the Chrome window, and then load the tests. This could be improved
    by running the Chrome Headless browser for Karma, which requires some configuration.
    However, it is still slower compared to the alternative (Jest). Also, at the time
    of writing this recipe, I’m running this on a Macbook Pro with the M2 Chip, *which
    is fast*. That’s why we’re going to replace it with Jest. Now that you understand
    the issue, in the next section, let’s take a look at the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have an Angular app with a simple `Counter` component. It shows the
    value of the counter and has three action buttons: one of the buttons is to increase
    the value of the counter, one of them is to decrease the value, and another is
    to reset the value. Additionally, there are some tests written with Karma and
    Jasmine, and all of the tests will pass if you run the tests. We’ll start by setting
    up Jest instead. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new Terminal window/tab, and make sure you’re inside the `start/apps/chapter10/ng-jest-setup`
    folder. Once inside, run the following command to install the packages that are
    required to test with Jest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now uninstall Karma and the unwanted dependencies. Now, run the following
    command in your Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the test configuration in the `angular.json` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now create a file to configure Jest for our project. Create a file
    named `jestSetup.ts` inside the project’s folder, and paste the following content
    inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s modify `tsconfig.spec.json` to use Jest instead of Jasmine. After
    the modification, your entire file should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now modify `package.json` to add the `npm` scripts that’ll run the Jest
    tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s wrap up the entire configuration for our Jest tests by adding
    the Jest configuration in the `package.json` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have set everything up, simply run the `test` command from within
    the `ng-jest-setup` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the tests are finished, you should be able to see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.3: The results of the tests with Jest'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Kaboom! You will notice that the entire process of running the tests with Jest
    takes about 6 seconds. It might take longer when you run it for the first time,
    but the subsequent runs should be faster. Now that you know how to configure an
    Angular app to use Jest for unit tests, please refer to the next section for resources
    in which to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bonus: Migrating to Jest in Angular v16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from Angular v16, all you need to do to migrate to Jest (considering
    your project currently uses Karma) is to update the `angular.json` file in the
    project with the following configuration object property hierarchy `your-app >
    architect > test` settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Web Frameworks with Jest: [https://jestjs.io/docs/en/testing-frameworks](https://jestjs.io/docs/en/testing-frameworks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting Started with Jest: [https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moving Angular CLI to Jest: [https://blog.angular.io/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca](https://blog.angular.io/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing global mocks for Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to set up Jest for Angular unit tests.
    There might be some scenarios in which you’d want to use a browser API that might
    not be part of your actual Angular code – for instance, using `LocalStorage` or
    `alert`. In such cases, we need to provide some global mocks for the functions
    that we want to return mock values from. This is so that we can perform tests
    involving them as well. In this recipe, you’ll learn how to provide global mocks
    to Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-jest-global-mocks`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.4: The ng-jest-global-mocks app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we’re using for this recipe uses two global APIs: `window.localStorage`
    and `window.alert`. Note that when the app starts, we get the counter value from
    `LocalStorage`, and then upon increment, decrement, and reset, we store it in
    `LocalStorage`. When the counter value becomes greater than the `MAX_VALUE` or
    lower than the `MIN_VALUE`, we show the alert using the `alert` method. Let’s
    begin the recipe by writing some cool unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll write our test cases to show the alert when the counter value
    goes beyond `MAX_VALUE` and `MIN_VALUE`. Modify the `counter.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you can see that the tests pass but with a bunch of console errors. And
    what if we wanted to check whether the value from `LocalStorage` is being saved
    and retrieved properly?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll create a new test to make sure the `localStorage.getItem` method is called
    to retrieve the last saved value from the `LocalStorageAPI`. Add the test to the
    `counter.component.spec.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that we’re using `it.only` for this test case. This is to ensure that
    we’re only running this test (for now). If you run the tests, you should be able
    to see something like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.5: The test that covers the LocalStorageAPI has failed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice the **Matcher error: received value must be a mock or a spy function**
    message. This is what we’re going to do next, that is, provide a mock.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a file inside the project’s `src` folder, and name the file `jest-global-mocks.ts`.
    Then, add the following code to mock the `LocalStorageAPI`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, import this file into the `src/test-setup.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you rerun the tests, they should pass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add another test to ensure we retrieve the last saved value from `LocalStorage`
    in the component initiation. Modify the `counter.component.spec.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s make sure that we save the counter value to `LocalStorage` whenever
    we trigger the `increment`, `decrement`, or `reset` methods. Update the `counter.component.spec.ts`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Awesomesauce! You’ve just learned how to provide global mocks to Jest for testing.
    Please refer to the next section to understand how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jest provides a way to define global mocks for tests. It comes with a lot of
    built-in functions to define test suites and test cases, along with assertion
    functions. Here is an example of a simple Jest test suite for a `sum` function
    that adds two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Jest also has a way to use a particular file to set up Jest in projects. When
    working with different frameworks, the file (or the filename) can be different,
    but the purpose would still be the same, that is, to define global configuration
    via this Jest setup file. In our NX workspace, we already have the Jest files
    in each project under the `src` folder, and the filename is usually `test-setup.ts`.
    One of the common approaches to define global mocks is to create a new file containing
    the mocks and then import it into the `test-setup.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we use the `Object.defineProperty` method in the `window` object
    to provide a mock implementation for the `LocalStorage` object, and we do similar
    for the `window.alert` mock. This is actually the same for any API that is not
    implemented in the **JSDOM**(**JavaScript Document Object Model**). Similarly,
    you can provide a global mock for each API that you use in your tests. Notice
    that in the `value` property, we create a new instance of the `LocalStorageMock`
    class using the `new` keyword. Essentially, this is one way to define mocks. We
    create the `LocalStorageMock` class, and in that, we have a private property named
    `storage` that mimics the `localStorage` object. We have also defined the `getItem`
    and `setItem` methods in there so that we can set values to this storage and get
    values from it. Notice that we do not have the implementations of the `removeItem`
    and `clear` methods that we have in the actual `localStorage` API. We don’t have
    to have them because we’re not using these methods in our actual code.
  prefs: []
  type: TYPE_NORMAL
- en: In the `should call the localStorage.getItem method on component init` test,
    we simply spy on the `localStorage` object’s `getItem` method, call the `ngOnInit`
    method ourselves, and then expect it to have been called. *Easy peasy!*
  prefs: []
  type: TYPE_NORMAL
- en: In the `should retrieve the last saved value from localStorage on component
    init` test, we save a value in the `localStorage` object for the counter value
    as `12`, using the `setItem` method. Essentially, calling the `setItem` method
    calls our mock implementation method and not the actual `localStorage` API’s `setItem`
    method. Notice that, here, we *do not* spy on the `getItem` method; this is because,
    later on, we want the value of the component’s `counter` property to be `12`.
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we spy on a method, remember that any statements in the actual function
    will no longer be executed. This is why we do not spy on the `getItem` method
    in the preceding test. If we do so, the `getItem` method from the mock implementation
    will not return anything. Therefore, our expected value for the counter property
    will not be `12`.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, if you have to rely on the outcome of a function’s implementation,
    or the statements executed within a function, do not spy on that function and
    replace such a function with `jest.fn().mockReturnValue(123);`. This ensures we
    can check if the function is called but also with a return value that can be used
    by the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: 'PS: I always end up learning this the hard way after debugging and bashing
    my head for a while.'
  prefs: []
  type: TYPE_NORMAL
- en: The final test is an easy one. In the `should save the new counterValue to localStorage
    on increment, decrement and reset` test, we spy on the `setItem` method. Then,
    we manually set the value of the counter property each time before we run the
    `increment`, `decrement`, and `reset` methods respectively. Additionally, we expect
    the `setItem` method to have been called with the right arguments to save the
    value to the store. Note that we do not check the store’s value after saving it.
    As I mentioned earlier, since we have spied on the `setItem` method, its internal
    statement won’t trigger and the value won’t be saved; therefore, we can’t retrieve
    the saved value afterward.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Jest documentation for `setupFiles`: [https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manual Mocks with Jest: [https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking Angular services using stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s rarely an Angular app that doesn’t have a **Service** created inside
    it. And where overall business logic is concerned, services hold a great deal,
    particularly when it comes to interacting with APIs. In this recipe, you’ll learn
    how to mock services using stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-services-stubs`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.6: The ng-test-services-stubs app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let’s take a
    look at the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the same application as the previous recipe; however, we’ve moved the
    logic of saving and retrieving data from `localStorage` to the `CounterService`
    we’ve created. Now, all the tests are passing. However, what if we wanted to hide/encapsulate
    the logic of where the counter value is stored? Perhaps we want to send a backend
    API call for it. To do this, it makes more sense to test that our `CounterService`''s
    methods are being called instead of checking `localStorage` methods. Let’s follow
    the recipe to provide a mock stub for our service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a folder inside the `src` folder, named `__mocks__`. Inside
    it, create another folder named `services`. Then, again inside this folder, create
    the `counter.service.mock.ts` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, provide the mock service instead of the actual service in the `counter.component.spec.ts`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the preceding change, you should see the following error that says the
    `localStorage.getItem` hasn’t been called. This is because we’re now spying on
    the methods on our mock stub for the service:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.7: localStorage.getItem is not called because of the methods being
    spied on'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, instead of expecting the `localStorage` object’s methods to be called,
    let’s expect our service’s methods to be called in our tests. Update the `counter.component.spec.ts`
    file using the snippet at [https://ng-cookbook.com/s/services-stub-tests](https://ng-cookbook.com/s/services-stub-tests)
    to replace all the tests below the following comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! You now know how to mock services to test components with service dependencies.
    Please refer to the next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Providing stubs for Angular services is already a breeze. This is thanks to
    Angular’s out-of-the-box methods and tooling from the `@angular/core` package,
    especially `@angular/core/testing`. First, we create the stub for our `CounterService`
    and use `jest.fn` for every method within `CounterService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `jest.fn` returns a new, unused mock function that Jest automatically
    spies upon as well. Optionally, we can also pass a mock implementation method
    as a parameter for `jest.fn`. View the following example from the official documentation
    for `jest.fn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once we create the stub, we pass it to the `TestBed` configuration in the provider’s
    array against the `CounterService` – but with the `useValue` property set to the
    `counterServiceMock`. This tells Angular to use our stub as it is for `CounterService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the test where we expect `CounterService.getFromStorage` method to
    be called when the component initiates, we use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding code, we are able to directly use `expect` on `counterServiceMock.getFromStorage`.
    While this isn’t possible in Karma and Jasmine, it is possible with Jest, since
    we’re using `jest.fn` for each underlying method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for a test in which we want to check whether the `getFromStorage` method
    is called and returns a saved value, we first use the `counterServiceMock.getFromStorage.mockReturnValue(12);`
    statement. This ensures that when the `getFromStorage` method is called, it returns
    the value of `12`. Then, we just run the `ngOnInit` method in the test and expect
    that our component’s counter property has now been set to `12`. This means that
    the following things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnInit` calls the `getFromStorage` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getFromStorage` returns the previously saved value (in our case, that’s `12`,
    but in reality, it’ll be fetched from `localStorage`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component’s counter property is set to the retrieved value, which, in our
    case, is `12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, for the final test, we just expect that the `saveToStorage` method of
    our `CounterService` is called in each necessary case. For this, we use the following
    types of `expect` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That’s pretty much about it. Unit tests are fun, aren’t they? Now that you’ve
    understood how it all works, please refer to the next section for some helpful
    resources that you can use for further reading.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The official documentation for `jest.fn`: [https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular’s *Component testing scenarios*: [https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spies on an injected service in a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can provide stubs for your services in the unit tests with Jest, sometimes,
    it might feel like an overhead creating a mock for every new service. Let’s suppose
    that if the service’s usage is limited to one test file, it might make more sense
    to just use spies on the actual injected service. In this recipe, that’s exactly
    what we’re going to do.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-services`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.8: ng-test-services app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running, in the next section, let’s go through the
    steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an application that has a `Counter` component. We can increment, decrement,
    and reset the counter, and the value for the counter changes. The value is also
    stored in the `localStorage`. We have the logic of saving and retrieving data
    from `localStorage` to the `CounterService`. Now, all the tests are passing, but
    we are checking the values in our tests directly from the `localStorage`. What
    if we decided to change the logic of where the counter value is stored? Perhaps
    we want to send a backend API call for it. To do this, it makes more sense to
    test that our `CounterService`''s methods are being called instead of checking
    `localStorage` methods. However, unlike the previous recipe, where we provided
    stubs for our services, we’re going to inject the service directly and will create
    jest spies for the functions from the Angular Service that we want to ensure are
    being called. Let’s follow the recipe to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `counter.component.spec.ts` file. You’ll see a comment that says `//
    replace the tests below`. Let’s replace the first test `should call the localStorage.getItem
    method on component init` below that comment with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run `npm run test` again, you should still see all the tests passing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s replace the test that says `should retrieve the last saved value
    from localStorage on component init` with the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, replace the last test that says `should save the new counterValue
    to localStorage on increment, decrement and reset` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Awesome! With this change, you should see all eight tests passing. Let’s take
    a look at the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe contained a lot of knowledge from the previous recipes of this chapter.
    However, the key highlight is the fact that the `CounterService` class that is
    injected in the component can only be directly mocked using the `jest.spyOn` method.
    This method removes the need to mock every single service separately. In the first
    (replaced) test, we spy on the `getFromStorage` method of the `component.counterService`
    property. This makes it a Jest spy that we can provide to the `expect` block and
    that can run the `expect(component.counterService.getFromStorage).toHaveBeenCalled();`
    statement. In the second test, notice that we not only spy on the `getFromStorage`
    method but also return a mock value, `12`, so that when the `component.ngOnInit`
    method is called, the value returned from the `CounterService` is this mocked
    value, `12`. Hence, the `counter` property is set to 12 and the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last test, we spy on the `saveToStorage` method. Then, every
    time we click `Increment`, `Decrement`, or `Reset`, we expect the spied function
    to be called with the correct value. *Easy peasy!*
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Angular Services: [https://angular.io/guide/testing-services](https://angular.io/guide/testing-services)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking child components and directives using the ng-mocks package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests mostly revolve around testing components, directives, pipes, or services
    in isolation. However, what if your component depends completely on another component
    or directive to work properly, especially in a non-standalone application/component?
    In such cases, you usually provide a mock implementation for the component, but
    that is a lot of work. However, with the `ng-mocks` package, it is super-easy.
    In this recipe, we’ll learn an advanced example of how to use `ng-mocks` for a
    parent component that depends on a child component to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-ng-mocks`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_09.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.9: ng-test-ng-mocks app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you run the command `npm run test ng-test-ng-mocks` from the workspace root,
    you’ll see that not all of our tests pass. Additionally, there are a bunch of
    errors on the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Error during unit tests mentioning app-version-control component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are using an app with `NgModule`, i.e., *not a standalone app*.
    This is to demonstrate how to work in such situations. Let’s go through the recipe
    to mock the respective components using the `ng-mocks` package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s install the `ng-mocks` package within our project. To do this,
    run the following command from your project root in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll try to fix the tests for the `App` component. To only run specific
    tests based on a string regex, we can use the -`t` parameter with the test command.
    Run the following command, and after it runs, press the -`t` key to provide the
    regex `"``App"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can see that we only run the tests for `AppComponent`, and they fail
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_11.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.11: Only running specific tests'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the error shown in *Figure 10.10*, we’ll import `VersionControlComponent`
    into the `TestBed` definition inside the `app.component.spec.ts` file. This is
    so that our test environment also knows the missing `<app-version-control>` component.
    To do this, modify the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you rerun the tests for `AppComponent`, you’ll see some fresher and newer
    errors. Progress! But since we have the `Version Control` component dependent
    on another component, the tests don’t pass. We’ll discuss why this is in more
    detail in the *How it works...* section. However, to fix this, let’s follow the
    next steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead of providing the `VersionControlComponent` directly, we need to mock
    it, since we don’t really care about it for the tests for `AppComponent`. One
    way would be to use `CUSTOM_ELEMENT_SCHEMA` in the `TestBed`''s configuration
    to tell the test bed that we don’t really care about the `VersionControlComponent`
    inside the tests for `AppComponent`. However, we’re going to use a `MockComponent`
    from `ng-mocks` to mock the component, achieving the same outcome. To do this,
    update the `app.component.spec.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Boom! Problem solved. Run the tests again, just for the `AppComponent`, and
    you should see them all pass as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_12.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.12: Passing all of the tests for App component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the *a* key in the terminal to run all tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s talk about the tests for the `Version Control` component. This depends
    on the `VC Logs` component. Let’s mock the `VCLogsComponent` class like a pro
    this time, using the `MockBuilder` and `MockRender` methods, so we can get rid
    of the errors during the tests. After the update, the `version-control.component.spec.ts`
    file should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run `npm run test` now, you should see all of the tests passing. Let’s
    write another test in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`VersionControlComponent` uses `VCLogsComponent` as a child component in the
    template. Additionally, it provides the `vName` property as `@Input()` to `VCLogsComponent`,
    via the `[vName]` attribute. We can check whether the input’s value is set correctly.
    To do so, update the `version-control.component.spec.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now going to modify the `vc-logs.component.spec.ts` file to make sure
    that when the `vName` changes inside the `VCLogsComponent`, we have a new log
    created inside the `logs` array. To do so, modify the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Boom! We have implemented some interesting tests by using the `ng-mocks` package.
    I absolutely love it every time I use it (mostly with components that are part
    of an `NgModule`, as `standalone` components don’t have this issue). Now that
    we’ve finished the recipe, in the next section, let’s take a look at how it all
    works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of interesting things that we have covered in this recipe.
    First, to avoid any errors on the console complaining about unknown components,
    we use the `MockComponent` method from the `ng-mocks` package, declaring the components
    we’re dependent on as mocks. Notice that when a component is mocked, it loses
    its functionality, as all the methods become `spy` functions. That is absolutely
    the simplest thing we can achieve with the `ng-mocks` package. However, we will
    move on to an advanced situation, which I will admit is sort of an unconventional
    approach, that is, testing the `@Input` properties and `@Output` emitters of the
    child components in the parent component in order to test an entire flow. This
    is what we do for the tests of `VersionControlComponent` by checking the value
    of an `@Input` property `vName`. Again, this is mostly useful for non-standalone
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we removed the usage of the `@angular/core/testing` package completely
    from the `version-control.component.spec.ts` file. This is because we’re no longer
    using `TestBed` to create the test environment. Instead, we use the `MockBuilder`
    method from the `ng-mocks` package to build the test environment for our `VersionControlComponent`.
    The `MockBuilder` method has several overloads, the one we used to take the target
    component as the first argument, and the `NgModule` this component is a part of
    as the second argument. The module and everything inside it are mocked. This makes
    it so much easier to test the component in isolation. You also have methods like
    `exclude` that you can chain, like `MockBuilder(MyComponent, MyModule).exclude(OtherComponent)`,
    to not mock specific components. However, we didn’t need to do that in this recipe.
    We also wrote an interesting test for the `VersionControlComponent`, that is,
    getting a child component (`VCLogsComponent`) using the `ngMocks.find` method
    and checking if the child component’s `@Input()` is set appropriately when the
    respective property in the parent changes. I call this interesting because now
    we’re getting away from the entire notion of “testing components in isolation,”
    as we are now checking a property of another component than the component we’re
    actually testing. In general, you would want to mock the child components or any
    dependency that a component has. With that said, the approach in your team might
    be different. If you have a strong case for not mocking the child component and
    then checking its properties as shown in the recipe, now you know how. Please
    refer to the next section for further resources to read.
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don’t use a spy on the `VersionControlComponent.addNewReleaseLog`
    method. This is because if we do so, that function will become a Jest spy function.
    Therefore, it’ll lose its internal functionality. In return, it’ll never add the
    new log to the `releaseLogs` array, and none of our tests will pass. You can try
    it out for fun.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ng-mocks` package’s `mock` method: [https://ng-mocks.sudo.eu/api/MockBuilder#mock](https://ng-mocks.sudo.eu/api/MockBuilder#mock)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ng-mocks` official documentation: [https://ng-mocks.sudo.eu](https://ng-mocks.sudo.eu)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing even easier tests with Angular CDK component harnesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing tests for components, there might be scenarios where you’d want
    to interact with the DOM elements. Now, this can already be achieved by using
    the `fixture.debugElement.query` method to find the element, using a selector
    and then triggering events on it. However, that means maintaining the DOM queries
    for different platforms, knowing the identifiers of all the selectors, and then
    exposing all of that in the tests. And this is even worse if we’re talking about
    an Angular library. It certainly isn’t necessary for each developer who interacts
    with my library to know all the element selectors in order to write tests. Only
    the author of the library should know that much to respect encapsulation. Luckily,
    we have the component harnesses from the Angular CDK team, which were released
    with Angular 9 along with the IVY compiler. And they’ve led by example, by providing
    component harnesses for the Angular material components as well. In this recipe,
    you’ll learn how to create your own component harnesses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-cdk-harness`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_13.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.13: The ng-test-cdk-harness app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have the app running, let’s move on to the next section to follow
    the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have our favorite Angular version control app that allows us to create release
    logs. Also, we have tests written already, including tests that interact with
    the DOM element to validate a few use cases. Let’s follow the recipe to use component
    harnesses instead, discovering how easy it becomes to use in the actual tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following command to run the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll create a `component harness` for the `VersionControlComponent`.
    Let’s create a new file inside the `version-control` folder, and name it `version-control.component.harness.ts`.
    Then, add the following code inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to set up the harness environment for our tests for `VersionControlComponent`.
    For this, we’ll use `TestbedHarnessEnvironment` from the Angular CDK. Update the
    `version-control.component.spec.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s write some methods in our `VersionControlComponentHarness` class
    to get the relevant information. We’ll use these methods in the later steps. Update
    the `version-control.component.harness.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll work on our first test, named `should show error on wrong version
    number input`, with the component harness. Update the `version-control.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you run `npm run test`, you should see all of the tests passing, which
    means our first test with the component harness works. Woo-hoo!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the final test, we also need a component harness for `VCLogsComponent`.
    Let’s quickly create it. Add a new file inside the `vc-logs` folder, named `vc-logs.component.harness.ts`,
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s modify our final tests in the `version-control.component.spec.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Voilà! That’s some amazing testing right there using the Angular CDK component
    harnesses. If you run the tests now, you should see them all passing. Now that
    you’ve finished the recipe, please refer to the next section to learn how this
    works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All right! That was a cool recipe, and I enjoyed writing it too. The key factor
    of this recipe is the `@angular/cdk/testing` package. If you have worked with
    `e2e` tests using Protractor before, this is a similar concept to the **Pages**
    or **Page Objects** (**POs**) in Protractor. The first thing we do is to create
    a component harness for both the `VCLogsComponent` and the `VersionControlComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we import the `ComponentHarness` class from `@angular/cdk/testing`
    for both component harnesses. Then, we extend our custom classes, called `VersionControlComponentHarness`
    and `VCLogsComponentHarness`, from the `ComponentHarness` class. Essentially,
    this is the correct way to author component harnesses. Did you notice the static
    property called `hostSelector`? We need this property for every component harness
    class that we create, and the value is always the selector of the target element/component.
    This ensures that when we load this harness into the test environment, the environment
    can find the host element in the DOM – for which we’re creating the component
    harness. In our component harness class, we use the `this.locatorFor` method to
    find elements within the host component. The `locateFor` method takes a single
    argument as the **CSS selector** of the element to be found, returning an `AsyncFactoryFn`.
    This means the returned value is a function that we can use later to get the required
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the `VersionControlComponentHarness` class, we find the submit button and
    the version number input using the *protected* methods `getSubmitButton` and `getAppVersionInput`,
    respectively. All of these are of the `AsyncFactoryFn` type, as mentioned earlier.
    We have these methods set as *protected* because we don’t want the developers
    who write the unit tests to access or care about the information of the DOM elements.
    This makes it much easier for everyone to write tests without worrying about the
    internal implementation of accessing the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to mention here is that when we call the `locatorFor` method
    or the `locatorForAll` method, we get back a `Promise` with the `TestElement`
    item or a `Promise` with a list of `TestElement` items, respectively. Each `TestElement`
    item has a bunch of handy methods, such as `click`, `sendKeys`, `focus`, `blur`,
    `getProperty`, `text`, and more. These methods are what we’re interested in, since
    we use them behind the scenes to interact with the DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about configuring the test environment. In the `version-control.component.spec.ts`
    file, we set up the environment to use component harnesses for both `VCLogsComponent`
    and `VersionControlComponent`. The `TestbedHarnessEnvironment` element is the
    key element here. We use the `TestbedHarnessEnvironment.harnessForFixture` method
    first. This is because we are writing tests for the `VersionControlComponent`,
    and we also want the harness of the same component as root. Therefore, the `harnessForFixture`
    method makes sense here. This method takes the `fixture` as the first argument
    and the `harness` class as the second. Then, we also use the `loader` method of
    the `TestbedHarnessEnvironment` class to get an instance of the `HarnessLoader`.
    This loader can then get the harness of the `VCLogsComponent`, i.e., get the instance
    of the `VCLogsComponentHarness` class. Note that the fixture is what we get in
    the test environment using the `TestBed.createComponent(VersionControlComponent)`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the tests, we use the `harnessLoader.getHarness` method by providing
    the harness class as an argument. This enables the test environment to find the
    DOM element associated with the `hostSelector` property of the harness class.
    Additionally, we get back the instance of the component harness that we can use
    further in the test.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding components in the DOM with component harnesses: [https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom](https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API for component harness authors: [https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors](https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing responses from HTTP calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re building an Angular application, it is very likely that you’ll work
    with HTTP calls inside the app at some point. For instance, you could be fetching
    data from a third-party API or just making APIs to your own server. In either
    case, it becomes slightly difficult to test applications that have HTTP calls
    in action. In this recipe, we’re going to learn how to create unit-tests with
    HTTP calls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-http-resp`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_14.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.14: The ng-test-http-resp app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s also run the tests. Right now, the test for the `UserService`, which
    fetches the `HTTP` response, doesn’t pass. You should see an output similar to
    *Figure 10.15*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_15.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.15: Test failing for the UserService'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app and tests running locally, in the next section, let’s
    take a look at the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll write one single test that checks if the service’s `getUser` method returns
    the correct data. If you open the `UserService`, you’ll notice that the service
    fetches the users using an HTTP call and then modifies the data to add the `fullAddress`
    property. Our test should expect the same to happen. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we’ll fix the failing test. We’ll add the `HttpClientModule`
    class to the test in the `imports` array. Update the `user.service.spec.ts` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as soon as you run the `npm run test` command, you’ll see that the tests
    pass now as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_16.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.16: Tests passing for the UserService as well'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll import the `HttpClientTestingModule` in the `user.service.spec.ts`
    file to be able to use it to intercept HTTP calls. Modify the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create a controller using the `HttpTestingController` class from the
    same `@angular/common/http/testing` package. We’ll use this controller later to
    expect and intercept the HTTP calls. Update the `user.service.spec.ts` file as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll write a test (finally). We’ll intercept the HTTP call to `/assets/users.json`
    using the `httpTestingController`, and then we will compare the result with our
    expected data. Update the `user.service.ts` file by adding a test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll add an `afterEach` hook in the tests to verify that there are no pending
    requests after our test. Let’s add it to the `user.service.spec.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s populate the mock data (the `mockUsers` array) with two users. Since
    we’re using `req.flush(mockUsers)`, the HTTP call will be intercepted, and this
    data (`mockUsers` array) will be returned from it as a response. Replace the test
    `it('should return expected user data (HttpClient called once)'` in the file `user.service.spec.ts`
    with the snippet from [https://ng-cookbook.com/s/ng-test-http-mock-users](https://ng-cookbook.com/s/ng-test-http-mock-users).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, update the test further to make the http call, using the `getUsers`
    method, and see if we can expect the transformed data. Update the `user.service.spec.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the tests, you should see them all pass as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_17.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.17: All of the tests pass'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! You now know how to work with `HttpTestingController` to test services
    that have methods, using HTTP calls. Although there’s still a lot to learn about
    testing HTTP calls and Observables in Angular, the purpose of this recipe was
    to keep everything simple and sweet.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have finished the recipe, please refer to the next section to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hero of this recipe is the `HttpClientTestingModule`, which allows us to
    use an instance of `HttpTestingController`. The `HttpTestingController` makes
    it easy to intercept the HTTP calls in our code and allows us to return a specific
    response. This makes it easier for us to not have our Angular services tested
    with real HTTP calls, which can be expensive. Another benefit of this approach
    to mocking the response is always having the same response object to work with.
    In our case, our `getUsers` method not only made an HTTP call but also transformed
    data, using the `map` operator from `RxJs`. Therefore, we used an array of mocked
    users and expected the result from the `getUsers` method to have the transformed
    data, i.e., including the `fullAddress` property containing the right data. You
    can see in the test that we use the `HttpTestingController.expectOne` method,
    telling our test that there should be only one request when we run the test. We
    expect the method of that request to be `GET`. Then, we expect that the returned
    value from the `getUsers` method has an array of users containing the `fullAddress`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular testing component scenarios: [https://docs.angular.lat/guide/testing-components-scenarios](https://docs.angular.lat/guide/testing-components-scenarios)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpTestingController` docs: [https://angular.io/api/common/http/testing/HttpTestingController](https://angular.io/api/common/http/testing/HttpTestingController)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing Angular pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, pipes are the easiest thing to test in an Angular application.
    Why? Well, this is because they’re (supposed to be) pure functions that return
    the same result based on the same set of inputs. In this recipe, we’ll write some
    tests for a simple pipe in an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-pipes`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_18.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.18: The ng-test-pipes app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have a simple recipe that takes two inputs – the digit and the max
    factor value. Based on these inputs, we show a multiplication table. We already
    have the `MultTablePipe` that is working fine according to our business logic.
    We’ll now write some unit tests to validate our inputs and expected outputs, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write our first custom test for `MultTablePipe`. We’ll make sure it returns
    an empty array when we have an invalid value for the `digit` input. Replace the
    whole `mult-table.pipe.spec.ts` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s write another test to validate the `limit` input so that we also return
    an empty array if it is invalid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll write a test to validate the output of the pipe’s `transform` method
    when both the `digit` and `limit` inputs are valid. In this scenario, we should
    get back the array containing the multiplication table. Write another test as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right now, within the app, we have the possibility to provide decimal digits
    for the `limit` input. For instance, we can write `2.5` as the max factor in the
    input. To handle this, we use a `Math.floor` in `MultTablePipe` to round it down
    to the lower number. Let’s write a test to make sure this works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Easy peasy!* Writing tests for Angular pipes is so straightforward that I
    love it. We could call this the power of pure functions. Now that you’ve finished
    the recipe, please refer to the next section for more informative links.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Angular pipes official documentation: [https://angular.io/guide/testing-pipes](https://angular.io/guide/testing-pipes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test Angular Pipes With Services: [https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576](https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularCookbook2e](Chapter_10.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1388317275422265.png)'
  prefs: []
  type: TYPE_IMG
