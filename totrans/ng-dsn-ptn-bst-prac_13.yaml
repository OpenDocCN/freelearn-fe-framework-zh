- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: The Angular Renaissance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 的文艺复兴
- en: Our applications need to continually evolve, and to meet this need, the Angular
    framework and its ecosystem also continue to evolve.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要不断地进化，为了满足这一需求，Angular 框架及其生态系统也在不断进化。
- en: In this chapter, we will learn about the latest features of Angular. While many
    of them are still in the developer preview phase, it is important for us to get
    a glimpse of what the future holds for this incredible framework.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 Angular 的最新功能。虽然其中许多功能仍处于开发者预览阶段，但对我们来说，了解这个令人难以置信的框架的未来前景非常重要。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Updating your project with the Angular CLI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 更新你的项目
- en: Using a new way to create templates – control flow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一种新的创建模板的方式——控制流
- en: Improving the user experience using the `defer` command
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `defer` 命令改进用户体验
- en: Creating transitions between pages – view transactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面之间创建过渡——视图事务
- en: Simplifying application states – Angular Signals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化应用程序状态——Angular 信号
- en: By the end of this chapter, you will have learned how to stay up to date with
    future versions of the framework and how to update your project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何跟上框架的未来版本，以及如何更新你的项目。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，你需要以下内容：
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18 或更高版本 ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch13](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch13).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在 [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch13](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch13)
    获取。
- en: During the course of this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的学习过程中，请记住使用 `npm start` 命令运行 `gym-diary-backend` 文件夹中的应用程序的后端。
- en: Updating your project with the Angular CLI
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 更新你的项目
- en: The Angular framework is continually evolving with new features and optimizations,
    but to help communities and developers keep organized and their applications up
    to date, the Angular team uses semantic versioning to number their releases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 框架在不断地进化，带来新的功能和优化，但为了帮助社区和开发者保持有序，并确保他们的应用程序保持最新，Angular 团队使用语义化版本号来编号他们的发布。
- en: 'A semantic version number is composed of three parts and each part has the
    following representation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 语义化版本号由三个部分组成，每个部分具有以下表示形式：
- en: '**Major**: A number that is increased every time there is a change in the framework,
    which in turn requires us to change something in our application so that it continues
    to work, also known as a **breaking change**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大版本**：每当框架发生变化时，这个数字都会增加，这反过来又要求我们在应用程序中做出一些更改，以便它能够继续工作，也称为**破坏性变更**'
- en: '**Minor**: A number that is increased when the new version has a new functionality
    that we can use, but if we don’t use it, we don’t need to change our application'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小版本**：当新版本有我们可以使用的新功能时，这个数字会增加，但如果我们不使用它，我们不需要更改我们的应用程序'
- en: '**Patch**: A number that is increased when there is a correction to the framework
    and we do not need to change our code; this is widely used for versions that have
    security corrections'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补丁版本**：当框架有修正时，我们不需要更改我们的代码；这通常用于有安全修正的版本'
- en: In this book, we are working with version 16.2.0 of Angular, and the next version
    will be 17.0.0, which will bring new functionality and also some breaking changes.
    While the the term “breaking changes” is used, we should note that the Angular
    team has taken more and more care with these changes and currently, they only
    affect very specific cases that the vast majority of applications are not affected
    by.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用的是 Angular 的 16.2.0 版本，下一个版本将是 17.0.0，它将带来新的功能，同时也可能有一些破坏性变更。虽然使用了“破坏性变更”这个术语，但我们应注意的是，Angular
    团队对这些变更越来越谨慎，目前，它们只影响非常特定的案例，而绝大多数应用程序不会受到影响。
- en: 'In addition to rigorous versioning, the Angular team takes care to release
    major releases every six months, allowing the team to plan application updates.
    You may ask, should I always update the Angular version of my application? The
    answer is yes, and here are some reasons:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了严格的版本控制之外，Angular 团队还注意每隔六个月发布主要版本，这使得团队能够规划应用程序的更新。你可能会问，我是否应该总是更新我的应用程序的
    Angular 版本？答案是肯定的，以下是一些原因：
- en: Every new version brings internal improvements to the framework that improve
    the rendering engines, which can make your application faster and the build time
    and the bundle size smaller and more optimized
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个新版本都会为框架带来内部改进，这可以改善渲染引擎，使你的应用程序更快，构建时间和包大小更小，更优化。
- en: New features give you more possibilities to create better experiences for your
    users
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新功能为你提供了更多可能性，以创造更好的用户体验
- en: It provides security updates and framework vulnerability fixes
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供安全更新和框架漏洞修复
- en: It is important to highlight that the Angular team is committed to making corrections
    (long-term support) for up to two major versions before the current one, which
    means that using old versions of Angular can leave your application vulnerable
    to new security breaches. However, the task of updating the Angular version of
    an application is not that complex as the Angular CLI helps to automate the entire
    process. Let’s update our project to version 17 of Angular to use the new features
    in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，Angular 团队致力于在当前版本之前为最多两个主要版本提供修正（长期支持），这意味着使用旧版本的 Angular 可能会使你的应用程序容易受到新的安全漏洞的攻击。然而，更新应用程序的
    Angular 版本的任务并不复杂，因为 Angular CLI 有助于自动化整个过程。让我们将我们的项目更新到 Angular 的第 17 版，以使用本章中的新功能。
- en: 'On your operating system’s command line, in the `gym-diary` project folder,
    use the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的操作系统命令行中，在 `gym-diary` 项目文件夹中，使用以下命令：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this command, the Angular CLI will update all Angular packages from the
    `package.json` file. Furthermore, it will analyze all your code in search of situations
    where it needs to be changed due to a breaking change. Also, if possible, it will
    update your code for you. If this is not possible, it will indicate what type
    of correction should be made, but again this only happens in very specific corner
    cases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，Angular CLI 将从 `package.json` 文件更新所有 Angular 包。此外，它将分析你的所有代码，寻找由于破坏性更改而需要更改的情况。如果可能，它将为你更新代码。如果不可能，它将指示应进行何种类型的更正，但这种情况仅发生在非常特定的角落案例中。
- en: After the update is complete, to ensure that the application continues to work
    after the process, we can run unit tests and end-to-end tests. For more details
    about the tests, see [*Chapter 10*](B19562_10.xhtml#_idTextAnchor264), *Design
    for Tests:* *Best Practices*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更新完成后，为确保应用程序在处理过程中继续工作，我们可以运行单元测试和端到端测试。有关测试的更多详细信息，请参阅[*第 10 章*](B19562_10.xhtml#_idTextAnchor264)，“为测试而设计：最佳实践”。
- en: With our updated project, we can explore the new syntax for HTML templates,
    which we will see in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们更新的项目，我们可以探索 HTML 模板的新的语法，我们将在下一节中看到。
- en: Using a new way to create templates – control flow
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用创建模板的新方法——控制流
- en: Since version 2 of the framework, the HTML template syntax has remained relatively
    stable and without much evolution. By using custom properties, we can evaluate
    conditions and iterate over lists and other forms of flow control to create visualization
    logic in components. The `*ngIf`, `*ngFor`, and `*ngSwitch` directives are used
    to improve the developer experience, internally generating the elements in the
    HTML. You can read more about this in [*Chapter 4*](B19562_04.xhtml#_idTextAnchor141),
    *Components* *and Pages*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自框架的第二个版本以来，HTML 模板语法相对稳定，没有太多变化。通过使用自定义属性，我们可以在组件中评估条件并遍历列表和其他形式的流程控制，以创建可视化逻辑。`*ngIf`、`*ngFor`
    和 `*ngSwitch` 指令用于提高开发者体验，内部生成 HTML 中的元素。你可以在[*第 4 章*](B19562_04.xhtml#_idTextAnchor141)、“组件”和“页面”中了解更多信息。
- en: Starting with version 17, the Angular team introduced a new form of control
    flow in HTML. The syntax in this version is in developer preview, which means
    that it is stable for production but may have changes in future versions. Let’s
    refactor our code to use the syntax and see the difference in practice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 17 开始，Angular 团队引入了 HTML 中的新形式的控制流。这个版本的语法处于开发者预览状态，这意味着它对生产是稳定的，但未来版本可能会有所变化。让我们重构我们的代码以使用这种语法，并看看实际中的差异。
- en: 'In the `app.component.html` file, we will change the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.component.html` 文件中，我们将更改以下内容：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we can notice the first new structure of the new control flow, `if`. Using
    the command in the HTML template with the `@` symbol, we apply the conditional
    statement as in TypeScript, evaluating whether the function or variable is true
    or false.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以注意到新的控制流结构中的第一个新结构，即 `if`。使用 HTML 模板中的命令并带有 `@` 符号，我们应用了与 TypeScript
    中的条件语句相同的条件语句，评估函数或变量是否为真或假。
- en: The novelty of the syntax is that we now have the `@else` instruction facilitating
    the chaining of conditionals, without the need to use the `ng-template` directive
    for this purpose.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 语法的新颖之处在于，我们现在有了 `@else` 指令，它简化了条件语句的链式操作，无需使用 `ng-template` 指令来完成此目的。
- en: 'We will refactor the `list-entries.component.html` file as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式重构 `list-entries.component.html` 文件：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we are using the `@for` instruction to replace the `*ngFor`
    directive. We provide the name of the variable that will receive the list iteration,
    in this case, `item`, and the list itself, in this component, named `exerciseList`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `@for` 指令来替换 `*ngFor` 指令。我们提供了将要接收列表迭代的变量名称，在这个例子中是 `item`，以及列表本身，在这个组件中命名为
    `exerciseList`。
- en: In [*Chapter 4*](B19562_04.xhtml#_idTextAnchor141), *Components and Pages*,
    we learned the good practice of using the `trackBy` property of the `*ngFor` directive
    to improve list rendering performance. This good practice is now mandatory in
    the new `@for` syntax, and in this case, it is even simpler as we can simply pass
    the attribute that Angular should check.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B19562_04.xhtml#_idTextAnchor141) *组件和页面* 中，我们学习了使用 `*ngFor` 指令的
    `trackBy` 属性来提高列表渲染性能的良好实践。现在，这种良好实践在新 `@for` 语法中是强制性的，并且在这种情况下，它甚至更简单，因为我们只需简单地传递
    Angular 应该检查的属性。
- en: A new element is the `@empty` instruction, which indicates what should be shown
    if the list in question is empty.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 新的元素是 `@empty` 指令，它指示如果相关的列表为空时应该显示什么。
- en: The new `@for` instruction, in addition to improving the development experience,
    is also 90% faster, according to the Angular team, when rendering lists than the
    previous solution. That’s because control statements aren’t just sugar syntax
    for directives; the template engine has been redesigned and the instructions manipulate
    Angular’s internal DOM rendering elements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `@for` 指令，除了提高开发体验外，根据 Angular 团队的说法，在渲染列表时比之前的解决方案快 90%，这是因为控制语句不仅仅是指令的糖语法；模板引擎已经被重新设计，指令操作
    Angular 的内部 DOM 渲染元素。
- en: 'Finally, let’s refactor the `new-entry-form-reactive.component.html` file as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们按照以下方式重构 `new-entry-form-reactive.component.html` 文件：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this file, we are replacing the conditionals that evaluate form errors with
    the `@if` statement. For the `@for` instruction that we use to render the list
    of exercises, we can notice that the use of the `async` pipe remains very similar
    to the `*ngFor` directive, and we added `track` to further improve the rendering
    of the list. Finally, we are using the `@else if` command to chain two conditionals.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们正在用 `@if` 语句替换评估表单错误的条件语句。对于我们用来渲染练习列表的 `@for` 指令，我们可以注意到，使用 `async`
    管道与 `*ngFor` 指令非常相似，并且我们添加了 `track` 以进一步提高列表的渲染。最后，我们使用 `@else if` 命令来链式操作两个条件语句。
- en: We can note that we do not need to perform any additional configuration to use
    the flow control syntax because this functionality is fully compatible with the
    previous mechanics and they can coexist in the same project and even in the same
    file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，我们不需要进行任何额外的配置来使用流程控制语法，因为这项功能与之前的机制完全兼容，它们可以在同一个项目中，甚至在同一个文件中共存。
- en: 'The Angular team even created a migration command in the Angular CLI, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 团队甚至在 Angular CLI 中创建了一个迁移命令，如下所示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will see a new possibility that this template refactoring
    provides to our application, the option of lazy loading components in our HTML
    templates.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到这种模板重构为我们应用程序提供的新可能性，即在 HTML 模板中懒加载组件的选项。
- en: Improving the user experience using the defer command
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 defer 命令改进用户体验
- en: The main intention behind the new HTML template flow control syntax was to have
    a new basis for building new possibilities in the framework’s templates. The first
    new feature made possible by the syntax is the `defer` instruction, with which
    it is possible to lazy load components directly from the HTML template.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 HTML 模板流程控制语法的背后主要意图是提供一个新基础，用于在框架的模板中构建新的可能性。通过这种语法，第一个新的功能是 `defer` 指令，它使得直接从
    HTML 模板中懒加载组件成为可能。
- en: We learned in [*Chapter 2*](B19562_02.xhtml#_idTextAnchor081), *Organizing Your
    Application*, that the best practice is to separate your application into functionality
    modules and configure Angular to load these modules in a lazy way. This means
    that the module and its components would only be loaded if the user accessed a
    certain route, resulting in smaller bundles and better performance of your application,
    especially if your user does not have a good internet connection (such as 3G).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B19562_02.xhtml#_idTextAnchor081)中学习了*组织你的应用程序*，最佳实践是将你的应用程序分为功能模块，并配置Angular以懒加载这些模块。这意味着只有当用户访问某个路由时，模块及其组件才会被加载，从而实现更小的包和更好的应用程序性能，特别是如果你的用户没有良好的互联网连接（如3G）。
- en: The `defer` command has the same purpose but instead of working for modules,
    it works for `standalone` components. We studied `standalone` components in [*Chapter
    11*](B19562_11.xhtml#_idTextAnchor285), *Micro Frontend with* *Angular Elements*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`命令具有相同的目的，但它不是为模块工作，而是为`standalone`组件工作。我们在[*第11章*](B19562_11.xhtml#_idTextAnchor285)中学习了*使用Angular
    Elements的微前端*中的`standalone`组件。'
- en: 'We will start our refactoring by transforming the exercise list components
    into a `standalone` component. In the `diary.component.ts` file, make the following
    changes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始重构，将练习列表组件转换为`standalone`组件。在`diary.component.ts`文件中，进行以下更改：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we have included the `standalone` attribute set to `true`
    and added the components it depends on directly using the `imports` attribute.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们包括了将`standalone`属性设置为`true`，并直接使用`imports`属性添加了它所依赖的组件。
- en: 'We will do the same procedure in the `EntryItemComponent` component:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`EntryItemComponent`组件中执行相同的步骤：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this component, in addition to the `standalone` property, we need to add
    the dependency so that the date pipe works. It is necessary to note that the standalone
    component needs to have its dependencies declaratively in the `imports` attribute,
    since it is not linked to any Angular module.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件中，除了`standalone`属性外，我们还需要添加依赖项，以便日期管道能够工作。需要注意的是，`standalone`组件需要在`imports`属性中声明式地包含其依赖项，因为它没有链接到任何Angular模块。
- en: 'To lazy load the template, we will also convert the `NewItemButtonComponent`
    component into a standalone one:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了懒加载模板，我们还将`NewItemButtonComponent`组件转换为`standalone`组件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last component to be converted into a standalone component is `ListEntriesComponent`,
    changing it as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要转换为`standalone`组件的是`ListEntriesComponent`，更改如下：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we added the `EntryItemComponent` dependency to the `import`
    attribute.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`EntryItemComponent`依赖项添加到了`import`属性中。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The unit tests were also adjusted to consider the component dependencies in
    the `TestBed` definition, and you can find the test code in the GitHub repository
    of this chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试也进行了调整，以考虑`TestBed`定义中的组件依赖项，并且你可以在这个章节的GitHub仓库中找到测试代码。
- en: 'The last adjustment must be made in the `DiaryModule` module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的调整必须在`DiaryModule`模块中进行：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we will dynamically load the components that were converted to standalone,
    we have to remove these components from the `declarations` attribute of the module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将动态加载已转换为`standalone`的组件，我们必须从模块的`declarations`属性中删除这些组件。
- en: 'After this preparation, we can use the `defer` command in the `diary.component.html`
    file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此准备之后，我们可以在`diary.component.html`文件中使用`defer`命令：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To use the `defer` command, we must create a block that includes the components
    that we want to lazy load.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`defer`命令，我们必须创建一个包含我们想要懒加载的组件的块。
- en: 'If we run our application and analyze the **Networks** tab, we will notice
    that specific bundles are loaded when the screen is rendered:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的应用程序并分析**网络**选项卡，我们会注意到当屏幕渲染时，会加载特定的包：
- en: '![Figure 12.1 – Lazy-loaded bundle](img/B19562_13_1.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 懒加载包](img/B19562_13_1.jpg)'
- en: Figure 12.1 – Lazy-loaded bundle
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 懒加载包
- en: 'We can see that the effect is similar to the lazy loading of a route module,
    but `defer` has other interesting options. Let’s see this in practice by changing
    our code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，效果类似于路由模块的懒加载，但`defer`有其他有趣的选择。让我们通过更改我们的代码来实际看看：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the `on hover(trigger)` condition, the list is loaded when we hover over
    the `defer` command opens up a range of opportunities for fine-tuning the user
    experience. The `defer` command has the following conditions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`on hover(trigger)`条件，当我们将鼠标悬停在`defer`命令上时，列表会被加载，这为微调用户体验打开了一系列机会。`defer`命令有以下条件：
- en: '`on immediate`: The component will be loaded the moment the screen is rendered.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on immediate`: 组件将在屏幕渲染的瞬间被加载。'
- en: '`on idle`: The component will be loaded on the first call to the browser `requestIdleCallback`
    API. This API allows non-blocking processing in the browser and is the default
    behavior of the `defer` command.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on idle`: 组件将在浏览器`requestIdleCallback` API的第一次调用时被加载。这个API允许浏览器中的非阻塞处理，并且是`defer`命令的默认行为。'
- en: '`on hover(target)`: We can define another interface component and loading will
    occur when the user hovers over this component.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on hover(target)`: 我们可以定义另一个界面组件，当用户悬停在组件上时将发生加载。'
- en: '`on timer(time)`: Allows us to define in milliseconds when the component will
    be loaded after the interface is rendered.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on timer(time)`: 允许我们在界面渲染后以毫秒为单位定义组件将被加载的时间。'
- en: '`on viewport(target)`: When the target component is in the browser’s viewport,
    the child components will be loaded. This behavior is ideal for loading a component
    that is located after the user has scrolled to the end of the page.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on viewport(target)`: 当目标组件位于浏览器视口中时，子组件将被加载。这种行为非常适合在用户滚动到页面底部后加载位于其后的组件。'
- en: '`on interaction(target)`: It has a similar behavior to *on hover*, but it will
    be triggered by some interaction, such as a click.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on interaction(target)`: 它与`on hover`有类似的行为，但它将由某些交互触发，例如点击。'
- en: '`when (condition)`: Allows us to control the loading of the component imperatively,
    through a Boolean attribute, or a function that returns a Boolean.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when (condition)`: 允许我们通过布尔属性或返回布尔值的函数强制控制组件的加载。'
- en: 'Complementing the `defer` command, we have other commands that we can use.
    Returning to our code, we will change it as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 补充`defer`命令，我们还有其他可以使用的命令。回到我们的代码，我们将按以下方式更改它：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These complementary commands have the following functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些补充命令具有以下功能：
- en: '`@loading`: Presents the content of the block while the components of the `defer`
    block are loaded'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@loading`: 在加载`defer`块的组件时，显示该块的内容'
- en: '`@placeholder`: Displays the content of the block, while the components of
    the `defer` block do not start loading, for example, if the user does not hover
    over the given target'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@placeholder`: 在`defer`块的组件未开始加载时显示该块的内容，例如，如果用户没有悬停在指定的目标上'
- en: '`@error`: Displays the content of the block if an error occurs when loading
    the components of the `defer` block'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@error`: 如果在加载`defer`块的组件时发生错误，将显示该块的内容'
- en: There are many possibilities that we have with this `defer` command in our templates,
    and we should explore them to improve our users’ experience. But note that we
    should not lazy load all the components of a screen. We need to use the `defer`
    command on large components or components that are not essential for the page
    we are building.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板中，使用这个`defer`命令有许多可能性，我们应该探索它们以提高用户体验。但请注意，我们不应该懒加载屏幕上的所有组件。我们需要在大型组件或对我们正在构建的页面不是必需的组件上使用`defer`命令。
- en: In the next section, we will explore how to improve the experience of transitions
    between routes in our application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何改善我们应用程序中路由之间转换的体验。
- en: Creating transitions between pages – view transactions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建页面之间的转换 – 视图事务
- en: 'As frontend developers, we need to worry about the technical performance of
    our applications. Small UI details, such as the loading screen that we created
    in [*Chapter 8*](B19562_08.xhtml#_idTextAnchor225), *Improving Backend Integrations:
    the Interceptor Pattern*, improve our users’ perception of the application’s performance.
    One of these UI details is the transition between pages of our application. Instead
    of dry loading from one route to another, we can create an animation that smooths
    this transition, making the user experience more pleasant.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前端开发者，我们需要关注我们应用程序的技术性能。一些小的UI细节，例如我们在[*第8章*](B19562_08.xhtml#_idTextAnchor225)“改进后端集成：拦截器模式”中创建的加载屏幕，可以提高用户对我们应用程序性能的认识。这些UI细节之一是我们应用程序页面之间的转换。我们可以在从一个路由到另一个路由的干燥加载之间创建一个平滑转换的动画，使用户体验更加愉快。
- en: 'Until version 17 of Angular, it was possible to make this animation using the
    standard Angular Animation package that we used earlier in the book, in the toaster
    animation created in [*Chapter 8*](B19562_08.xhtml#_idTextAnchor225), *Improving
    Backend Integrations: the Interceptor Pattern*. The way to create this animation
    is specific to Angular and is not very simple for designers specializing in CSS.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 版本 17 之前，可以使用我们之前在书中使用的标准 Angular 动画包来创建此动画，在 *第 8 章* 中创建的 toaster
    动画，*改进后端集成：拦截器模式*。创建此动画的方法是特定于 Angular 的，并且对于专注于 CSS 的设计师来说并不简单。
- en: 'As of version 17 of Angular, there is support for the `app-routing.module.ts`
    file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Angular 版本 17，对 `app-routing.module.ts` 文件有支持：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We are configuring Angular so that the route mechanisms will use view transitions
    written in CSS with the `enableViewTransitions` property. With just this change,
    we can notice in our application that the transition between pages has a pleasant
    fade-in and fade-out animation. This default animation was created by the Angular
    team to make developers’ lives easier. But we can also customize this animation
    with a little CSS. In the `styles.css` file, we will create the following classes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在配置 Angular，以便路由机制将使用带有 `enableViewTransitions` 属性编写的 CSS 视图过渡。仅通过这一变化，我们就可以在我们的应用程序中注意到页面之间的过渡具有令人愉悦的淡入和淡出动画。这个默认动画是由
    Angular 团队创建的，旨在让开发者的生活更轻松。但我们可以用一点 CSS 来自定义这个动画。在 `styles.css` 文件中，我们将创建以下类：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For CSS animations, we need to define an initial and final state that we want
    the element to be in, in this case, the entire screen. For our example, we define
    a state where the screen goes to the right in the `slide-right` keyframe and goes
    to the left in the `slide-left` keyframe. Finally, we define the keyframes for
    the fade-in and fade-out effects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CSS 动画，我们需要定义一个初始状态和最终状态，我们希望元素处于该状态，在这种情况下，整个屏幕。在我们的示例中，我们定义了一个状态，其中屏幕在
    `slide-right` 关键帧中向右移动，在 `slide-left` 关键帧中向左移动。最后，我们定义了淡入和淡出效果的关键帧。
- en: Note that when we define the transition animation, we completely replace Angular’s
    default transition animation, so we are defining the fade-in and fade-out keyframes
    here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们定义过渡动画时，我们完全替换了 Angular 的默认过渡动画，因此我们在这里定义了淡入和淡出关键帧。
- en: 'To set up the animation, let’s add the following to the `styles.css` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置动画，让我们将以下内容添加到 `styles.css` 文件中：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The View Transitions API creates pseudo-elements in the CSS where we define
    the exit animation of the old page (`::view-transition-old`) and the entrance
    animation of the new page (`::view- transition-old`). In this case, we define
    that the old screen will fade out and move to the left and the new page will fade
    in and slide in from the right.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 视图过渡 API 在 CSS 中创建伪元素，其中我们定义了旧页面的退出动画（`::view-transition-old`）和新页面的进入动画（`::view-transition-old`）。在这种情况下，我们定义旧屏幕将淡出并向左移动，而新页面将淡入并从右侧滑入。
- en: Important note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The View Transitions API was created in 2023 and is being gradually adopted
    by browsers. Go to [https://caniuse.com/](https://caniuse.com/) and check whether
    the browsers your users will use have support for this API.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 视图过渡 API 于 2023 年创建，并正在逐渐被浏览器采用。请访问 [https://caniuse.com/](https://caniuse.com/)
    检查您的用户将使用的浏览器是否支持此 API。
- en: In the next section, we will explore Angular Signals and how we can use it to
    simplify state control in our application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 Angular 信号以及我们如何使用它来简化应用程序中的状态控制。
- en: Simplifying application states – Angular Signals
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化应用程序状态 - Angular 信号
- en: Controlling the state of a frontend application is one of the biggest challenges
    for a developer, as by nature, the interface is dynamic and needs to react to
    various user actions. Angular, with its *stacks included* philosophy, already
    had tools suitable for this task, and we studied in *Chapters 5*, *Angular Services
    and the Singleton Pattern*, and [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity with RxJS*, how to use these tools. However, despite being
    effective, the Angular community and team recognize that they are a bit complex
    for new developers and for simple cases of reactivity in frontend projects. To
    fill this gap, the Angular team introduced, from version 17 onward, a new element
    to the framework, called Signals.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 控制前端应用程序的状态是开发者的一个重大挑战，因为从本质上讲，界面是动态的，需要响应用户的各种操作。Angular以其“包含堆栈”的哲学，已经拥有了适合这项任务的工具，我们在第5章、*Angular服务和单例模式*和[*第9章*](B19562_09.xhtml#_idTextAnchor242)、*使用RxJS探索响应性*中研究了如何使用这些工具。然而，尽管有效，Angular社区和团队认识到，对于新开发者以及前端项目中简单的响应性情况来说，它们可能有点复杂。为了填补这一空白，Angular团队从版本17开始，向框架中引入了一个新元素，称为信号。
- en: According to the Angular documentation, a signal is a wrapper around a value
    that notifies consumers when that value changes. An analogy that you can associate
    with a signal is a cell in a spreadsheet. It can contain a value and we can create
    formulas in other cells that use its value to create other values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Angular文档，信号是一个围绕值的包装器，当该值发生变化时，它会通知消费者。您可以将其与电子表格中的一个单元格相关联的类比。它可以包含一个值，我们可以在其他单元格中创建公式，使用其值来创建其他值。
- en: 'Before refactoring our application, let’s illustrate this with a simpler example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构我们的应用程序之前，让我们用一个更简单的例子来说明这一点：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To create a signal, we use the `signal` function, where we define what type
    of value it will store and declare an initial value for it. A signal can be writable
    or read-only; in this case, the variables `a` and `b` are writable. The variable
    `c` is also a signal but of a specific type, called computed. The computed type
    is, in our analogy of a spreadsheet, a cell that contains a formula where you
    can read the values of other cells to determine its value. Finally, we are reading
    the value of the signal by simply calling it as a function. The result of this
    code snippet is the value `5`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个信号，我们使用 `signal` 函数，其中我们定义它将存储的值的类型，并声明它的初始值。信号可以是可写的或只读的；在这种情况下，变量 `a`
    和 `b` 是可写的。变量 `c` 也是一个信号，但类型特定，称为计算信号。计算类型在我们的电子表格类比中，是一个包含公式的单元格，您可以通过读取其他单元格的值来确定其值。最后，我们通过简单地像调用函数一样调用信号来读取信号值。此代码片段的结果是值
    `5`。
- en: 'We will now change the example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更改示例：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this change, we are updating the value of signal `a` using the `set` method.
    When reading the `sum` signal, we can notice that the value was updated to `12`.
    Notice that the calculation reacts in real time just like it would in a spreadsheet..
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次更改中，我们正在使用 `set` 方法更新信号 `a` 的值。当读取 `sum` 信号时，我们可以注意到值已更新为 `12`。请注意，计算会实时反应，就像在电子表格中一样。
- en: 'Another way to update the value of a writable signal is by using the `update`
    method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更新可写信号的值的另一种方法是使用 `update` 方法：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `update` method allows you to update the signal based on the last value
    contained there.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法允许您根据信号中包含的最后一个值来更新信号。'
- en: Despite being simple, `signal` allows many possibilities as it can contain any
    type of value, from primitive ones such as numeric, string, and Boolean to complex
    objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管简单，`signal` 允许许多可能性，因为它可以包含任何类型的值，从原始的数值、字符串和布尔值到复杂对象。
- en: 'We will refactor our project to use signals, starting with the `LoadService`
    service:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的项目以使用信号，从 `LoadService` 服务开始：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we are exchanging the `isLoading` attribute for the `isLoading` signal,
    simplifying the service. We will change the `AppComponent` component template
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将 `isLoading` 属性替换为 `isLoading` 信号，简化了服务。我们将更改 `AppComponent` 组件模板如下：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To read the contents of the signal, we call it as if it were a function. Normally,
    it is not a good practice to call a function in a template, due to unnecessary
    processing. However, the signal was created and optimized to be read in the template,
    so in this case, there is no problem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取信号的内容，我们就像调用一个函数一样调用它。通常，在模板中调用函数不是一种好做法，因为它会导致不必要的处理。然而，信号被创建和优化为在模板中读取，所以在这种情况下，没有问题。
- en: 'The next task will be to refactor the list of journal entries so that we no
    longer manage the list but leave everything to the `ExerciseSetsService` service.
    We’ll start by changing the `ExerciseSetsService` service as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务将是重构日记条目列表，以便我们不再管理列表，而是将一切留给`ExerciseSetsService`服务。我们将首先按照以下方式更改`ExerciseSetsService`服务：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code block, we created the `exerciseList` signal by declaring
    it to contain `ExerciseSetList` and initializing it with an empty list. Then,
    we changed the `getInitialList` method toupdate the `exerciseList` signal based
    on the API return. We also changed the `delete` method to update the signal after
    deleting the diary entry.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们通过声明它包含`ExerciseSetList`并使用空列表初始化它来创建`exerciseList`信号。然后，我们将`getInitialList`方法更改为根据API返回值更新`exerciseList`信号。我们还更改了`delete`方法，在删除日记条目后更新信号。
- en: As we are changing the behavior of the function, we also need to exclude the
    `diaryResolver` function as now, the service will manage the query in the API
    and the component will consume the created signal.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在更改函数的行为，我们还需要排除`diaryResolver`函数，因为现在服务将管理API中的查询，而组件将消费创建的信号。
- en: 'In the `ListEntriesComponent` component, we will refactor to consume the signal
    list we created:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ListEntriesComponent`组件中，我们将重构以消费我们创建的信号列表：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code block, we replace the component’s `input` with the `ExerciseSetsService`
    service and receive the `exerciseList` signal from it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们将组件的`input`替换为`ExerciseSetsService`服务，并从中接收`exerciseList`信号。
- en: 'We will change the `ListEntriesComponent` component template as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式更改`ListEntriesComponent`组件模板：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `@for` command is prepared to read the content of a signal, including checking
    the type of value contained in it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`@for`命令已准备好读取信号的内容，包括检查其中包含的值的类型。'
- en: 'To finish this refactoring, we will change the template of the `''``DiaryComponent''`
    component:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此重构，我们将更改`'DiaryComponent'`组件的模板：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We removed the exercise list from the `app-list-entries` component as it will
    manage the state itself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从`app-list-entries`组件中删除了练习列表，因为它将自行管理状态。
- en: 'After changing the template, we can change the `DiaryComponent` component:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改模板后，我们可以更改`DiaryComponent`组件：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As the state is now managed by the `ExerciseSetsService` service, we are simplifying
    the component by just calling the service’s methods, without having to manage
    subscriptions to observables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于状态现在由`ExerciseSetsService`服务管理，我们通过仅调用服务的方法来简化组件，无需管理可观察对象的订阅。
- en: With the state managed by Signals, we can add a new feature here on this screen.
    Let’s assume that we need to inform the total training volume in the diary, that
    is, the total amount of exercise performed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过信号管理状态，我们可以在该屏幕上添加一个新功能。假设我们需要在日记中通知总训练量，即执行的总练习量。
- en: To have this information and react to events such as the deletion or inclusion
    of an entry, we can use Angular Signals!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取此信息并对诸如条目的删除或包含等事件做出反应，我们可以使用Angular Signals！
- en: 'In the `DiaryComponent` component, we will make the following change:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DiaryComponent`组件中，我们将进行以下更改：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We create a new computed signal called `'volume'` and perform the calculation
    in it based on the value contained in the `'``exerciseList'` signal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的计算信号，称为`'volume'`，并在其中根据`'exerciseList'`信号中的值进行计算。
- en: 'To use this new signal, let’s change the template:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新信号，让我们更改模板：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are consuming the `volume` signal by calling the signal directly in the template.
    By running our project, we can notice that this `volume` signal reacts to the
    changes we make in our list of exercises.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在模板中直接调用信号来消费`volume`信号。通过运行我们的项目，我们可以注意到这个`volume`信号会响应我们在练习列表中做出的更改。
- en: '![Figure 12.2 – Lazy-loaded bundle](img/B19562_13_2.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 懒加载包](img/B19562_13_2.jpg)'
- en: Figure 12.2 – Lazy-loaded bundle
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 懒加载包
- en: Signals are elements that will be increasingly improved by the Angular team,
    giving more control over the reactivity of our applications. An important point
    that we need to pay attention to is that Signals will not replace RxJS; in fact,
    they complement each other as we still need observables to control asynchronous
    flows and more complex flows, as we studied in [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是Angular团队将不断改进的元素，这将使我们能够更好地控制应用程序的反应性。我们需要注意的一个重要点是，信号不会取代RxJS；实际上，它们是互补的，因为我们仍然需要可观察者来控制异步流程和更复杂的流程，正如我们在[*第9章*](B19562_09.xhtml#_idTextAnchor242)，“使用RxJS探索反应性”中学习的那样。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the possibilities that the future of the Angular
    framework can offer us. We learned how to update our project to new versions of
    Angular, an ongoing activity as the framework continues to evolve. We understood
    how Angular versioning works and the importance of continually updating our project,
    from the point of view of security, performance, and new features. Then, we changed
    our application to use the new template expressions, which, in addition to simplifying,
    can, depending on the case, improve the performance of our applications. With
    this improvement in template expressions, we looked at the `defer` expression,
    which allows for the lazy loading of components within templates, giving us new
    options for optimizing interfaces with complex components. We also learned how
    to use the View Transactions API to improve our users’ experience with animations
    between page changes. Finally, we explored Angular Signals and simplified the
    state management of our application with this new element that complements RxJs.
    Angular is a framework that never stops evolving, as our users never stop demanding
    new features. In this chapter, we learned how to stay up to date with Angular.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Angular框架未来可以为我们提供的可能性。我们学习了如何将我们的项目更新到Angular的新版本，这是一个持续的活动，因为框架仍在不断发展。我们了解了Angular版本的工作原理以及持续更新我们的项目的重要性，从安全、性能和新功能的角度来看。然后，我们将我们的应用程序更改为使用新的模板表达式，这不仅简化了操作，而且在某些情况下，还可以提高我们应用程序的性能。随着模板表达式的这一改进，我们研究了`defer`表达式，它允许在模板中延迟加载组件，为我们提供了优化具有复杂组件的界面的新选项。我们还学习了如何使用视图事务API来改善用户在页面变化之间的动画体验。最后，我们探索了Angular信号，并使用这个补充RxJs的新元素简化了我们的应用程序的状态管理。Angular是一个不断进化的框架，正如我们的用户不断要求新功能一样。在本章中，我们学习了如何保持Angular的更新。
