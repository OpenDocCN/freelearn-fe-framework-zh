- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Testing and Source Control
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和源代码控制
- en: The success of our application depends on many factors, beyond the quality of
    our code organization or patterns. Moreover, the very nature of software implies
    that there will be changes during and after development, changes in the requirements,
    the scope, and so on. With each feature developed, an item of complexity is introduced
    into the software, creating relationships and dependencies. New inclusions may
    disrupt these connections and introduce breaking changes, bugs, or even completely
    disable the system. The solution for this problem is to keep track of code changes
    and conduct tests on the application to identify problems and ensure as much as
    possible that the system complies with the desired software attributes and satisfies
    the requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的成功取决于许多因素，而不仅仅是代码组织或模式的品质。此外，软件的本质意味着在开发和之后都会有变化，包括需求、范围等方面的变化。随着每个功能的开发，软件中会引入一个复杂性项，形成关系和依赖。新的添加可能会破坏这些连接，引入破坏性变更、错误，甚至完全禁用系统。解决这个问题的方法是跟踪代码变更并在应用程序上进行测试，以识别问题并尽可能确保系统符合所需的软件属性并满足需求。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Different approaches to testing and the concept of **test-driven** **development
    (TDD)**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的不同方法和**测试驱动开发（TDD）**的概念
- en: Installing a test suite (Vitest) and test tools (Vue Test Utils) for our project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的项目安装测试套件（Vitest）和测试工具（Vue Test Utils）
- en: Creating and running tests on an existing project for synchronous and asynchronous
    code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有项目中创建和运行同步和异步代码的测试
- en: Testing our components by simulating user interactions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟用户交互来测试我们的组件
- en: Installing and managing our source code using Git and online repositories such
    as GitHub or GitLab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Git和在线仓库（如GitHub或GitLab）安装和管理我们的源代码
- en: The concepts in this chapter are introductions to important professional skills
    for a developer to ensure the delivery of good-quality software. Often, these
    tasks are left aside or relegated as an afterthought. However, the lack of them
    may lead to expensive mistakes and lengthy overwork as the software complexity
    grows. For non-trivial applications with more than one developer involved, nowadays,
    it is hardly possible to conceive a project that does not use some of these tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的概念是介绍对开发者确保交付高质量软件的重要专业技能。通常，这些任务会被搁置或作为事后考虑。然而，缺乏这些任务可能会导致昂贵的错误和长时间的超负荷工作，随着软件复杂性的增长。对于涉及多个开发者的非平凡应用程序，如今几乎无法想象一个不使用这些工具的项目。
- en: In this chapter, we will focus on **unit testing** and the tools provided by
    the Vue team to perform it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注**单元测试**以及Vue团队提供的执行它的工具。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not have additional requirements to those of previous implementations
    of code examples. The final source code can be found in the official repository
    for this book at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有对之前代码示例实现的要求的额外要求。最终源代码可以在本书的官方仓库[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09)中找到。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/UqRIi](https://packt.link/UqRIi)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://packt.link/UqRIi](https://packt.link/UqRIi)
- en: What are testing and TDD
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和TDD是什么
- en: 'Testing is the process to verify that the software is doing what it is supposed
    to do, according to the requirements of the project. It involves the manual or
    automated execution of tools to evaluate and measure different properties and
    attributes of the software, identify errors and bugs, and provide feedback for
    developers to take action to correct them. There are many different approaches
    and types of tests to be performed, such as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是验证软件是否按照项目需求执行其预期功能的过程。它涉及手动或自动执行工具来评估和测量软件的不同属性和特性，识别错误和缺陷，并为开发者提供反馈，以便采取行动进行纠正。有许多不同的测试方法和类型需要执行，如下所示：
- en: '**Unit testing**: This is where relevant units of the source code are validated
    against a series of inputs and outputs. It is often automated.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这是对源代码的相关单元进行一系列输入和输出的验证。这通常会被自动化。'
- en: '**Integration testing**: All the components of a system are verified together
    as a group, looking for errors and bugs in the resulting integration, communication,
    and so on.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：系统中的所有组件作为一个组一起验证，寻找在集成、通信等方面出现的错误和缺陷。'
- en: '**End-to-end testing**: This involves a complete validation of the application
    simulating real-world use, interacting with databases, network scenarios, and
    so on. It can be performed with automated tools that simulate human interaction,
    and manual testing using real-life users.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这涉及到对应用程序的完整验证，模拟真实世界的使用，与数据库、网络场景等交互。可以使用模拟人类交互的自动化工具，以及使用真实用户进行的手动测试。'
- en: These types of testing are just a small sample of this discipline, as there
    are hundreds of possible tests to apply to the software. Large companies may have
    entire testing teams dedicated to ensuring the quality of the software. Usually,
    the more complex the software, the more complex the testing may be. In practice,
    the testing plan can be as complex as the development plan itself. As mentioned
    in the introduction, we will focus on the official tools provided by the Vue team
    for this task.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的测试只是这个领域的一小部分，因为针对软件可能有数百种可能的测试。大型公司可能拥有专门的测试团队，以确保软件的质量。通常，软件越复杂，测试可能越复杂。在实践中，测试计划可能和开发计划一样复杂。正如引言中提到的，我们将专注于Vue团队为此任务提供的官方工具。
- en: 'Testing can be done before, during, after, or in parallel with the development.
    **TDD** is a discipline that places the burden of testing as early in the project
    as possible, even before the actual coding begins, with the objective to match
    the requirements. It involves the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以在开发之前、开发期间、开发之后或与开发并行进行。**TDD**是一种将测试负担尽可能提前到项目中的学科，甚至在实际编码开始之前，目标是匹配需求。它包括以下步骤：
- en: Write a test case, based on the requirements and design of the application,
    with key inputs and expected outputs.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据应用程序的需求和设计编写一个测试用例，包括关键输入和预期输出。
- en: Run the test, which should fail (as there is no code written yet).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试，它应该失败（因为还没有编写代码）。
- en: Write the actual code to be tested (a function, Vue component, etc.).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写要测试的实际代码（一个函数、Vue组件等）。
- en: Run the test against the created code. If it fails, refactor the code or design.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对创建的代码运行测试。如果测试失败，重构代码或设计。
- en: Start again with a new test case for the next unit.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的测试用例开始，为下一个单元测试。
- en: This process is repeated, and it is expected to provide developers with a significant
    reduction of “bugs” and errors and help them focus on the requirements. This does
    incur an overhead of effort early in the project, as opposed to refactoring, when
    the tests are performed toward the end.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会重复进行，预计可以为开发者提供显著的“错误”和错误的减少，并帮助他们专注于需求。这个过程在项目早期就会产生一定的努力开销，与重构相比，测试是在项目后期进行的。
- en: 'TDD has become popular in some teams and with some frameworks, and it is supposed
    to help developers improve their own code as they now acquire a “testing” mindset.
    However, there are no specific studies made to confirm this, but practitioners
    of this discipline do report that it has improved their code and design. This,
    of course, begs the question: what needs to be tested, and how can we streamline
    the task into our workflow? That is the topic we will discuss next.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）在一些团队和一些框架中已经变得流行，它被认为可以帮助开发者提高自己的代码质量，因为他们现在培养了一种“测试”的思维模式。然而，并没有具体的研究来证实这一点，但这个领域的实践者确实报告说，它改善了他们的代码和设计。这当然引发了一个问题：需要测试什么，我们如何将这项任务简化到我们的工作流程中？这正是我们接下来要讨论的主题。
- en: What to test
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要测试什么
- en: A key factor in the success of a good testing plan and implementation is deciding
    what to test. It is not possible to test the full universe of possibilities or
    100% of the components and interactions in a project when considering internal
    and external factors. Even the attempt to fully cover all possibilities would
    be incredibly expensive and practically impossible. Instead, the focus needs to
    be on the real possibilities of what can be tested within our time and budget
    constraints, by carefully selecting the non-trivial elements that “make or break”
    our project requirements. This is often not an easy task.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的测试计划和实施成功的关键因素是决定测试什么。在考虑内部和外部因素时，不可能测试所有可能性的全集或项目中的100%的组件和交互。即使尝试全面覆盖所有可能性也会极其昂贵且在实际上不可能实现。相反，我们需要关注在时间和预算限制内可以测试的真实可能性，通过仔细选择那些“成败”我们项目需求的非平凡元素。这通常不是一个容易的任务。
- en: 'When it comes to Vue applications, we need to focus on crucial services and
    components that perform key operations. We need to test the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到Vue应用时，我们需要关注执行关键操作的关键服务和组件。我们需要测试以下内容：
- en: '**Services**: Self-contained functions, both synchronous and asynchronous.
    Functions that don’t return a value but perform logical procedures will serve
    a different kind of testing than what we will see here. These will involve mocking
    network communications or database calls, application policies, and so on. However,
    the principles for testing these are similar.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：自包含的函数，包括同步和异步。不返回值但执行逻辑过程的函数将涉及不同于我们在这里看到的测试类型。这些将涉及模拟网络通信或数据库调用、应用程序策略等。然而，测试这些的原则是相似的。'
- en: '**Components**: We need to test inputs (props) and outputs (events and HTML).
    Higher-level components that group other components to perform a workflow or business
    logic can also be tested in the same way (props, events, and HTML rendered). However,
    these also will need other types of testing, such as end-to-end testing.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：我们需要测试输入（属性）和输出（事件和HTML）。将其他组件分组以执行工作流程或业务逻辑的高级组件也可以以相同的方式进行测试（属性、事件和渲染的HTML）。然而，这些也需要其他类型的测试，例如端到端测试。'
- en: We can write our own functions and tools to perform tests, but apart from some
    edge cases, the obvious recommendation is to use stable test suites and tools.
    In our case, for Vue, there are official resources provided by the same team,
    called **Vitest** and **Vue Test Utils**. Using a testing suite/library has many
    benefits, akin to the use of a framework or library in the “regular” development
    of an application. Perhaps one of the major benefits has to do with **DX**, or
    **Developer eXperience**, as they streamline and make the development process
    easier or lighter in the best case. Let’s learn how to apply these tools in our
    workflow by going through an example application, which we will address in the
    next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写自己的函数和工具来执行测试，但除了某些边缘情况外，明显的建议是使用稳定的测试套件和工具。在我们的案例中，对于Vue，有由同一团队提供的官方资源，称为**Vitest**和**Vue
    Test Utils**。使用测试套件/库有许多好处，类似于在“常规”应用开发中使用框架或库。可能其中一个主要好处与**DX**（开发者体验）有关，因为它们使开发过程更加流畅或更轻便。让我们通过一个示例应用来学习如何将这些工具应用到我们的工作流程中，我们将在下一节中介绍这个应用。
- en: Our base example application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的基础示例应用
- en: It is best to understand the discipline of testing and learn about the tools
    by applying them to a real project through practice. As a learning exercise, we
    will first take a running application based on one of the examples presented in
    [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and
    Patterns*. We will build a **Fibonacci calculator** and install the Vitest test
    suite and Vue Testing Utils to the project. Later, we will explain what would
    change in this approach when applying the TDD discipline.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过将测试应用到实际项目中通过实践来了解测试的学科并学习工具。作为一个学习练习，我们将首先基于在[*第二章*](B18602_02.xhtml#_idTextAnchor040)中介绍的示例之一，即*软件设计原则和模式*，选择一个正在运行的应用程序。我们将构建一个**斐波那契计算器**并将Vitest测试套件和Vue测试工具安装到项目中。稍后，我们将解释在应用TDD（测试驱动开发）纪律时，这种方法会有哪些变化。
- en: 'The code for this application can be found in the repository for this chapter.
    Once downloaded, you need to execute the following command to install the dependencies:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的代码可以在本章的仓库中找到。下载后，您需要执行以下命令来安装依赖项：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to run the application, you must run the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了运行该应用程序，您必须运行以下命令：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the server is ready, loading the site in your web browser should present
    you with an application like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器准备好后，在您的网络浏览器中加载网站应该会显示一个像这样的应用程序：
- en: '![Figure 9.1 – The example application with a Fibonacci calculator](img/Figure_9.01_B18602.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 带有斐波那契计算器的示例应用程序](img/Figure_9.01_B18602.jpg)'
- en: Figure 9.1 – The example application with a Fibonacci calculator
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 带有斐波那契计算器的示例应用程序
- en: 'The design of this application has been made with the purpose of learning the
    basics of testing functions and components, so it is very basic but sufficient.
    We are presented with one service file (`/src/services/Fibonacci.js`) and three
    components: `App.vue`, `FibonacciInput.vue`, and `FibonacciOutput.vue`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的设计是为了学习测试函数和组件的基础，所以它非常基础但足够了。我们面前有一个服务文件（`/src/services/Fibonacci.js`）和三个组件：`App.vue`、`FibonacciInput.vue`
    和 `FibonacciOutput.vue`。
- en: '![Figure 9.2 – Components and service for the application](img/Figure_9.02_B18602.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 应用程序组件和服务](img/Figure_9.02_B18602.jpg)'
- en: Figure 9.2 – Components and service for the application
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 应用程序组件和服务
- en: Our application-level component, `App.vue`, receives from `FibonacciInput.vue`
    a positive integer number through an event, which passes as a prop input to `FibonacciOutput.vue`.
    This component uses the `Fibonacci.js` service to calculate the respective Fibonacci
    number corresponding in the series and present it to the user. As simple as this
    application sounds, it gives us basic examples to create tests for the most common
    cases, which will give us a solid start. It is now time to install our test suite.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用级组件 `App.vue` 通过一个事件从 `FibonacciInput.vue` 接收一个正整数，并将其作为属性输入传递给 `FibonacciOutput.vue`。该组件使用
    `Fibonacci.js` 服务来计算相应的斐波那契数列中的数，并将其展示给用户。尽管这个应用程序听起来很简单，但它为我们提供了创建测试最常见情况的示例，这将为我们提供一个坚实的基础。现在是时候安装我们的测试套件了。
- en: Installation and use of Vitest
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vitest 的安装和使用
- en: '`/src/__tests__` folder, some examples, and a few extra entries in our `package.json`
    file. But all this boilerplate can be a bit confusing unless we have previous
    experience in this area. Instead, we start from an already created project, so
    we will install Vitest as a development dependency – a task that will give us
    an insight into how it works and is organized.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/__tests__` 文件夹，一些示例，以及 `package.json` 文件中的一些额外条目。但除非我们在这个领域有之前的经验，否则所有这些样板代码可能会有些令人困惑。相反，我们从已经创建的项目开始，因此我们将安装
    Vitest 作为开发依赖项——这将让我们了解它是如何工作的以及它的组织结构。'
- en: 'Install Vitest from the command line at the root directory of the project with
    this command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在项目的根目录下通过命令行安装 Vitest：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The package manager will take some time to include Vitest and all necessary
    dependencies but won’t modify our source code or organization. For convenience,
    we will use `npm` as well to run our tests, so we need to open our `package.json`
    file, and in the `scripts` section, enter the following lines so the section looks
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器将花费一些时间来包含 Vitest 和所有必要的依赖项，但不会修改我们的源代码或组织结构。为了方便起见，我们还将使用 `npm` 来运行我们的测试，因此我们需要打开我们的
    `package.json` 文件，并在 `scripts` 部分输入以下行，以便该部分看起来像这样：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we can now test our test suite:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们现在可以测试我们的测试套件了：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After you run that command, you will be graciously greeted with a red message
    explaining that the tests have failed. Perfect. This is what it should do, as
    we do not have any tests yet! So, let’s add them. We will start by testing our
    `Fibonacci.js` service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令后，你会看到一个红色的消息友好地告诉你测试失败了。太好了。这正是我们期望的，因为我们还没有任何测试！所以，让我们添加它们。我们将从测试我们的
    `Fibonacci.js` 服务开始。
- en: 'Vitest allows us to write our test functions in independent files or in-source,
    meaning that we place them alongside our component’s JavaScript. There are benefits
    and trade-offs with both approaches, but to start, we will place our test code
    in independent files, one for each service and component. In this way, we place
    these files in their own directory, which by convention can be either `/src/tests`
    or `/src/components/__tests__`, but they could also be placed alongside the Single
    File Components or with the services. Vitest will scan the entire source folder
    for the test files. Even though we can be very creative when placing these files,
    we will place them in `/src/test` to keep things neat and tidy. There is another
    convention to adhere to, which is that each test file must have the same name
    as the file being tested, plus the `.spec.js` or `.test.js` extension. Vitest
    uses this convention to identify and run the tests in an organized manner. So,
    in our case, our `Fibonacci.js` service will have its testing counterpart in `/src/tests/Fibonacci.test.js`.
    Go ahead and create that file, and enter the following lines:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 允许我们在独立的文件或源文件中编写我们的测试函数，这意味着我们将它们放置在与组件的JavaScript相同的目录下。这两种方法都有其优势和权衡，但为了开始，我们将测试代码放置在独立的文件中，每个服务和组件一个文件。这样，我们将这些文件放在它们自己的目录中，按照惯例可以是
    `/src/tests` 或 `/src/components/__tests__`，但它们也可以放置在单文件组件或服务旁边。Vitest 将扫描整个源文件夹以查找测试文件。尽管我们可以非常创意地放置这些文件，但我们仍将它们放在
    `/src/test` 以保持整洁有序。还有一个需要遵守的惯例，即每个测试文件必须与被测试的文件具有相同的名称，加上 `.spec.js` 或 `.test.js`
    扩展名。Vitest 使用这个惯例以有组织的方式识别和运行测试。因此，在我们的情况下，我们的 `Fibonacci.js` 服务将在 `/src/tests/Fibonacci.test.js`
    中有其测试对应物。请继续创建该文件，并输入以下行：
- en: /src/tests/Fibonacci.test.js
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: /src/tests/Fibonacci.test.js
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the first line, we import three functions from Vitest, which are the foundation
    of all our testing, and the ones that we will be using most often. Here is what
    each one does:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们导入来自 Vitest 的三个函数，这是所有测试的基础，也是我们将最常使用的函数。以下是每个函数的作用：
- en: '`describe(String, Function)`: This function groups together a number of tests,
    and Vitest will report the test group by using the description given as the first
    parameter. The second parameter is a function, where we will run the tests with
    the `test()` function.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe(String, Function)`: 这个函数将多个测试组合在一起，Vitest 将使用作为第一个参数提供的描述来报告测试组。第二个参数是一个函数，我们将使用
    `test()` 函数在其中运行测试。'
- en: '`test(String, Function)`: The first parameter is a description of the tests
    encompassed in the second parameter, which is a function. The test will “pass”
    if no errors are thrown within it. This means that we can write our own test logic
    and tools following this condition and throw a JavaScript error when the validation
    fails. However, there is a simpler approach...'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test(String, Function)`: 第一个参数是对第二个参数中包含的测试的描述，第二个参数是一个函数。如果在这个函数中没有抛出错误，测试将“通过”。这意味着我们可以根据这个条件编写自己的测试逻辑和工具，当验证失败时抛出JavaScript错误。然而，有一个更简单的方法...'
- en: '`expect(value)`: This is the function that performs the “magic” of testing.
    It receives, as a unique argument, a single value or a function that resolves
    to a single value. The result of `expect()` is a chainable object that exposes
    many different and almost language-natural assertions (comparisons, validations,
    etc.) to perform on the argument value. Under the hood, it uses the Chia syntax
    to a certain extent and is also compatible with other test suites, such as Jest
    – for example, `expect(2).toBe(2)`. A full list of all the possible assertion
    methods can be found in the official documentation here: [https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect(value)`: 这是一个执行测试“魔法”的函数。它接收一个唯一的参数，即单个值或解析为单个值的函数。`expect()` 的结果是可链式对象，它公开了许多不同的几乎与语言自然相符的断言（比较、验证等），可以对参数值执行。在底层，它在一定程度上使用
    Chia 语法，并且也与其他测试套件兼容，例如 Jest – 例如，`expect(2).toBe(2)`。所有可能的断言方法的全列表可以在官方文档中找到：[https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html)。'
- en: 'In the second line of the test file, we directly import the two functions contained
    in the service: `Fibonacci()` and `FibonacciPromise()`. We need to import each
    function that we want to test, and then create as many test groups as necessary
    for each one. Let’s start with the self-contained `Fibonacci()` function by adding
    the following test group:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件的第二行，我们直接导入服务中包含的两个函数：`Fibonacci()` 和 `FibonacciPromise()`。我们需要导入我们想要测试的每个函数，并为每个函数创建必要的测试组。让我们从添加以下测试组开始，以自包含的
    `Fibonacci()` 函数为例：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start by creating a test group with `describe()` and create inside the passed
    function as many tests as needed. Inside each `test()` function, we can create
    as many assertions as needed, but it has to have at least one. Notice how we are
    executing the function from the service with different arguments, and then asserting
    them to the expected value as defined in the numerical series. In this case, we
    are using `.toBe()` to test equality, but in the same way, we could be testing
    strings, objects, types, and so on, using other assertions, such as `.not, .toEqual,
    .toBeGreaterThan`, etc. There are more than 50 assertion methods defined in the
    documentation ([https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html)).
    Take some time to review them, and remember that these are chainable, so you can
    make more than one assertion at once.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `describe()` 创建一个测试组，并在传递的函数内部创建所需数量的测试。在每一个 `test()` 函数内部，我们可以创建所需数量的断言，但至少要有一个。注意我们是如何使用不同的参数从服务中执行函数，然后将它们断言为数值序列中定义的预期值。在这种情况下，我们使用
    `.toBe()` 来测试相等性，但同样，我们也可以使用其他断言，如 `.not, .toEqual, .toBeGreaterThan` 等，来测试字符串、对象、类型等。文档中定义了超过
    50 种断言方法（[https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html)）。花些时间回顾它们，并记住这些是可链式的，所以你可以一次做出多个断言。
- en: 'After saving this file, you can run the test again:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件后，你可以再次运行测试：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should receive a few messages in green, indicating the number of tests performed
    and whether they passed or not. In the case that one raises an error, it will
    be pointed out in red letters using the descriptive text and line where it occurred.
    That is a sign to start refactoring the code (assuming the test function and assertion
    were properly and correctly written; otherwise, you get a false positive!).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会收到几条绿色的消息，指示执行了多少次测试以及它们是否通过。如果其中一个引发了错误，它将用红色字母指出，并使用描述性文本和发生错误的行。这是一个开始重构代码的信号（假设测试函数和断言被正确且恰当地编写；否则，你会得到一个假阳性！）。
- en: 'In the case that no assertion method works for a particular edge case, you
    can create inside `test()` your own logic in plain JavaScript and throw an error
    when the validation fails. For example, these two code snippets are equivalent:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有断言方法适用于特定的边缘情况，你可以在 `test()` 内部创建自己的逻辑，使用纯 JavaScript 并在验证失败时抛出错误。例如，这两个代码片段是等价的：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Even though this example is trivial, it is easy to see how the first case, using
    `expect()`, results in a better developer experience, as it is succinct, elegant,
    and easy to read.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子很简单，但很容易看出，使用 `expect()` 的第一种情况，结果会带来更好的开发者体验，因为它简洁、优雅且易于阅读。
- en: Vitest is still running!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 仍在运行！
- en: Perhaps you have noticed that running `npm run test` does not end the execution
    of the script once the tests have terminated. Just like with a developer server,
    Vitest keeps waiting for changes to occur to the source code or test files and
    automatically reruns all the tests for you. If you want to run the tests only
    once, use `npm run test:once` or `vitest –-run` to flag Vitest to run the tests
    only once and then exit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你已经注意到，运行 `npm run test` 并不会在测试结束后结束脚本的执行。就像开发者服务器一样，Vitest 会持续等待源代码或测试文件发生变化，并自动为你重新运行所有测试。如果你想只运行一次测试，请使用
    `npm run test:once` 或 `vitest –-run` 来标记 Vitest 只运行一次测试然后退出。
- en: Special assertion case – fail on purpose
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊断言情况 – 故意失败
- en: 'All the previous assertions thus far have been made using the “positive” approach
    that a function will return what is expected. Using the “negative” approach in
    testing is to make sure that a function will fail when it is supposed to. For
    example, the Fibonacci series is not defined for negative numbers, so any calculation
    should not return a value but should throw an error. In these cases, we need to
    wrap the execution of the function in another function, thus encapsulating it
    to test the assertion against a thrown error. This would be the equivalent of
    using a `try..catch` block in plain JavaScript to avoid terminating the execution
    of the script when an error occurs. For example, executing `Fibonacci(-5)` should
    throw an error, so we will write our test case as this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有之前的断言都是使用“积极”方法进行的，即函数将返回预期的结果。在测试中使用“消极”方法是为了确保函数在应该失败时确实会失败。例如，斐波那契数列在负数上没有定义，因此任何计算都不应该返回值，而应该抛出错误。在这些情况下，我们需要将函数的执行封装在另一个函数中，从而测试抛出的错误。这相当于在纯JavaScript中使用`try..catch`块来避免在发生错误时终止脚本的执行。例如，执行`Fibonacci(-5)`应该抛出错误，因此我们将我们的测试用例写成这样：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding assertion will work as expected, without interrupting the testing
    process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的断言将按预期工作，而不会中断测试过程。
- en: Special assertion case – asynchronous code
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊断言情况 - 异步代码
- en: 'Another special case to keep in mind is asynchronous code, such as network
    calls, promises, and so on. In this case, the solution is to use `async..await`,
    not on the function but on `expect`. For example, to test the `FibonacciPromise()`
    asynchronous function, we would write a test like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的特殊情况是异步代码，例如网络调用、Promise等。在这种情况下，解决方案是在`expect`上使用`async..await`，而不是在函数上。例如，为了测试`FibonacciPromise()`异步函数，我们会编写一个像这样的测试：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how we are applying the `async` syntax to the entire test function, and
    `await` to the `expect()` function. We also need to use the `.resolves` assertion
    to indicate the successful resolution for the value to validate. If we needed
    to test a `Promise` rejection, we would use `.rejects` instead of `.resolves`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将`async`语法应用于整个测试函数，将`await`应用于`expect()`函数的。我们还需要使用`.resolves`断言来指示值的成功解析以进行验证。如果我们需要测试`Promise`拒绝，我们将使用`.rejects`而不是`.resolves`。
- en: With this, we have covered the majority of tools and test approaches to get
    us started in unit-testing our plain JavaScript functions. However, all these
    tests are executed using **Node.js** (the server version of JavaScript), not on
    the browser where our Vue components will be executed. In Node.js, there is no
    **DOM** or **Windows** object, so we don’t have any HTML... so how do we test
    our **Single File Components**?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经涵盖了大多数工具和测试方法，以帮助我们开始对纯JavaScript函数进行单元测试。然而，所有这些测试都是使用**Node.js**（JavaScript的服务器版本）执行的，而不是在Vue组件将要执行的浏览器上。在Node.js中，没有**DOM**或**Windows**对象，所以我们没有HTML...那么我们如何测试我们的**单文件组件**？
- en: The answer is to provide Vitest with a simulated DOM where we can mount our
    components and run tests as if it were a browser window. Here is where the Vue
    Test Utils tools come into play.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是向Vitest提供一个模拟的DOM，我们可以在其中挂载我们的组件并运行测试，就像它是一个浏览器窗口一样。这就是Vue Test Utils工具发挥作用的地方。
- en: Installation of Vue Test Utils
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue Test Utils的安装
- en: 'As of now, Vitest provides us, out of the box, with tools to test plain JavaScript
    functions, classes, events, and so on. To test our Single File Components, we
    need additional resources, and these are provided to us again by the official
    Vue team in the form of **Vue Test Utils** ([https://test-utils.vuejs.org/](https://test-utils.vuejs.org/)).
    To install them, run the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Vitest为我们提供了开箱即用的工具来测试纯JavaScript函数、类、事件等。为了测试我们的单文件组件，我们需要额外的资源，这些资源再次由官方Vue团队以**Vue
    Test Utils**（[https://test-utils.vuejs.org/](https://test-utils.vuejs.org/)）的形式提供。要安装它们，请运行以下命令：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the installation has completed, we need to update our `vite.config.js`
    file to include the environment where the components will be tested, meaning a
    browser context. Modify the configuration file so it looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要更新我们的`vite.config.js`文件，以包含组件将被测试的环境，即浏览器上下文。修改配置文件，使其看起来像这样：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Vitest and Vue Test Utils both integrate seamlessly with Vite, to the point
    that they share the same configuration file. You can now run the test suite, and
    Vitest will attempt to download and install any missing dependencies on the first
    run after these modifications. If for some reason the installation of `jsdom`
    does not happen automatically, you can install it manually with this command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 和 Vue Test Utils 都可以无缝集成到 Vite 中，以至于它们共享相同的配置文件。现在，您可以运行测试套件，Vitest 将在第一次运行后尝试下载并安装任何缺失的依赖项。如果由于某种原因，`jsdom`
    的安装没有自动发生，您可以使用以下命令手动安装：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, with these changes, we are ready to start our first component tests. Let’s
    start creating a file to test our `FibonacciOutput.vue` component, as it is the
    simplest, we have in our application. Create the following file in the test directory
    with this code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过这些更改，我们已准备好开始我们的第一个组件测试。让我们开始创建一个文件来测试我们的 `FibonacciOutput.vue` 组件，因为它是我们应用程序中最简单的，创建以下文件在测试目录中，并使用此代码：
- en: /src/tests/FibonacciOutput.test.js
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: /src/tests/FibonacciOutput.test.js
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code is not that different from a basic unit test as we have done
    before, but it does some things a bit differently. In line `#1`, we import a function
    from the Vue Test Utils library that allows us to “mount” our component in a test
    environment simulating a browser window with Vue 3\. In line `#2`, we import our
    component in the usual way, and then proceed to write our test group as before.
    The difference here is in line `#3`. We use the `mount` function to create our
    live component by passing it as the first argument and, as the second, we pass
    an object with properties that will be applied to the component. In this case,
    we are passing the `number` prop with a value of `10`. The `mount` function will
    return a wrapper object representing our component, exposing an API that we access
    to perform our assertions. In this case, in line `#4`, we are checking that the
    plain text rendered by the component contains the value 55, which we will find
    to be true when the test is run. It is by using this wrapper object that we can
    access the component properties, events, slots, and rendered HTML by accessing
    the proper methods. We will only discuss a few in this chapter, but a full list
    is available in the official documentation at [https://test-utils.vuejs.org/api/#wrapper-methods](https://test-utils.vuejs.org/api/#wrapper-methods).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与我们之前所做的基本单元测试没有太大区别，但它做了一些不同的事情。在第 `#1` 行，我们从 Vue Test Utils 库中导入一个函数，该函数允许我们在模拟浏览器窗口的测试环境中“挂载”我们的组件，使用
    Vue 3。在第 `#2` 行，我们以通常的方式导入我们的组件，然后像以前一样继续编写我们的测试组。这里的区别在于第 `#3` 行。我们使用 `mount`
    函数通过将其作为第一个参数传递来创建我们的实时组件，作为第二个参数，我们传递一个包含将应用于组件的属性的对象。在这种情况下，我们传递了值为 `10` 的 `number`
    属性。`mount` 函数将返回一个表示我们的组件的包装器对象，提供了一个我们可以访问的 API 来执行我们的断言。在这种情况下，在第 `#4` 行，我们检查组件渲染的纯文本是否包含值
    55，当测试运行时，我们会发现这是真的。正是通过使用这个包装器对象，我们可以通过访问适当的方法来访问组件属性、事件、插槽和渲染的 HTML。我们将在本章中仅讨论其中的一些，但完整的列表可在官方文档中找到，网址为
    [https://test-utils.vuejs.org/api/#wrapper-methods](https://test-utils.vuejs.org/api/#wrapper-methods)。
- en: 'This short example gives us a template to write our tests, but now we move
    to a more complex example to test our `input` component. In the test directory,
    create the following file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的示例为我们提供了一个编写测试的模板，但现在我们转向一个更复杂的示例来测试我们的 `input` 组件。在测试目录中，创建以下文件：
- en: /src/tests/FibonacciInput.test.js
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: /src/tests/FibonacciInput.test.js
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This final example starts in the same way as before, by importing the functions
    that we will use to describe the tests, mount our component, and the component
    itself. Our purpose here is to simulate to a certain degree the user interaction
    with the component by entering a value in the `input` field, clicking the button,
    and then capturing the event and the value passed programmatically. We will rely
    on the methods just like before. We start in line `#1` by mounting our component
    and creating the wrapper. Notice that, this time, we are not passing any options,
    as we don’t need them. In line `#2`, we use the wrapper’s `find()` method to locate
    an `input` element and set a value of `10`. The `find()` method retrieves elements
    using a string with the same syntax as `querySelector` in a browser window. The
    returned object is a wrapper around the element, which again exposes methods for
    users to interact with it – in this case, `.setValue()`. Using a similar logic,
    in line `#3`, we also locate the button and trigger the `click` event, which will
    emit the `input` event in our component. Notice how easy it is in lines `#2` and
    `#3` to manipulate our component. In this way, we can access and interact programmatically
    with it, much like it could happen in an end-to-end test. We could, in theory,
    create our end-to-end tests using this tool, but there are better options, such
    as **Cypress** ([https://www.cypress.io/](https://www.cypress.io/)), which work
    excellently with Vitest, giving us a great DX.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'In line `#3`, we have clicked a button, which we know should emit an event.
    In line `#4`, we capture all the emitted events with the name `input`. The result
    is an array of wrapped events that we can use in our assertions, by referencing
    each event by its ordinal index. In this case, we only triggered one event, so
    in line `#5`, we pass that to our expected function as `inputEvents[0]`. However,
    notice that the assertion matches the output to an array, `[10]`, instead of the
    value we entered in line `#2`. Why is that? The answer is that each *event* has
    an undetermined number of arguments it could pass, so these are captured in an
    array. An equivalent notation is shown here in line `#6`, where we pass to `expect()`
    directly the value of the first element in the array of arguments, from the first
    event captured: `inputEvents[0][0]`. Then, we can directly validate the result
    to a value with `.toBe(10)`. Now, this approach may seem a bit convoluted and
    clumsy, having to refer to events and their values in such a way, but it is very
    powerful. Consider that we can, in one single line, assert a full array with a
    set of related values!'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: In these two files, we have now tested the input and output of our components
    and even validated the interactivity as expected. We have also learned how to
    retrieve elements rendered and access their properties. Any error thrown in these
    functions will invalidate the test and point us in the right direction, line,
    and comment on where to fix it. Placing tests in individual files is a very convenient
    alternative. However, Vitest also accepts in-source testing, which we will see
    next.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: In-source testing
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With in-source testing, we can indicate to Vitest to look into our JavaScript
    and Single Component Files for the tests to run, as opposed to specific files.
    These alternatives are not exclusive to each other, so we could have both active
    at the same time. The reason behind this is that, in some cases, a test case would
    benefit to be “close” to the original code that it is trying to assert. Such code
    must be placed at the end of our file following this format:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, for Vitest to find this code in our files, we also need to modify the
    `vite.config.js` file to include the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, to eliminate the test code from the production build, we need
    to add the following before the bundling:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With these changes, we can then include the tests at the end of our JavaScript
    files, with the benefits and trade-offs that this brings. For example, if there
    is an in-house service that is shared or used among projects, it could be a good
    idea to place the tests in the same file as opposed to duplicating them for each
    project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our tests in place, let’s see two more benefits that we get
    from using Vitest: *coverage* and a live*web UI.*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Coverage
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of coverage is very simple, and it answers the question of how
    much of our code is covered by automated tests. We know that 100% coverage is
    only possible for small applications, as the same effort for large projects falls
    fast into the law of diminishing returns Vitest offers us a simple way to answer
    this question by running the `vitest –coverage` command. In our case, we have
    already set this option in our `package.json` scripts section, so we can run the
    following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the preceding command is run, if any dependency is missing, it will prompt
    us on whether we want to try to download and install it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.3 – Vitest prompts \uFEFFus to install missing dependencies for\
    \ coverage](img/Figure_9.03_B18602.jpg)"
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Vitest prompts us to install missing dependencies for coverage
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'For our chapter code example, the coverage report should look something like
    this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Vitest coverage report example](img/Figure_9.04_B18602.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Vitest coverage report example
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to retrieve this information on a file (as `json`, `text`, or
    `html`) if we need to. For that, we just need to include a new line in our `vite.config.js`
    file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result of running the command again will be a website placed in a new directory
    called `coverage` at the root of our project. This static website provides for
    navigation and drills down in the report. In our example, it looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Coverage HTML report](img/Figure_9.05_B18602.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Coverage HTML report
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on our needs, this simple tool may provide us with insight into our
    project that would be hard to find otherwise. The export to JSON file comes also
    very handy if we need to integrate our project with other reporting software or
    format. There is yet another alternative that may come in handy: Vitest also provides
    a web UI to view and interact with the tests in the form of a dashboard. We will
    see this next.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The Vitest UI
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Vitest is based on Vite, it does make good use of some of its features,
    not only for live testing but also to provide a live development server displaying
    the tests in real time. To make use of this option, we only need to install the
    appropriate dependency as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, for convenience, we should add the following line in our `package.json`
    file so we can run the application using `npm`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can then run the server with this command line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The development test server will start and provide us with an address to open
    in the browser. For our application, this looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.6 – Vitest UI \uFEFFdashboard](img/Figure_9.06_B18602.jpg)"
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Vitest UI dashboard
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The web UI has also new possibilities to interact with the test cases, and even
    see the relationships between components and services in a graphical manner, all
    the way down to the test code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have cleaned up our code and run tests, it is time to look into
    another tool to keep track of changes, a fundamental concept for today: source
    control with Git.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: What is source control... and why?
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development is a “human-intensive” discipline, meaning that it depends
    heavily on the creativity and involvement of the developer and their know-how.
    It is common to try different approaches to the same situation and write and rewrite
    code. Even the process of refactoring after testing implies making changes in
    the code. It is not an anomaly that during this process, we need to “go back”
    to a previous code when a change or approach didn’t meet expectations. If we are
    constantly overwriting the same files... how do we keep track of what changed
    where? And by whom? Our own memory is not enough when time and complexity grow.
    Save files with different names? That would become impractical very soon. And
    what about combining source code from multiple developers? We can quickly see
    that managing the source code for non-trivial projects is a very important task
    in itself.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The historical solution to this early problem in computer science has been the
    creation of additional software in charge of keeping track of changes in the code,
    allowing a developer to go back on their tracks, and facilitating the chore of
    merging code from multiple developers to make a cohesive source code. The emerging
    discipline for this task is called **Source Control** (**SC**), and the software
    to implement it is called a **Source Control System** (**SCS**) or **Source Control
    Management System** (**SCMS**). There have been many, and still are many, different
    systems in use today, such as **Mercurial**, **Subversion**, **ClearCase**, **Git**,
    and **BitKeeper**. Each one has its trade-offs. In particular, Git is used today
    by most projects and developers around the globe. Statistics on the internet show
    different percentages for the most popular ones, but each one shows this trend.
    Because of this, it is important that we learn how to use Git, which is our next
    topic.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Source control with Git
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, the most popular SCS is Git, which was created by **Linus Torvalds**,
    who is also the creator of the Linux kernel. The story goes that the Linux kernel
    project used *BitKeeper* for source control, but the team hit many issues with
    the growing complexity and distributed nature of the development. Frustrated,
    Linus Torvalds decided to make his own SCS to solve the real-life problems they
    had... and it took him one weekend! (See [https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/](https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/).)
    That was the humble beginning of Git, and from there, it became popular in the
    open source community as well as in the enterprise world.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Git is a distributed SCMS, simple and effective to use from the command line.
    It offers the following features:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Creates and manages a **repository**, where it collects the source files and
    the history of changes for each one.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows sharing projects by cloning **remote repositories** into local projects.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the project to be branched and merged. This means that you can have different
    copies of the same project with different code (a **branch**), switch between
    them, join them, and unify them by request (a **merge**).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizes changes from a remote repository into a local copy (called a **pull**).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends local changes to a remote repository (called a **push**).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s learn how to use Git by applying it to our current project for this chapter.
    Let’s start by installing it in our system, so it’s available for all our projects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Windows systems
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest and recommended way to install Git on Windows systems is to download
    the installers from the official Git website at [https://git-scm.com/download/win](https://git-scm.com/download/win).
    Click on the version you want to use, according to your operating system (32-
    or 64-bit), and then run the installer following the directions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Official Git installers for Windows](img/Figure_9.07_B18602.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Official Git installers for Windows
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is done, the command-line tools will be installed on your
    system so we can run them through a terminal. Also, if you are using a code editor
    such as Visual Studio Code, it will integrate the tools and provide you with a
    GUI to handle basic operations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Linux systems
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Linux systems, the installation is done through the command line, using
    the distribution’s package manager. The package name in (almost) all distributions
    is simply `git`. In Debian and Ubuntu systems, the installation can be run with
    the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, in these distributions, there may not be the latest version, so if
    you need the latest stable release, you need to add the official PPA repository.
    In this case, run the following commands in order:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding commands will update your system dependencies and install (or
    upgrade) Git on your system. For a complete list of distributions and commands
    to install Git, please refer to the official documentation at [https://git-scm.com/download/linux](https://git-scm.com/download/linux).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Installation on macOS systems
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In macOS systems, there are different ways to install Git:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If you have Homebrew installed, run `$ brew install git` in a Terminal
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If instead, you have MacPorts, run `$ sudo port install git` in a Terminal
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have installed Xcode, Git is included
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other alternatives, please check the official documentation at https://git-scm.com/download/mac.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Using Git
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regardless of which system you are working on, or the installation type you
    made, Git will be installed in your local path, so it can be executed from any
    terminal window. To verify the installation and version, run this command (does
    not require admin privileges):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At the time of writing, the current stable version is *2.39.2*. With this done,
    open a terminal window in the root folder of our project. To start using Git,
    we need to create a local repository with this command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After the execution is done, a new hidden directory will be created in the folder.
    You don’t have to worry about it, as it will be managed by Git. If your File Explorer
    has deactivated the option to see hidden files, then you may not notice the creation.
    It is recommended that you have **Show/view hidden files** in your system activated.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created the repository, we can start using it. The steps to work
    with files usually includes the following stages:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Working stages of Git](img/Figure_9.08_B18602.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Working stages of Git
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have files created or edited, the next step is to “stage” the files.
    This indicates to Git that it needs to keep track of changes and include the file
    in the next commit event. **Committing** is the act of moving those files/changes
    into the repository. If a file is not staged, it will not be included in the commit.
    To add a file, run the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will add the files, but it is quite verbose. Instead, if you want to add
    all changes in all files, run this instead:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will come in handy in the first commit when the repository is initialized.
    After running this command, all the files will start to be tracked. However, we
    do not want to track everything in our root folder, so to exclude files or directories,
    we can use a special file named `.gitignore`. If you open this file in the example
    directory, you will find something like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: /chapter 10/.gitignore
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a plain text file that indicates to Git not to track the files and directories
    indicated in each line. You can also use wildcards such as an asterisk (`*`) and
    question mark (`?`) to include a match pattern. This is very useful, as there
    are parts of your code base that you don’t need to track, such as the node dependencies
    and binary files (images and the like). Make sure to have this file in your directory
    before making a massive staging.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have staged files, you can check them with this command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the case of our example project, it will show something like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – First staging in Git](img/Figure_9.09_B18602.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – First staging in Git
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how Git informs us also that we are in the `master` branch, and that
    there have not been any commits yet. The `master` branch is the main branch for
    our code and is created by default. This is a special branch that is used to keep
    the stable code of our applications. In tools such as GitLab and GitHub (we will
    talk about them later), these branches also trigger certain events once committed.
    For now, let’s move forward and create our first commit with this command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will see results like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Results from the first commit](img/Figure_9.10_B18602.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Results from the first commit
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: With these simple lines, we have started to keep track of our source code. Now,
    as mentioned before, we have committed our initial code to the `master` branch.
    Git allows us to make an instant copy of the state of our code, much like a screenshot,
    and continue working from there without affecting the original. This is called
    **branching** and is an important part of using Git.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Managing branches and merges
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using branches to control our development is a very good way to move forward
    on a certain footing. Here are the most common commands to manage branches:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '| Action | Command example |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| Create a branch and switch to it |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '| Create a branch but stay in current |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '| Delete branch |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '| Switch to a branch |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '| Merge a branch with current |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '| Check current branch |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Once you have moved to another branch, you can perform all the regular Git operations
    (edit and delete files, etc.) without affecting the other ones.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Merging conflicts
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When merging multiple branches together or with `master`, it is possible and
    more than likely that some files will have a discrepancy with the current branch.
    In this case, the *merge* will fail, and the user will be prompted to solve the
    differences. What Git does is mark the target file (the file in the current branch)
    with markers in the text for the user to edit. Once these have been edited, the
    file can be staged and committed, thus ending the *merge*. Let’s try that without
    code, by purposely creating a discrepancy to fix. Follow these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new branch, `dev`, with this command: `$ git checkout –``b dev`.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `index.html`, adding in line 11 (before the script tag) the following:
    `<div>A div created in` `branch dev</div>`.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file, stage it, and commit the change with `$ git add index.html` and
    then `$ git commit –m "added div` `in dev"`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will move to the `master` branch with `$ git` `checkout master`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice how line 11 with the div has disappeared from `index.html`. This is
    because that edition was never made on this file. Now, add in that line the following:
    `<p>This change was made` `in master</p>`.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file, stage it, and commit it with a different message (look at *step
    3*).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will try to merge both branches and, as `index.html` has been committed
    to both with a different code, it will fail! To start the *merge*, run `$ git
    merge dev`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see an error on the terminal, and new lines added to `index.html`
    indicating the discrepancies. In our code example, it looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Merge conflict](img/Figure_9.11_B18602.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Merge conflict
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the conflict, just edit the source code to your best judgment (also
    delete the extra labels added by Git), then save the file, stage it, and finally
    make a commit. You will receive a message indicating that the *merge* has been
    resolved.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with branches and resolving mergers when they appear is a common practice
    and quite useful, but we are still not using the full potential of Git. As you
    remember, Git is a distributed SCMS, and this relies on its great potential. Enter
    the remote repository...
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Working with remote repositories
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the same way that we work with a local repository, Git can also synchronize
    code with a remote repository. This enables team members from anywhere in the
    world to collaborate together in the same code base, resolve conflicts, and also
    synchronize their own code with others’ contributions. Working with a remote repository
    involves the following steps to set up:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The remote repository must be created, and a URL provided to connect to it.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add the remote repository as a new origin to our local repository with the
    following command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We set our `master` branch to synchronize with the remote repository:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We retrieve changes from the remote repository:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We submit our changes to the remote repository:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once you have done *steps 1* to *3*, the regular activity will involve *steps
    4* and *5*. These activities will keep your local repository synchronized with
    your remote repository. In practice, modern IDEs such as Visual Studio Code will
    already provide you with graphical tools to make these operations, and this results
    in more convenience when you are working on a project. They also include visual
    tools to resolve conflicts during *merges*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Git server for your local network is outside the scope of this
    book, but this introduction would not be complete without a word about **GitHub**
    and **GitLab**. It is common that when people first hear about Git, they associate
    it with GitHub, which is understandable, as the latter has a much more popular
    media presence. GitHub is not Git. It is a web platform that provides tools built
    on top of Git, to host online projects hosting remote repositories. Thus, you
    can perfectly work with Git locally, and synchronize with a GitHub or GitLab remote
    repository. This is the most common case.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: GitHub provides messaging and documentation tools, and much more – even additional
    services that allow detecting events in our repository to trigger certain actions
    and services, some provided locally (at a cost), others remotely (for example,
    webhooks). For example, it is possible for you to commit locally, push the changes
    to the `master` branch on GitHub, and have a whole set of routines started, from
    compilation to website presentation. Again, managing all these options is outside
    our current scope in this chapter, but the important thing to remember is that
    all of this is based and built upon Git, so if you understand *how* it the works
    and *what* it does, you have a solid foundation to move ahead with other tools
    and services. There is one more concept that has become familiar with this topic,
    Continuous Integration and Delivery, which we will see next.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration and Delivery
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) is a practice enabled by the technologies
    we have seen thus far, where developers commit their changes to a central (remote)
    repository as frequently as possible. The central repository detects the incoming
    changes and triggers automated tests against the code. Then, it compiles/builds
    the final product. This is done continuously, as opposed to the practice of merging
    and compiling on a given date before launch.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Delivery** (**CD**) builds on top of CI, by also deploying the
    released product to its final location. You can configure this process to create
    preliminary versions of software or web applications, (for example, betas, nightly
    builds, etc.), and program a release date for the end location and delivery to
    the customers (sometimes, this last part may involve a process of its own and
    is called **Continuous Deployment**). Both services mentioned before (GitHub and
    GitLab) offer these types of services.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: By using these concepts, it is possible to set up a whole automated workflow
    from your desktop to the web, where a simple Git commit and a push to the server
    would trigger your application to be tested and published in its destination online.
    The way to implement this workflow is particular to the tool used to implement
    CI and CD.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered very important concepts regarding the care
    and quality of our code. We have learned how to install official tools to perform
    automated tests in our code and components, as well as how to keep track of changes
    and management in the source code. While the examples and information provided
    here are introductory, they are detailed enough to implement them in your own
    projects and keep your learning skills growing. The concepts of CI and CD, as
    well as services provided by online repositories, also give you a solid foundation
    to learn to use them, as they all are based on the functionality provided by Git.
    All these tools have professional value for a developer and are required in the
    industry today.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is automated testing important? Does it eliminate the need to perform manual
    testing?
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is necessary to test our Single File Components in Vue?
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is source control, and why is it necessary?
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Git, and how is it different from GitHub/GitLab?
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you modify a file in a branch, does that modify it in all other branches?
    Why does or doesn’t this happen?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the commands to control Git the same across all platforms?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do CI and CD stand for, and what is the value they add to a workflow?
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
