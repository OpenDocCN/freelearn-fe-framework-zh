- en: Deploying to the Cloud with Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 部署到云端
- en: Kubernetes, also known as the container orchestration tool. As we have seen
    in the previous chapter, it comes with many additional features and is much easier
    to configure and manage. This makes Kubernetes a default choice for any container
    orchestration. The ability to mask the lower-level details and provide out-of-the-box
    service discovery, self-healing, and health checks attracted many companies and
    organizations to switch to Kubernetes. Aside from that, Kubernetes is the evolution
    of Google's internal orchestration tool.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes，也称为容器编排工具。正如我们在上一章所看到的，它附带了许多附加功能，并且配置和管理起来更加容易。这使得 Kubernetes 成为任何容器编排的首选。能够隐藏底层细节并提供开箱即用的服务发现、自我修复和健康检查吸引了众多公司和组织转向
    Kubernetes。除此之外，Kubernetes 还是 Google 内部编排工具的演变。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generating Kubernetes configuration files with JHipster
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JHipster 生成 Kubernetes 配置文件
- en: Walking through the generated files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看生成的文件
- en: Deploying the application to Google Cloud with Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 将应用程序部署到 Google Cloud
- en: Generating Kubernetes configuration files with JHipster
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JHipster 生成 Kubernetes 配置文件
- en: Knowing the components of Kubernetes and how it works is beyond the scope of
    this book. However, we will look at how JHipster simplifies microservices deployment
    with Kubernetes. Let's go ahead and generate the Kubernetes configuration file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Kubernetes 的组件及其工作原理超出了本书的范围。然而，我们将探讨 JHipster 如何简化使用 Kubernetes 的微服务部署。让我们继续生成
    Kubernetes 配置文件。
- en: Similar to the `docker-compose` sub-generator, JHipster also comes bundled with
    a Kubernetes sub-generator. In order to use it, just like with `docker-compose`,
    we will create a new folder and name it Kubernetes. Then, we will go inside the
    folder to create the configuration files.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `docker-compose` 子生成器类似，JHipster 也附带了一个 Kubernetes 子生成器。为了使用它，就像使用 `docker-compose`
    一样，我们将创建一个新的文件夹并将其命名为 Kubernetes。然后，我们将进入该文件夹以创建配置文件。
- en: 'We can create Kubernetes configuration files with the following command and
    then answer the questions that the sub-generator asks us:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令创建 Kubernetes 配置文件，然后回答子生成器提出的问题：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To install kubectl, please follow the instructions at Kubernetes' website ([https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 kubectl，请遵循 Kubernetes 网站的说明（[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)）。
- en: Kubernetes sub-generator needs kubectl (v1.2 or later) to be installed on your
    computer. kubectl is the command line interface for Kubernetes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 子生成器需要在您的计算机上安装 kubectl（v1.2 或更高版本）。kubectl 是 Kubernetes 的命令行界面。
- en: 'We can also install Cloud SDK from Google Cloud, which will also install kubectl.
    To set up gcloud:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从 Google Cloud 安装 Cloud SDK，这将也会安装 kubectl。为了设置 gcloud：
- en: Download the binary (based on your operating system) from[ https://cloud.google.com/sdk/](https://cloud.google.com/sdk/).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)下载基于您操作系统的二进制文件。
- en: Then, install the application by following the steps given on the website (make
    sure that you have python installed).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照网站上的步骤安装应用程序（确保您已安装 python）。
- en: Once installed, set up Google Cloud. In order to set up Google Cloud, run `gcloud
    init`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，设置 Google Cloud。为了设置 Google Cloud，请运行 `gcloud init`。
- en: 'This will then ask you to log in to your Google account:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将要求您登录到您的 Google 账户：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we have seen already, Kubernetes needs separate tools for running locally
    (that is for development purposes). Therefore, if you need to do things locally,
    please install minikube from Kubernetes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，Kubernetes 需要单独的工具来在本地运行（即用于开发目的）。因此，如果您需要在本地进行操作，请安装 Kubernetes 的
    minikube。
- en: 'The first question the sub-generator asks is which type of application we''d
    like to deploy. It provides two options, which are monolithic and microservices. 
    We will choose the microservices option:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 子生成器首先会问我们希望部署哪种类型的应用程序。它提供了两种选项，即单体和微服务。我们将选择微服务选项：
- en: '![](img/6acdbc99-a5b2-4686-90cc-b9ab1a8e011d.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6acdbc99-a5b2-4686-90cc-b9ab1a8e011d.png)'
- en: 'Then, it asks us to enter the root directory. We will select the default option
    since our directories are present as the siblings of the Kubernetes folder:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它会要求我们进入根目录。由于我们的目录作为 Kubernetes 文件夹的兄弟存在，我们将选择默认选项：
- en: '![](img/6ae09d92-e019-4a61-97f1-46a76474ed2e.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ae09d92-e019-4a61-97f1-46a76474ed2e.png)'
- en: 'Then, the sub-generator will list all the folders with our JHipster generated
    application. Here, it will list all three applications that we need—gateway, invoice,
    and notification. Select all three applications and hit enter:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，子生成器将列出所有由 JHipster 生成的应用程序的文件夹。在这里，它将列出我们需要的所有三个应用程序——网关、发票和通知。选择所有三个应用程序并按回车键：
- en: '![](img/67486104-8c87-44f7-9e81-9a43cfae4c46.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67486104-8c87-44f7-9e81-9a43cfae4c46.png)'
- en: 'Then, it will ask us to provide the password for the registry service. In our
    case, it is JHipster Registry. We will select the default one for now, but it
    is generally advisable to use a strong password here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将要求我们提供注册服务的密码。在我们的情况下，它是 JHipster 注册表。我们现在将选择默认设置，但通常建议在这里使用一个强密码：
- en: '![](img/3eef9433-a527-413c-ad49-fa4112840d75.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3eef9433-a527-413c-ad49-fa4112840d75.png)'
- en: Afterward, it will ask us for the namespace that we need to use in Kubernetes.
    So, what is a namespace?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它将询问我们需要在 Kubernetes 中使用的命名空间。那么，什么是命名空间？
- en: 'We can consider namespaces as a group within which resources should be named
    uniquely. When the cluster is shared between different users or teams, namespaces
    can provide resource quotas for them. Ideally, namespaces should be used only
    for a larger team. For smaller teams, it is better to go with default options.
    Kubernetes, by default, provides three namespaces, which are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将命名空间视为一个组，其中资源应该具有唯一的名称。当集群在不同用户或团队之间共享时，命名空间可以为它们提供资源配额。理想情况下，命名空间应仅用于大型团队。对于小型团队，最好选择默认选项。Kubernetes
    默认提供三个命名空间，如下所示：
- en: '`Default`: When you start a container or pod without providing any namespaces,
    they will end up in the default namespace'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default`：当你启动容器或 pod 而不提供任何命名空间时，它们将最终进入默认命名空间'
- en: '`Kube-system`: This namespace contains Kubernetes system-based objects'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kube-system`：这个命名空间包含基于 Kubernetes 系统的对象'
- en: '`Kube-admin`: This is a public namespace, which will be shown to all the users
    publically without any authentication'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kube-admin`：这是一个公开的命名空间，将向所有用户公开显示，无需任何身份验证'
- en: 'We will select the default namespace here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里选择默认命名空间：
- en: '![](img/b8ac9f07-0185-4e74-af39-0d9169146467.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8ac9f07-0185-4e74-af39-0d9169146467.png)'
- en: 'Then, the sub-generator will ask for our Docker repository name so that Kubernetes
    can use this Docker repository to pull the images (the login username of the Docker
    repository):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，子生成器将要求我们提供 Docker 仓库名称，以便 Kubernetes 可以使用此 Docker 仓库来拉取镜像（Docker 仓库的登录用户名）：
- en: '![](img/790e7e6e-b79a-4597-b13c-bf30de057917.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/790e7e6e-b79a-4597-b13c-bf30de057917.png)'
- en: 'Then, the sub-generator will ask for our command so that we can push the image
    to the Docker repository. We will select the default command here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，子生成器将要求我们提供命令，以便我们可以将镜像推送到 Docker 仓库。我们将在这里选择默认命令：
- en: '![](img/88656422-6281-4981-b5bd-97288393c255.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88656422-6281-4981-b5bd-97288393c255.png)'
- en: 'Then, it will ask whether we need the JHipster-console for log aggregation,
    and we will select Yes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将询问我们是否需要 JHipster-console 进行日志聚合，我们将选择是：
- en: '![](img/ce7f95fc-1224-4c69-a2f7-7795416c4b4a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce7f95fc-1224-4c69-a2f7-7795416c4b4a.png)'
- en: 'JHipster also comes with Prometheus integration, so the next question will
    be whether we would like to export our services to Prometheus. It needs a Prometheus
    operator in general to work. We will select No for this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 还提供了 Prometheus 集成，所以下一个问题将是是否希望将我们的服务导出到 Prometheus。通常需要 Prometheus
    操作员才能工作。我们将选择否：
- en: '![](img/567e9a6b-7e7f-4da7-a5d1-b3bc246ad0a5.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/567e9a6b-7e7f-4da7-a5d1-b3bc246ad0a5.png)'
- en: Then, the generator will ask us to choose the Kubernetes service type. So, what
    is the service type?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，生成器将要求我们选择 Kubernetes 服务类型。那么，服务类型是什么？
- en: In Kubernetes, everything that we deploy is a pod. These pods are managed by
    replication controllers, which can create and destroy any pods. Each pod needs
    an identifier, so they are tagged with an IP address. This dynamic nature of pods
    will lead to a lot of problems for other pods that depend on them. To come up
    with a solution for this problem, Kubernetes introduced services. Services are
    nothing but a logical grouping of unique pods which have policies attached to
    them. These policies are applicable for all the pods inside the services, but
    we need to publish these services to the external world to access them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，我们部署的每一件事都是一个 pod。这些 pod 由复制控制器管理，可以创建和销毁任何 pod。每个 pod 都需要一个标识符，因此它们被标记为
    IP 地址。pod 的这种动态特性将导致许多依赖它们的 pod 出现问题。为了解决这个问题，Kubernetes 引入了服务。服务不过是具有附加策略的唯一
    pod 的逻辑分组。这些策略适用于服务内的所有 pod，但我们需要将这些服务发布到外部世界以供访问。
- en: One of the most powerful features of Kubernetes is that they help to maintain
    the number of replicas of pods consistently.  The replication controller helps
    to maintain the pods count by automatically shutting down and booting up the pods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最强大的功能之一是它们帮助保持pods副本数的一致性。副本控制器通过自动关闭和启动pods来维护pods的数量。
- en: 'Kubernetes gives us four different service types, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了四种不同的服务类型，如下所示：
- en: '`Cluster IP`: This is the default type. This will assign the cluster''s internal
    IP and make it visible within the cluster itself.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cluster IP`：这是默认类型。这将分配集群的内部IP，并在集群内部可见。'
- en: '`NodePort`: This will expose the service to a static port in the Node''s IP.
    The port will be random and will be chosen between `30000`-`32767`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NodePort`：这将使服务在节点的IP上的静态端口暴露。端口号将是随机的，将在`30000`-`32767`之间选择。'
- en: '`LoadBalancer`: This will expose the service externally. Kubernetes will assign
    an IP automatically. This will create a route to the NodePort and Cluster IP internally.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadBalancer`：这将使服务外部暴露。Kubernetes将自动分配一个IP。这将创建一个指向NodePort和Cluster IP的内部路由。'
- en: '`Ingress`: An Ingress is a special option that Kubernetes provides. This will
    provide load-balancing, SSL termination, and name-based virtual hosting to the
    services.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ingress`：Ingress是Kubernetes提供的一个特殊选项。这将提供负载均衡、SSL终止和基于名称的虚拟主机服务。'
- en: 'We will select the `LoadBalancer` option:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择`LoadBalancer`选项：
- en: '![](img/dce399ad-02ea-4fdc-9036-2275152bb2f0.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dce399ad-02ea-4fdc-9036-2275152bb2f0.png)'
- en: That's it. This will generate the necessary configuration files for us to deploy
    the application with Kubernetes. Next up, we will check the files that have been
    generated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。这将为我们生成必要的配置文件，以便我们使用Kubernetes部署应用程序。接下来，我们将检查生成的文件。
- en: Walking through the generated files
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查生成的文件
- en: The files generated by JHipster are in the following structure. That is, each
    application will have its own folder and the files related to that service will
    be present inside it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster生成的文件结构如下。也就是说，每个应用程序都将有自己的文件夹，并且与该服务相关的文件将位于其中。
- en: We will start with the gateway application. There will be three generated files,
    which will be the `gateway-service`, `gateway-mysql`, and `gateway-deployment.yml`
    files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网关应用程序开始。将生成三个文件，它们将是`gateway-service`、`gateway-mysql`和`gateway-deployment.yml`文件。
- en: 'The following is the `gateway-service.yml` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的文件是`gateway-service.yml`：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line defines the API version of Kubernetes, followed by the kind of
    template or object that this template carries. This template will have a service
    inside of it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了Kubernetes的API版本，然后是此模板或对象的类型。此模板将包含一个服务。
- en: 'Then, we will have the metadata information. Kubernetes uses this metadata
    information to group certain services together. In the metadata, we can define:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将有元数据信息。Kubernetes使用这些元数据信息来将某些服务分组在一起。在元数据中，我们可以定义：
- en: The service name
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务名称
- en: The namespace it belongs to
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它所属的命名空间
- en: The labels, which are key and value pairs
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签，它们是键值对
- en: Then, we will define the spec. The spec in the Kubernetes object will provide
    the state of the service. In the spec, we can define the number of replicas we
    need. We can also define the selector, within which we can specify the service
    with identifiers. We can also specify the type of the service. Kubernetes will
    take the information from this spec and then maintain the application in the state
    provided (we will have a look at the spec gateway in a while), followed by the
    ports in which port the application should run. This is similar to the Dockerfile,
    so we are exposing the `8080` port for the gateway service.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义spec。在Kubernetes对象中的spec将提供服务的状态。在spec中，我们可以定义所需的副本数量。我们还可以定义选择器，在其中我们可以指定具有标识符的服务。我们还可以指定服务的类型。Kubernetes将从此spec中获取信息，然后维护应用程序在提供的状态（我们稍后将查看spec网关），然后是应用程序应该运行的端口。这与Dockerfile类似，因此我们正在暴露网关服务的`8080`端口。
- en: 'Then, we have the `gateway-mysql.yml` file, where we have defined our MySQL
    server for the gateway application. The difference here is that the spec points
    to `gateway-mysql`, which is defined in the same file and is exposed on port `3306`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`gateway-mysql.yml`文件，其中我们为网关应用程序定义了MySQL服务器。这里的区别在于spec指向`gateway-mysql`，它在同一文件中定义，并且暴露在端口`3306`上：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `gateway-mysql` app declaration, we have specified the database and environment
    properties that are needed for our application to run. Here, the `kind` is mentioned
    as **deployment**. The job of the deployment object is to change the state of
    the services to the state that is defined in the deployment object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gateway-mysql` 应用声明中，我们指定了应用程序运行所需的数据库和环境属性。在这里，`kind` 被提到为 **deployment**。部署对象的工作是改变服务的状态，使其符合部署对象中定义的状态。
- en: 'Here, we have defined a single replica of the MySQL server, followed by the
    spec, where we have mentioned the version of MySQL that we need (the container).
    This is then followed by the username, password, and then the database schema.
    We can also specify the volume information with volume mounts for persistent storage:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 MySQL 服务器的单个副本，然后是规范，其中我们提到了我们需要的 MySQL 版本（容器）。然后是用户名、密码，然后是数据库模式。我们还可以指定卷信息，使用卷挂载进行持久化存储：
- en: 'Note: we can also define a spec inside a spec object (as shown in the following
    code):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们也可以在规范对象内部定义一个规范（如下面的代码所示）：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similarly, we have `gateway-deployment.yml`, in which we have defined the gateway
    application and its environment properties along with the other details like ports,
    probes and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们有一个 `gateway-deployment.yml` 文件，其中我们定义了网关应用程序及其环境属性，以及其他细节，如端口、探针等。
- en: A similar approach is done for both the invoice and notification services. You
    can find them in their respective folders.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发票和通知服务，我们采用了类似的方法。您可以在各自的文件夹中找到它们。
- en: In `JHipster-registry`, alongside `Service` and `Deployment`, we have defined
    Secret and StatefulSet.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `JHipster-registry` 中，除了 `Service` 和 `Deployment` 之外，我们还定义了 Secret 和 StatefulSet。
- en: The secret is used to handle passwords. It will be an opaque type and the password
    is base64 encoded.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥用于处理密码。它将是一个不透明的类型，密码将以 base64 编码。
- en: Then, we have the StatefulSet, which are similar to pod except they have a sticky
    identity. Pods are dynamic in nature. These pods have a persistent identifier
    that is maintained throughout. It makes sense for a registry server to be defined
    as a StatefulSet, since it is essential that the registry server should be identified
    by a persistent identifier. This enables all services to connect to that single
    endpoint and get the necessary information. If the registry server is down, then
    communication between the services will also have problems, since the services
    connect to other services via the registry server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有 StatefulSet，它们类似于 pod，但具有粘性标识符。Pods 是动态的。这些 pod 有一个在整个过程中保持不变的持久标识符。将注册表服务器定义为
    StatefulSet 是有意义的，因为注册表服务器应该通过一个持久的标识符来识别。这使得所有服务都可以连接到该单个端点并获取必要的信息。如果注册表服务器宕机，那么服务之间的通信也会出现问题，因为服务通过注册表服务器连接到其他服务。
- en: 'There are various options that are available to set the controller, which are
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种选项可以设置控制器，如下所示：
- en: '**Replica Set**: Provides a replica of pods at any time with selectors'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副本集**：在任何时候通过选择器提供 pods 的副本'
- en: '**Replica Controller**: Provides a replica of pods without any selectors'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副本控制器**：提供没有选择器的 pods 的副本'
- en: '**StatefulSet**: Makes the pod unique by providing it with a persistent identifier'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态集**：通过提供一个持久的标识符使 pod 唯一'
- en: '**DaemonSet**: Provides a copy of the pod which is going to be run'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护进程集**：提供将要运行的 pod 的副本'
- en: The JHipster Registry is configured in a cluster and with high availability.
    The UI access to the JHipster Registry is also restricted to the cluster for better
    security.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 注册表配置在集群中，并具有高可用性。对 JHipster 注册表的 UI 访问也仅限于集群，以增强安全性。
- en: Similarly, configuration files are generated for the JHipster Console, and they
    are placed in a console folder, which is `jhipster-console.yml`, where the JHipster
    Console is also defined.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为 JHipster 控制台生成了配置文件，并将它们放置在控制台文件夹中，该文件夹是 `jhipster-console.yml`，其中也定义了
    JHipster 控制台。
- en: The JHipster Console runs on an ELK stack, so we need Elasticsearch, which is
    defined in `jhipster-elasticsearch.yml`, followed by Logstash in the `jhipster-logstash.yml`
    file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 控制台运行在 ELK 堆栈上，因此我们需要 Elasticsearch，它在 `jhipster-elasticsearch.yml`
    文件中定义，然后是 Logstash 在 `jhipster-logstash.yml` 文件中。
- en: Deploying the application to Google Cloud with Kubernetes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 将应用程序部署到 Google Cloud
- en: We have created Kubernetes configuration files with the `jhipster kubernetes` command.
    The next step is to build the artifacts and deploy them into Google Cloud.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `jhipster kubernetes` 命令创建了 Kubernetes 配置文件。下一步是构建工件并将它们部署到 Google Cloud。
- en: Kubernetes will use the image from the Docker Registry. We configured the Docker
    username when we generated the application, so the first step will be to tag those
    images and then push them to our Docker repository.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 将使用 Docker 仓库中的镜像。我们在生成应用程序时配置了 Docker 用户名，因此第一步将是标记这些镜像，然后将它们推送到我们的
    Docker 仓库。
- en: 'To do so, we will do the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将执行以下操作：
- en: 'We will open the terminal and go to the Kubernetes folder that we have generated:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开终端并转到我们生成的 Kubernetes 文件夹：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And we will push this image into the Docker repository:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将此镜像推送到 Docker 仓库：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note: you have to log in to the Docker Hub before pushing the image. You can
    login to Docker using the `docker login` command followed by your username and
    password. If you don''t have an account, you can create one at the following link: [https://cloud.docker.com/](https://cloud.docker.com/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在推送镜像之前，您必须登录到 Docker Hub。您可以使用 `docker login` 命令，后跟您的用户名和密码登录 Docker。如果您没有账户，您可以在以下链接创建一个：[https://cloud.docker.com/](https://cloud.docker.com/)。
- en: 'Similarly, push the invoice application to the Docker repository:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，将发票应用程序推送到 Docker 仓库：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Do the same for notification:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对通知也进行相同的操作：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will push gateway, invoice, and notification to the Docker repository.
    We can check this in the Docker console:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将推送网关、发票和通知到 Docker 仓库。我们可以在 Docker 控制台中检查这一点：
- en: '![](img/87c9e9ec-e51d-4afd-babb-c1516fb83679.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87c9e9ec-e51d-4afd-babb-c1516fb83679.png)'
- en: Now, we can connect to gcloud and deploy our containers with Kubernetes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以连接到 gcloud 并使用 Kubernetes 部署我们的容器。
- en: This assumes that you have set up gcloud SDK and kubectl on your machine.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设您已经在您的机器上设置了 gcloud SDK 和 kubectl。
- en: 'First, we will log in to the gcloud via the Terminal. In order to do that,
    open your Terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过终端登录到 gcloud。为了做到这一点，打开您的终端：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, gcloud will ask you to log in to your google account. Once validated,
    this will list the projects that you might already have.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，gcloud 将要求您登录到您的 Google 账户。一旦验证，这将列出您可能已经拥有的项目。
- en: Here, we can choose [31] Create a new projectby entering the number before creating
    a new project. Then, press enter. It will ask you to enter the project information
    and then configure a few Google services for that project. Then, gcloud will list
    all the available regions and you can choose a region that suits you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过在创建新项目前输入数字来选择 [31] 创建新项目。然后按回车键。系统将要求您输入项目信息，然后为该项目配置一些 Google 服务。然后，gcloud
    将列出所有可用的区域，您可以选择一个适合您的区域。
- en: 'If you have already logged in to the console and used it for other projects,
    then you can switch projects using the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经登录到控制台并用于其他项目，则可以使用以下命令切换项目：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will set the project, region, and the setting chosen as the default.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置项目、区域和选择的设置作为默认值。
- en: Then, you have to enable Kubernetes in our application. We can do this by logging
    in to our Google Cloud console via the browser. Then, select the project that
    we have just created and go to [https://console.cloud.google.com/kubernetes/list](https://console.cloud.google.com/kubernetes/list).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须在我们的应用程序中启用 Kubernetes。我们可以通过浏览器登录到我们的 Google Cloud 控制台来完成此操作。然后，选择我们刚刚创建的项目，并转到
    [https://console.cloud.google.com/kubernetes/list](https://console.cloud.google.com/kubernetes/list)。
- en: 'This will create a cluster for your project. Instead, you can create a cluster
    using the `gcloud` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您的项目创建一个集群。相反，您可以使用 `gcloud` 命令创建一个集群：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the output of the preceding command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在先前的命令输出：
- en: '![](img/cdb14c70-6bc6-4eb2-b6f6-453e482c0ef0.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdb14c70-6bc6-4eb2-b6f6-453e482c0ef0.png)'
- en: Thus, the cluster is created with 3 nodes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集群已使用 3 个节点创建。
- en: 'Then, we can go to our Kubernetes folder and start deploying the services using
    kubectl:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以进入我们的 Kubernetes 文件夹，并使用 kubectl 开始部署服务：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/d26a63b8-7c32-4fe8-9aab-f8ccb30161ab.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d26a63b8-7c32-4fe8-9aab-f8ccb30161ab.png)'
- en: This will create all the applications in the Google Cloud environment, under
    your project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 Google Cloud 环境中创建所有应用程序，位于您的项目下。
- en: 'You can check the `pods` deployment process using the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令检查 `pods` 部署过程：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will list down the `pods` that are spinning up and shutting down:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出正在启动和关闭的 `pods`：
- en: '![](img/d4332800-c6e5-4cba-b901-dcd6ff5c92e7.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4332800-c6e5-4cba-b901-dcd6ff5c92e7.png)'
- en: 'You can also get the logs of the application using the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令获取应用程序的日志：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其输出：
- en: '![](img/8f2ffa96-cec5-443b-9835-f62b3f23f5fb.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f2ffa96-cec5-443b-9835-f62b3f23f5fb.png)'
- en: 'You can get the application''s external IP using this piece of code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码片段获取应用程序的外部IP：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will list the application''s name, type, IP address, external address,
    ports, and uptime:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出应用程序的名称、类型、IP地址、外部地址、端口和运行时间：
- en: '![](img/4b2ec1cb-3981-4381-9115-a3f4d12a4920.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b2ec1cb-3981-4381-9115-a3f4d12a4920.png)'
- en: 'We can find the same information on the Google Cloud console:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Google Cloud控制台中找到相同的信息：
- en: '![](img/1f39f95d-c307-48c9-b277-f4e69cf3d4bc.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f39f95d-c307-48c9-b277-f4e69cf3d4bc.png)'
- en: 'The application can be accessed at the preceding External-IP:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过前面的外部IP访问：
- en: '![](img/bfe0972c-578b-462a-8f83-d56110c76a89.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfe0972c-578b-462a-8f83-d56110c76a89.png)'
- en: 'You can also scale the application by using the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下命令来扩展应用程序：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The JHipster-registry is deployed in headless mode. In order to check the JHipster
    registry, we can explicitly expose the service by using this command—`**kubectl
    expose service jhipster-registry --type=NodePort --name=exposed-registry**`—and
    then we can access the application via `exposed-registry`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster-registry以无头模式部署。为了检查JHipster注册表，我们可以使用以下命令显式暴露服务——`**kubectl expose
    service jhipster-registry --type=NodePort --name=exposed-registry**`——然后我们可以通过`exposed-registry`访问应用程序。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Orchestrating your containers is the most difficult task to perform in the microservices
    environment. Kubernetes, as a container orchestrator, stands out in solving this.
    We have seen how to generate the configuration file for Kubernetes with JHipster,
    followed by deploying the application to the Google Cloud.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务环境中，编排你的容器是最难执行的任务。Kubernetes作为一个容器编排器，在解决这一问题上脱颖而出。我们已经看到了如何使用JHipster生成Kubernetes的配置文件，随后将应用程序部署到Google
    Cloud。
- en: So far, we've seen how we can develop and deploy an e-commerce application using
    JHipster. We started with a monolith and we successfully scaled it into a microservice
    architecture, all with the help of JHipster and the various tools and technologies
    it supports. With this chapter, our journey of developing the e-commerce web application
    comes to an end and we hope you had a wonderful experience following it though.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用JHipster开发和部署电子商务应用程序。我们从单体应用开始，并成功将其扩展到微服务架构，这一切都得益于JHipster及其支持的各项工具和技术。随着本章的结束，我们希望你在跟随它的过程中有一个愉快的体验。
- en: In the next chapter, we will see how you can use JHipster further to create
    an application with a React client-side application, so stay tuned.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何进一步使用JHipster创建一个具有React客户端应用程序的应用程序，所以请保持关注。
