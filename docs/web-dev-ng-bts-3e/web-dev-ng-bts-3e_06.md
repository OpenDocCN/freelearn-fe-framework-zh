# 第六章：构建 Angular 组件

由于整个 Angular 由几个相互关联的部分组成，几乎不可能选择 Angular 的某一部分比其他部分更重要。删除其中任何一个部分都会使整个系统受损，甚至可能变得无用。话虽如此，如果我必须选择一个真正重要的部分，我会选择组件。组件有几个非常酷的特点，比如当我们构建组件时，我们基本上也在扩展 HTML，因为我们正在创建自定义 HTML 标签。组件是 TypeScript 类，正如我们稍后在本章中将看到的那样，我们将代码链接到自定义 HTML 标签的方式是通过`@Component`注释。我也会在本章后面解释注释是什么。

在此之后使用的术语简要说明：我使用“部分”一词而不是“组件”一词，以避免混淆，因为“组件”一词是一个多义词-在不同的上下文中有不同的含义。此外，当谈论视图（即屏幕）时，我从经典的 Web 应用程序角度使用“页面”一词，而不是字面意义上的意思。

Angular 应用程序包含一个根组件。但是，在讨论应用程序的屏幕或视图时，有必要提及其他充当该视图的根组件的组件。例如，注册屏幕有一个根组件。

以下是我们将一起涵盖的主题的项目列表：

+   一个 Angular 应用程序作为组件树

+   `@Component`注释

+   `@Component`注释的属性

+   内容投影

+   生命周期钩子

+   组件接口

+   需要实现与本章相关的三个线框的组件

# Angular 应用程序架构-组件树

Angular 应用程序基本上是一个组件树。正如我们在之前的章节中学到的，Angular 是一个单页面应用程序框架，因此有一个单页面来展示其组件树。我们已经看到 Angular 有一个顶层组件，称为根组件，根据我们希望应用程序对用户操作做出的响应，我们让根组件加载其他组件。这些其他组件（暂时称它们为*次级根组件*）反过来递归地渲染其他组件。我们在第四章中设置路由的方式是将 URL 映射到我们的*次级根组件*，每个*页面*一个组件，当用户点击导航（即菜单）链接时，它们就会显示出来。

所有这些都是可能的原因是组件是可组合的。这意味着我们的组件由其他组件组成，因此是嵌套的。我们可以在任意深的组件层次结构中嵌套我们的组件，因此在本节的开头就有了这样的陈述，*Angular 应用程序基本上是一个组件树*。

Angular 框架会递归地加载和渲染我们的组件。

# 设计 Angular 应用程序

就像大多数工程项目一样，软件项目也需要有一个设计和架构应用程序的过程。开始的典型方式是将你正在构建的东西分解成独立的工作块。在 Angular 的术语中，这意味着我们需要将我们的应用程序分解成独立的组件，每个组件负责某些事情，比如显示计算结果或接受用户输入。

一旦我们有了需要使用的组件列表（无论是第三方组件还是自定义组件），我们需要把它们当作黑匣子——或数学函数。让我解释一下我的意思。

当我说我们需要把组件当作黑匣子对待时，我是在建议我们不应该在这个阶段（即我们只是列举它们时）让我们的思绪被它们的实现所占据。我们将在本章稍后关注构建我们的组件，但现在，把它们当作黑匣子就足够了。

当我说我们需要把组件当作数学函数来对待时，我只是建议我们考虑输出会是什么，以及函数（也就是我们的组件）需要什么输入。组件的输入和输出构成了它们的公共接口。我们稍后会更仔细地研究组件接口。

# 将你的组件分解为子组件

一个应用程序中的组件数量，甚至每个页面中的组件数量，都各不相同。它可以从几个到几百甚至更多。然而，对于将组件（比如作为特定页面的顶级组件的子组件）分解为子组件，有一个很好的经验法则。如果你记住了组件的可重用性，当你将组件分解为子组件时，你只需要问自己这个问题：“这个组件有两个或更多部分可以在其他地方重用吗？”如果答案是肯定的，你可能会受益于进一步分解。如果答案是否定的，那么你就完成了，不需要再进一步分解组件。

让我们考虑一个简单的例子，只是为了让这个问题不那么抽象。假设你在页面上有一个商品清单，每个商品占据一行，商品就是一个组件。我们还假设每个商品都有一个缩略图，用于显示该商品。如果缩略图可以在其他地方使用，比如在结账页面或商品详细页面，那么这个缩略图应该是它自己的组件，是商品组件的子组件。

从商品清单示例中放大一点，从页面视图开始，你可以采取这种方法来帮助你在规划组件时开始：

+   你的页面页眉也是一个组件

+   你可能在页面右侧有一个快速链接部分，这也将是另一个组件

+   你有你的主要内容部分，占据了大部分屏幕空间，这也将是一个组件

+   你的页面页脚也是一个组件

从前面的组件中，所有这些组件都可能是可重用的，除了主要内容部分。您可能希望您的页面标题和页面页脚出现在应用程序中的每个页面上，并且您可能希望在各个页面上重新显示快速链接部分。出于这些原因，这些组件可能已经很好了。不需要进一步的拆分。您需要拆分主要内容组件的原因是它不可重用，因为您不太可能拥有相同页面的两个副本！

# 组件责任

被架构化的 Angular 应用程序将具有不仅可重用而且有明确定义边界的组件。也就是说，它们具有关注点分离。每个组件只做一件事，并且做得很好。这些组件应该相互抽象，它们不应该了解彼此的细节（即实现）。它们应该了解彼此的唯一事情是如何与彼此通信。这是通过它们的公共接口实现的，我们很快会看到这一点。

目前，您需要知道的是，当您计划应用程序的组件时，您应该列出它们的责任。也就是说，写下它们将要做什么。敏锐的读者可能会看到用例图和组件责任列表之间的联系，因为组件是用户将如何与应用程序交互的方式。

# 注解

注解是 TypeScript 的一个新特性。它们是以`@`符号为前缀的符号，我们将其添加到我们的代码中（即用于装饰我们的类）。注解可以出现在我们的类声明顶部，或者在我们的函数顶部，甚至在我们的类属性顶部。一般来说，注解的作用是在它们附加的地方（即我们的类、函数或属性）注入样板代码。虽然我们不需要注解，因为我们可以选择自己编写样板代码，但我们最好利用它们，因为样板代码不应该一遍又一遍地编写。此外，通过使用注解而不是手写样板代码，不仅可以消除单调乏味，而且我们不必处理容易出错的代码。我们将在本书的各个章节中看到更多的注解，但让我们专注于本章的`@Component`和`@NgModule`装饰器。

# @Component

虽然注解可以出现在我们的类声明顶部，或者在我们的函数顶部，甚至在我们的类属性顶部，但`@Component`注解将始终出现在我们组件类声明的顶部。

为了使`@Component`注解对我们可用，我们必须像这样导入它：

```ts
import { Component } from '@angular/core';
```

让我们仔细看一下那行代码。这是 JavaScript，具体来说是 ES6。如果你还记得第二章中的*ECMAScript 和 TypeScript 速成课程*，这个语句的大括号部分是 ES6 中称为*解构*的新构造。此外，没有明确的路径指向`@angular/core`模块。我们让 CLI 和 TypeScript 编译器来找出模块在哪里，以及如何加载和使其在我们的类中可用。

# @Component 装饰器的属性

`@Component`装饰器为配置我们的组件提供了许多属性。让我们来看看它们。

# 选择器

`selector`是`@Component`注解的一个属性，它的值（类型为字符串）是为我们的自定义 HTML 标签命名的。我喜欢汽车，所以这里有一个`car`组件的示例代码，显示了它的注解、选择器和类名：

```ts
@Component({
 selector: 'car'
})
class CarComponent {
}
```

当 Angular 看到我们的自定义 HTML 标签`<car></car>`时，它会创建我们的`CarComponent`的一个实例，并将我们的自定义标签替换为浏览器实际理解的一些 HTML。好的，但是在我们的组件类中，我们在哪里添加东西，使我们的组件不再只是一个幽灵般的光环？下一节就是答案（即`template`属性）。

# 模板和模板 URL

我们可怜的小`car`组件目前还没有可见的主体。这是因为 Angular 需要知道在渲染我们的`car`组件时要添加什么浏览器友好的 HTML，而我们还没有为 Angular 提供这个。提供的方法是使用`template`属性（类型为字符串）来保存 Angular 在创建`CarComponent`类的实例后将为我们渲染的 HTML（每当它看到我们的自定义标签`<car></car>`时）。让我们通过加强我们之前的`@Component`注解来纠正这一点：

```ts
@Component({
  selector: 'car',
  template: '<h3>What production car has the fastest acceleration 
     time from 0 to 60?</h3><p>Tesla </p>'
})
class CarComponent {
}
```

如果我们的组件需要大量 HTML 会发生什么？好吧，这就是为什么我们有另一个可以使用的属性，`templateUrl`*。*`templateUrl`属性为我们提供了一种将组件的 HTML 从组件类外部化并放在单独文件中的方法。您的`template`属性看起来可能是这样的：

```ts
template: 'car.html'
```

# styles 和 stylesUrls

`styles`属性用于您期望的用途-向我们的组件模板添加样式。就像`template`属性一样，值的类型是字符串。此外，因为在多行上间隔 CSS 最容易阅读，我们将使用反引号字符（在 ES6 中是新的，因此也在 TypeScript 中可用），它使我们能够创建所谓的*模板文字*。让我们向`CarComponent`类添加`styles`参数，看看这可能是什么样子：

```ts
@Component({
 selector: 'car',
  template: '<h3>What production car has the fastest acceleration 
     time from 0 to 60?</h3><p>Tesla </p>',
  styles: [`
    .car {
      color: #008000;
      font-weight: bold; 
    }
  `]
})
class CarComponent {
}
```

这就是`styles`属性的全部内容。我敢打赌你可以猜到`styleUrls`属性的作用。是的-它的工作原理就像`templateUrl`属性一样。它为我们提供了一种将组件的 CSS 从组件类外部化并将其放在外部样式表中的方法。请注意，我提到了*文件*，即*文件*的复数形式。`styleUrls`属性接受字符串数组的值（与`templateUrl`属性的值的类型为字符串相反）-因此，如果我们想要，我们可以将多个样式表传递给它*。*

因此，通过使用模板，`templateUrl`，styles 和`styleUrls`属性的组合，我们可以将 HTML（即我们的组件模板）和我们想要应用于模板的 CSS 封装在我们的组件类中-感谢`@Component`注释为我们提供的属性。由于`selector`属性，我们可以在组件的父模板中使用自定义 HTML 标记。您开始对所有这些东西如何组合在一起有了良好的感觉吗？如果没有，别担心-当我们开始实现示例应用程序的视图时，您很快就会明白。

# 视图封装

视图封装是非常方便和非常酷的东西-就像 Angular 中的大多数东西一样-用于配置我们的 CSS 的范围。

通常，当我们创建（或更改）CSS 类时，样式会应用于整个应用程序，而不限于特定页面、组件等。Angular 通过允许我们将样式封装（即限制或包含）到包含给定样式表/CSS 的组件中，为我们提供了对此的一定程度的控制。这是通过`@Component`注释的另一个属性`encapsulation`来实现的。

我们可以将组件样式的封装设置为以下三个可能值之一：

+   `ViewEncapsulation.Emulated`: 这是默认值，效果是我们的样式将仅限于我们的组件。它们不会影响我们页面上的其他任何东西。但是，我们的组件仍将继承或访问全局可访问的样式。

+   `ViewEncapsulation.Native`: 这基本上与`ViewEncapsulation.Emulated`相同，只是我们要求 Angular 阻止或保护我们的组件免受任何全局定义的样式影响。效果是我们的组件将免受未分配给我们`@Component`注释的`styles`或`styleUrls`属性的任何样式的影响。

+   `ViewEncapsulation.None`: 这是我们会使用的设置，如果我们不想控制 CSS 隔离的级别。换句话说，如果我们希望让我们组件的 CSS 影响其他页面资产，并且还希望我们的组件继承全局定义的 CSS 规则集，这就是我们会使用的设置。

这很酷，不是吗？多么棒的功能！如果你仔细想想，这是使代码重用成为可能的事情之一，甚至在不同的应用程序之间，而不仅仅是在同一个应用程序中。如果我们想要保证我们的组件在 Angular 应用程序中看起来相同，无论任何给定应用程序的样式如何，我们可以将我们组件的`encapsulation`属性设置为`ViewEncapsulation.Native`，然后就可以了。

# 模块与 NgModule

术语非常重要，因为由于语义的原因很容易混淆事物。当涉及的主题中的语言/术语包含重载词时，这一点尤为真实，就像 Angular 作为主题一样。例如，我们已经看到，我们必须非常明确地说明我们所说的*组件*和*页面*的含义。同样的事情也适用于*模块*这个词，所以在继续之前，我想在这一点上澄清一些事情。

正如我们在第二章中所看到的，*ECMAScript 和 TypeScript 速成课*，模块的概念在 ES6 中是新的。在 JavaScript 中，当我们谈论模块时，通常是指一个代码文件，然后我们可以将其导入到我们执行脚本的上下文中，使其封装的函数对我们的脚本可用。Angular 模块，或`NgModule`，是由多个文件组成的模块，因此通常被称为包。因为我们像导入 JavaScript 模块一样对待这个`NgModule`或包，我们经常认为它们是等价的，但它们并不是。

本章重点是组件，但当我们将对后端 API 的调用封装在一个统一的包中时，我们还将在第十一章中看一下如何构建我们自己的`NgModules`，*依赖注入和服务*。

在我们离开关于`NgModule`的讨论之前，将进一步讨论推迟到以后的章节，我想至少触及一下它的一些参数，因为`@NgModule`是我提到过的另一个存在的注解。

# @NgModule 装饰器的属性

如果您查看我们在第四章中开始构建的示例应用程序中的`app.module.ts`文件，您会看到在我们的`AppModule`类上的`@NgModule`注解中有四个参数。让我们快速看一下这四个参数以及我们用它们做什么：

+   **声明**：这是我们列出需要打包在这个`NgModule`中的组件和指令的地方。

+   **导入**：这使得其他模块的导出声明对我们的`NgModule`可用。

+   **提供者**：这是我们列出服务和值的地方，以便它们为**依赖注入**（**DI**）所知。它们被添加到根作用域，并被注入到其他具有它们作为依赖项的服务或指令中。我们将在第十二章中介绍 DI，*集成后端数据服务*。

+   **引导**：这是我们列出我们希望 Angular 在应用程序启动时引导的组件。

在我们的应用程序中只能有一个`NgModule`，我们在其中使用 Bootstrap 参数，因为引导过程始于只有一个模块。

# 内容投影

内容投影的概念为组件开发人员提供了一种可以增加其可重用性的机制。特别是，我指的是它们的数据显示方式（即呈现方式）。

这意味着，我们不再试图创建一个组件，为每种可能的方式都有属性，而是可以更改其模板（这几乎是不可能的），以便使用组件的开发人员可以变化这些属性的值，以自定义渲染方式。内容投影提供了一种以更少的仪式实现这一点的方法。

我们使用的机制是一对 `ng-content` 标签，就像这样：`<ng-content></ng-content>`。

我们将在照片列表页面中实践这一点，但现在让我给你展示一个人为的例子。让我们修改我们的 `CarComponent` 模板为以下代码片段（添加一对 `ng-content` 标签）：

```ts
template: '<h3>What production car has the fastest acceleration time from 0 to 60?</h3><ng-content></ng-content>'
```

这样做的目的是使 CarComponent 的父组件能够将内容投影到 CarComponent 的模板中，从而根据需要更改模板。假设我们不仅仅想在常规文本中显示汽车制造商，而是想在一组 `<p>` 标签中显示汽车制造商。

父组件将如下所示：

```ts
<car>
    <strong>Tesla</strong>
</car>
```

而不是如下所示：

```ts
<car></car>
```

再次，这是一个人为的例子。另外，Angular 的整个重点是拥有动态数据，但我们在这里没有做到。例如，我们会将汽车问题和答案数据绑定到组件模板中的元素，而不是将其硬编码（在这种情况下是 *哪辆量产汽车的 0 到 60 加速时间最快？* 和 *特斯拉*）。然而，我们简化的硬编码代码以最直接的方式说明了内容投影的概念——即不使数据动态化，而我们将在本书的后面部分做一些动态化。

# 投影多个部分

可以包含多对 `ng-content` 标签。然而，由于 Angular 无法确定哪个投影内容已替换了哪组 `ng-content` 标签，我们需要以某种方式标记 `ng-content` 标签，以使它们彼此区分开来。

一种简单的方法是通过类名标记或标记`ng-content`标签，以便预期投影的内容替换所需的一组`ng-content`标签。我们使用`ng-content`的名为`select`的属性来标记标签。让我们扩展我们的虚构`CarComponent`示例，看看这在具有两对`ng-content`标签时会是什么样子：

```ts
template: '<ng-content select=".question"></ng-content><ng-content select=".answer"></ng-content>'
```

以下是父组件的样子：

```ts
<car>
    <h3 class="question">What production car has the fastest acceleration 
       time from 0 to 60?</h3>
    <span select="answer"><strong>Tesla</strong></span>
</car>
```

通过使用`ng-content`标签及其`select`属性，如果您有多个内容投影目标，您可以创建可由消费者定制的组件。

# 生命周期钩子

与几乎所有活着的事物一样，从我们太阳系中的恒星到您可能买来装饰餐桌的花朵，Angular 组件也有一个生命周期，它们从诞生到消亡经历的不同阶段或阶段。

我们可以在这些不同的阶段钩入任何我们希望 Angular 为我们运行的代码，因为 Angular 为我们提供了特殊的方法，每个组件生命周期阶段都有一个方法，Angular 会为我们调用。我们所要做的就是提供我们希望 Angular 运行的代码，我们是通过在组件类中添加与生命周期钩子同名的函数来实现的。

组件有一组生命周期钩子，其子组件（即子组件）也有一组生命周期钩子。以下表列出了最常见的生命周期钩子：

| **生命周期钩子** | **类型** | **在...时调用** |
| --- | --- | --- |
| `constructor` | 组件 | Angular 在类上调用`new`时创建组件。 |
| `ngOnInit` | 组件 | 组件已完全初始化。 |
| `ngOnChanges` | 组件 | 输入属性发生变化（每次变化调用一次）。 |
| `ngOnDestroy` | 组件 | Angular 即将销毁组件。 |
| `ngAfterContentInit` | 子 | 组件的内容投影发生后。 |
| `ngAfterContentChecked` | 子 | Angular 在内容上运行其变更检测算法。 |
| `ngAfterViewInit` | 子 | 组件的视图已完全初始化。 |
| `ngAfterViewChecked` | 子 | Angular 在视图上运行其变更检测算法。 |

# 最常见的生命周期钩子

从前面的八个生命周期钩子中，你最有可能只使用其中的三个（在大多数情况下）。所有这三个都属于组件类型的生命周期钩子：

+   `ngOnInit`：我们的组件初始化逻辑将放在这里。你可能会认为构造函数是添加初始化逻辑的地方，但`ngOnInit`更可取，因为通过我们的接口（即输入属性）进行的任何数据绑定都已经完成。构造函数阶段并非如此。

+   `ngOnChanges`：当我们想知道哪些输入属性已经改变，以及它们被改变成了什么，这就是需要查看的地方。

+   `ngOnDestroy`：这是我们为组件插入清理逻辑的地方（如果我们有任何需要清理的东西 - 否则，我们就不使用它）。

这是一个我们如何钩入`ngOnInit`生命周期钩子的例子（我们只是向控制台输出一些内容）：

```ts
class CarComponent {
    ngOnInit()  {
        console.log('An instance of our CarComponent has 
            been fully initialized.');
    }
}
```

# 组件接口 - 输入和输出，以及数据流

如果你要在特定屏幕上创建一个组件的图表（即视图/页面），在它们之间画箭头来表示数据流，箭头将从一个组件的输出指向另一个组件的输入。

在代码中，正如我们将在实现中看到的那样，我们绑定输出和输入的方式是在我们的组件模板中（即在 HTML 中）。但是要在 HTML 中进行绑定，我们需要在代码中创建我们的组件，并且我们需要给它们接口。

让我们快速看一个具体的例子，它将展示父组件如何将数据传递给它的子组件。为了演示这一点，让我们首先创建我们的两个组件。

这是我们的`DadComponent`，它将是父组件：

```ts
import {Component } from '@angular/core';
@Component({
    selector: 'dad',
    template: `<h1>Hello. {{message}}.</h1> <br/> 
        <son *ngFor="let name of arrSonNames" 
        [Name]="name">
        </son>
    `,
})
export class DadComponent { 
    message : string = "I'm a Dad";
    arrSonNames = ['Justin','','Brendan'];
}
```

这是我们的`SonComponent`，它将是子组件：

```ts
import { Component, Input, OnInit } from '@angular/core';
@Component({
    selector: 'son',
    template: `<h2>Hi. I'm a son, and my name is {{_name}}.</h2>`
})
export class SonComponent implements OnInit {
    _name: string;
    constructor() {
        console.log("The son component was just instantiated.");
    }
    ngOnInit(){
        console.log("The son component is now fully initialized.");
    }
    @Input()
    set Name(name : string ) {
        this._name = (name && name.trim()) || "I am a son."; 
    }
    get Name() {
        return this._name;
    }
}
```

这段代码中发生了很多事情。我不会描述前面代码块中发生了什么。相反，我希望你花几分钟时间研究一下，看看你能否弄清楚发生了什么。你应该从以前的章节中获得足够的信息，再加上一些关于 JavaScript/TypeScript 的基本知识，以及对 getter 和 setter 的理解（因为许多语言都有）。我知道你能做到——试一试。我会给你两个提示：1）`@Input()`是一个装饰器，在这种情况下，它创建了`SonComponent`的公共接口；2）`DadComponent`最终会创建三个`SonComponent`的实例。其中两个儿子会知道自己的名字，不幸的是，其中一个儿子不会知道自己的名字。他会说什么？知道自己名字的儿子叫什么？你能看出为什么会创建三个儿子吗？你能猜到会写入控制台什么，以及会写入多少次吗？

我们将在我们的实现中看到很多这种模式，所以如果看起来奇怪，或者似乎有点复杂，并且你不能回答我提出的所有问题，不要担心。过一段时间，这些东西应该变得很自然。是的，我将从现在开始解释我们的实现代码——不是详细到极致，但足够让你理解手头的材料。目前，我只是想让你感受一下通过组件接口传递数据是什么样子。

# 我们三个页面的组件实现

我们现在有足够的知识来实现（即，在代码中创建）我们示例应用程序以下三个页面所需的组件：

+   预览列表

+   照片列表

+   预览照片

为了生成这些组件，我们将利用 Angular CLI 原理图。运行以下命令，我们应该期望自动生成组件和所需的文件：

```ts
ng generate component photo-listing
ng generate component preview-listing
ng generate component preview-photo
```

一旦命令成功运行，我们应该看到如下屏幕截图所示的输出：

！[](assets/21ffb974-aa8f-4b2c-aa74-aa5c58aa2b9e.png)

在上面的屏幕截图中，我们可以注意到已为组件生成了相应的文件，并且`app.module.ts`文件已经更新为最新生成的组件。

到目前为止，我们应用程序的最终项目结构如下所示：

！[](assets/ee18d776-dfb0-4d9a-8c20-fe27b2ef2770.png)

# 摘要

在本章中，我们涵盖了很多内容。您可能并没有完全理解上一节中的一些代码，这没关系，因为当我们一起为示例应用程序实现页面时，您会变得擅长这些内容。由于本章是关于组件的，我只是想向您展示如何设置父组件和子组件的一般结构，以及如何通过子组件的公共接口从父组件传递数据。但是，现在您应该对 Angular 应用程序只是一组组件的树有了相当好的理解。分解组件为子组件的经验法则是什么，注解和装饰器是什么。

我们还研究了`@Component`注解/装饰器是什么，它的属性是什么，以及如何配置它们。然后，我们转向了`@NgModule`装饰器是什么，它的一些属性是什么，以及它们的作用是什么。然后，我们研究了内容投影是什么，以及如何使用它允许其他开发人员自定义他们的渲染。

最后，我们学习了什么是生命周期钩子，如何使用它们以及为什么要使用它们。然后，我们转向了组件接口是什么以及如何创建它们。最后，我们研究了我们三个页面（预览列表、照片列表和预览照片）所需的组件的实现。

在下一章，第七章，*模板、指令和管道*，我们将深入研究组件的模板部分，因为那里是所有数据绑定和渲染发生的地方——将我们的 Angular 应用程序从一堆 0 和 1 带到我们的屏幕上。

Angular 提供了许多工具，以指令和管道的形式，供我们利用，这样我们就可以告诉它如何在画布上绘制。所以，翻过页面，让我们了解如何让 Angular 开始在应用程序画布上放置我们的组件绘制，从而使我们的应用程序生动起来——这就是我们将把我们的组件放置到我们的三个页面（预览列表、照片列表和预览照片）上的地方。
