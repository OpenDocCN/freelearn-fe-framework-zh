<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer116">
			<h1 id="_idParaDest-94"><em class="italic"><a id="_idTextAnchor094"/>Chapter 6</em>: Implementing Additional Tools and Plugins for Testing</h1>
			<p>In the previous chapters, we learned the basics of React Testing Library and how to test from simple to complex components using the tool. In this chapter, we will learn how to increase our productivity by using additional tools. We will install and use a few plugins to help our ability to write tests by avoiding common mistakes and following React Testing Library's best practices.</p>
			<p>We will add a library to audit and increase application accessibility. We'll ensure we select the best React Testing Library query method with Testing Playground. Finally, we will increase our productivity by using Wallaby.js to receive rapid feedback on our tests' status from our code editor.</p>
			<p>In this chapter, we're going to cover the following main topics: </p>
			<ul>
				<li>Using <strong class="source-inline">eslint-plugin-testing-library</strong> to follow best practices and avoid common mistakes when using React Testing Library</li>
				<li>Using <strong class="source-inline">eslint-plugin-jest-dom</strong> to follow best practices and avoid common mistakes when using <strong class="source-inline">jest-dom</strong></li>
				<li>Using <strong class="source-inline">jest-axe</strong> to increase application accessibility</li>
				<li>Selecting the Testing Library-recommended queries with Testing Playground</li>
				<li>Increasing our testing productivity with Wallaby.js</li>
			</ul>
			<p>The skills in this chapter will increase your productivity and enhance your ability to test React applications using Testing Library's best practices.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Technical requirements</h1>
			<p>For the examples in this chapter, you will need to have Node.js installed on your machine. We will be using the <strong class="source-inline">create-react-app</strong> CLI tool for all code examples. Please familiarize yourself with the tool before starting this chapter, if required. Code snippets will be provided throughout the chapter to understand the code under test, but the objective is to understand how to test the code.</p>
			<p>You can find code examples for this chapter at <a href="https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06">https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter06</a>.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Implementing best practices with Testing Library ESLint plugins</h1>
			<p>In this section, you will learn how to install and use <strong class="source-inline">eslint-plugin-testing-library</strong> and <strong class="source-inline">eslint-plugin-jest-dom</strong>. The purpose of these plugins is to audit your test code and help you to write tests that follow the<a id="_idIndexMarker288"/> best practices of <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) Testing Library and <strong class="source-inline">jest-dom</strong>. The plugins work by highlighting areas that can be improved and providing recommendations to refactor your code.</p>
			<p>Before installing the plugins, w<a id="_idTextAnchor097"/>e<a id="_idIndexMarker289"/> need to have <strong class="bold">ESLint</strong> installed in our project. ESLint is a tool that statistically analyzes and informs you of problems in your code. You can think of ESLint as having someone look over your shoulder to point out issues you might otherwise take longer to debug on your own. For example, you could create the following function:</p>
			<p class="source-code">const reverseWord = str =&gt; str.split('').reverse().join('')</p>
			<p>In the preceding code, we have a <strong class="source-inline">reverseWord</strong> function that reverses a passed-in string. If we invoke the function with the word <strong class="source-inline">packt</strong>, we get the following result:</p>
			<p class="source-code">reverseWord('packt') // tkcap</p>
			<p>In the preceding code, we get a result of <strong class="source-inline">tkcap</strong> when we pass in <strong class="source-inline">packt</strong> as a parameter to the function. However, if we mistakenly misspell the function name and run the code, we get the following result:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="Images/Figure_6.1_B16887.jpg" alt="Figure 6.1 – The reverseWord function name typo" width="498" height="74"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The reverseWord function name typo</p>
			<p>In the previous code, the console output indicates <strong class="source-inline">ReferenceError</strong>. The error refers to the interpreter not locating a defined function, called <strong class="source-inline">reverseeWord</strong>, in the file. The problem was that the user mistakenly added an extra <strong class="source-inline">e</strong> in the function name. We could create a better <a id="_idIndexMarker290"/>workflow by installing and configuring ESLint in our project to help debug issues.</p>
			<p>If you are using <strong class="source-inline">create-react-app</strong> for your project, then ESLint should automatically be installed for you. For projects that don't already have ESLint installed, use the following command:</p>
			<p class="source-code">npm install eslint --save-dev</p>
			<p>The previous command will install ESLint as a development dependency to your project.</p>
			<p>Next, we can create a configuration file to tell ESLint how we want it to lint our files:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "extends": "eslint:recommended",</p>
			<p class="source-code">  "parserOptions": {</p>
			<p class="source-code">    "ecmaVersion": 2021,</p>
			<p class="source-code">    "sourceType": "module"</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The configuration file that was created in <strong class="source-inline">json</strong> format, in the previous code, has a few settings that tell ESLint how to lint our files. The <strong class="source-inline">"extends"</strong> key is set to <strong class="source-inline">"eslint:recommended"</strong>. This means that we want to use ESLint's recommended linting rules. The <strong class="source-inline">"parserOptions"</strong> key is set to an object with two keys. The <strong class="source-inline">"ecmaVersion"</strong> key is set to <strong class="bold">2021</strong>. This means that the code we write will support JavaScript options available in the 2021 version of ECMAScript. The <strong class="source-inline">"sourceType"</strong> key is set to <strong class="source-inline">"module"</strong>, meaning our code will support ES modules. There are numerous ways ESLint can be configured to lint your project files.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please refer to <em class="italic">Configuring ESLint</em> (<a href="https://eslint.org/docs/user-guide/configuring/">https://eslint.org/docs/user-guide/configuring/</a>) for more details.</p>
			<p>Use the following command to run ESLint against your project files:</p>
			<p class="source-code">npx eslint .</p>
			<p>In the previous command, we use the <strong class="source-inline">npx</strong> command to run ESLint against all of the project files. Note that <strong class="source-inline">npx</strong> allows you to quickly execute <strong class="source-inline">npm</strong> packages regardless of whether the package is <a id="_idIndexMarker291"/>installed locally or globally on your machine or not installed at all. We receive the following output in the console after running the command:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="Images/Figure_6.2_B16887.jpg" alt="Figure 6.2 – ESLint output&#13;&#10;" width="1372" height="129"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – ESLint output</p>
			<p>In the previous command, ESLint informs us of two errors in our code. The first error says that the <strong class="source-inline">reverseWord</strong> function was never used on line <strong class="source-inline">1</strong>, referencing the <strong class="source-inline">no-unused-vars</strong> ESLint rule. The second error says that <strong class="source-inline">reverseeWord</strong> on line <strong class="source-inline">3</strong> is not defined anywhere in the file, referencing the <strong class="source-inline">no-undef</strong> ESLint rule. We can also enhance our ESLint workflow by displaying the output directly in our code editor to learn about any potential issues before running our code. For example, the VSCode and Atom code editors have third-party tools that we can install to display problems directly in the editor.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please refer to <em class="italic">ESLint</em> (<a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint</a>) for the VSCode editor <a id="_idIndexMarker292"/>extension. Alternatively, you can refer to <em class="italic">linter-eslint</em> (<a href="https://atom.io/packages/linter-eslint">https://atom.io/packages/linter-eslint</a>) for the Atom editor plugin for installation and configuration details.</p>
			<p>Displaying the linter output directly in the code editor provides faster feedback than manually running<a id="_idIndexMarker293"/> ESLint via the command line. Now that you understand how to get ESLint up and running, we will install and configure <strong class="source-inline">eslint-plugin-testing-library</strong> in the next section.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>Installing and configuring eslint-plugin-testing-library</h2>
			<p>In this section, we<a id="_idIndexMarker294"/> will learn how to install and configure <strong class="source-inline">eslint-plugin-testing-library</strong> inside our application. Install the plugin using the<a id="_idIndexMarker295"/> following command:</p>
			<p class="source-code">npm install --save-dev eslint-plugin-testing-library</p>
			<p>The preceding command installs <strong class="source-inline">eslint-plugin-testing-library</strong> as a development dependency in your project. Now that the plugin is installed, we can add it to our ESLint configuration file:</p>
			<p class="source-code">    "overrides": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "files": ["*.test.js"],</p>
			<p class="source-code">      "extends": [</p>
			<p class="source-code">        "plugin:testing-library/react"</p>
			<p class="source-code">      ]</p>
			<p>In the previous code, we created an <strong class="source-inline">"overrides"</strong> section in our ESLint configuration to target any files ending in <strong class="source-inline">.test.js</strong>. Then, we added <strong class="source-inline">plugin:testing-library/react</strong> to the <strong class="source-inline">extends</strong> array in the configuration file. We added the React version of the plugin to gain React-specific rules and the rules we get from DOM Testing Library's base rules. The plugin applies a particular set of linting rules that are specific to React applications. For example, the <strong class="source-inline">no-dom-import</strong> rule, which doesn't allow direct imports from DOM Testing Library, is useful because React Testing Library re-exports everything from DOM Testing Library, eliminating the need for direct imports.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please refer to <em class="italic">Supported Rules</em> (<a href="https://github.com/testing-library/eslint-plugin-testing-library#supported-rules">https://github.com/testing-library/eslint-plugin-testing-library#supported-rules</a>) for a complete list of React-specific applied rules.</p>
			<p>Note that the <strong class="source-inline">react-app</strong> entry is also included in the array. The <strong class="source-inline">react-app</strong> entry adds ESLint rules that have been set up by <strong class="source-inline">create-react-app</strong>. Now that we have the plugin set up in <a id="_idIndexMarker296"/>the project, we can write tests. We will <a id="_idIndexMarker297"/>test a drop-down component that allows a user to select a programming language:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="Images/Figure_6.3_B16887.jpg" alt="Figure 6.3 – The drop-down component&#13;&#10;" width="443" height="388"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The drop-down component</p>
			<p>In the preceding screenshot, you can see a dropdown that lists four programing languages that a user can click on to choose. When a user selects a language, we get the following:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="Images/Figure_6.4_B16887.jpg" alt="Figure 6.4 – The selected drop-down option" width="534" height="147"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The selected drop-down option</p>
			<p>Here, you can view the text <strong class="bold">You selected: JavaScript</strong>, which appears when a user selects the <strong class="bold">JavaScript</strong> option. We can write <a id="_idIndexMarker298"/>a test to verify that <a id="_idIndexMarker299"/>the selected language displays on the screen:</p>
			<p class="source-code">test('LanguageDropdown, given selected menu item, displays   selection', async () =&gt; {</p>
			<p class="source-code">  render(&lt;LanguageDropdown /&gt;)</p>
			<p class="source-code">  user.click(screen.getByRole('button', { name: /programming language/I }))</p>
			<p class="source-code">  user.click(screen.getByRole''menuite'', { name: /javascript/i }))</p>
			<p class="source-code">  user.click(screen.getByRole''menuite'', { name: /javascript/i }))</p>
			<p>In the preceding code, first, we render the <strong class="source-inline">LanguageDropdown</strong> component in the DOM. Next, we click on the <strong class="bold">Programming Language</strong> button. Then, we select <strong class="bold">JavaScript</strong> from the menu options. Next, we will verify that the selected option is displayed on the screen:</p>
			<p class="source-code">  const selection = await waitFor(() =&gt;</p>
			<p class="source-code">    screen.getByRole('heading', { name: /you selected:       javascript/i })</p>
			<p class="source-code">  )</p>
			<p>In the preceding code, we use the <strong class="source-inline">waitFor</strong> method from React Testing Library to get the element with the text that includes the selected option. The <strong class="source-inline">waitFor</strong> method can be used when you <a id="_idIndexMarker300"/>need to wait for an element in the DOM. However, according to <strong class="source-inline">eslint-plugin-testing-library</strong>, <strong class="source-inline">waitFor</strong> is not the best way<a id="_idIndexMarker301"/> to select an element in this situation:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="Images/Figure_6.5_B16887.jpg" alt="Figure 6.5 – The findByRole linter suggestion&#13;&#10;" width="1365" height="451"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – The findByRole linter suggestion</p>
			<p>In the previous screenshot, the code that includes the <strong class="source-inline">waitFor</strong> method is underlined by ESLint, drawing our attention to the code issue. When we hover over the <strong class="source-inline">waitFor</strong> method code, we get feedback indicating that the preferred query is <strong class="source-inline">findByRole</strong> via the <strong class="source-inline">prefer-find-by</strong> rule of <strong class="source-inline">eslint-plugin-testing-library</strong>.</p>
			<p>In <a href="B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Refactoring Legacy Applications with React Testing Library</em>, we learned how to use the <strong class="source-inline">findByRole</strong> query to select elements that need time to appear on the screen. The <strong class="source-inline">prefer-find-by</strong> rule is a <strong class="source-inline">fixable</strong> rule; this means that we can select to have the problem code automatically fixed for us.</p>
			<p>One easy way to automatically fix issues is by setting up your code editor to automatically resolve any fixable issues when saving a file. Please refer to the documentation of your respective code editor for instructions. If, for some reason, your editor does not have a <em class="italic">fix on save</em> feature, you can run <strong class="source-inline">eslint --fix</strong> in the command line or use pre-commit hooks via <strong class="source-inline">git</strong>. As a last resort, you always have the option of referring to the <strong class="source-inline">eslint-plugin-testing-library</strong> documentation, which is related to the <strong class="source-inline">prefer-find-by</strong> rule and others, for suggestions. Once we refactor the problem code, we get the following output:</p>
			<p class="source-code">  const selection = await screen.findByRole('heading', {</p>
			<p class="source-code">    name: /you selected: javascript/i</p>
			<p class="source-code">  })</p>
			<p class="source-code">  expect(selection).toBeInTheDocument()</p>
			<p class="source-code">})</p>
			<p>In the preceding code, the <strong class="source-inline">waitFor</strong> code is replaced with the <strong class="source-inline">findByRole</strong> query method. The code has a cleaner syntax that behaves similarly to the <strong class="source-inline">waitFor</strong> code and satisfies the linter rules. Finally, we assert that the selected code is in the document.</p>
			<p>Some rules are not automatically<a id="_idIndexMarker302"/> enabled with the React version of <strong class="source-inline">eslint-plugin-testing-library</strong>. For example, in previous<a id="_idIndexMarker303"/> versions of React Testing Library, it was common to see selectors written as follows:</p>
			<p class="source-code">  const { getByRole } = render(&lt;LanguageDropdown /&gt;)</p>
			<p class="source-code">  user.click(getByRole('button', { name: /programming     language/i }))</p>
			<p class="source-code">  user.click(getByRole('menuitem', { name: /javascript/i }))</p>
			<p>In the preceding code, we access the query methods by destructuring them off the rendered component. The latest React Testing Library versions suggest using the <strong class="source-inline">screen</strong> object to access query methods for a better user experience. The <strong class="source-inline">screen</strong> object allows you to access query methods using your editor's autocomplete feature rather than undergoing explicit destructuring via the rendered component. We can add the <strong class="source-inline">prefer-screen-queries</strong> rule to our ESLint configuration file to enforce this way of selecting query methods:</p>
			<p class="source-code">  "rules": {</p>
			<p class="source-code">    "testing-library/prefer-screen-queries": "error"</p>
			<p class="source-code">  }</p>
			<p>In the preceding code, we added a <strong class="source-inline">"rules"</strong> key to the configuration file. The <strong class="source-inline">"rules"</strong> key is used when we want to add specific rules to enforce our code. Inside the <strong class="source-inline">"rules"</strong> key, we add the <strong class="source-inline">"testing-library/prefer-screen-queries"</strong> key, which is set to <strong class="source-inline">"error"</strong>. If we had our project set up with a linting script to run ESLint across our files, the error would trigger an exit code to stop file execution, making it clear that the current code is not acceptable for use.</p>
			<p>Now, with this rule in place, the previous code using destructuring will be flagged by ESLint:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="Images/Figure_6.6_B16887.jpg" alt="Figure 6.6 – The prefer-screen-queries linter suggestion&#13;&#10;" width="1439" height="161"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – The prefer-screen-queries linter suggestion</p>
			<p>In the previous<a id="_idIndexMarker304"/> screenshot, <strong class="source-inline">getByRole</strong> is underlined by ESLint to draw our attention to the query issue. When we hover over the query, we get feedback indicating that the preferred approach uses <strong class="source-inline">screen</strong> to query DOM <a id="_idIndexMarker305"/>elements via the <strong class="source-inline">prefer-screen-queries</strong> rule of <strong class="source-inline">eslint-plugin-testing-library</strong>.</p>
			<p>Unlike the <strong class="source-inline">prefer-find-by</strong> rule in the previous example, <strong class="source-inline">prefer-screen-queries</strong> is not a <em class="italic">fixable</em> rule. This means that we will need to fix the code manually. When we refactor the code, we get the following result:</p>
			<p class="source-code">render(&lt;LanguageDropdown /&gt;)</p>
			<p class="source-code">user.click(screen.getByRole('button', { name: /programming   language/i }))</p>
			<p class="source-code">user.click(screen.getByRole('menuitem', { name: /javascript/i }))</p>
			<p>The DOM selectors have been refactored to use the <strong class="source-inline">screen</strong> object in the preceding code, satisfying the <strong class="source-inline">prefer-screen-queries</strong> rule. The code also looks cleaner compared to the version using destructured query methods.</p>
			<p>In some situations, we might want rules that provide a warning compared to an error when ESLint runs across project files. The warning won't stop code execution; however, instead, it will serve as a reminder to the user to remove the file's highlighted code before committing the code. For example, it is common to use the <strong class="source-inline">debug</strong> method to view the current state of the DOM as we build tests:</p>
			<p class="source-code">  render(&lt;LanguageDropdown /&gt;)</p>
			<p class="source-code">  <strong class="bold">screen.debug()</strong></p>
			<p>In the previous <a id="_idIndexMarker306"/>code, the <strong class="source-inline">debug</strong> method is used for logging the current DOM output to the console after rendering the <strong class="source-inline">LanguageDropdown</strong> component. The <strong class="source-inline">debug</strong> method will be <a id="_idIndexMarker307"/>highlighted in the editor, as follows:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="Images/Figure_6.7_B16887.jpg" alt="Figure 6.7 – The no-debug linter suggestion&#13;&#10;" width="1429" height="161"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – The no-debug linter suggestion</p>
			<p>In the preceding screenshot, <strong class="source-inline">debug</strong> is underlined by ESLint to draw our attention to an issue with the query. When we hover over the query, we get feedback indicating the method should be removed via the <strong class="source-inline">no-debug</strong> rule of <strong class="source-inline">eslint-plugin-testing-library</strong>. We often forget to remove the console's logging code before committing work, so the <strong class="source-inline">no-debug</strong> rule serves as a helpful reminder to remove it.</p>
			<p>Now you know how to install and configure ESLint with <strong class="source-inline">eslint-plugin-testing-library</strong> to help avoid issues and follow best practices while writing tests.</p>
			<p>In the next section, we will go a step further by installing another plugin that is specific to <strong class="source-inline">jest-dom</strong>.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Installing and configuring eslint-plugin-jest-dom</h2>
			<p>In the previous section, we installed and configured ESLint and <strong class="source-inline">eslint-plugin-testing-library</strong>. In this section, we <a id="_idIndexMarker308"/>will teach you how to install and configure <strong class="source-inline">eslint-plugin-jest-dom</strong>, ensuring we follow the best practices using <strong class="source-inline">jest-dom</strong>. Use the following command to <a id="_idIndexMarker309"/>install the plugin:</p>
			<p class="source-code">npm install --save-dev eslint-plugin-jest-dom</p>
			<p>The previous command installs <strong class="source-inline">eslint-plugin-jest-dom</strong> as a development dependency inside the project. Now that the plugin is installed, we can add it to our ESLint configuration file:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "extends": ["react-app", "plugin:jest-dom/recommended"]</p>
			<p class="source-code">}</p>
			<p>In the previous code, we added <strong class="source-inline">plugin:jest-dom/recommended</strong> to the <strong class="source-inline">extends</strong> array in the configuration file. The <strong class="source-inline">recommended</strong> configuration for the plugin is used to automatically include a set of standard rules to enforce <strong class="source-inline">jest-dom</strong> best practices. We will test a <strong class="source-inline">checkbox</strong> component that allows the user to select their preferred programming languages:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="Images/Figure_6.8_B16887.jpg" alt="Figure 6.8 – The languages checkbox component&#13;&#10;" width="580" height="109"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – The languages checkbox component</p>
			<p>In the preceding screenshot, you can see that there are four checkboxes for programming languages that a user can select from. When a user selects a language, we get the following:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="Images/Figure_6.9_B16887.jpg" alt="Figure 6.9 – The selected language checkbox &#13;&#10;" width="582" height="108"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – The selected language checkbox </p>
			<p>In the preceding screenshot, the user selects <strong class="bold">JavaScript</strong>, which results in the associated checkbox being selected, the text color changing to <em class="italic">green,</em> and the font-weight changing to <em class="italic">bold</em>. We can write a test to verify that the checkbox for the selected language is selected and has the<a id="_idIndexMarker310"/> expected classes associated with the color and font-weight of the <a id="_idIndexMarker311"/>text the user sees on the screen:</p>
			<p class="source-code">test('LanguageCheckbox, given selected item, item is checked',   () =&gt; {</p>
			<p class="source-code">  render(&lt;LanguageCheckBox /&gt;)</p>
			<p class="source-code">  const jsCheckbox = screen.getByRole('checkbox', { name: /    javascript/i })</p>
			<p class="source-code">  user.click(jsCheckbox)</p>
			<p>In the preceding code, we render the <strong class="source-inline">LanguageCheckBox</strong> component to the DOM. Next, we get the <strong class="bold">JavaScript</strong> checkbox, store it in the <strong class="source-inline">jsCheckbox</strong> variable, and click on it. Next, we will make assertions on the expected output. First, we try using the <strong class="source-inline">toHaveAttribute</strong> Jest matcher:</p>
			<p class="source-code">  expect(jsCheckbox).toHaveAttribute("checked");</p>
			<p>In the preceding code, we use <strong class="source-inline">toHaveAttribute</strong> to verify that the checkbox has the <strong class="source-inline">checked</strong> attribute after being clicked. However, our test will fail with this matcher because it only looks for an explicit <strong class="source-inline">checked</strong> attribute that is added to the elements commonly used in situations where we want a prechecked checkbox. In our case, we're testing the result of a user clicking on the checkbox in the resulting DOM, so we need a different matcher. Next, we try using the <strong class="source-inline">toHaveProperty</strong> Jest matcher:</p>
			<p class="source-code">  expect(jsCheckbox).toHaveProperty("checked", true);</p>
			<p>In the preceding code, we use the <strong class="source-inline">toHaveProperty</strong> Jest matcher to verify that the checkbox has the <strong class="source-inline">checked</strong> property set to <strong class="source-inline">true</strong>. This matcher works in a technical sense, but it doesn't read very clearly. Additionally, when we hover over the matcher, we get the following output:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="Images/Figure_6.10_B16887.jpg" alt="Figure 6.10 – The prefer-checked linter suggestion &#13;&#10;" width="1363" height="234"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – The prefer-checked linter suggestion </p>
			<p>In the preceding screenshot, the <strong class="source-inline">toHaveProperty</strong> matcher is underlined by ESLint to draw our attention to<a id="_idIndexMarker312"/> the matcher's issue. When we hover over the matcher, we get feedback indicating it should be replaced with the <strong class="source-inline">jest-dom</strong> <strong class="source-inline">toBeChecked</strong> matcher via the <strong class="source-inline">prefer-checked</strong> rule of <strong class="source-inline">eslint-plugin-jest-dom</strong>. The rule is automatically fixable and will refactor<a id="_idIndexMarker313"/> the matcher for us if we have our code editor set up. When we refactor our matcher, we get the following output:</p>
			<p class="source-code">  expect(jsCheckbox).toBeChecked()</p>
			<p>In the preceding code, we use the <strong class="source-inline">toBeChecked</strong> <strong class="source-inline">jest-dom</strong> matcher to verify that the checkbox is checked. Now we have a matcher that eliminates any issues with previous matcher versions and also reads a lot better. Next, we will assert the expected classes:</p>
			<p class="source-code">expect(screen.getByText(/javascript/i).className).  toContain('text-success font-weight-bold')</p>
			<p>In the preceding code, we access the <strong class="source-inline">className</strong> property inside the element with the <strong class="source-inline">javascript</strong> text to verify that it contains the <strong class="source-inline">text-success</strong> and <strong class="source-inline">font-weight-bold</strong> classes. However, when we hover over <strong class="source-inline">toContain</strong>, we get the following feedback:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="Images/Figure_6.11_B16887.jpg" alt="Figure 6.11 – The prefer-to-have-class linter suggestion&#13;&#10;" width="1370" height="181"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – The prefer-to-have-class linter suggestion</p>
			<p>In the preceding screenshot, the <strong class="source-inline">toContain</strong> matcher is underlined by ESLint to draw our attention to the matcher's issue. When we hover over the matcher, we get feedback indicating that it should be replaced with the <strong class="source-inline">jest-dom</strong> <strong class="source-inline">toHaveClass</strong> matcher via the <strong class="source-inline">prefer-to-have-class</strong> rule of <strong class="source-inline">eslint-plugin-jest-dom</strong>. Similar to the previous example, the <strong class="source-inline">prefer-to-have-class</strong> rule is automatically fixable and will refactor the <a id="_idIndexMarker314"/>matcher for us if we have our code <a id="_idIndexMarker315"/>editor set up to do so. When we refactor the code, we get the following output:</p>
			<p class="source-code">  expect(screen.getByText(/javascript/i)).toHaveClass(</p>
			<p class="source-code">    'text-success font-weight-bold'</p>
			<p class="source-code">  )</p>
			<p>In the preceding code, we refactored our code to use the <strong class="source-inline">jest-dom</strong> <strong class="source-inline">toHaveClass</strong> matcher. Now we have a matcher that is easier to implement and read compared to our original example.</p>
			<p>Now you understand how to install and use the <strong class="source-inline">eslint-plugin-jest-dom</strong> plugin to use assertion matchers that follow the <strong class="source-inline">jest-dom</strong> best practices. In the next section, we will learn how to install and use a package to increase the accessibility of our component's source code.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>Testing accessibility with jest-axe</h1>
			<p>In this section, we will learn how to <a id="_idIndexMarker316"/>use a tool that is designed to help improve the accessibility of our features. There are many tools available that can help increase accessibility by automating the process of auditing and reporting issues, such <a id="_idIndexMarker317"/>as Wave (<a href="https://wave.webaim.org/">https://wave.webaim.org/</a>) and Lighthouse (<a href="https://developers.google.com/web/tools/lighthouse">https://developers.google.com/web/tools/lighthouse</a>). However, there<a id="_idIndexMarker318"/> is no single tool that can guarantee accessibility across an entire application. Accessibility auditing tools are helpful, but they do not replace the need for manual accessibility auditing done by a human. For example, when an abbreviation is used for the first time in a line of text, the related expanded version should be included:</p>
			<p class="source-code">Structured Query Language (SQL) is used to manage data in relational databases.</p>
			<p>In the preceding sentence, the expanded version, <strong class="source-inline">Structured Query Language</strong>, is included with its abbreviated form, <strong class="source-inline">SQL</strong>. The sentence would need to be manually checked to verify accessibility. We will learn how to use <strong class="source-inline">jest-axe</strong>, which is a tool that adds a custom matcher for Jest and behaves in ways that are similar to ESLint. The tool helps find and <a id="_idIndexMarker319"/>report common accessibility issues in your code, such as image buttons with no alternate text or <strong class="source-inline">inputs</strong> with no associated labels. Use the following command to install the tool:</p>
			<p class="source-code">npm install --save-dev jest-axe</p>
			<p>The previous command installs <strong class="source-inline">jest-axe</strong> as a development dependency inside the project. Now that the tool is installed, we can use it in our tests. First, we will test the accessibility of an image button:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="Images/Figure_6.12_B16887.jpg" alt="Figure 6.12 – An inaccessible image button" width="723" height="149"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – An inaccessible image button</p>
			<p>In the preceding screenshot, we have an image that behaves as a <strong class="bold">Submit</strong> button. The following is the source code for the image button:</p>
			<p class="source-code">import loginImg from './image/login.png'</p>
			<p class="source-code">&lt;input src={loginImg} type="image" /&gt;</p>
			<p>In the preceding code, we will import an image and pass it as <strong class="source-inline">source</strong> for an input of the <strong class="source-inline">image</strong> type. Now we will write a test to verify that the element is accessible to users:</p>
			<p class="source-code">import { render } from '@testing-library/react'</p>
			<p class="source-code">import { axe } from 'jest-axe'</p>
			<p class="source-code">import 'jest-axe/extend-expect'</p>
			<p class="source-code">import NoAccessibility from './NoAccessibility'</p>
			<p>In the preceding code, first, we import the <strong class="source-inline">render</strong> method from React Testing Library. Then, we import the <strong class="source-inline">axe</strong> method from <strong class="source-inline">jest-axe</strong>. The <strong class="source-inline">axe</strong> method is what we will use to audit the accessibility of our component. Next, we import <strong class="source-inline">jest-axe/extend-expect</strong>, which adds a special matcher to Jest to report the audit outcome in a readable format. Finally, we import the <strong class="source-inline">NoAccessibility</strong> component to test. Next, we will write the main test code:</p>
			<p class="source-code">  const { container } = render(&lt;NoAccessibility /&gt;)</p>
			<p class="source-code">  const results = await axe(container)</p>
			<p class="source-code">  expect(results).toHaveNoViolations()</p>
			<p>In the preceding code, first, we<a id="_idIndexMarker320"/> destructure <strong class="source-inline">container</strong> off the rendered component. Unlike query methods, we can destructure <strong class="source-inline">container</strong> off the rendered component without violating DOM Testing Library's best practices because it is not available on the <strong class="source-inline">screen</strong> object. <strong class="source-inline">container</strong> is the <strong class="source-inline">div</strong> element that wraps your React component under test.</p>
			<p>Next, we pass <strong class="source-inline">container</strong> as an argument to the <strong class="source-inline">axe</strong> method and store it in the <strong class="source-inline">results</strong> variable. The <strong class="source-inline">axe</strong> method will run an accessibility audit across our component under test. Finally, we assert that the results have no accessibility issues using the <strong class="source-inline">toHaveNoViolations</strong> matcher. The test will pass if no violations are found.</p>
			<p>However, if violations are found, the test will fail and provide feedback to resolve those issues. When we run the test, we get the following output:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="Images/Figure_6.13_B16887.jpg" alt="Figure 6.13 – Inaccessible image button test output&#13;&#10;" width="1023" height="580"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – Inaccessible image button test output</p>
			<p>The preceding screenshot shows that accessibility violations were found in the <strong class="source-inline">NoAccessibility</strong> component, which resulted in a test failure with feedback. First, the feedback indicates that an <strong class="source-inline">input</strong> element is the source of the issue. Next, we see the entire element printed on the screen. Then, we get the <strong class="source-inline">"Image buttons must have alternate text (input-image-alt)"</strong> message, informing us why the element failed the audit. Next, we get several suggestions that we can implement to resolve the issue. Finally, we get a<a id="_idIndexMarker321"/> hyperlink that we can follow to gain a deeper understanding of the issue. We will resolve the issue by providing an <strong class="source-inline">alt</strong> attribute:</p>
			<p class="source-code">&lt;input src={loginImg} type="image" <strong class="bold">alt="login"</strong> /&gt;</p>
			<p>In the preceding code, we added an <strong class="source-inline">alt</strong> attribute with the value of <strong class="source-inline">login</strong>. Now, when we rerun our test, we get the following result:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="Images/Figure_6.14_B16887.jpg" alt="Figure 6.14 – Accessible image button test output&#13;&#10;" width="1368" height="306"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – Accessible image button test output</p>
			<p>In the preceding screenshot, the test results indicate that <strong class="source-inline">NoAccessibility, given accessibility audit, returns no violations</strong> passes with no violations. Next, we will <a id="_idIndexMarker322"/>test the accessibility of a list that includes an image:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="Images/Figure_6.15_B16887.jpg" alt="Figure 6.15 – An inaccessible list&#13;&#10;" width="894" height="417"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – An inaccessible list</p>
			<p>In the preceding screenshot, we have an unordered list that includes an <strong class="source-inline">image</strong> element. The following is the source code for the list:</p>
			<p class="source-code">      &lt;ul&gt;</p>
			<p class="source-code">        &lt;li&gt;Building with React&lt;/li&gt;</p>
			<p class="source-code">        &lt;li&gt;Testing with React Testing Library&lt;/li&gt;</p>
			<p class="source-code">        &lt;img</p>
			<p class="source-code">          src="http://unsplash.it/g/200?random&amp;gravity=center"</p>
			<p class="source-code">          alt="tulips"</p>
			<p class="source-code">        /&gt;</p>
			<p class="source-code">      &lt;/ul&gt;</p>
			<p>In the preceding code, we have an unordered list element with two <strong class="source-inline">list item</strong> child elements and one <strong class="source-inline">image</strong> child element. Our test code will be the same as the previous test for the image button. The only difference here is the component that we pass into the <strong class="source-inline">render</strong> method. So, for this example, we will only focus on the test results:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="Images/Figure_6.16_B16887.jpg" alt="Figure 6.16 – Inaccessible list test results" width="1378" height="445"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – Inaccessible list test results</p>
			<p>The preceding screenshot shows that<a id="_idIndexMarker323"/> accessibility violations were found in the unordered list component, which resulted in a test failure with feedback. First, the feedback indicates that a <strong class="source-inline">ul</strong> element is the source of the issue. Next, we see the entire element printed on the screen. Then, we get the <strong class="source-inline">"&lt;ul&gt; and &lt;ol&gt; must only directly contain &lt;li&gt;, &lt;script&gt; or &lt;template&gt; elements (list)"</strong> message, which helps us to understand why the element failed the audit.</p>
			<p>Next, we get a suggestion regarding how to resolve the issue. Finally, we get a hyperlink that we can follow to gain a deeper understanding of the issue. We will resolve the issue by moving the image inside an <strong class="source-inline">li</strong> element:</p>
			<p class="source-code">      &lt;ul&gt;</p>
			<p class="source-code">        &lt;li&gt;Building with React&lt;/li&gt;</p>
			<p class="source-code">        &lt;li&gt;Testing with React Testing Library&lt;/li&gt;</p>
			<p class="source-code">        <strong class="bold">&lt;li&gt;</strong></p>
			<p class="source-code"><strong class="bold">          &lt;img</strong></p>
			<p class="source-code"><strong class="bold">            src="http://unsplash.it/ g/200?random&amp;               gravity=center"</strong></p>
			<p class="source-code"><strong class="bold">            alt="tulips"</strong></p>
			<p class="source-code"><strong class="bold">          /&gt;</strong></p>
			<p class="source-code"><strong class="bold">        &lt;/li&gt;</strong></p>
			<p class="source-code">      &lt;/ul&gt;</p>
			<p>In the previous code, we wrapped the <strong class="source-inline">image</strong> element inside an <strong class="source-inline">li</strong> element. When we rerun our test, the test will pass and return results that are similar to what we saw in the image button's previous test. Now you know how to use <strong class="source-inline">jest-axe</strong> to increase the accessibility of applications using React with Jest. It is important to reiterate that automated accessibility tools help increase our applications' ability to work for various end users. However, they cannot<a id="_idIndexMarker324"/> catch all issues and are not a replacement for manual audits.</p>
			<p>Next, we will learn how to use a tool to speed up our element selections with React Testing Library.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor101"/>Selecting the best queries with Testing Playground</h1>
			<p>In this section, we will learn how to use <strong class="bold">Testing Playground</strong>. This is a tool that makes it easier for you to determine the right DOM Testing Library query selector. Testing Playground allows you to<a id="_idIndexMarker325"/> paste HTML into an interactive website, which allows you to click on elements as they appear rendered in the browser. This enables you to learn which DOM Testing Library queries can be used to select a particular element.</p>
			<p>The tool always suggests queries in order, based on the DOM Testing Library query recommendations for elements that offer multiple ways of selection. Furthermore, the tool allows you to copy the selector to use in your test code. We will look at two ways of using Testing Playground: first, via the website, and second, via a Chrome extension.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor102"/>Selecting queries using the Testing Playground website</h2>
			<p>In this section, we will learn how to use<a id="_idIndexMarker326"/> Testing Playground via its website. In previous examples throughout the book, we used the <strong class="source-inline">debug</strong> method to log the resulting HTML of components to the console while writing tests. One limitation of the <strong class="source-inline">debug</strong> method is that it has no feature that enables you to log the output to the browser and test out different query methods to select elements.</p>
			<p>We can use the <strong class="source-inline">logTestingPlaygroundURL</strong> method inside a test file to log the resulting HTML to a browser via <em class="italic">Testing Playground</em> (<a href="https://testing-playground.com/">https://testing-playground.com/</a>) and utilize the<a id="_idIndexMarker327"/> site's query selector features. For example, we could be in the process of selecting elements in a test for the following <strong class="source-inline">MoreInfoPopover</strong> component:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="Images/Figure_6.17_B16887.jpg" alt="Figure 6.17 – The Popover component&#13;&#10;" width="364" height="259"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – The Popover component</p>
			<p>In the preceding screenshot, we have a <strong class="source-inline">button</strong> element with the text <strong class="bold">More Info</strong>, which displays a popover with dummy text when it is clicked on. We want to select the <strong class="source-inline">button</strong> element using DOM Testing Library queries, so we start our test as follows:</p>
			<p class="source-code">import { render, screen } from '@testing-library/react'</p>
			<p class="source-code">import MoreInfoPopover from './MoreInfoPopover'</p>
			<p class="source-code">it('logs output to Testing Playground', () =&gt; {</p>
			<p class="source-code">  render(&lt;MoreInfoPopover /&gt;)</p>
			<p class="source-code">  screen.logTestingPlaygroundURL()</p>
			<p class="source-code">})</p>
			<p>We import the <strong class="source-inline">render</strong> and <strong class="source-inline">screen</strong> methods from React Testing Library and the component under test in the preceding code. Inside the main test code, first, we render the component in the DOM. Next, we call the <strong class="source-inline">logTestingPlaygroundURL</strong> method. When we run the test, we get the following output:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="Images/Figure_6.18_B16887.jpg" alt="Figure 6.18 – The Testing Playground link" width="1100" height="311"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18 – The Testing Playground link</p>
			<p>In the preceding <a id="_idIndexMarker328"/>screenshot, we have a unique link to the Testing Playground website to follow and view our component's rendered HTML. When we follow the link, we should see something similar to the following:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="Images/Figure_6.19_B16887.jpg" alt="Figure 6.19 – The Testing Playground HTML structure&#13;&#10;" width="559" height="469"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19 – The Testing Playground HTML structure</p>
			<p>In the preceding screenshot, the link navigated us to the Testing Playground website. First, we see a section that includes the HTML structure for our component. Next, we see the rendered browser output, as follows:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="Images/Figure_6.20_B16887.jpg" alt="Figure 6.20 – The Testing Playground browser output" width="216" height="113"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20 – The Testing Playground browser output</p>
			<p>In the preceding screenshot, we <a id="_idIndexMarker329"/>can see a section with the browser output for our component. Notice that we don't see the complete result with associated styles included. The Testing Playground website only displays the HTML content. Next, we see a <strong class="bold">suggested query</strong> section, as follows:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="Images/Figure_6.21_B16887.jpg" alt="Figure 6.21 – Testing Playground suggested query &#13;&#10;" width="515" height="379"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21 – Testing Playground suggested query </p>
			<p>In the preceding screenshot, we get a <strong class="bold">suggested query</strong> for the <strong class="source-inline">button</strong> element we clicked on in the browser output section. The <strong class="source-inline">getByRole</strong> query is the best way to select the button based on its HTML structure. Additionally, we can see the <strong class="bold">This is great. Ship it!</strong> message, which suggests that we should use this query further.</p>
			<p>There are also other options available, as shown in the following screenshot, to select the element:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="Images/Figure_6.22_B16887.jpg" alt="Figure 6.22 – Testing Playground query priority options&#13;&#10;" width="617" height="501"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.22 – Testing Playground query priority options</p>
			<p>In the preceding code, we can see multiple options to select the element in order of priority. Based on the HTML structure of the <strong class="source-inline">button</strong> element, there are two ways we could choose the element – <em class="italic">by its role</em> and <em class="italic">by its text value</em>. The other listed queries are not available for the<a id="_idIndexMarker330"/> button and, therefore, display <strong class="bold">n/a</strong>. If we decide to select the <strong class="bold">Text</strong> query option, we should see something similar to the following screenshot:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="Images/Figure_6.23_B16887.jpg" alt="Figure 6.23 – The Testing Playground text query option&#13;&#10;" width="674" height="143"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23 – The Testing Playground text query option</p>
			<p>In the preceding screenshot, we can see the text <strong class="bold">Nice! getByText is a great selector! Using getByRole would still be preferable though.</strong>. This message informs us that while it is not wrong to use <strong class="source-inline">getByText</strong> to select the button, it is not the best query for the selected element. Once we decide on the query we want to grab the element, we can click on the icon displayed on the far right of the <strong class="bold">suggested query</strong> box to copy the code needed to select the element within our test.</p>
			<p>Now you know how to use the <strong class="source-inline">logTestingPlaygroundURL</strong> method to select elements using the Testing Playground website. There is one notable limitation to using the Testing Playground <a id="_idIndexMarker331"/>website. When we click on the <strong class="bold">More Info</strong> button, we should see a popup appear beneath the button. We cannot use the Testing Playground website to perform this action since it only copies the HTML and not the associated JavaScript to render the result of clicking on the button.</p>
			<p>In the next section, we will learn how to use the Testing Playground Chrome extension to overcome this limitation.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/>Selecting queries using the Testing Playground Chrome extension</h2>
			<p>In this section, we will install and<a id="_idIndexMarker332"/> use the Testing Playground Chrome extension to overcome the limitations of using the Testing Playground website. This extension provides the benefit of allowing you to use Testing Playground features locally, in the same browser that is used to run your application. The extension is currently only available for the Google Chrome browser, so be sure to install it if necessary.</p>
			<p>Install the <em class="italic">Testing Playground Chrome extension</em> (<a href="https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano">https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano</a>) via the Chrome Web Store. Once the extension is installed, a new <strong class="bold">Testing Playground</strong> tab is added to your <strong class="bold">Chrome Developer Tools</strong>.</p>
			<p>Going back to the <strong class="source-inline">MoreInfoPopover</strong> component from the previous section, we can write a test to verify that the popover is displayed when a user clicks on the <strong class="bold">More Info</strong> button:</p>
			<p class="source-code">test('MoreInfoPopover, given clicked button, displays popover',   () =&gt; {</p>
			<p class="source-code">  render(&lt;MoreInfoPopover /&gt;)</p>
			<p>In the preceding code, we render <strong class="source-inline">MoreInfoPopover</strong> in the DOM. Next, we will use the Testing Playground extension to find the preferred query selector for the button:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="Images/Figure_6.24_B16887.jpg" alt="Figure 6.24 – The Testing Playground Chrome extension&#13;&#10;" width="935" height="191"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24 – The Testing Playground Chrome extension</p>
			<p>In the previous screenshot, we <a id="_idIndexMarker333"/>can see a tab added for the <strong class="bold">Testing Playground</strong> extension in the <strong class="bold">Chrome Developer Tools</strong>. The experience of using the Chrome extension is similar to that of the Testing Playground website. However, now, we can interact with our component's HTML output with the associated JavaScript and styles included. As we discussed in the <em class="italic">Selecting queries using the Testing Playground website</em> section, when we click on the button, we get the preferred <strong class="source-inline">getByRole</strong> query selector. When we copy the selector, we get the query code to add to our test:</p>
			<p class="source-code">  screen.getByRole('button', {  name: /more info/i})</p>
			<p>In the preceding code, we copied the <strong class="source-inline">getByRole</strong> selector to access the <strong class="bold">More Info</strong> button. Next, we will use the extension to help select the popover, which is displayed after clicking on the button:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="Images/Figure_6.25_B16887.jpg" alt="Figure 6.25 – The popover query selector" width="849" height="92"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25 – The popover query selector</p>
			<p>In the preceding screenshot, <strong class="source-inline">getByRole</strong> is the suggested query for the <strong class="source-inline">popover</strong> element after selecting it in the browser. Now we have all the selectors that we need to write the remaining test code:</p>
			<p class="source-code">  user.click(screen.getByRole('button', { name: /more info/i     }))</p>
			<p class="source-code">  const popover = await screen.findByRole('heading', { name: /     lorem ipsum/i })</p>
			<p class="source-code">  expect(popover).toBeInTheDocument()</p>
			<p>In the preceding code, first, we click on the <strong class="bold">More Info</strong> button. Next, we grab the <strong class="source-inline">popover</strong> element by its heading and store it in a variable. Notice that we used <strong class="source-inline">findByRole</strong> instead of the <strong class="source-inline">getByRole</strong> query. Testing Playground only provides <strong class="source-inline">getBy*</strong> queries, so it might be <a id="_idIndexMarker334"/>necessary to modify the copied query based on the situation. Finally, we assert that the <strong class="source-inline">popover</strong> element is in the DOM. When we run the test, we get the following result:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="Images/Figure_6.26_B16887.jpg" alt="Figure 6.26 – The popover test results&#13;&#10;" width="1056" height="268"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26 – The popover test results</p>
			<p>In the previous screenshot, the results indicate that the <strong class="source-inline">MoreInfoPopover, given clicked button, displays popover</strong> test passes as expected. Now you know how to install and use the Testing Playground Chrome extension to enhance your workflow when writing tests. The Testing Playground website and extension are great supporting tools to utilize when working with DOM Testing Library.</p>
			<p>In the next section, we will learn how to use a tool that will speed up the results feedback from beginning to completion when writing tests.  </p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor104"/>Increasing our testing productivity with Wallaby.js</h1>
			<p>In this section, we will learn how to<a id="_idIndexMarker335"/> increase our productivity by using the <a id="_idIndexMarker336"/>Wallaby.js productivity tool. Wallaby.js works by automatically running your tests behind the scenes via a Headless Chrome browser. There is also the option to run tests in other environments, such as Node.js or Phantom.js, with a custom configuration file. Wallaby.js helps to speed up your workflow by providing immediate test results inside your code editor, so you can<a id="_idIndexMarker337"/> type without needing to save and run a test script to view the results.</p>
			<p>Wallaby.js provides many features, such as the following:</p>
			<ul>
				<li><strong class="bold">Time Travel Debugging</strong>: This allows you to <a id="_idIndexMarker338"/>navigate through your code to pinpoint bug sources easily.</li>
				<li><strong class="bold">Test Story Viewer</strong>: This provides the <a id="_idIndexMarker339"/>ability to view the code associated with your test on one compact screen.</li>
				<li><strong class="bold">Inline Code Coverage</strong>: This informs you of the test coverage for each line of code inside the code editor.<p class="callout-heading">Note</p><p class="callout">Please refer to the <em class="italic">Features</em> section (<a href="https://wallabyjs.com/#features">https://wallabyjs.com/#features</a>) on the Wallaby.js documentation website for a complete list of features.</p></li>
			</ul>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor105"/>Installing and configuring Wallaby.js</h2>
			<p>In this section, we <a id="_idIndexMarker340"/>will learn how to install and set up Wallaby.js for the Visual Studio Code editor. Please refer to the <em class="italic">Install</em> section (<a href="https://wallabyjs.com/download/">https://wallabyjs.com/download/</a>) on the Wallaby.js<a id="_idIndexMarker341"/> documentation website for a complete list of installation options. To get started, add the Wallaby.js VSCode extension to your editor via the <em class="italic">VSCode Marketplace</em> (<a href="https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode">https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode</a>). Once the extension has been installed, we can configure it to work in our project.</p>
			<p>The quickest and easiest way to configure Wallaby.js is with automatic configuration. Projects using specific versions of tools such as <strong class="source-inline">create-react-app version 3</strong> or greater, or <strong class="source-inline">Jest version 24</strong> or greater, qualify for automatic configuration.</p>
			<p>For projects that do not qualify for automatic configuration, please refer to the <em class="italic">Configuration File</em> section (<a href="https://wallabyjs.com/docs/intro/config.html?editor=vsc#configuration-file">https://wallabyjs.com/docs/intro/config.html?editor=vsc#configuration-file</a>) in the Wallaby.js documentation for specific configurations based on your project setup.</p>
			<p>Start Wallaby.js in VSCode with automatic configuration using the command palette:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="Images/Figure_6.27_B16887.jpg" alt="Figure 6.27 – Select Configuration &#13;&#10;" width="881" height="128"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27 – Select Configuration </p>
			<p>In the preceding <a id="_idIndexMarker342"/>screenshot, <strong class="source-inline">wallaby</strong> is entered into the command palette to bring up the available Wallaby.js <a id="_idIndexMarker343"/>commands. We will click on the <strong class="bold">Wallaby.js: Select Configuration</strong> option:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="Images/Figure_6.28_B16887.jpg" alt="Figure 6.28 – The Automatic Configuration option&#13;&#10;" width="715" height="109"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.28 – The Automatic Configuration option</p>
			<p>In the preceding screenshot, we have selected the <strong class="bold">Automatic Configuration &lt;project directory&gt;</strong> and <strong class="bold">Automatic Configuration &lt;custom directory&gt;</strong> options. We will select <strong class="bold">&lt;project directory&gt;</strong> to use the directory of our current project. Once we select the configuration, Wallaby.js will start and run our tests to provide feedback directly inside the test files of the code editor, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="Images/Figure_6.29_B16887.jpg" alt="Figure 6.29 – Wallaby.js enhanced test output&#13;&#10;" width="1268" height="251"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.29 – Wallaby.js enhanced test output</p>
			<p>In the preceding screenshot, we can see a test that we created earlier, in the <em class="italic">Selecting the best queries with Testing Playground</em> section of this chapter, enhanced with Wallaby.js' features. First, we see green-colored square shapes to the left of the line numbers indicating that all the test lines have passed. Next, we see links for the Wallaby.js <strong class="bold">Debug</strong>, <strong class="bold">View Story</strong>, <strong class="bold">Profile</strong>, and <strong class="bold">Focus</strong> features, which we can click on to analyze the test from the perspective of that particular feature.</p>
			<p>Finally, we see<a id="_idIndexMarker344"/> the test runtime, <strong class="source-inline">45ms</strong>, logged next to the test. Now you understand how to install and configure Wallaby.js. You should also understand the basic <a id="_idIndexMarker345"/>enhancements that Wallaby.js adds directly inside the test files.</p>
			<p>In the next section, we will walk through how to write a test utilizing Wallaby.js's Interactive Test Output feature.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor106"/>Writing tests with Interactive Test Output</h2>
			<p>In the <em class="italic">Selecting the best queries with Testing Playground</em> section of this chapter, we wrote the <strong class="source-inline">MoreInfoPopover, given clicked button, displays popover</strong> test for a <strong class="source-inline">MoreInfoPopover</strong> component. Let's walk through how to create the same test<a id="_idIndexMarker346"/> utilizing Wallaby.js.</p>
			<p>First, we will render the component under test in the DOM and use the <strong class="source-inline">debug</strong> method to log the current state of the HTML output:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="Images/Figure_6.30_B16887.jpg" alt="Figure 6.30 – The Wallaby.js inline debug output&#13;&#10;" width="1140" height="496"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.30 – The Wallaby.js inline debug output</p>
			<p>In the preceding screenshot, we used the <strong class="source-inline">//?</strong> command from Wallaby.js to log the results of <strong class="source-inline">debug</strong> directly inside the code editor. The output is automatically displayed horizontally to the right of <strong class="source-inline">debug</strong> when we hover over the method. This feature speeds up our workflow <a id="_idIndexMarker347"/>because, normally, we would have to execute our test runner from the command line to see the output.</p>
			<p>Next, we will add queries to select the DOM elements:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="Images/Figure_6.31_B16887.jpg" alt="Figure 6.31 – A query error&#13;&#10;" width="1317" height="573"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.31 – A query error</p>
			<p>In the preceding screenshot, we have a test failure resulting from React Testing Library not finding a <strong class="source-inline">heading</strong> element named <strong class="source-inline">lorem ipsum</strong>. Wallaby.js increases our ability to discover the error in two ways. First, we see a red-colored square shape to the left of the test name and, specifically, the line number where the error occurred. The inline code notifications help us to quickly identify where we should focus on pinpointing the cause of the error. Second, when we hover over the <strong class="source-inline">test</strong> method, React Testing Library's test result output is displayed directly in the code editor.</p>
			<p>This feature speeds up our workflow because Wallaby.js reruns our test and provides feedback any time we add new code to the test. Furthermore, we don't even have to save our test file to gain feedback. We can also view test feedback in the <strong class="bold">Wallaby.js Tests</strong> console:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="Images/Figure_6.32_B16887.jpg" alt="Figure 6.32 – The Wallaby.js Tests console" width="1379" height="363"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.32 – The Wallaby.js Tests console</p>
			<p>In the preceding <a id="_idIndexMarker348"/>screenshot, we can see similar React Testing Library feedback to what we see directly in the editor anytime code is updated in the test file, but now it is in an expanded view. Additionally, we can see the number of failing tests compared to passing tests, and clickable links for <strong class="source-inline">Launch Coverage &amp; Test Explorer</strong>, which is a feature that allows you to see visualized test coverage for each file, and <strong class="source-inline">Search Test</strong>, which is a feature that allows you to quickly search for any test in the project.</p>
			<p>After debugging the failure with the help of Wallaby.js' in-editor features, we learned that the <strong class="source-inline">heading</strong> element with the name of <strong class="source-inline">lorem ipsum</strong> is not immediately displayed. Using our knowledge of Testing Library queries, we can determine that the element should be selected using an asynchronous <strong class="source-inline">findBy*</strong> query:</p>
			<p class="source-code">  const popover = await screen.findByRole('heading', { name: /     lorem ipsum/i })</p>
			<p>In the preceding code, we update the selector to <strong class="source-inline">findByRole</strong>. Immediately after updating the selector, we get feedback within the editor:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="Images/Figure_6.33_B16887.jpg" alt="Figure 6.33 – Query refactor&#13;&#10;" width="1380" height="276"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.33 – Query refactor</p>
			<p>In the preceding screenshot, we see green-colored square shapes to the left of all of the line numbers. This indicates that we have successfully refactored the test code to a working state. We have <a id="_idIndexMarker349"/>also written an assertion to verify that the test passes as expected. Now you know how to use Wallaby.js to gain instant editor feedback and test debugging capabilities. Using Wallaby.js is a great tool to have when you need to save time running and debugging tests.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/>Summary</h1>
			<p>This chapter has taught you the benefits of using ESLint plugins to follow the DOM Testing Library and <strong class="source-inline">jest-dom</strong> best practices. You have gained an understanding of accessible code and used <strong class="source-inline">jest-axe</strong> to increase the accessibility of your applications. You have learned how to speed up the process of determining the best query method with Testing Playground. Finally, you have learned how to increase test writing productivity with Wallaby.js.</p>
			<p>In the next chapter, you will learn about end-to-end UI testing using the popular Cypress framework.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Questions</h1>
			<ol>
				<li>Install and configure the React-specific version of <strong class="source-inline">eslint-plugin-testing-library</strong> into a project and add additional rules.</li>
				<li>Create examples of <strong class="source-inline">jest</strong> assertions using matchers that don't use <strong class="source-inline">jest-dom</strong> best practices. Then, install and configure <strong class="source-inline">eslint-plugin-jest-dom</strong> inside a project and use it as a guide to correct highlighted issues.</li>
				<li>Create a few components with accessibility issues, install and run <strong class="source-inline">jest-axe</strong> against the components and use the feedback to fix them.</li>
				<li>Visit three of your favorite websites and use Testing Playground to see how many elements you can select using DOM Testing Library's preferred <strong class="source-inline">byRole*</strong> queries.</li>
				<li>Install Wallaby.js and log how quickly you can write a test using its in-editor features.</li>
			</ol>
		</div>
	</div></body></html>