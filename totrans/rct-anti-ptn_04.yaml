- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Designing Your React Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计您的 React 组件
- en: Welcome to this pivotal chapter on mastering React component design. In this
    chapter, we’ll embark on an enriching journey to recognize and eradicate common
    anti-patterns in designing React components, including issues such as large monolithic
    components, prop drilling, and other prevalent pitfalls that often perplex developers
    and hamper the maintainability and scalability of React applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到这个关于掌握 React 组件设计的核心章节。在本章中，我们将开始一段丰富的旅程，以识别和消除设计 React 组件中的常见反模式，包括大型单体组件、属性钻取和其他常见的陷阱，这些陷阱经常困扰开发者，并阻碍
    React 应用的可维护性和可扩展性。
- en: First, we’ll introduce the single responsibility principle. In the realm of
    React, this guides us to ensure that each component has one specific purpose.
    Adhering to this principle makes components easier to understand, test, and maintain,
    all while making your code more readable and manageable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍单一职责原则。在 React 的领域，这指导我们确保每个组件有一个特定的目的。遵循这个原则使组件更容易理解、测试和维护，同时使您的代码更易于阅读和管理。
- en: Next, we’ll explore the don’t repeat yourself principle. One of the core tenets
    of effective programming, this encourages developers to minimize repetition and
    promote reuse. In the context of React, this principle can be the key to unlocking
    a more streamlined, efficient, and maintainable code base.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索“不要重复自己”原则。这是有效编程的核心原则之一，它鼓励开发者最小化重复并促进重用。在 React 的上下文中，这个原则可能是解锁更流畅、高效和可维护的代码库的关键。
- en: Finally, we’ll delve into the component composition principle. Composition allows
    us to build complex UIs by combining simpler, reusable components. In React, composition
    is favored over inheritance, leading to more flexible and easier-to-manage components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入研究组件组合原则。组合允许我们通过组合更简单、可重用的组件来构建复杂的 UI。在 React 中，组合优于继承，导致更灵活且易于管理的组件。
- en: Throughout this chapter, we’ll take a deep dive into each of these principles,
    providing real-world examples and practical applications. By doing so, we aim
    to guide you in crafting more efficient components, bolstering your understanding
    of React’s potential, and enhancing your problem-solving skills in this powerful
    library.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨这些原则的每一个，提供现实世界的例子和实际应用。通过这样做，我们旨在指导您构建更高效的组件，增强您对 React 潜力的理解，并提高您在这个强大库中的问题解决技能。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Exploring the single responsibility principle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索单一职责原则
- en: Learning about the don’t repeat yourself principle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解“不要重复自己”原则
- en: Using composition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合
- en: Combining component design principles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合组件设计原则
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure under [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch4](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch4).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个 GitHub 仓库来托管本书中讨论的所有代码。对于本章，您可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch4](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch4)找到推荐的架构。
- en: Exploring the single responsibility principle
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单一职责原则
- en: The **single responsibility principle** (**SRP**) is one of the fundamental
    concepts in software engineering, asserting that a function, class, or, in the
    context of React, a component, should have only one reason to change. In other
    words, each component should ideally handle a single task or functionality. Following
    this principle can make your code more readable, maintainable, and easier to test
    and debug.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**（SRP）是软件工程中的基本概念之一，它断言一个函数、类，或者在 React 的上下文中，一个组件，应该只有一个改变的理由。换句话说，每个组件理想上应该处理一个单一的任务或功能。遵循此原则可以使您的代码更易于阅读、维护，并且更容易测试和调试。'
- en: 'Let’s illustrate this with an example. Suppose you initially have a `BlogPost`
    component that fetches blog post data, displays the post, and handles the user
    liking the post, all in one component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点。假设您最初有一个 `BlogPost` 组件，它在一个组件中获取博客文章数据、显示文章并处理用户对文章的点赞：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code defines a functional component called `BlogPost` that takes an `id`
    prop of the `string` type. Inside the component, there are two state variables
    defined using the `useState` Hook: `post` and `isLiked`. The `post` state represents
    the blog post data, initialized with a default value of an empty blog post. The
    `isLiked` state represents whether the post is liked or not, initialized as `false`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个名为 `BlogPost` 的函数组件，它接受一个 `id` 属性，该属性为 `string` 类型。在组件内部，使用 `useState`
    钩子定义了两个状态变量：`post` 和 `isLiked`。`post` 状态表示博客文章数据，初始值为一个空的博客文章。`isLiked` 状态表示文章是否被喜欢，初始值为
    `false`。
- en: Following this, we need to manage the side effect (sending network requests)
    in the `useEffect` Hook. It is used to fetch the blog post data from the server
    based on the provided `id` prop. It triggers the `fetch` operation whenever the
    `id` prop changes. Once the data is fetched, the `post` state is updated with
    the retrieved post using the `setPost` function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们需要在 `useEffect` 钩子中管理副作用（发送网络请求）。它用于根据提供的 `id` 属性从服务器获取博客文章数据。每当 `id` 属性变化时，它都会触发
    `fetch` 操作。一旦获取数据，就使用 `setPost` 函数将获取的文章更新到 `post` 状态。
- en: 'Inside the `useEffect` Hook call, for the network request, there is a function
    called `fetchPostById`. The function is simply a `fetch` call to a remote API
    endpoint. We can assume the function is implemented with something like the following
    code snippet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `useEffect` 钩子调用中，对于网络请求，有一个名为 `fetchPostById` 的函数。该函数简单地对远程 API 端点进行 `fetch`
    调用。我们可以假设该函数是用以下代码片段实现的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The component renders the title and summary of the blog post from the `post`
    state. It also renders a button that toggles the `isLiked` state when clicked,
    displaying `isLiked`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 组件从 `post` 状态渲染博客文章的标题和摘要。它还渲染一个按钮，当点击时切换 `isLiked` 状态，显示 `isLiked`。
- en: 'While this code works, it violates the SRP. It’s doing three separate things:
    fetching data, displaying the blog post, and handling the like functionality.
    Instead, let’s refactor it into smaller, single-responsibility components:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码可以工作，但它违反了 SRP。它做了三件不同的事情：获取数据、显示博客文章和处理喜欢功能。相反，让我们将其重构为更小、单一职责的组件：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we’ve refactored `BlogPost` into smaller, single-responsibility components:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `BlogPost` 重构为更小、单一职责的组件：
- en: '`useFetchPost` is a custom Hook responsible for fetching the blog post data'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useFetchPost` 是一个自定义钩子，负责获取博客文章数据'
- en: '`LikeButton` is a component responsible for handling the like functionality'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LikeButton` 是一个组件，负责处理喜欢功能'
- en: '`BlogPost` is now just responsible for rendering the blog post content and
    `LikeButton`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlogPost` 现在只负责渲染博客文章内容和 `LikeButton`'
- en: Each part has a single responsibility and could be tested and maintained independently,
    leading to a more manageable code base.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都有一个单一的责任，可以独立进行测试和维护，从而使得代码库更易于管理。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a real-world application, clicking a `fetch` request that is sent to an endpoint
    such as https://post.service/post/<id> to change the `isLiked` status.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，点击发送到端点（例如 https://post.service/post/<id>）以更改 `isLiked` 状态的 `fetch` 请求。
- en: So, in the first section, we explored the SRP. This principle encourages each
    component to take charge of a single piece of functionality, making our code more
    maintainable and understandable. Here, we applied this principle to break down
    large, monolithic components into smaller, more manageable pieces.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第一部分，我们探讨了 SRP。这个原则鼓励每个组件负责单一的功能，使我们的代码更易于维护和理解。在这里，我们应用了这个原则，将大型、单体组件分解为更小、更易于管理的部分。
- en: As we advance further into our design journey, our next section leads us to
    a principle that intertwines closely with the philosophy of SRP – the don’t repeat
    yourself principle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步深入我们的设计之旅，我们的下一节将引导我们到一个与 SRP 哲学紧密相连的原则——不要重复自己原则。
- en: Don’t repeat yourself
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: The **don’t repeat yourself** (**DRY**) principle is a fundamental concept in
    software development that aims to reduce repetition within the code. Following
    this principle leads to better maintainability, readability, and testability,
    and can prevent bugs that occur due to the duplication of logic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己**（DRY）原则是软件开发中的一个基本概念，旨在减少代码中的重复。遵循这个原则可以带来更好的可维护性、可读性和可测试性，并可以防止由于逻辑重复而发生的错误。'
- en: 'Let’s say that you have a shopping website, and you want to display a list
    of products and the user’s cart side by side, something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个购物网站，你想要并排显示产品列表和用户的购物车，就像这样：
- en: '![Figure 4.1: The product list page](img/B31103_04_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：产品列表页面](img/B31103_04_01.jpg)'
- en: 'Figure 4.1: The product list page'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：产品列表页面
- en: The `ProductList` component will display the product’s image, name, and price,
    with an `Cart` component will display a list of cart items with a **Remove from**
    **Cart** button.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductList`组件将显示产品的图像、名称和价格，而`Cart`组件将显示购物车中的项目列表，并带有**从购物车中删除**按钮。'
- en: 'A naive implementation of `ProductList` might look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductList`的一个简单实现可能看起来像这样：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This functional component named `ProductList` accepts two props: `products`
    (an array of product objects) and `addToCart` (a function used to add a product
    to a shopping cart).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`ProductList`的功能组件接受两个属性：`products`（产品对象数组）和`addToCart`（用于将产品添加到购物车的函数）。
- en: Each product object is of the `Product` type, which has the `id`, `name`, `image`,
    and `price` properties.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个产品对象都是`Product`类型，具有`id`、`name`、`image`和`price`属性。
- en: The component maps over the `products` array and renders a `div` for each product,
    including an image, product name, price, and an `addToCart` function is invoked
    with the corresponding product’s `id` prop as an argument.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件遍历`products`数组，并为每个产品渲染一个`div`，包括图像、产品名称、价格，并调用带有相应产品`id`属性的参数的`addToCart`函数。
- en: 'The `Cart` component has a similar structure, as you can imagine; it requires
    a list of items and renders a button with the text **Remove from Cart**, and a
    callback function for the user to invoke:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cart`组件的结构与您想象中的相似；它需要一个项目列表，并渲染一个带有文本**从购物车中删除**的按钮和一个用户可以调用的回调函数：'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Cart` component iterates over the `cartItems` array and, for each item,
    it renders a `div` with the item’s image, name, price, and a `removeFromCart`
    function with the respective item’s `id` prop as an argument, signifying that
    this item should be removed from the cart.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cart`组件遍历`cartItems`数组，并为每个项目渲染一个包含项目图像、名称、价格和一个`removeFromCart`函数的`div`，该函数以相应的项目`id`属性作为参数，表示应从购物车中删除此项目。'
- en: 'To reduce the duplication and make each component only do one thing, we can
    extract a `LineItem` component:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少重复并使每个组件只做一件事，我们可以提取一个`LineItem`组件：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We defined a functional component called `LineItem` that renders a product’s
    details and a button. It accepts properties for `product`, `performAction`, and
    `label`, and uses destructuring to extract the necessary values. The component
    returns JSX code to display the product’s information and trigger the `performAction`
    function when the button is clicked.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`LineItem`的功能组件，用于渲染产品的详细信息和一个按钮。它接受`product`、`performAction`和`label`属性，并使用解构来提取必要的值。该组件返回JSX代码以显示产品信息，并在按钮被点击时触发`performAction`函数。
- en: 'For the `ProductList` and `Cart` components, you can simply pass in different
    props to the `LineItem` component to reduce the duplication we had before:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ProductList`和`Cart`组件，您只需将不同的属性传递给`LineItem`组件，以减少我们之前存在的重复：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The new `ProductList` component receives `products` and `addToCart` as props.
    It renders a list of products, with each product having an **Add to** **Cart**
    button.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`ProductList`组件接收`products`和`addToCart`作为属性。它渲染产品列表，每个产品都有一个**添加到** **购物车**按钮。
- en: 'Similarly, for the `Cart` component, we’ll have a similar structure that reuses
    the `LineItem` component for rendering the product details (`image`, `name`, and
    `price`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于`Cart`组件，我们将有一个类似的结构，它将重用`LineItem`组件来渲染产品详情（`image`、`name`和`price`）：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a more maintainable and reusable approach by following the DRY principle.
    There is less chance of introducing bugs because changes only need to be made
    in one place, and if we must add new features of `LineItem`, we only need to touch
    a single component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更可维护和可重用的方法，遵循DRY原则。引入错误的可能性更小，因为更改只需要在一个地方进行，如果我们必须添加`LineItem`的新功能，我们只需要接触一个组件。
- en: In this section, we dove into the DRY principle. It guided us to eliminate redundancy
    in our code, reducing the likelihood of inconsistencies and bugs. By avoiding
    code duplication, we’ve simplified maintenance as changes in functionality need
    to be addressed in a single place. As we refined our understanding of DRY, we
    prepared ourselves to enhance our component structure using a key concept in React
    – composition.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了DRY原则。它指导我们消除代码中的冗余，降低不一致性和错误的可能性。通过避免代码重复，我们简化了维护工作，因为功能的变化只需要在一个地方解决。随着我们对DRY理解的深入，我们准备使用React中的一个关键概念——组合来增强我们的组件结构。
- en: Using composition
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合
- en: In React, `div` with an `h2` tag seamlessly, without the need to incorporate
    anything new.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，`div`与`h2`标签无缝结合，无需引入任何新内容。
- en: The custom component is nothing more special than the built-in ones like a `div`;
    you can use your `Cart` component with a `div` just as you can use a `p` tag with
    it. This pattern enables more straightforward reuse of components, which can contribute
    to cleaner and more maintainable code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义组件并不比内置组件如`div`更特殊；你可以像使用`p`标签一样使用你的`Cart`组件与`div`。这种模式使得组件的重用更加直接，有助于编写更干净、更易于维护的代码。
- en: 'Let’s consider an example. Suppose we’re building a `UserDashboard` component
    that displays user information. The profile includes an avatar, a name, and a
    list of the user’s friends and the latest posts. Here’s how it might look:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。假设我们正在构建一个`UserDashboard`组件，用于显示用户信息。个人资料包括头像、姓名以及用户的朋友列表和最新帖子。以下是它的可能外观：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this simplified example, `UserDashboard` is responsible for rendering the
    user’s profile, a list of friends, and the latest posts, which violates the SRP.
    We can break it down into smaller components, each responsible for one thing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的例子中，`UserDashboard`负责渲染用户的个人资料、朋友列表和最新帖子，这违反了单一职责原则。我们可以将其分解为更小的组件，每个组件负责一项任务。
- en: 'First, we can extract the profile-related JSX into a `UserProfile` component
    that displays the user’s profile, which includes an `h1` tag (the user’s name)
    and an `avatar` image:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将与个人资料相关的JSX提取到一个`UserProfile`组件中，该组件显示用户的个人资料，包括一个`h1`标签（用户的姓名）和`avatar`图像：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we create a `FriendList` component that displays a list of the user’s
    friends; it includes an `h2` tag and a `friends` list:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`FriendList`组件，用于显示用户的朋友列表；它包括一个`h2`标签和`friends`列表：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we create a `PostList` component that displays a feed of posts, which
    includes an `h2` tag and a list of `posts`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`PostList`组件，用于显示帖子流，包括一个`h2`标签和`posts`列表：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, our `UserDashboard` component becomes simpler and delegates its responsibilities
    to these smaller components:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`UserDashboard`组件变得更加简单，并将责任委托给这些较小的组件：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The refactored version of the `UserDashboard` component is superior due to
    several reasons:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建的`UserDashboard`组件之所以更优越，有以下几个原因：
- en: '`UserProfile`, `FriendList`, and `PostList`), you ensure that each component
    is responsible for one task. This improves the maintainability of the code.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`UserProfile`、`FriendList`和`PostList`（），你确保每个组件只负责一项任务。这提高了代码的可维护性。
- en: '`UserDashboard` is easier to read and understand. It becomes immediately clear
    what this component is rendering: a user profile, a list of friends, and a list
    of posts. There’s no need to read through details about how each of these parts
    is rendered.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserDashboard`更容易阅读和理解。它立即清楚这个组件渲染了什么：用户个人资料、朋友列表和帖子列表。无需阅读关于每个部分如何渲染的细节。'
- en: '`UserProfile`, `FriendList`, and `PostList` components can now be reused in
    other parts of the application if needed, thereby promoting code reuse and reducing
    redundancy.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserProfile`、`FriendList`和`PostList`组件现在可以在需要时在其他应用程序的部分重用，从而促进代码重用并减少冗余。'
- en: '**Testability**: Smaller, single-responsibility components are easier to test,
    as they tend to have less complex interactions and dependencies. We’ll cover the
    testing and testability in [*Chapter 5*](B21103_05.xhtml#_idTextAnchor124).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：较小的、单一职责的组件更容易测试，因为它们通常具有更简单的交互和依赖关系。我们将在[*第五章*](B21103_05.xhtml#_idTextAnchor124)中介绍测试和可测试性。'
- en: 'This is a simple example, but it illustrates the basic idea of composition
    in React. Composition can become more complex as you deal with components that
    have their own state or logic, but the core principle remains the same: building
    larger components from smaller, reusable parts.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但它说明了React中组合的基本思想。随着你处理具有自己状态或逻辑的组件，组合可能会变得更加复杂，但核心原则保持不变：从较小的、可重用的部分构建较大的组件。
- en: This section brought us to the power of composition in React. With composition,
    we could efficiently structure and combine our components, creating complex user
    interfaces from simpler, single-responsibility components. We observed how composition
    allowed us to fully leverage the principles of SRP and DRY, leading to the creation
    of sophisticated UIs that remain easy to understand, test, and maintain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节让我们领略了React中组合的力量。通过组合，我们可以有效地构建和组合我们的组件，从更简单、单一职责的组件中创建复杂的用户界面。我们观察到组合如何使我们充分利用单一职责原则和DRY原则，从而创建出既复杂又易于理解、测试和维护的UI。
- en: Combining component design principles
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件设计原则
- en: We’ve separately analyzed the principles of single responsibility, don’t repeat
    yourself, and composition. However, in practical coding scenarios, things can
    get intricate, necessitating the simultaneous application of multiple principles
    to enhance the readability and maintainability of the code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分别分析了单一职责原则、不要重复自己和组合原则。然而，在实际的编码场景中，事情可能会变得复杂，需要同时应用多个原则来提高代码的可读性和可维护性。
- en: Let’s consider an example of a `Page` component, which might have many responsibilities
    such as managing the state and behavior of a header, sidebar, and main content
    area. Also, there are a bunch of props for configuring each of these sections.
    It’s typical to encounter such code when individuals simply replicate the existing
    code base without much consideration or critical thinking; so the prop list grows
    as new features are added.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个`Page`组件的例子，它可能具有许多职责，例如管理标题、侧边栏和主要内容区域的状态和行为。此外，还有许多属性用于配置这些区域中的每一个。当个人简单地复制现有的代码库而没有太多考虑或批判性思维时，通常会遇到这样的代码；因此，随着新功能的添加，属性列表会增长。
- en: 'Here is a simplified example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简化的例子：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We defined a `Page` component; the component uses the preceding props to render
    a page with a clickable header, a sidebar containing clickable links, and a main
    content section. The component expects an object of the `PageProps` type as its
    properties.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`Page`组件；该组件使用前面的属性来渲染一个带有可点击标题、包含可点击链接的侧边栏和主要内容部分的页面。该组件期望其属性为`PageProps`类型的对象。
- en: 'Let’s take a closer look inside `PageProps`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`PageProps`内部：
- en: '`headerTitle`: This string will be displayed as the main title in the page’s
    header'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headerTitle`：这个字符串将在页面标题中显示为主要标题'
- en: '`headerSubtitle`: This string will be displayed as the subtitle in the page’s
    header'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headerSubtitle`：这个字符串将在页面标题中显示为副标题'
- en: '`sidebarLinks`: This is an array of strings, where each string represents a
    link that will be displayed in the page’s sidebar'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sidebarLinks`：这是一个字符串数组，其中每个字符串代表将在页面侧边栏中显示的链接'
- en: '`isLoading`: This is a flag to determine whether the main content is ready
    or not'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading`：这是一个标志，用于确定主要内容是否已准备好'
- en: '`mainContent`: This can be any valid React node (a component, an element, null,
    etc.) that represents the main content of the page'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mainContent`：这可以是任何有效的React节点（组件、元素、null等），它代表页面的主要内容'
- en: '`onHeaderClick`: This function will be executed when the header section of
    the page is clicked'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onHeaderClick`：当点击页面标题部分时，将执行此函数'
- en: '`onSidebarLinkClick`: This function will be executed when any sidebar link
    is clicked. The function will receive the clicked link as an argument'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSidebarLinkClick`：当点击任何侧边栏链接时，将执行此函数。该函数将接收被点击的链接作为参数'
- en: The `Page` component has multiple responsibilities, and it has a long list of
    props that could make it hard to work with. A long prop list – when a component
    has over five props – typically signals a need for component breakdown. This is
    because remembering the purpose of each prop can be challenging, and it also increases
    the likelihood of passing the wrong prop or misordering them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page`组件具有多个职责，并且它有一长串属性，这可能会使其难以处理。当组件有超过五个属性时，长属性列表通常表明需要组件分解。这是因为记住每个属性的目的可能具有挑战性，它还增加了传递错误属性或误排序它们的可能性。'
- en: We can group the props based on how they are used. The `headerTitle`, `headerSubtitle`,
    and `onHeaderClick` props can be split out into a group, while `isLoading` and
    `mainContent` belong to another group.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据它们的使用方式对属性进行分组。`headerTitle`、`headerSubtitle`和`onHeaderClick`属性可以分成一组，而`isLoading`和`mainContent`属于另一组。
- en: 'Extracting a small part of the large component is always a good starting point.
    Note that there might be many ways to do the extracting; if the information looks
    related to each other, we can group them and create a new component for that group
    of data. For example, we can extract a `Header` component first:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从大型组件中提取一小部分始终是一个好的起点。请注意，可能有许多提取的方法；如果信息看起来彼此相关，我们可以将它们分组并为此组数据创建一个新的组件。例如，我们可以首先提取一个`Header`组件：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `Header` component in React takes three props – `headerTitle`, `headerSubtitle`,
    and `onHeaderClick` – and renders a header with the provided title and subtitle.
    The `onHeaderClick` prop is then called when the header is clicked.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个React中的`Header`组件接受三个属性——`headerTitle`、`headerSubtitle`和`onHeaderClick`——并渲染一个带有提供标题和副标题的标题。当点击标题时，将调用`onHeaderClick`属性。
- en: 'Now, because `title`, `subtitle`, and the `onClick` callback are already in
    the `Header` component, we don’t need the `header` prefix in the prop names. Let’s
    rename these props:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为`title`、`subtitle`和`onClick`回调已经在`Header`组件中，我们不需要在属性名称中使用`header`前缀。让我们重命名这些属性：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It’s now much clearer regarding what `Header` does – it accepts `title`, `subtitle`,
    and `onClick` and doesn’t need to know anything beyond that. This extraction also
    increases the reusability of `Header`, meaning we might reuse the component in
    a different place.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于`Header`的功能已经非常清晰——它接受`title`、`subtitle`和`onClick`，并且不需要知道更多。这种提取也增加了`Header`的可重用性，这意味着我们可能在不同的地方重用这个组件。
- en: 'Now, we can extract a `Sidebar` component with the same approach:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用相同的方法提取一个`Sidebar`组件：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Sidebar` component accepts an array of `links` and an `onLinkClick` function
    as props and generates a list of clickable items from the `links` array. The `onLinkClick`
    function is triggered when a link is clicked, passing the clicked link as an argument.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sidebar`组件接受一个`links`数组和`onLinkClick`函数作为属性，并从`links`数组生成一个可点击的项目列表。当点击链接时，会触发`onLinkClick`函数，并将点击的链接作为参数传递。'
- en: 'After we extracted `Header` and `Sidebar`, the only thing left in `Page` is
    the part related to the main content. We can apply the same approach for the main
    content, extracting a `Main` component with the simple JSX fragment, as in the
    following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从`Page`中提取了`Header`和`Sidebar`之后，`Page`中剩下的唯一部分就是与主要内容相关的部分。我们可以对主要内容采用相同的方法，通过简单的JSX片段提取一个`Main`组件，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we extracted most of the content out of the `Page` component, we can now
    use these simple components without changing the public interface of `Page`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从`Page`组件中提取了大部分内容，我们现在可以使用这些简单的组件，而无需更改`Page`的公共接口：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Page` component arranges the `Header`, `Sidebar`, and `Main` components
    and takes in several props. It then passes these props to the respective child
    components – `Header` gets the title, subtitle, and a click handler; `Sidebar`
    receives a list of links and a click handler; and the `Main` component gets the
    main content and a loading state.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page`组件安排`Header`、`Sidebar`和`Main`组件，并接受几个属性。然后它将这些属性传递给相应的子组件——`Header`获取标题、副标题和一个点击处理程序；`Sidebar`接收一个链接列表和一个点击处理程序；`Main`组件获取主要内容和一个加载状态。'
- en: The refactored `Page` looks much nicer, but it’s not perfect. Let’s consider
    a common issue with the current code. What happens if we need to pass in new props
    to `Sidebar` or `Main`?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重新设计的`Page`组件看起来更美观，但还不是完美的。让我们考虑当前代码的一个常见问题。如果我们需要向`Sidebar`或`Main`传递新的属性会发生什么？
- en: To accept the new props passed into `Sidebar` or `Main`, we need to extend the
    prop list, which already has seven props. For people who use the `Page` component,
    as more props are added, they will have to remember even more props, which wouldn’t
    be a good experience (not to mention the additional testing efforts because of
    these props).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接受传递给`Sidebar`或`Main`的新属性，我们需要扩展属性列表，该列表已经有七个属性。对于使用`Page`组件的人来说，随着属性的增加，他们需要记住更多的属性，这不会是一个好的体验（更不用说因为这些属性而增加的额外测试工作）。
- en: 'Instead of accepting these detailed descriptions to customize `Header` or `Sidebar`,
    we can pass in an instance of `Header` and then just plug it into the correct
    slot (to replace the `Header` component):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是接受这些详细的描述来自定义`Header`或`Sidebar`，我们可以传递一个`Header`实例，然后只需将其插入正确的插槽（以替换`Header`组件）：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, the `Page` component accepts a `header` prop (along with a list of sidebar
    links, a loading state, main content, and a link click handler as props) and renders
    the `Header` component directly. That means we can pass in any `header` instance
    from outside of `Page`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Page`组件接受一个`header`属性（以及侧边栏链接列表、加载状态、主要内容和一个链接点击处理程序作为属性），并直接渲染`Header`组件。这意味着我们可以从`Page`外部传递任何`header`实例。
- en: 'Similarly, we can do the same for `Sidebar` and `Main`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以对`Sidebar`和`Main`做同样的事情：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Page` component accepts three props – `header`, `sidebar`, and `main` –
    with each expected to be a `Page` component simply renders these three props in
    a `div` in the order they are provided, effectively forming a simple page layout
    with a header, a sidebar, and a main section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page`组件接受三个属性——`header`、`sidebar`和`main`——每个属性都期望是一个`Page`组件，`Page`组件简单地按照提供的顺序在`div`中渲染这三个属性，从而形成一个带有标题、侧边栏和主要内容页面的简单布局。'
- en: 'You can then use `Page` in the most flexible way – you can pass in a fully
    customized `Header`, `Sidebar`, and `Main` as parameters into the `Page` component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以以最灵活的方式使用`Page`组件——你可以将完全定制的`Header`、`Sidebar`和`Main`作为参数传递给`Page`组件：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This `MyPage` component renders a `Page` component, passing in `Header`, `Sidebar`,
    and `Main` components as props, while click events on the `Header` and `Sidebar`
    components will log certain messages to the console.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`MyPage`组件渲染一个`Page`组件，通过props传入`Header`、`Sidebar`和`Main`组件，而点击`Header`和`Sidebar`组件将向控制台记录某些消息。
- en: 'Note that here you can pass anything into `Page` to define `header`, `sidebar`,
    or `main`. Here’s an example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里你可以将任何内容传递给`Page`以定义`header`、`sidebar`或`main`。以下是一个示例：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `MyPage` component wraps a `Page` component. The `Page` component receives
    three props: `header`, `sidebar`, and `main`, each containing JSX elements that
    specify what’s to be rendered in each respective section of the page. The `header`
    prop has a heading, the `sidebar` prop includes a list with `main` section contains
    the main content of the page.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyPage`组件包裹了一个`Page`组件。`Page`组件接收三个props：`header`、`sidebar`和`main`，每个都包含JSX元素，指定了页面相应部分的渲染内容。`header`prop包含一个标题，`sidebar`prop包含一个列表，而`main`部分包含页面的主要内容。'
- en: The original `Page` component was heavily burdened with a multitude of responsibilities,
    leading to a long list of props. This design presented a **prop drilling** problem,
    where a large amount of data had to be passed down through multiple layers of
    components. This setup was both complex and hard to maintain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`Page`组件承担了众多责任，导致props列表很长。这种设计带来了**prop drilling**问题，其中大量数据必须通过多个组件层传递。这种设置既复杂又难以维护。
- en: With that, let’s review our process of how we applied different principles.
    The refactoring process started by breaking down the monolithic `Page` component
    into smaller, more manageable components – `Header`, `Sidebar`, and `Main` – using
    the SRP. These sub-components were designed to handle their respective responsibilities,
    thus simplifying their individual prop requirements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾一下我们应用不同原则的过程。重构过程始于将单体`Page`组件分解成更小、更易于管理的组件——`Header`、`Sidebar`和`Main`——使用SRP（单一职责原则）。这些子组件被设计来处理它们各自的责任，从而简化了它们各自的prop需求。
- en: Once these components were extracted, we modified the `Page` component to accept
    these sub-components (`Header`, `Sidebar`, and `Main`) as props using composition.
    This approach significantly reduced the prop drilling issue, as each sub-component
    now receives props directly at the point of usage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提取了这些组件，我们就通过组合使用修改了`Page`组件以接受这些子组件（`Header`、`Sidebar`和`Main`）作为props。这种方法显著减少了prop
    drilling问题，因为每个子组件现在都直接在使用的点上接收props。
- en: This refactoring exercise streamlined the `Page` component, resulting in a cleaner,
    more manageable code base. It utilized the principles of component composition
    and single responsibility to solve the prop drilling problem effectively.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重构练习简化了`Page`组件，从而得到一个更干净、更易于管理的代码库。它利用了组件组合和单一职责的原则，有效地解决了prop drilling问题。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered several key principles in designing and developing components
    in React: the SRP, DRY, and the use of component composition. Each of these principles
    provides different strategies for achieving clean, maintainable, and scalable
    code bases.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在React中设计和开发组件的几个关键原则：SRP（单一职责原则）、DRY（不要重复自己）以及组件组合的使用。这些原则中的每一个都提供了不同的策略，以实现干净、可维护和可扩展的代码库。
- en: By understanding and applying these principles, we can create a solid foundation
    for our React applications. These strategies lead to more organized, scalable,
    and robust code bases, ultimately making our work as developers more effective
    and enjoyable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解和应用这些原则，我们可以为我们的React应用程序打下坚实的基础。这些策略导致更组织化、可扩展和健壮的代码库，最终使我们的开发工作更加高效和愉快。
- en: In the next chapter, we’ll start to look into an exciting topic in React applications
    – testing – and see how good structured tests can protect us from making mistakes
    while helping us to improve the code quality.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探讨React应用程序中的一个令人兴奋的主题——测试，并看看良好的结构化测试如何帮助我们避免犯错，同时帮助我们提高代码质量。
- en: 'Part 2: Embracing Testing Techniques'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：拥抱测试技术
- en: In this part, you will delve into the significance of testing in frontend development,
    exploring various testing methodologies and refactoring techniques that will ensure
    the robustness and maintainability of your React applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将深入了解测试在前端开发中的重要性，探索各种测试方法和重构技术，以确保你的React应用程序的健壮性和可维护性。
- en: 'This part contains the following chapters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B21103_05.xhtml#_idTextAnchor124), *Testing in React*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21103_05.xhtml#_idTextAnchor124), *React中的测试*'
- en: '[*Chapter 6*](B21103_06.xhtml#_idTextAnchor153), *Exploring Common Refactoring
    Techniques*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21103_06.xhtml#_idTextAnchor153), *探索常见的重构技术*'
- en: '[*Chapter 7*](B21103_07.xhtml#_idTextAnchor176), *Introducing Test-Driven Development
    with React*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21103_07.xhtml#_idTextAnchor176), *使用React介绍测试驱动开发*'
