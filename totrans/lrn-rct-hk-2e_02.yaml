- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing React and React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a JavaScript library used to build efficient and extensible web applications.
    React was developed by Meta and is used in many large-scale web applications,
    such as Facebook, Instagram, Netflix, Shopify, Airbnb, Cloudflare, and the BBC.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are going to learn how to build complex and efficient user
    interfaces with React, while keeping the code simple and extensible. Using the
    paradigm of React Hooks, we can greatly simplify dealing with state and effects
    in web applications, ensuring the potential for growing and extending the application
    later. We are also going to learn about **React Context**, **React Suspense**,
    and **Form Actions**, as well as how they can be used with Hooks. Finally, we
    are going to learn how to build our own Hooks and how to migrate existing applications
    from React class components to a React Hooks-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this first chapter, we are going to learn about the fundamental principles
    of React and React Hooks. We will start by learning what React and React Hooks
    are, and why we should use them. Then, we will move on to learn about the inner
    workings of Hooks. Finally, you will be introduced to the Hooks that are provided
    by React, and a couple of Hooks provided by the community – such as data fetching
    and routing Hooks. By learning the fundamentals of React and React Hooks, we will
    be better able to understand the concepts that will be introduced throughout this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Principles of React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motivation to use React Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with React Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out their official website:
    [https://nodejs.org/](https://nodejs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to their official website:
    [https://code.visualstudio.com](https://code.visualstudio.com).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we use the following versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js v22.14.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm` v10.9.2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code v1.97.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The versions mentioned in the preceding list are the ones used in the book.
    While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter01).'
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  prefs: []
  type: TYPE_NORMAL
- en: Principles of React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start learning how to set up a React project, let’s revisit the three
    fundamental principles of React. These principles allow us to easily write scalable
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'React is based on three fundamental principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative**: Instead of telling React how to do things, we tell it what
    we want it to do. For example, if we change data, we don’t need to tell React
    which components need to be re-rendered. That would be complex and error-prone.
    Instead, we just tell React that data has changed and all components using this
    data will be efficiently updated and re-rendered for us. React takes care of the
    details so that we can focus on the tasks at hand to easily develop our web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component-based**: React encapsulates components that manage their own state
    and views and then allows us to compose them in order to create complex user interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learn once, write anywhere**: React does not make assumptions about your
    technology stack and tries to ensure that you can develop apps without rewriting
    existing code as much as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React’s three fundamental principles make it easy to write code, encapsulate
    components, and share code across multiple platforms. Instead of reinventing the
    wheel, React always tries to make use of existing JavaScript features as much
    as possible. As a result, we are going to learn about software design patterns
    that will be applicable in many more cases than just designing user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just learned that React is component-based. In React, there are two types
    of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function components**: JavaScript functions that take the props as an argument,
    and return the user interface (usually via JSX, which is an extension of the JavaScript
    syntax that allows us to write HTML-like markup directly within JavaScript code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class components**: JavaScript classes that provide a `render` method, which
    returns the user interface (usually via JSX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While function components are easier to define and understand, in the past,
    class components were needed to deal with state, contexts, and many more of React’s
    advanced features. However, with React Hooks, we can use most of React’s advanced
    features without needing a class component!
  prefs: []
  type: TYPE_NORMAL
- en: There are certain features of React that, at the time of writing, are not possible
    with function components and Hooks yet. For example, defining error boundaries
    still requires class components and the `componentDidCatch` and `getDerivedStateFromError`
    lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation to use React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React always strives to make the developer experience as smooth as possible
    while ensuring to keep it performant enough, without the developer having to worry
    too much about how to optimize performance. However, throughout the years of using
    React, a couple of problems have been identified.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippets in the following subsections are just intended to give you
    an understanding of why Hooks were needed, by giving examples of how developers
    previously dealt with certain problems in React. If you are not familiar with
    those old ways, do not worry, it’s not necessary to understand the old ways to
    follow along. In the upcoming sections, we are going to learn how to deal with
    these problems in a better way using React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a look at these problems in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Confusing classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, we had to use class components with special functions called life
    cycle methods, such as `componentDidUpdate`, and special state-handling methods
    such as `this.setState`, to deal with state changes. React classes, and especially
    the `this` context, are hard to read and understand for both developers and machines.
  prefs: []
  type: TYPE_NORMAL
- en: '`this` is a special keyword in JavaScript that always refers to the object
    that it belongs to:'
  prefs: []
  type: TYPE_NORMAL
- en: In a method, `this` refers to the class object (instance of the class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In an event handler, `this` refers to the element that received the event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a function or standing alone, `this` refers to the global object. For example,
    in a browser, the global object is the `Window` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In strict mode, `this` is `undefined` in a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, methods such as `call()` and `apply()` can change the object that
    `this` refers to, so it can refer to any object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For developers, classes are hard, because `this` always refers to different
    things, so sometimes (for example, in event handlers) we need to manually rebind
    it to the class object. For machines, classes are hard, because they do not know
    which methods in a class will be called and how `this` will be modified, making
    it hard to optimize performance and remove unused code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, classes sometimes require us to write code in multiple places
    at once. For example, if we want to fetch data when the component renders or props
    of a component change, we need to do this using two methods: once in `componentDidMount`,
    and once in `componentDidUpdate`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example, let’s define a class component that fetches data from an
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a class component by extending the `React.Component` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the `componentDidMount` life cycle method, where we pull data
    from an API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, we also need to define the `componentDidUpdate` life cycle method
    in case the `name` prop changes. Additionally, we need to add a manual check here,
    to ensure that we only re-fetch data if the `name` prop changed, and not when
    other props change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the code less repetitive, we could refactor our code by creating a
    separate method called `fetchData` and fetch the data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we could call the method in `componentDidMount` and `componentDidUpdate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, even then we still need to call the method in two places. Whenever
    we update arguments that are passed to the method, we need to update them in two
    places, which makes this pattern very prone to errors and future bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper hell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume we already implemented an `authenticateUser` higher-order component
    function that adds authentication to one of our components, and a context called
    `AuthenticationContext` to provide information about the authenticated user via
    render props. We would then use this context as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing the `authenticateUser` function to wrap our component
    with the context, and the `AuthenticationContext` component to be able to access
    the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define an `App` component, where we make use of the `AuthenticationContext.Consumer`
    component and the `user` render prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Render props** are a way to pass props down to the children of a component.
    As we can see here, the render prop allowed us to pass `user` down to the children
    of the `AuthenticationContext.Consumer` component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we display different texts depending on whether the user is logged in
    or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we used two JavaScript concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **ternary operator**, which is an inline version of the `if` conditional.
    It looks as follows: `ifThisIsTrue ? returnThis : otherwiseReturnThis`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **template string**, which can be used to insert variables into a string.
    It is defined with backticks (`` ` ``) instead of normal single quotes (`'`).
    Variables can be inserted via the `${variableName}` syntax. We can also use any
    JavaScript expressions within the `${}` brackets – for example, `${someValue +
    1}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we export the component after wrapping it with the `authenticateUser`
    context, by making use of the higher-order component pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Higher-order components** are functions that wrap components and add functionality
    to them. They were needed to encapsulate and reuse state management logic before
    Hooks.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used the `authenticateUser` higher-order component function
    to add authentication logic to our existing component. We then used `AuthenticationContext.Consumer`
    to inject the `user` prop into our component through its render props.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, using many higher-order components will result in a large
    tree with many sub-trees, which is an anti-pattern called **wrapper hell**. For
    example, when we want to use three contexts, the wrapper hell looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is not very easy to read or write and is also prone to errors if we need
    to change something later on. The wrapper hell makes debugging hard because we
    need to look at a large component tree, with many components just acting as wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about some common problems with React, let’s learn
    about the Hook pattern to better deal with these problems!
  prefs: []
  type: TYPE_NORMAL
- en: Hooks to the rescue!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Hooks are based on the same fundamental principles as React. They encapsulate
    state management by using existing JavaScript features. As a result, we do not
    need to learn and understand many specialized React features anymore; we can simply
    tap into our existing JavaScript knowledge to use Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks, we can come up with better solutions to the previously mentioned
    problems. Hooks are simply functions that can be called in function components.
    We also do not need to use render props for contexts anymore, because we can simply
    use a **Context Hook** to get the data that we need. Additionally, Hooks allow
    us to reuse stateful logic between components, without creating higher-order components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the aforementioned problems with life cycle methods could be solved
    using an **Effect Hook**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This Effect Hook will automatically trigger when the component mounts, and whenever
    the `name` prop changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wrapper hell mentioned earlier could be solved using Context Hooks, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, by using Hooks, we can keep our code clean and concise, making
    sure that our code stays easy to read and maintain. Writing custom Hooks also
    makes it easy to reuse application logic in a project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know which problems Hooks can solve, we can get started using them
    in practice. First, however, we need to quickly set up our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we are going to use **VS Code** as our code editor. Feel free
    to use whichever editor you prefer, but keep in mind that the extensions used
    and settings configured may be slightly different in the editor of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now install VS Code and some useful extensions, and then continue setting
    up all the tools needed for our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VS Code and extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can get started developing and setting up the other tools, we need
    to set up our code editor, by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download VS Code for your operating system from the official website (at the
    time of writing, the URL is [https://code.visualstudio.com/](https://code.visualstudio.com/)).
    We are going to use version 1.97.2 in this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After downloading and installing the application, open it, and you should see
    the following window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A fresh installation of Visual Studio Code (on macOS)](img/B31327_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – A fresh installation of Visual Studio Code (on macOS)
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier later, we are going to install some extensions, so click
    on the **Extensions** icon, which is the fifth icon from the top left in the screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A sidebar should open, where you can see **Search Extensions in Marketplace**
    at the top. Enter an extension name here and click on **Install** to install it.
    Let’s start by installing the **ESLint** extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Installing the ESLint extension in Visual Studio Code](img/B31327_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Installing the ESLint extension in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to install the following extensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ESLint (by Microsoft)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prettier – Code formatter (by Prettier)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for JavaScript and Node.js already comes built-in with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for the projects made in this book (for example, you can call
    it `Learn-React-Hooks-Second-Edition`). Inside this folder, create a new folder
    called `Chapter01_1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the empty `Chapter01_1` folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you get a dialog asking **Do you trust the authors of the files in this folder?**,
    check **Trust the authors of all files in the parent folder ‘Learn-React-Hooks’**
    and then click on the **Yes, I trust the authors** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Allowing VS Code to execute files in our project folder](img/B31327_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Allowing VS Code to execute files in our project folder
  prefs: []
  type: TYPE_NORMAL
- en: You can safely ignore this warning in your own projects, as you can be sure
    that those do not contain malicious code. When opening folders from untrusted
    sources, you can press **No, I don’t trust the authors**, and still browse the
    code. However, when doing so, some features of VS Code will be disabled.
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully set up VS Code and are ready to start setting up our
    project! If you cloned the folder from the GitHub code examples provided, a notification
    telling you that a Git repository was found will also pop up. You can simply close
    this one, as we only want to open the `Chapter01_1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that VS Code is ready, let’s continue by setting up a new project with Vite.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project with Vite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this book, we are going to use **Vite** to set up our project, as it is
    the most popular and liked local development server, according to *The State of
    JS 2024* survey ([https://2024.stateofjs.com/](https://2024.stateofjs.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Vite also makes it easy to set up a modern frontend project while still making
    it possible to extend the configuration later if needed. Follow these steps to
    set up your project with Vite:'
  prefs: []
  type: TYPE_NORMAL
- en: In the VS Code menu bar, go to **Terminal** | **New Terminal** to open a new
    terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `$` symbol shows that this is a command that needs to be entered into a
    terminal. Enter everything after the `$` symbol into the terminal and confirm
    with *Return/Enter* to run the command. Make sure there is a period at the end
    of the command to create the project in the current folder instead of creating
    a new folder.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the instructions in this book working even when new versions are released,
    we pin all packages to a fixed version. Please follow the instructions with the
    given versions. After finishing this book, when starting new projects on your
    own, you should always try using the latest versions, but keep in mind that changes
    might be needed to get them working. Consult the documentation of the respective
    packages and follow the migration path from the book version to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: When asked whether `create-vite` should be installed, simply type `y` and press
    the *Return/Enter* key to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are asked about the current directory not being empty, select the option
    **Remove existing files and continue**, then press *Return/Enter* to confirm it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When asked for a package name, confirm the default suggestion by pressing *Return/Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When asked about the framework, use the arrow keys to select **React** and press
    *Return/Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When asked about the variant, select **JavaScript**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For simplicity and to cater to a wider audience, we are only using plain JavaScript
    in this book. It should be noted that, nowadays, TypeScript is widely used in
    many projects, so you may want to consider adopting TypeScript in your own projects
    later. However, learning about TypeScript is outside of the scope of this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit `package.json` and make sure that the versions of `dependencies` and `devDependencies`
    are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now our project is set up and we can run `npm install` in the terminal to install
    the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Afterward, run `npm run dev` to start the dev server, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – The terminal after setting up a project with Vite and before
    starting the dev server](img/B31327_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – The terminal after setting up a project with Vite and before starting
    the dev server
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity of setup, we just used `npm` directly. If you prefer `yarn` or
    `pnpm`, you can instead run `yarn create vite` or `pnpm create vite` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, you will see a URL telling you where your app is running. You
    can either hold *Ctrl* (*Cmd* on macOS) and click on the link to open it in your
    browser, or manually enter the URL in a browser. Open the link in a browser now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test whether your app is interactive, click the button with the text **count
    is 0**, and it should increase the count every time it is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Our first React app running with Vite](img/B31327_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Our first React app running with Vite
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Vite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatives to Vite are bundlers, such as webpack, Rollup, and Parcel. These
    are highly configurable but often do not offer a great experience for dev servers.
    They first must bundle all our code together before serving it to the browser.
    Instead, Vite natively supports the **ECMAScript Module** (**ESM**) standard.
    Furthermore, Vite requires very little configuration to get started. A downside
    of Vite is that it can be hard to configure certain more complex scenarios with
    it. An upcoming bundler that is promising is Rolldown ([https://rolldown.rs](https://rolldown.rs));
    however, it is still very new at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our boilerplate project is up and running, let’s spend some time setting
    up tools that will enforce best practices and a consistent code style.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up ESLint and Prettier to enforce best practices and code style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our React app is set up, we are going to set up **ESLint** to enforce
    coding best practices with JavaScript and React. We are also going to set up **Prettier**
    to enforce a code style and automatically format our code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the necessary dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we are going to install all the necessary dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, click on the **Split Terminal** icon at the top right of the
    terminal pane to create a new terminal pane (alternatively, right-click on the
    terminal pane and select **Split Terminal**). This will keep our app running while
    we run other commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on this newly opened pane to focus it. Then, enter the following command
    to install Prettier and the Prettier config for ESLint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `--save-dev` flag in `npm` saves those dependencies as `dev` dependencies,
    which means that they will only be installed for development. They will not be
    installed and included in a deployed app. The `--save-exact` flag ensures that
    the versions are pinned to the exact version provided by the book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the dependencies are installed, we need to configure Prettier and ESLint.
    We will start with configuring Prettier.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Prettier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prettier will format the code for us and replace the default code formatter
    for JavaScript in VS Code. It will allow us to spend more time writing code, automatically
    formatting it for us properly when we save the file. Follow these steps to configure
    Prettier:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click below the files list in the left sidebar of VS Code (if it is not
    opened, click the **Files** icon) and click on **New file...** to create a new
    file. Call it `.prettierrc.json` (do not forget the period at the beginning of
    the filename!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The newly created file should open automatically; start writing the following
    configuration into it. We first create a new object and set the `trailingComma`
    option to `all` to make sure objects and arrays that span over multiple lines
    always have a comma at the end, even for the last element. This reduces the number
    of touched lines when committing a change via Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set the `tabWidth` option to two spaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set `printWidth` to 80 characters per line to avoid long lines in our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `semi` option to `false` to avoid semicolons where not necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we enforce the use of single quotes instead of double quotes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These settings for Prettier are just an example of a coding style convention.
    Of course, you are free to adjust these to your own preferences. There are many
    more options, all of which can be found in the Prettier docs ([https://prettier.io/docs/en/options.html](https://prettier.io/docs/en/options.html)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configuring the Prettier extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a configuration file for Prettier, we need to make sure the
    VS Code extension is properly configured to format the code for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the VS Code settings by going to **File | Preferences... | Settings** on
    Windows/Linux, or **Code | Settings... | Settings** on macOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the newly opened settings editor, click on the **Workspace** tab. This ensures
    that we save all our settings in a `.vscode/settings.json` file in our project
    folder. When other developers open our project, they will automatically be using
    those settings as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `editor format on save` and check the checkbox to enable formatting
    code on save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `editor default formatter` and select **Prettier - Code formatter**
    from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify that Prettier works, open the `.prettierrc.json` file, add some extra
    spaces to the beginning of a line, and save the file. You should notice that Prettier
    reformatted the code to adhere to the defined code style. It will reduce the number
    of spaces for indentation to 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that Prettier is set up properly, we do not need to worry about formatting
    our code manually anymore. Feel free to just type in code as you go and save the
    file to get it formatted for you!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Prettier ignore file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To improve performance and avoid running Prettier on files that should not
    be automatically formatted, we can ignore certain files and folders by creating
    a Prettier ignore file. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `.prettierignore` in the root of our project, similar
    to how we created the `.prettierrc.json` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following contents to it, to ignore the transpiled source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `node_modules/` folder is automatically ignored by Prettier.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully set up Prettier, we are going to configure ESLint
    to enforce coding best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ESLint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While Prettier focuses on the style and formatting of our code, ESLint focuses
    on the actual code, avoiding common mistakes or unnecessary code. Let’s configure
    it now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the automatically created `eslint.config.js` file and add the following
    import to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Scroll down to the bottom of the file, and add the Prettier config at the end
    of the array, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, disable the `react/prop-types` rule, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since React 19, prop type checks are completely removed and will be silently
    ignored. The only way to add type checks to props is to use a full type-checking
    solution, such as TypeScript. Since we are focusing on learning plain React with
    Hooks in this book, using TypeScript is out of scope. However, if you haven’t
    yet, I strongly recommend learning TypeScript on your own after finishing this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Save the files and run `npx eslint src` in the terminal to run the linter. You
    will see that there is no output, which means that everything was linted successfully
    and there were no errors!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `npx` command allows us to execute commands provided by `npm` packages,
    in a similar context as running them in `package.json` scripts would do. It can
    also run remote packages without installing them permanently. In the case that
    the package is not installed yet, it will ask you whether it should do this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new script to run our linter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we have been calling the linter by running `npx eslint
    src` manually. We are now going to add a `lint` script to our `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal, run the following command to define a lint script in our `package.json`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run `npm run lint` in the terminal. This should execute `eslint src` successfully,
    just like `npx eslint src` did:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – The linter running successfully, with no errors](img/B31327_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – The linter running successfully, with no errors
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully set up our development environment, let’s move
    on to learning about using React class components versus React Hooks in practice!
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter01/Chapter01_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned earlier in this chapter, React Hooks solve many problems, especially
    in larger web applications. Hooks were added in React 16.8, and they allow us
    to use state, and various other React features, without writing a class. In this
    section, we will start by defining a class component, and then we will write the
    same component as a function component using Hooks. We will then discuss the advantages
    of Hooks and how to migrate from classes to a Hook-based solution.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a class component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a traditional React class component, which lets us
    enter a name; this is then displayed in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter01_1` folder to a new `Chapter01_2` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On macOS, it is important to run the command with a capitalized `-R` flag, not
    `-r`. The `-r` flag deals differently with symlinks and causes the `node_modules/`
    folder to break. The `-r` flag only exists for historical reasons and should not
    be used on macOS. Always prefer using the `-R` flag instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the new `Chapter01_2` folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Remove* the `src/assets/` folder and all its contents.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Remove* the `src/App.css` and `src/index.css` files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `src/main.jsx` file and *remove* the following import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, adjust the import of the `App` component from a default import
    to a named import, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In most cases, it’s preferable to use named exports/imports over default exports/imports.
    Using named exports/imports makes the code less error-prone when refactoring.
    For example, let’s imagine you have a `Login` component and you copy and paste
    it to a new `Register` component but forget to rename the component to `Register`.
    With default imports, it will still be possible to import it as `Register`, although
    the component is called `Login` internally. However, when debugging in React dev
    tools or trying to find the component in your project, you will see it named `Login`,
    which can be confusing, especially in large-scale projects. When dealing with
    functions, using named exports is even more useful because it allows you to move
    them around in different files easily.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `src/App.jsx` file and *remove* all existing code from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we import React, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then start defining a class component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we have to define a `constructor` method, where we set the initial `state`
    object, which will be an empty string. Here, we also need to make sure to call
    `super(props)`, to let the `React.Component` constructor know about the `props`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define a method to set the `name` variable, by using `this.setState`.
    As we will be using the method to handle input from a text field, we need to use
    `evt.target.value` to get the value from the input field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the `render` method, where we are going to display an input
    field and the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the `name` variable from the `this.state` object, we are going to use
    destructuring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previous statement is the equivalent of doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we display the currently entered `name` state variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We display an input field, passing the handler method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we were to run this code now, we would get the following error when entering
    text, because passing the handler method to `onChange` changes the `this` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, on some browsers, you may get the following error instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we need to adjust the constructor method and rebind the `this` context
    of our handler method to the class. Edit `src/App.jsx` and add the following line
    in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the dev server, by opening a terminal (**Terminal** | **New Terminal**
    menu option in VS Code), and executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the link to the dev server in your browser, and you should see the component
    being rendered. Try entering some text now and it should work!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, since ES6, it is possible to use arrow functions as class methods
    to avoid having to rebind the `this` context.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our component works! As you can see, there is a lot of code required
    to get state handling to work properly with class components. We also had to rebind
    the `this` context; otherwise, our handler method would not work. This is not
    very intuitive, and is easy to miss while developing, causing a frustrating developer
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter01/Chapter01_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks instead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After using a traditional class component to create our app, we are going to
    write the same app using Hooks. As before, our app is going to let us enter a
    name, which we then display in the app.
  prefs: []
  type: TYPE_NORMAL
- en: It is only possible to use Hooks in React function components. You cannot use
    Hooks in a React class component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `Chapter01_2` folder to a new `Chapter01_3` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the new `Chapter01_3` folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `src/App.jsx` file and *remove* all existing code from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we import the `useState` Hook, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We start with the function definition. In our case, we do not pass any arguments,
    because our component does not have any props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step would be to get the `name` variable from the component state.
    However, we cannot use `this.state` in function components. We have already learned
    that Hooks are just JavaScript functions, but what does that really mean? It means
    that we can simply use Hooks from function components, just like any other JavaScript
    function!
  prefs: []
  type: TYPE_NORMAL
- en: 'To use state via Hooks, we call `useState()`, with our initial state as the
    argument. This function returns an array with two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A setter function to set the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use destructuring to store these two elements in separate variables,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previous code is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define the input handler function, where we make use of the `setName`
    setter function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we are not dealing with classes now, there is no need to rebind `this` anymore!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we render our user interface, by returning it from the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that’s it – we have successfully used Hooks for the first time! As you can
    see, the `useState` Hook is a simple replacement for `this.state` and `this.setState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run our app by executing `npm run dev` in the Terminal and opening the
    URL in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Our first React app using Hooks!](img/B31327_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Our first React app using Hooks!
  prefs: []
  type: TYPE_NORMAL
- en: After implementing the same app with a class component and a function component,
    let’s compare the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in the `Chapter01/Chapter01_3`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s compare our two solutions to see the differences between class components
    and function components using Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Class component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The class component makes use of the `constructor` method to define state and
    needs to rebind `this` to be able to pass the handler method to the `input` field.
    The full class component code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the class component needs a lot of boilerplate code to initialize
    the `state` object and handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at the function component.
  prefs: []
  type: TYPE_NORMAL
- en: Function component with a Hook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function component makes use of the `useState` Hook instead, so that we
    do not need to deal with `this` or a `constructor` method. The full function component
    code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Hooks make our code much more concise and easier to reason about.
    We do not need to worry about how things work internally anymore; we can simply
    use state, by accessing the `useState` function!
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s remind ourselves about the first principle of React:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarative: Instead of telling React how to do things, we tell it what we
    want it to do. As a result, we can easily design our applications, and React will
    efficiently update and render just the right components when the data changes.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As we have learned in this chapter, Hooks allow us to write code that tells
    React what we want. With class components, however, we need to tell React how
    to do things. As a result, Hooks are much more declarative than class components,
    making them a better fit in the React ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks being declarative also means that React can do various optimizations on
    our code, since it is easier to analyze functions and function calls rather than
    classes and their complex `this` behavior. Additionally, Hooks make it easier
    to abstract and share common stateful logic between components. By using Hooks,
    we can avoid render props and higher-order components.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that Hooks not only make our code more concise and are easier to
    reason about for developers but they also make the code easier to optimize for
    React.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, you might be wondering whether that means class components are deprecated,
    and we need to migrate everything to Hooks now. Of course not – Hooks are completely
    opt-in. You can try Hooks in some of your components without rewriting any of
    your other code. The React team also does not plan on removing classes at the
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: There is no rush to migrate everything to Hooks right now. It is recommended
    that you gradually adopt Hooks in certain components where they will be most useful.
    For example, if you have many components that deal with similar logic, you can
    extract the logic to a Hook. You can also use function components with Hooks side
    by side with class components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hooks are backward-compatible and provide a direct API to various React concepts
    that you already know about: **props**, **state**, **context**, **refs**, and
    the **life cycle**. Additionally, Hooks offer new ways to combine these concepts
    and encapsulate their logic in a much better way that does not lead to wrapper
    hell or similar problems.'
  prefs: []
  type: TYPE_NORMAL
- en: The Hooks mindset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main goal of Hooks is to decouple stateful logic from rendering logic. Hooks
    allow us to define logic in separate functions and reuse them across multiple
    components. With Hooks, we do not need to change our component hierarchy to implement
    stateful logic. There is no need to define a separate component that provides
    the state logic to multiple components anymore, we can simply use a Hook instead!
  prefs: []
  type: TYPE_NORMAL
- en: However, Hooks require a completely different mindset from traditional React
    development. We should not think about the life cycle of components anymore. Instead,
    we should think about data flow. For example, we can tell Hooks to trigger when
    certain props or values from other Hooks change. We are going to learn more about
    this concept in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor103), *Using the Reducer
    and Effect Hooks*. We should also not split components based on life cycle methods
    anymore. Instead, we can use Hooks to deal with common functionalities, such as
    fetching data or setting up a data subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hooks are very flexible. However, there are certain limitations to using Hooks,
    which we should always keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooks can only be used in function components and inside other Hooks, not in
    class components or arbitrary functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of Hook definitions matters and needs to stay the same; thus, we cannot
    put Hooks in `if` conditionals, loops, or nested functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thankfully, Vite already configured an ESLint plugin for us that ensures that
    the rules of Hooks are not violated.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to discuss these limitations in more detail, as well as how to
    work around them, throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter of the book, we started by learning about the fundamental
    principles of React, and which types of components it provides. We then moved
    on to learn about common problems with class components, using existing features
    of React, and how they break the fundamental principles. Next, we implemented
    a simple application using class components and function components with Hooks,
    in order to be able to compare the differences between the two solutions. As we
    found out, function components with Hooks are a much better fit for React’s fundamental
    principles; they do not suffer from the same problems as class components, and
    they make our code much more concise and easy to understand! The React team now
    even recommends using function components instead of class components, making
    function components the state-of-the-art way to write React code. After reading
    this chapter, the basics of React and React Hooks are clear. We can now move on
    to learn about Hooks in detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to gain an in-depth knowledge of how the State
    Hook works, by reimplementing it from scratch. By doing so, we are going to get
    a grasp on how Hooks work internally, and what their limitations are. Afterward,
    we are going to create a small blog application using the State Hook!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are React’s three fundamental principles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two types of components in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the problems with class components in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the problem when using higher-order components in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which tool can we use to set up a React project, and what is the command that
    we need to run to use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What do we need to do if we get the following error with class components:
    `Uncaught TypeError: Cannot read properties of undefined (reading ''setState'')`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we use React state with Hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using function components with Hooks, in comparison
    to class components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we need to replace all class components with function components using Hooks
    when updating React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about function components: [https://react.dev/reference/react/Component](https://react.dev/reference/react/Component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC for React Hooks: [https://github.com/reactjs/rfcs/blob/main/text/0068-react-hooks.md](https://github.com/reactjs/rfcs/blob/main/text/0068-react-hooks.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Destructuring: [https://exploringjs.com/es6/ch_destructuring.html](https://exploringjs.com/es6/ch_destructuring.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template strings: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ternary operator: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/wnXT0](Chapter_01.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_%283%29.png)'
  prefs: []
  type: TYPE_IMG
