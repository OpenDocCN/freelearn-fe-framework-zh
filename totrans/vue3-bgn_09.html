<html><head></head><body>
		<div id="_idContainer108">
			<h1 id="_idParaDest-112" class="chapter-number"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.2.1">Introduction to Advanced Vue.js Techniques – Slots, Lifecycle, and Template Refs</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">Up until now, we have learned about the basic features and techniques offered by Vue.js. </span><span class="koboSpan" id="kobo.3.2">Things such as properties and computed are the foundation of the Vue.js framework and will be used daily as you develop your next application with Vue.js. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we are going to cover a few features that are what I call “advanced.” </span><span class="koboSpan" id="kobo.3.4">This is not described as “advanced” because of its complexity, but in the fact that you will be less likely to use this daily. </span><span class="koboSpan" id="kobo.3.5">Features such as slots and Template Refs are used to solve specific use cases and are not expected to be encountered during your average task but are more likely to be used for specific situations that occur less frequently during a project. </span><span class="koboSpan" id="kobo.3.6">What you will learn in this chapter may not be used for quite some time, so it would be good to remember its existence and make sure you come back to it if the need for any of these features arises in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">your task.</span></span></p>
			<p><span class="koboSpan" id="kobo.5.1">In this chapter, we are going to add yet more features to our Companion App. </span><span class="koboSpan" id="kobo.5.2">We are first going to enhance our base button to introduce the notion of slots. </span><span class="koboSpan" id="kobo.5.3">Next, we will create a shared layout to be used in our static pages using named slots. </span><span class="koboSpan" id="kobo.5.4">Then, we will turn our attention to adding a new feature that will allow us to add new posts. </span><span class="koboSpan" id="kobo.5.5">While doing so, we are going to learn how to use Template</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.6.1"> Ref to access the </span><strong class="old"><span class="koboSpan" id="kobo.7.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong class="old"><span class="koboSpan" id="kobo.9.1">DOM)</span></strong><span class="koboSpan" id="kobo.10.1"> to autofocus the </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">CreatePost.vue </span></strong><span class="koboSpan" id="kobo.12.1">component. </span><span class="koboSpan" id="kobo.12.2">To conclude the chapter, we are going to build a completely new feature that will allow us to expand and collapse our sidebar. </span><span class="koboSpan" id="kobo.12.3">While doing so, we are not only going to iterate over the Vue.js lifecycles hooks but we are also using this opportunity to go over previously learned techniques such as methods, dynamic classes, </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">and directives.</span></span></p>
			<p><span class="koboSpan" id="kobo.14.1">The chapter will be divided into the </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">following sections:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.16.1">The power </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">of slots</span></span></li>
				<li><span class="koboSpan" id="kobo.18.1">Accessing components elements with </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Template Refs</span></span></li>
				<li><span class="koboSpan" id="kobo.20.1">Deep diving into the lifecycle of a </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">real app</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.22.1">By the end of this chapter, you will be able to use components that offer slots and develop components that expose one or multiple slots. </span><span class="koboSpan" id="kobo.22.2">You will also be able to access an element within a component with the use of Template Refs and finally be able to make better decisions when using lifecycles, to ensure that the application is free </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">of bugs.</span></span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.25.1">In this chapter, the branch is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">CH09</span></strong><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">To pull this branch, run the following command or use your GUI of choice to support you in </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">this operation:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.29.1">
git switch CH09.</span></pre>
			<p><span class="koboSpan" id="kobo.30.1">The code files for the chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-for-Beginners"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Vue.js-3-for-Beginners</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.34.1">The power of slots</span></h1>
			<p><span class="koboSpan" id="kobo.35.1">In the first few chapters of this book, we have learned</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.36.1"> how properties and events can be used for a parent and a child to communicate with each other. </span><span class="koboSpan" id="kobo.36.2">This method of communication is not very flexible, as the only way for a component to expose information is by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">new property.</span></span></p>
			<p><span class="koboSpan" id="kobo.38.1">In many cases, the rigidity that properties provide is precisely what we want to make sure that our component renders correctly, but there are times when more flexibility is needed, and this is where slots </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">come in.</span></span></p>
			<p><span class="koboSpan" id="kobo.40.1">Let’s consider our base button component. </span><span class="koboSpan" id="kobo.40.2">Its look and feel are defined by its properties and so is its value, but what would happen if we wanted to create a button with an icon before </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">its value?</span></span></p>
			<p><span class="koboSpan" id="kobo.42.1">With our current knowledge of Vue.js, we would resort to creating a new prop of icon (</span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">prependIcon</span></strong><span class="koboSpan" id="kobo.44.1">) that accepts an icon. </span><span class="koboSpan" id="kobo.44.2">Then, a further requirement may need us to add an icon after the value, so we would again resort to a new property of icon (</span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">appendIcon</span></strong><span class="koboSpan" id="kobo.46.1">). </span><span class="koboSpan" id="kobo.46.2">Each additional request may result in a new property making our component very hard to maintain. </span><span class="koboSpan" id="kobo.46.3">Luckily, all the preceding requirements can be solved </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">using slots.</span></span></p>
			<p><span class="koboSpan" id="kobo.48.1">Slots turn your component into a wrapper, allowing people to pass any arbitrary HTML or components into it. </span><span class="koboSpan" id="kobo.48.2">Slots are nothing new; in fact, native HTML offers a very similar functionality that you have been using automatically without knowing it. </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.50.1"> is just a wrapper to other elements, </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">&lt;h1&gt;</span></strong><span class="koboSpan" id="kobo.52.1"> can include text but also other elements in its content, and the list can </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">go on.</span></span></p>
			<p><span class="koboSpan" id="kobo.54.1">The same functionality that a native button, heading, or span offers is also offered by </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">Vue.js slots.</span></span></p>
			<p><span class="koboSpan" id="kobo.56.1">Let’s consider how we would use a button in HTML. </span><span class="koboSpan" id="kobo.56.2">We would open the element with </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">&lt;button&gt;</span></strong><span class="koboSpan" id="kobo.58.1"> and then we would add something within its content – this could be simple text, another element, or both. </span><span class="koboSpan" id="kobo.58.2">Finally, we would close the element with </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">&lt;/button&gt;</span></strong><span class="koboSpan" id="kobo.60.1">, just </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.62.1">
&lt;button&gt;
  &lt;icon src="myIcon" /&gt;
  My button with icon
&lt;/button&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.63.1">Well, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">My button</span></strong><span class="koboSpan" id="kobo.65.1"> text and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">&lt;icon&gt;</span></strong><span class="koboSpan" id="kobo.67.1"> element displayed in the previous code snippets</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.68.1"> are what we refer to in Vue.js as </span><strong class="old"><span class="koboSpan" id="kobo.69.1">slot content</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">As previously mentioned, using properties is a great way to ensure that the values passed to the component are of a certain type, but this advantage can easily turn into a disadvantage that makes the component </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">quite rigid.</span></span></p>
			<p><span class="koboSpan" id="kobo.72.1">Let’s see how to use slots</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.73.1"> by modifying </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">TheButton.vue</span></strong><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">We are going to remove the property called value and replace it with a slot so that our button will act as a native </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">HTML button.</span></span></p>
			<p><span class="koboSpan" id="kobo.77.1">Let’s modify </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">our component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.79.1">
&lt;template&gt;
  &lt;button :class="theme"&gt;
    </span><strong class="old"><span class="koboSpan" id="kobo.80.1">&lt;slot&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.81.1">
  &lt;/button&gt;
&lt;/template&gt;
&lt;script setup&gt;
defineProps({
</span><strong class="old"><span class="koboSpan" id="kobo.82.1">  value: {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.83.1">    type: [String, Number],</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.84.1">    required: true</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.85.1">  },</span></strong><span class="koboSpan" id="kobo.86.1">
  width: {
    type: String,
    default: "100px"
  },
  theme: {
    type: String,
    default: "light",
    validator: (value) =&gt; ["light", "dark"].includes(value)
  }
})
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.87.1">First, we removed the property</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.88.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">value</span></strong><span class="koboSpan" id="kobo.90.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">defineProps</span></strong><span class="koboSpan" id="kobo.92.1"> object, and then we added a slot in our component template by adding a Vue.js element called </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">&lt;slot&gt;</span></strong><span class="koboSpan" id="kobo.94.1">. </span><span class="koboSpan" id="kobo.94.2">This element does not need to be imported as it is </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">accessible globally.</span></span></p>
			<p><span class="koboSpan" id="kobo.96.1">Now, we need to find all the occurrences of </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">TheButton</span></strong><span class="koboSpan" id="kobo.98.1"> and replace the syntax from the previous one that used the </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">property value:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
&lt;TheButton value="Example value" /&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.101.1">We need to replace this with the new one that uses </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">a slot:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
&lt;TheButton&gt;Example value&lt;/TheButton&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.104.1">The preceding change needs to happen in </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">CreatePost.vue</span></strong><span class="koboSpan" id="kobo.106.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">SocialPost.vue</span></strong><span class="koboSpan" id="kobo.108.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Sidebar.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.112.1">Slots are more than just text</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.113.1">Remember that now our component value not only accepts text, but it can also accept other HTML elements</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.114.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">Vue components.</span></span></p>
			<p><span class="koboSpan" id="kobo.116.1">Now that we know the basics of slots, let’s move on and learn about them in more detail, starting with the slot </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">default value.</span></span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.118.1">Adding default values to a slot</span></h2>
			<p><span class="koboSpan" id="kobo.119.1">Vue.js slots not only allow us to replicate</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.120.1"> native functionalities, but they also offer some extra features, one of which is the ability to add default values to our slots. </span><span class="koboSpan" id="kobo.120.2">This could either be a dialog heading or the text shown in a form submit button; default values can help you keep your </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">code clean.</span></span></p>
			<p><span class="koboSpan" id="kobo.122.1">Adding default values for your slot is very simple; all you need to do is add the value that you want directly within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">&lt;slot&gt;</span></strong><span class="koboSpan" id="kobo.124.1"> declaration. </span><span class="koboSpan" id="kobo.124.2">This value is going to be used if no other alternative is passed to the component, otherwise, it is going to be removed and overridden from the </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">slot received.</span></span></p>
			<p><span class="koboSpan" id="kobo.126.1">Let’s see a quick example to understand the declaration and usage of </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">default slots.</span></span></p>
			<p><span class="koboSpan" id="kobo.128.1">First, we are going to add a default text of </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Click Me</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.130.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">TheButton.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.133.1">
&lt;template&gt;
  &lt;button :class="theme"&gt;
    &lt;slot&gt;</span><strong class="old"><span class="koboSpan" id="kobo.134.1">Click Me</span></strong><span class="koboSpan" id="kobo.135.1">&lt;/slot&gt;
  &lt;/button&gt;
&lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.136.1">Now that we have added a default value, our button will automatically show the new text, in the case in which no content </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">is passed.</span></span></p>
			<p><span class="koboSpan" id="kobo.138.1">To see the default slot in action, we would have to call our button without any slot content, so the code would look </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
&lt;TheButton&gt;&lt;/TheButton&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.141.1">This will render our </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">default text.</span></span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<span class="koboSpan" id="kobo.143.1"><img src="image/B21130_09_01.jpg" alt="Figure 9.1: Default button with a value of “Click me”"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.144.1">Figure 9.1: Default button with a value of “Click me”</span></p>
			<p><span class="koboSpan" id="kobo.145.1">The text is there just as a fallback; in fact, adding a value within the slot will override </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">the text:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.147.1">
&lt;TheButton&gt;Show this&lt;/TheButton&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.148.1">Just as we saw before, adding text</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.149.1"> in the slot will display it, just as you would expect in a native </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">HTML element:</span></span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<span class="koboSpan" id="kobo.151.1"><img src="image/B21130_09_02.jpg" alt="Figure 9.2: Default button with a value of “Show this”"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.152.1">Figure 9.2: Default button with a value of “Show this”</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.153.1">Slot versus property</span></h2>
			<p><span class="koboSpan" id="kobo.154.1">Before we learn one more feature</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.155.1"> about slots, I want</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.156.1"> to write a few words to clarify why we need two methods (slots and properties) to achieve a very </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">similar result.</span></span></p>
			<p><span class="koboSpan" id="kobo.158.1">Slots and properties solve two different use cases, and both have advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">and disadvantages:</span></span></p>
			<ul>
				<li><strong class="old"><span class="koboSpan" id="kobo.160.1">Slots</span></strong><span class="koboSpan" id="kobo.161.1">: These are used mainly for components that require the values to be flexible. </span><span class="koboSpan" id="kobo.161.2">These are components that just provide a structure, for example, a dialog or end elements such as buttons </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">or headings.</span></span></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.163.1">Properties</span></strong><span class="koboSpan" id="kobo.164.1">: These are used for elements that require fine control of what is being passed to them. </span><span class="koboSpan" id="kobo.164.2">This could either be due to some style that would break with different content or because of the need to validate or format the </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">value received.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.166.1">We can use native HTML elements to emphasize the differences we just defined. </span><span class="koboSpan" id="kobo.166.2">In favor of slots, we have headings tags such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">&lt;h1&gt;</span></strong><span class="koboSpan" id="kobo.168.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">&lt;h2&gt;</span></strong><span class="koboSpan" id="kobo.170.1">. </span><span class="koboSpan" id="kobo.170.2">These are very generic elements that provide styles, mainly in the form of font size and spacing to its content. </span><span class="koboSpan" id="kobo.170.3">This element requires flexibility, and the use of slots is perfect for it. </span><span class="koboSpan" id="kobo.170.4">In fact, native heading elements wrap their content just </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">like slots.</span></span></p>
			<p><span class="koboSpan" id="kobo.172.1">On the other hand, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">&lt;input&gt;</span></strong><span class="koboSpan" id="kobo.174.1"> element to prove</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.175.1"> the usefulness of attribute values (properties in Vue.js). </span><span class="koboSpan" id="kobo.175.2">The input element</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.176.1"> requires a specific attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">value</span></strong><span class="koboSpan" id="kobo.178.1">. </span><span class="koboSpan" id="kobo.178.2">The value offered by the input field only accepts a string or a number as its value. </span><span class="koboSpan" id="kobo.178.3">Offering a syntax that accepts an attribute, </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">&lt;input value="text" /&gt;</span></strong><span class="koboSpan" id="kobo.180.1">, ensures that the value passed to the input field </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">is validated.</span></span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.182.1">Provide multiple slots with named slots</span></h2>
			<p><span class="koboSpan" id="kobo.183.1">As you have probably</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.184.1"> noticed, slots have lots of useful features</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.185.1"> and can be very handy for constructing complex components. </span><span class="koboSpan" id="kobo.185.2">In the previous section, we have seen how we can define a single slot, but Vue.js offers more </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">than that.</span></span></p>
			<p><span class="koboSpan" id="kobo.187.1">In fact, components in Vue.js can define more than one slot at a time. </span><span class="koboSpan" id="kobo.187.2">This is achieved using a functionality called </span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.188.1">named slots</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.190.1">A common use of named slots is to define layouts. </span><span class="koboSpan" id="kobo.190.2">You can define a layout that accepts a sidebar, main content, and footer and then allow users to pass all the content that they see fit within the individual section. </span><span class="koboSpan" id="kobo.190.3">Another good example is a main hero component that offers a heading and a subheading, or a dialog component that offers a title and </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">its content.</span></span></p>
			<p><span class="koboSpan" id="kobo.192.1">Let’s create a very basic layout for our static content. </span><span class="koboSpan" id="kobo.192.2">We are going to store our new component in a folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">templates</span></strong><span class="koboSpan" id="kobo.194.1"> and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">StaticTemplate.vue</span></strong><span class="koboSpan" id="kobo.196.1">. </span><span class="koboSpan" id="kobo.196.2">The relative URL would </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">src/components/templates/StaticTemplate.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
&lt;template&gt;
  &lt;h1&gt;&lt;/h1&gt;
  &lt;main&gt;&lt;/main&gt;
  &lt;footer&gt;&lt;/footer&gt;
&lt;/template&gt;
&lt;style scoped&gt;
h1, main, footer {
  grid-column-start: 1;
  grid-column-end: 3;
}
h1{
  align-items: center;
}
main {
  padding: 16px 32px;
}
footer {
  border-top: solid 1px lightgray;
}
&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.201.1">Our layout is going to have some basic styles that are required to create the correct spacing and show the difference between the individual sections. </span><span class="koboSpan" id="kobo.201.2">The template also includes three different sections: a heading defined with </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">&lt;h1&gt;</span></strong><span class="koboSpan" id="kobo.203.1">, the main content defined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">&lt;main&gt;</span></strong><span class="koboSpan" id="kobo.205.1"> element, and </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">finally, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">&lt;footer&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.209.1">Let’s now add the named slot</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.210.1"> to our templates. </span><span class="koboSpan" id="kobo.210.2">The syntax of the named</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.211.1"> slot is very similar to the normal slot, therefore defined using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">&lt;slot&gt;</span></strong><span class="koboSpan" id="kobo.213.1"> element, but with the addition of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">name </span></strong><span class="koboSpan" id="kobo.215.1">attribute. </span><span class="koboSpan" id="kobo.215.2">Just to emphasize the previous learning material, we are going to provide a default value for </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">the footer:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
&lt;template&gt;
  &lt;h1&gt;</span><strong class="old"><span class="koboSpan" id="kobo.218.1">&lt;slot name="heading"&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.219.1">&lt;/h1&gt;
  &lt;main&gt;</span><strong class="old"><span class="koboSpan" id="kobo.220.1">&lt;slot name="default"&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.221.1">&lt;/main&gt;
  &lt;footer&gt;
    </span><strong class="old"><span class="koboSpan" id="kobo.222.1">&lt;slot name="footer"&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.223.1">    Copyright reserved to Vue.js for beginners</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.224.1">    &lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.225.1">
  &lt;/footer&gt;
&lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.226.1">With the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">StaticTemplate.vue</span></strong><span class="koboSpan" id="kobo.228.1"> file can be called with the possibility to pass three different sections. </span><span class="koboSpan" id="kobo.228.2">Let’s go over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">AboutView.vue</span></strong><span class="koboSpan" id="kobo.230.1"> page within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Views</span></strong><span class="koboSpan" id="kobo.232.1"> folder and try to use this </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">new layout.</span></span></p>
			<p><span class="koboSpan" id="kobo.234.1">The syntax for the named slot</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.235.1"> is a little different than the default</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.236.1"> slot, as we need to define the actual name of the section that we are defining. </span><span class="koboSpan" id="kobo.236.2">To use a named slot, you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">&lt;template #</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">slotName&gt;&lt;/template&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.239.1"> syntax.</span></span></p>
			<p><span class="koboSpan" id="kobo.240.1">Let’s try to apply this to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">AboutView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1"> page:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
&lt;template&gt;
</span><strong class="old"><span class="koboSpan" id="kobo.244.1">&lt;StaticTemplate&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.245.1">  &lt;template #heading&gt;About Page&lt;/template&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.246.1">  &lt;template #default&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.247.1">    This is my content and default slot</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.248.1">  &lt;template&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.249.1">&lt;/StaticTemplate&gt;</span></strong><span class="koboSpan" id="kobo.250.1">
&lt;/template&gt;
&lt;script setup&gt;
</span><strong class="old"><span class="koboSpan" id="kobo.251.1">import StaticTemplate from '../components/templates/staticTemplate.vue'</span></strong><span class="koboSpan" id="kobo.252.1">
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.253.1">First, we imported the new component in the script section and then we used the component just like we would use </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.255.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">&lt;span&gt;</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">Last, we added content for our slot by defining a heading and default section. </span><span class="koboSpan" id="kobo.257.3">Because </span><strong class="old"><span class="koboSpan" id="kobo.258.1">About Page</span></strong><span class="koboSpan" id="kobo.259.1"> does not require the overriding of the footer, we are leaving that out of our instance so that the default value can </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">be rendered.</span></span></p>
			<p><span class="koboSpan" id="kobo.261.1">If we access </span><strong class="old"><span class="koboSpan" id="kobo.262.1">About Page</span></strong><span class="koboSpan" id="kobo.263.1"> at “</span><a href="http://localhost:5173/about"><span class="koboSpan" id="kobo.264.1">http://localhost:5173/about</span></a><span class="koboSpan" id="kobo.265.1">”, we should see </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">the following:</span></span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<span class="koboSpan" id="kobo.267.1"><img src="image/B21130_09_03.jpg" alt="Figure 9.3: About Page using the new layout"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.268.1">Figure 9.3: About Page using the new layout</span></p>
			<p><span class="koboSpan" id="kobo.269.1">The page is displaying all three sections as </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">we expected.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.271.1">The default slot does not require the &lt;template #default&gt; syntax</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.272.1">If we wanted to, we would have been able to call the default slot without the need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">&lt;template #default&gt;</span></strong><span class="koboSpan" id="kobo.274.1">, but this is not a suggested approach as it would have produced a hard-to-read code with </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">mixed methodology.</span></span></p>
			<p><span class="koboSpan" id="kobo.276.1">There is one more feature offered</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.277.1"> by Vue.js slot implementation called the </span><strong class="old"><span class="koboSpan" id="kobo.278.1">scoped slot</span></strong><span class="koboSpan" id="kobo.279.1">. </span><span class="koboSpan" id="kobo.279.2">This is a very advanced technique that allows you to define slots that expose the child’s scope to its parents. </span><span class="koboSpan" id="kobo.279.3">Due to their complexity, these are not going to be tackled within </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">this book.</span></span></p>
			<p><span class="koboSpan" id="kobo.281.1">Slots are a very powerful technique</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.282.1"> that helps us make our components</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.283.1"> easier to use, improve their readability, and offer enhanced flexibility. </span><span class="koboSpan" id="kobo.283.2">Just like every other feature, slots have their own advantages and disadvantages and should be used just when needed. </span><span class="koboSpan" id="kobo.283.3">The flexibility caused by the use of slots can produce unwanted side effects with the UI and it can be easier at times to control the layout of a component by imposing its values with the use </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">of properties.</span></span></p>
			<p><span class="koboSpan" id="kobo.285.1">In this chapter so far, we have introduced the notion of slots by comparing them with existing features available within native HTML elements, and we then learned the syntax required to define and use default slots. </span><span class="koboSpan" id="kobo.285.2">After, we compared slots and properties and tried to distinguish the different scenarios in which one method may be preferred to another. </span><span class="koboSpan" id="kobo.285.3">Last, we learned how to define default values for a slot</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.286.1"> and the possibility of defining multiple slots</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.287.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">named slot.</span></span></p>
			<p><span class="koboSpan" id="kobo.289.1">We are going to continue the chapter with another advanced topic, introducing how we can access children’s components or HTML elements with the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">Template Ref.</span></span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.291.1">Accessing components elements with Template Refs</span></h1>
			<p><span class="koboSpan" id="kobo.292.1">In this section, we are going</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.293.1"> to improve the control</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.294.1"> of our components by learning how to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">DOM element.</span></span></p>
			<p><span class="koboSpan" id="kobo.296.1">When I first started to learn about Vue.js, I was astonished by how much could be accomplished without the need to access DOM elements. </span><span class="koboSpan" id="kobo.296.2">The Vue.js engine is structured in a way that we can accomplish all basic operations with the use of props, data, methods, and </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">computed properties.</span></span></p>
			<p><span class="koboSpan" id="kobo.298.1">Just like everything else, there are times when we may need some extra control, and this can be achieved with the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Template Ref</span></strong><span class="koboSpan" id="kobo.300.1">. </span><span class="koboSpan" id="kobo.300.2">Using this feature exposes the DOM element in which the Ref was defined. </span><span class="koboSpan" id="kobo.300.3">This would be the same as using </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">querySelector</span></strong><span class="koboSpan" id="kobo.302.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">getElementById</span></strong><span class="koboSpan" id="kobo.304.1"> offered by </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">vanilla JavaScript.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.306.1">Same Refs different usage</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.307.1">You may be wondering</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.308.1"> why we are learning about Refs if we already learned about it at the start of the book to define the private properties of a component. </span><span class="koboSpan" id="kobo.308.2">Well, this Refs is different. </span><span class="koboSpan" id="kobo.308.3">It is defined with the same syntax, but it is going to hold the value of an HTML element or component instead of primitive data such as strings </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">and numbers.</span></span></p>
			<p><span class="koboSpan" id="kobo.310.1">Refs can be used for two different scenarios. </span><span class="koboSpan" id="kobo.310.2">The first is accessing a native element to access its native APIs; one such thing could be to focus an element or trigger native validation for an input field. </span><span class="koboSpan" id="kobo.310.3">The next is to access another Vue component or package to expose methods or their inner information. </span><span class="koboSpan" id="kobo.310.4">A common scenario for this is the need to set or fetch the value of a WYSIWYG  (What you see is what you get) or code editor. </span><span class="koboSpan" id="kobo.310.5">The second scenario is not common practice and should be used just in case of emergency. </span><span class="koboSpan" id="kobo.310.6">The reason why accessing a child component using Template Ref is not suggested is that it will couple the two elements together</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.311.1"> and this should always</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.312.1"> be avoided in </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">component-based architecture.</span></span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.314.1">Focus an onMounted element</span></h2>
			<p><span class="koboSpan" id="kobo.315.1">Let’s start to play with Template Refs by learning</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.316.1"> how to fetch the reference</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.317.1"> of an input field and focus it when the page loads. </span><span class="koboSpan" id="kobo.317.2">The focus feature could have been achieved with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">autofocus</span></strong><span class="koboSpan" id="kobo.319.1"> attribute, but we will develop the feature manually to showcase the use </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">of Refs.</span></span></p>
			<p><span class="koboSpan" id="kobo.321.1">We are going to work in </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">CreatePost.vue</span></strong><span class="koboSpan" id="kobo.323.1"> and autofocus the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">textarea</span></strong><span class="koboSpan" id="kobo.325.1"> used to write a </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">new post.</span></span></p>
			<p><span class="koboSpan" id="kobo.327.1">We need to make three modifications to our component. </span><span class="koboSpan" id="kobo.327.2">First, we are going to define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">ref</span></strong><span class="koboSpan" id="kobo.329.1">, just like we learned throughout this book. </span><span class="koboSpan" id="kobo.329.2">Next, we are going to assign the Template Ref to </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">textarea</span></strong><span class="koboSpan" id="kobo.331.1"> and we are going to access that element using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">onMounted</span></strong><span class="koboSpan" id="kobo.333.1"> lifecycle and focus </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">the component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.335.1">
&lt;template&gt;
  &lt;form&gt;
    &lt;h2&gt;Create a Post&lt;/h2&gt;
      &lt;textarea rows="4" cols="20" </span><strong class="old"><span class="koboSpan" id="kobo.336.1">ref="textareaRef"</span></strong><span class="koboSpan" id="kobo.337.1">&gt;
      &lt;/textarea&gt;
      &lt;TheButton&gt;Create&lt;/TheButton&gt;
  &lt;/form&gt;
&lt;/template&gt;
&lt;script setup&gt;
  </span><strong class="old"><span class="koboSpan" id="kobo.338.1">import { onMounted, ref } from 'vue';</span></strong><span class="koboSpan" id="kobo.339.1">
  import TheButton from '../atoms/TheButton.vue';
</span><strong class="old"><span class="koboSpan" id="kobo.340.1">  const textareaRef = ref(null);</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.341.1">  onMounted( () =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.342.1">    textareaRef.value.focus();</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.343.1">  });</span></strong><span class="koboSpan" id="kobo.344.1">
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.345.1">Working with Refs follows a specific order; we first create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">const textareaRef = ref(null)</span></strong><span class="koboSpan" id="kobo.347.1"> Ref and, at this point, the Ref is going to be null. </span><span class="koboSpan" id="kobo.347.2">We then assign the ref to a specific element within our component; in our scenario, we add it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">textarea</span></strong><span class="koboSpan" id="kobo.349.1">. </span><span class="koboSpan" id="kobo.349.2">The Ref is still empty because the component is not rendered, and the element does not exist on the page yet. </span><span class="koboSpan" id="kobo.349.3">Finally, we trigger our logic within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">onMounted</span></strong><span class="koboSpan" id="kobo.351.1"> lifecycle. </span><span class="koboSpan" id="kobo.351.2">Because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">onMounted</span></strong><span class="koboSpan" id="kobo.353.1"> lifecycle is triggered after the component is fully rendered, the Ref will be fully defined and ready </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">to use.</span></span></p>
			<p><span class="koboSpan" id="kobo.355.1">Before we move on, I want to focus on three more parts of the code block. </span><span class="koboSpan" id="kobo.355.2">First is a reminder that Refs in Vue.js require </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">.value</span></strong><span class="koboSpan" id="kobo.357.1"> to be appended to them to be able to access their internal value. </span><span class="koboSpan" id="kobo.357.2">This applies to both normal refs, such as strings and numbers, and Template Refs which we are covering in this section of the book. </span><span class="koboSpan" id="kobo.357.3">Second, I want to emphasize the fact a Tempalte Ref associated with an element (in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">texareaRef</span></strong><span class="koboSpan" id="kobo.359.1">) is going to be null until </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">onMounted</span></strong><span class="koboSpan" id="kobo.361.1"> is triggered. </span><span class="koboSpan" id="kobo.361.2">This means that if we ever use it in a computed property or method, we need to ensure that we check for null values to avoid errors. </span><span class="koboSpan" id="kobo.361.3">The last is about the naming convention. </span><span class="koboSpan" id="kobo.361.4">It is important for the name of the Template Ref</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.362.1"> and the one used in the HTML element</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.363.1"> to match for it to function. </span><span class="koboSpan" id="kobo.363.2">It is important for the name of the Template Ref variables (const textareaRef) and the one used in the HTML attribute (ref="textareaRef") to match for it to </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">function successfully.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.365.1">Refs are just for exceptional cases</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.366.1">Vue.js provides us with mostly</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.367.1"> everything we need out of the box, so Refs should not be overused. </span><span class="koboSpan" id="kobo.367.2">The use of Refs should be saved for specific use cases and not become the norm. </span><span class="koboSpan" id="kobo.367.3">If you find yourself using this more than a handful of times in a project, you are probably misusing other </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">Vue.js features.</span></span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.369.1">Access from native validation</span></h2>
			<p><span class="koboSpan" id="kobo.370.1">This section will focus on advanced</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.371.1"> topics; we are going to reiterate the topic we</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.372.1"> just introduced by implementing another example that uses Template Ref to access an element. </span><span class="koboSpan" id="kobo.372.2">We will continue to work on the code that handles the creation of a post by adding some validation using the native HTML validation offered by HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">form inputs.</span></span></p>
			<p><span class="koboSpan" id="kobo.374.1">We are going to continue our work in </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">CreatePost.vue</span></strong><span class="koboSpan" id="kobo.376.1">. </span><span class="koboSpan" id="kobo.376.2">First, we are going to add some specific validation within our </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">textarea&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1"> element:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
&lt;textarea
  rows="4"
  cols="20"
  ref="textareaRef"
</span><strong class="old"><span class="koboSpan" id="kobo.381.1">  required="true"</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.382.1">  minlength="10"</span></strong><span class="koboSpan" id="kobo.383.1">
&gt;&lt;/textarea&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.384.1">We made </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">textarea</span></strong><span class="koboSpan" id="kobo.386.1"> required and defined</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.387.1"> a minimum character length of </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">10</span></strong><span class="koboSpan" id="kobo.389.1">. </span><span class="koboSpan" id="kobo.389.2">Next, we are going to create a new ref, and this time, we will gain access to the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.391.1"> element within </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">the page:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
&lt;template&gt;
&lt;form </span><strong class="old"><span class="koboSpan" id="kobo.394.1">ref="createPostForm"</span></strong><span class="koboSpan" id="kobo.395.1">&gt;
   ...
</span><span class="koboSpan" id="kobo.395.2">&lt;/form&gt;
&lt;/template&gt;
&lt;script setup&gt;
import TheButton from '../atoms/TheButton.vue';
import { onMounted, ref } from 'vue';
const textareaRef = ref(null);
</span><strong class="old"><span class="koboSpan" id="kobo.396.1">const createPostForm = ref(null);</span></strong></pre>
			<p><span class="koboSpan" id="kobo.397.1">Just like in our previous example, the creation of a Ref requires two steps. </span><span class="koboSpan" id="kobo.397.2">First, we add an attribute of Ref to an element, and then we create a constant that has a name matching </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the Ref.</span></span></p>
			<p><span class="koboSpan" id="kobo.399.1">In this last step, we are going to create a method that will be called when the form is submitted and use our newly created Template Ref</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.400.1"> to access the native</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.401.1"> form </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">validation API:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
&lt;template&gt;
  &lt;form ref="createPostForm" </span><strong class="old"><span class="koboSpan" id="kobo.404.1">@submit="createPost"</span></strong><span class="koboSpan" id="kobo.405.1">&gt;
    &lt;h2&gt;Create a Post&lt;/h2&gt;
    &lt;textarea
      rows="4"
      cols="20"
      ref="textareaRef"
      required="true"
      minlength="10"
    &gt;&lt;/textarea&gt;
    &lt;TheButton&gt;Create Post&lt;/TheButton&gt;
  &lt;/form&gt;
&lt;/template&gt;
&lt;script setup&gt;
import TheButton from '../atoms/TheButton.vue';
import { onMounted, ref } from 'vue';
const textareaRef = ref(null);
const createPostForm = ref(null);
</span><strong class="old"><span class="koboSpan" id="kobo.406.1">const createPost = (event) =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.407.1">  event.preventDefault();</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.408.1">  if(createPostForm.value.reportValidity()){</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.409.1">    //code to create post</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.410.1">  };</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.411.1">}</span></strong><span class="koboSpan" id="kobo.412.1">
...</span></pre>
			<p><span class="koboSpan" id="kobo.413.1">To achieve this, we used our knowledge of events gained in </span><a href="B21130_06.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.414.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.415.1"> and triggered a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">createPost</span></strong><span class="koboSpan" id="kobo.417.1"> on form submission. </span><span class="koboSpan" id="kobo.417.2">Then, we created a method that prevented the native submit from triggering and used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">createPostForm</span></strong><span class="koboSpan" id="kobo.419.1"> Ref to check the validity of the form </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">createPostForm.value.reportValidity()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.423.1">This method will return a Boolean (so </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">true</span></strong><span class="koboSpan" id="kobo.425.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">false</span></strong><span class="koboSpan" id="kobo.427.1">) depending on whether the form is valid and it will also display the native error message on </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">the screen.</span></span></p>
			<p><span class="koboSpan" id="kobo.429.1">Let’s start our application and try to trigger the form with an </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">empty input:</span></span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<span class="koboSpan" id="kobo.431.1"><img src="image/B21130_09_04.jpg" alt="Figure 9.4: Native HTML validation error displayed on textarea"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.432.1">Figure 9.4: Native HTML validation error displayed on textarea</span></p>
			<p><span class="koboSpan" id="kobo.433.1">We are going to leave this form as it is even if it is not fully functional as the code required to submit the form will be completed in </span><a href="B21130_12.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.434.1">Chapter 12</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.435.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.436.1">In this section, we have learned that Ref is not only used to define our component values but it is also used to hold values of HTML elements. </span><span class="koboSpan" id="kobo.436.2">We have applied this newly learned technique by developing the functionality and validation needed to create new posts in </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">CreatePost.vue</span></strong><span class="koboSpan" id="kobo.438.1">. </span><span class="koboSpan" id="kobo.438.2">Finally, we iterated on the flow in which Refs are defined and how it requires the mounted</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.439.1"> state to be completed </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.440.1">for it to </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">be accessible.</span></span></p>
			<p><span class="koboSpan" id="kobo.442.1">In the next section, we will add the ability to expand and minimize the sidebar of our application and iterate through the notion of </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">the lifecycle.</span></span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.444.1">Deep diving into the lifecycle of a real app</span></h1>
			<p><span class="koboSpan" id="kobo.445.1">Lifecycles are not a new notion</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.446.1"> and have been mentioned once or twice throughout this book, but due to their importance, it is a good idea to iterate through them by adding further functionality to our </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">Companion App.</span></span></p>
			<p><span class="koboSpan" id="kobo.448.1">In this section, we are going to add new functionality that will enable us to expand and minimize the left sidebar of our application and store the value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">localStorage</span></strong><span class="koboSpan" id="kobo.450.1"> to ensure the user preferences are persistent on refresh. </span><span class="koboSpan" id="kobo.450.2">We are going to learn how having a better understanding of the lifecycle can improve the user experience provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">our application.</span></span></p>
			<p><span class="koboSpan" id="kobo.452.1">Before we jump into the code itself, let’s think about what steps would be required to achieve this new functionality. </span><span class="koboSpan" id="kobo.452.2">Thinking over a problem helps you memorize all the different aspects of the Vue.js framework that we have learned and supports you in realizing any lack of knowledge or misunderstanding that you </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">may have.</span></span></p>
			<p><span class="koboSpan" id="kobo.454.1">To complete the task of enabling the sidebar to collapse and expand, we would need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">the following:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.456.1">Add the UI required for the user to trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">this action.</span></span></li>
				<li><span class="koboSpan" id="kobo.458.1">Add some style to improve the look and feel of </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">the sidebar.</span></span></li>
				<li><span class="koboSpan" id="kobo.460.1">Create a new value that will hold the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">the sidebar.</span></span></li>
				<li><span class="koboSpan" id="kobo.462.1">Expand the sidebar to have different renderings for the </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">different states.</span></span></li>
				<li><span class="koboSpan" id="kobo.464.1">Add the logic to handle the sidebar state change and save </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">the value.</span></span></li>
				<li><span class="koboSpan" id="kobo.466.1">Finally, read the user preferences on load and apply them to </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">the component.</span></span></li>
			</ol>
			<p><span class="koboSpan" id="kobo.468.1">The list may seem very long, but these are all small tasks that you should be able to accomplish without my aid. </span><span class="koboSpan" id="kobo.468.2">Let’s start our work by working on the new </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">UI changes.</span></span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.470.1">Adding conditional rendering to the sidebar</span></h2>
			<p><span class="koboSpan" id="kobo.471.1">Let’s start by reiterating</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.472.1"> the Vue.js directive</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.473.1"> by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">v-if</span></strong><span class="koboSpan" id="kobo.475.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">v-else</span></strong><span class="koboSpan" id="kobo.477.1"> to effectively display two different views. </span><span class="koboSpan" id="kobo.477.2">One will show the expanded sidebar, while the other will display a minimal layout with just the button required to expand </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">the sidebar.</span></span></p>
			<p><span class="koboSpan" id="kobo.479.1">All the following developments will take place in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">SideBar.vue</span></strong><span class="koboSpan" id="kobo.481.1"> file that holds the logic required for our sidebar. </span><span class="koboSpan" id="kobo.481.2">Before we make changes to its layout, we are going to import two new icons, </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">IconLeftArrow</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.483.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">IconRightArrow</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
&lt;script setup&gt;
import { ref } from 'vue';
import TheButton from '../atoms/TheButton.vue'
</span><strong class="old"><span class="koboSpan" id="kobo.487.1">import IconLeftArrow from '../icons/IconLeftArrow.vue'</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.488.1">import IconRightArrow from '../icons/IconRightArrow.vue'</span></strong><span class="koboSpan" id="kobo.489.1">
...</span></pre>
			<p><span class="koboSpan" id="kobo.490.1">Next, we are going to add the two layouts using the conditional logic provided </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">v-if/v-else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
&lt;template&gt;
&lt;aside&gt;
  </span><strong class="old"><span class="koboSpan" id="kobo.495.1">&lt;template v-if=""&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.496.1">    &lt;IconRightArrow /&gt;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.497.1">  &lt;/template&gt;</span></strong><span class="koboSpan" id="kobo.498.1">
  </span><strong class="old"><span class="koboSpan" id="kobo.499.1">&lt;template v-else&gt;</span></strong><span class="koboSpan" id="kobo.500.1">
    &lt;h2&gt;Sidebar&lt;/h2&gt;
   </span><strong class="old"><span class="koboSpan" id="kobo.501.1"> &lt;IconLeftArrow /&gt;</span></strong><span class="koboSpan" id="kobo.502.1">
    &lt;TheButton&gt;Create post&lt;/TheButton&gt;
    &lt;div&gt;Current time: {{currentTime}}&lt;/div&gt;
    &lt;TheButton @click="onUpdateTimeClick"&gt;Update Time&lt;/TheButton&gt;
  </span><strong class="old"><span class="koboSpan" id="kobo.503.1">&lt;/template&gt;</span></strong><span class="koboSpan" id="kobo.504.1">
&lt;/aside&gt;
&lt;/template&gt;</span></pre>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">&lt;aside&gt;</span></strong><span class="koboSpan" id="kobo.506.1"> includes two different blocks, both delineated by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.508.1"> element. </span><span class="koboSpan" id="kobo.508.2">The first block just contains the right arrow icon and will be used to display our collapsed layout, while the other layout includes the existing code that was present in the component before we started the modification, with the addition of the left </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">arrow icon.</span></span></p>
			<p><span class="koboSpan" id="kobo.510.1">If you have looked closely</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.511.1"> at the preceding code, you may realize</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.512.1"> that something is missing, or incomplete. </span><span class="koboSpan" id="kobo.512.2">In fact, a conditional statement such as an if/else requires a hypothesis and this is currently missing in our code: </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">&lt;template </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">v-if="" &gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.516.1">For the statement to work, we need to add a condition that will be evaluated by the Vue.js compiler to display the correct layout. </span><span class="koboSpan" id="kobo.516.2">We are going to create a R</span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">ef</span></strong><span class="koboSpan" id="kobo.518.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">closed</span></strong><span class="koboSpan" id="kobo.520.1"> that will hold a Boolean value. </span><span class="koboSpan" id="kobo.520.2">This variable will be used by our if/else statement to define which layout should </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">be displayed.</span></span></p>
			<p><span class="koboSpan" id="kobo.522.1">To accomplish this, we first define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">ref </span></strong><span class="koboSpan" id="kobo.524.1">in our </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">script section:</span></span></p>
			<p><span class="koboSpan" id="kobo.526.1">&lt;</span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">script setup&gt;</span></span></p>
			<pre class="source-code">
<strong class="old"><span class="koboSpan" id="kobo.528.1">import { ref } from 'vue';</span></strong><span class="koboSpan" id="kobo.529.1">
...
</span><span class="koboSpan" id="kobo.529.2">const currentTime = ref(new Date().toLocaleTimeString());
</span><strong class="old"><span class="koboSpan" id="kobo.530.1">const closed = ref(false);</span></strong></pre>
			<p><span class="koboSpan" id="kobo.531.1">Next, we use this new variable within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">v-if</span></strong><span class="koboSpan" id="kobo.533.1"> directive that we have </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">previously defined:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.535.1">
&lt;template&gt;
&lt;aside&gt;
  &lt;template v-if="</span><strong class="old"><span class="koboSpan" id="kobo.536.1">closed</span></strong><span class="koboSpan" id="kobo.537.1">"&gt;
    &lt;IconRightArrow /&gt;
  &lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.538.1">Due to the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">closed</span></strong><span class="koboSpan" id="kobo.540.1"> being hardcoded</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.541.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">false</span></strong><span class="koboSpan" id="kobo.543.1">, the sidebar will always display</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.544.1"> the expanded layout. </span><span class="koboSpan" id="kobo.544.2">In the next section, we will write the logic required to toggle the </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">two layouts.</span></span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.546.1">Writing the logic to handle the sidebar states</span></h2>
			<p><span class="koboSpan" id="kobo.547.1">To be able to toggle between</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.548.1"> the two different views of our sidebar, we need to provide the user with the ability to change the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">closed</span></strong><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">We will use the left arrow and right arrow icons added in the previous section to trigger a click event on user input. </span><span class="koboSpan" id="kobo.550.3">The event will initiate a method that we are going to </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">toggleSidebar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.554.1">To code this, we are first going to add the event handler to the </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">two icons:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.556.1">
&lt;template v-if="closed"&gt;
  &lt;IconRightArrow </span><strong class="old"><span class="koboSpan" id="kobo.557.1">@click="toggleSidebar"</span></strong><span class="koboSpan" id="kobo.558.1"> /&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;h2&gt;Sidebar&lt;/h2&gt;
  &lt;IconLeftArrow </span><strong class="old"><span class="koboSpan" id="kobo.559.1">@click="toggleSidebar"</span></strong><span class="koboSpan" id="kobo.560.1"> /&gt;
  &lt;TheButton&gt;Create post&lt;/TheButton&gt;
...</span></pre>
			<p><span class="koboSpan" id="kobo.561.1">Then, we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">toggleSidebar</span></strong><span class="koboSpan" id="kobo.563.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.565.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">our component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
const toggleSidebar = () =&gt; {
  closed.value = !closed.value;
}</span></pre>
			<p><span class="koboSpan" id="kobo.568.1">The method accepts no argument and just redeclares the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">closed</span></strong><span class="koboSpan" id="kobo.570.1"> by making it equal to the opposite of the current value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">closed</span></strong><span class="koboSpan" id="kobo.572.1">. </span><span class="koboSpan" id="kobo.572.2">This generates a logic that toggles a Boolean value between </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">true</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.574.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.577.1">If you run the application</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.578.1"> now, you should be able to toggle between two layouts. </span><span class="koboSpan" id="kobo.578.2">The next step involves adding some styles to the collapsed layout that is currently still showing a </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">full-size sidebar.</span></span></p>
			<p><span class="koboSpan" id="kobo.580.1">Let’s add some styles to </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">our component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.582.1">
&lt;template&gt;
&lt;aside </span><strong class="old"><span class="koboSpan" id="kobo.583.1">:class="{ 'sidebar__closed': closed}"</span></strong><span class="koboSpan" id="kobo.584.1">&gt;
  &lt;template v-if="closed"&gt;
    &lt;IconRightArrow </span><strong class="old"><span class="koboSpan" id="kobo.585.1">class="sidebar__icon"</span></strong><span class="koboSpan" id="kobo.586.1"> @click="toggleSidebar" /&gt;
  &lt;/template&gt;
  &lt;template v-else&gt;
    &lt;h2&gt;Sidebar&lt;/h2&gt;
    &lt;IconLeftArrow</span><strong class="old"><span class="koboSpan" id="kobo.587.1"> class="sidebar__icon"</span></strong><span class="koboSpan" id="kobo.588.1"> @click="toggleSidebar" /&gt;
    &lt;TheButton&gt;Create post&lt;/TheButton&gt;
    &lt;div&gt;Current time: {{currentTime}}&lt;/div&gt;
    &lt;TheButton @click="onUpdateTimeClick"&gt;Update Time&lt;/TheButton&gt;
  &lt;/template&gt;
&lt;/aside&gt;
&lt;/template&gt;
&lt;script setup&gt;...&lt;/script&gt;
&lt;style scoped&gt;
aside {
  display: flex;
  flex-direction: column;
</span><strong class="old"><span class="koboSpan" id="kobo.589.1">  position: relative;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.590.1">  &amp;.sidebar__closed{</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.591.1">    width: 40px;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.592.1">  }</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.593.1">  .sidebar__icon{</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.594.1">    position: absolute;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.595.1">    right: 12px;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.596.1">    top: 22px;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.597.1">    cursor: pointer;</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.598.1">  }</span></strong><span class="koboSpan" id="kobo.599.1">
}
&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.600.1">To better style our two layouts, we declared two classes. </span><span class="koboSpan" id="kobo.600.2">The first is </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">sidebar__closed</span></strong><span class="koboSpan" id="kobo.602.1">, which is used to reduce the width of our sidebar. </span><span class="koboSpan" id="kobo.602.2">The second is </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">sidebar__icon</span></strong><span class="koboSpan" id="kobo.604.1">, which is used to define the size and position of </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">the arrows.</span></span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">sidebar__icon</span></strong><span class="koboSpan" id="kobo.607.1"> is applied to both icons, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">sidebar__closed</span></strong><span class="koboSpan" id="kobo.609.1"> is just assigned to </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">&lt;aside&gt;</span></strong><span class="koboSpan" id="kobo.611.1"> if the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">closed</span></strong><span class="koboSpan" id="kobo.613.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">true</span></strong><span class="koboSpan" id="kobo.615.1">. </span><span class="koboSpan" id="kobo.615.2">To do so, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">:class="{ 'sidebar__closed': closed}"</span></strong><span class="koboSpan" id="kobo.617.1"> syntax. </span><span class="koboSpan" id="kobo.617.2">This syntax is useful as it allows you to create complex styles with the ability to easily apply classes when a specific condition </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">is met.</span></span></p>
			<p><span class="koboSpan" id="kobo.619.1">At this stage, the sidebar not only works</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.620.1"> but it is also styled properly with a collapsed and expanded layout. </span><span class="koboSpan" id="kobo.620.2">What is left to do is to make the data </span><em class="italic"><span class="koboSpan" id="kobo.621.1">persistent</span></em><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">In development, we describe data as persistent when its value remains consistent, even after a </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">browser refresh.</span></span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<span class="koboSpan" id="kobo.624.1"><img src="image/B21130_09_05.jpg" alt="Figure 9.5: Expanded sidebar"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.625.1">Figure 9.5: Expanded sidebar</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<span class="koboSpan" id="kobo.626.1"><img src="image/B21130_09_06.jpg" alt="Figure 9.6: Collapsed sidebar"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.627.1">Figure 9.6: Collapsed sidebar</span></p>
			<p><span class="koboSpan" id="kobo.628.1">Now that the sidebar’s look</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.629.1"> has been improved, it is time to make its value persist </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">on refresh.</span></span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.631.1">Save and read the user preference in localStorage</span></h2>
			<p><span class="koboSpan" id="kobo.632.1">At this stage, even if the sidebar </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.633.1">logic is fully working, its data</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.634.1"> is not persistent yet. </span><span class="koboSpan" id="kobo.634.2">In fact, if you set the sidebar to its collapsed state and refresh the page, you will see that it will go back to the expanded view that was defined as its default state (the value that we used to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">closed</span></strong><span class="koboSpan" id="kobo.636.1"> ref </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">was </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">).</span></span></p>
			<p><span class="koboSpan" id="kobo.640.1">To enable persistence, we are going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">localStorage</span></strong><span class="koboSpan" id="kobo.642.1"> to save our value and re-read it on </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">page load.</span></span></p>
			<p><span class="koboSpan" id="kobo.644.1">Before we go through the code, we should try and define what the best method is for us to achieve this. </span><span class="koboSpan" id="kobo.644.2">In fact, this section was named after the Vue.js lifecycle, but up to this stage, we have not used </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">them yet.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.646.1">Why is the use of the correct lifecycle important?</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.647.1">Before moving forward, spend a few minutes to try and understand what the consequences </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.648.1">would be of using the incorrect lifecycle to load our data from </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">localStorage</span></strong><span class="koboSpan" id="kobo.650.1">. </span><span class="koboSpan" id="kobo.650.2">Think about the different lifecycles, when they are triggered, and what could be the effect on </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">the application.</span></span></p>
			<p><span class="koboSpan" id="kobo.652.1">As we learned in </span><a href="B21130_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.653.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.654.1">, there are different lifecycles that support different use cases. </span><span class="koboSpan" id="kobo.654.2">In our scenario, we are planning to use a lifecycle to read the value of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">closed</span></strong><span class="koboSpan" id="kobo.656.1"> variable and apply it to the component. </span><span class="koboSpan" id="kobo.656.2">When making an operation like this one, you usually should ask yourself a couple of questions. </span><span class="koboSpan" id="kobo.656.3">The first is whether the data is asynchronous, and the second is whether the data is required before the application is rendered </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">on screen.</span></span></p>
			<p><span class="koboSpan" id="kobo.658.1">Each lifecycle happens at different </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.659.1">stages of the component</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.660.1"> life. </span><span class="koboSpan" id="kobo.660.2">Some such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">beforeCreate </span></strong><span class="koboSpan" id="kobo.662.1">is triggered before the component is even created, while others trigger after a component is fully mounted within the DOM like </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">onMounted</span></strong><span class="koboSpan" id="kobo.664.1">, and it is important to select the correct one for our </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">specific scenario.</span></span></p>
			<p><span class="koboSpan" id="kobo.666.1">In our case, the data is fetched from </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">localStorage</span></strong><span class="koboSpan" id="kobo.668.1"> and is a synchronous operation; it is needed before the component is fully rendered or screened, also referred to as “</span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">before mounted.”.</span></span></p>
			<p><span class="koboSpan" id="kobo.670.1">The lifecycle that best fits our needs is </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">onBeforeMount</span></strong><span class="koboSpan" id="kobo.672.1">. </span><span class="koboSpan" id="kobo.672.2">This will trigger just before the component is rendered but after all the methods and Refs have </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">been initialized.</span></span></p>
			<p><span class="koboSpan" id="kobo.674.1">Let’s add this logic to </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">our component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.676.1">
&lt;script setup&gt;
import { ref, </span><strong class="old"><span class="koboSpan" id="kobo.677.1">onBeforeMount </span></strong><span class="koboSpan" id="kobo.678.1">} from 'vue';
import TheButton from '../atoms/TheButton.vue'
import IconLeftArrow from '../icons/IconLeftArrow.vue'
import IconRightArrow from '../icons/IconRightArrow.vue'
const currentTime = ref(new Date().toLocaleTimeString());
const closed = ref(false);
const toggleSidebar = () =&gt; {
  closed.value = !closed.value;
  </span><strong class="old"><span class="koboSpan" id="kobo.679.1">window.localStorage.setItem("sidebar", closed.value);</span></strong><span class="koboSpan" id="kobo.680.1">
}
...
</span><strong class="old"><span class="koboSpan" id="kobo.681.1">onBeforeMount( () =&gt; {</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.682.1">  const sidebarState = window.localStorage.getItem("sidebar");</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.683.1">  closed.value = sidebarState === "true";</span></strong>
<strong class="old"><span class="koboSpan" id="kobo.684.1">});</span></strong><span class="koboSpan" id="kobo.685.1">
&lt;/script&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.686.1">To achieve persistence, we first imported the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">onBeforeMount</span></strong><span class="koboSpan" id="kobo.688.1"> method from the Vue package and then we saved the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">closed</span></strong><span class="koboSpan" id="kobo.690.1"> Ref every time the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">toggleSidebar</span></strong><span class="koboSpan" id="kobo.692.1"> method was triggered. </span><span class="koboSpan" id="kobo.692.2">To achieve this, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">localStorage.setItem</span></strong><span class="koboSpan" id="kobo.694.1"> method that is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">window</span></strong><span class="koboSpan" id="kobo.696.1"> object. </span><span class="koboSpan" id="kobo.696.2">Lastly, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">onBeforeMount</span></strong><span class="koboSpan" id="kobo.698.1"> to read the value from localStorage and then assign it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">closed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1"> ref.</span></span></p>
			<p><span class="koboSpan" id="kobo.701.1">At this stage, our application will not only allow the user to toggle the sidebar, but its value will also be persistent </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">on refresh.</span></span></p>
			<p><span class="koboSpan" id="kobo.703.1">Before we complete this chapter, I want to focus on why using the correct lifecycle is important. </span><span class="koboSpan" id="kobo.703.2">In fact, if we had used another lifecycle such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">onMounted</span></strong><span class="koboSpan" id="kobo.705.1">, the sidebar would have been fully rendered (incorrectly) before the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">localStorage </span></strong><span class="koboSpan" id="kobo.707.1">would have been read and applied to the app. </span><span class="koboSpan" id="kobo.707.2">The main issue with bugs such as this one is that in development they may not reproduce or may be very hard </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">to see.</span></span></p>
			<p><span class="koboSpan" id="kobo.709.1">It is very important when creating</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.710.1"> code that is going</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.711.1"> to alter the view of the component to ensure that you have used the correct lifecycle and, if working with asynchronous data, that the correct loading is defined, or the promise awaited before the rest of the component executes. </span><span class="koboSpan" id="kobo.711.2">This practice may seem hard to comprehend at first, but code practice and mistakes will help you improve your understanding of a Vue.js component and improve </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">your skills.</span></span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.713.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.714.1">In this chapter, we have covered a couple of advanced topics such as slots, lifecycles, and refs. </span><span class="koboSpan" id="kobo.714.2">The aim of this chapter was not to provide you with all the information that you may need on these topics but to introduce you to these points so that you can practice them in your next development and continue to learn as you expand your knowledge </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">of Vue.js.</span></span></p>
			<p><span class="koboSpan" id="kobo.716.1">We have learned how to use slots to expand the flexibility of our components. </span><span class="koboSpan" id="kobo.716.2">Slots and named slots can be used for simple cases, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">&lt;button&gt;</span></strong><span class="koboSpan" id="kobo.718.1">, style elements, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.720.1">, or for more advanced techniques, such as defining a page layout with </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">different areas.</span></span></p>
			<p><span class="koboSpan" id="kobo.722.1">We then moved on to Template </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">Ref</span></strong><span class="koboSpan" id="kobo.724.1">, a topic that we had partly introduced in an earlier chapter. </span><span class="koboSpan" id="kobo.724.2">We learned how Template </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">Ref</span></strong><span class="koboSpan" id="kobo.726.1"> can be used to access a component DOM element. </span><span class="koboSpan" id="kobo.726.2">This is defined as an advanced technique because, with all the available features offered by Vue.js, it is uncommon that you would need to use Template </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">Ref</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.728.1">this way.</span></span></p>
			<p><span class="koboSpan" id="kobo.729.1">Lastly, we went over lifecycles again. </span><span class="koboSpan" id="kobo.729.2">Vue.js lifecycles are very important, and they require lots of practice to help you understand their usage and, more importantly, their order of execution. </span><span class="koboSpan" id="kobo.729.3">We have added an extra feature to our Companion App so that we can understand one of its use cases and think over the possible result that a different lifecycle would </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">have produced.</span></span></p>
			<p><span class="koboSpan" id="kobo.731.1">In the next chapter, we are going to learn how to define multiple routes with </span><strong class="old"><span class="koboSpan" id="kobo.732.1">vue-router</span></strong><span class="koboSpan" id="kobo.733.1">. </span><span class="koboSpan" id="kobo.733.2">Defining multiple pages is a required step for most applications and </span><strong class="old"><span class="koboSpan" id="kobo.734.1">vue-router </span></strong><span class="koboSpan" id="kobo.735.1">offers a very simple syntax that will help us achieve this functionality within our </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">Companion App.</span></span></p>
		</div>
	</body></html>