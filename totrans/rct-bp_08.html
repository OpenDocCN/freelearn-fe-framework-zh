<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Deploying Your App to the Cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Deploying Your App to the Cloud</h1></div></div></div><p>In this chapter, we're going to create a production pipeline for our apps. This involves splitting your configuration files for development and production as well as making a production-ready instance of your Node.js server. First we'll look at how to set up a production-ready deployment of the Browserify scaffold from <a class="link" href="ch01.html" title="Chapter 1. Diving Headfirst into ReactJS">Chapter 1</a>, <span class="emphasis"><em>Diving Headfirst Into React</em></span>, and then we'll look at how to do the same with Webpack.</p><p>Using a cloud server is the most cost-efficient way to deploy your code. Before the cloud became a viable option, you would often have to deploy your code to your physical server, situated in a single data center. If you want to deploy your code to several data centers, you'd need to purchase or rent more physical servers, often at a significant cost.</p><p>The cloud changes this because now you can deploy your code to a cloud provider who has data centers all over the world. The cost of deploying your app in the U.S. as well as in Europe and Asia is usually the same and relatively inexpensive as well.</p><p>These are the topics we'll cover in detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Choosing a cloud provider</li><li class="listitem" style="list-style-type: disc">Preparing a Browserify app for the cloud</li><li class="listitem" style="list-style-type: disc">Preparing a Webpack app for the cloud</li></ul></div><div class="section" title="Choosing a cloud provider"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Choosing a cloud provider</h1></div></div></div><p>There <a class="indexterm" id="id571"/>are a vast number of decent cloud providers available to choose from. Among the most popular and mature providers are <a class="indexterm" id="id572"/>
<span class="strong"><strong>Heroku</strong></span>, <a class="indexterm" id="id573"/>
<span class="strong"><strong>Microsoft Azure</strong></span>, <a class="indexterm" id="id574"/>
<span class="strong"><strong>Amazon</strong></span>, <a class="indexterm" id="id575"/>
<span class="strong"><strong>Google App Engine</strong></span>, and <a class="indexterm" id="id576"/>
<span class="strong"><strong>Digital Ocean</strong></span>. All of them come with their own set of advantages and disadvantages, so it's well worth investigating each one of them before you decide to choose which one to go for.</p><p>In this book, we've used Heroku throughout to deploy our apps, and we'll set up our deployments to target this platform. Let's take a brief look at the advantages and disadvantages of using Heroku.</p><p>The advantages<a class="indexterm" id="id577"/> are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easy to use. After the initial sign-up, you usually only need to issue a single Git push to deploy your code.</li><li class="listitem" style="list-style-type: disc">Easy to scale when traffic to your app increases.</li><li class="listitem" style="list-style-type: disc">Provides great plugin support for third-party apps and cloud services.</li><li class="listitem" style="list-style-type: disc">Free basic tier.</li><li class="listitem" style="list-style-type: disc">No infrastructure management.</li></ul></div><p>Now, the<a class="indexterm" id="id578"/> disadvantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Can get pricey. Heroku offers a generous free tier, but the first rung of the price ladder is pretty steep.</li><li class="listitem" style="list-style-type: disc">The vendor lock-in issue; it's a lot of work moving from Heroku to another cloud provider.</li><li class="listitem" style="list-style-type: disc">The basic tier was sufficient for a while, but recently, Heroku has added a policy that the free instance must be inactive for 6 hours every 24 hours.</li><li class="listitem" style="list-style-type: disc">The environment gets wiped irregularly. You can't log in to the instance and make local changes to the environment because they will be gone the next time the instance is refreshed.</li></ul></div><p>Because it's relatively easy<a class="indexterm" id="id579"/> to get going with Heroku, we'll be using Heroku for deployment.</p><p>Start with signing up for a <a class="indexterm" id="id580"/>free account at <a class="ulink" href="https://signup.heroku.com/">https://signup.heroku.com/</a>. After you've done this, download the Heroku toolbelt<a class="indexterm" id="id581"/> from <a class="ulink" href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</a>. You also need to upload your SSH key. If you need help in generating an <a class="indexterm" id="id582"/>SSH key, visit <a class="ulink" href="https://devcenter.heroku.com/articles/keys">https://devcenter.heroku.com/articles/keys</a>.</p><p>When the setup is done, you can create a Heroku app by issuing this command in your terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>heroku create &lt;name&gt;</strong></span>
</pre></div><p>You can omit the name, in which case Heroku will provide you with a random one. Note that Heroku requires Git. If you have a Git repository already, Heroku will automatically add the configuration parameters to your <code class="literal">.git/config</code> file. If not, you will have to do it manually later. The parameters look like this:</p><div class="informalexample"><pre class="programlisting">[remote "heroku"]
  url = https://git.heroku.com/<span class="emphasis"><em>&lt;name&gt;</em></span>.git
  fetch = +refs/heads/*:refs/remotes/heroku/*</pre></div><p>You can find the configuration file inside the <code class="literal">.git</code> folder (note the dot). The file is called <code class="literal">config</code>, so the full path is <code class="literal">.git/config</code>.</p><p>To deploy your app, add the<a class="indexterm" id="id583"/> files to your repository and commit your changes. Then, issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git push heroku master</strong></span>
</pre></div><p>Your app will then be deployed, based on the master branch. You can deploy other branches by typing in <code class="literal">git push heroku yourbranch:master</code> instead.</p></div></div>
<div class="section" title="Setting up cloud deployment with npm"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Setting up cloud deployment with npm</h1></div></div></div><p>If we try to<a class="indexterm" id="id584"/> publish our scaffold right off the bat, we'll <a class="indexterm" id="id585"/>probably end up with an error because we haven't told Heroku how to serve our app. Heroku will simply try running the app with <code class="literal">npm start</code>.</p><p>The <code class="literal">npm</code> package is the backbone of Node.js. We've covered it briefly in previous chapters, but as we're going to depend heavily on it now, it's time to take a closer look at what it can do for you.</p><p>You may have heard of or even used task runners such as<a class="indexterm" id="id586"/> <span class="strong"><strong>Grunt</strong></span>, <a class="indexterm" id="id587"/>
<span class="strong"><strong>Gulp</strong></span>, or<a class="indexterm" id="id588"/> <span class="strong"><strong>Broccoli</strong></span>. They are great at automating tasks so that you can focus on writing code rather than performing repetitive tasks, such as minifying and bundling your code, copying and concatenating stylesheets, and so on.</p><p>Yet, for most tasks, you're better off letting <code class="literal">npm</code> do the job for you. With <code class="literal">npm</code> scripts, you have all the power you need to automate common tasks, with less overhead and maintenance to boot.</p><p>The <code class="literal">npm</code> package comes with a few built-in commands, one of which is <code class="literal">npm run-script</code> (<code class="literal">npm run</code> for short). This command extracts the scripts object from <code class="literal">package.json</code>. The first argument passed to <code class="literal">npm run</code> refers to a property in the scripts object. For any property you create yourself, you need to run them with <code class="literal">npm run</code>. A few property names have been reserved, such as <code class="literal">start</code>, <code class="literal">stop</code>, <code class="literal">restart</code>,
<code class="literal">install</code>, <code class="literal">publish</code>, <code class="literal">test</code>, and so on. They can be invoked by simply executing <code class="literal">npm start</code> and so on.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>An important thing to note is that <code class="literal">npm run foo</code> will also run <code class="literal">prefoo</code> and <code class="literal">postfoo</code> if defined. You can run each stage separately by executing <code class="literal">npm run prefoo</code> or <code class="literal">postfoo</code>.</p></div></div><p>Execute <code class="literal">npm run</code> to <a class="indexterm" id="id589"/>see the available scripts; you'll see the<a class="indexterm" id="id590"/> following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Lifecycle scripts included in webpack-scaffold:</strong></span>
<span class="strong"><strong>  test</strong></span>
<span class="strong"><strong>    echo "Error: no test specified" &amp;&amp; exit 1</strong></span>
<span class="strong"><strong>  start</strong></span>
<span class="strong"><strong>    node server.js</strong></span>
</pre></div><p>This is interesting. We haven't made a start script, yet <code class="literal">npm</code> <code class="literal">run</code> tells us that <code class="literal">npm start</code> will run <code class="literal">node server.js</code>. This is another default of node. If you haven't specified a start script and there is a <code class="literal">server.js</code> file in your root, then this will be executed.</p><p>Heroku still won't run the scaffold because the express server is configured to start a develop session with Webpack and hot reloading. You need to create a production server in addition to your develop server.</p><p>You can approach this in one of two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One option is to introduce <code class="literal">environment</code> flags in your server code, such as this:<div class="informalexample"><pre class="programlisting">if(process.env.NODE_ENV !== "development"){
  // production server code
}</pre></div></li><li class="listitem" style="list-style-type: disc">The other option is to create an independent production <code class="literal">server</code> file</li></ul></div><p>Either way is good, but it's arguably cleaner to use a separate file, so we'll go with that approach.</p></div>
<div class="section" title="Preparing your Browserify app for cloud deployment"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Preparing your Browserify app for cloud deployment</h1></div></div></div><p>In this section, we'll <a class="indexterm" id="id591"/>use the shop application we <a class="indexterm" id="id592"/>developed in <a class="link" href="ch02.html" title="Chapter 2. Creating a Web Shop">Chapter 2</a>, <span class="emphasis"><em>Creating a Web Shop</em></span>. The app uses Browserify to bundle the code and node to run the development server. We'll keep on using the node in production, but we'll need to set up a specific <code class="literal">server</code> file in order to make a production-ready app.</p><p>As a reminder, this is how our shop app looks like before we start:</p><div class="informalexample"><pre class="programlisting">├── package.json
├── public
│   ├── app.css
│   ├── bundle.js
│   ├── heroku.js
│   ├── index.html
│   └── products.json
├── server.js
└── source
    ├── actions
    │   ├── cart.js
    │   ├── customer.js
    │   └── products.js
    ├── app.jsx
    ├── components
    │   ├── customerdata.jsx
    │   ├── footer.jsx
    │   └── menu.jsx
    ├── layout.jsx
    ├── pages
    │   ├── checkout.jsx
    │   ├── company.jsx
    │   ├── home.jsx
    │   ├── item.jsx
    │   ├── products.jsx
    │   └── receipt.jsx
    ├── routes.jsx
    └── stores
        ├── cart.js
        ├── customer.js
        └── products.js</pre></div><p>We'll take these<a class="indexterm" id="id593"/> steps to<a class="indexterm" id="id594"/> make it cloud-ready:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a production server file</li><li class="listitem" style="list-style-type: disc">Install production dependencies</li><li class="listitem" style="list-style-type: disc">Modify <code class="literal">package.json</code></li><li class="listitem" style="list-style-type: disc">Transpile our code base to EcmaScript 5</li></ul></div><div class="section" title="The actual process"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec82"/>The actual process</h2></div></div></div><p>Create a new file called <code class="literal">server.prod.js</code> and put it in the root of your project. Add this code to it:</p><div class="informalexample"><pre class="programlisting">var express = require("express");
var app = express();
var port = process.env.PORT || 8080;
var host = process.env.HOST || '0.0.0.0';</pre></div><p>We're defining an express server and setting up a host and a <code class="literal">port</code> variable. The defaults are port <code class="literal">8080</code> on <code class="literal">0.0.0.0</code>. This host address is functionally identical to localhost when running on your local machine, but it can make a difference when running on your server. If the server host has several IP addresses, specifying <code class="literal">0.0.0.0</code> as the host will match any request. Using a parameter such as localhost can result in a situation where the server will be unable to bind your app and fail to start:</p><div class="informalexample"><pre class="programlisting">var path = require("path");
var compression = require("compression");
app.use(compression());</pre></div><p>Since we're going to be serving files to the public, it's worth compressing them with <span class="strong"><strong>GZIP</strong></span><a class="indexterm" id="id595"/> before serving them. For text and script files, the savings can be dramatic, up to 80-90 percent in many <a class="indexterm" id="id596"/>cases. For a low-traffic site, this <a class="indexterm" id="id597"/>implementation is good enough. For a high-traffic site, the best way to put compression in place is to implement it at a reverse proxy level, for instance, by using <span class="strong"><strong>nginx</strong></span>. We'll route all requests to our <code class="literal">public</code> folder and the desired filename:</p><div class="informalexample"><pre class="programlisting">app.get("*", function (req, res) {
  var file = path.join(__dirname, "public", req.path);
  res.sendFile(file);
});</pre></div><p>Finally, the server will start with a debug message telling us the address of the deployed app:</p><div class="informalexample"><pre class="programlisting">app.listen(port, host, function (err) {
  console.log('Server started on http://'+host+':'+port)
});</pre></div><p>The next thing we need to do is create a <code class="literal">build</code> script to bundle our JavaScript code. When running the development server, the code is bundled automatically. This bundle is usually rather large. For instance, the development bundle for the shop app is 1.4 MB. Even with compression enabled, this file is arguably too large to present to your users. When deploying to production, we need to create a smaller bundle so that your app will download and be ready to use faster. Fortunately, this is rather easy.</p><p>We're going to use a combination of the CLI version of Browserify and UglifyJS. The latter is a compression tool that strips out newlines, shortens variable names, and strips out unused code from our bundle. We'll run it by first bundling our source files with Browserify, then we'll use the pipe operator (<code class="literal">|</code>) to send the output to UglifyJS. The result of this operation is then sent to a <code class="literal">bundle</code> file with the greater-than operator (<code class="literal">&gt;</code>).</p><p>The first part of the sequence looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./node_modules/.bin/browserify --extension=.jsx source/app.jsx -t [ babelify ]</strong></span>
</pre></div><p>When you run this, the entire bundle will be returned as a string output. You can optionally specify <code class="literal">-o bundle.js</code> in order to save the result to a bundle file. We don't want to do this because we have no use for a temporary bundle.</p><p>The second part of the sequence looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./node_modules/.bin/uglifyjs -p 5 -c drop_console=true -m --max-line-len --inline-script</strong></span>
</pre></div><p>We have specified a few arguments, so let's look at what they do.</p><p>The <code class="literal">-p</code> argument skips the prefix for the original filenames that appear in the source name. The saving here is very small, but it's worth keeping in there nonetheless. The number after the argument is the number of relative paths dropped.</p><p>The <code class="literal">-c</code> option is<a class="indexterm" id="id598"/> short for compressor. By not<a class="indexterm" id="id599"/> specifying any compressor option, the default compress option will be used. This saves quite a few bytes.</p><p>The next is <code class="literal">drop_console=true</code>. This tells UglifyJS to remove any console logs. This is useful if you've used this method for debugging your app and have forgotten to remove it from your code.</p><p>The next one is <code class="literal">-m</code>, which is short for mangle. This option changes and shortens your variable and function names and is a serious byte-saving factor.</p><p>The final two arguments won't save any bytes, but they're still useful. The <code class="literal">--max-line-len</code> argument will break up the uglified code if the line length is above a given value (defaults to 32,000 characters). This is useful when supporting older browsers that can't cope with very long lines. The <code class="literal">––inline-script</code> argument escapes the slash in the occurrences of <code class="literal">&lt;/script</code> in strings.</p><p>Running this command on its own won't result in a compressed bundle because we haven't specified an input. If you store the bundle in a temporary file, you could send the content to the preceding command by using the less-than operator and the filename like this: <code class="literal">&lt; bundle.js</code>.</p><p>Finally, we'll send the result to the output location we desire by using the greater-than operator.</p><p>The full command sequence looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>NODE_ENV=production browserify --extension=.jsx source/app.jsx -t [ babelify ] | ./node_modules/.bin/uglifyjs  -p 5 -c drop_console=true -m --max-line-len --inline-script &gt; public/bundle.js</strong></span>
</pre></div><p>Running the first part results in a bundle size that's approximately 1.4 MB. Passing it through UglifyJS results in a bundle size of about 548 KB. If you drop the options and go with vanilla UglifyJS, you'll end up with a bundle size that's about 871 KB.</p><p>After bundling and minifying, we're now ready to deploy our app to the cloud. Since we're using compression, the final bundle size will be approximately 130 KB. That's a huge win when compared to the original file size of 1.4 MB.</p><p>Before we deploy our code, we need to tell Heroku how to start our app. We'll do this by adding a single file called <code class="literal">Procfile</code>. This is a special file that Heroku will read and execute if it exists. If it doesn't exist, Heroku will try to execute <code class="literal">npm start</code> instead; if this fails, try to run <code class="literal">node server.js</code>.</p><p>Add the <code class="literal">Procfile</code> file with this content:</p><div class="informalexample"><pre class="programlisting">web: node server.prod.js</pre></div><p>When you've done this, commit your code and push to Heroku by executing this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git push heroku master</strong></span>
</pre></div><p>The end result <a class="indexterm" id="id600"/>should look identical to the <a class="indexterm" id="id601"/>local app, except that now you're running it on the cloud. The example app is available on <a class="ulink" href="https://reactjsblueprints-webshop.herokuapp.com/">https://reactjsblueprints-webshop.herokuapp.com/</a>. The following screenshot displays the web page of the preceding link:</p><div class="mediaobject"><img alt="The actual process" src="graphics/B04943_08_01.jpg"/></div><p>It's very tough to remember the entire command sequence for generating a minified Browserify bundle. We'll add it to <code class="literal">package.json</code> so we can execute it with ease.</p><p>Open <code class="literal">package.json</code> and replace the contents in the <code class="literal">scripts</code> section with this code:</p><div class="informalexample"><pre class="programlisting">"scripts": {
  "bundle": "browserify --extension=.jsx source/app.jsx -t [ babelify ] | ./node_modules/.bin/uglifyjs  -p 5 -c drop_console=true -m --max-line-len --inline-script &gt; public/bundle.js",
  "start": "node server.js"
},</pre></div><p>Now you can run<a class="indexterm" id="id602"/> the bundle operation<a class="indexterm" id="id603"/> with <code class="literal">npm run bundle</code>.</p></div></div>
<div class="section" title="Deploying a Webpack app to the cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Deploying a Webpack app to the cloud</h1></div></div></div><p>In this section, we'll use the<a class="indexterm" id="id604"/> Webpack scaffold we developed <a class="indexterm" id="id605"/>in <a class="link" href="ch06.html" title="Chapter 6. Advanced React">Chapter 6</a>, <span class="emphasis"><em>Advanced React</em></span>. We'll need to add a few packages and make some modifications.</p><p>As a reminder, this is the file structure of our scaffold before we start:</p><div class="informalexample"><pre class="programlisting">├── assets
│   ├── app.css
│   ├── favicon.ico
│   └── index.html
├── package.json
├── server.js
├── source
│   └── index.jsx
└── webpack.config.js</pre></div><p>Let's start by renaming our <code class="literal">server.js</code> file to <code class="literal">server-development.js</code>. Then, create a new file called <code class="literal">server-production.js</code> in the root of the scaffold and add this code:</p><div class="informalexample"><pre class="programlisting">'use strict';

var path = require('path');
var express = require('express');
var serveStatic = require('serve-static')
var compression = require('compression')
var port = process.env.PORT || 8080;
var host = process.env.HOST || '0.0.0.0';</pre></div><p>Here, we instruct the server to use the preconfigured variables for <code class="literal">PORT</code> and <code class="literal">HOST</code> or the default variables if these aren't provided, just as we did with the Browserify server. Then, we add an error handler so that we are able to respond to errors gracefully. This could also be added to the Browserify server:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
var errorHandler = require('express-error-handler');</pre></div><p>We add compression as well:</p><div class="informalexample"><pre class="programlisting">var app = express();
app.use(compression());</pre></div><p>Now we move on to the <code class="literal">assets</code> file:</p><div class="informalexample"><pre class="programlisting">var cpFile = require('cp-file');
cpFile('assets/index.prod.html', 'public/assets/index.html').then(function() {
  console.log('Copied index.html');
});
cpFile('assets/app.css', 'public/assets/app.css').then(function() {
  console.log('Copied app.css');
});</pre></div><p>We'll copy the <code class="literal">asset</code> files we need manually. We only have two, so it's okay to do this manually. If we had many files to copy, another approach might be more beneficial. An option that is cross-compatible across different environments is <a class="indexterm" id="id606"/>
<span class="strong"><strong>ShellJS</strong></span>. With this extension, you can set up ordinary <code class="literal">shell</code> commands and have them executed in a JavaScript environment. We won't do this in this project but it's worth looking into. Now refer to the following lines of code:</p><div class="informalexample"><pre class="programlisting">var envs = require('envs');
app.set('environment', envs('NODE_ENV', 'production')); 
app.use(serveStatic(path.join(__dirname, 'public', 'assets')));</pre></div><p>Here, we set the <code class="literal">environment</code> to <code class="literal">production</code>, and we let Express know that our static files are placed in the <code class="literal">./public/assets</code> folder using the <code class="literal">serve-static</code> middleware. This means we can refer to <code class="literal">/app.css</code> in our file, and Express will know to look for it in the correct <code class="literal">assets</code> folder. For low-traffic apps, this is a good implementation, but for a high-traffic app, it's better to use a reverse proxy to serve static files. The main benefit of using a reverse proxy is to remove load from your dynamic server to other servers specially designed to handle assets. We route all requests to <code class="literal">index.html</code>. This will not apply to files that exist in the <code class="literal">static</code> folder:</p><div class="informalexample"><pre class="programlisting">var routes = function (app) {
  app.get('*', function(req, res) {
    res.sendFile(path.join(__dirname, 'public', 'assets','index.html'));
  });
}</pre></div><p>We create the <code class="literal">server</code> <a class="indexterm" id="id607"/>object so that we can pass it to the error<a class="indexterm" id="id608"/> handler:</p><div class="informalexample"><pre class="programlisting">var router = express.Router();
routes(router);
app.use(router);

Var server = http.createServer(app);</pre></div><p>Here, we respond to errors and conditionally shut down the server. The <code class="literal">server</code> object is passed as an argument so that the error handler can shut it down gracefully:</p><div class="informalexample"><pre class="programlisting">app.use(function (err, req, res, next) {
  console.log(err);
  next(err);
});

app.use( errorHandler({server: server}) );</pre></div><p>Finally, we start the app:</p><div class="informalexample"><pre class="programlisting">app.listen(port, host, function() {
  console.log('Server started at http://'+host+':'+port);
});</pre></div><p>As you've noticed, we've<a class="indexterm" id="id609"/> added a few new packages. Install these with this<a class="indexterm" id="id610"/> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install --save compression@1.6.1 envs@0.1.6 express-error-handler@1.0.1 serve-static@1.10.2 cp-file@3.1.0 rimraf@2.5.1</strong></span>
</pre></div><p>All modules that are required in <code class="literal">server.prod.js</code> need to be moved to the <code class="literal">dependencies</code> section in <code class="literal">package.json</code>. Your dependencies section should now look like this:</p><div class="informalexample"><pre class="programlisting">"devDependencies": {
  "react-transform-catch-errors": "^1.0.1",
  "react-transform-hmr": "^1.0.1",
  "redbox-react": "^1.2.0",
  "webpack-dev-middleware": "^1.4.0",
  "webpack-hot-middleware": "^2.6.0",
  "babel-core": "^6.3.26",
  "babel-loader": "^6.2.0",
  "babel-plugin-react-transform": "^2.0.0",
  "babel-preset-es2015": "^6.3.13",
  "babel-preset-react": "^6.3.13",
  "babelify": "^7.3.0",
  "uglifyjs": "^2.4.10",
  "webpack": "^1.12.9",
  "rimraf": "^2.5.1",
  "react": "^15.1.0",
  "react-dom": "^15.1.0"
},
"dependencies": {
  "compression": "^1.6.1",
  "cp-file": "^3.1.0",
  "envs": "^0.1.6",
  "express": "^4.13.3",
  "express-error-handler": "^1.0.1",
  "path": "^0.12.7",
  "serve-static": "^1.10.2"
}</pre></div><p>All dependencies that Heroku needs must be put in the normal dependencies section because Heroku will omit all packages in <code class="literal">devDependencies</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>
<span class="strong"><strong>Dependency strategy for cloud deployment</strong></span>
</p><p>Since downloading and <a class="indexterm" id="id611"/>installing packages from <code class="literal">npm</code> is rather slow, it's a good practice to put packages you only need when developing in <code class="literal">devDependencies</code> and vice-versa. We've been doing this throughout the entire book, so hopefully you're already following this pattern.</p></div></div><p>We're almost done, but we need to create a production version of <code class="literal">webpack.config.js</code>, <code class="literal">index.html</code> and add the build scripts before we're ready.</p><p>Rename your existing <code class="literal">webpack.config.js</code> file to <code class="literal">Webpack-development.config.js</code>, and then create a file called <code class="literal">Webpack-production.config.js</code>. Note that this means you need to change the Webpack import in <code class="literal">server-development.js</code> to reflect this change.</p><p>Add the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';

var path = require('path');
var webpack = require('webpack');

module.exports = {
  entry: [
    './source/index'
  ],
  output: {
    path: path.join(__dirname, 'public', 'assets'),
    filename: 'bundle.js',
    publicPath: '/assets/'
  },
  plugins: [
    new webpack.optimize.OccurenceOrderPlugin(),</pre></div><p>This plugin reorders the <a class="indexterm" id="id612"/>packages so that the most used one is put at the<a class="indexterm" id="id613"/> top. This should reduce the file size and make the bundle more efficient. We specify that this is a production build so that Webpack utilizes the most byte-saving algorithm it has:</p><div class="informalexample"><pre class="programlisting">    new webpack.DefinePlugin({
      'process.env': {
        'NODE_ENV': JSON.stringify('production')
      }
    }),</pre></div><p>We'll also tell it to use UglifyJS to compress our code:</p><div class="informalexample"><pre class="programlisting">    new webpack.optimize.UglifyJsPlugin({
      compressor: {
        warnings: false
      }
    })</pre></div><p>From the <code class="literal">production</code> configuration of Webpack, we remove the hot loader plugin since it only makes sense to have it included when developing:</p><div class="informalexample"><pre class="programlisting">  ],
  module: {
    loaders: [{
      tests: /\.js?$/,
      loaders: ['babel'],
      include: path.join(__dirname, 'source')
    }]
  },
  resolve: {
    extensions: ['', '.js', '.jsx']
  }
};</pre></div><p>Next, add a file called <code class="literal">index-production.html</code> to <code class="literal">assets</code> and add this code:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ReactJS + Webpack Scaffold&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, 
    initial-scale=1"&gt;
    &lt;link rel="stylesheet" href="/app.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script src="/bundle.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Finally, add these <a class="indexterm" id="id614"/>scripts<a class="indexterm" id="id615"/> to <code class="literal">package.json</code>:</p><div class="informalexample"><pre class="programlisting">"scripts": {
  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
  "prestart": "npm run build",
  "start": "node server-production.js",
  "dev": "node server-development.js",
  "prebuild": "rimraf public",
  "build": "NODE_ENV=production webpack --config Webpack-production.config.js",
  "predeploy": "npm run build",
  "deploy": "echo Ready to deploy. Commit your changes and run git push heroku master"
},</pre></div><p>These scripts let you build and deploy your app. We've stopped short from actually committing the changes to let you know that the deploy process is ready to commence.</p><p>Note that in the build argument, we add <code class="literal">NODE_ENV=production</code> in order to prevent Babel from trying to use the <code class="literal">hot</code> module replacement when building the code. The configuration that controls this is in <code class="literal">.babelrc</code>.</p><p>Your Webpack scaffold is now production-ready!</p><p>When developing, execute <code class="literal">npm run dev</code> and enjoy a slick development environment with hot reloading.</p><p>On <code class="literal">npm deploy</code>, the build script is executed and it lets you know when it's ready to publish your changes. You need to add the changes yourself via <code class="literal">git add</code> and <code class="literal">git commit</code> and then run <code class="literal">git push heroku master</code>. You can, of course, automate this in the deploy script.</p><p>The build script can also be triggered by issuing <code class="literal">npm run build</code>. Before building the script, we will first execute <code class="literal">rimraf public</code>. <span class="strong"><strong>Rimraf</strong></span><a class="indexterm" id="id616"/> is an environment-safe command that deletes the <code class="literal">public</code> folder and all its contents. It's the same as running <code class="literal">rm -rf public</code> on Mac/Linux. This command doesn't exist on Windows, so running <code class="literal">rm</code> on that platform won't work, but running <code class="literal">rimraf</code> will work on either platform. Finally, the script executes <code class="literal">webpack</code> and builds a production bundle that is put in <code class="literal">public/assets/bundle.js</code>.</p><p>In general, Webpack <a class="indexterm" id="id617"/>is slightly more efficient at removing unused <a class="indexterm" id="id618"/>code, so the final bundle sizes will be smaller than the ones generated by Browserify. The bundle generated in this example is about 132 KB.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>Note that this is not an apples-to-apples comparison because the app we bundled in the Browserify section was much larger.</p></div></div><p>The final result is available at <a class="ulink" href="https://reactjsblueprints-wpdeploy.herokuapp.com/">https://reactjsblueprints-wpdeploy.herokuapp.com/</a>.</p><div class="mediaobject"><img alt="Deploying a Webpack app to the cloud" src="graphics/B04943_08_02.jpg"/></div><p>For reference, our file structure now looks like this:</p><div class="informalexample"><pre class="programlisting">├── .babelrc
├── assets
│   ├── app.css
│   ├── favicon.ico
│   ├── index.html
│   └── index-production.html
├── package.json
├── server-development.js
├── server-production.js
├── source
│   └── index.jsx
├── Webpack-development.config.js
└── Webpack-production.config.js</pre></div><p>It's still quite<a class="indexterm" id="id619"/> manageable. Admittedly, separating the <a class="indexterm" id="id620"/>files in <code class="literal">prod</code> and <code class="literal">dev</code> requires a bit more handholding, but it's arguably better than switching the code with <code class="literal">if…else</code> loops inside different files. However, code <a class="indexterm" id="id621"/>organization is admittedly a thorny <a class="indexterm" id="id622"/>issue, and there is no general setup that will please everyone. For small modifications spanning just a few files, <code class="literal">if…else</code> statements are probably preferable to break up the files in production and development versions.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we added cloud deployment to the two scaffolds we developed throughout this book. A preview of both examples are available online.</p><p>Generating cloud-deployable apps generally means bundling our code as tight as possible. With the era of HTTP/2 upon us, this strategy may have to be revisited as it may be more beneficial to generate a set of files that can be downloaded in parallel instead of a single bundle, however small it may be. It's worth noting that very small files won't benefit much from <span class="emphasis"><em>gzipping</em></span>.</p><p>It's also possible to split your code bundles with Webpack. For more on code splitting with Webpack, take a look at <a class="ulink" href="https://webpack.github.io/docs/code-splitting.html">https://webpack.github.io/docs/code-splitting.html</a>.</p><p>In the next chapter, we'll develop a streaming server-rendered app based on the production Webpack setup we just made in this chapter.</p></div></body></html>