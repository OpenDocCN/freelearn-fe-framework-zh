- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Splitting Using Lazy Components and Suspense
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code splitting** has been a significant part of React applications for many
    years, even before official support was included in the **React API**. The evolution
    of React has brought about APIs that are specifically designed to assist in code-splitting
    scenarios. Code splitting becomes crucial when dealing with large applications
    containing a vast amount of JavaScript code that needs to be delivered to a browser.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In the past, **monolithic JavaScript bundles** containing an entire application
    could cause usability issues due to long initial page load times. Thanks to code
    splitting, we now have much more granular control over how code is transferred
    from the server to the browser. This gives us ample opportunities to optimize
    load-time **User Experience** (**UX**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will revisit how to implement this in your React applications
    by using the `lazy()` API and the `Suspense` components. These features are very
    powerful tools in the React toolbox. By gaining a thorough understanding of how
    these components function, you’ll be fully equipped to seamlessly integrate code
    splitting into your applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Using the `lazy()` API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Suspense` component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding **lazy components**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring **lazy pages** and **routes**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files of this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter08](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Using the lazy API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two pieces involved with using the `lazy()` API in React. First,
    there’s bundling components into their own separate files so that they can be
    downloaded by the browser separately from other parts of the application. Second,
    once you have created the bundles, you can build React components that are lazy:
    they don’t download anything until they are needed. Let’s look at both of these.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic imports and bundles
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code examples in this book use the **Vite** tooling for creating bundles.
    The nice thing about this approach is that you don’t have to maintain any bundle
    configuration. Instead, bundles are created for you automatically, based on how
    you import your modules. If you’re using the plain `import` statement (not to
    be confused with the `import` method) everywhere, your app will be downloaded
    all at once in one bundle. When your app gets bigger, there will likely be features
    that some users never use or don’t use as frequently as others. You can use the
    `import()` function to import modules on demand. By using this function, you’re
    telling Vite to create a separate bundle for the code that you’re importing dynamically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple component that we might want to bundle separately from
    the rest of the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s take a look at how we would import this module dynamically using
    the `import()` function, resulting in a separate bundle:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run this example, you’ll see the `<p>` text rendered right away. If
    you open the browser dev tools and look at the network requests, you’ll notice
    that a separate call is made to fetch the bundle containing the `MyComponent`
    code. This happens because of the call to `import("./MyComponent")`. The `import()`
    function returns a promise that resolves with the module object. Since we need
    the default export to access `MyComponent`, we reference `module.default` when
    we call `setMyComponent()`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we’re setting a component as the `MyComponent` state is that
    when the `App` component renders for the first time, we don’t have the `MyComponent`
    code loaded yet. Once it loads, `MyComponent` will reference the proper value,
    which results in the correct text being rendered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of how bundles get created and are fetched by the
    app, it’s time to see how the `lazy()` API greatly simplifies this process for
    us.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Making components lazy
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of manually handling the promise returned by `import()` by returning
    the default export and setting state, you can lean on the `lazy()` API. This function
    takes a function that returns an `import()` promise. The return value is a lazy
    component that you can just render. Let’s modify the `App` component to use this
    API:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `MyComponent` value is created by calling `lazy()`, passing in the dynamic
    module import as an argument. Now, you have a separate bundle for your component
    and a lazy component that loads the bundle when it’s first rendered.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how code splitting works. You learned that the
    `import()` function handles bundle creation for you. You also learned that the
    `lazy()` API makes your components lazy and handles all of the gritty work of
    importing components for you. But there’s one last thing we need, the `Suspense`
    component, to help display placeholders while components are loading.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Using the Suspense component
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore some of the more common usage scenarios of the
    `Suspense` component. We’ll look at where to place `Suspense` components in your
    component tree, how to simulate latency when fetching bundles, and some of the
    options available to us to use as the fallback content.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Top-level Suspense components
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Lazy components** need to be rendered inside of a `Suspense` component. However,
    they do not have to be direct children of `Suspense` though, which is important
    because this means that you can have one `Suspense` component handle every lazy
    component in your app. Let’s illustrate this concept with an example. Here’s a
    component that we would like to bundle separately and use lazily:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let’s make the `MyFeature` component lazy and render it inside of a `MyPage`
    component:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we’re using the `lazy()` API to make the `MyFeature` component lazy.
    This means that when the `MyPage` component is rendered, the code bundle that
    contains `MyFeature` will be downloaded because `MyFeature` was also rendered.
    What’s important to note with the `MyPage` component is that it is rendering a
    lazy component (`MyFeature`) but isn’t rendering a `Suspense` component. This
    is because our hypothetical app has many page components, each with its own lazy
    components. Having each of these components render its own `Suspense` component
    would be redundant. Instead, we can render one `Suspense` component inside of
    our `App` component, like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the `MyFeature` code bundle is being downloaded, `<MyPage>` is replaced
    with the fallback text passed to `Suspense`. So, even though `MyPage` isn’t lazy
    itself, it renders a lazy component that `Suspense` knows about and will replace
    its children with the fallback content while this happens.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we haven’t really been able to see the fallback content that displays
    while our lazy components load their code bundles. This is because when developing
    locally, these bundles load almost instantly. To be able to see fallback component
    and loading process, you can enable throttling in **Network** tab of the dev tools:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_08_01.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Enabling throttling in the browser'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: This setting emulates a slow internet connection. Instead of loading instantly,
    the page will be rendering for a few seconds and you will see a **loading …**
    fallback.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at an approach to use loading spinners as a
    fallback component.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Working with spinner fallbacks
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest fallback that you can use with the `Suspense` component is some
    text that indicates to the user that something is happening. The fallback property
    can be any valid React element, which means that we can enhance the fallback to
    be something more visually appealing. For example, the `react-spinners` package
    has a selection of `spinner` components, all of which can be used as a fallback
    with `Suspense`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `App` component from the last section to include a `spinner`
    from the `react-spinners` package as the `Suspense` fallback:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `FadeLoader` component will render a `spinner` that we’ve configured with
    a color value of `lightblue`. The rendered element of the `FadeLoader` component
    is passed to the `fallback` property. With the Slow 3G throttling, you should
    be able to see the `spinner` when you first load the app:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_08_02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: The image rendered by the loader component'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of text, we’re showing an animated `spinner`. This likely provides
    a user experience that your users are more accustomed to. The `react-spinners`
    package has several `spinners` for you to choose from, each of which has several
    configuration options. There are other spinner libraries that you can use or implement
    on your own.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned that you can use a single `Suspense` component
    that will display its fallback content for any lazy components that are lower
    in the tree. You learned how to simulate latency during local development so that
    you can experience what your users will experience with your `Suspense` fallback
    content. Finally, you learned how to use components from other libraries as the
    fallback content to provide something that looks better than plain text.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn about why it doesn’t make sense to make every
    component in your app a lazy component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding lazy components
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It might be tempting to make most of your React components lazy components
    that live in their own bundle. After all, there isn’t much extra work that needs
    to happen to set up separate bundles and make lazy components. However, there
    are some downsides to this. If you have too many lazy components, your app will
    end up making several HTTP requests to fetch them: at the same time. There’s no
    benefit to having separate bundles for components used on the same part of the
    app. You’re better off trying to bundle components together in a way that one
    HTTP request is made to load what is needed on the current page.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'A helpful way to think of this is to associate **pages** with **bundles**.
    If you have lazy page components, everything on that page will also be lazy yet
    bundled together with other components on the page. Let’s build an example that
    demonstrates how to organize our lazy components. Let’s say that your app has
    a couple of pages and a few features on each page. We don’t necessarily want to
    make these features lazy if they’re all going to be needed when the page loads.
    Here’s the `App` component that shows the user a selector to pick which page to
    load:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `First` and `Second` components are the pages that make up our app, so
    we want them to be lazy components that load their bundles on demand. The `ShowComponent`
    component renders the appropriate page when the user changes the selector:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let’s look at the first page and see how it’s composed, starting with
    the `First` component:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `First` component pulls in three components and renders them: `One`, `Two`,
    and `Three`. These three components will be part of the same bundle. While we
    could make them lazy, there would be no point, as all we would be doing is making
    three HTTP requests for bundles at the same time instead of one.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of how to map the page structures of
    your application to bundles, let’s look at another use case where we use a router
    component to navigate around our app.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Exploring lazy pages and routes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Avoiding lazy components* section, you saw where to avoid making components
    lazy when there is no benefit in doing so. The same pattern can be applied when
    you’re using `react-router` as the mechanism to navigate around your application.
    Let’s take a look at an example. Here are the imports we’ll need:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we have two lazy page components that will be bundled
    separately from the rest of the app. The fallback content in this example uses
    the same `FadeLoader` `spinner` component that was introduced in the *Working
    with spinner fallbacks* section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个将单独打包的懒加载页面组件。在这个例子中，回退内容使用了在*使用旋转器回退*部分中引入的相同的`FadeLoader` `spinner`组件。
- en: 'Note that the `Suspense` component is placed beneath the navigation links.
    This means that the fallback content will be rendered in the spot where the page
    content will eventually show when it loads. The children of the `Suspense` component
    are the `Route` components that will render our lazy page components: for example,
    when the `/first` route is activated, the `First` component is rendered for the
    first time, triggering the bundle download.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Suspense`组件放置在导航链接之下。这意味着当内容加载时，将在这个位置渲染出最终显示的页面内容。`Suspense`组件的子元素是`Route`组件，它们将渲染我们的懒加载页面组件：例如，当`/first`路由被激活时，`First`组件将首次渲染，触发包下载。
- en: That brings us to the end of this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了这一章。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about code splitting and bundling, which are important
    concepts for large React applications. We started by looking at how code is split
    into bundles in your React applications by using the `import()` function. Then,
    we looked at the `lazy()` React API and how it helps to simplify loading bundles
    when components are rendered for the first time. Next, we looked more deeply at
    the `Suspense` component, which is used to manage content while component bundles
    are being fetched. The `fallback` property is how we specify the content to be
    shown while bundles are being loaded. You typically don’t need more than one `Suspense`
    component in your app, as long as you follow a consistent pattern for bundling
    pages of your app.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于代码拆分和打包，这些是大型React应用程序中的重要概念。我们首先通过使用`import()`函数查看如何在你的React应用程序中将代码拆分成包。然后，我们探讨了`lazy()`
    React API以及它是如何帮助简化首次渲染组件时的包加载。接下来，我们更深入地研究了`Suspense`组件，该组件用于在组件包被检索时管理内容。`fallback`属性是我们指定在加载包时显示的内容的方式。只要你的应用程序遵循一致的打包模式，通常你不需要在应用程序中使用超过一个`Suspense`组件。
- en: 'In the next chapter, you’ll learn how to use the **Next.js** framework to handle
    rendering React components on the server. The Next.js framework allows you to
    create pages that act as React components and can be rendered on the server and
    in the browser. This is an important capability for applications that need good
    initial page load performance: that is, all applications.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用**Next.js**框架来处理在服务器上渲染React组件。Next.js框架允许你创建作为React组件的页面，这些页面可以在服务器和浏览器上渲染。这对于需要良好的初始页面加载性能的应用程序来说是一个重要的功能：也就是说，所有应用程序。
