- en: '*Chapter 10*: Using the Angular Compatibility Compiler'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular Ivy replaces the previous-generation Angular compiler and rendering
    runtime known as Angular View Engine. The last version to support the View Engine
    runtime is Angular version 11.2.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about the bridge between View Engine-compiled
    Angular packages on npm and your Angular Ivy application, namely the **Angular
    Compatibility Compiler** (**ngcc**).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Angular Compatibility Compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Angular Compatibility Compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the Angular Compatibility Compiler in your CI/CD workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your Angular Ivy application consumes View Engine-compiled libraries from
    a package registry, you must use the Angular Compatibility Compiler. After learning
    about the topics covered in this chapter, you will know what is happening in your
    local development workflow and be able to fine-tune the Angular Compatibility
    Compiler in your CI/CD workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the techniques demonstrated in this chapter, your application requires
    at least the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular Ivy version 11.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript version 4.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Angular Compatibility Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code of Angular libraries is compiled before it is published on a
    package registry such as npm. Until Angular version 12.0, it was not possible
    to compile Angular libraries using partial Angular Ivy compilation; they had to
    be compiled with the View Engine compiler. As part of a transition period, Angular
    uses the Angular Compatibility Compiler to allow Angular Ivy applications to use
    libraries that are compiled using the View Engine compiler and published to a
    package registry.
  prefs: []
  type: TYPE_NORMAL
- en: As of Angular version 12.2, the Angular Compatibility Compiler is still included
    as part of the Angular CLI, meaning that our Angular Ivy applications can consume
    libraries that are compiled using either the View Engine or the Angular Ivy compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular CLI version 12.0, partial Ivy compilation for Angular libraries was
    introduced. In short, it compiles all Angular-specific code except component templates.
    However, partial Ivy compilation breaks backward compatibility for libraries in
    that consumers must also have at least Angular CLI version 12.0\. In the period
    following this release, we will see a transition from View Engine-compiled Angular
    libraries to partially Ivy-compiled Angular libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that we do not have to change anything in our Angular Ivy application
    except keep Angular packages up to date. As soon as we have at least Angular 12.0,
    our application supports partially Ivy-compiled Angular libraries through an internal
    part of the Angular framework known as the Angular Linker.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular Linker is a replacement for the Angular Compatibility Compiler in
    that it converts a partially Ivy-compiled Angular library bundle to a fully Ivy-compiled
    library bundle before including it in the compilation of our application.
  prefs: []
  type: TYPE_NORMAL
- en: As such, the Angular Compatibility Compiler will be removed in a version of
    Angular unknown at the time of writing but later than version 12.2\. When this
    happens, our Angular application will only be able to use partially Ivy-compiled
    Angular libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an overview of what the Angular Compatibility Compiler and
    the Angular Linker are and awareness of why they are needed, in the next section,
    we will discuss how to use the Angular Compatibility Compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Angular Compatibility Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some Angular version 9 releases, we had to run the Angular Compatibility
    Compiler manually before building, testing, or serving our Angular Ivy application.
    In later releases, this changed so that the Angular CLI triggers the Angular Compatibility
    Compiler as needed.
  prefs: []
  type: TYPE_NORMAL
- en: It is still possible to run the Angular Compatibility Compiler manually. In
    fact, this allows for fine-tuning it to optimal compilation speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular Compatibility Compiler needs to run at least once before any of
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a development server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing automated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time we install a new version of an Angular library or an additional Angular
    library from a package registry, we must run the Angular Compatibility Compiler
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Consider running the Angular Compatibility Compiler as part of your Git repository's
    `postinstall` hook. When using this technique, we do not have to wait the next
    time we perform one of the actions mentioned in the previous list. While the Angular
    Compatibility Compiler is running, we are free to change our source code.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, use the `--target` option, as described in the *Angular Compatibility
    Compiler options* section coming up next.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Compatibility Compiler options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular Compatibility Compiler bundles an executable named `ngcc`. When
    running this command, we can pass the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--create-ivy-entry-points`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an `__ivy_ngcc_` subdirectory inside each Angular library package directory.
    Inside this directory, another subdirectory will be created with the name of the
    output bundle format, for example, `fesm2015`. Inside the bundle format folder,
    the Ivy-compiled bundles and source maps will be placed. If this option is not
    passed, the original bundles will instead be overwritten.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`--first-only`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When this option is used in combination with `--properties`, the Angular Compatibility
    Compiler will only compile the first module format it recognizes in a library
    package based on the order of the package property names specified by `--properties`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`--properties <package-property-names>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This option specifies the acceptable library package formats to compile using
    the Angular Compatibility Compiler. The package property names refer to the properties
    of the JSON configuration in a library package's `package.json` module declaration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example: `--properties es2015 browser module main`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`--target <package-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This option only compiles the specified package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example: `--target @angular/material/button`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`--tsconfig <tsconfig-path>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use this option with `--use-program-dependencies` to target a specific
    project in your Angular workspace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example: `--tsconfig projects/music-app/tsconfig.app.json`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`--use-program-dependencies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use this option to decide which library packages you want to compile
    with the Angular Compatibility Compiler based on the source code in your Angular
    workspace or project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A few more options exist but are for exceptional use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the Angular Compatibility Compiler manually, for example, after modifying
    or adding a package dependency, allows us to optimize the compilation speed. When
    we are triggering compilation of the entire workspace manually, we should generally
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `--first-only` option ensures that only one package format is compiled into
    an Angular Ivy-compatible package bundle using the `esm2015` package format. The
    `--properties` option lists the preferred package format. Research has shown that
    the `es2015` format is generally the fastest package format to compile from a
    View Engine-compatible bundle to an Angular Ivy-compatible bundle, closely followed
    by the `module` format. Finally, the `--create-ivy-entry-points` option is generally
    faster than in-place bundle replacement.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Angular version 9.0 or 11.1, consider leaving out the `--create-ivy-entry-points`
    option to use in-place bundle replacement. Research has found this option to be
    slightly faster in these specific versions.
  prefs: []
  type: TYPE_NORMAL
- en: Consider also adding the `--use-program-dependencies` option to only compile
    packages that are imported by an application. When using this option, we must
    run the Angular Compatibility Compiler every time we use a package for the first
    time in our application.
  prefs: []
  type: TYPE_NORMAL
- en: The `--use-program-dependencies` option is especially useful when using Angular
    CDK and Angular Material because they have many sub-packages that are all compiled
    individually. Additionally, every Angular CDK and Angular Material sub-package
    is compiled by default, not just the ones used by an application. This impacts
    compilation speed significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `ngcc` commands listed in this chapter are meant to be used in pre-defined
    command listings inside the `scripts` property of `package.json`. To run them
    from a terminal, prefix them with `npx`, for example, `npx ngcc --create-ivy-entry-points`.
  prefs: []
  type: TYPE_NORMAL
- en: That is all about options and common techniques for your local development workflow.
    In the following section, you will learn how to optimize the Angular Compatibility
    Compiler for speed in a CI/CD workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Angular Compatibility Compiler in your CI/CD workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can tell from the description of some of the options supported by the
    Angular Compatibility Compiler, it maintains files inside your application's `node_modules`
    folder. Depending on your CI environment, caching and restoring the entire `node_modules`
    folder might be too slow. In this case, cache your package manager's package cache
    folder instead.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe caching is not enabled at all in your CI/CD workflow. In both cases, we
    must run the Angular Compatibility Compiler in every CI/CD workflow run. It starts
    from scratch with the files it manages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this use case, we use guidelines described in *Angular Compatibility Compiler
    options section*. We use the following `postinstall` hook to run `ngcc` in what
    is overall the fastest combination of parameter options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This only compiles a single package format to the Angular Ivy package format
    and prefers package formats in the order of the formats that are overall the fastest
    to compile. The package files are compiled to new files in subfolders managed
    by the Angular Compatibility Compiler rather than replacing the existing, View
    Engine-compiled package files.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Consider leaving out the `--create-ivy-entry-points` option if you are using
    Angular versions 9.0 or 11.1\. Research has indicated that in-place Ivy compilation
    is faster in these versions.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Angular Compatibility Compiler in a separate step rather than on
    demand has the benefit of allowing fine-tuning as we just did. Additionally, it
    allows us to track the time spent on testing or building our application while
    excluding the View Engine to Angular Ivy compilation time.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting a single application in a monorepo workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the *Angular Compatibility Compiler options* section, the Angular
    CDK and Angular Material are examples of Angular library packages with many sub-packages.
    If we have a monorepo workspace with several Angular applications, perhaps only
    some of them are using the Angular CDK or Angular Material. Additionally, any
    single one of these applications is most likely not using every sub-package of
    the Angular CDK or Angular Material.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take this into account if we have a CI or CD job targeting a single
    application, for example, a test or build job for a particular application. Imagine
    that we have a monorepo workspace with two Angular applications, one using the
    Bootstrap UI component library and the other using Angular Material. In a test
    or build job for the application using Bootstrap, we use the following command
    in a step after installing package dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are targeting the Bootstrap application by passing the path of its TypeScript
    configuration file to the `--tsconfig` option and finally we are adding the `--use-program-dependencies`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: This will save significant compute time in our CI/CD jobs as our CI server will
    not have to compile any sub-packages of Angular Material.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even in the case of the application using Angular Material, we can use a similar
    command to save time because it will only compile the Angular Material sub-packages
    that are imported by our application instead of all of them. This is shown in
    the following example command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we changed the path passed to the `--tsconfig` option.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned the most common optimization techniques for Angular application
    CI/CD workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first discussed how the Angular Compatibility Compiler is
    a tool needed in the transition phase while Angular library packages are still
    compiled using the Angular View Engine compiler. The Angular Compatibility Compiler
    compiles these package bundles into the Angular Ivy format so that they can be
    used by our Angular Ivy applications.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we discussed how recent versions of Angular support partially
    Ivy-compiled Angular library packages using the Angular Linker, which eventually
    fully replaces the Angular Compatibility Compiler.
  prefs: []
  type: TYPE_NORMAL
- en: After reviewing the use cases that rely on the Angular Compatibility Compiler,
    we briefly discussed the most useful options for the `ngcc` command-line tool.
    Following that, we walked through common optimization techniques using these options.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter ended by considering how the Angular Compatibility Compiler
    can be optimized for speed in CI/CD workflows. We discussed solutions for several
    specific and common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to take advantage of the Angular Compatibility Compiler and
    you know when and how to optimize it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be guided on migrating your existing Angular application
    from View Engine to Ivy. You will learn about automated and manual migrations
    as well as other considerations when migrating from View Engine to Angular Ivy.
  prefs: []
  type: TYPE_NORMAL
