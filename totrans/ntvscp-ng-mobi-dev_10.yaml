- en: '@ngrx/store + @ngrx/effects for State Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/store + @ngrx/effects用于状态管理'
- en: Managing state in any app can become troubling as the app scales over time.
    We want to have full confidence over the predictability of our app's behavior
    and getting a hang of its state is key to gaining that confidence.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用随时间扩展，管理任何应用的状态可能会变得麻烦。我们希望对我们的应用行为的可预测性有完全的信心，而掌握其状态是获得这种信心的关键。
- en: State can be broadly defined as the particular condition that someone or something
    is in at a specific time. With regard to our app, the state can encompass whether
    our player is playing or not, whether the recorder is recording or not, and whether
    the track list UI is in mixing mode or not.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 状态可以广泛地定义为某人在特定时间所处的特定条件。就我们的应用而言，状态可以包括我们的播放器是否在播放，录音机是否在录音，以及轨道列表UI是否在混音模式中等。
- en: Storing state in a single spot allows you to know exactly what the state of
    the app is at any given moment. Without a single store, you usually wind up with
    state buried throughout different components and services, which often leads to
    two or more different versions of state as features are built out. This unwieldy
    growth of state becomes even more troublesome as different features need to interact
    with each other, which may or may not necessarily depend on each other.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态存储在单个位置允许你确切地知道在任何给定时刻应用的状态。没有单一的状态存储，你通常会在不同的组件和服务中找到隐藏的状态，这通常会导致随着功能的构建出现两个或更多不同的状态版本。当不同的功能需要相互交互时，这种状态的不规则增长变得更加麻烦，而这些交互可能或可能不依赖于彼此。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding what Redux is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Redux是什么
- en: Understanding what ngrx is and how it relates to Redux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ngrx是什么以及它与Redux的关系
- en: Defining state for an app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用的状态
- en: Integrating @ngrx/store to manage state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成@ngrx/store来管理状态
- en: Understanding what @ngrx/effects are
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解@ngrx/effects是什么
- en: Integrating side effects to aid our state management
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成副作用来帮助我们的状态管理
- en: Going from *inactive to reactive* with our code base (Mike Ryan/Brandon Roberts^(TM))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的代码库从*非活动状态*转换为*响应状态*（Mike Ryan/Brandon Roberts^(TM)）
- en: Understanding Redux and integrating @ngrx/store
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Redux和集成@ngrx/store
- en: Redux is an open source library that defines itself as a predictable state container
    for JavaScript apps. The concepts are not exactly new, but the details were developed
    by Dan Abramov in 2015 who was influenced by Facebook's Flux and the functional
    programming language, Elm. It quickly gained popularity among the React community
    as it was used throughout Facebook.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个开源库，它将自己定义为JavaScript应用的预测状态容器。这些概念并不完全新颖，但细节是在2015年由Dan Abramov开发的，他受到了Facebook的Flux和函数式编程语言Elm的影响。它在React社区中迅速流行起来，因为Facebook广泛使用了它。
- en: 'We don''t want to redefine what Redux is, so we will quote directly from the
    Redux repo ([https://github.com/reactjs/redux](https://github.com/reactjs/redux)):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想重新定义Redux是什么，所以我们将直接引用Redux仓库([https://github.com/reactjs/redux](https://github.com/reactjs/redux))：
- en: The whole state of your app is stored in an object tree inside a single *store*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的全部状态都存储在单个*store*中的对象树内。
- en: The only way to change the state tree is to emit an *action*, an object describing
    what happened.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 改变状态树的唯一方法是发出一个*action*，一个描述发生了什么的对象。
- en: To specify how the actions transform the state tree, you write pure *reducers*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定动作如何转换状态树，你需要编写纯*reducers*。
- en: That's it!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: The concept is fairly simple and quite brilliant. You emit actions (which are
    simple string typed objects with a payload representing the data to be passed
    along) against the system, which wind up hitting a reducer (a pure function) to
    define how state is transformed by these actions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念相当简单且非常出色。你向系统发出动作（这些是带有表示要传递数据的有效载荷的简单字符串类型对象），这些动作最终会击中reducer（一个纯函数）来定义这些动作如何转换状态。
- en: It's important not to confuse transform with mutate. One of the fundamental
    concepts of Redux is that all state is **immutable**; hence, each reducer is a
    **pure** function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要混淆transform和mutate。Redux的一个基本概念是所有状态都是**不可变的**；因此，每个reducer都是一个**纯函数**。
- en: A pure function always returns the same results given the same parameters. Its
    execution does not depend on the state of the system as a whole [[https://en.wikipedia.org/wiki/Pure_function](https://en.wikipedia.org/wiki/Pure_function)].
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数总是对相同的参数返回相同的结果。它的执行不依赖于整个系统的状态[[https://en.wikipedia.org/wiki/Pure_function](https://en.wikipedia.org/wiki/Pure_function)]。
- en: So, although a reducer transforms state, it does not mutate it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管reducer会转换状态，但它不会对其进行修改。
- en: In depth, engineering studies have been done on change detection systems and
    how object equality/reference checks are superior in speed when compared to object
    comparison checks on deeply nested properties. We won't go into detail for the
    reasons for this, but immutability of your app's data flow has significant impact
    on how you can fine-tune its performance, especially with regard to Angular.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究，已经对变化检测系统进行了工程研究，并且与深层嵌套属性上的对象比较检查相比，对象相等性/引用检查在速度上具有优势。我们不会深入探讨这一点的理由，但你的应用程序数据流的不可变性对你的性能微调有重大影响，尤其是在Angular方面。
- en: Along with performance enhancements, the concepts of Redux further enhance decoupling
    across your entire code base, leading to the reduction of various dependencies
    spread throughout. With the power of actions describing the various interactions
    our app entails, we no longer need to inject explicit service dependencies to
    execute its APIs. Instead, we can simply emit actions and the principles of Redux
    will work for us to propagate and handle the necessary functionality our app demands,
    all the while maintaining a single and dependable source of truth.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能提升外，Redux的概念进一步增强了整个代码库的解耦，导致各种分散的依赖减少。有了描述我们应用程序各种交互的动作的强大功能，我们不再需要注入显式的服务依赖来执行其API。相反，我们可以简单地发出动作，Redux的原则将为我们传播和处理应用程序所需的功能，同时保持一个单一且可靠的真相来源。
- en: What is @ngrx/store?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/store是什么？'
- en: Early in the rewrite of Angular (from 1.x to 2.x+), a core team member turned
    developer advocate at Google, Rob Wormald, developed **ngrx/store** as an "*RxJS
    powered state management [system] for Angular applications, inspired by Redux."*
    The key point in that phrase is the term "**RxJS"**. Hence the name **ngrx** derives
    its name from joining "**ng"** for A**ng**ular with "**rx"** from **Rx**JS. The
    open source library quickly gained highly-talented contributors such as Mike Ryan,
    Brian Troncone, and Brandon Roberts and took off to become an extremely intelligent
    and powerful state management system for modern Angular applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的重写早期（从1.x到2.x+），一位核心团队成员在Google担任开发者倡导者，Rob Wormald，开发了**ngrx/store**，这是一个“由RxJS驱动的Angular应用程序的状态管理[系统]，灵感来自Redux”。这个短语中的关键点是术语“**RxJS**”。因此，**ngrx**这个名字是从将“**ng**”与Angular结合，以及从**Rx**JS中的“**rx**”中得来的。这个开源库迅速吸引了像Mike
    Ryan、Brian Troncone和Brandon Roberts这样才华横溢的贡献者，并迅速发展成为现代Angular应用程序的一个极其智能和强大的状态管理系统。
- en: Although it is heavily inspired by Redux and utilizes the same concepts, it
    is uniquely different in making RxJS a first-class citizen in how the system is
    wired. It brings **Observables** full circle throughout all the concepts of Redux,
    enabling truly **reactive** user interfaces and apps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它深受Redux的启发并利用了相同的概念，但在将RxJS作为系统连接的第一公民方面，它具有独特的不同之处。它使**Observables**在Redux的所有概念中完整地循环，使真正**响应式**的用户界面和应用程序成为可能。
- en: 'If all these concepts are new to you, Brian Troncone''s thorough post will
    definitely help you gain more understanding as we won''t be able to cover every
    detail of ngrx here. Please see this post:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些概念对你来说都是新的，Brian Troncone的详尽文章肯定会帮助你更好地理解，因为我们在这里无法涵盖ngrx的所有细节。请参阅这篇文章：
- en: '[https://gist.github.com/btroncone/a6e4347326749f938510](https://gist.github.com/btroncone/a6e4347326749f938510)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/btroncone/a6e4347326749f938510](https://gist.github.com/btroncone/a6e4347326749f938510)'
- en: Designing the state model
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计状态模型
- en: 'Before integrating ngrx, it''s good to first think about the various aspects
    of state throughout your app in addition to which module they might pertain to.
    With our app, here''s a reasonable starter list (*not meant to be complete or
    thorough at this point*):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成ngrx之前，首先思考一下应用程序中状态的各种方面以及它们可能属于哪个模块是个好主意。就我们的应用程序而言，这里有一个合理的起始列表（目前不是完整或详尽的）：
- en: '`CoreModule`:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoreModule`：'
- en: '`user: any;` user-related state:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user: any;` 与用户相关的状态：'
- en: '`recentUsername: string`; most recently used successful username'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recentUsername: string`；最近使用的成功用户名'
- en: '`current: any`; authenticated user (if there is one)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current: any`；认证用户（如果有）'
- en: '`MixerModule`:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MixerModule`：'
- en: '`mixer: any`: mixer-related state'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mixer: any`；与mixer相关的状态'
- en: '`compositions: Array<IComposition>`; list of user-saved compositions'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compositions: Array<IComposition>`；用户保存的组成列表'
- en: '`activeComposition: CompositionModel`; the active composition'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activeComposition: CompositionModel`；当前组成'
- en: '`PlayerModule`:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerModule`：'
- en: '`player: any`; various aspects of player state.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`player: any`；玩家状态的各个方面。'
- en: '`playing: boolean`; whether audio is playing or not.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playing: boolean`; 音频是否正在播放。'
- en: '`duration: number`; total duration of playback.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration: number`; 播放的总时长。'
- en: '`completed: boolean`; whether playback reached the end and is completed. This
    will help determine the difference between when the user stops playback or when
    it autostops due to the player reaching the end.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completed: boolean`; 是否播放已达到末尾并完成。这将有助于确定用户停止播放或播放器因到达末尾而自动停止之间的区别。'
- en: '`seeking: boolean`; whether playback seeking is in progress.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seeking: boolean`; 是否正在播放寻求。'
- en: '`RecorderModule`:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecorderModule`：'
- en: '`recorder: RecordState`; recording state represented simply by an enum'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recorder: RecordState`; 通过枚举简单表示的录制状态'
- en: 'No module in particular, just state we want to observe:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特定的模块，只是我们想要观察的状态：
- en: '`ui: any`; user interface state'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ui: any`; 用户界面状态'
- en: '`trackListViewType: string`; the currently active view toggle for track listing'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trackListViewType: string`; 轨迹列表当前活动的视图切换'
- en: The key point here is not to worry about getting this exactly right the first
    time. It's hard to know the precise state model when you first build an app, and
    it will most likely change a bit over time and that's okay.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点不是担心第一次就完全正确。当你第一次构建应用程序时，很难知道精确的状态模型，并且它很可能会随着时间的推移而略有变化，这是可以接受的。
- en: State for our app is better known at this time because we have already built
    a working app, so this is a tad bit easier. Typically, mapping this out before
    you build an app is more difficult; however, again, don't worry about getting
    it right the first time! You can easily refactor and tweak it over time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序状态更易于理解，因为我们已经构建了一个工作中的应用程序，所以这稍微容易一些。通常，在构建应用程序之前规划这一点会更困难；然而，再次提醒，不要担心第一次就完全正确！你可以很容易地在以后重构和调整它。
- en: Let's take this state and work it into our app with ngrx.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 ngrx 将这个状态整合到我们的应用程序中。
- en: Installing and integrating @ngrx/store
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和集成 @ngrx/store
- en: 'We want to first install `@ngrx/store`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想安装 `@ngrx/store`：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now provide the single store to our app via the `StoreModule`. We define
    these initial slices of state in our `CoreModule`, which will be available when
    the app boots, while each lazy loaded feature module adds its own state and reducers
    later when needed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过 `StoreModule` 为我们的应用程序提供单个存储库。我们在 `CoreModule` 中定义这些初始状态切片，当应用程序启动时它们将可用，而每个懒加载的功能模块将在需要时添加自己的状态和减少器。
- en: Providing the initial app state excluding any lazily loaded module state
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供初始应用程序状态，排除任何懒加载模块状态
- en: We want to start by defining the initial app state, excluding any lazily loaded
    feature module state. Since our `CoreModule` provides `AuthService`, which deals
    with handling our user, we will consider the **user** slice a fundamental key
    to our app's initial state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想首先定义初始应用程序状态，排除任何懒加载的功能模块状态。由于我们的 `CoreModule` 提供了 `AuthService`，它负责处理我们的用户，因此我们将
    **用户** 切片视为我们应用程序初始状态的基本关键。
- en: In particular, let's begin by defining the shape of our user state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是让我们首先定义我们的用户状态的结构。
- en: 'Create `app/modules/core/states/user.state.ts`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `app/modules/core/states/user.state.ts`：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our user state is very simple. It contains a `recentUsername` representing a
    string of the most recently successfully authenticated username (useful if the
    user were to log out and return to log in later). Then, we have **current**, which
    will represent a user object if authenticated, or null if not. We also include
    a `loginCanceled` boolean since we surmise it may be useful for analyzing user
    interaction if we were to start reporting state as analytics data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户状态非常简单。它包含一个 `recentUsername`，代表最近成功认证的用户名字符串（如果用户注销并稍后返回登录，这很有用）。然后，我们有
    **当前**，如果认证，将代表用户对象，如果没有，则为 null。我们还包含一个 `loginCanceled` 布尔值，因为我们推测，如果我们开始将状态作为分析数据报告，它可能对分析用户交互有用。
- en: Any data points around authentication can be critical to understanding our app's
    user base. For example, it might be insightful to learn whether or not requiring
    authentication to record was causing more canceled logins than signups, which
    may have a direct affect on user retention.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证相关的任何数据点都可能对我们应用程序的用户基础的理解至关重要。例如，了解是否要求认证来记录是否导致取消登录比注册更多，这可能会直接影响用户保留。
- en: 'To be consistent with our approach throughout this book, also create `app/modules/core/states/index.ts`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与本书中的方法保持一致，也创建 `app/modules/core/states/index.ts`：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s create our user actions; create `app/modules/core/actions/user.action.ts`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的用户操作；创建 `app/modules/core/actions/user.action.ts`：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, follow up with our standard; create `app/modules/core/actions/index.ts`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，按照我们的标准；创建 `app/modules/core/actions/index.ts`:'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Okay now, what''s going on with those actions?! Here''s what we''ve defined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在这些动作有什么问题？！以下是我们定义的内容：
- en: '`INIT`: To initialize the user right when the app launches. In other words,
    this action will be used to check persistence and restore a user object onto the
    app''s state at launch time.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INIT`: 当应用启动时立即初始化用户。换句话说，这个动作将用于检查持久性和在启动时将用户对象恢复到应用的状态中。'
- en: '`LOGIN`: Begin the login sequence. In our app, this will show the login dialog.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGIN`: 开始登录序列。在我们的应用中，这将显示登录对话框。'
- en: '`LOGIN_SUCCESS`: Since login is asynchronous, this action will dispatch once
    login is complete.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGIN_SUCCESS`: 由于登录是异步的，这个动作将在登录完成后分发。'
- en: '`LOGIN_CANCELED`: If the user cancels login.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGIN_CANCELED`: 如果用户取消登录。'
- en: '`LOGOUT`: When user logs out.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGOUT`: 当用户注销时。'
- en: '`UPDATED`: We will use this as a simple action to update our user state. This
    will generally not be dispatched directly, but will be used in the reducer we''ll
    create in a moment.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATED`: 我们将使用这个简单的动作来更新我们的用户状态。这通常不会直接分发，但将在我们稍后创建的reducer中使用。'
- en: The formalities you see here provide a consistent and strongly-typed structure.
    By utilizing a namespace, we are able to uniquely identify this set of actions
    with a name, `UserActions`. This allows the interior naming to remain the same
    across many other namespaced actions we will create for the lazy loaded modules
    state, providing a great standard to work with. The `CATEGORY` is necessary because
    every action must be unique, not just in this set of actions but across the entire
    app. The interfaces help provide good intelligence when using our actions, in
    addition to type safety. The various action classes help ensure that all actions
    dispatched are new instances and provide a powerful way to strongly type our action
    payloads. This also makes our code easy to refactor down the line. The last utility
    in our structure is the union type at the bottom, which helps our reducer determine
    the applicable actions it should be concerned with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的正式性提供了统一且强类型的结构。通过使用命名空间，我们能够通过名称唯一地识别这一组动作，即`UserActions`。这允许内部命名在许多其他我们将为懒加载模块状态创建的命名空间动作中保持一致，提供了一个很好的工作标准。`CATEGORY`是必要的，因为每个动作都必须是唯一的，不仅在这个动作集中，在整个应用中都必须是唯一的。接口帮助在使用我们的动作时提供良好的智能，同时提供类型安全。各种动作类有助于确保所有分发的动作都是新实例，并提供了一种强大的方式来强类型化我们的动作负载。这也使得我们的代码在未来易于重构。我们结构中的最后一个实用工具是底部的联合类型，它帮助我们的reducer确定它应该关注的适用动作。
- en: 'Speaking of that reducer, let''s create it now: `app/modules/core/reducers/user.reducer.ts`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '说到那个reducer，我们现在就创建它：`app/modules/core/reducers/user.reducer.ts`:'
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reducer is incredibly simple. As mentioned, it is a pure function that takes
    in the existing state along with an action and returns a new state (as a new Object
    unless it's the default starting case). This maintains immutability and keeps
    things quite elegant. The `UPDATED` action will always be the last in any action
    chain to fire off and ultimately change the user state. In this case, we'll keep
    things simple and allow our `UPDATED` action to be the only action that actually
    changes the user state. The other actions will set up a chain, whereby they end
    up dispatching `UPDATED` if they need the user state to change. You could certainly
    set up more cases here based on our actions to change the state; however, in our
    app, this will be the only action that ultimately changes the user state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 非常简单。如前所述，它是一个纯函数，它接受现有的状态以及一个动作，并返回一个新的状态（除非是默认的起始情况，否则是一个新对象）。这保持了不可变性，并保持了事物的优雅。`UPDATED`
    动作将是任何动作链中最后触发的动作，并最终改变用户状态。在这种情况下，我们将保持简单，并允许我们的 `UPDATED` 动作是唯一实际改变用户状态的动作。其他动作将设置一个链，最终在需要改变用户状态时触发
    `UPDATED`。你当然可以根据我们的动作设置更多的情况来改变状态；然而，在我们的应用中，这将唯一改变用户状态的动作。
- en: '*Action chain?* What on earth do we mean by an *Action chain*?! You may be
    wondering how we wire these actions to interplay with each other if needed?'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*动作链？* 我们所说的 *动作链* 是什么意思？！你可能想知道如果需要，我们如何将这些动作连接起来进行交互？'
- en: Installing and integrating @ngrx/effects
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和集成 @ngrx/effects
- en: 'Without redefining, let''s look at the description of @ngrx/effects straight
    from the repo ([https://github.com/ngrx/effects](https://github.com/ngrx/effects)):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '不重新定义，让我们看看 @ngrx/effects 的描述，直接来自仓库 ([https://github.com/ngrx/effects](https://github.com/ngrx/effects)):'
- en: In `@ngrx/effects`, effects are the sources of actions. You use the `@Effect()`
    decorator to hint which observables on a service are action sources, and `@ngrx/effects`
    automatically merges your action streams, letting you subscribe them to store.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@ngrx/effects` 中，效果是动作的来源。您使用 `@Effect()` 装饰器来提示服务上的哪些可观察者是动作源，并且 `@ngrx/effects`
    会自动合并您的动作流，让您可以订阅它们到存储。
- en: To help you compose new action sources, `@ngrx/effects` exports an action observable
    service that emits every action dispatched in your application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您组合新的动作源，`@ngrx/effects` 导出一个动作可观察服务，该服务会发出您应用程序中发出的每个动作。
- en: In other words, we can chain our actions together with effects to provide powerful
    data flow composition throughout our app. They allow us to insert behavior that
    should take place between when an action is dispatched and before the state is
    ultimately changed. The most common use case is to handle HTTP requests and/or
    other asynchronous operations; however, they have many useful applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以通过效果将我们的动作链起来，以在我们的应用程序中提供强大的数据流组合。它们允许我们在动作发出和最终更改状态之前插入应该发生的行为。最常见的情况是处理
    HTTP 请求和/或其他异步操作；然而，它们有许多有用的应用。
- en: 'To use, let''s first install `@ngrx/effects`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '要使用，我们首先安装 `@ngrx/effects`:'
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let's take a look at what our user actions look like in an effect chain.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的用户操作在效果链中的样子。
- en: Real quickly, though, to remain consistent with our naming structure, let's
    rename `auth.service.ts` to `user.service.ts`. It helps when we have a naming
    standard that is consistent across the board.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了保持命名结构的一致性，让我们将 `auth.service.ts` 重命名为 `user.service.ts`。当我们有一个在整个范围内一致的命名标准时，这有助于我们。
- en: 'Now, create `app/modules/core/effects/user.effect.ts`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，创建 `app/modules/core/effects/user.effect.ts`:'
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have clarified the intent of our data flow concerning our `UserService`
    and delegated the responsibility to this effect chain. This allows us to compose
    our data flow in a clear and consistent manner with a great deal of flexibility
    and power. For instance, our `InitAction` chain now allows us to automatically
    initialize the user via the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经澄清了我们关于 `UserService` 的数据流意图，并将责任委托给这个效果链。这使我们能够以清晰和一致的方式，以及极大的灵活性和能力来组合我们的数据流。例如，我们的
    `InitAction` 链现在允许我们通过以下方式自动初始化用户：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Earlier, we were calling a private method--`this._init()`--inside the service
    constructor; however, we no longer need explicit calls like that as effects are
    run and queued up once the module is bootstrapped. The `.startWith` operator will
    cause the observable to fire off one single time (at the point of module creation),
    allowing the init sequence to be executed at a particularly opportune time, when
    our app is initializing. Our initialization sequence is the same as we were previously
    handling in the service; however, this time we''re taking into consideration our
    new `recentUsername` persisted value (if one exists). We then end the init sequence
    with a `UserActions.UpdatedAction`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在服务构造函数内部调用了一个私有方法--`this._init()`--但是，一旦模块启动，我们不再需要这样的显式调用，因为效果会被运行并排队。`.startWith`
    操作符将导致可观察者一次性触发（在模块创建时），允许在应用程序初始化的特定有利时机执行初始化序列。我们的初始化序列与我们之前在服务中处理的是相同的；然而，这次我们考虑了新的
    `recentUsername` 持久值（如果存在）。然后我们以 `UserActions.UpdatedAction` 结束初始化序列：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that there''s no effect chain wired to `UserActions.ActionTypes.UPDATED`.
    This is because there are no side effects that should occur by the time that `Action`
    occurs. Since there are no more side effects, the observable sequence ends up
    in the reducer that has a `switch` statement to handle it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有效果链连接到 `UserActions.ActionTypes.UPDATED`。这是因为当 `Action` 发生时，不应该发生任何副作用。由于没有更多的副作用，可观察序列最终会进入具有
    `switch` 语句以处理它的还原器：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This takes the payload (which is typed as the shape of the user state, `IUserState`)
    and overwrites the values in the existing state to return a brand new user state.
    Importantly, `Object.assign` allows any existing values in the source object to
    not be overridden unless explicitly defined by the incoming payload. This allows
    only new incoming payload values to be reflected on our state, while still maintaining
    the existing values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取有效负载（其类型为用户状态形状，`IUserState`），并覆盖现有状态中的值以返回一个新的用户状态。重要的是，`Object.assign`
    允许源对象中任何现有的值不被覆盖，除非显式由传入的有效负载定义。这允许只有新的传入有效负载值反映在我们的状态上，同时仍然保持现有值。
- en: The rest of our `UserEffect` chain is fairly self-explanatory. Primarily, it's
    handling much of what the service was previously handling, with the exception
    of prompting the login dialog, which the effect chain is utilizing the service
    method to do. However, it's worth mentioning that we can go so far as to completely
    remove this service as the contents of the `promptLogin` method can easily be
    carried out directly in our effect now.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`UserEffect`链的其余部分相当直观。主要的是，它处理了服务之前处理的大部分内容，除了提示登录对话框，效果链正在使用服务方法来完成。然而，值得一提的是，我们可以完全移除这个服务，因为`promptLogin`方法的内容现在可以直接在我们的效果中执行。
- en: When deciding if you should handle more logic in your effect or a designated
    service, it really comes down to personal preference and/or scalability. If you
    have rather lengthy service logic and more than a couple of methods to handle
    logic while working with effects, creating a designated service will help greatly.
    You can scale more functionality into the service without diluting the clarity
    of your effects chain.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否在效果或指定服务中处理更多逻辑时，这实际上取决于个人偏好和/或可扩展性。如果你有相当长的服务逻辑，并且在与效果一起工作时需要处理多个方法，创建一个指定服务将非常有帮助。你可以将更多功能扩展到服务中，而不会稀释你的效果链的清晰度。
- en: Lastly, unit testing will be easier with a designated service with more logic.
    In this case, our logic is fairly simple; however, we'll leave the `UserService`
    for example purposes as well as best practice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有了专门的服务和更多的逻辑，单元测试将会更容易。在这种情况下，我们的逻辑相当简单；然而，为了示例目的以及最佳实践，我们还将保留`UserService`。
- en: Speaking of, let's take a look at how simplified our `UserService` looks now
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们看看我们的`UserService`现在看起来有多简化
- en: 'in `app/modules/core/services/user.service.ts`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/modules/core/services/user.service.ts`中：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's much cleaner now. Okay, so how do we let our app know about all this new
    goodness?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要干净多了。好吧，那么我们如何让我们的应用知道所有这些新功能呢？
- en: 'First, let''s follow one of our standards by adding an index to our entire
    core module; add `app/modules/core/index.ts`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们遵循我们的一个标准，为整个核心模块添加一个索引；添加`app/modules/core/index.ts`：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We simply export all the goodies our core module now provides, including the
    module itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地导出核心模块现在提供的所有好东西，包括模块本身。
- en: 'Then, open `app/modules/core/core.module.ts` to finish our wiring:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`app/modules/core/core.module.ts`来完成我们的连接：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we ensure that we define our `user` state key to use the `userReducer`
    and register it with `StoreModule`. We then call `EffectsModule.forRoot()`, with
    a collection of singleton effect providers to register like our `UserEffects`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确保定义我们的`user`状态键以使用`userReducer`，并将其与`StoreModule`注册。然后我们调用`EffectsModule.forRoot()`，使用一系列单例效果提供者进行注册，如我们的`UserEffects`。
- en: Now, let's take a look at how this improves the rest of the code base since
    we were undoubtedly injecting the `UserService` (previously named `AuthService`)
    in a couple of places.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这如何改进代码库的其余部分，因为我们无疑在几个地方注入了`UserService`（之前命名为`AuthService`）。
- en: 'We were previously injecting `AuthService` in `AppComponent` to ensure that
    Angular''s dependency injection constructed it early on when the app was bootstrapped,
    creating the necessary singleton our app needed. However, with `UserEffects` automatically
    running now on bootstrap, which in turn injects (now renamed) `UserService`, we
    no longer need this rather silly necessity anymore, so, we can update `AppComponent`
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在`AppComponent`中注入`AuthService`，以确保Angular的依赖注入在应用启动时尽早构建它，创建应用所需的单例。然而，随着`UserEffects`现在在启动时自动运行，它反过来注入（现在重命名为）`UserService`，我们不再需要这个相当愚蠢的必要性，因此，我们可以更新`AppComponent`如下：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In one swoop, our code base is now getting smarter and slimmer. Let's keep going
    to see other benefits of our ngrx integration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一举一动，我们的代码库现在变得更聪明、更精简。让我们继续看看我们的ngrx集成带来的其他好处。
- en: 'Open `app/auth-guard.service.ts`, and we can now make the following simplifications:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/auth-guard.service.ts`，我们现在可以做出以下简化：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When activating the `/record` route, we dispatch the `LoginAction` every time
    since we require an authenticated user to use the recording features. Our login
    effects chain properly handles if the user is already authenticated, so all we
    need to do is set up our state subscription to react accordingly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当激活`/record`路由时，由于我们需要一个经过身份验证的用户来使用录制功能，我们每次都会分发`LoginAction`。我们的登录效果链正确处理了用户已经经过身份验证的情况，所以我们只需要设置我们的状态订阅以相应地做出反应。
- en: Ngrx is flexible, and how you set up your actions and effects chains is purely
    up to you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ngrx 是灵活的，你如何设置你的动作和效果链完全取决于你。
- en: Providing lazily loaded feature module state
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供懒加载的功能模块状态
- en: 'We can now build out the scalable ngrx structure into our various feature modules,
    which will provide state. Starting with `MixerModule`, let''s modify `app/modules/mixer/mixer.module.ts`
    with the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将可扩展的 ngrx 结构构建到我们的各个功能模块中，这将提供状态。从 `MixerModule` 开始，让我们用以下内容修改 `app/modules/mixer/mixer.module.ts`：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are defining what the `MixerModule` state will provide. Now, let's
    define its shape; create
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 `MixerModule` 状态将提供的内容。现在，让我们定义其形状；创建
- en: '`app/modules/mixer/states/mixer.state.ts`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/modules/mixer/states/mixer.state.ts`：'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To be consistent with our approach throughout this book, also create `app/modules/mixer/states/index.ts`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持本书中的一致性，也创建 `app/modules/mixer/states/index.ts`：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s create our mixer actions; create `app/modules/mixer/actions/mixer.action.ts`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的混音动作；创建 `app/modules/mixer/actions/mixer.action.ts`：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similar to our UserActions, we will also use an `INIT` action to autoinitialize
    this state with user-saved compositions (or our sample demo composition to start).
    Here''s a quick rundown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的 UserActions 类似，我们也将使用一个 `INIT` 动作来自动使用用户保存的合成（或我们的示例演示合成）初始化此状态。以下是简要概述：
- en: '`INIT`: To initialize the mixer right when the app launches. Just as we did
    with `UserActions`, this action will be used to check persistence and restore
    any user-saved compositions onto the mixer state at launch time.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INIT`: 在应用启动时立即初始化混音。就像我们使用 `UserActions` 一样，这个动作将用于检查持久性并在启动时将任何用户保存的合成恢复到混音状态。'
- en: '`ADD`: Show the add new composition dialog.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`: 显示添加新合成对话框。'
- en: '`EDIT`: Edit a composition''s name by prompting a dialog.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EDIT`: 通过提示对话框编辑合成的名称。'
- en: '`SAVE`: Save compositions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SAVE`: 保存合成。'
- en: '`CANCEL`: General action to cancel out of any effect chain.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CANCEL`: 通用动作，用于取消任何效果链。'
- en: '`SELECT`: Select a composition. We will use this action to drive the Angular
    router to the main selected composition view.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`: 选择一个合成。我们将使用此动作来驱动 Angular 路由到主选定的合成视图。'
- en: '`OPEN_RECORD`: Handle the preparation of opening the recording view, including
    checking for authentication, pausing playback if playing, and opening in modal
    or routing to it.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPEN_RECORD`: 处理打开录音视图的准备，包括检查认证、暂停播放（如果正在播放）以及在模态中打开或将其路由到。'
- en: '`UPDATE`: Initiate an update to a composition.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE`: 启动对合成的更新。'
- en: '`UPDATED`: This will generally not be dispatched directly, but used at the
    end of an effect sequence that the reducer will pick up to finally change the
    mixer state.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATED`: 这通常不会直接分发，但会在效果序列的末尾使用，以便还原器最终更改混音状态。'
- en: 'Now, we can create the reducer that is similar to our user reducer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个与我们的用户还原器类似的还原器：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After this, let''s create our `MixerEffects` at `app/modules/mixer/effects/mixer.effect.ts`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在 `app/modules/mixer/effects/mixer.effect.ts` 中创建我们的 `MixerEffects`：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Probably, the most interesting effect is the`openRecord$` chain. We use `@Effect({
    dispatch: false })` to indicate that it should not dispatch any actions at the
    end as we are using it to execute work directly, such as checking whether the user
    is authenticated or if `activeComposition` contains tracks to conditionally open
    record view in a modal or as a route. We make use of another operator:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '可能最有趣的效果是 `openRecord$` 链。我们使用 `@Effect({ dispatch: false })` 来指示它不应该在末尾分发任何动作，因为我们正在使用它直接执行工作，例如检查用户是否已认证或
    `activeComposition` 是否包含轨道，以便有条件地在模态中打开记录视图或将其作为路由。我们使用了另一个操作符：'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This allows us to insert an arbitrary action without affecting the sequence
    of events. In this case, we ensure that playback is always paused when the user
    attempts to open a record view (since they can attempt to open the record view
    while playback is playing). We are presenting a few more advanced usage options
    with this chain, just to show what is possible. We are also stepping ahead a bit
    since we have not shown the creation of `PlayerActions` yet; however, we will
    just be presenting a couple of highlights in this chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们插入任意动作而不影响事件序列。在这种情况下，我们确保当用户尝试打开记录视图时播放总是暂停（因为他们在播放时可以尝试打开记录视图）。我们通过这个链提供了一些更高级的使用选项，只是为了展示什么是可能的。我们也在向前迈进，因为我们还没有展示
    `PlayerActions` 的创建；然而，我们将在本章中只展示几个亮点。
- en: 'With this effect chain, we can simplify our `MixerService` with the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个效果链，我们可以简化我们的 `MixerService`，如下所示：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've simplified the service logic, leaving most of the result handling work
    inside the effects chain. You might decide to leave the service with more logic and
    keep the effects chain simpler; however, we have designed this setup as an example
    to show more alternate setups with how flexible ngrx is.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简化了服务逻辑，将大部分结果处理工作留在了效果链中。你可能会决定在服务中保留更多逻辑，并保持效果链更简单；然而，我们设计这个设置作为一个示例，以展示ngrx的更多灵活设置。
- en: 'To finish up our lazy loaded state handling, ensure that these effects are
    run; when `MixerModule` loads, we can make these adjustments to the module:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的懒加载状态处理，确保这些效果被运行；当 `MixerModule` 加载时，我们可以对这些模块进行调整：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s look at how this improves our component handling, starting with `app/modules/mixer/components/mixer.component.ts`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这是如何改善我们的组件处理的，从 `app/modules/mixer/components/mixer.component.ts` 开始：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time, inside `ngOnInit`, we just set up the component to be reactive to
    our mixer's state by setting the composition to the `activeComposition`. This
    is guaranteed to always be whichever composition the user has currently selected
    and is working on. We dispatch our `OpenRecordAction` inside the `record` method,
    passing along the proper `ViewContainerRef` and a track if the user is rerecording.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在 `ngOnInit` 中，我们只是将组件设置为对混合器的状态做出响应，将组成设置为 `activeComposition`。这保证它总是用户当前选中并正在工作的任何组成。我们在
    `record` 方法内部触发 `OpenRecordAction`，传递适当的 `ViewContainerRef` 和一个跟踪，如果用户正在重新录制。
- en: 'Next up is the simplification of `app/modules/mixer/components/mix-list.component.ts`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对 `app/modules/mixer/components/mix-list.component.ts` 的简化：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have removed the `MixerService` injection and made it reactive by setting
    up a state Observable--`mixer$`--and integrated our `MixerActions`. This lightens
    up the component, making it easier to test and maintain since it no longer has
    an explicit dependency on the `MixerService`, which was previously being used
    for view bindings as well. If we take a look at the view, we can now utilize Angular''s
    async pipe to gain access to the user-saved compositions via the state:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了 `MixerService` 注入，并通过设置状态可观察对象--`mixer$`--使其变得响应式，并集成了我们的 `MixerActions`。这使得组件变得更轻量，更容易测试和维护，因为它不再有对
    `MixerService` 的显式依赖，之前它还被用于视图绑定。如果我们查看视图，我们现在可以利用Angular的异步管道通过状态访问用户保存的组成：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From the official documentation: Angular''s async pipe subscribes to an Observable
    or Promise and returns the latest value it has emitted. When a new value is emitted,
    the async pipe marks the component to be checked for changes. When the component
    gets destroyed, the async pipe unsubscribes automatically to avoid potential memory
    leaks.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档：Angular的异步管道订阅一个可观察对象或Promise，并返回它发出的最新值。当有新值发出时，异步管道标记组件以检查更改。当组件被销毁时，异步管道会自动取消订阅，以避免潜在的内存泄漏。
- en: This is truly remarkable and incredibly handy, allowing us to create reactive
    components that're highly maintainable and flexible.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实非常出色且极其方便，使我们能够创建高度可维护和灵活的响应式组件。
- en: Inspect the code! Exploring more on your own
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查代码！自行探索更多
- en: Since a lot of what we saw earlier are the exact same principles applied to
    the rest of our code base, instead of increasing the size of this book further,
    we invite you to explore the rest of the ngrx integration in the same chapter
    branch on the accompanying code repository to this book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前看到的大部分内容都是应用于我们代码库其余部分的相同原则，为了避免进一步增加本书的篇幅，我们邀请你探索本书附带的代码仓库中同一章节分支上的ngrx集成。
- en: Looking through the actual code, running it, and even stepping through it will
    hopefully give you a solid understanding of how ngrx fits into your app and the
    many advantages it can bring.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看实际代码、运行它，甚至逐步执行它，希望你能对ngrx如何融入你的应用以及它能够带来的许多优势有一个坚实的理解。
- en: The community is lucky to have members like Rob Wormald, Mike Ryan, Brian Troncone,
    Brandon Roberts, and more, who have helped make ngrx so nice to use, so a **huge
    thank you to all the contributors**!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 社区很幸运有像Rob Wormald、Mike Ryan、Brian Troncone、Brandon Roberts等成员，他们帮助使ngrx的使用变得如此愉快，因此向所有贡献者表示衷心的感谢！
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Hopefully, you are starting to see a pattern of simplification and clarity to
    the data flow while integrating ngrx. It has helped reduce code, while improving
    data flow by providing consistent effect chains to various actions, which may
    need to occur anywhere (from lazy loaded modules or not). By reducing the overhead
    of managing explicit injected dependencies throughout and instead relying on Store
    and Actions to initiate the appropriate work, we are increasing the maintainability
    and scalability of our app. On top of all that, it is paving a pathway to effective
    testability, which we will cover in [Chapter 12](part0136.html#41MCG0-289fe2426d594f99a90e4363b2c9c34d),
    *Unit Testing*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经开始在整合 ngrx 的过程中看到数据流简化和清晰化的模式。它通过为各种可能发生（从懒加载模块或非懒加载模块）的动作提供一致的效果链，帮助减少了代码量，并改善了数据流。通过减少管理显式注入依赖项的开销，并转而依赖
    Store 和 Actions 来启动适当的工作，我们正在提高我们应用的维护性和可扩展性。除此之外，它还在为有效的可测试性铺平道路，这将在第 12 章 [单元测试](part0136.html#41MCG0-289fe2426d594f99a90e4363b2c9c34d)中进行介绍。
- en: This chapter highlighted the additional advantages when combining NativeScript
    with Angular by opening up integration potential with rich libraries such as ngrx to
    improve our app's architecture and data flow.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章强调了将 NativeScript 与 Angular 结合使用时的额外优势，通过开放与丰富库如 ngrx 的集成潜力，以改善我们的应用架构和数据流。
- en: It's been a long time coming, and we couldn't be more excited about [Chapter
    11](part0131.html#3STPM0-289fe2426d594f99a90e4363b2c9c34d), *Polish with SASS*, coming
    up next. Finally, we are ready to polish our app to give it that special spark!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经期待已久，我们对即将到来的第 11 章 [Polish with SASS](part0131.html#3STPM0-289fe2426d594f99a90e4363b2c9c34d)
    感到无比兴奋。终于，我们准备好对我们的应用进行打磨，让它散发出那独特的火花！
