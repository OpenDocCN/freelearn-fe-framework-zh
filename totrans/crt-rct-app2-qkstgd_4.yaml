- en: Keep Your App Healthy with Tests and Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important part of any application developer's life is making sure that their
    application runs properly the first time, every time. That can be a difficult
    thing to do as applications get more complicated; what might have previously required
    just a few minutes and a single line of code to clean up or fix might instead
    start taking hours, days, or even weeks (or longer) to try to fix! In addition,
    if you're trying to build up your application and make it work cleanly and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The history of testing React applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different ways to run React tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to the test watcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The why and when of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering why we've started tackling our tests so late in our application.
    Generally speaking, when you're just starting out in your projects, you might
    wait a little bit to see how your application shakes out before you start verifying
    its behavior with tests. That being said, we're now also at a really good point
    to start shoring up our project and make it something that we can deploy to production
    with confidence!
  prefs: []
  type: TYPE_NORMAL
- en: The history of testing React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, it's great to understand the history of the toolset to understand why
    certain features or libraries are being used. When people were just getting started
    with React, ideas and standards around testing were absolutely all over the place.
    Some people used weird combinations of libraries that had all sorts of names,
    such as night-something, mocha, or some other random framework. You had to figure
    out mocking libraries, test harnesses, and user interface test frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: It was absolutely *exhausting*, and inevitably any framework and setup you were
    using would either fall out of favor or fall out of date and you'd have to turn
    around and start learning a new one every few weeks! Even worse, if you asked
    a ton of different people what their particular test setup was, you'd get at least
    that many different answers!
  prefs: []
  type: TYPE_NORMAL
- en: About Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest was the React team's answer to the constant question of *what test harness
    should we use for our React application?* You'd always get a different answer
    depending on who you asked, and sometimes you'd have to use multiple harnesses
    just to get features you wanted, which led to a ton of bloat and developer confusion
    about which one was the correct one to use at any given time!
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the structure of Jest tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best place for us to get started is to take a look at the default standard
    test that comes with any new Create React App project, and that is the test for
    our `App` component, located at `src/App.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, this isn''t a particularly *exciting* test by any stretch of the imagination.
    As the name implies, this test just verifies that the `App` component can be rendered
    on the page without any major hiccups or errors. This test might seem kind of
    superfluous, but it actually serves an incredibly important purpose: it remains
    as a sanity check for your application!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about it: if your main application or component couldn''t render without
    any other more complicated checks, then your project is very, very broken! It
    helps us check whether we''re accidentally excluding things or introducing significantly
    breaking changes to our project in a way that keeps us all sane! Let''s also verify
    that this actually does work the way we expect even with our changes right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, we should expect to see some output in our console window
    that tells us a little more about what tests were run, what tests passed, what
    failed, and other metadata about our test run as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2b2fb64-8cba-44a9-8349-019c80868546.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like that, clean and working tests! Now, that by itself is really cool,
    but let's take a few minutes to analyze the previous output window!
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the test output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right now, if we just look at the previous output without any context, it may
    not make a ton of sense! Let''s start off by taking a look at the first line after
    the test, which talks about our Test Suites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Jest allows us to run and organize our tests in a number of different and helpful
    ways! For example, our tests can be run by suites; suites being larger groupings
    of tests. We''ll explore this line of output a little further later on when we
    have more than a single test, but right now we only have one test suite, and thus
    we''ve only run a single test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We ran a single test, and that single test passed! This allows us to also keep
    track of what tests were run as our application code changed; we may not need
    to run every single test in every single suite across the board when we make minor
    changes! Instead, we can focus on the tests that would be affected by whatever
    the change was, so you may see this as being less than the total number of tests
    in your suites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Snapshots are a different feature entirely with Jest. Snapshots are a way to
    tell Jest that *given input X, the rendered component should look exactly like
    this*. We''ll explore this in greater detail later! The following line indicates
    how long our tests took to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is important to note, as sometimes you might introduce some code to your
    application that makes your application incredibly slow! This can help you catch
    those sneaky performance-ruining bits of code in your application. Your tests
    will essentially be your early-warning system against poorly-performing algorithms!
    We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get some output that tells us a little bit about what tests ran
    and what else we can do. We can also hit *w* here to get more options about what
    we can do with our test runner and watcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92a3d97a-e583-4719-9168-686a13069455.png)'
  prefs: []
  type: TYPE_IMG
- en: A development test workflow with the F key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we hit *w*, we get a new list of commands that we can run to continue with
    our test suite and do more for it. We've already explored these options a little
    bit, but it's worth reiterating the work that we can (and should) do during development
    and talk a little bit about *when* to use these tests as well!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first major one is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use this one *a lot*. Often when you''re developing complex applications
    you might introduce changes that break your test suite, or you might be going
    with more of a test-driven development approach, in which case you''ll be working
    with broken tests and then fixing things in your application or in your tests
    until the tests pass again! If that''s the case, you''ll be using this command
    a lot, so get comfortable with it early! If we try to run this now without any
    failed tests, we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes sense. We had no failed tests, so of course it wouldn''t find any
    and thus wouldn''t run any tests. We can make this work for us, though, by introducing
    a failing test intentionally and then running our full test suite, followed by
    just the failed tests! We can simulate this very quickly by returning back to
    `src/App.js` and commenting out the `export` statement at the bottom of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now if you restart your tests, you will get one failing test! We should be able
    to hit *F* and it will rerun the single failing test (and we can repeat this process
    over and over, as well). Now if we uncomment that line and save the file, if we
    rerun our test suite (either automatically or manually using *F*), we should be
    back to a fully-working test suite!
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another reason to get comfortable with rerunning failed tests: you
    should get comfortable with the idea of writing tests that intentionally fail
    until you make the test pass, or passes unless you comment or intentionally break
    the code! If you make code changes that should break your tests but the test still
    passes, that means your tests aren''t actually testing the behavior of your application
    correctly!'
  prefs: []
  type: TYPE_NORMAL
- en: It's time to add some new tests!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a pretty good understanding of our initial test, but there''s so much
    more we can learn by writing new tests! We''ll start off by testing the absolute
    simplest component that we''ve written so far: our `Todo` component! You''ll notice
    a pattern with how we have to name our tests to have Jest pick them up appropriately:
    we''ll create a test for our `Todo` component (in `src/Todo.js`) as `src/Todo.test.js`!
    We''ll almost always want to start off our tests by mimicking the structure in
    `App.test.js`, so we''ll start off by doing almost the same things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After rerunning our Test Suite (you may have to exit out of the test watcher
    with *Q* and rerun `yarn test`), you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bf82bda-648b-4260-8270-fdb8e35861e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So it ran our `src/Todo.test.js` test that we just added, and it''s a new test
    suite as well! Let''s expand out our tests since right now they''re not really
    doing anything. To do that, however, we''ll need to add a few more libraries to
    our test suite! We''ll want to add `enzyme` (for shallow rendering); `enzyme`
    is a React v16.x adapter, and React''s test `renderer` to our application. We
    can do so with one quick `yarn` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`enzyme` adds a lot to our test suite and makes it that much easier to work
    with, so it''s honestly worth it to include `enzyme` as a baseline to our test
    suite! In fact, it''s so helpful that it''s included on some of the default React/Jest
    test documentation! Now, just including these by themselves won''t do everything
    we need, so we''ll also need to create a test setup file to initialize Enzyme.
    Create `src/setupTests.js` and give it the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done that, we can start tackling some real test code! We''ll need to
    open up `src/Todo.test.js`, where we can add some code at the top which will give
    us the ability to take advantage of the `enzyme` shallow `renderer`! We''ll also
    need `react-test-renderer` of the `renderer()` function, since we''ll use that
    to create snapshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have everything we need to begin writing our tests. Before we start
    writing our tests, I generally begin by throwing all of our tests into a big `describe`
    function, so let''s start off there by moving the test that we already wrote inside
    of our `describe` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the tests and we should be back to green and two suites and two tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ec90fbe-3f03-486e-a24e-a9a01c10b22c.png)'
  prefs: []
  type: TYPE_IMG
- en: Describe is a way of blocking together related tests, whether by functionality,
    concept, or otherwise. You have a few ways to declare a describe block. You can
    either use a string to specify the name of a test, or you can use a valid `Class`
    or `Component` name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to start making our tests a little more complicated, we''ll
    also need to do some basic setup stuff, since if you remember from our `Todo`
    component, we have a few functions that need to get passed down into our child
    component. Let''s take a look at the default `props` of our `Todo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And the function body of the `removeTodo` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Description is easy; that's just a string that we need to pass in. `removeTodo(...)`,
    on the other hand, is more complicated. It's a function that doesn't live as part
    of this component; instead, it lives inside of the parent and is passed in! So,
    how do we deal with that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple, we can *mock* a function with Jest! Mocking a function basically makes
    a fake function that keeps track of when it''s called. We''ll also need to perform
    a **shallow render** of our component to verify how the component appears in the
    DOM overall. We''ll talk a little more about this in a minute, but for right now
    add the following at the top of the describe block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous example, `jest.fn()` allows us to create a
    mocked function. Mocking a function, as mentioned previously, doesn't do anything
    in particular. It pretends to be a function, sees who is trying to use that function,
    and also keeps track of things, such as fake arguments or sets up fake return
    values for the function. This is good if we want to verify that the `removeTodo`
    in our `props` actually does anything at all but we don't care that it performs
    a specific behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic snapshot test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Talking about writing tests is one thing, but let''s actually start implementing
    our tests. I typically approach test-writing in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a generic snapshot test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write some subcomponent-specific tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Snapshot tests can be used to verify initial state renders and renders after
    specific conditions are met. This works by grabbing a representation of your component,
    storing that, and then using it for future tests. This can be tricky when you
    have components that are changing constantly, but can be incredibly handy when
    your components are stable and shouldn''t be getting modified often. Let''s write
    our `snapshot` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the `renderer` we had to `import` from `react-test-renderer`? This
    is where we use it! We create a `Todo` component via JSX and pass that into the
    `renderer.create()` function. We then grab the component structure, transform
    it into JSON, and verify that it matches the appropriate snapshot from a previous
    run. This is another early warning system to help catch when someone changes the
    component but doesn''t do anything to update the tests! Let''s take a look at
    the results in our Test Suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dc30b06-4cdd-4310-bfd0-2ec10cd121d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing tests for content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll also need to make sure that when properties are passed in that modify
    what's displayed to the user, those properties actually make it into the fully-rendered
    function! We have a `description` variable that we already set at the top of our
    describe block. Before we jump too far, we need to write a quick test for our
    shallow render to make sure that is also working functionally!
  prefs: []
  type: TYPE_NORMAL
- en: What’s a shallow render?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A shallow render is basically just a fake render of the component where it
    only renders the root-level component and nothing else. It''s the most minimal
    rendition of any component that you can use for a test, so we should always use
    that before we jump into anything else! Let''s write our shallow render test first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple test. It just ensures that we render out a `div` with a CSS
    class of `Todo`, which is the root `div` that gets rendered when we instantiate
    our `Todo` component in JSX. Otherwise, there are no major surprises here! Following
    that, we''ll need to write some tests that make sure these `props` passed in make
    it into the `component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We already created the shallow rendered version of the `component`, so we're
    grabbing that component, analyzing the rendered `text` that would get added to
    the DOM if it were a real render, and then making sure that whatever we put in
    the description made it in there!
  prefs: []
  type: TYPE_NORMAL
- en: Testing interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step is to test the actual interactions in your component! We''ll
    need to be able to target each of our buttons, though. If you think back to our
    `Todo` component''s `render()` function, there are two buttons that get created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Without any modifications, it would actually be difficult for us to specifically
    target either of the actual buttons. We''ll want a way to target each `button`
    separately from each other, so let''s go into the `Todo` component and add a unique
    `className` to each button! Add `MarkDone className` to the first `button` and
    `RemoveTodo className` to the second `button` in the render function in `src/Todo.js`,
    just like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this code and the tests will rerun and it fails? But why? We haven''t
    changed the tests yet! Refer the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff519430-4309-4b51-b4a4-fe51e57b89d4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is actually doing exactly what it's supposed to! We made some modifications
    to our component that changed how the component got rendered out. In our case,
    we're totally okay with these changes, so we'll use another one of our test-watcher
    commands to update the `snapshot`! Hit *u* and our `snapshot` will get updated
    and our tests will go back to passing! Finally, we can go back to finishing up
    our tests for interaction!
  prefs: []
  type: TYPE_NORMAL
- en: Completing our interactivity tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can isolate each of the buttons, we can test what happens when
    each of them is clicked! We''ll need to start off by verifying our `MarkDone button`
    marks that `Todo` as done, which we can do via checking the `state`, as well!
    Let''s take a look at the test and then we''ll talk about what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The easiest way to reason about these tests is to say them out loud. If we were
    to test this behavior as a human, we'd say, find the button that marks the `Todo`
    as done, click on that button, and then we should expect that `Todo` to be complete!
    Our code does precisely that! It *finds* the component via a CSS selector that
    grabs the button that has a CSS class attached to it of `MarkDone` (remember our
    `render()` function changes earlier). We then simulate a `"click"` event sent
    to that `button` which targets the `onClick` handler. Finally, we have to use
    the `state()` function to grab a value out of the component's state, which for
    us is the `"done"` property in the `state`! If that's now `true`, then we're golden
    and our tests work!
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our mocked function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked a lot about our function mocks but then focused on a bunch of other
    tests; now it''s time for us to revisit our mocked function and actually test
    it out! Basically, all we need to do is to use a helper function to verify that
    our mock has been called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We had our `mockRemoveTodo` function that we had put back up in the top of
    our describe block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already seen the `simulate` call in a previous test, so all we do is
    create the expectation that our mock function has been called, and that''s it!
    With that, we have a very thorough test suite for our `Todo` component, and everything
    we do from here are just slightly more complicated variations of the same tests! Seven
    total Tests, two Test Suites, and one Snapshots test—all working perfectly! Refer
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1812bab-ea68-4fd4-8536-611a2b305a1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we move on, let''s verify the full test suite for `src/Todo.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's now add some tests for `TodoList` as well!
  prefs: []
  type: TYPE_NORMAL
- en: Adding tests for TodoList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start off by adding a framework to put the rest of our `TodoList` tests
    on! We''ll need our standard imports and tests for rendering, snapshots, and shallow
    components! We''ll start off with this scaffold for `src/TodoList.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We covered these tests previously, so there''s not much we''ll need to jump
    into, but we will want to make sure that, since our `render()` call includes a
    `NewTodo` component and we''ve imported that `component` at the top of our file,
    we have a test that verifies there''s a single `NewTodo` in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to verify how many `Todo` components appear in our `TodoList`,
    but there''s a little bit of a more complicated problem we have to solve with
    this test. If you remember, the state''s `"items"` property in `TodoList` determines
    what `Todo`s should appear, so we''ll check the state versus the component''s `find`
    function to see that the two are in sync with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `component` already gets rendered out via the `shallow()` call, so we''ll
    use the `state()` call to verify the length of the items and find the equal number
    of `Todo` components. We''ll also need to test our `addTodo` function of `TodoList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There's some new functionality in here that might be slightly complicated, so
    let's talk a little bit about it! We start off by finding out how many Todos already
    exist, since after we add another item we should expect that to be what we started
    with, plus another one! After that, we'll want to call `addTodo()` on the component,
    but to do that we need to jump down into the actual living context of `component`.
    We can do that via the `instance()` call, which allows us to call any function
    on the `component` without having to simulate any button clicks! After we call
    `addTodo`, we grab the list of all of the Todos that exist on the function and
    expect it to be more than what we originally started with! This is a really important
    and great way to write our tests; we never hardcode the number of Todos or anything
    else; instead, we check relative values after events happen! This eliminates weird
    scenarios where someone changes the default or initial state for our components
    and breaks our tests as a direct result!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to implement a `removeTodo` test, which is just the reverse
    operation from the test we previously wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The only notable difference is the fact that `removeTodo` needs an actual item
    to remove, so we have to grab one of the items out of the list and remove that
    specifically by passing that value into the `removeTodo` function!
  prefs: []
  type: TYPE_NORMAL
- en: 'After all is said and done, we should have a full test suite for `TodoList.test.js`
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Adding tests for NewTodo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At last, we can add our final test suite and make sure `NewTodo` is covered
    as well. For the most part, we''ll work with the same skeleton we already have
    and have used before. Create `src/NewTodo.test.js` and give it the following skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also want to modify the tests we wrote that check our content, since
    we should at least make sure that the there''s still a text field and a `button`
    as part of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also want to test our mocked `addTodo` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is essentially identical to what we did in the `Todo` component suite.
    We''ll need a test for our `handleUpdate` function, which should modify the `"item"
    state` property to the faked `input` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of the `handleUpdate` argument is a little wacky, so we need
    to make sure we''re passing in an object that''s compatible with the `handleUpdate`
    function that we wrote, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `state` function to verify that `"item"` now matches what we
    passed in! We''ll close out our test-writing escapade by verifying that when the
    button to add an item is clicked that the value in the `"item" state` key is reset
    to blank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We need to verify that we're being thorough with our test by making sure the
    component has a value first and then is reset to blank. If we don't, we wouldn't
    have any way to verify that our test was working the way we're expecting!
  prefs: []
  type: TYPE_NORMAL
- en: 'The full test suite is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result of all of our tests, if you''ve been following along, should
    be the following Test Suite results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/960d844d-732f-4983-8f63-9b2c25383d67.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is something that's absolutely critical to the overall health of your
    application! It ensures your development cycles are sane and your deploys are
    not incredibly dangerous. Your behavior can be tested, verified, and you can be
    confident in what your application is doing at any point in time without ever
    needing to open up a browser!
  prefs: []
  type: TYPE_NORMAL
- en: This is something that used to be a nightmare to do. The React test setup was
    a function that people generally hated given how much of a time commitment it
    took and how finicky it ended up being after the setup was done. One misstep or
    bad configuration change and the entire test harness framework could fall apart
    completely!
  prefs: []
  type: TYPE_NORMAL
- en: Be prepared to write a lot of tests if you write a production-ready React application!
    It's a great software engineering practice to be do whenever you're doing anything
    code-wise, and React is no different!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive into cleaning up the visual design of our project
    with the new CSS module and the SASS support that's built into Create React App's
    latest version, and we'll incorporate a major CSS framework as well!
  prefs: []
  type: TYPE_NORMAL
