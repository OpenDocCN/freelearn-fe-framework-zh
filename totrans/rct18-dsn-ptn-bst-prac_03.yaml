- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cleaning Up Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have prior experience with **JSX** (**JavaScript
    XML**) and are interested in improving your skills to use it effectively. To use
    JSX/TSX without any issues or unexpected behavior, it’s crucial to understand
    how it works under the hood and the reasons why it’s a useful tool for building
    UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Our objective is to write clean JSX/TSX code, maintain it, and have a good understanding
    of its inner workings, including how it’s translated to JavaScript and the features
    it provides.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the intricacies of JSX/TSX, you can leverage its full potential
    to build efficient and scalable UIs. We will explore various tips and techniques
    to help you write better code and avoid common mistakes. By the end of this chapter,
    you will have a solid grasp of how JSX/TSX works and how to use it effectively
    in your React applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX and why should we use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Babel and how can we use it to write modern JavaScript code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main features of JSX and the differences between HTML and JSX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices to write JSX in an elegant and maintainable way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How linting, and ESLint in particular, can make our JavaScript code consistent
    across applications and teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of functional programming and why following a functional paradigm
    will make us write better React components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 1*, we saw how React changes the concept of separation of concerns,
    moving the boundaries inside components. We also learned how React uses the elements
    returned by the components to display the UI on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at how we can declare elements inside our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'React provides two ways to define elements. The first one is by using JavaScript
    functions, and the second one is by using JSX, an optional XML-like syntax. The
    following is a screenshot of the new official documentation of React.js ([https://react.dev](https://react.dev)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website  Description automatically generated](img/B18414_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: New official documentation site of React.js'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, JSX is one of the main reasons why people fail to approach React,
    because looking at the examples on the home page and seeing JavaScript mixed with
    HTML for the first time can seem strange to most of us.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we get used to it, we realize that it is very convenient, precisely
    because it is similar to HTML and looks very familiar to anyone who has already
    created UIs on the web. The opening and closing tags make it easier to represent
    nested trees of elements, something that would have been unreadable and hard to
    maintain using plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at JSX in more detail in the following sub-sections.
  prefs: []
  type: TYPE_NORMAL
- en: Babel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Babel is a popular JavaScript compiler widely used in the React community. It
    allows developers to write code using the latest language features, such as JSX
    and ES6, that may not yet be supported in all browsers. By transpiling the code
    into the more widely supported ES5, Babel ensures that your application runs smoothly
    across different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Babel, you’ll first need to install the necessary packages. In older
    versions (Babel 6.x), you would install the `babel-cli` package, which included
    **babel-node** and **babel-core**. However, in more recent versions, these packages
    have been separated into individual modules: `@babel/core`, `@babel/cli`, `@babel/node`,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Babel, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the required packages globally (although local installations are generally
    preferred):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To compile a JavaScript file using Babel, run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Babel is highly configurable, and you can customize it using presets. To install
    the most common presets, run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `.babelrc` configuration file in your project’s root directory and
    add the following content to tell Babel to use the installed presets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can write ES6 and JSX in your source files, and Babel will transpile
    them into browser-compatible ES5 JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our environment supports JSX, let’s explore a basic example: creating
    a `div` element. Using the `_jsx` function, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using JSX, we can simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This appears similar to regular HTML, but the crucial difference is that we’re
    writing markup within a `.js` file. Keep in mind that JSX is only syntactic sugar
    and gets transpiled into JavaScript before being executed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: When we run Babel, our `<div />` element is translated into `_jsx('div', {})`.
    Remember this when crafting templates.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from **React 17**, `React.createElement('div')` has been deprecated,
    and the library now uses `react/jsx-runtime` internally to render JSX. This means
    that you no longer need to import the React object to write JSX code. Instead,
    you can write JSX directly, as shown in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: DOM elements and React components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSX allows us to create both HTML elements and React components, with the only
    difference being whether or not they start with a capital letter. For instance,
    to render an HTML button, we use `<button />`, while to render the `Button` component,
    we use `<Button />`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first button is transpiled into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one is transpiled into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The key difference is that in the first call, we pass the type of the DOM element
    as a string, while in the second call, we pass the component itself. As a result,
    the component should exist in the scope for it to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: JSX also supports self-closing tags, which are useful for keeping the code concise
    and avoiding unnecessary tag repetition.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX is very convenient when your DOM elements or React components have props.
    Using XML is pretty easy to set attributes on elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent in JavaScript would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is far less readable, and even with only a couple of attributes, it is
    harder to read without a bit of reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: Children
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX allows you to define children to describe the tree of elements and compose
    complex UIs. A basic example is a link with text inside it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be transpiled into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our link can be enclosed inside a `div` element for some layout requirements,
    and the JSX snippet to achieve that is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript equivalent is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It should now be clear how the *XML-like* syntax of JSX makes everything more
    readable and maintainable, but it is always important to know the JavaScript parallel
    to our JSX has control over the creation of elements. The good part is that we
    are not limited to having elements as children of elements, but we can use JavaScript
    expressions, such as functions or variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we have to enclose the expression within curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies to non-string attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you see, any variable or function should be enclosed in curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Differences with HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have looked at the similarities between JSX and HTML. Let’s now look
    at the little differences between them and the reasons they exist.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must always keep in mind that JSX is not a standard language and that it
    gets transpiled into JavaScript. Because of this, some attributes cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, instead of `class`, we have to use `className`, and instead of
    `for`, we have to use `htmlFor`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that `class` and `for` are reserved words in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pretty significant difference is the way the `style` attribute works. We will
    look at how to use it in more detail in *Chapter 6*, *Making Your Components Look
    Beautiful*, but now we will focus on the way it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `style` attribute does not accept a CSS string as the HTML parallel does,
    but it expects a JavaScript object where the style names are *camelCased*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you can pass an object to the `style` prop, meaning you can
    even have your styles in a separate variable if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the best way to have better control of your inline styles.
  prefs: []
  type: TYPE_NORMAL
- en: Root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important difference with HTML worth mentioning is that since JSX elements
    get translated into JavaScript functions, and you cannot return two functions
    in JavaScript, whenever you have multiple elements at the same level, you are
    forced to wrap them in a parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Before, React forced you to return an element wrapped with an `<div>` element
    or any other tag; since **React 16.2.0**, it is possible to return an array directly
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can even return a string directly, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, React now has a new feature called `Fragment` that also works as a special
    wrapper for elements. It can be specified with `React.Fragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use empty tags (`<></>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`Fragment` won’t render anything visible on the DOM; it is just a helper tag
    to wrap your React elements or components.'
  prefs: []
  type: TYPE_NORMAL
- en: Spaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s one thing that could be a little bit tricky in the beginning and, again,
    it concerns the fact that we should always keep in mind that JSX is not HTML,
    even if it has XML-like syntax. JSX handles the spaces between text and elements
    differently from HTML, in a way that’s counter-intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In a browser that interprets HTML, this code would give you `My name is Carlos`,
    which is exactly what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JSX, the same code would be rendered as `MynameisCarlos`, which is because
    the three nested lines get transpiled as individual children of the `div` element,
    without taking the spaces into account. A common solution to get the same output
    is putting a space explicitly between the elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, we are using an empty string wrapped inside a JavaScript
    expression to force the compiler to apply a space between the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A couple more things are worth mentioning before really starting regarding the
    way you define Boolean attributes in JSX.
  prefs: []
  type: TYPE_NORMAL
- en: If you set an attribute without a value, JSX assumes that its value is `true`,
    following the same behavior as the HTML `disabled` attribute, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if we want to set an attribute to `false`, we have to declare
    it explicitly as `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is another example of the Boolean attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This can be confusing in the beginning, because we may think that omitting an
    attribute would mean `false`, but it is not like that. With React, we should always
    be explicit to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Spread attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important feature is the `spread attribute` operator (`...`), which comes
    from the rest/spread properties for ECMAScript “proposal” and is very convenient
    whenever we want to pass all the attributes of a JavaScript object to an element.
  prefs: []
  type: TYPE_NORMAL
- en: A common practice that leads to fewer bugs is not to pass entire JavaScript
    objects down to children by reference, but to use their primitive values, which
    can be easily validated, making components more robust and error-proof.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gets transpiled into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Template literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Template`literals are string literals that allow for embedded expressions,
    multiline strings, and string interpolation. They are enclosed by the backtick
    (``) character instead of single or double quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most useful features of template literals is the ability to include
    placeholders using the dollar sign and curly braces `(${expression}`). This allows
    us to easily interpolate variables or complex expressions into our string templates.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In addition to string interpolation, template literals also support multiline
    strings, making it easier to write and read complex strings without needing to
    concatenate multiple strings with the plus (`+`) operator.
  prefs: []
  type: TYPE_NORMAL
- en: Common patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how JSX works and can master it, we are ready to see how to
    use it in the right way following some useful conventions and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with a very simple one. As stated previously, one of the main reasons
    we should prefer JSX over React’s `_jsx` function is because of its XML-like syntax,
    and because balanced opening and closing tags are perfect to represent a tree
    of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we should try to use it in the right way and get the most out of
    it. One example is as follows; whenever we have nested elements, we should always
    go multiline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is preferable to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception is if the children are not elements such as text or variables.
    In that case, it makes sense to remain on the same line and avoid adding noise
    to the markup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Always remember to wrap your elements inside parentheses when you write them
    on multiple lines. JSX always gets replaced by functions, and functions written
    on a new line can give you an unexpected result because of automatic semicolon
    insertion. Suppose, for example, that you are returning JSX from your render method,
    which is how you create UIs in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example works fine because the `div` element is on the same line
    as the `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following, however, is not right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that you would then have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why you have to wrap the statement in parentheses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Multi-properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common problem in writing JSX comes when an element has multiple attributes.
    One solution is to write all the attributes on the same line, but this would lead
    to very long lines that we do not want in our code (see the following section
    for how to enforce coding style guides).
  prefs: []
  type: TYPE_NORMAL
- en: 'A common solution is to write each attribute on a new line, with one level
    of indentation, and then align the closing bracket with the opening tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Conditionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Things get more interesting when we start working with `conditionals`, for example,
    if we want to render some components only when certain conditions are matched.
    The fact that we can use JavaScript in our conditions is a big plus, but there
    are many ways to express conditions in JSX, and it is important to understand
    the benefits and problems of each one of these to write code that is both readable
    and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to show a logout button only if the user is currently logged
    in to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple snippet to start with is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This works, but it is not very readable, especially if there are multiple components
    and multiple conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JSX, we can use an inline condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This works because if the condition is `false`, nothing gets rendered, but if
    the condition is `true`, the `createElement` function of `LoginButton` gets called,
    and the element is returned to compose the resulting tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the condition has an alternative (the classic `if...else` statement) and
    we want, for example, to show a logout button if the user is logged in and a login
    button otherwise, we can use JavaScript’s `if...else` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, and better still, we can use a ternary condition that makes
    the code more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the ternary condition used in popular repositories, such as the
    Redux real-world example ([https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28](https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js#L28)),
    where the ternary is used to show a `Loading` label if the component is fetching
    the data or `Load More` inside a button depending on the value of the `isFetching`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now look at the best solution for when things get more complicated and,
    for example, we have to check more than one variable to determine whether to render
    a component or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, it is clear that using the inline condition is a good solution,
    but the readability is strongly impacted. Instead, we can create a helper function
    inside our component and use it in JSX to verify the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this change makes the code more readable and the condition more
    explicit. If you look at this code in 6 months, you will still find it clear just
    by reading the name of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies to computed properties. Suppose you have two single properties
    for currency and value. Instead of creating the price string inside `render`,
    you can create a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is better because it is isolated, and you can easily test it if it contains
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to conditional statements, we can create a custom component and
    call it `RenderIf` to render our components conditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then easily use it in our projects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common operation in UI development is to display lists of items. When
    it comes to showing lists, using JavaScript as a template language is a very good
    idea.
  prefs: []
  type: TYPE_NORMAL
- en: If we write a function that returns an array inside our JSX template, each element
    of the array gets compiled into an element.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen before, we can use any JavaScript expressions inside curly braces,
    and the most common way to generate an array of elements, given an array of objects,
    is to use `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into a real-world example. Suppose you have a list of users, each
    one with a `name` property attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an unordered list to show the users, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This snippet is incredibly simple and incredibly powerful at the same time,
    where the power of HTML and JavaScript converge.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth stressing that we always want to keep our components very small
    and our render methods very clean and simple.
  prefs: []
  type: TYPE_NORMAL
- en: However, that is not an easy goal, especially when you are creating an application
    iteratively, and in the first iteration, you are not sure exactly how to split
    the components into smaller ones. So, what should we be doing when the `render`
    method becomes too big to maintain? One solution is to split it into smaller functions
    in a way that lets us keep all the logic in the same component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is not always considered best practice because it seems more obvious to
    split the component into smaller ones. However, sometimes it helps to keep the
    render method cleaner. For example, in the Redux real-world examples, a sub-render
    method is used to render the *load more* button.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are JSX power users, it is time to move on and see how to follow
    a style guide within our code to make it consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Styling code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to implement **EditorConfig** and **ESLint**
    to improve your code quality by validating your code style. It is important to
    have a standard code style in your team and avoid using different code styles.
  prefs: []
  type: TYPE_NORMAL
- en: EditorConfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**EditorConfig** helps developers to maintain consistent coding styles between
    different IDEs.'
  prefs: []
  type: TYPE_NORMAL
- en: EditorConfig is supported by a lot of editors. You can check whether your editor
    is supported or not on the official website, [https://www.editorconfig.org](https://www.editorconfig.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to create a file called `.editorconfig` in your `root` directory –
    the configuration I use is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can affect all the files with `[*]`, and specific files with `[.extension]`.
  prefs: []
  type: TYPE_NORMAL
- en: Prettier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Prettier** is an opinionated code formatter, supported by many languages,
    that can be integrated with most editors. This plugin is really useful because
    you can format the code on saving and you don’t need to discuss the code style
    in code reviews, which will save you a lot of time and energy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you work with Visual Studio Code, you have to install the Prettier extension
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text, website  Description automatically generated](img/B18414_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Prettier – Code formatter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you want to configure the option to format when you save a file, you
    need to go to **Settings**, search for `Format` `on` `Save`, and check that option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Configuring option to format when saving a file'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will affect all your projects because it is a global setting. If you want
    to apply this option just in a specific project, you have to create a `.vscode`
    folder inside your project and a `settings.json` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can configure the options you want in your `.prettierrc` file – this
    is the configuration I normally use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will help you or your team to standardize the code style.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing high-quality code is always our goal, but errors can still occur, and
    spending hours hunting down a bug caused by a simple typo can be incredibly frustrating.
    Thankfully, there are tools that can help us catch these errors as soon as we
    type them, allowing us to avoid simple syntactical mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re coming from a statically typed language like C#, you may be used to
    getting warnings inside your IDE. In the JavaScript world, the popular tool for
    linting code is ESLint. ESLint is an open-source project released in 2013 that
    is highly configurable and extensible.
  prefs: []
  type: TYPE_NORMAL
- en: In the fast-paced JavaScript ecosystem, where libraries and techniques change
    frequently, it’s crucial to have a tool that can be easily extended with plugins
    and rules that can be enabled or disabled as needed. Additionally, with transpilers
    like Babel and experimental language features that aren’t yet part of the standard
    JavaScript version, we need to be able to tell our linter which rules we’re following
    in our source files. A linter not only helps us catch errors sooner, but it also
    enforces common coding style guides, which is particularly important in large
    teams where consistency is key.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll take a closer look at ESLint and how it can
    help us write better, more consistent code.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, we have to install ESLint and some plugins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the executable is installed, we can run it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The output will tell us if there are errors within the file.
  prefs: []
  type: TYPE_NORMAL
- en: When we install and run it for the first time, we do not see any errors because
    it is completely configurable, and it does not come with any default rules.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start configuring ESLint. It can be configured using a `.eslintrc` file
    that lives in the root folder of the project. To add some rules, let’s create
    a `.eslintrc` file configured for TypeScript and add one basic rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration file needs a bit of explanation: `"semi"` is the name of
    the rule and `[2, "never"]` is the value. It is not very intuitive the first time
    you see it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ESLint rules have three levels that determine the severity of the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '`off` (or `0`): The rule is disabled.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`warn` (or `1`): The rule is a warning.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`error` (or `2`): The rule throws an error.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using the value `2` because we want ESLint to throw an error every time
    our code does not follow the rule. The second parameter tells ESLint that we want
    the semicolon to never be used (the opposite is *always*). ESLint and its plugins
    are very well documented, and for any single rule, you can find the description
    of the rule and some examples of when it passes and when it fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create an `index.ts` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run `eslint index.js`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is great; we set up the linter and it is helping us follow our first rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are other rules that I prefer to turn off or change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Git Hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid having unlinted code in our repository, what we can do is add ESLint
    at one point of our process using Git Hooks. For example, we can use `husky` to
    run our linter in a Git Hook called `pre-commit`, and it is also useful to run
    our unit tests on the Hook called `pre-push`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `husky`, you need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Then, in our `package.json` file, we can add this node to configure the tasks
    we want to run in the Git Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `package.json >` `prepare` script and run it once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There is a special option (flag) for the ESlint command called `--fix` – with
    this option, ESLint will try to fix all our linter errors automatically (not all
    of them). Be careful with this option because sometimes it can affect a little
    bit of our code style. Another useful flag is `--ext` to specify the extensions
    of the files we want to validate – in this case, just the `.tsx` and `.ts` files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about how **functional programming** (**FP**)
    works and topics such as first-class objects, purity, immutability, currying,
    and composition.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to following best practices and using a linter to catch errors and
    enforce consistency, another way to clean up our code is to adopt an **FP** style.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in *Chapter 1,* *Taking Your First Steps with React*, React’s
    declarative programming approach makes our code more readable. FP is a declarative
    paradigm as well, where side effects are avoided, and data is considered immutable
    to make the code easier to maintain and reason about.
  prefs: []
  type: TYPE_NORMAL
- en: While we won’t cover FP in depth in this section, we’ll introduce some concepts
    commonly used in React that you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: FP principles, such as immutability, pure functions, and higher-order functions,
    can help us write more maintainable and testable code. By treating our data as
    immutable, we can avoid side effects and make it easier to reason about the flow
    of our application. Pure functions, which always return the same output for the
    same input, help us avoid unintended side effects and make our code easier to
    test. Higher-order functions, which take functions as arguments and/or return
    functions as output, can help us create more modular and reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: By adopting an FP style, we can write more declarative and less imperative code,
    making our components easier to read and reason about.
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has first-class functions because they are treated like any other
    variable, meaning you can pass a function as a parameter to other functions, or
    it can be returned by another function and be assigned as a value to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to introduce the concept of **Higher-Order Functions** (**HoFs**).
    HoFs are functions that take a function as a parameter, and optionally some other
    parameters, and return a function. The returned function is usually enhanced with
    some special behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, a function is adding two numbers that enhance a function that logs all
    the parameters and then executes the original function.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is pretty important to understand because, in the React world,
    a common pattern is to use Higher-Order Components to treat our components as
    functions, and to enhance them with common behaviors. We will see HOCs and other
    patterns in *Chapter 4,* *Exploring Popular Composition Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Purity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important aspect of FP is to write pure functions. You will encounter this
    concept very often in the React ecosystem, especially if you look into libraries
    such as Redux.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean for a function to be pure?
  prefs: []
  type: TYPE_NORMAL
- en: A function is pure when there are no side effects, which means that the function
    does not change anything that is not local to the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a function that changes the state of an application, or modifies
    variables defined in the upper scope, or a function that touches external entities,
    such as the **Document Object Model** (**DOM**), is considered impure. Impure
    functions are harder to debug, and most of the time it is not possible to apply
    them multiple times and expect to get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following function is pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It can be run multiple times, always getting the same result, because nothing
    is stored anywhere, and nothing gets modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function is not pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Running `add(1)` twice, we get two different results. The first time we get
    `1`, but the second time we get `2`, even if we call the same function with the
    same parameter. The reason we get that behavior is that the global state gets
    modified after every execution.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to write pure functions that don’t mutate the state, but what
    if we need to change the value of a variable? In FP, a function, instead of changing
    the value of a variable, creates a new variable with a new value and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: This way of working with data is called **immutability**.
  prefs: []
  type: TYPE_NORMAL
- en: An immutable value is a value that cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function doesn’t follow immutability because it changes the value
    of the given array. Again, if we call the same function twice, we get different
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the preceding function to make it immutable using `concat`, which
    returns a new array without modifying the given one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: After we have run the function twice, `myArr` still has its original value.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common technique in FP is currying. `Currying` is the process of converting
    a function that takes multiple arguments into a function one argument at a time
    and returning another function. Let’s look at an example to clarify the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the `add` function we have seen before and transform it into
    a curried function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instead define the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty convenient way of writing functions because, since the first
    value is stored after the application of the first parameter, we can reuse the
    second function multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, an important concept in FP that can be applied to React is **composition**.
    Functions (and components) can be combined to produce new functions with more
    advanced features and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions can be composed together to create a new function that adds
    two numbers and then doubles the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Following this paradigm, we end up with small, simple, testable pure functions
    that can be composed together.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the fundamentals of JSX, including its syntax
    and features. We have also learned how to configure Prettier and ESLint to maintain
    consistency and catch errors early on in our codebase. Additionally, we have explored
    some essential concepts of functional programming, which can help us write more
    maintainable and testable code.
  prefs: []
  type: TYPE_NORMAL
- en: With our code now clean and well-organized, we are ready to dive deeper into
    React and learn how to write truly reusable components in the next chapter. By
    following best practices and adopting good coding habits, we can create React
    applications that are easier to maintain, scale, and test.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2450023176943770109.png)'
  prefs: []
  type: TYPE_IMG
