- en: Continuous Integration and API Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和API设计
- en: Before we start building more complicated features for our LOB app, LemonMart,
    we need to ensure that every code push we create has passing tests, adheres to
    the coding standards, and is an executable artifact that team members can run
    tests against, as we continue to further develop our application. Simultaneously,
    we need to start thinking about how our application will communicate with a backend
    server. Whether you, your team, or another team will be creating the new APIs,
    it will be important that the API design accommodates the needs of both the frontend
    and backend architectures. To ensure a smooth development process, a robust mechanism
    is needed to create an accessible, living piece of documentation for the API.
    **Continuous Integration** (**CI**) can solve the first problem and Swagger is
    perfect to address API design, documentation, and testing needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为我们的LOB应用LemonMart构建更复杂的功能之前，我们需要确保我们创建的每个代码推送都通过了测试，符合编码标准，并且是团队成员可以运行测试的可执行构件，因为我们继续进一步开发我们的应用。同时，我们需要开始考虑我们的应用将如何与后端服务器进行通信。无论是您、您的团队还是其他团队将创建新的API，都很重要的是API设计能够满足前端和后端架构的需求。为了确保开发过程顺利进行，需要一个强大的机制来为API创建一个可访问的、实时的文档。**持续集成**（**CI**）可以解决第一个问题，而Swagger非常适合解决API设计、文档和测试需求。
- en: Continuous Integration is critical to ensuring a quality deliverable by building
    and executing tests on every code push. Setting up a CI environment can be time
    consuming and requires specialized knowledge of the tool being used. CircleCI
    is an established, cloud-based CI service with a free tier and helpful articles
    to get you started with as little configuration as possible. We will go over a
    Docker-based approach that can be run on most CI services, keeping your specific
    configuration knowledge relevant and CI service knowledge down to a minimum.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成对于确保质量可交付成果至关重要，它会在每次代码推送时构建和执行测试。建立CI环境可能会耗费时间，并需要对所使用的工具有专门的知识。CircleCI是一个成熟的基于云的CI服务，拥有免费的套餐和有用的文章，可以让您尽可能少地进行配置就能开始使用。我们将介绍一种基于Docker的方法，可以在大多数CI服务上运行，使您的特定配置知识保持相关，并将CI服务知识降至最低。
- en: Another aspect of full-stack development is that you will likely be developing
    the frontend and backend of your application around the same time. Whether you
    work by yourself, as a team, or with multiple teams, it is critical to establish
    a data contract to ensure that you won't run into eleventh-hour integration challenges.
    We will use Swagger to define a data contract for a REST API and then create a
    mock server that your Angular application can make HTTP calls to. For backend
    development, Swagger can act as a great starting point to generate boilerplate
    code and can go forward as living documentation and testing UI for your API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈开发的另一个方面是，您可能会同时开发应用程序的前端和后端。无论您是独自工作，还是与团队或多个团队合作，建立数据契约都是至关重要的，以确保您不会在最后关头遇到集成挑战。我们将使用Swagger为REST
    API定义数据契约，然后创建一个模拟服务器，您的Angular应用程序可以向其发出HTTP调用。对于后端开发，Swagger可以作为生成样板代码的良好起点，并且可以作为API的实时文档和测试UI。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: CI with CircleCI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CircleCI的CI
- en: API design with Swagger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Swagger进行API设计
- en: 'This chapter requires the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: A free CircleCI account
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的CircleCI账户
- en: Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Continuous Integration
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: The aim of Continuous Integration is to enable a consistent and repeatable environment
    to build, test, and generate deployable artifacts of your application with every
    code push. Before a pushing code, a developer should have a reasonable expectation
    that their build will pass; therefore creating a reliable CI environment that
    automates commands that developers can also run in their local machines is paramount.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成的目标是在每次代码推送时实现一致且可重复的环境，用于构建、测试和生成可部署的应用程序成果。在推送代码之前，开发人员应该合理地期望他们的构建会通过；因此，创建一个可靠的持续集成环境，自动化开发人员也可以在本地机器上运行的命令是至关重要的。
- en: Containerizing build environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建环境容器化
- en: In order to ensure a consistent build environment across various OS platforms,
    developer machines, and Continuous Integration environments, you may containerize
    your build environment. Note that there are at least half-a-dozen common CI tools
    currently in use. Learning the ins and outs of each tool is almost an impossible
    task to achieve. Containerization of your build environment is an advanced concept
    that goes above and beyond of what is currently expected of CI tools. However,
    containerization is a great way to standardize over 90% of your build infrastructure,
    and can be executed in almost any CI environment. With this approach, the skills
    you learn and the build configuration you create becomes far more valuable, because
    both your knowledge and the tools you create become transferable and reusable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保跨各种操作系统平台、开发者机器和持续集成环境的一致构建环境，您可以将构建环境容器化。请注意，目前至少有半打常见的持续集成工具在使用中。学习每个工具的细节几乎是一项不可能完成的任务。构建环境的容器化是一个高级概念，超出了当前持续集成工具的预期。然而，容器化是标准化您的构建基础设施的绝佳方式，几乎可以在任何持续集成环境中执行。通过这种方法，您学到的技能和创建的构建配置变得更有价值，因为您的知识和创建的工具都变得可转移和可重复使用。
- en: There are many strategies to containerize your build environment with different
    levels of granularity and performance expectations. For the purpose of this book,
    we will focus on reusability and ease of use. Instead of creating a complicated,
    interdependent set of Docker images that may allow for more efficient fail-first
    and recovery paths, we will focus on a single and straightforward workflow. Newer
    versions of Docker have a great feature called multi-stage builds, which allow
    you to define a multi image process in an easy-to-read manner and maintain a singular `Dockerfile`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多策略可以将构建环境容器化，具有不同的粒度和性能期望。对于本书的目的，我们将专注于可重用性和易用性。我们将专注于一个简单和直接的工作流程，而不是创建一个复杂的、相互依赖的一组Docker映像，这可能允许更有效的失败优先和恢复路径。较新版本的Docker具有一个很棒的功能，称为多阶段构建，它允许您以易于阅读的方式定义多个映像过程，并维护一个单一的`Dockerfile`。
- en: At the end of the process, you can extract an optimized container image as our
    deliverable artifact, shedding the complexity of images used previously in the
    process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在流程结束时，您可以提取一个优化的容器映像作为我们的交付成果，摆脱先前流程中使用的映像的复杂性。
- en: 'As a reminder your single `Dockerfile` would look like the sample below:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，您的单个`Dockerfile`将类似于下面的示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Multi-stage works by using multiple `FROM` statements in a single `Dockerfile`,
    where each stage can perform a task and make any resources within its instance
    available to other stages. In a build environment, we can implement various build-related
    tasks as their own stages, and then copy the end result, such as the `dist` folder
    of an Angular build to the final image, which contains a web server. In this case,
    we will implement three stages of images:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段工作是通过在单个`Dockerfile`中使用多个`FROM`语句来实现的，其中每个阶段可以执行一个任务，并使其实例内的任何资源可用于其他阶段。在构建环境中，我们可以将各种与构建相关的任务实现为它们自己的阶段，然后将最终结果，例如
    Angular 构建的`dist`文件夹，复制到包含 Web 服务器的最终镜像中。在这种情况下，我们将实现三个阶段的镜像：
- en: '**Builder**: Used to build a production version of your Angular app'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建器**：用于构建 Angular 应用程序的生产版本'
- en: '**Tester**: Used to run unit and e2e tests against a headless Chrome instances'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试器**：用于对无头 Chrome 实例运行单元测试和端到端测试'
- en: '**Web Server**: The final result only containing the optimized production bits'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 服务器**：最终结果仅包含优化的生产位'
- en: Multi-stage builds require Docker version 17.05 or higher. To read more about
    multi-stage builds, read the documentation at [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建需要 Docker 版本 17.05 或更高版本。要了解有关多阶段构建的更多信息，请阅读[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)中的文档。
- en: Start by creating a new file to implement the multi-stage configuration, named
    `Dockerfile.integration`, at the root of your project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个新文件开始，以实现多阶段配置，命名为`Dockerfile.integration`，位于项目的根目录。
- en: Builder
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建器
- en: 'The first stage is `builder`. We need a lightweight build environment that
    can ensure consistent builds across the board. For this purpose, I''ve created
    a sample Alpine-based Node build environment complete with npm, bash, and git
    tools. For more information on why we''re using Alpine and Node, refer to [Chapter
    3,](4e68114e-68b7-4fe6-a853-81347e981667.xhtml)* Prepare Angular App for Production
    Release*, in the *Containerizing the App using Docker* section:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段是`构建器`。我们需要一个轻量级的构建环境，可以确保一致的构建。为此，我创建了一个基于 Alpine 的 Node 构建环境示例，其中包含 npm、bash
    和 git 工具。有关为什么我们使用 Alpine 和 Node 的更多信息，请参阅[第 3 章](4e68114e-68b7-4fe6-a853-81347e981667.xhtml)*准备
    Angular 应用程序进行生产发布*，*使用 Docker 容器化应用程序*部分。
- en: 'Implement a new npm script to build your Angular app:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的 npm 脚本来构建你的 Angular 应用程序：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inherit from a Node.js based build environment like `node:10.1`  or `duluca/minimal-node-build-env:8.11.2`
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基于 Node.js 的构建环境继承，如`node:10.1`或`duluca/minimal-node-build-env:8.11.2`
- en: 'Implement your environment specific build script, as shown here:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现你的特定环境构建脚本，如下所示：
- en: Note that at the time of publishing a bug in low-level npm tooling is preventing `node` based
    images  from successfully installing Angular dependencies. This means that the
    sample `Dockerfile` below is based on an older version of Node and npm with `duluca/minimal-node-build-env:8.9.4`.
    In the future, when the bugs are sorted out an updated build environment will
    be able to leverage `npm ci` to install dependencies, which brings significant
    speed gains over the `npm install` command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在发布时，低级 npm 工具中的一个错误阻止了基于`node`的镜像成功安装 Angular 依赖项。这意味着下面的示例`Dockerfile`基于较旧版本的
    Node 和 npm，使用了`duluca/minimal-node-build-env:8.9.4`。在将来，当错误得到解决时，更新的构建环境将能够利用`npm
    ci`来安装依赖项，这将比`npm install`命令带来显著的速度提升。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, the source code is being pulled from GitHub by the
    container. I have chosen to do that for the sake of keeping the sample simple,
    because it works the same way in both local and remote continuous integration
    environments. However, your CI server will already have a copy of the source code,
    which you'll want to copy from your CI environment and then into the container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，容器正在从GitHub拉取源代码。我选择这样做是为了保持示例简单，因为在本地和远程持续集成环境中它的工作方式是相同的。然而，您的持续集成服务器将已经有源代码的副本，您需要从持续集成环境中复制然后放入容器中。
- en: Instead of the `RUN git clone $GIT_REPO .` command, you can copy source code
    with the `COPY $SRC_CODE_LOCATION .` command from your CI server or your local
    machine. If you do this, you will have to implement a `.dockerignore` file that
    somewhat resembles your `.gitignore` file to ensure that secrets aren't leaked,
    `node_modules` is not copied and the configuration is repeatable in other environments.
    In a CI environment, you will want to override the environment variable `$SRC_CODE_LOCATION` so
    that the source directory of the `COPY` command is correct. Feel free to create
    multiple versions of the `Dockerfile` that may fit your various needs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`COPY $SRC_CODE_LOCATION .`命令从持续集成服务器或本地计算机复制源代码，而不是使用`RUN git clone $GIT_REPO
    .`命令。如果这样做，您将需要实现一个`.dockerignore`文件，它与您的`.gitignore`文件有些相似，以确保不会泄露机密信息，不会复制`node_modules`，并且配置在其他环境中是可重复的。在持续集成环境中，您将需要覆盖环境变量`$SRC_CODE_LOCATION`，以便`COPY`命令的源目录是正确的。随时创建多个适合您各种需求的`Dockerfile`版本。
- en: In addition, I have built a minimal Node build environment `duluca/minimal-node-build-env` based
    on `node-alpine`, which you can observe on Docker Hub at [https://hub.docker.com/r/duluca/minimal-node-build-env](https://hub.docker.com/r/duluca/minimal-node-build-env).
    This image is about ten times smaller than `node`. The size of Docker images have
    a real impact on build times, since the CI server or your team members will spend
    extra time pulling a larger image. Choose the environment that best fits your
    needs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我构建了一个基于`node-alpine`的最小Node构建环境`duluca/minimal-node-build-env`，您可以在Docker
    Hub上观察到它，网址为[https://hub.docker.com/r/duluca/minimal-node-build-env](https://hub.docker.com/r/duluca/minimal-node-build-env)。这个镜像比`node`小大约十倍。Docker镜像的大小对构建时间有真正的影响，因为持续集成服务器或您的团队成员将花费额外的时间拉取更大的镜像。选择最适合您需求的环境。
- en: Debugging build environment
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试构建环境
- en: Depending on your particular needs, your initial setup of the builder portion
    of the `Dockerfile` may be frustrating. To test out new commands or debug errors,
    you may need to directly interact with the build environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的特定需求，`Dockerfile`的构建部分的初始设置可能会令人沮丧。为了测试新命令或调试错误，您可能需要直接与构建环境进行交互。
- en: 'To interactively experiment and/or debug within the build environment, execute
    the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在构建环境中进行交互实验和/或调试，执行以下操作：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can test or debug commands within this temporary environment before baking
    them into your `Dockerfile`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在将命令嵌入您的`Dockerfile`之前，您可以在此临时环境中测试或调试命令。
- en: Tester
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试人员
- en: The second stage is `tester`. By default, the Angular CLI generates a testing
    requirement that is geared toward a development environment. This will not work
    in a continuous integration environment; we must configure Angular to work against
    a headless browser that can execute without the assistance of a GPU and further,
    a containerized environment to execute the tests against.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段是`tester`。默认情况下，Angular CLI生成了一个针对开发环境的测试要求。这在持续集成环境中不起作用；我们必须配置Angular以针对一个无需GPU辅助执行的无头浏览器，并且进一步，一个容器化环境来执行测试。
- en: Angular testing tools are covered in [Chapter 3](4e68114e-68b7-4fe6-a853-81347e981667.xhtml),* Prepare
    Angular App for Production Release.*
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Angular测试工具在[第3章](4e68114e-68b7-4fe6-a853-81347e981667.xhtml)中有所涵盖，*为生产发布准备Angular应用程序*
- en: Configuring a headless browser for Angular
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Angular配置无头浏览器
- en: 'The protractor testing tool officially supports running against Chrome in headless
    mode. In order to execute Angular tests in a continuous integration environment,
    you will need to configure your test runner, Karma, to run with a headless Chrome
    instance:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor测试工具正式支持在无头模式下运行Chrome。为了在持续集成环境中执行Angular测试，您需要配置您的测试运行器Karma以使用无头Chrome实例运行：
- en: 'Update `karma.conf.js` to include a new headless browser option:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`karma.conf.js`以包括新的无头浏览器选项：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ChromiumNoSandbox` custom launcher encapsulates all the configuration elements
    needed for a good default setup.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChromiumNoSandbox`自定义启动器封装了所有需要的配置元素，以便进行良好的默认设置。'
- en: 'Update `protractor` configuration to run in headless mode:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`protractor`配置以在无头模式下运行：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to test your application for responsive scenarios, you can use the
    `--window-size` option, as shown earlier, to change the browser settings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应用程序的响应情况，您可以使用`--window-size`选项，如前所示，来更改浏览器设置。
- en: 'Update the `package.json` scripts to select the new browser option in production
    build scenarios:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`package.json`脚本以在生产构建场景中选择新的浏览器选项：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that `test:prod` doesn't include `npm run e2e`. e2e tests are integration
    tests that take longer to execute, so  think twice about including them as part
    of your critical build pipeline. e2e tests will not run on the lightweight testing
    environment mentioned in the next section, so they will require more resources
    and time to execute.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`test:prod`不包括`npm run e2e`。e2e测试是需要更长时间执行的集成测试，因此在包含它们作为关键构建流程的一部分时要三思。e2e测试将不会在下一节提到的轻量级测试环境中运行，因此它们将需要更多的资源和时间来执行。
- en: Configuring testing environment
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置测试环境
- en: 'For a lightweight testing environment, we will be leveraging an Alpine-based
    installation of the Chromium browser:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于轻量级测试环境，我们将利用基于Alpine的Chromium浏览器安装：
- en: Inherit from `slapers/alpine-node-chromium`
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承自`slapers/alpine-node-chromium`
- en: 'Append the following configuration to `Docker.integration`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下配置附加到`Docker.integration`：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding script will copy the production build from the `builder` stage
    and execute your test scripts in a predictable manner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本将从`builder`阶段复制生产构建，并以可预测的方式执行您的测试脚本。
- en: Web server
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务器
- en: 'The third and final stage generates the container that will be your web server.
    Once this stage is complete, the prior stages will be discarded and the end result
    will be an optimized sub-10 MB container:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和最后阶段生成将成为您的Web服务器的容器。一旦完成此阶段，先前的阶段将被丢弃，最终结果将是一个优化的小于10MB的容器：
- en: Containerize your application with Docker, as discussed in [Chapter 3](4e68114e-68b7-4fe6-a853-81347e981667.xhtml),
    *Prepare Angular App for Production Release*
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker将您的应用程序容器化，如[第3章](4e68114e-68b7-4fe6-a853-81347e981667.xhtml)中所讨论的，*为生产发布准备Angular应用程序*
- en: Append the `FROM` statement at the end of the file
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾添加`FROM`语句
- en: '`COPY` the production ready code from `builder` as shown here:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`builder`中复制生产就绪代码，如下所示：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Build and test your multi-stage `Dockerfile`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和测试您的多阶段`Dockerfile`：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you are pulling code from GitHub, ensure that your code is committed and
    pushed before building the container, since it will pull your source code directly
    from the repository. Use the `--no-cache` option to ensure that new source code
    is pulled. If you are copying code from your local or CI environment, then do
    *not* use `--no-cache` as you won't the speed gains from being able to reuse previously
    built container layers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从GitHub拉取代码，请确保在构建容器之前提交和推送您的代码，因为它将直接从存储库中拉取您的源代码。使用“--no-cache”选项确保拉取新的源代码。如果您从本地或CI环境复制代码，则*不要*使用“--no-cache”，因为您将无法从能够重用先前构建的容器层中获得速度提升。
- en: 'Save your script as a new npm script named `build:ci` as shown:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为名为“build:ci”的新npm脚本，如下所示：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: CircleCI
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CircleCI
- en: CircleCI makes it easy to get started with a free tier and great documentation
    for beginners and pros alike. If you have unique enterprise needs, CircleCI can
    be brought on premise, behind corporate firewalls, or as a private deployment
    in the cloud.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI使得轻松开始使用免费套餐，并为初学者和专业人士提供了很好的文档。如果您有独特的企业需求，可以将CircleCI部署在企业内部，企业防火墙后，或作为云中的私有部署。
- en: 'CircleCI has pre-baked build environments for virtual configuration of free
    setups, but it can also run builds using Docker containers, making it a solution
    that scales to user skills and needs, as mentioned in the *Containerizing Build
    Environment* section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI具有预先配置的构建环境，适用于免费设置的虚拟配置，但也可以使用Docker容器运行构建，这使得它成为一个可以根据用户技能和需求进行扩展的解决方案，正如“容器化构建环境”部分所述：
- en: Create a CircleCI account at [https://circleci.com/](https://circleci.com/)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://circleci.com/](https://circleci.com/)上创建一个CircleCI帐户
- en: 'Sign up with GitHub:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GitHub注册：
- en: '![](Images/9759f615-e39e-44c5-ab40-25cec3c052e4.png)CircleCI Sign up page'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9759f615-e39e-44c5-ab40-25cec3c052e4.png)CircleCI注册页面'
- en: 'Add a new project:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新项目：
- en: '![](Images/90fb322a-1b08-46d1-8e3f-3aa7d3fdf976.png)CircleCI Projects Page'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/90fb322a-1b08-46d1-8e3f-3aa7d3fdf976.png)CircleCI项目页面'
- en: On the next screen, you have an option to select Linux or macOS build environments.
    The macOS build environments are very useful for building iOS or macOS apps. However,
    there is no free-tier for those environments; only Linux instances with 1x parallelism
    are free.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，您可以选择Linux或macOS构建环境。macOS构建环境非常适用于构建iOS或macOS应用程序。但是，这些环境没有免费套餐；只有具有1x并行性的Linux实例是免费的。
- en: Search for lemon-mart and click on Setup project
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索lemon-mart并点击设置项目
- en: Select Linux
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Linux
- en: Select Platform 2.0
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择平台2.0
- en: Select Language as Other, since we'll use a custom containerized build environment
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择语言为其他，因为我们将使用自定义容器化构建环境
- en: 'In your source code, create a folder named `.circleci` and add a file named `config.yml`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的源代码中，创建一个名为“.circleci”的文件夹，并添加一个名为“config.yml”的文件：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding file, a `build` job is defined, which is based on CircleCI's
    pre-built `docker:17.12.0-ce-git` image, containing the Docker and git CLI tools
    within itself. We then define build `steps`, which checks out the source code
    from GitHub with `checkout`, informs CircleCI to set up a Docker-within-Docker
    environment with the `setup_remote_docker` command and then executes the `docker
    build -f Dockerfile.integration .` command to initiate our custom build process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中，定义了一个“build”作业，它基于CircleCI预先构建的“docker:17.12.0-ce-git”镜像，其中包含Docker和git
    CLI工具。然后我们定义了构建“步骤”，使用“checkout”从GitHub检出源代码，通知CircleCI使用“setup_remote_docker”命令设置Docker-within-Docker环境，然后执行“docker
    build -f Dockerfile.integration .”命令来启动我们的自定义构建过程。
- en: In order to optimize builds, you should experiment with layer caching and copying
    source code from the already checked out source code in CircleCI.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化构建，您应该尝试使用层缓存和从CircleCI中已经检出的源代码复制源代码。
- en: Sync your changes to Github
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改同步到Github
- en: On CircleCI, click to Create your project
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CircleCI上，点击创建您的项目
- en: 'If everything goes well, you will have passing, *green*, build. As shown in
    the following screenshot, build #4 was successful:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将获得通过的*绿色*构建。如下截图所示，构建＃4成功：
- en: '![](Images/9c508c74-fb5d-45ce-9e5e-cede85b7f54a.png)Green build on CircleCI'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI上的绿色构建
- en: At the moment, the CI server is running, building the app in stage 1, then running
    the tests in stage 2, and then building the web server in stage 3\. Note that
    we are not doing anything with this web server container image, such as deploying
    it to a server.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，CI服务器正在运行，在第1阶段构建应用程序，然后在第2阶段运行测试，然后在第3阶段构建Web服务器。请注意，我们没有对此Web服务器容器映像执行任何操作，例如将其部署到服务器。
- en: 'In order to deploy your image, you will need to implement a deploy step. In
    this step, you can deploy to a multitude of targets such as Docker Hub, Zeit Now,
    Heroku, or AWS ECS. The integration to these targets will involve multiple steps.
    At a highlevel, these steps are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署您的映像，您需要实现一个部署步骤。在此步骤中，您可以部署到多个目标，如Docker Hub，Zeit Now，Heroku或AWS ECS。与这些目标的集成将涉及多个步骤。在高层次上，这些步骤如下：
- en: Install target-specific CLI tool with a separate run step
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单独的运行步骤安装特定于目标的CLI工具
- en: Configure Docker with login credentials specific to the target environment,
    storing said credentials as CircleCI environment variables
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用特定于目标环境的登录凭据配置Docker，并将这些凭据存储为CircleCI环境变量
- en: Use `docker push` to submit the resulting web server image to the target's Docker
    registry
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker push`将生成的Web服务器映像提交到目标的Docker注册表
- en: Execute a platform-specific `deploy` command to instruct the target to run the
    Docker image that was just pushed.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行特定于平台的`deploy`命令，指示目标运行刚刚推送的Docker映像。
- en: An example of how to configure such a deployment on AWS ECS from your local
    development environment is covered in [Chapter 11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml),
    *Highly-Available Cloud Infrastructure on AWS*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从本地开发环境配置AWS ECS上的此类部署在[第11章](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml)中有所介绍，*AWS上高可用云基础设施*。
- en: Code coverage report
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖报告
- en: A good way to understand the amount and the trends of unit tests coverage for
    your Angular project is through a code coverage report.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 了解您的Angular项目的单元测试覆盖量和趋势的一个好方法是通过代码覆盖报告。
- en: 'In order to generate the report for your app, execute the following command
    from your project folder:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为您的应用程序生成报告，请从项目文件夹中执行以下命令：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting report will be created as HTML under a folder name coverage;
    execute the following command to view it in your browser:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的报告将以HTML形式创建在名为coverage的文件夹下；执行以下命令在浏览器中查看：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s the folder-level sample coverage report generated by `istanbul.js` for
    LemonMart:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由`istanbul.js`生成的LemonMart的文件夹级示例覆盖报告：
- en: '![](Images/7090d87d-c51f-47e4-847d-97e5ffbf9186.jpg)Istanbul code coverage
    report for LemonMart'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart的Istanbul代码覆盖报告
- en: 'You can drill down on a particular folder, like `src/app/auth`, and get a file-level
    report, as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以深入研究特定文件夹，例如`src/app/auth`，并获得文件级报告，如下所示：
- en: '![](Images/596c8313-3338-4b91-bc99-a63df239ad64.png)Istanbul code coverage
    report for src/app/auth'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Istanbul代码覆盖报告适用于src/app/auth
- en: 'You can further drill down to get line-level coverage for a given file, like
    `cache.service.ts`, as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步深入了解给定文件的行级覆盖率，例如`cache.service.ts`，如下所示：
- en: '![](Images/24cf5a48-ae9b-44dc-8082-1d0650fadc96.png)Istanbul Code Coverage
    Report for cache.service.ts'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: cache.service.ts的Istanbul代码覆盖报告
- en: In the preceding image you can see that lines 5, 12, 17-18 and 21-22 are not
    covered by any test. The Iicon denotes that the if path was not taken. We can
    increase our code coverage by implementing unit tests that exercise the functions
    that are contained within `CacheService`. As an exercise, the reader should attempt
    to atleast cover one of these functions with a new unit test and observe the code
    coverage report change.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，您可以看到第5、12、17-18和21-22行没有被任何测试覆盖。图标表示if路径未被执行。我们可以通过实现对`CacheService`中包含的函数进行单元测试来增加我们的代码覆盖率。作为练习，读者应该尝试至少用一个新的单元测试覆盖其中一个函数，并观察代码覆盖报告的变化。
- en: Ideally, your CI server configuration should generate and host the code coverage
    report with every test run in a readily accessible manner. Implement these commands
    as script in `package.json` and execute them in your CI pipeline. This configuration
    is left as an exercise for the reader.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您的CI服务器配置应该以一种方便访问的方式生成和托管代码覆盖报告，并在每次测试运行时执行。将这些命令作为`package.json`中的脚本实现，并在CI流水线中执行它们。这个配置留给读者作为一个练习。
- en: Install `http-server` as a development dependency to your project.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将`http-server`安装为项目的开发依赖项。
- en: API design
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计
- en: 'In full-stack development, nailing down the API design early on is important.
    The API design itself is closely correlated with how your data contract will look.
    You may create RESTful endpoints or use the next-gen GraphQL technology. In designing
    your API, frontend and backend developers should closely collaborate to achieve
    shared design goals. Some high-level goals are listed as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈开发中，早期确定API设计非常重要。API设计本身与您的数据契约的外观密切相关。您可以创建RESTful端点，也可以使用下一代GraphQL技术。在设计API时，前端和后端开发人员应该密切合作，以实现共享的设计目标。一些高层目标列如下：
- en: Minimize data transmitted between client and server
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化客户端和服务器之间传输的数据
- en: Stick to well-established design patterns (that is, pagination)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坚持使用成熟的设计模式（即分页）
- en: Design to reduce business logic present in the client
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计以减少客户端中存在的业务逻辑
- en: Flatten data structures
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扁平化数据结构
- en: Do not expose database keys or relationships
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要暴露数据库键或关系
- en: Version endpoints from the get go
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一开始就版本化端点
- en: Design around major data components
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计
- en: It is important not to reinvent the wheel and take a disciplined, if not strict,
    approach to designing your API. The downstream effect of missteps in API design
    can be profound and impossible to correct once your application goes live.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要重复造轮子，并且在设计API时采取一种有纪律的，如果不是严格的方法是很重要的。API设计错误的下游影响可能是深远的，一旦您的应用程序上线就无法纠正。
- en: I will go into details of designing around major data components and implement
    a sample Swagger endpoint.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我将详细介绍围绕主要数据组件进行设计，并实现一个示例的Swagger端点。
- en: Designing around major data components
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计
- en: It helps to organize your APIs around major data components. This will roughly
    match how you consume data in various components in your Angular application.
    We will start off by defining our major data components by creating a rough data
    entity diagram and then implementing a sample API for the user data entity with
    swagger.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计有助于组织您的API。这将大致匹配您在Angular应用程序的各个组件中使用数据的方式。我们将首先通过创建一个粗略的数据实体图来定义我们的主要数据组件，然后使用swagger为用户数据实体实现一个示例API。
- en: Defining entities
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义实体
- en: Let's start by taking a stab at what kind of entities you would like to store
    and how these entities might relate to one another.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试一下您想要存储的实体类型以及这些实体之间可能的关系。
- en: 'Here''s a sample design for LemonMart, created using [draw.io](http://draw.io):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用[draw.io](http://draw.io)创建的LemonMart的样本设计：
- en: '![](Images/d8658c68-54ab-4f6f-aaae-d7c0ba98b653.jpg)Data entity diagram for
    LemonMartAt this moment, whether your entities are stored in a SQL or NoSQL database
    is inconsequential. My suggestion is to stick to what you know, but if you''re
    starting from scratch, a NoSQL database like MongoDB will offer the most amount
    of flexibility as your implementation and requirements evolve.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/d8658c68-54ab-4f6f-aaae-d7c0ba98b653.jpg) LemonMart的数据实体图'
- en: Roughly speaking, you will need CRUD APIs for each entity. You can use Swagger
    to design your APIs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的实体是存储在SQL还是NoSQL数据库中并不重要。我的建议是坚持你所知道的，但如果你是从零开始的，像MongoDB这样的NoSQL数据库将在您的实现和需求发展时提供最大的灵活性。
- en: Swagger
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger
- en: Swagger will allow you to design your web API. For teams, it can act as an interface
    between frontend and backend teams. Additionally, with API mocking, you can develop
    and complete API features before the implementation of the APIs even begins.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger将允许您设计您的Web API。对于团队来说，它可以充当前端和后端团队之间的接口。此外，通过API模拟，您甚至可以在API的实现开始之前开发和完成API功能。
- en: We will implement a sample Users API as we move on, to demonstrate how Swagger
    works.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进展，我们将实现一个示例用户API，以演示Swagger的工作原理。
- en: The sample project comes with recommended extensions for VS Code. Swagger Viewer
    allows us to preview the YAML file without running any additional tools.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目附带了VS Code的推荐扩展。Swagger Viewer允许我们在不运行任何其他工具的情况下预览YAML文件。
- en: Defining a Swagger YAML file
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粗略地说，您将需要为每个实体创建CRUD API。您可以使用Swagger来设计您的API。
- en: 'The most widely used and supported version of the Swagger spec is `swagger:
    ''2.0''`. The following example is given using the newer, standards-based, `openapi:
    3.0.0`. The sample code repository contains both examples. However, at the time
    of publishing, most tooling in the Swagger ecosystem relies on version 2.0.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`下，添加共享的`parameters`，使其易于重用常见模式，如分页端点：
- en: The sample code repository can be found at [github.com/duluca/lemon-mart-swagger-server](http://github.com/duluca/lemon-mart-swagger-server).For
    your mock API server, you should create a separate git repository, so that this
    contract between your frontend and backend can be maintained separately.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码存储库可以在[github.com/duluca/lemon-mart-swagger-server](http://github.com/duluca/lemon-mart-swagger-server)找到。对于您的模拟API服务器，您应该创建一个单独的git存储库，以便前端和后端之间的这个契约可以分开维护。
- en: Create a new GitHub repository, called `lemon-mart-swagger-server`
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`lemon-mart-swagger-server`的新GitHub存储库
- en: 'Start defining a YAML file with general information and target servers:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始定义一个带有一般信息和目标服务器的YAML文件：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Under `components`, define shared data `schemas`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Swagger规范的最广泛使用和支持的版本是`swagger: ''2.0''`。下面的示例是使用更新的、基于标准的`openapi: 3.0.0`给出的。示例代码存储库包含了这两个示例。然而，在发布时，Swagger生态系统中的大多数工具都依赖于2.0版本。在`components`下，定义共享数据`schemas`：'
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Under `components`, add shared `parameters`, making it easy to reuse common
    patterns like paginated endpoints:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Swagger YAML文件
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Under `paths`, define a `get` endpoint for the `/users` path:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paths`下，为`/users`路径定义一个`get`端点：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Under `paths`, add `get` user by ID and `update` user by ID endpoints:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paths`下，添加`get`通过ID获取用户和`update`通过ID更新用户的端点：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To validate your Swagger file, you can use the online editor at [editor.swagger.io](https://editor.swagger.io).Note
    the use of `style: form` and `explode: false`, which are the simplest way to configure
    an endpoint that expects basic form data. For more parameter serialization options
    or to simulate authentication endpoints and a slew of other possible configurations,
    refer to the documentation at [swagger.io/docs/specification/](https://swagger.io/docs/specification/).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '要验证你的Swagger文件，你可以使用在线编辑器[editor.swagger.io](https://editor.swagger.io)。注意使用`style:
    form`和`explode: false`，这是配置期望基本表单数据的端点的最简单方式。要了解更多参数序列化选项或模拟认证端点和其他可能的配置，请参考[swagger.io/docs/specification/](https://swagger.io/docs/specification/)上的文档。'
- en: Creating a Swagger server
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Swagger服务器
- en: Using your YAML file, you can generate a mock Node.js server using the Swagger
    Code Gen tool.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的YAML文件，你可以使用Swagger Code Gen工具生成一个模拟的Node.js服务器。
- en: OpenAPI 3.0 with unofficial tooling
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非官方工具的OpenAPI 3.0
- en: 'As mentioned in the earlier section, this section will use version 2 of the
    YAML file, which can generate a server using the official tooling. There are,
    however, other tools out there that can generate some code, but not complete enough
    to be easy to use:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，本节将使用YAML文件的第2版，它可以使用官方工具生成服务器。然而，还有其他工具可以生成一些代码，但不完整到足够易于使用：
- en: 'If using OpenAPI 3.0 on the project folder, execute the following command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在项目文件夹中使用OpenAPI 3.0，请执行以下命令：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Under a new folder, called `server`, you should now have a Node Express server
    generated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`server`的新文件夹下，你现在应该有一个生成的Node Express服务器。
- en: 'Install dependencies for the server:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务器安装依赖项：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You must then manually implement the missing stubs to complete the implementation
    of the server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须手动实现缺失的存根来完成服务器的实现。
- en: Swagger 2.0 with official tooling
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用官方工具的Swagger 2.0
- en: 'Using official tooling and version 2.0, you can automate API creation and response
    generation. Once official tooling fully supports them, OpenAPI 3.0, the same instructions
    should apply:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用官方工具和2.0版本，你可以自动创建API和生成响应。一旦官方工具完全支持OpenAPI 3.0，相同的指令应该适用：
- en: 'Publish your YAML file on a URI that will be accessible by your machine:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的YAML文件发布到一个可以被你的机器访问的URI上：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In your project folder, execute the following command, replacing `<uri>` with
    the one pointing at your YAML file:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中，执行以下命令，用你的YAML文件指向的URI替换`<uri>`：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similar to the preceding section, this will create a Node Express server under
    the server directory. In order to execute this server, carry on with the following
    steps.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一节类似，这将在服务器目录下创建一个Node Express服务器。为了执行这个服务器，继续以下步骤。
- en: Install the server's dependencies with `npm install`
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`npm install`安装服务器的依赖项。
- en: Run `npm start`. Your mock server should now be up and running.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm start`。你的模拟服务器现在应该已经启动。
- en: Navigate to `http://localhost:3000/docs`
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:3000/docs`
- en: 'Try out the API for `get /users`; you''ll note that the items property is empty:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试`get /users`的API；你会注意到items属性是空的：
- en: '![](Images/e1adb59c-d15f-4d20-b645-0ee3715a3a80.png)Swagger UI - Users endpoint'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/e1adb59c-d15f-4d20-b645-0ee3715a3a80.png)Swagger UI - 用户端点'
- en: However, you should be receiving dummy data. We will correct this behavior.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你应该收到虚拟数据。我们将纠正这种行为。
- en: 'Try out `get /user/{id}`; you''ll see that you''re receiving some dummy data
    back:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试`get /user/{id}`；你会看到你收到了一些虚拟数据：
- en: '![](Images/fcf9446c-167f-41d3-9ecc-c6a5c98f1692.png)Swagger UI - User by ID
    endpoint'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/fcf9446c-167f-41d3-9ecc-c6a5c98f1692.png)Swagger UI - 按用户ID端点'
- en: The difference in behavior is because, by default, the Node Express server uses
    controllers generated under `server/controllers/Default.js` to read random data
    generated during server creation from `server/service/DefaultService.js`. However,
    you can disable the default controllers and force Swagger into a better default
    stubbing mode.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 行为上的差异是因为，默认情况下，Node Express 服务器使用在 `server/controllers/Default.js` 下生成的控制器来读取在服务器创建期间从
    `server/service/DefaultService.js` 生成的随机数据。然而，您可以禁用默认控制器，并强制 Swagger 进入更好的默认存根模式。
- en: 'Update `index.js` to force the use of stubs and comment out controllers:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `index.js` 以强制使用存根并注释掉控制器：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Try out the `/users` endpoint again
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试 `/users` 端点
- en: 'As you can see here, the response is higher quality by default:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里所看到的，响应默认情况下具有更高的质量：
- en: '![](Images/84d70e47-757e-448f-86f6-d8822b229a70.png)Swagger UI - Users endpoint
    with dummy data'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/84d70e47-757e-448f-86f6-d8822b229a70.png)Swagger UI - 使用虚拟数据的用户端点'
- en: In the preceding, `total` is a whole number, `role` is defined correctly, and
    `items` is a valid array structure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述中，`total` 是一个整数，`role` 被正确定义，`items` 是一个有效的数组结构。
- en: To enable better and more customized data mocking, you can edit `DefaultService.js`.
    In this case, you would want to update the `usersGET` function to return an array
    of customized users.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用更好和更定制的数据模拟，您可以编辑 `DefaultService.js`。在这种情况下，您希望更新 `usersGET` 函数以返回一个定制用户数组。
- en: Enable Cross-Origin Resource Sharing (CORS)
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用跨域资源共享（CORS）
- en: 'Before you''re able to use your server from your application, you will need
    to configure it to allow for **Cross-Origin Resource Sharing** (**CORS**) so that
    your Angular application hosted on `http://localhost:5000` can communicate with
    your mock server hosted on `http://localhost:3000`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够从应用程序中使用您的服务器之前，您需要配置它以允许**跨域资源共享**（**CORS**），以便您托管在 `http://localhost:5000`
    上的 Angular 应用程序可以与您托管在 `http://localhost:3000` 上的模拟服务器进行通信：
- en: 'Install the `cors` package:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `cors` 包：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Update `index.js` to use `cors`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `index.js` 以使用 `cors`：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ensure that `app.use(cors())` is called right before `initializeMiddleware`;
    otherwise, other Express middleware may interfere with the functionality of `cors()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `initializeMiddleware` 之前调用 `app.use(cors())`；否则，其他 Express 中间件可能会干扰 `cors()`
    的功能。
- en: Verifying and publishing Swagger server
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和发布 Swagger 服务器
- en: You can verify your Swagger server setup through the SwaggerUI, which will be
    located at `http://localhost:3000/docs`, or you can achieve a more integrated
    environment with the Preview Swagger extension in VS Code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 SwaggerUI 验证您的 Swagger 服务器设置，SwaggerUI 将位于 `http://localhost:3000/docs`，或者您可以通过
    VS Code 中的预览 Swagger 扩展实现更集成的环境。
- en: 'I will demonstrate how you can use this extension to test your API from within
    VS Code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我将演示如何使用这个扩展来从 VS Code 内部测试您的 API：
- en: Select the YAML file in Explorer
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源管理器中选择 YAML 文件
- en: Press *Shift* + *Alt* + *P *and execute the Preview Swagger command
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Shift* + *Alt* + *P* 并执行预览 Swagger 命令
- en: 'You will see an interactive window to test your configuration, as illustrated:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个交互式窗口来测试您的配置，如下所示：
- en: '![](Images/451bf379-14b2-46bb-96fd-6ecdd6920235.png)Preview Swagger Extension
    in Visual Studio Code'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/451bf379-14b2-46bb-96fd-6ecdd6920235.png)在 Visual Studio Code 中预览
    Swagger 扩展'
- en: Click on the Get button for /users
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 /users 的 Get 按钮
- en: Click on Try it out to see the results
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Try it out 查看结果
- en: In OpenAPI 3.0.0, instead of schemes, you will see a list of servers, including
    local and remote resources. This is a very convenient tool to explore various
    data sources as you code your frontend application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenAPI 3.0.0 中，您将看到一个服务器列表，包括本地和远程资源，而不是方案。这是一个非常方便的工具，可以在编写前端应用程序时探索各种数据源。
- en: Now that you have verified your Swagger server, you can publish your server
    to make it accessible to team members or **Automated Acceptance Test** (**AAT**)
    environments that require a predictable dataset to execute successfully.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经验证了Swagger服务器，您可以发布服务器，使团队成员或需要可预测数据集才能成功执行的**自动验收测试**（**AAT**）环境可以访问它。
- en: Perform the following steps, as covered in [Chapter 3](4e68114e-68b7-4fe6-a853-81347e981667.xhtml),
    *Prepare Angular App for Production Release:*
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，如[第3章](4e68114e-68b7-4fe6-a853-81347e981667.xhtml)中所述，*为生产发布准备Angular应用程序*：
- en: Add npm Scripts for Docker to the root level `package.json` file
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根级别的`package.json`文件中为Docker添加npm脚本
- en: 'Add a `Dockerfile`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Dockerfile`：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once you build the container, you are ready to deploy it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器后，您就可以部署它了。
- en: I have published a sample server on Docker Hub at [https://hub.docker.com/r/duluca/lemon-mart-swagger-server](https://hub.docker.com/r/duluca/lemon-mart-swagger-server).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在Docker Hub上发布了一个示例服务器，网址为[https://hub.docker.com/r/duluca/lemon-mart-swagger-server](https://hub.docker.com/r/duluca/lemon-mart-swagger-server)。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to create a container-based Continuous Integration
    environment. We leveraged CircleCI as a cloud-based CI service and highlighted
    the fact that you can deploy the outcome of your builds to all major cloud hosting
    providers. If you enable such automated deployment, you will achieve **Continuous Deployment**
    (**CD**). With a CI/CD pipeline, you can share every iteration of your app with
    clients and team members and quickly deliver bug fixes or new features to your
    end users.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何创建基于容器的持续集成环境。我们利用CircleCI作为基于云的CI服务，并强调您可以将构建结果部署到所有主要的云托管提供商。如果您启用了这样的自动化部署，您将实现**持续部署**（**CD**）。通过CI/CD管道，您可以与客户和团队成员分享应用程序的每个迭代，并快速向最终用户交付错误修复或新功能。
- en: We also discussed the importance of good API design and established Swagger
    as a tool that is beneficial to frontend and backend developers alike to define
    and develop against a live data-contract. If you create a Swagger mock server,
    you can enable team members to pull the mock server image and use it to develop
    their frontend applications before backend implementation is completed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了良好API设计的重要性，并确定Swagger作为一个有益于前端和后端开发人员的工具，用于定义和开发针对实时数据契约的应用。如果您创建了一个Swagger模拟服务器，您可以让团队成员拉取模拟服务器镜像，并在后端实现完成之前使用它来开发他们的前端应用程序。
- en: Both CircleCI and Swagger are highly sophisticated tools in their own ways.
    The techniques mentioned in this chapter are straightforward on purpose, but they
    are meant to enable sophisticated workflows, giving you a taste of the true power
    of such tools. You can improve upon the efficiency and the capability of this
    technique vastly, but the techniques will depend on your specific needs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI和Swagger都是各自高度复杂的工具。本章提到的技术故意简单，但旨在实现复杂的工作流程，让您领略到这些工具的真正威力。您可以大大提高这种技术的效率和能力，但这些技术将取决于您的具体需求。
- en: Armed with CI and mocked APIs that we can send real HTTP requests to, we are
    ready to iterate rapidly, while ensuring a high-quality deliverable. In the next
    chapter, we will dive deep into designing an authorization and authentication
    experience for your line-of-business app using token-based authentication and
    conditional navigation techniques to enable a smooth user experience, continuing
    the Router-first approach.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 装备了CI和模拟的API，我们可以发送真实的HTTP请求，我们准备快速迭代，同时确保高质量的可交付成果。在下一章中，我们将深入探讨如何使用基于令牌的身份验证和条件导航技术，为您的业务应用程序设计授权和身份验证体验，以实现平滑的用户体验，继续采用路由器优先的方法。
