- en: Chapter 11. Putting Things to the Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing tests is crucial for the maintainability of your code. It's a known
    fact that having a good range of tests that cover most of your functionality is
    equally important as the functionality itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that comes to mind when thinking about tests is probably code
    quality assurance. You test the code that you write, so this is definitely true.
    However, there are many other important aspects of writing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resistance to unexpected change**: Your tests define what your code is supposed
    to do. They test whether your code conforms to your specifications. This has several
    benefits, where the most obvious is probably a resistance to unexpected change
    in the future. If you modify the code in the future, you''ll less likely break
    your existing code because your tests will validate whether the existing functionality
    still works as specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Your tests define what your code should do. At the same
    time, they display the API calls that are required to use the concerned functionality.
    This is the perfect documentation for any developer. Whenever I want to understand
    how a library really works, the tests are the first thing that I look at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoiding unnecessary code**: The practice of writing tests forces you to
    limit your code to fulfil the requirements of your specification and nothing more.
    Any code in your application that is not reached in your automated tests can be
    considered dead code. If you stick to a merciless refactoring approach, you''d
    then remove such unused code ASAP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we haven't considered testing in our book at all, and given its importance,
    you may wonder why I come up with this now in the last chapter. In a real project,
    we'd definitely create tests much earlier if not at first. However, I hope you
    understand that in this book, we postponed this rather important topic until the
    end. I really love testing, but as we're mainly focused on the component architecture
    of Angular, placing this chapter at the end seemed more logical.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look into how to perform proper unit testing on your
    components. We'll focus on unit testing; automated end-to-end testing is beyond
    the scope of this book. Still, we'll look into how to test user interaction on
    components, although not on the level it would be done in end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Jasmine testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing simple JavaScript tests for components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `tests.html` file, which serves as an in-browser test runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Jasmine spies and observing component output properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Angular testing utilities, such as `inject`, `async`, `TestComponentBuilder`,
    `DebugElement`, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking existing services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests for our `AutoComplete` UI component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests for our plugin system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is a very simple testing framework, which comes with an API that allows
    you to write **Behavior-driven Development** (**BDD**) style tests. BDD is an
    agile software development process of defining specifications in a written format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In BDD, we define that an agile user story consists of multiple scenarios.
    These scenarios closely relate to or even replace the acceptance criteria of a
    story. They define requirements on a higher level, and they are mostly written
    narrative. Each scenario then consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: This part is used to describe the initial state of the scenario.
    The test code is where we perform all the setup that is needed to execute the
    test scenario.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: This part reflects the changes that we perform to the system under
    test. Usually, this part consists of some API calls and actions that reflect the
    behavior of a user of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then**: This part specifies what the system should look like after the given
    state and the changes applied in the *when* part. In our code, this is the part
    that is usually at the end of our tests function, where we use assertion libraries
    to verify the state of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jasmine comes with an API that makes it very easy to write tests which structure
    according to the BDD style. Let''s look at a very simple example of how we use
    Jasmine to write a test for a shopping cart system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Jasmine provides us with a `describe` function, which allows us to group certain
    scenarios on the same subject. In this example, we used the `describe` function
    to register a new test suite for tests about buying items in a shop.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `it` function, we can register individual scenarios, which we'd like
    to get tested. In the `describe` callback function, we can register as many scenarios
    using the `it` function as we like.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the callback function of the Jasmine `it` function, we can start writing
    our test. We use a `BDD` style to structure the code inside our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t necessarily need to run Jasmine in the browser, but if you do this,
    you''ll get a nice summary report of all tests and their state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An introduction to Jasmine](img/image00355.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Jasmine provides a nice visual report over all your test specifications, which
    also allows you to rerun individual tests and provides you with more options
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine comes in three parts that are relevant to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jasmine core**: This contains the test definition APIs, the assertion library,
    and all the other core parts of the testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jasmine HTML**: This is the HTML reporter, which will write all tests results
    to the browser document and even provide options to rerun individual tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jasmine boot**: This is the file that bootstraps the Jasmine framework for
    the browser and performs any setup that is needed with the HTML reporter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our project, we will use Jasmine and the preceding parts directly from a
    CDN, so we don't need to install anything to get started. We create a new `tests.html`
    file, which will serve as a runner for our tests. In conjunction with `live-server`,
    we can always have this page open in our browser. This way we'll get immediate
    feedback on our tests while developing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jasmine also plays nice with test runners such as Karma to run your tests. Karma
    is a popular test runner, which allows you to run your tests in parallel using
    the Karma CLI or integrate it in your build pipeline. This also allows you to
    run tests in different browsers. In this chapter, we will use the Jasmine HTML
    and Jasmine boot to run our tests directly in the browser. This allows us to skip
    the rather complex setup that we'd need to undertake if we used Karma as our test
    runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code of the `tests.html` file that we create in the root
    folder of our application, right next to the `index.html` file, which is already
    present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Besides loading the usual suspects for our Angular application (ES6 shim, Angular
    polyfills, and SystemJS), we now also load the three main components of Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Jasmine executes all registered tests on the window''s `load` event.
    However, as we will load our tests using SystemJS, we need to defer the bootstrap
    of Jasmine until SystemJS has completely loaded our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We first put aside the function that was registered by Jasmine boot on `window.onload`.
    We store the function in a temporary `_jasmineOnLoad` global variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we use SystemJS to import our entry point module for our tests, which will
    be stored in the `all.spec.js` file. SystemJS returns a `Promise` that will be
    resolved if the test module has been loaded and executed successfully. We can
    use the `then` function of the returned `Promise` to execute the Jasmine boot
    function stored in `window._jasmineOnLoad`. In this way, we make sure that Jasmine
    is booted after all our tests have been registered.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are all set with the Jasmine setup, we can start writing our first
    test. In this section, we will create a first test for the `AutoComplete` component
    that we created in [Chapter 8](part0054.xhtml#aid-1JFUC2 "Chapter 8. Time Will
    Tell"), *Time Will Tell*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: As Angular components are just classes, we can already test a lot of the functionality
    by instantiating the `Component` class and testing its methods. Tests that can
    be performed like this should always be considered first. These tests can run
    without Angular bootstrapping the component.
  prefs: []
  type: TYPE_NORMAL
- en: The `AutoComplete` component filters displayed results based on the available
    items and a filter criteria. In the following test, we'll verify that the `filter`
    method on the component works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we follow the practice to store test files by appending a `.spec.js`
    file to the name of the file that has to be tested. We'll also store these test
    files in the same folder of the subject. This makes it much easier to keep the
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a new `auto-complete.spec.js` file in the folder of the `AutoComplete`
    component at `lib/ui/auto-complete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we loaded Jasmine prior to executing our test, we could rely on the global
    `describe`, `it`, and `expect` functions that are exposed by Jasmine. However,
    Angular provides us with some nice wrappers of the Jasmine functions, which we
    can import from the module located in `@angular/core/testing`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we don't really need to activate the `AutoComplete` component
    in order to test some of its functionality. By simply testing the component class,
    we can already execute some of our executable specifications.
  prefs: []
  type: TYPE_NORMAL
- en: We follow a BDD approach to structure our test, and in the `Given` section,
    we instantiate a new `AutoComplete` component class, and then we initialize the
    items list with some test items. Even if the items field is actually a component
    input, we can simply disregard this fact in order to test the filtering functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the `When` section of our test, we actually call the `filterItems` method
    of the component class and test whether it does filter the items according to
    the specification.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Then` section, we use the `expect` function of Jasmine in order to assert
    the expected state after the `When` section. As the component should filter all
    items with partial and case-insensitive matches of the filter criteria, the expected
    value in `filteredItems` should be an array with the `One` and `two` items.
  prefs: []
  type: TYPE_NORMAL
- en: We use the assertion `toEqual` function in order to perform a deep equal check.
    If we use the `toBe` matcher, we'd compare the references of the two arrays, which
    will result in a negative match.
  prefs: []
  type: TYPE_NORMAL
- en: This is it for our first test. What's left to do still is to create our main
    test module that is loaded in the `tests.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created the main entry point for all our tests in a `all.spec.js` file on
    the root path of our application. This file will then include all specification
    files that we create in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is currently all that we need to make our test run. We simply import the
    test file that we just created. Now, `tests.html` will use SystemJS to load our
    `all.spec.js` file, and here, we then load the `auto-complete-spec.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: We can now start `live-server` in the root path of our application and navigate
    to `http://127.0` `.0.1:8080/tests.html` in our browser. As `live-server` will
    reload our browser on changes, we can start adding new tests while we constantly
    get updates on our test state in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Spying on component outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common practice in testing is to use spy function calls during the execution
    of tests and then evaluate these calls, checking whether all functions have been
    called correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine provides us with some nice helpers in order to use spy function calls.
    We can use the `spyOn` function of Jasmine in order to replace the original function
    with a spy function. The spy function will record any calls, and we can later
    on evaluate how many times it was called and with what parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example of how to use the `spyOn` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will test a simple `Calculator` class that has two methods. The `multiply`
    method simply multiplies two numbers and returns the result. The `pythagorean`
    method calculates the hypotenuse of a right-angled triangle with two sides, `a`
    and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember the formula for the Pythagorean theorem from your early
    school days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will use this formula to produce `c` from `a` and `b` by getting the square
    root of the result of `a*a + b*b`. For the multiplications, we'll use our `multiply`
    method instead of using arithmetic operators directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''d want to test our calculator `pythagorean` method, and as it uses
    the `multiply` method to multiply `a` and `b`, we can spy on this method to verify
    our test result in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `spyOn` function of Jasmine takes an object as first parameter and the function
    name on the object which we'd like to spy on.
  prefs: []
  type: TYPE_NORMAL
- en: This will effectively replace the original `multiply` function on our class
    instance with a new spy function of Jasmine. By default, spy functions will only
    record function calls, and they won't delegate the call further to the original
    function. We can use the `.and.callThrough()` function to specify that we'd like
    Jasmine to call the original function. This way our spy function will act as a
    proxy and record any calls at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Then` section of our test, we can then inspect the spy function. Using
    the `toHaveBeenCalled` matcher, we can check whether the spy function was called
    after all.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `calls` property of the spy function, we can inspect in more detail
    and verify the call count as well as the arguments that individual calls received.
  prefs: []
  type: TYPE_NORMAL
- en: Using the knowledge that we gained about Jasmine spies, we can now apply that
    to our component tests. As we know that all output properties of components contain
    an `EventEmitter`, we can actually spy on them to check whether our component
    sends output.
  prefs: []
  type: TYPE_NORMAL
- en: Inside components, we call the `next` method on `EventEmitter` in order to send
    output to parent component bindings. As this is an asynchronous operation and
    we'd also like to test our components without needing to involve parent components,
    we can simply spy on the `next` method of our output properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next two tests for our `AutoComplete` component, we''d like to verify
    the functionality when we save an edit in the `Editor` child component. Let''s
    quickly recap on this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: On saved edits, we get the `onEditSaved` method on the `AutoComplete` component
    that is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the saved value is an empty string, the `AutoComplete` component should emit
    a `selectedItemChange` event with a `null` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the saved value is no empty string and the value is not present in the items
    of the `AutoComplete` component, an `itemCreated` event should be emitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create the tests for the previous expected behavior to the already existing
    `lib/ui/auto-complete/auto-complete.spec.js` test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We create two Jasmine spies here. The first one spies on the `selectedItemChange`
    output property, while the second one spies on the `itemCreated` output property.
  prefs: []
  type: TYPE_NORMAL
- en: After simulation, the editor was saved with an empty string. We can start verifying
    our spies in the `Then` section of our test.
  prefs: []
  type: TYPE_NORMAL
- en: The `next` function of the `selectedItemChange` event, `EventEmitter`, should
    have been called with a `null` value, while `next` of `itemCreated` shouldn't
    have been called at all. We can use the `not` property on the returned expectation
    object to invert the matcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a second test for the behavior when an editor was saved with a value
    that does not yet exist in the `AutoComplete` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This time, we simulate a saved edit with a value, which isn't an empty string
    and does not exist in the autocomplete items already.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Then` section of our code, we evaluate the spies and expect that the
    `itemCreated.next` function was called with a `four` string.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine spies, we managed to test our component output successfully without
    the need to bootstrap Angular. We performed these tests solely on the component
    class and by creating spies on the `EventEmitter` that is present on all output
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Utilities to test components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we tested our components with plain vanilla JavaScript. The fact that
    components are in just regular classes make this possible. However, this can only
    be done for very simple use-cases. As soon as we'd like to test components for
    things that involve template compilation, user interaction on components, change
    detection, or dependency injection, we'll need to get a little help from Angular
    to perform our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Angular comes with a whole bunch of testing tools that help us out here. In
    fact, the platform-agnostic way that Angular is built allows us to exchange the
    regular view adapter with a debug view adapter. This enables us to render components
    in such a way that allows us to inspect them in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the debugging capabilities of Angular while rendering components,
    we need to modify our main entry point for our tests first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `all.spec.js` to make the necessary modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using the `setBaseTestProviders` function of the `@angular/core/testing` module,
    we can actually initialize a test platform injector, which will then be used in
    the context of our Angular testing. This function takes two arguments where the
    first one is an array of platform providers, and the second one is an array of
    application providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `@angular/platform-browser-dynamic/testing` module, we can import
    two constants that contain an already prepared list for both platform and application-level
    dependencies. Here are some of the providers present in these constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform-level providers**: These consist mostly of platform initialization
    providers to debug'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application-level providers**: These consist of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DebugDomRootRenderer`: This overrides the default `DomRenderer` in the browser
    and enables debugging of elements using `DebugElement` and probing'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockDirectiveResolver`: This overrides the default `DirectiveResolver` and
    allows overriding of directive metadata for testing purposes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockViewResolver`: This overrides the default `ViewResolver` and allows overriding
    of component view specific metadata'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `setBaseTestProviders` function and the imported constants with the
    debugging providers, we can now initialize our test environment. After calling
    this function and passing our providers, Angular is set up for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting in tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Injecting Angular dependencies in tests is made easy by two helper functions
    that we can use. The `inject` and `async` functions are available through the
    `@angular/core/testing` package, and they help us inject dependencies in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this simple example where we inject the document element using
    the `inject` wrapper function. This test is irrelevant for our application, but
    it illustrates how we can now make use of injection in our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can simply use `inject` to wrap our test function. The `inject` function
    accepts an array as the first parameter that should include a list of injectables.
    The second parameter is our actual test function, which will now receive the injected
    document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `async` function on the other hand helps us with a different concern too.
    What if our tests actually involve asynchronous operations? Well, a standard asynchronous
    Jasmine test would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Jasmine provides us with a nice way to specify asynchronous tests. We can simply
    use the first parameter of our test functions, which resolves to a callback function.
    By calling this callback function, in our case we named it `done`, we tell Jasmine
    that our asynchronous operations are done, and we would like to finish the test.
  prefs: []
  type: TYPE_NORMAL
- en: Using callbacks to indicate whether our asynchronous test is finished is a valid
    option. However, this can make our test quite complicated if many asynchronous
    operations are involved. It's sometimes even impossible to monitor all the asynchronous
    operations that are happening under the hood, which also makes it impossible for
    us to determine the end of our test.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `async` helper function comes into play. Angular uses a library
    called Zone.js to monitor any asynchronous operation in the browser. Simply put,
    Zone.js hooks into any asynchronous operation and monitors where they are initiated
    as well as when they are finished. With this information, Angular knows exactly
    how many pending asynchronous operations there are.
  prefs: []
  type: TYPE_NORMAL
- en: If we're using the `async` helper, we tell Angular to automatically finish our
    test when all asynchronous operations in our test are done. The helper uses Zone.js
    to create a new zone and determine whether all the microtasks executed within
    this zone are finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can combine injection with an asynchronous operation
    in our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By combining `inject` with `async` (wrapping), we now have an asynchronous operation
    in our test. The `async` helper will make our test wait until all asynchronous
    operations are completed. We don't need to rely on a callback, and we have the
    guarantee that even internal asynchronous operations will complete before our
    test finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Zone.js is designed to work with all asynchronous operations in the browser.
    It patches all core DOM APIs and makes sure that every operation goes through
    a zone. Angular also relies on Zone.js in order to initiate change detection.
  prefs: []
  type: TYPE_NORMAL
- en: Test component builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular comes with another very important testing utility to test components
    and directives. So far, we only tested the component class of our components.
    However, as soon as we need to test components and their behavior in our application,
    this involves a few more things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing the view of components**: It''s sometimes required that we test the
    rendered view of components. With all the bindings in our view, dynamic instantiation
    using template directives and content insertion, it''s required that we can have
    a way to test all this behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing change detection**: As soon as we update our model in our component
    class, we want to test the updates that are performed via change detection. This
    involves the whole change detection behavior of our components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interaction**: Our component templates probably contain a set of event
    bindings, which trigger some behavior on user interaction. We''d also need a way
    to test the state after some user interaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overriding and mocking**: In a testing scenario, it''s sometimes required
    to mock certain areas in our components in order to create a proper isolation
    for our test. In unit testing, we should be concerned only about the specific
    behavior that we want to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TestComponentBuilder`, which is available through the `@angular/compiler/testing`
    package, helps us exactly with the previous concerns. It's our main tool to test
    components.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestComponentBuilder` is provided to the test application injector, which
    we initialized in our `all.spec.js` module using the `setBaseTestProviders` function.
    The reason for this is that the builder itself also relies on a lot of platform
    and application dependencies to create components. As all our dependencies now
    come from the test injector and most of them are overridden to enable inspection,
    this makes perfect sense.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a very simple example of how we can use `TestComponentBuilder`
    to test the view rendering of a dummy component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As `TestComponentBuilder` is exposed in the test injector, we need to use dependency
    injection to get hold of the instance. We use the `inject` helper for this purpose.
    As creating a component is an asynchronous operation, we also need to make our
    test wait for completion using the `async` helper.
  prefs: []
  type: TYPE_NORMAL
- en: In our test function, we call the `createAsync` method of `TestComponentBuilder`
    and pass a reference to `DummyComponent`, which we want to create. This method
    returns a `Promise`, which will resolve once the component is successfully compiled.
  prefs: []
  type: TYPE_NORMAL
- en: In the `then` callback of the returned promise, we'll receive a special fixture
    object of the `ComponentFixture` type. We can then call the `detectChanges` method
    on this fixture object, which will execute change detection on the created component.
    After this initial change detection, the view of our dummy component is updated.
    We can now use the `nativeElement` property of the fixture in order to access
    the root DOM element of the created component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `ComponentFixture` type and the available fields in more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `detectChanges()` | This executes change detection on the root component
    that was created in the context of the fixture. The template bindings will not
    be evaluated automatically after creating a component using `TestComponentBuilder`.
    It''s our own responsibility to trigger change detection. Even after we change
    the state of our components, we''d need to trigger change detection again. |'
  prefs: []
  type: TYPE_TB
- en: '| `destroy()` | This method destroys the underlying component and performs
    any cleanup that is required. This can be used to test the `OnDestroy` component''s
    lifecycle. |'
  prefs: []
  type: TYPE_TB
- en: '| `componentInstance` | This property points to the component class instance,
    and this is our main interaction point if we want to interact with the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `nativeElement` | This is a reference to the native DOM element at the root
    of the created component. This property can be used to inspect the rendered DOM
    of our component directly. |'
  prefs: []
  type: TYPE_TB
- en: '| `elementRef` | This is the `ElementRef` wrapper around the root element of
    the created component. |'
  prefs: []
  type: TYPE_TB
- en: '| `debugElement` | This property points to an instance of `DebugElement` that
    was created by `DebugDomRootRenderer` in the component view rendering pipeline.
    The debug element provides us with some nice utilities to inspect the rendered
    element tree and testing user interaction. We''ll take a closer look at this later
    in another section. |'
  prefs: []
  type: TYPE_TB
- en: We've now looked at a very simple dummy component and how to test it using `TestComponentBuilder`
    in conjunction with the `inject` and `async` helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: This is great, but it doesn't really reflect the complexity that we face when
    we need to test real components. Real components have a lot more dependencies
    than our dummy component. We rely on child directives and probably on injected
    services to obtain data.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the `TestComponentBuilder` also provides us with the tools that we
    need in order to test more complex components and keep the necessary isolation
    in a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at an example where we''d like to test a `ParentComponent`
    component, which uses a `ChildComponent` component to render a list of numbers.
    As we''d only like to test `ParentComponent`, we''re not interested in how `ChildComponent`
    renders this list. We want to remove the behavior of the child component from
    our test by providing a mock component for `ChildComponent` during our test, which
    allows us to easily verify that the data is received by the child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is our starting point. We have two components, where we'll only be interested
    in testing the parent component. However, the child component is required by the
    parent component, and it implies a very specific way to render the numbers that
    are passed by the parent. We would only like to test whether our numbers were
    passed successfully to the child component. We don't want to involve the rendering
    logic of the child component in our test. This is very important because changing
    only the child component could then break our parent component test, which we
    want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing we want to achieve now is to create a mock of our child component
    in the context of our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In our `MockChildComponent` class, it's important that we use the same selector
    property as the real component. Otherwise, the mocking will not work. In the template,
    we use a very simple output of the numbers input, which enables an easy inspection.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important that we provide the same input properties as the original
    component. Otherwise, we won't imitate the real component correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can go ahead and perform our test. Using an additional method of `TestComponentBuilder`,
    we are able to override the real `ChildComponent` with our mock component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using the `overrideDirective` method on `TestBuilderComponent`, we can modify
    the parent component's `directives` metadata before we create it. In this way,
    we're able to exchange the real child component with our `MockChildComponent`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we decouple `ParentComponent` from `ChildComponent` in the context
    of our test. We need this level of separation in order to create a proper isolation
    of our unit test. As our mock child component simply renders the string representation
    of the passed array, we can easily test the text content of our fixture.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The definition of a unit test is to test a single unit and isolate the unit
    from any dependencies. If we want to stick to this paradigm, we'd need to create
    a mock for every dependent component. This can easily get us into a situation
    where we need to maintain more complexity only for the sake of our tests. The
    key here lies in finding the right balance. You should mock dependencies that
    have a great impact on our subject and ignore dependencies that have low impact
    on the functionality we'd like to test.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a different use case where we have a component that injects a
    service in order to obtain data. As we also want to test only our component and
    not the service it relies on, we somehow need to sneak in a mock service instead
    of the real service into our component. `TestComponentBuilder` also provides a
    method to modify the `providers` metadata of directives, which comes in very handy
    for this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare our base component and a service that it relies on. In this
    example, the `NumbersComponent` class injects the `NumbersService` class, and
    it obtains an array with numbers from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a mock service that provides the data required in our
    test and isolates our component from the original service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this simplified example, we just provide a different set of numbers. However,
    in a real mocking case, we can exclude a lot of steps that are unnecessary and
    could potentially create side effects. Using a mock service also ensures that
    our test, which is focused on the `NumbersComponent` class, will not break because
    of a change in the `NumbersService` class.
  prefs: []
  type: TYPE_NORMAL
- en: By extending the real service, we can leverage some of the behavior of our original
    service while overriding certain functionality in our mock. You need to be careful
    with this approach though, as we rely on the original service by doing this. If
    you'd like to create a fully isolated test, you should probably override all methods
    and properties. Or you can create a completely independent mock service, which
    provides the same methods and properties that are used in your test.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using TypeScript, you should use interfaces for this purpose where both
    your real service as well as your mock service implement the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the test case and how we can use `TestComponentBuilder`
    to provide our mock service instead of the real one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using the `overrideProviders` method on `TestComponentBuilder`, we can provide
    additional providers to the component under test. This allows us to override existing
    providers that are already present on the component. Using the `provide` function
    of the `@angular/core` module, we can create a provider which provides on requests
    for `NumberService` but also resolves to a `MockNumberService`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestComponentBuilder` allows us to perform tests in a very simple, isolated,
    and flexible fashion. It plays a major role when writing unit tests for components.
    If you''d like to read more about the available methods on `TestComponentBuilder`,
    you can visit the official documentation website at [https://angular.io/docs/ts/latest/api/core/testing/TestComponentBuilder-class.html](https://angular.io/docs/ts/latest/api/core/testing/TestComponentBuilder-class.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to use what we learned about `TestComponentBuilder` service and
    start to test our application components in action!
  prefs: []
  type: TYPE_NORMAL
- en: Testing components in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous topic, we learned about the `TestComponentBuilder` service and
    how to use it to create components in our testing environment. We learned about
    the `inject` and `async` helpers as well as how to mock components and services.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now use this knowledge to work on our tests for the `AutoComplete` component.
    Let's add another test to the `auto-complete.spec.js` file on the `lib/ui/auto-complete`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `AutoComplete` component relies on the rather complex `Editor` component,
    it''s probably a good idea to mock our `Editor` component before we start writing
    a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This might look a bit tenuous, but this is actually all that we need for our
    current tests on the `AutoComplete` component. The `Editor` component should just
    accept a content input, which is the main interaction between the two components.
    In the template of our `MockEditor` component, we just render the content input
    property. This way, we can easily verify the result of using the `AutoComplete`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this mock editor to write our next test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In our tests, we'd like to test whether the `AutoComplete` component initializes
    `Editor` (respectively, our `MockEditor` component) with the right content. We
    test whether `selectedItem` of our `AutoComplete` component successfully reflects
    into the editor.
  prefs: []
  type: TYPE_NORMAL
- en: We use `TestComponentBuilder`, which creates components asynchronously. Using
    the `async` helper function, we tell Jasmine to wait for all asynchronous operations
    to complete for this test.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ComponentFixture` that is provided by `TestComponentBuilder`, we
    can start to interact with the created component. Using the `componentInstance`
    member of the component fixture, we can set the required input properties of our
    `AutoComplete` component.
  prefs: []
  type: TYPE_NORMAL
- en: As we're responsible for the triggering of change detection manually in our
    tests, we use the `detectChanges` method on our fixture to update the component
    view, based on the new state. This will initiate the change detection lifecycle
    on our component and perform the necessary view updates.
  prefs: []
  type: TYPE_NORMAL
- en: After the view updates both of our `AutoComplete` component and the underlying
    `MockEditor` component, we can run our assertions to validate the updated DOM
    by getting the text content of the `nativeElement` property on our fixture.
  prefs: []
  type: TYPE_NORMAL
- en: For this particular test, we're fine with this approach. However, in other scenarios
    where we have more DOM elements involved, it wouldn't be sufficient to assert
    on the root component's `textContent` property directly. This would probably include
    a lot of noise, which we're not interested in for our assertion. We should always
    try to narrow our assertion to the fewest details possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have access to the native DOM element on our fixture, we can simply use
    the DOM API to select child elements in order to narrow our assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This would successfully select the DOM element of our mock editor, and we can
    only check the text content inside the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Although this would be a feasible approach, Angular provides us with a much
    better approach to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Provided by `ComponentFixture`, we have access to the `DebugElement` tree that
    is created by `DebugDomRootRenderer` in the context of our test. `DebugElement`
    allows us advanced inspection of the element tree that was created by Angular
    when rendering our components. It also contains an advanced querying API, which
    allows us to search for certain elements in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our test to use the advanced capabilities provided by `DebugElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `query` and `queryAll` methods that are available on every `DebugElement`
    object allow us to query the Angular view tree like we would query a DOM tree
    using `querySelector` and `querySelectorAll`. The difference here is that we can
    use a predicate helper to query for matching elements. Using the `By` helper class,
    we can create these predicates, which will then be used in order to query the
    `DebugElement` tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently three different predicates available using the `By` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `By.all()` | This is the predicate, which will result in querying for all
    the child `DebugElement` object of the current `DebugElement` object |'
  prefs: []
  type: TYPE_TB
- en: '| `By.css(selector)` | This is the predicate, which will result in querying
    for `DebugElement` using the specified CSS selector |'
  prefs: []
  type: TYPE_TB
- en: '| `By.directive(type)` | This is the predicate, which will result in querying
    for `DebugElement` that contain the specified directive |'
  prefs: []
  type: TYPE_TB
- en: Going back to our test, we can now use the query method on the fixture debug
    element in order to query for our editor. As we've exchanged the real `Editor`
    component with our `MockEditor` component, we need to query for the latter. We
    use a `By.directive(MockEditor)` predicate, which will successfully query for
    the `DebugElement` object that represents the host element of our `MockEditor`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The `query` method of the `DebugElement` object will always return a new `DebugElement`
    object of the first found element if there was a match. It will return `null`
    if the queried element was not found.
  prefs: []
  type: TYPE_NORMAL
- en: The `queryAll` method of the `DebugElement` will return an array of many `DebugElement`
    which contains all elements that match the predicate. If there were no matching
    elements, this method will return an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: Testing component interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although UI interaction testing is probably part of end-to-end testing, we'll
    look at how to test basic user interaction on your components in this topic.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we'll test the autocomplete component behavior if the user clicks
    on an item in the callout window that shows all available items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this test to the already existing `auto-complete.spec.js` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, we want to set up a Jasmine spy on the `selectedItemChange` `EventEmitter`
    `next` function for our test. This way, we can check later whether our `AutoComplete`
    component successfully emitted the event when the user selects an item from the
    callout.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Given` section of our test code, we also call the `onEditModeChanged`
    and `onEditableInput` methods on the `AutoComplete` component instance. With these
    calls, we simulate the editor that was used, and there's currently no content
    in the editor. This will result in the desired filtering, which will present all
    available items in the callout for selection.
  prefs: []
  type: TYPE_NORMAL
- en: In the `When` section of our code, we first need to trigger change detection
    on the fixture. This results in the callout with all available auto-complete items
    being rendered in the `AutoComplete` component.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can simulate the `click` event on one of our autocomplete items to fishing
    the actions in this test.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll select all `DebugElement` object that match the CSS class of our
    autocomplete items in the callout. This will provide us with an array containing
    all the elements, where we can now use the `Array.prototype.find` method to select
    one specific item based on the contained text.
  prefs: []
  type: TYPE_NORMAL
- en: On the `DebugElement` resulting from our query, we now call the `triggerEventHandler`
    method to simulate a click event. This will actually not trigger a real click
    event, but rather it will execute the handler attached to the binding in the view
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: After simulating a click on the autocomplete item with the text content of `two`,
    we can now inspect our spy on the `selectedItemChange.next` function. According
    to the behavior in our component, this should have been called with the selected
    item value.
  prefs: []
  type: TYPE_NORMAL
- en: Testing user interaction on components is made very easy using the `DebugElement`.
    We also decouple our tests from the underlying DOM events by taking the shortcut
    enabled by the `triggerEventHandler` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `triggerEventHandler` method operates on the virtual element tree of Angular,
    rather than the actual DOM tree. Due to this, we can also use this method to trigger
    event handlers that are attached to component output properties.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our plugin system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we created tests for the `AutoComplete` component,
    which is a rather simple UI component. However, we learned about all the techniques
    that are required to perform testing on more complex components or even systems
    of components.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll look into testing the plugin system that was created in [Chapter
    10](part0064.xhtml#aid-1T1401 "Chapter 10. Making Things Pluggable"), *Making
    Things Pluggable*.
  prefs: []
  type: TYPE_NORMAL
- en: It's probably a good time to recap on the plugin system architecture overview
    before working on this topic. As always with testing, it's crucial to understand
    exactly what's happening in the system under test.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new `plugin.spec.js` file in the `lib/plugin` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement our first test function for this subject, we will need
    to create some dummy components and plugins to test our system with. Let''s create
    these at the top of our testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special here. We declare two dummy components with a static template
    that will serve us in performing our plugin tests. Additionally, we created a
    dummy application component, which will be our main testing component. In the
    following tests, we will make use of a dummy component to test our `PluginSlot`
    directive, as opposed to testing a component directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to mock our `PluginService` injectable, which is designed
    to load plugins asynchronously from URLs. In our mock, we''d want to override
    this functionality. Instead of loading plugins from URLs, we want to load some
    predefined test plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We override the `loadPlugins` method to avoid any plugins being loaded during
    the construction of the service. We also override the RxJS subject present on
    the `change` property in order to prevent any reactive behavior of our plugin
    system because this would only disturb our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive right into our first test where we want to test a very basic plugin
    with one plugin component, to be instantiated correctly by the `PluginSlot` directive.
    First, we set up our test structure using the `describe` and `it` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here to what we already knew is that we use a new `beforeEachProviders`
    function from the `@angular/core/testing` module. This function allows us to set
    up some default providers that are used in our tests. As all our plugin system
    tests will rely on the presence of `PluginService`, we use this function to set
    up the mock provider resolving to our `MockPluginService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using `beforeEachProviders`, we could also use the `overrideProviders`
    method in the `TestComponentBuilder` to provide additional injectables. However,
    this will limit the use to the inside of our components. If we want to interact
    with the service from our test function, we need to use the `beforeEachProviders`
    helper.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `inject` helper, we inject `TestComponentBuilder` and `PluginService`,
    which we provided using the `beforeEachProviders` helper.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now implement the missing test body inside of the `Promise` callback after
    executing `createAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, we define a new dummy plugin, which uses the `PluginConfig`
    decorator from the previous chapter. We create a `PluginPlacement` in the plugin
    metadata, which includes a mapping of `DummyPluginComponent1` into the slot with
    the name `dummy-slot`. If you take a look at the `DummyApplication` component
    that we use in this test again, you can see that it contains a `PluginSlot` directive
    with the name attribute set to `dummy-slot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This plugin should now cause the `DummyPluginComponent1` component to be rendered
    in the plugin slot of our `DummyApplication` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, we add the `DummyPlugin` class to the plugins list of our `MockPluginService`
    mock service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The object that we're adding to the plugins array of the `MockPluginService`
    simply simulates a plugin that would normally be loaded in `PluginService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we put aside a reference to the `PluginSlot` directive, which is placed
    in our `DummyApplication` component. For this, we can use the `query` method on
    the `DebugElement` root of our fixture. We use a predicate, which allows us to
    query by the directive type of our `PluginSlot` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We need the reference to the directive instance of the plugin slot in order
    to initialize the slot prior to our test assertion. This is an important step
    because we can't rely on the observable subject in our `MockPluginService` class
    to initialize our `PluginSlot` directive. We explicitly disabled the reactive
    features of our plugin system in order to perform proper testing. Therefore, we
    need to manually initialize our plugin slot before we can perform any assertion.
  prefs: []
  type: TYPE_NORMAL
- en: After executing the query with the directive predicate (searching for an element
    which contains the `PluginSlot` directive), we'll receive `DebugElement` of our
    plugin slot element. In order to get the directive instance, we use the element
    injector present on each `DebugElement` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `initialize` method on the `PluginSlot` component instance will create
    all relevant plugin components. Luckily, this will also return a `Promise` to
    us, which will be resolved once all components have been created in the view of
    our `ApplicationDummy` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the callback of the `Promise` returned by the `initialize` method of the
    `PluginSlot` instance, we can finally assert on the text content of the root element
    of our `DummyApplication` component.
  prefs: []
  type: TYPE_NORMAL
- en: As the `DummyPluginComponent1` class has a simple static template that contains
    the text `dummy1`, we should see a complete text content of `dummy-slot:dummy1`
    in our application view.
  prefs: []
  type: TYPE_NORMAL
- en: This is it for our first plugin test. Now, we will look at a second test, which
    we'll use to verify another feature of our plugin system. Our plugin system should
    also be able to render two components of the same plugin into two separate plugin
    slots. However, in the template of our `DummyApplication` component, we currently
    only have one plugin slot with the name `dummy-slot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to modify the template of our `DummyApplication` component just for
    a particular test, we can use the `overrideTemplate` method on `TestBuilderComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In our test function, we create a new template for our `DummyApplication` component.
    We're adding two plugin slots to the template with their name attributes set to
    `dummy-slot1` and `dummy-slot2`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use the `overrideTemplate` method on `TestComponentBuilder` to override
    the `DummyApplication` component template before we create it. This provides us
    with the necessary flexibility to reuse mock and dummy components for different
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code that comes in the `createAsync` promise callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new `DummyPlugin` plugin class and use the `PluginConfig`
    decorator to configure it. In the placement metadata, we configure the mappings
    so that we map two components into different plugin slots. The first component
    is mapped to the plugin slot with the name `DummySlot1`, while the second one
    will go to the slot with the name `DummySlot2`. We've overridden our `DummyApplication`
    template to include both of these plugin slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now add our `DummyPlugin` class to the `MockPluginService` class and simulate
    the plugin being loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code queries for `DebugElements` in the fixture using the `queryAll`
    method. We use a predicate that queries for all elements containing the `PluginSlot`
    directive. With an additional call to `Array.prototype.map`, we transform the
    array in order to get back the component instances of the discovered `PluginSlot`
    components directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to complete our test. Using the `Promise.all` function, we''re
    able to streamline an array of Promises into a single Promise, which will resolve
    once all underlying Promises are resolved. We can then map our `pluginSlots` array
    by executing the initialize method on each of the `PluginSlot` components. This
    will return an array of Promises to us, which will resolve when all components
    within the plugin slots are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the `then` callback of the consolidated promise using the `Promise.all` function,
    we can finally perform our assertion. With the overridden template of our `DummyApplication`
    component and the output of our two plugin components in the two separated plugin
    slots, we should get a text content of `dummy-slot1:dummy1dummy-slot2:dummy2`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last test that we look at in this chapter. However, there are more
    tests in the code that comes with this book. Just check out the code repository
    and get your hands on those tests yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to write concise unit tests for our components.
    We followed a BDD style approach of writing tests, and we also covered the basics
    of the JavaScript testing framework, Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the debugging tools that are available in Angular and how to
    set up an injector environment for testing. Using `TestComponentBuilder`, we were
    able to perform tests in a very flexible but precise way. We also learned about
    the view tree of multiple `DebugElement` that are created along with `TestComponentBuilder`
    running in the debug environment. This allowed us to perform clever inspection
    and apply practical queries to the rendered views in order to assert expected
    results.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `inject` and `async` helpers to inject dependencies and, at the
    same time, run asynchronous tests. We built both mock and dummy components in
    order to isolate our tests from the rest of our application.
  prefs: []
  type: TYPE_NORMAL
