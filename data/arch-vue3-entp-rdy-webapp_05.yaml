- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: An Introduction to GraphQL, Queries, Mutations, and RESTful APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL、查询、突变和 RESTful API 简介
- en: In the previous chapters, we explored different libraries and methods to develop
    large-scale enterprise applications using Vue 3\. In this chapter, we will first
    understand what GraphQL is and how it is different from REST. Next, we will explore
    GraphQL, GraphQL Apollo Server 2, queries, and mutations, and how to integrate
    these technologies into your Vue.js 3 application. In addition, you will learn
    how to utilize GraphQL to deliver scalable and high-performing applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了使用 Vue 3 开发大规模企业应用的不同库和方法。在本章中，我们将首先了解 GraphQL 是什么以及它与 REST 的不同之处。接下来，我们将探索
    GraphQL、GraphQL Apollo Server 2、查询和突变，以及如何将这些技术集成到您的 Vue.js 3 应用程序中。此外，您还将学习如何利用
    GraphQL 来提供可扩展且性能高的应用程序。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: An introduction to GraphQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 简介
- en: Understanding queries and mutations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解查询和突变
- en: Integrating GraphQL Apollo Client with Vue 3
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 GraphQL Apollo 客户端与 Vue 3 集成
- en: Also, in this chapter, you will learn how to integrate GraphQL into Vue 3 and
    structure it properly following the law of predictability by implementing a login
    and register authentication system using the GraphQL Apollo client and Vue 3.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，您将学习如何将 GraphQL 集成到 Vue 3 中，并按照可预测性原则正确地构建它，通过使用 GraphQL Apollo 客户端和
    Vue 3 实现登录和注册认证系统。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get started with this chapter, we recommend you read through [*Chapter 4*](B17237_04.xhtml#_idTextAnchor112),
    *Architecture for Large-Scale Web Applications*, where we explored building large-scale
    enterprise applications with different industry-standard structuring, architecture,
    and standards.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章的学习，我们建议您阅读 *第 4 章*，*大规模 Web 应用程序的架构*，其中我们探讨了使用不同的行业标准结构、架构和标准来构建大规模企业应用。
- en: 'All the code files for this chapter can be found at: [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5)。
- en: An introduction to GraphQL
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL 简介
- en: GraphQL is the new buzzword in the API development industry. While REST remains
    the most popular way to expose data from a server, it comes with many limitations
    that GraphQL tends to solve.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是 API 开发行业中的新热点。虽然 REST 仍然是暴露服务器数据最流行的方式，但它带来了许多 GraphQL 倾向于解决的局限性。
- en: GraphQL is a query language created and maintained by Facebook. The purpose
    of creating GraphQL is to build client applications based on intuitive and flexible
    syntax for describing their data requirements and interactions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是由 Facebook 创建和维护的一种查询语言。创建 GraphQL 的目的是构建基于直观和灵活语法的客户端应用程序，以描述它们的数据需求和交互。
- en: One of the benefits of GraphQL is that we have a single endpoint to access all
    data from the server instead of having multiple endpoints in REST.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 的一个好处是，我们有一个单一的端点可以访问服务器上的所有数据，而不是在 REST 中有多个端点。
- en: In this section, we will explore everything you need to know about GraphQL,
    the different unique features of GraphQL, and why you should consider GraphQL
    instead of the RESTful API design pattern. Lastly, we will work you through creating
    and setting up your first GraphQL server with Express.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨您需要了解的所有关于 GraphQL 的内容，GraphQL 的不同独特特性，以及为什么您应该考虑使用 GraphQL 而不是 RESTful
    API 设计模式。最后，我们将指导您创建并设置您的第一个 GraphQL 服务器，使用 Express。
- en: What is GraphQL?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 GraphQL？
- en: As per the official documentation (https://graphql.org/),
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档（https://graphql.org/），
- en: GraphQL is a query language for APIs and a runtime for fulfilling those queries
    with your existing data. GraphQL provides a complete and understandable description
    of the data in your API, gives clients the power to ask for exactly what they
    need and nothing more, makes it easier to evolve APIs over time, and enables powerful
    developer tools.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是一种用于 API 的查询语言，也是执行这些查询的运行时环境。GraphQL 为您的 API 中的数据提供了完整且易于理解的定义，赋予客户端请求所需数据的权力，而不需要更多，这使得
    API 随时间演变变得更加容易，并使强大的开发者工具成为可能。
- en: GraphQL is a server-side runtime for executing queries using the type system
    you define for your data. Also, GraphQL is not tied to any specific database or
    storage engine but instead backed by your existing code and data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是一个服务器端运行时，用于执行使用您为数据定义的类型系统进行的查询。此外，GraphQL 不绑定到任何特定的数据库或存储引擎，而是由您现有的代码和数据支持。
- en: '![Figure 5.1 – A diagram explaining GraphQL (Source: https://www.wallarm.com/what/what-is-graphql-definition-with-example)](img/Figure_5.01_B17237.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 解释 GraphQL 的图表（来源：https://www.wallarm.com/what/what-is-graphql-definition-with-example）](img/Figure_5.01_B17237.jpg)'
- en: 'Figure 5.1 – A diagram explaining GraphQL (Source: https://www.wallarm.com/what/what-is-graphql-definition-with-example)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 解释 GraphQL 的图表（来源：https://www.wallarm.com/what/what-is-graphql-definition-with-example）
- en: The GraphQL type system defines various data types that can be used in a GraphQL
    application. This type system helps to define the schemas that will be used in
    the GraphQL application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 类型系统定义了可以在 GraphQL 应用程序中使用的各种数据类型。这个类型系统有助于定义将在 GraphQL 应用程序中使用的模式。
- en: To create a GraphQL service, you need to start by defining schema types and
    creating fields on those types, then providing functions to be executed on each
    field.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 GraphQL 服务，你需要首先定义模式类型，并在这些类型上创建字段，然后提供在每个字段上执行的功能。
- en: 'For example, we can define a new schema type called `Photo` in the following
    code snippet to demonstrate how types work in GraphQL:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在以下代码片段中定义一个新的模式类型 `Photo`，以演示类型在 GraphQL 中的工作方式：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we have an idea of GraphQL and have seen how to define a GraphQL schema
    type. Next, let’s explore the features of GraphQL before we dive deeper into creating
    GraphQL queries and resolvers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 GraphQL 有了一定的了解，也看到了如何定义 GraphQL 模式类型。接下来，在我们深入创建 GraphQL 查询和解析器之前，让我们探索
    GraphQL 的特性。
- en: Features of GraphQL
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL 的特性
- en: GraphQL comes with excellent features. We are going to explore a few of the
    features of GraphQL in the following subsections.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 拥有出色的功能。我们将在接下来的小节中探索 GraphQL 的几个功能。
- en: Easy to get started
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 易于开始
- en: The learning curve of GraphQL is easy, especially for developers who are familiar
    with building APIs with RESTful design patterns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 的学习曲线很容易，尤其是对于熟悉使用 RESTful 设计模式构建 API 的开发者来说。
- en: Users can get started with GraphQL with small queries for fetching data right
    away and learn about the advanced features a bit later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以从使用小查询立即获取数据开始使用 GraphQL，稍后可以了解一些高级特性。
- en: Built for interactive apps
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为交互式应用程序而构建
- en: GraphQL is built for real-time and interactive applications because changes
    between the client and the server happen almost immediately, giving a swift response.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是为实时和交互式应用程序而构建的，因为客户端和服务器之间的变化几乎立即发生，从而提供快速响应。
- en: Small and flexible
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小巧灵活
- en: GraphQL allows users to request and receive the exact data that was requested.
    This feature solves the problem of over- and under-fetching with RESTful APIs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 允许用户请求并接收请求的确切数据。此功能解决了 RESTful API 中过度和不足获取的问题。
- en: Universally compatible
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 兼容性强
- en: GraphQL Apollo is built to be compatible with any build setup, any GraphQL server,
    and any GraphQL schema.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Apollo 是为了与任何构建设置、任何 GraphQL 服务器和任何 GraphQL 模式兼容而构建的。
- en: Incrementally adoptable
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可逐步采用
- en: GraphQL is built to make integrating into a new or existing project effortless
    without breaking any changes. It is easily adaptable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是为了使集成到新项目或现有项目中变得毫不费力而构建的，而不会破坏任何更改。它很容易适应。
- en: Why use GraphQL instead of REST?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用 GraphQL 而不是 REST？
- en: In this section, we will identify some properties of GraphQL and discuss why
    you should use GraphQL for your subsequent API development instead of RESTful
    APIs. We will discuss a few of these properties. Additionally, we will get into
    a detailed comparison of these technologies with the GraphQL versus RESTful API
    guide in this section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将确定 GraphQL 的一些特性，并讨论为什么你应该在后续的 API 开发中使用 GraphQL 而不是 RESTful API。我们将讨论这些特性中的几个。此外，我们将在本节中详细比较这些技术与
    GraphQL 与 RESTful API 指南。
- en: The following subsections mention the top five reasons why you should use GraphQL
    instead of RESTful API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将提到使用 GraphQL 而不是 RESTful API 的前五个原因。
- en: Strongly-typed schema
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强类型模式
- en: In GraphQL, **Schema Definition Language** (**SDL**) is used to define the contract
    between the client and the server and to define how the client accesses the data
    in the server. GraphQL uses a strong type system to define the capabilities of
    the API. All the APIs exposed to the client are written down in a schema called
    the SDL.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，**模式定义语言**（**SDL**）用于定义客户端和服务器之间的合同以及定义客户端如何访问服务器中的数据。GraphQL 使用强类型系统来定义
    API 的功能。所有暴露给客户端的 API 都记录在一个称为 SDL 的架构中。
- en: Once these schemas are defined, both the frontend and the backend can communicate
    separately without any further changes or assistance since the frontend knows
    that the data in the schema is always going to be in sync or consistent across
    the system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了这些架构，前端和后端就可以在没有任何进一步更改或帮助的情况下单独通信，因为前端知道架构中的数据始终会在整个系统中保持同步或一致。
- en: This solves the data inconsistency problem in REST. The frontend expects a specific
    dataset but retrieves a different one due to changes since no consistent schema
    is defined.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了 REST 中的数据不一致问题。前端期望获取特定的数据集，但由于没有定义一致的架构，因此检索到了不同的数据。
- en: No over-fetching or under-fetching
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无过度或不足获取数据
- en: The issue of over- or under-fetching is a known problem with RESTful APIs where
    clients download data by hitting endpoints that return fixed data structures or
    retrieve either excessive amounts of data or less than what they expected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 过度或不足获取数据的问题是 RESTful API 中已知的问题，其中客户端通过访问返回固定数据结构或获取过多或过少数据的端点来下载数据。
- en: Over-fetching is the problem of fetching more data than what is required in
    the app. It can also mean fetching more data than what is required to fulfill
    the request. With a RESTful API, you have to fetch all the user’s details or create
    a new endpoint that returns only the names of all the users of your application
    just to display only the name of the user on your frontend application. While
    in GraphQL, you can use just a single query to return only the name of all the
    users or any other details by creating a separate query or endpoint.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 过度获取数据是获取比应用程序所需更多数据的问题。它也可以意味着获取比满足请求所需更多的数据。在使用 RESTful API 时，你必须获取所有用户的详细信息或创建一个新的端点，该端点仅返回应用程序中所有用户的名称，只是为了在您的前端应用程序中显示用户的名称。而在
    GraphQL 中，你可以使用单个查询仅返回所有用户的名称或任何其他详细信息，通过创建单独的查询或端点。
- en: Under-fetching is rare, but it happens when the specific endpoint does not provide
    all the required information. The client must make additional requests to access
    the other information as needed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不足获取数据很少见，但发生在特定端点没有提供所有所需信息的情况下。客户端必须根据需要发出附加请求以访问其他信息。
- en: GraphQL solves this problem by providing a medium for the client to specify
    the information needed, and it returns exactly the required information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 通过提供一个客户端指定所需信息的媒介来解决此问题，并返回所需的确切信息。
- en: Saving time and bandwidth
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节省时间和带宽
- en: The problem of over-fetching can result in higher bandwidth consumption for
    clients, which may, in time, cause lagging in your application. Using RESTful
    API design patterns, it is more time-consuming to sort out the information needed
    from an enormous payload.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 过度获取数据的问题可能会导致客户端带宽消耗增加，这可能会随着时间的推移导致应用程序出现延迟。使用 RESTful API 设计模式，从大量负载中整理所需信息需要更多时间。
- en: GraphQL allows you only to select what you need, thereby reducing the amount
    of payload transferred over the network.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 允许你只选择你需要的内容，从而减少通过网络传输的数据量。
- en: Multiple endpoints
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个端点
- en: One of the significant problems of RESTful APIs is having too many endpoints
    to access information. For instance, if a client wants to access a particular
    user by their ID, you will be presented with `/users/1`. Also, if you’re going
    to access that user’s photos, you will have to send a request to another endpoint,
    `/users/1/photos`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 的重要问题之一是端点过多，难以访问信息。例如，如果客户端想要通过 ID 访问特定用户，你将看到 `/users/1`。此外，如果你要访问该用户的照片，你必须向另一个端点
    `/users/1/photos` 发送请求。
- en: In GraphQL, you have a single endpoint, and you don’t need to send multiple
    requests to retrieve different information about the user.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，你只有一个端点，并且不需要发送多个请求来获取关于用户的不同信息。
- en: 'With GraphQL, you can access all the user’s information in a single request,
    as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，使用 GraphQL，你可以在单个请求中访问所有用户的信息：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding script will only access `name` of the user and `title` and `url`
    of all the user’s `photos`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本将仅访问用户的`name`以及所有用户的`photos`的`title`和`url`。
- en: Versioning is not required
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制不是必需的
- en: Versioning is a feature of RESTful APIs where different versions are assigned
    to an API when changes and updates are made to it. This is done to avoid breaking
    changes in production that might cause issues for the user.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是RESTful API的一个特性，当对API进行更改和更新时，会为API分配不同的版本。这样做是为了避免在生产中造成破坏性更改，可能会对用户造成问题。
- en: If we want users to use our new features in the latest version, we have to force
    them to update the application, which is not a good user experience.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望用户使用最新版本的我们的新功能，我们必须强迫他们更新应用程序，这并不是一个好的用户体验。
- en: In GraphQL, there is no need to worry about versioning and forcing users to
    update their application to use the new changes since it happens automatically,
    and clients only implement the features available in the SDL.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL中，无需担心版本控制，也不需要强迫用户更新他们的应用程序以使用新更改，因为它是自动发生的，客户端只实现SDL中可用的功能。
- en: Here, we have discussed the different features and benefits of using GraphQL
    and why you should consider using GraphQL instead of RESTful APIs. In the next
    section, we will further discuss the difference between GraphQL and RESTful APIs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论了使用GraphQL的不同功能和好处，以及为什么你应该考虑使用GraphQL而不是RESTful API。在下一节中，我们将进一步讨论GraphQL与RESTful
    API之间的区别。
- en: The difference between GraphQL and RESTful APIs
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL与RESTful API的区别
- en: The core difference between GraphQL and REST is that GraphQL is a specification
    and a query language, while REST APIs are an architectural concept for network-based
    applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL与REST之间的核心区别在于，GraphQL是一个规范和查询语言，而REST API是网络应用程序的架构概念。
- en: Both concepts play an important role in creating and maintaining scalable microservices
    and large-scale enterprise applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念在创建和维护可扩展的微服务和大型企业应用中发挥着重要作用。
- en: Therefore, choosing a particular technology to go with will depend on your level
    of expatriation in each technology, which one your team is comfortable with, and
    which one makes your product development easier and faster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择特定的技术将取决于你在每种技术中的国际化程度，你团队对哪种技术更舒适，以及哪种技术使你的产品开发更容易、更快。
- en: 'The following points show you the other differences you might want to consider:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点展示了你可能想要考虑的其他差异：
- en: GraphQL is a query language used to solve problems by integrating APIs, while
    REST API is an architectural style that describes the conventional standard for
    designing APIs
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL是一种查询语言，通过集成API来解决问题，而REST API是一种描述设计API的传统标准的架构风格
- en: Additionally, with GraphQL, you can use a single endpoint to access all the
    data in your server without the need for multiple endpoints, while REST API allows
    multiple endpoints and a set of URLs that each exposes a single resource, which
    can be confusing to understand
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，使用GraphQL，你可以使用单个端点访问服务器上的所有数据，无需多个端点，而REST API允许多个端点和一组URL，每个URL都暴露一个单一的资源，这可能会让人难以理解
- en: GraphQL uses a client-driven architecture and lacks an in-built caching mechanism,
    while REST API uses a server-driven architecture and uses caching automatically
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL使用客户端驱动的架构，缺乏内置的缓存机制，而REST API使用服务器驱动的架构并自动使用缓存
- en: No API versioning is required in GraphQL, and its response is only in JSON format,
    while REST APIs support multiple API versioning and allow response output in XML,
    JSON, or YAML
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GraphQL中不需要API版本控制，其响应仅以JSON格式，而REST API支持多个API版本控制，并允许以XML、JSON或YAML格式输出响应
- en: GraphQL offers type safety and auto-generated documentation and it also allows
    schema stitching and remote data fetching, while REST API doesn’t offer type safety
    or auto-generated documentation, and simplifying work with multiple endpoints
    requires expensive custom middleware
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL提供类型安全和自动生成的文档，它还允许模式拼接和远程数据获取，而REST API不提供类型安全或自动生成的文档，简化与多个端点的工作需要昂贵的自定义中间件
- en: GraphQL is also an application-layer server-side technology used for executing
    queries with existing data, while REST is a software architectural style used
    to define a set of constraints for creating web services
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL也是一种用于执行现有数据查询的应用层服务器端技术，而REST是一种用于定义创建网络服务约束的软件架构风格
- en: GraphQL can be organized in terms of a schema, while REST is not arranged or
    organized in schemas but is arranged in terms of endpoints
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 可以根据模式组织，而 REST 则不是根据模式组织，而是根据端点组织
- en: The development speed in GraphQL is faster when compared with REST APIs
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 REST API 相比，GraphQL 的开发速度更快
- en: The message format for GraphQL mutations should be a string, while the message
    format for REST APIs can be anything
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 突变的消息格式应该是一个字符串，而 REST API 的消息格式可以是任何内容
- en: GraphQL uses metadata for query validation, while REST does not have cacheable
    machine-readable metadata
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 使用元数据来进行查询验证，而 REST 没有可缓存的机器可读元数据
- en: We have explored the difference between GraphQL and REST API to give you an
    insight into which is better for your enterprise application. We will allow you
    to make a choice, but we will explore GraphQL in more depth in the following sections.
    In the next section, we will discuss queries and mutations, expanding more on
    how to create your first query and mutation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 GraphQL 和 REST API 之间的区别，以便让你了解哪个更适合你的企业应用。我们将让你做出选择，但在接下来的章节中我们将更深入地探讨
    GraphQL。在下一节中，我们将讨论查询和突变，进一步介绍如何创建你的第一个查询和突变。
- en: Understanding queries and mutations in GraphQL
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GraphQL 中的查询和突变
- en: Queries and mutations are vital in GraphQL because they are the only way to
    access or send data to the GraphQL server from your frontend.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查询和突变在 GraphQL 中至关重要，因为它们是访问或从前端向 GraphQL 服务器发送数据的唯一方式。
- en: Using queries
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询
- en: GraphQL queries define all the queries that a client can run on the GraphQL
    API. If you’re familiar with REST APIs, it is synonymous with the popular `GET`
    requests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 查询定义了客户端可以在 GraphQL API 上运行的查询。如果你熟悉 REST API，它与流行的 `GET` 请求同义。
- en: You can define GraphQL queries in many ways, but defining a root query to wrap
    all your queries is recommended.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用多种方式定义 GraphQL 查询，但建议定义一个根查询来包装所有的查询。
- en: 'The following code snippet shows you how to define a root query called `RootQuery`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何定义一个名为 `RootQuery` 的根查询：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also define individual queries for `User` and `Photo` like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像这样为 `User` 和 `Photo` 定义单独的查询：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the preceding queries, we have successfully defined endpoints to retrieve
    users and photos corresponding to how it can be done with REST API using the `GET`
    method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的查询，我们已经成功定义了端点来检索用户和照片，这与使用 REST API 的 `GET` 方法执行的方式相同。
- en: Next, we will explore how to create or update data on our GraphQL API using
    mutations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用突变在 GraphQL API 上创建或更新数据。
- en: Using mutations
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用突变
- en: Mutations in GraphQL are used to create, update, and delete data from our GraphQL
    API, and are synonymous with REST API’s `POST`, `PUT`, and `DELETE` methods, respectively.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 中的突变用于从我们的 GraphQL API 创建、更新和删除数据，分别与 REST API 的 `POST`、`PUT` 和 `DELETE`
    方法同义。
- en: 'Creating mutations in GraphQL is simple; take a look at the following snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中创建突变很简单；看看下面的代码片段：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding snippet shows how to create mutations. Furthermore, we have created
    `createUser`, `updateUser`, and `removeUser` to create, update, and delete users
    from the GraphQL API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了如何创建突变。此外，我们还创建了 `createUser`、`updateUser` 和 `removeUser` 来从 GraphQL
    API 中创建、更新和删除用户。
- en: Most importantly, for GraphQL to connect to our database and carry out the operations
    in both queries and mutations, we need to define a resolver, which we will cover
    in the next subsection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，为了让 GraphQL 连接到我们的数据库并在查询和突变操作中执行操作，我们需要定义一个解析器，这将在下一小节中介绍。
- en: Resolvers
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析器
- en: A GraphQL resolver connects our queries and mutations to the right methods for
    execution. It informs GraphQL what to do when each of these queries/mutations
    is requested. It is a basic function that does the hard work of hitting the database
    layer to do the CRUD operations, hitting an internal REST endpoint, or calling
    a microservice to fulfill the client’s request.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 解析器将我们的查询和突变连接到执行的正确方法。它通知 GraphQL 在请求每个查询/突变时应该做什么。这是一个基本功能，它执行击中数据库层以执行
    CRUD 操作、击中内部 REST 端点或调用微服务以满足客户端请求的繁重工作。
- en: 'Let’s map the queries/mutations we have created in the preceding sections to
    a resolver that will be called when any of the queries/mutations are requested:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面章节中创建的查询/突变映射到一个解析器上，该解析器将在请求任何查询/突变时被调用：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To foster understanding, we imported our model from `sequelize`, which is a
    database **object-relational mapping** (**ORM**) to manipulate database tables
    with defined methods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进理解，我们导入了来自 `sequelize` 的模型，这是一个用于使用定义的方法操作数据库表的 **对象关系映射**（**ORM**）。
- en: Next, we created and exported a `resolver` function, which returns an object
    containing `RootQuery` and `RootMutation`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建并导出了一个 `resolver` 函数，它返回一个包含 `RootQuery` 和 `RootMutation` 的对象。
- en: Next, inside the `RootQuery` and `RootMutation` objects, we resolve each of
    the methods with the appropriate business logic to be executed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `RootQuery` 和 `RootMutation` 对象内部，我们使用适当的企业逻辑解决每个方法。
- en: For example, when a client requests all users, the GraphQL frontend client will
    call the user’s queries defined in the `sequelize` ORM. The same logic applies
    to all the mutations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当客户端请求所有用户时，GraphQL 前端客户端将调用定义在 `sequelize` ORM 中的用户查询。相同的逻辑适用于所有突变。
- en: In this section, we explained of how GraphQL works and how you can create your
    own GraphQL API to understand the best way to structure your GraphQL client in
    the frontend for enterprise projects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了 GraphQL 的工作原理以及如何创建自己的 GraphQL API，以了解在前端为大型项目结构化 GraphQL 客户端的最佳方式。
- en: In the next section, we are going to explore the best way to structure your
    enterprise Vue.js application with GraphQL for scalability and faster team adoption.
    Remember the law of predictability for your teams that we discussed in [*Chapter
    3*](B17237_03.xhtml#_idTextAnchor087)*, Scaling Performance in* *Vue.js 3*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何以最佳方式结构化你的企业级 Vue.js 应用程序，以实现可扩展性和更快地被团队成员接受。记住我们在 [*第 3 章*](B17237_03.xhtml#_idTextAnchor087)*
    中讨论的团队的可预测性法律* *Vue.js 3* *中的性能扩展*。
- en: Integrating GraphQL Apollo Client with Vue 3
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 GraphQL Apollo 客户端与 Vue 3 集成
- en: It is tempting to ask what the best way to integrate GraphQL client into Vue
    3 is and how to structure it in an enterprise project to foster faster adoption
    by team members, including new team members.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易想知道将 GraphQL 客户端集成到 Vue 3 的最佳方式以及如何在企业项目中结构化它以促进团队成员，包括新成员的快速采用。
- en: In my career as a full-stack software engineer, I recently joined a fintech
    company using Vue 3 and GraphQL to disrupt the fintech industry in Germany, and
    I was so impressed at the arrangement of such a large code base and how easy it
    was for me to jump right into solving my first task.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的全栈软件工程师职业生涯中，我最近加入了一家使用 Vue 3 和 GraphQL 来颠覆德国金融科技行业的金融科技公司，我对这样一个大型代码库的安排以及我如何轻松地直接解决我的第一个任务印象深刻。
- en: There are many ways to structure your Vue 3 project with GraphQL, but I want
    to outline the best way I have seen that works for small- or large-scale enterprise
    projects, including the fintech one I worked on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GraphQL 结构你的 Vue 3 项目有许多方法，但我想要概述一下我见过的最适合小型或大型企业项目的方法，包括我参与的那个金融科技项目。
- en: GraphQL Apollo Client is a JavaScript library used to connect to the GraphQL
    server to interchange data. With the library, you can connect to the server, send
    requests, and receive responses from the server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Apollo 客户端是一个 JavaScript 库，用于连接到 GraphQL 服务器以交换数据。使用该库，您可以连接到服务器，发送请求，并从服务器接收响应。
- en: First, we will start by listing and installing the necessary packages for GraphQL
    and the GraphQL client in Vue 3.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开始列出并安装 Vue 3 中 GraphQL 和 GraphQL 客户端所需的必要包。
- en: Installation
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Follow these steps to install all the necessary packages:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装所有必要的包：
- en: 'Type in the following commands to install `graphql`, `graphql-tag`, `apollo-composable`,
    and `apollo client`. These are the recommended libraries from the official documentation
    used to communicate with the GraphQL server using Vue 3:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令来安装 `graphql`、`graphql-tag`、`apollo-composable` 和 `apollo client`。这些是从官方文档中推荐的库，用于通过
    Vue 3 与 GraphQL 服务器进行通信：
- en: '[PRE6]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After installation, we will create a new file called `apollo.config.js` inside
    our `plugins` folder from the folder structure we created in [*Chapter 3*](B17237_03.xhtml#_idTextAnchor087)*,
    Scaling Performance in Vue.js 3* and add the following scripts to configure the
    `graphql` client:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，我们将在我们创建的文件夹结构中（在 [*第 3 章*](B17237_03.xhtml#_idTextAnchor087)*，*Vue.js 3*
    中的性能扩展*）的 `plugins` 文件夹内创建一个名为 `apollo.config.js` 的新文件，并添加以下脚本以配置 `graphql` 客户端：
- en: '[PRE7]js'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE7]js'
- en: import { ApolloClient, createHttpLink, InMemoryCache } from '@apollo/client/core'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import { ApolloClient, createHttpLink, InMemoryCache } from '@apollo/client/core'
- en: // HTTP connection to the API
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 与 API 的 HTTP 连接
- en: const httpLink = createHttpLink({
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const httpLink = createHttpLink({
- en: // You should use an absolute URL here
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 这里应使用绝对 URL
- en: 'uri: ''http://localhost:3020/graphql'','
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'uri: ''http://localhost:3020/graphql'','
- en: '})'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: // Cache implementation
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 缓存实现
- en: const cache = new InMemoryCache()
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const cache = new InMemoryCache()
- en: // Create the apollo client
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 创建 Apollo 客户端
- en: const apolloClient = new ApolloClient({
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const apolloClient = new ApolloClient({
- en: 'link: httpLink,'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'link: httpLink,'
- en: cache,
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cache,
- en: '})'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: export default apolloClient
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: export default apolloClient
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lastly, inside your Vue 3 `main.js` file, add the following script to the existing
    one:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您的 Vue 3 `main.js` 文件中，向现有的脚本中添加以下脚本：
- en: '[PRE9]js'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE9]js'
- en: import { createApp, provide, h } from 'vue'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import { createApp, provide, h } from 'vue'
- en: import apolloClient from "./plugins/apollo.config";
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import apolloClient from "./plugins/apollo.config";
- en: import { DefaultApolloClient } from '@vue/apollo-composable'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import { DefaultApolloClient } from '@vue/apollo-composable'
- en: …
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: const app = createApp({
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const app = createApp({
- en: setup () {
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: setup () {
- en: provide(DefaultApolloClient, apolloClient)
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: provide(DefaultApolloClient, apolloClient)
- en: '},'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: 'render: () => h(App),'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'render: () => h(App),'
- en: '})'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: …
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: '[PRE10]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding steps, we demonstrated how to install the GraphQL client and
    completely set it up with the other libraries in our Vue 3 enterprise application.
    In the next section, we will discuss the best practices for structuring our Vue
    3 application with GraphQL.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们展示了如何在 Vue 3 企业应用程序中安装 GraphQL 客户端，并与其他库完全设置。在下一节中，我们将讨论使用 GraphQL
    结构化我们的 Vue 3 应用程序的最佳实践。
- en: Structuring GraphQL
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化 GraphQL
- en: After successfully installing and configuring Apollo Client with Vue 3, let’s
    structure our queries and mutations around the law of predictability to enable
    old and new team members to easily adapt to the project.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装和配置 Apollo Client 与 Vue 3 后，让我们根据可预测性原则来结构化我们的查询和突变，以便老成员和新成员能够轻松适应项目。
- en: Create a new folder inside the `src` folder called `graphql`. This new folder
    will contain all our queries and mutations grouped in to different directories
    according to the features of the application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹内创建一个名为 `graphql` 的新文件夹。这个新文件夹将包含所有我们的查询和突变，根据应用程序的功能分组到不同的目录中。
- en: Let’s take an example from the schema we developed in the previous section.
    From the schema, it is clear that our project has `User` and `Photo` features,
    so we will create different folders inside the general `graphql` folder for these
    specific features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一节中开发的模式中举一个例子。从模式中可以看出，我们的项目有 `User` 和 `Photo` 功能，因此我们将在通用的 `graphql`
    文件夹内为这些特定功能创建不同的文件夹。
- en: 'Create new folders using the following command line or manually from your code
    editor:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令行或从您的代码编辑器手动创建新文件夹：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should have a new folder structure, as shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该有一个新的文件夹结构，如下面的截图所示：
- en: '![Figure 5.2 – The folder structure after installing and setting up GraphQL](img/Figure_5.02_B17237.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 安装和设置 GraphQL 后的文件夹结构](img/Figure_5.02_B17237.jpg)'
- en: Figure 5.2 – The folder structure after installing and setting up GraphQL
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 安装和设置 GraphQL 后的文件夹结构
- en: After installing and setting up GraphQL, your folder structure should look like
    the preceding screenshot, containing each feature with its corresponding queries
    and mutations file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和设置 GraphQL 后，您的文件夹结构应该看起来像前面的截图，包含每个功能及其对应的查询和突变文件。
- en: Structuring your GraphQL API this way makes it easy for your team to automatically
    understand where to find anything related to GraphQL queries or mutations and
    in which feature they are looking for them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式结构化您的 GraphQL API，使您的团队能够自动理解在哪里找到与 GraphQL 查询或突变相关的内容，以及它们在寻找它们的功能中。
- en: Now that we have our folder structure figured out for predictability, in the
    next section, we will demonstrate with a practical exercise using the structure
    we learned about in the previous sections to authenticate a user into our application
    using GraphQL Apollo Client and JWT installed on our GraphQL server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了预测性的文件夹结构，在下一节中，我们将通过一个实际练习来演示，使用我们在前几节中学到的结构，通过 GraphQL Apollo 客户端和安装在
    GraphQL 服务器上的 JWT 来认证用户。
- en: JWT authentication for sign in/sign up
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT 认证用于登录/注册
- en: With the structure we have on the ground, it becomes easy to add new features
    and write our queries/mutations without scattering them in the code base.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在地面上已有的结构基础上，添加新功能和编写查询/突变变得容易，而不会在代码库中分散。
- en: 'Let’s demonstrate how to implement the login and register authentication process
    with GraphQL and Vue 3 by following these steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤演示如何使用 GraphQL 和 Vue 3 实现登录和注册认证过程：
- en: 'Firstly, create a new folder called `auth` inside the `graphql` folder and
    add `mutations.js` inside it:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `graphql` 文件夹内创建一个名为 `auth` 的新文件夹，并在其中添加 `mutations.js`：
- en: '[PRE12]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside the newly created mutation file, add the following script for registration
    and login endpoints:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的突变文件中，为注册和登录端点添加以下脚本：
- en: '[PRE13]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, export the mutation inside the `graphql/index.js` file we created earlier
    to make it available throughout our Vue application:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将我们之前创建的 `graphql/index.js` 文件中的突变导出，使其在 Vue 应用程序中可用：
- en: '[PRE14]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `export` script makes importing our GraphQL queries and mutations a lot
    easier.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`export` 脚本使得导入我们的 GraphQL 查询和突变变得容易得多。'
- en: Next, we will look at how to call the authentication mutation inside the Vue
    3 component and retrieve the user’s information.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何在 Vue 3 组件中调用认证突变并检索用户信息。
- en: With the `vue-composable` library we installed earlier, we can use different
    GraphQL hooks, such as `useMutation` and `useQuery`, to manipulate the GraphQL
    API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前安装的 `vue-composable` 库，我们可以使用不同的 GraphQL 钩子，例如 `useMutation` 和 `useQuery`，来操作
    GraphQL API。
- en: 'Create a `login` component inside the `organisms` folder and add the following
    code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `organisms` 文件夹内创建一个 `login` 组件，并添加以下代码：
- en: '[PRE15]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first code snippet shows the template and the view part of the component;
    it has a form component with four child components, including `TextField`, `CheckField`,
    and `Button`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码片段显示了组件的模板和视图部分；它包含一个表单组件，其中包含四个子组件，包括 `TextField`、`CheckField` 和 `Button`：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The script section of the component performs the business logic; it has many
    properties and a function called `Login`, which performs the authentication process
    for your application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的脚本部分执行业务逻辑；它有许多属性和一个名为 `Login` 的函数，该函数执行应用程序的认证过程。
- en: The preceding snippet shows how to implement the login functionality for our
    project. You can implement the registration component or take a look at the repository
    ([https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5))
    for the complete code base for this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了如何实现我们项目的登录功能。您可以实现注册组件或查看仓库 ([https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5))
    以获取本章的完整代码库。
- en: "![Figure 5.3 – A screenshot sh\uFEFFowing the implementation of a login form](img/Figure_5.03_B17237.jpg)"
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 展示登录表单实现的截图](img/Figure_5.03_B17237.jpg)'
- en: Figure 5.3 – A screenshot showing the implementation of a login form
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 展示登录表单实现的截图
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter delved deeper into GraphQL, GraphQL Apollo Server 2, queries, mutations,
    and how to integrate these technologies into your Vue.js 3 application. In addition,
    we learned how to utilize GraphQL to deliver scalable and high-performing applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了 GraphQL、GraphQL Apollo Server 2、查询、突变，以及如何将这些技术集成到您的 Vue.js 3 应用程序中。此外，我们还学习了如何利用
    GraphQL 来交付可扩展且性能高的应用程序。
- en: We also covered in detail how to integrate GraphQL into Vue 3 and properly structure
    it following the law of predictability.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还详细介绍了如何将 GraphQL 集成到 Vue 3 中，并按照可预测性原则正确地构建其结构。
- en: Lastly, we demonstrated how to implement a login and register authentication
    system using GraphQL Apollo Client and Vue 3.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了如何使用 GraphQL Apollo Client 和 Vue 3 实现登录和注册认证系统。
- en: In the next chapter, you will learn how to build a complete Pinterest clone
    with Vue 3 and GraphQL. You will utilize your knowledge of GraphQL to develop
    and deliver an enterprise application such as Pinterest using Vue 3 and GraphQL.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用 Vue 3 和 GraphQL 构建一个完整的 Pinterest 克隆。您将利用对 GraphQL 的了解，使用 Vue
    3 和 GraphQL 开发和交付一个如 Pinterest 一样的企业级应用程序。
