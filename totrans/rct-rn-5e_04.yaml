- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding React Components and Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the React components and their fundamental
    aspects and introduce you to the power of **Hooks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the essential concept of component data and how it shapes the
    structure of your React applications. We will discuss two primary types of component
    data: **properties** and **state**. Properties allow us to pass data to components,
    while state enables components to manage and update their internal data dynamically.
    We will examine how these concepts apply to function components and illustrate
    the mechanics of setting component state and passing properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are component properties?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is component state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining state using Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing initialization and cleanup actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data using context Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization with Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter03](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components are the building blocks of modern web and mobile applications.
    They encapsulate reusable sections of code that define the structure, behavior,
    and appearance of different parts of a user interface. By breaking down the UI
    into smaller, self-contained components, React enables developers to create scalable,
    maintainable, and interactive applications.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, a React component is a JavaScript function or class that returns
    JSX syntax, which resembles HTML markup. In this book, we will focus mostly on
    function components, as they have become the preferred approach for building components
    in recent years. Function components are simpler, more concise, and easier to
    understand compared to class components. They leverage the power of JavaScript
    functions and utilize React Hooks to manage state and perform side effects.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary advantages of using components in React is their reusability.
    Components can be reused across multiple parts of an application, reducing code
    duplication and increasing development efficiency. Moreover, components promote
    a modular approach to development, allowing developers to break down complex UIs
    into smaller, manageable pieces.
  prefs: []
  type: TYPE_NORMAL
- en: What are component properties?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, **component properties**, commonly known as **props**, allow us to
    pass data from a parent component to its child components. Props provide a way
    to customize and configure components, making them flexible and reusable. Props
    are read-only, meaning that the child component should not modify them directly.
    Instead, the parent component can update the props value and trigger a re-render
    of the child component with the updated data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining a function component, you can access the props passed to it as
    a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the `MyComponent` function component receives the props
    object as a parameter. We can access the individual props by using dot notation,
    such as `props.title` and `props.description`, to render the data within the component’s
    JSX markup. It is also possible to access props using destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this approach is even cleaner and also allows us to use another
    destructuring feature, default values, which we will discuss in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Passing property values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React component properties are set by passing JSX attributes to the component
    when it is rendered. In *Chapter 7*, *Type Checking and Validation with TypeScript*,
    I’ll go into more detail about how to validate the property values that are passed
    to components. Now let’s create a couple of components in addition to `MyComponent`
    that expect different types of property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple button component expects a Boolean disabled property and a string
    text property. While we create components to show how we can pass the following
    props, you will notice how we already pass these properties to the button HTML
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '**disabled property**: we put into the button attribute with the name `disabled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**text property**: we pass to the button as a child attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s also important to know that any JavaScript expression you want to pass
    to the component should be wrapped with curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create one more component that expects an array property value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can pass just about anything you want as a property value via JSX, just
    as long as it’s a valid JavaScript expression. The `MyList` component accepts
    an items property, an array that is mapped to `<li>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s write some code to set these property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `render` function looks like it’s creating new React component instances
    every time it’s called. React is smart enough to figure out that these components
    already exist, and that it only needs to figure out what the difference in output
    will be with the new property values. In this example, the call to `setTimeout`
    causes a delay of 1 second. Then, the `appState.disabled` value is changed to
    false and the `appState.items` array has a new value added to the end of it. The
    call to `render` will re-render the components with new property values.
  prefs: []
  type: TYPE_NORMAL
- en: Another takeaway from this example is that you have an `appState` object that
    holds onto the state of the application. Pieces of this state are then passed
    into components as properties when the components are rendered. The state has
    to live somewhere and, in this case, it’s outside of the component. We’ll explore
    this approach in depth, and why it’s important, in *Chapter 12*, *State Management
    in React*.
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you noticed we’ve rendered another button where we passed props in a
    different way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a valid JSX expression and in case we want to pass constant values to
    the components, we can pass strings without curly braces and pass the Boolean
    value `true`, just leaving the attribute name in the component.
  prefs: []
  type: TYPE_NORMAL
- en: Default property values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to passing data, we can also specify default values for props using
    the `defaultProps` property. This is helpful when a prop is not provided, ensuring
    that the component still behaves correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if the parent component does not provide the `text` or `disabled`
    props, the component will fall back to the default values specified in `defaultProps`.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, with destructuring, we have a more convenient way to
    set up default props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the updated example of the `MyButton` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using destructuring, we can define props and set the default value right inside
    the function. It’s cleaner and easy to see in cases when we have a big component
    with a lot of props.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will further dive into component state with Hooks,
    and other key concepts.
  prefs: []
  type: TYPE_NORMAL
- en: What is component state?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, component state refers to the internal data held by a component. It
    represents the mutable values that can be used within the component and can be
    updated over time. State allows components to keep track of information that can
    change, such as user input, API responses, or any other data that needs to be
    dynamic and responsive.
  prefs: []
  type: TYPE_NORMAL
- en: State is a feature provided by React that enables components to manage and update
    their own data. It allows components to re-render when the state changes, ensuring
    that the user interface reflects the latest data.
  prefs: []
  type: TYPE_NORMAL
- en: To define state in a React component, you should use the `useState` hook inside
    of the component. You can then access and modify the state within the component’s
    methods or JSX code. When the state is updated, React will automatically re-render
    the component and its child components to reflect the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping to examples of using state in components, let’s briefly explore
    what a React hook is.
  prefs: []
  type: TYPE_NORMAL
- en: React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Hooks are a feature introduced in **React 16.8** that allows you to use
    state and other React features in functional components. Before Hooks, state management
    and lifecycle methods were primarily used in class components. Hooks provide a
    way to achieve similar functionality in functional components, making them more
    powerful and easier to write and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are functions that enable you to “hook into” React’s internal features,
    such as state management, context, effects, and more. They are prefixed with the
    `use` keyword (such as `useState`, `useEffect`, `useContext`, and so on). React
    provides several built-in Hooks, and you can also create custom Hooks to encapsulate
    reusable stateful logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used built-in Hooks are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useState`: This hook allows you to add state to a functional component. It
    returns an array with two elements: the current state value and a function to
    update the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useEffect`: This hook lets you perform side effects in your components, such
    as fetching data, subscribing to events, or manually manipulating the DOM. It
    runs after every render by default and can be used to handle component lifecycle
    events like when the component is mounted, updated, or unmounted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useContext`: This hook allows you to consume values from a React context.
    It provides a way to access context values without nesting multiple components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useCallback` and `useMemo`: These Hooks are used for performance optimization.
    `useCallback` memoizes a function, preventing it from being recreated on every
    render, while `useMemo` memoizes a value, recomputing it only when its dependencies
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will examine all these Hooks in this chapter and will use them throughout
    the book. Let’s continue with state and explore how we can manage it with the
    `useState` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining state using Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first React Hook API that we’ll look at is called `useState`, which enables
    your functional React components to be stateful. In this section, you’ll learn
    how to initialize state values and change the state of a component using Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Initial state values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our components are first rendered, they probably expect some state values
    to be set. This is called the initial state of the component, and we can use the
    `useState` hook to set the initial state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `App` component is a functional React component that returns JSX markup.
    But it’s also now a stateful component, thanks to the `useState` hook. This example
    initializes two pieces of state, `name` and `age`. This is why there are two calls
    to `useState`, one for each state value.
  prefs: []
  type: TYPE_NORMAL
- en: You can have as many pieces of state in your component as you need. The best
    practice is to have one call to `useState` per state value. You could always define
    an object as the state of your component using only one call to `useState`, but
    this complicates things because you have to access state values through an object
    instead of directly. Updating state values is also more complicated using this
    approach. When in doubt, use one `useState` hook per state value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call `useState`, we get an array returned to us. The first value of
    this array is the state value itself. Since we’ve used array-destructuring syntax
    here, we can call the value whatever we want; in this case, it is `name` and `age`.
    Both of these constants have values when the component is first rendered because
    we passed the initial state values for each of them to `useState`. Here’s what
    the page looks like when it’s rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Rendered output using values from state Hooks'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to set the initial state values of your components,
    let’s learn about updating these values.
  prefs: []
  type: TYPE_NORMAL
- en: Updating state values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'React components use state for values that change over time. The state values
    used by components start off in one state, as we saw in the previous section,
    and then change in response to some event: for example, the server responds to
    an API request with new data, or the user has clicked a button or changed a form
    field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the state, the `useState` hook provides an individual function for
    every piece of state, which we can access from the returned array from the `useState`
    hook. The first item is the state value and the second is the function used to
    update the value. Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the example from the initial state values section, the `App` component
    in this example has two pieces of state: `name` and `age`. Unlike the previous
    example, this component uses two functions to update each piece of state. These
    are returned from the call to `useState`. Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two functions: `setName` and `setAge`: that can be used to update
    the state of our component. Let’s take a look at the text input field that updates
    the `name` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the user changes the text in the `<input>` field, the `onChange` event
    is triggered. The handler for this event calls `setName`, passing it `e.target.value`
    as an argument. The argument passed to `setName` is the new state value of name.
    The succeeding paragraph shows that the text input is also updated with the new
    name value every time the user changes the text input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the `age` number input field and how this value is passed
    to `setAge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `age` field follows the exact same pattern as the `name` field. The only
    difference is that we’ve made the input a number type. Any time the number changes,
    `setAge` is called with the updated value in response to the `onChange` event.
    The following paragraph shows that the number input is also updated with every
    change that is made to the `age` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the two inputs and their two corresponding paragraphs look like
    when they’re rendered on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Using Hooks to change state values'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the `useState` hook, which is used to add
    state to functional React components. Each piece of state uses its own hook and
    has its own value variable and its own setter function. This greatly simplifies
    accessing and updating state in your components. Any given state value should
    have an initial value so that the component can render correctly the first time.
    To re-render functional components that use state Hooks, you can use the setter
    functions that `useState` returns to update your state values as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The next hook that you’ll learn about is used to perform initialization and
    cleanup actions.
  prefs: []
  type: TYPE_NORMAL
- en: Performing initialization and cleanup actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, our React components need to perform actions when the component is created.
    For example, a common initialization action is to fetch the API data that the
    component needs. Another common action is to make sure that any pending API requests
    are canceled when the component is removed. In this section, you’ll learn about
    the `useEffect` hook and how it can help you with these two scenarios. You’ll
    also learn how to make sure that the initialization code doesn’t run too often.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching component data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useEffect` hook is used to run “side effects” in your component. Another
    way to think about side-effect code is that functional components have only one
    job: returning JSX content to render. If the component needs to do something else,
    such as fetching API data, this should be done in a `useEffect` hook. For example,
    if you were to just make the API call as part of your component function, you
    would likely introduce race conditions and other difficult-to-fix buggy behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example that fetches API data using Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `useEffect` hook expects a function as an argument. This function is called
    after the component finishes rendering, in a safe way that doesn’t interfere with
    anything else that React is doing with the component under the covers. Let’s look
    at the pieces of this example more closely, starting with the mock API function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetchUser` function is defined using the `useCallback` hook. This hook
    is used to memoize the function, meaning that it will only be created once and
    will not be recreated on subsequent renders unless the dependencies change. The
    `useCallback` accepts two arguments: the first is the function we want to memorize
    and the second is the list of dependencies that will be used to identify when
    React should re-create this function instead of using the memorized version. The
    `fetchUser` function is passed an empty array (`[]`) as the dependency list. This
    means that the function will only be created once during the initial render and
    won’t be recreated on subsequent renders.'
  prefs: []
  type: TYPE_NORMAL
- en: The `fetchUser` function returns a promise. The promise resolves a simple object
    with two properties, `id` and `name`. The `setTimeout` function delays the promise
    resolution for 1 second, so this function is asynchronous, just as a normal `fetch`
    call would be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the Hooks used by the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in addition to `useCallback`, we’re using two Hooks in this
    component: `useState` and `useEffect`. Combining hook functionality like this
    is powerful and encouraged. First, we set up the `id` and `name` states of the
    component. Then, `useEffect` is used to set up a function that calls `fetchUser`
    and sets the state of our component when the promise resolves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `App` component looks like when it’s first rendered, using
    the initial state of `id` and `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Displaying the loading text until the data arrives'
  prefs: []
  type: TYPE_NORMAL
- en: 'After 1 second, the promise returned from `fetchUser` is resolved with data
    from the API, which is then used to update the ID and name states. This results
    in `App` being rerendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The state changes, removing the loading text and displaying returned
    values'
  prefs: []
  type: TYPE_NORMAL
- en: There is a good chance that your users will navigate around your application
    while an API request is still pending. The `useEffect` hook can be used to deal
    with canceling these requests.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling actions and resetting state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a good chance that, at some point, your users will navigate your app
    and cause components to unmount before responses to their API requests arrive.
    Sometimes your component can listen for some events and you should delete all
    listeners before unmounting the component to avoid memory leaks. In general, it’s
    important to stop performing any background actions when a related component is
    deleted from the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the `useEffect` hook has a mechanism to clean up effects such as
    pending `setInterval` when the component is removed. Let’s take a look at an example
    of this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple `Timer` component. It has the state `timer`, it sets up interval
    callback to update `timer` inside `useEffect()`, and it renders the output with
    the current `timer` value. Let’s take a closer look at the `useEffect()` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This effect creates an interval timer by calling the `setInterval` function
    with a callback, which updates our `timer` state. The interesting thing you will
    notice here is that to the `setTimer` function, we are passing a callback instead
    of a number. It’s a valid React API: when we need the previous state value to
    use to calculate a new one, we can pass a callback where the first argument is
    the current or ‘previous’ state value and we should return the new state value
    from this callback to update our state.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside `useEffect`, we are also returning a function, which React runs when
    the component is removed. In this example, the interval that is created by calling
    `setInterval` is cleared by calling the function that we returned from `useEffect`,
    where we call `clearInterval`. Functions that you return from `useEffect` will
    be triggered when the component is going to unmount.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the `App` component, which renders and removes the `Timer`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `App` component renders a button that is used to toggle the `show` state.
    This state value determines whether or not the `Timer` component is rendered,
    but by using the `ShowHideTimer` convenience component. If show is true, `<Timer
    />` is rendered; otherwise, `Timer` is removed, triggering our `useEffect` cleanup
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the screen looks like when it first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: A button used to initiate the state change'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Timer` component isn’t rendered because the `show` state of the `App`
    component is `false`. Try clicking on the show timer button. This will change
    the `show` state and render the `Timer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Displays the timer'
  prefs: []
  type: TYPE_NORMAL
- en: You can click on the **Hide Timer** button once more to remove the `Timer` component.
    Without the cleanup interval that we added to `useEffect`, this will create new
    listeners every time the timer is rendered, which will affect the memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: React allows us to control when we want to run our effects. For example, when
    we want to all API requests after the first render, or we want to perform effects
    when a particular state changes. We’ll take a look at how to do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing side-effect actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, React assumes that every effect that is run needs to be cleaned
    up and it should be run on every render. This typically isn’t the case. For example,
    you might have specific property or state values that require cleanup and run
    one more time when they change. You can pass an array of values to watch as the
    second argument to `useEffect`: for example, if you have a resolved state that
    requires cleanup when it changes, you would write your effect code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the effect will be triggered and only ever run if the resolved
    state value changes. If the effect runs and the resolved state hasn’t changed,
    then the cleanup code will not run and the original effect code will not run a
    second time. Another common case is never running the cleanup code, except for
    when the component is removed. In fact, this is what we want to happen in the
    example from the section on fetching user data. Right now, the effect runs after
    every render. This means that we’re repeatedly fetching the user API data when
    all we really want is to fetch it once when the component is first mounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make some modifications to the `App` component from the fetching component
    data requests example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added a second argument to `useEffect`, an empty array. This tells React
    that there are no values to watch and that we only want to run the effect once
    it is rendered and cleanup code when the component is removed. We’ve also added
    `console.count('fetching user')` to the `fetchUser` function. This makes it easier
    to look at the browser dev tools console and make sure that our component data
    is only fetched once. If you remove the `[]` argument that is passed to `useEffect`,
    you’ll notice that `fetchUser` is called several times.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about side effects in React components. Effects
    are an important concept, as they are the bridge between your React components
    and the outside world. One of the most common use cases for effects is to fetch
    data that the component needs, when it is first created, and then clean up after
    the component when it is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’re going to look at another way to share data with React components:
    context.'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data using context Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React applications often have a few pieces of data that are global in nature.
    This means that several components, possibly every component in an app, share
    this data: for example, information about the currently logged-in user might be
    used in several places. This is where the **Context API** comes in handy. The
    Context API provides a way to create a shared data store that can be accessed
    by any component in the tree, regardless of its depth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize the Context API, we need to create a context using the `createContext`
    function from the **React** library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we create a context called `MyContext` using `createContext`.
    This creates a context object that contains a `Provider` and a `Consumer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Provider` component is responsible for providing the shared data to its
    child components. We wrap the relevant portion of the component tree with the
    `Provider` and pass the data using the `value` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Any component within the `MyContext.Provider` can access the shared data using
    the `Consumer` component or the `useContext` hook. Let’s take a look at how to
    read context using a hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By utilizing the Context API, we can avoid the prop-drilling problem where data
    needs to be passed through multiple levels of components. It simplifies the process
    of sharing data and allows components to access the shared data directly, making
    the code more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that the Context API is not intended for all scenarios and
    should be used judiciously. It is most useful for sharing data that is truly global
    or relevant to a large portion of the component tree. For smaller-scale data sharing,
    props are still the recommended approach.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization with Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In React, function components are called on every render, which means that
    expensive computations and function creations can negatively impact performance.
    To optimize performance and prevent unnecessary recalculations, React provides
    three Hooks: `useMemo`, `useCallback`, and `useRef`. These Hooks allow us to memoize
    values, functions, and references, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: useMemo Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useMemo` hook is used to memoize the result of a computation, ensuring
    that it is only recomputed when the dependencies have changed. It takes a function
    and an array of dependencies and returns the memoized value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using the `useMemo` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `expensiveResult` value is memoized using `useMemo`. The
    computation inside the function is only executed when the `dependency` value changes.
    If the `dependency` remains the same, the previously memoized value is returned
    instead of recomputing the result.
  prefs: []
  type: TYPE_NORMAL
- en: useCallback hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already explored `useCallback` hook in this chapter, but I want to highlight
    one important use case. When a function component renders, all of its functions
    are recreated, including any inline callbacks defined within the component. This
    can lead to unnecessary re-renders of child components that receive these callbacks
    as props, as they perceive the callback as a new reference and trigger re-renders.
    Let’s take a look at the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the inline function we provide to the `onClick` prop will be
    created every time `MyComponent` renders. It means the `MyButton` component will
    receive a new function reference each time, and as we already know, it will result
    in a new render for the `MyButton` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that demonstrates the use of the `useCallback` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `clickHandler` function is memoized using `useCallback`.
    The empty dependency array `[]` indicates that the function has no dependencies
    and should remain constant throughout the component’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the same function instance is provided to `MyButton` on each render
    of `MyComponent`, preventing unnecessary re-renders of the child.
  prefs: []
  type: TYPE_NORMAL
- en: useRef hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useRef` hook allows us to create a mutable reference that persists across
    component renders. It is commonly used to store values or references that need
    to be preserved between renders without triggering re-renders. Additionally, `useRef`
    can be used to access the DOM node or a React component instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `inputRef` is created using `useRef`, and it is assigned
    to the `ref` attribute of the `input` element. This allows us to access the DOM
    node using the `inputRef.current` property. In the `handleButtonClick` function,
    we call the focus method on the `inputRef.current` to focus the input element
    when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: By using `useRef` to access the DOM node, we can interact with the underlying
    DOM elements directly without triggering re-renders of the component.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging memoization with the `useMemo`, `useCallback`, and `useRef` Hooks,
    we can optimize the performance of our React applications by avoiding unnecessary
    computations, preventing unnecessary re-renders, and preserving values and references
    across renders. This results in a smoother user experience and more efficient
    use of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to React components and React Hooks. You learned
    about component properties or props by implementing code that passed property
    values from JSX to the component. Next, you found out what state is and how to
    manipulate it with the `useState` hook. Then, you learned about `useEffect`, which
    enables lifecycle management in functional React components, such as fetching
    API data when a component is mounted and cleaning up any pending async operations
    when it is removed. Then, you learned how to use the `useContext()` hook in order
    to access global application data. Lastly, you learned about memoization with
    the `useMemo`, `useCallback`, and `useMemo` Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you’ll learn about event handling with React components.
  prefs: []
  type: TYPE_NORMAL
