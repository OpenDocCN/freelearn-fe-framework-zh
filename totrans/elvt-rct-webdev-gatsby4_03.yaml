- en: '*Chapter 2*: Styling Choices and Creating Reusable Layouts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*: 样式选择和创建可复用布局'
- en: Gatsby sites can be styled in a multitude of ways. In this chapter, we will
    introduce you to a large selection of styling techniques to help you make an informed
    choice about how you would like to style your site. Once you've settled on a styling
    method, we will implement it on the pages we created in [*Chapter 1*](B15983_01_ePub_RK.xhtml#_idTextAnchor013),
    *An Overview of Gatsby.js for the Uninitiated*, before creating the **reusable
    components** that will be used across all our site pages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Gatsby站点可以通过多种方式进行样式化。在本章中，我们将向您介绍大量样式化技术，以帮助您做出明智的选择，决定您希望如何样式化您的站点。一旦您确定了样式化方法，我们将在[*第一章*](B15983_01_ePub_RK.xhtml#_idTextAnchor013)，*Gatsby.js入门概述*中实现的页面上实施它，然后再创建将在所有我们的站点页面上使用的**可复用组件**。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Styling in Gatsby
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gatsby中的样式化
- en: Styling with CSS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS进行样式化
- en: Styling with Sass
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sass进行样式化
- en: Styling with Tailwind.css
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tailwind.css进行样式化
- en: Styling with Styled components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Styled组件进行样式化
- en: Creating a reusable layout
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可复用布局
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to navigate this chapter, you will need to have completed the Gatsby
    setup and created the pages in [*Chapter 1*](B15983_01_ePub_RK.xhtml#_idTextAnchor013),
    *An Overview of Gatsby.js for the Uninitiated*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导航本章，您需要完成Gatsby的设置并创建了[*第一章*](B15983_01_ePub_RK.xhtml#_idTextAnchor013)，*Gatsby.js入门概述*中的页面。
- en: In this chapter, we will start adding our first reusable components to our pages.
    As these components are not standalone pages, we will need a new place to store
    them. Create a subfolder inside your `src` folder called `components` that we
    can use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始将我们的第一个可复用组件添加到我们的页面中。由于这些组件不是独立的页面，我们需要一个新的地方来存储它们。在您的`src`文件夹内创建一个名为`components`的子文件夹，我们可以使用它。
- en: The code present in this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter02](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter02).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中出现的代码可以在[https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter02](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter02)找到。
- en: Styling in Gatsby
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gatsby中的样式化
- en: This chapter is all about styling your Gatsby site, but what does styling refer
    to? While our React code is defining the structure of our web documents, we will
    use styling to define our documents' look and feel through page layouts, colors,
    and fonts. There is an abundance of tools you can use to style any Gatsby project.
    In this book, I will introduce you to four different approaches – **vanilla CSS**,
    **Sass**, **Tailwind.css**, and **CSS in JS**. Let's explore each of these in
    a little more detail before deciding which to use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于样式化您的Gatsby站点，但样式化指的是什么？虽然我们的React代码定义了我们的网络文档的结构，但我们将使用样式化通过页面布局、颜色和字体来定义文档的外观和感觉。您可以使用大量工具来样式化任何Gatsby项目。在这本书中，我将向您介绍四种不同的方法——**纯CSS**、**Sass**、**Tailwind.css**和**CSS
    in JS**。在决定使用哪种方法之前，让我们更详细地探讨每一种。
- en: Vanilla CSS
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯CSS
- en: When your browser navigates to a site, it loads the site's HTML. It converts
    this HTML into a **Document Object Model** (**DOM**). After this, the browser
    will begin to fetch resources referenced in the HTML. This includes images, videos,
    and, more importantly right now, CSS. The browser reads through the CSS and sorts
    selectors by element, class, and identifiers. It then goes through the DOM and
    uses the selectors to attach styles to elements as required, creating a render
    tree. The visual page is then shown on the screen by utilizing this render tree.
    CSS has withstood the test of time, as we have been shipping CSS in this way with
    HTML for 25 years. But using vanilla CSS has some pros and cons.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的浏览器导航到站点时，它会加载站点的HTML。它将此HTML转换为**文档对象模型**（**DOM**）。在此之后，浏览器将开始获取HTML中引用的资源。这包括图片、视频，更重要的是，现在的CSS。浏览器读取CSS，并按元素、类和标识符对选择器进行排序。然后它遍历DOM，并使用选择器将样式附加到所需的元素上，创建一个渲染树。然后，利用这个渲染树，将可视页面显示在屏幕上。CSS已经经受住了时间的考验，因为我们已经以这种方式将CSS与HTML一起使用了25年。但使用纯CSS有一些优点和缺点。
- en: 'The pros for using vanilla CSS are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯CSS的优点如下：
- en: '**Its age**: Because CSS has been around for 25 years at the time of writing
    this book, there is an abundance of content available on CSS. Due to its age,
    the chances that someone has already worked out how to fix any issue you encounter
    is also very high. Both these reasons make vanilla CSS a great choice for a beginner.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其年龄**：由于 CSS 在撰写本书时已经存在了 25 年，因此有关 CSS 的内容非常丰富。由于其年龄，有人已经解决了您遇到的任何问题的可能性也非常高。这两个原因都使纯
    CSS 成为初学者的一个很好的选择。'
- en: '**Understandable syntax**: The syntax that makes up CSS consists of very few
    abbreviations. Reading it as a beginner, it is far easier to learn what any line
    of CSS is doing compared to the other style implementations in this chapter.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可理解的语法**：构成 CSS 的语法非常少使用缩写。对于初学者来说，阅读 CSS 的每一行所做的工作，比本章中其他样式实现要容易得多。'
- en: 'The cons for using vanilla CSS are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯 CSS 的缺点如下：
- en: '**Long style sheets**: In traditional websites, you often see that they only
    ship with one CSS file. This makes maintaining and organizing styles very difficult,
    as the file can end up incredibly long. This can lead to a pattern where lazy
    developers who can''t find the styles they are looking for might just append them
    to the bottom of the file (also known as an **append-only style sheets**). If
    they do this and the file already exists, then they are just increasing the file
    size for nothing.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长样式表**：在传统的网站上，您经常看到它们只包含一个 CSS 文件。这使得维护和组织样式变得非常困难，因为文件可能会变得非常长。这可能导致一种模式，即懒惰的开发者找不到他们想要的样式，可能会直接将它们附加到文件的底部（也称为**只读样式表**）。如果他们这样做，而文件已经存在，那么他们只是在增加文件大小而没有其他作用。'
- en: '**Class reuse confusion**: Reusing styles can sometimes lead to more trouble
    than it''s worth. Let''s say you have used one specific class in use across various
    elements in your application. You might update this class to make it fit one instance
    of it, only to break all the others. If you fall into this cycle multiple times,
    it can really slow down your development. This can be avoided with a little forward-thinking
    – instead of reusing classes, make components that are reused. Another option
    is to create "utility classes" that are unlikely to change; if you''d rather not
    create these yourself, you should read the section on Tailwind CSS.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类重用混淆**：重用样式有时可能会带来比其价值更大的麻烦。假设您已经在应用程序的各个元素中使用了某个特定的类。您可能更新这个类以使其适应一个实例，结果却破坏了所有其他实例。如果您陷入这种循环多次，这可能会真正减慢您的开发速度。通过一点前瞻性思维可以避免这种情况——与其重用类，不如创建可重用的组件。另一个选择是创建不太可能改变的“实用类”；如果您不想自己创建这些类，您应该阅读关于
    Tailwind CSS 的部分。'
- en: '**Inheritance pain points**: By using inheritance, we end up tightly coupling
    our CSS to the structure of our HTML. If you break that structure, your CSS may
    no longer work. While inheritance sometimes is unavoidable, we should try and
    keep it to a minimum.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承的痛点**：通过使用继承，我们最终将 CSS 紧密耦合到 HTML 的结构中。如果您破坏了这个结构，CSS 可能就不再起作用了。虽然继承有时是不可避免的，但我们应尽量将其保持在最低限度。'
- en: CSS has withstood the test of time and is still a solid choice today. You might
    be asking why these are cons when I have listed ways to work around/avoid all
    of them. These cons can all be fixed one way or another using one of the other
    implementations in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 经受了时间的考验，至今仍是一个可靠的选择。您可能会问，为什么我列出了绕过/避免所有这些方法的方式，这些缺点仍然是缺点。这些缺点都可以通过本章中其他实现方式中的任何一种来修复。
- en: Sass
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sass
- en: Sass is a preprocessor scripting language that compiles into CSS. It gives developers
    tools that allow them to create more efficient CSS.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Sass 是一种预处理器脚本语言，它编译成 CSS。它为开发者提供了工具，使他们能够创建更高效的 CSS。
- en: 'The pros for using Sass are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sass 的优点如下：
- en: '**Large toolset**: Sass contains a bundle of powerful tools that you can''t
    utilize in vanilla CSS. While we won''t be covering these in detail, these include
    tools like mixins, loops, functions, and imports that can be used to create more
    powerful and performant CSS for your application. This is a huge pro for Sass.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型工具集**：Sass 包含了一组强大的工具，您在纯 CSS 中无法使用。虽然我们不会详细讨论这些工具，但它们包括混入、循环、函数和导入等工具，可以用来为您的应用程序创建更强大和高效的
    CSS。这对于 Sass 来说是一个巨大的优点。'
- en: '`.scss` files to break down files. You can then import them into one another
    as needed. This drastically helps improve the organization of your code.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.scss` 文件用于分解文件。然后您可以根据需要将它们相互导入。这极大地帮助提高了您代码的组织性。'
- en: '**Freedom**: Sass enforces a convention of how to write it – you can choose.
    This means that you can choose a style that suits your team.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自由度**：Sass强制执行一种编写方式——你可以选择。这意味着你可以选择一种适合你团队的风格。'
- en: 'The cons for using Sass are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sass的缺点如下：
- en: '**Skip foundations**: Freedom can also be a negative for developers new to
    styling. If you haven''t used Sass before, you may create code that works but
    in a way that is overly complicated. This can lead to future developers struggling
    with the code. Concrete CSS guidelines can help avoid this misuse.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳过基础**：对于刚开始学习样式的开发者来说，自由度也可能是一个缺点。如果你之前没有使用过Sass，你可能会创建出工作但过于复杂的代码。这可能会导致未来的开发者难以理解代码。具体的CSS指南可以帮助避免这种误用。'
- en: '**Naming conventions**: Naming every class you create for every element you
    style is a tedious process. There are methodologies that can help you create sensible
    class names; however it still takes a long time.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名规范**：为每个你设计的元素创建类名是一个繁琐的过程。有方法可以帮助你创建有意义的类名；然而，这仍然需要很长时间。'
- en: '**Two sources of truth**: When you write your HTML, you probably will also
    add class names to your elements to style them. You then jump across to your Sass
    file to add these class names, only to forget what names you had for them. Jumping
    back and forth between your HTML and Sass can be an annoying context switch. You
    might consider abstracting styles away from your markup to be a good thing, but
    when markup and styles are so interconnected, this can be an inconvenience.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个事实来源**：当你编写HTML时，你可能会也为你元素添加类名以进行样式化。然后你跳转到Sass文件来添加这些类名，但可能会忘记它们的名称。在HTML和Sass之间跳转可能会是一个烦人的上下文切换。你可能会认为将样式从你的标记中抽象出来是一个好主意，但当标记和样式如此紧密相连时，这可能会是一个不便。'
- en: Although Sass is a powerhouse, increased power does also mean increased complexity.
    While the learning curve may be higher for beginners, gaining control of it will
    give you a great deal of freedom.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Sass是一个强大的工具，但增加的力量也意味着增加的复杂性。虽然对于初学者来说学习曲线可能更高，但掌握它将给你带来极大的自由度。
- en: Tailwind (utility-first CSS framework)
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tailwind（以实用类为首要的CSS框架）
- en: Tailwind CSS is a utility-first CSS framework. The "utility-first" approach
    was created to combat the cons we talked about previously with CSS and Sass. In
    this methodology, we use small utility classes to build a component's style instead
    of defining our own class names. It can feel a little like writing inline styling,
    as your elements will have a string of utility classes added to them, but the
    benefit is that you don't have to write a single line of your own CSS if you don't
    want to.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS是一个以实用类为首要的CSS框架。这种“以实用类为首要”的方法是为了对抗我们之前讨论的CSS和Sass的缺点。在这个方法中，我们使用小的实用类来构建组件的样式，而不是定义我们自己的类名。这可能会感觉有点像编写内联样式，因为你的元素将添加一串实用类，但好处是如果你不想写，你不需要写一行自己的CSS。
- en: 'The pros for using Tailwind are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Tailwind的优点如下：
- en: '**One source of truth**: When using CSS or Sass, you must switch between two
    files: your markup and your style sheets. Tailwind does away with this concept
    and instead allows you to embed your styles directly in your markup.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一事实来源**：当使用CSS或Sass时，你必须在这两个文件之间切换：你的标记和你的样式表。Tailwind消除了这个概念，并允许你直接在你的标记中嵌入样式。'
- en: '**Naming conventions**: Tailwind removes the need for you to create your own
    classes. It has its own classes that are incredibly granular called "utility classes."
    You use these classes to build up your elements'' styles and not worry about creating
    unique classes for each component.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名规范**：Tailwind消除了你需要创建自己类名的需求。它有一套非常细粒度的类名，称为“实用类”。你使用这些类来构建元素的样式，而无需担心为每个组件创建唯一的类名。'
- en: '**Smaller CSS**: Tailwind provides you with a complete set of utility classes
    that you rarely need to supplement with your own styles. Your CSS, therefore,
    stops increasing; in fact, it gets smaller. When you''re ready to production-build
    your application, you can use Tailwind''s built-in purge function to remove unused
    classes.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的CSS**：Tailwind为你提供了一套完整的实用类，你很少需要用你自己的样式来补充。因此，你的CSS不再增加；事实上，它变得更小了。当你准备好生产构建你的应用程序时，你可以使用Tailwind内置的清除功能来删除未使用的类。'
- en: '**No side effects**: As we are adding styles in our markup and not manipulating
    the underlying class names, there are never any unintended side effects elsewhere
    in our application.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无副作用**：因为我们是在我们的标记中添加样式而不是操作底层类名，所以在我们的应用程序的其他地方永远不会出现任何意外的副作用。'
- en: 'The cons for using Tailwind are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Tailwind 的缺点如下：
- en: '**Markup legibility**: As your markup contains your style built from utilities,
    the class names of elements can become incredibly long. When you add in the fact
    that these may need to change on hover or at breakpoints, your line length can
    end up very long.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标记可读性**：由于你的标记包含从实用工具构建的样式，元素的类名可能会变得非常长。当你考虑到这些类名可能需要在悬停或断点时改变，你的行长度可能会变得非常长。'
- en: '**Learning curve**: Utility-first requires you to learn many class names to
    know what tools you must build your styles with. This learning can take some time
    and slow you down at the beginning, but I believe once you have these under your
    belt, your development speed will become much faster.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线**：实用工具优先需要你学习许多类名来了解你必须使用哪些工具来构建样式。这种学习可能需要一些时间，并在开始时减慢你的速度，但我相信一旦你掌握了这些，你的开发速度将会大大提高。'
- en: Tailwind hits a great balance of abstraction and flexibility. It is the newest
    implementation on this list and my personal favorite.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind 在抽象和灵活性之间达到了很好的平衡。这是列表中最新的实现，也是我个人最喜欢的。
- en: CSS in JS
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS in JS
- en: CSS in JS gives you the ability to write plain CSS within your components while
    removing the possibility of naming collisions with class names. For the purpose
    of exploring this option, I will be reviewing the pros and cons of the most popular
    solution, Styled Components ([https://styled-components.com](https://styled-components.com)).
    It is, however, worth mentioning that there are many different CSS in JS solutions,
    including Emotion ([https://emotion.sh](https://emotion.sh)) and JSS ([https://cssinjs.org](https://cssinjs.org)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CSS in JS 允许你在组件内编写纯 CSS，同时避免了与类名发生命名的冲突。为了探索这个选项，我将审查最受欢迎的解决方案——样式组件（[https://styled-components.com](https://styled-components.com)）。然而，值得一提的是，有许多不同的
    CSS in JS 解决方案，包括 Emotion ([https://emotion.sh](https://emotion.sh)) 和 JSS ([https://cssinjs.org](https://cssinjs.org))。
- en: 'The pros for using Styled Components are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用样式组件的优点如下：
- en: '**One source of truth**: Like Tailwind, Styled Components also removes context-switching,
    as your CSS code is housed within the same file as the component making use of
    it.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一的真实来源**：与 Tailwind 一样，样式组件也消除了上下文切换，因为你的 CSS 代码存储在与使用它的组件相同的文件中。'
- en: '**Styles tied to components**: Styles are created for use by one specific component
    and are located next to the markup that implements them. As such, you know exactly
    what makes use of these styles but, more importantly, you know that editing these
    styles will only affect the markup located with them.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式与组件绑定**：样式是为使用特定组件而创建的，并且位于实现它们的标记旁边。因此，你知道哪些样式被使用，更重要的是，你知道编辑这些样式只会影响与它们一起定位的标记。'
- en: '**JS in CSS**: We can make use of JS inside our CSS to determine styling. This
    makes handling conditionals within styles much easier, as we do not have to create
    two different class names and use a ternary operator.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JS 在 CSS 中**：我们可以在 CSS 中使用 JS 来确定样式。这使得在样式内处理条件变得更容易，因为我们不需要创建两个不同的类名并使用三元运算符。'
- en: '**Extending**: It can often be the case that you may want to use a component
    style but subtly modify it for a different use case. Instead of copying the styles
    again and creating a new component from the ground up, we can instead create a
    component that inherits the styling of another.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：通常情况下，你可能想使用一个组件样式，但为了不同的用例微妙地修改它。而不是再次复制样式并从头开始创建一个新的组件，我们可以创建一个继承另一个组件样式的组件。'
- en: 'The cons for using Styled Components are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用样式组件的缺点如下：
- en: '`index.html`. Styles used across all your pages are pulled in on every page
    without any way to easily split them. Even caching the styles is difficult, as
    class names are dynamically generated and can, therefore, change between builds.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`。在所有页面中使用的样式会在每个页面上被拉入，而且没有简单的方法来轻松地将它们分开。即使缓存样式也很困难，因为类名是动态生成的，因此可能在构建之间发生变化。'
- en: If you like a single source of truth, Styled Components improves the legibility
    of your markup when you are combining everything into one file. While performance
    is listed as a con, this is something that the community behind Styled Components
    is making an effort to improve.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢单一的真实来源，当将所有内容合并到一个文件中时，样式组件可以提高你的标记的可读性。虽然性能被列为缺点，但这是样式组件背后的社区正在努力改进的事情。
- en: Picking a styling tool
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择样式工具
- en: 'When it comes to styling your Gatsby site, there is no right or wrong way of
    styling it. It will totally depend on your existing skill set, how coupled you
    want your styles and JS to be, and your own personal preferences. I thought I
    would end this section by looking at a few common scenarios and what styling implementation
    I would use for each of them:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到样式化你的 Gatsby 网站，没有正确或错误的方式。这完全取决于你现有的技能集，你希望你的样式和 JS 多么紧密耦合，以及你个人的偏好。我想以查看一些常见场景及其对应的样式实现方式来结束本节：
- en: '*My experience with styling is limited*: If you are new to styling applications,
    I would suggest using vanilla CSS. The fundamentals you will learn using this
    implementation are built on in every other implementation. By learning the basics,
    you will be able to pick another implementation more easily in the future.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我的样式经验有限*：如果你是样式应用的初学者，我建议使用纯CSS。你通过这种实现方式学到的基本知识是其他所有实现方式的基础。通过学习基础知识，你将能够在未来更容易地选择另一种实现方式。'
- en: '*I don''t want to spend lots of time styling my application*: If you are looking
    for the option with the least setup, then look no further than Tailwind. Using
    utility classes will save you a lot of time, as you do not need to create your
    own classes.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我不想花太多时间在样式上*：如果你在寻找最少设置的选项，那么 Tailwind 就是你的不二选择。使用实用类可以节省你大量时间，因为你不需要创建自己的类。'
- en: '*I don''t like context switching*: In this case, I would lean toward Styled
    Components or Tailwind, as in both implementations your styles are located next
    to your markup – one file and one source of truth.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我不喜欢切换上下文*：在这种情况下，我会倾向于使用 Styled Components 或 Tailwind，因为在两种实现中，你的样式都位于你的标记旁边——一个文件和一个单一的事实来源。'
- en: '*I have used CSS and want to build on that*: Using Sass would be a great option
    for you, as you can write the CSS you know and love but also enhance it with the
    Sass toolset.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我已经使用过CSS，并想在此基础上构建*：使用 Sass 将是一个很好的选择，因为你可以编写你熟悉和喜爱的 CSS，同时也可以通过 Sass 工具集来增强它。'
- en: At this point, you should feel ready to make an informed choice about which
    styling tool is for you. I strongly suggest that you *only implement one of the
    styling choices outlined in this chapter* instead of trying to mix and match.
    If you add multiple styling implementations, you can end up in a position where
    your site styles don't seem to match up. This is because one implementation can
    override another. By sticking to one method, you have the added benefit of keeping
    your site's style consistently uniform, which is important, as it reinforces your
    brand.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经准备好做出明智的选择，决定哪种样式工具适合你。我强烈建议你*只实现本章中概述的样式选择之一*，而不是尝试混合搭配。如果你添加了多个样式实现，你的网站样式可能会显得不一致。这是因为一个实现可以覆盖另一个。通过坚持一种方法，你将获得额外的优势，即保持网站风格的一致性，这对于强化品牌非常重要。
- en: Now that you have made a decision, let's start looking at implementations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经做出了决定，让我们开始查看实现方式。
- en: Styling with CSS
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS进行样式化
- en: In this section, we will learn how to implement CSS styling into our Gatsby
    project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将 CSS 样式应用到我们的 Gatsby 项目中。
- en: There are two different methods to adding global CSS styling to our Gatsby site
    – creating a wrapper component or using `gatsby-browser.js`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的 Gatsby 网站添加全局 CSS 样式有两种不同的方法——创建包装组件或使用 `gatsby-browser.js`。
- en: Creating a wrapper component
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建包装组件
- en: 'The idea behind a wrapper component is to wrap our page components in another
    component that brings common styles to the page:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 包装组件背后的想法是将我们的页面组件包裹在另一个组件中，这个组件将常见的样式带到页面上：
- en: 'Create `StyleWrapper.css` in your `components` folder:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `components` 文件夹中创建 `StyleWrapper.css`：
- en: '[PRE0]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we are defining a background color and a font family
    that all children of the HTML tag can inherit.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在定义一个背景颜色和字体家族，所有 HTML 标签的子元素都可以继承。
- en: 'Let''s now add some `h1` styles to this file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来添加一些 `h1` 样式到这个文件中：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are adding the color, size, and weight of the largest `heading` tag.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在添加最大 `heading` 标签的颜色、大小和权重。
- en: 'Similarly, we can also add some styles for the `p` and `a` tags:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们也可以为 `p` 和 `a` 标签添加一些样式：
- en: '[PRE2]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are adding a color to each tag and, in the case of the `a` tags, an
    underline to make them more prominent.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们为每个标签添加颜色，在 `a` 标签的情况下，添加下划线以使其更加突出。
- en: 'Create `StyleWrapper.js` in your `components` folder:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `components` 文件夹中创建 `StyleWrapper.js`：
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As the name might suggest, we will use this component to wrap our pages to apply
    the styles we are importing on the second line.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如其名称所示，我们将使用此组件来包裹我们的页面，以应用我们在第二行导入的样式。
- en: 'In order to use `StyleWrapper.js`, we need to import it into our pages; let''s
    look at `pages/index.js` as an example:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用`StyleWrapper.js`，我们需要将其导入到我们的页面中；让我们以`pages/index.js`为例：
- en: '[PRE4]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using gatsby-browser.js
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`gatsby-browser.js`
- en: 'If you want the same styles applied to every page, you might feel that importing
    `StyleWrapper` on all page instances doesn''t feel like you''re following **Don''t
    Repeat Yourself** (**DRY**) principles. In cases where you are absolutely sure
    the styles are needed on every page, we can add them to our application using
    the Gatsby browser instead:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望相同的样式应用于每个页面，你可能会觉得在所有页面实例上导入`StyleWrapper`并不符合**不要重复自己**（DRY）原则。在确定样式确实需要在每个页面上使用的情况下，我们可以使用Gatsby浏览器将它们添加到我们的应用程序中：
- en: Create a `styles` folder inside your `src` directory. As these styles are being
    used globally and are not tied to a specific component, it does not make sense
    to store them in the `component` directory, as we did when implementing `StyleWrapper.js`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在你的`src`目录中创建一个`styles`文件夹。由于这些样式是全局使用的，并且与特定组件无关，因此将它们存储在`component`目录中是没有意义的，正如我们在实现`StyleWrapper.js`时所做的。 '
- en: 'Create a `global.css` file in your `styles` folder and add the following:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`styles`文件夹中创建一个`global.css`文件，并添加以下内容：
- en: '[PRE5]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are adding the exact same styles that we had in the alternate CSS implementation,
    so I won't explain them again here. The key difference is in this next step.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了与替代CSS实现中完全相同的样式，因此我不会在这里再次解释它们。关键区别在于接下来的步骤。
- en: 'Navigate to `gatsby-browser.js` and add the following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`gatsby-browser.js`并添加以下内容：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By importing our CSS in `gatsby-browser.js`, Gatsby will wrap every page with
    this CSS.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在`gatsby-browser.js`中导入我们的CSS，Gatsby将为每个页面包裹这个CSS。
- en: Verifying our implementation
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证我们的实现
- en: 'Regardless of which of the two methods you opted for, if everything has gone
    according to plan, you should be presented with a styled site that looks like
    this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择了哪种方法，如果一切按计划进行，你应该会看到一个样式化的网站，看起来像这样：
- en: '![Figure 2.1 – Development of the index page with styles'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – 带样式的索引页开发'
- en: '](img/B15983_02_01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15983_02_01.jpg)'
- en: Figure 2.1 – Development of the index page with styles
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 带样式的索引页开发
- en: You should be able to pick out your CSS additions on this page.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在这个页面上找到你的CSS添加内容。
- en: You have now implemented CSS as a styling tool within your Gatsby site. You
    can disregard the other styling implementations that follow and proceed to the
    *Creating a reusable layout* section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经在你的Gatsby网站上实现了CSS作为样式工具。你可以忽略后续的其他样式实现，并继续到*创建可重用布局*部分。
- en: Styling with Sass
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sass进行样式化
- en: 'In this section, we will learn how to implement Sass styling in our Gatsby
    project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在我们的Gatsby项目中实现Sass样式：
- en: 'To start using Sass, we will need to install it along with a few other dependencies.
    Open a terminal at the `root` folder of your project and run the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用Sass，我们需要安装它以及一些其他依赖项。在你的项目根目录中打开一个终端，并运行以下命令：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are installing the core Sass dependency as well as the Gatsby plugin
    that integrates it.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在安装核心Sass依赖项以及与之集成的Gatsby插件。
- en: 'Modify your `gatsby-config.js` file with the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容修改你的`gatsby-config.js`文件：
- en: '[PRE8]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are updating our Gatsby configuration to let Gatsby know to make use
    of the `gatsby-plugin-sass` plugin. Now, create a `styles` folder inside your
    `src` directory.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在更新我们的Gatsby配置，让Gatsby知道要使用`gatsby-plugin-sass`插件。现在，在你的`src`目录中创建一个`styles`文件夹。
- en: 'Create a `global.scss` file in your `styles` folder and add the following:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`styles`文件夹中创建一个`global.scss`文件，并添加以下内容：
- en: '[PRE9]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I rarely add more than HTML styles to the `global.scss` file. Instead, I prefer
    to import other `.scss` files into this one. This keeps styles in order and the
    files small and readable. As an example, let''s create `typography.scss` to store
    some typography styles:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我很少在`global.scss`文件中添加超过HTML样式。相反，我更喜欢将其他`.scss`文件导入到这个文件中。这有助于保持样式有序，并使文件保持小而可读。例如，让我们创建`typography.scss`来存储一些排版样式：
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we are adding a color to each and, in the case of the `a` tags, adding
    an underline to make them more prominent. We can now import this file into our
    `global.scss` file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们为每个元素添加了颜色，对于`a`标签，我们还添加了下划线以使其更加突出。现在我们可以将此文件导入到我们的`global.scss`文件中：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Navigate to your `gatsby-browser.js` file and add the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的`gatsby-browser.js`文件并添加以下内容：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This tells our Gatsby application to include this style sheet on the client,
    allowing us to make use of it in our application.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉我们的Gatsby应用程序在客户端包含这个样式表，使我们能够在应用程序中使用它。
- en: You have now implemented Sass as a styling tool within your Gatsby site. You
    can disregard the other styling implementations that follow and proceed to the
    *Creating a reusable layout* section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经在你的Gatsby网站上实现了Sass作为样式工具。你可以忽略后续的其他样式实现，并继续到*创建可重用布局*部分。
- en: Styling with Tailwind.css
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tailwind.css进行样式设计
- en: 'In this section, we will learn how to implement Tailwind styling in our Gatsby
    project:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在我们的Gatsby项目中实现Tailwind样式：
- en: 'To start using Tailwind, we will need to install it along with a few other
    dependencies. Open a terminal at the `root` folder of your project and run the
    following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用Tailwind，我们需要安装它以及一些其他依赖项。在你的项目根目录下打开一个终端并运行以下命令：
- en: '[PRE13]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are installing PostCSS, its associated Gatsby plugin, and `tailwindcss`.
    PostCSS is a tool for transforming styles with JS plugins. These plugins can lint
    your CSS, support variables and mixins, transpile future CSS syntax, inline images,
    and more. In the case of Tailwind, there is a specific tailwind plugin for PostCSS
    that we will be implementing.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在安装PostCSS、其关联的Gatsby插件以及`tailwindcss`。PostCSS是一个使用JS插件转换样式的工具。这些插件可以检查CSS的语法、支持变量和混入、转译未来的CSS语法、内联图片等等。在Tailwind的情况下，有一个特定的Tailwind插件用于PostCSS，我们将要实现它。
- en: 'Modify your `gatsby-config.js` with the following:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容修改你的`gatsby-config.js`：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are updating our Gatsby configuration to let it know to make use of
    the Gatsby PostCSS plugin.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在更新我们的Gatsby配置，让它知道要使用Gatsby PostCSS插件。
- en: 'In order to use PostCSS, it requires `postcss.config.js` to be present at the
    root of your project. Go ahead and create this file now and add the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用PostCSS，它需要在项目根目录下存在`postcss.config.js`文件。现在就创建这个文件并添加以下内容：
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this file, we are telling PostCSS to make use of our newly installed `tailwindcss`
    package.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个文件中，我们告诉PostCSS使用我们新安装的`tailwindcss`包。
- en: 'Much like PostCSS, Tailwind also requires a configuration file. Tailwind has
    a built-in script for creating the default configuration. Open a terminal and
    run the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与PostCSS类似，Tailwind也需要一个配置文件。Tailwind有一个内置的脚本用于创建默认配置。打开一个终端并运行以下命令：
- en: '[PRE16]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If this command is successful, you should notice that a new `tailwind.config.js`
    has been created at the root of your project. The default configuration within
    this file will work just fine, so for now, we don't need to edit it.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这个命令成功执行，你应该会注意到在项目根目录下创建了一个新的`tailwind.config.js`文件。这个文件内的默认配置将正常工作，所以目前我们不需要编辑它。
- en: Create a `styles` folder inside your `src` directory.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`src`目录内创建一个`styles`文件夹。
- en: 'Create a `global.css` file inside your `styles` folder and add the following:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`styles`文件夹内创建一个`global.css`文件并添加以下内容：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following to the `gatsby-browser.js` file:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`gatsby-browser.js`文件中：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This tells our Gatsby application to include this style sheet on the client,
    allowing us to make use of Tailwind classes.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉我们的Gatsby应用程序在客户端包含这个样式表，使我们能够使用Tailwind类。
- en: 'With these steps concluded, we now have everything in place to start using
    Tailwind within our application. To make use of Tailwind''s utility classes, we
    can use React''s `className` prop within our components; for example, in `pages/index.js`,
    we could add the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们现在已经为在应用程序中使用Tailwind做好了准备。为了使用Tailwind的实用类，我们可以在组件中使用React的`className`属性；例如，在`pages/index.js`中，我们可以添加以下内容：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we are modifying the style of the heading with the following
    utility classes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用以下实用类修改了标题的样式：
- en: '`text-3xl`: Set the text to the third extra-large size, equivalent to 1.875
    rem.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text-3xl`：将文本设置为第三大额外大号，相当于1.875 rem。'
- en: '`font-bold`: Set the text to the bold font-weight.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font-bold`：将文本设置为粗体字体重量。'
- en: '`text-blue-600`: Set the color of the text to blue.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text-blue-600`：将文本颜色设置为蓝色。'
- en: 'You can alternatively append styles to the `global.css` file that we created
    to have them included:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以另外将样式追加到我们创建的`global.css`文件中，以便它们被包含：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you will see the exact same styles, just defined globally. Both will equate
    to the same styling on the `h1` tag; deciding which variation to use is all about
    frequency. If you intend to use this `h1` style more than once, you should be
    incorporating it into your CSS to save you writing the same styles over and over.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你会看到完全相同的样式，只是定义在全局。两者都将等同于`h1`标签上的相同样式；决定使用哪种变体完全取决于频率。如果你打算多次使用这个`h1`样式，你应该将其合并到你的CSS中，以避免重复编写相同的样式。
- en: 'Let''s now supplement this with a few more styles:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再补充一些样式：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are adding a color to each element and, in the case of the `a` tags,
    adding an underline to make them more prominent.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为每个元素添加一个颜色，对于`a`标签，添加下划线以使其更加突出。
- en: You have now implemented Tailwind as a styling tool within your Gatsby site.
    You can disregard the other styling implementations that follow and proceed to
    the *Creating a reusable layout* section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经在你的Gatsby网站上实现了Tailwind作为样式工具。你可以忽略接下来的其他样式实现，并继续到*创建一个可重用的布局*部分。
- en: Styling with styled-components
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用styled-components进行样式化
- en: 'In this section, we will learn how to implement Styled Components as a styling
    tool in our Gatsby project:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在我们的Gatsby项目中实现Styled Components作为样式工具：
- en: 'Open a terminal at the `root` folder of your project and run to install your
    dependencies:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根目录打开终端并运行以下命令来安装你的依赖项：
- en: '[PRE22]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These are the details of the dependencies:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是依赖项的详细信息：
- en: '`styled-components`: The Styled Components library'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`styled-components`：Styled Components库'
- en: '`gatsby-plugin-styled-components`: The official Gatsby plugin for Styled Components'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gatsby-plugin-styled-components`：Styled Components的官方Gatsby插件'
- en: '`babel-plugin-styled-components`: Provides consistently hashed class names
    between builds'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`babel-plugin-styled-components`：在构建之间提供一致的哈希类名'
- en: 'Update your `gatsby-config.js` with the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容更新你的`gatsby-config.js`：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This instructs Gatsby to use the Styled Components plugin that we just installed.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指示Gatsby使用我们刚刚安装的Styled Components插件。
- en: We can have all the pieces in place to create styles on a page/component level
    and a global level.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以拥有所有必要的组件来在页面/组件级别和全局级别创建样式。
- en: 'To demonstrate utilizing them, navigate to your `pages/index.js` file and add
    the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示如何使用它们，导航到你的`pages/index.js`文件并添加以下内容：
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Occasionally, you may want to create styles globally; in order to demonstrate
    this, navigate to your `gatsby-browser.js` file and add the following:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，你可能想要全局创建样式；为了演示这一点，请导航到你的`gatsby-browser.js`文件并添加以下内容：
- en: '[PRE25]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use the `styled-components` `createGlobalStyle` helper function to create
    our global styles. This stops Styled Components from being scoped to a local CSS
    class.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`styled-components`的`createGlobalStyle`辅助函数来创建全局样式。这阻止了Styled Components被限制在本地CSS类中。
- en: By using the `wrapPageElement` method, we tell Gatsby to wrap every page in
    the component. We can make use of this to wrap every page in our global styles.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用`wrapPageElement`方法，我们告诉Gatsby将每个页面包裹在组件中。我们可以利用这一点来将每个页面包裹在我们的全局样式中。
- en: Regardless of your implementation choice, you should now have the basics in
    place to start building a fully styled site. Let's now start creating the reusable
    layout that we will utilize across the site.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的实现选择如何，你现在都应该有了开始构建一个完全样式化的网站的基本知识。现在让我们开始创建一个可重用的布局，我们将在整个网站上使用它。
- en: Creating a reusable layout
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可重用的布局
- en: Most websites feature headers and footers that are present across all their
    pages. With our knowledge of how pages work, you might be tempted to import a
    header component into every page component. But wait – what happens when you suddenly
    need to pass that component a new prop? Situations like these are why it's a good
    idea to reduce any duplication across pages. Instead, it's a much better option
    to create a layout component that contains a header and footer that we can then
    wrap our pages in.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站都有头部和页脚，这些在所有页面上都存在。根据我们对页面工作原理的了解，你可能会想将头部组件导入到每个页面组件中。但是等等——当你突然需要向该组件传递一个新属性时会发生什么？这类情况正是为什么减少页面之间的任何重复是一个好主意的原因。相反，创建一个包含头部和页脚的布局组件，然后我们可以将其包裹在我们的页面中，这会是一个更好的选择。
- en: In order to keep our `components` folder well structured, it's useful to create
    subfolders to house different parts of the site. Create a `layout` folder in the
    `components` folder to house components that are related to the layout. We will
    use these layout components across all our page files. Now, let's populate this
    folder with a header, footer, and layout component.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`components`文件夹结构良好，创建子文件夹来存放网站的各个部分是有用的。在`components`文件夹中创建一个`layout`文件夹来存放与布局相关的组件。我们将使用这些布局组件跨越所有页面文件。现在，让我们用标题、页脚和布局组件来填充这个文件夹。
- en: Important Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the code examples in this section, you will notice I am using `Tailwind.css`
    to style my components. In the accompanying GitHub repository ([https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main)),
    you can find implementations of these components using all the styling implementations
    we have covered in this chapter. In future chapters, I will be sticking to Tailwind.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中的代码示例中，您会注意到我正在使用`Tailwind.css`来为我的组件添加样式。在配套的GitHub仓库([https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main))中，您可以找到使用本章中涵盖的所有样式实现这些组件的实现。在未来的章节中，我将坚持使用Tailwind。
- en: Site header
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网站页眉
- en: A header component acts as the anchor of our site. It is common to include your
    site header across all your pages so that visitors are reminded that they are
    on your site.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 页眉组件作为我们网站的锚点。在所有页面上包含您的网站页眉是很常见的，这样访客就会记得他们是在您的网站上。
- en: 'To get started, let''s create a `Header.js` component in our `components` folder:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们在我们的`components`文件夹中创建一个`Header.js`组件：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we are creating the most basic of header examples. Note
    that we are making use of the HTML `header` tag. As we will learn in [*Chapter
    6*](B15983_06_ePub_RK.xhtml#_idTextAnchor092), *Improving Your Site's Search Engine
    Optimisation*, using the correct tags when creating content is very important,
    as it helps web crawlers and accessibility tools understand your site.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了最基本的标题示例。请注意，我们正在使用HTML的`header`标签。正如我们将在[*第6章*](B15983_06_ePub_RK.xhtml#_idTextAnchor092)中学习到的，*提高网站搜索引擎优化*，在创建内容时使用正确的标签非常重要，因为它有助于网络爬虫和辅助工具理解您的网站。
- en: Site footer
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网站页脚
- en: Adding a footer to your site can be a powerful tool. I like to think of it as
    a way to keep user engagement after they have finished a page. We can use it to
    give people quick links to our social media so that they can get in touch, we
    can suggest other interesting content that they might enjoy, and we can even tell
    them how many views the current page has had.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网站上添加页脚可以是一个强大的工具。我喜欢将其视为在用户完成页面后保持用户参与度的一种方式。我们可以用它提供快速链接到我们的社交媒体，以便他们能够联系到我们，我们可以建议他们可能喜欢的其他有趣内容，我们甚至可以告诉他们当前页面有多少次浏览。
- en: 'Let''s get started with a basic implementation. Create a `Footer.js` component
    in the `components` folder:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本实现开始。在`components`文件夹中创建一个`Footer.js`组件：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Much like our `Header`, it's important that we use the proper HTML `footer`
    tag.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的`Header`一样，使用正确的HTML `footer`标签是很重要的。
- en: Layout component
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局组件
- en: 'We could directly import our header and footer onto every page we create, but
    if we did that, it would lead to a lot of duplication. One common way to get around
    this is to create a `Layout` component. We wrap every page we build in this component.
    Not only is this an easy way to bring in our header and footer but it also allows
    us to style the main content of every page with minimal effort:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将我们的页眉和页脚导入到我们创建的每个页面中，但如果我们这样做，会导致大量的重复。一种常见的解决方法是创建一个`Layout`组件。我们将每个构建的页面都包裹在这个组件中。这不仅是一个引入我们的页眉和页脚的简单方法，而且还可以让我们以最小的努力为每个页面的主要内容进行样式设计：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, you can see I am importing our newly created `Header` and `Footer` components.
    I am making use of the `children` prop and rendering child content within a `main`
    block.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我正在导入我们新创建的`Header`和`Footer`组件。我正在使用`children`属性并在`main`块内渲染子内容。
- en: 'To demonstrate using the `Layout` component, let''s wrap our index page in
    the component. Modify your `index.js` in pages with the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用`Layout`组件，让我们将我们的索引页面包裹在这个组件中。修改页面中的`index.js`，如下所示：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can see that I have wrapped the landing page in our new `Layout` component
    that has been imported on the third line. If you spin up `gatsby develop` at this
    point, you should see your page content with a header before it and a footer after
    it. You can continue to wrap your other pages in your `layout` component at this
    moment. Before proceeding, let's step back for a moment and look at how we can
    organize the components we're creating for our pages.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我已经将着陆页包裹在我们的新`Layout`组件中，该组件已在第三行导入。如果你此时启动`gatsby develop`，你应该会看到你的页面内容，在其前面有一个页眉，在其后面有一个页脚。你现在可以继续将其他页面包裹在你的`layout`组件中。在继续之前，让我们暂时退后一步，看看我们如何组织为我们的页面创建的组件。
- en: Tip
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some of the styling implementations discussed previously make use of style wrappers.
    If your implementation has made use of a style wrapper, import it into your `layout`
    component and wrap content in this component. This way, you only wrap your pages
    in one component instead of both the `layout` and `style wrapper` components.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的一些样式实现使用了样式包装器。如果你的实现使用了样式包装器，请将其导入到你的`layout`组件中，并用此组件包裹内容。这样，你只需在一个组件中包裹你的页面，而不是`layout`和`style
    wrapper`组件。
- en: Organization with atomic design
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原子设计进行组织
- en: 'As your site expands, it''s important to try and keep your `components` folder
    structured. One commonly used method is to use **atomic design** principles. Atomic
    design is the process of creating effective interface design systems by breaking
    down your site elements into atoms, molecules, organisms, templates, and pages:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的网站扩展，尝试保持你的`components`文件夹的结构是很重要的。一种常用的方法是使用**原子设计**原则。原子设计是通过将网站元素分解为原子、分子、生物体、模板和页面来创建有效的界面设计系统的过程：
- en: '**Atoms**: These are the smallest components that might be incorporated into
    our site, such as buttons, typography components, or text inputs. Atoms cannot
    be logically broken down into subcomponents while still keeping them functional.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子**：这些是我们网站可能包含的最小组件，例如按钮、排版组件或文本输入。在保持其功能的同时，原子不能逻辑上分解成子组件。'
- en: '**Molecules**: Built from two or more atoms, molecules are small groups of
    elements that work together to provide some functionality. A search box consisting
    of a text input and a button could be considered a molecule.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分子**：由两个或更多原子组成，分子是协同工作以提供某些功能的小组元素。一个由文本输入和按钮组成的搜索框可以被视为一个分子。'
- en: '**Organisms**: Built from a group of molecules and atoms, these form larger
    sections of an interface, such as a site''s hero section.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生物体**：由一组分子和原子组成，这些形成界面的大块区域，例如网站的英雄部分。'
- en: '**Templates**: These wrap organisms in a layout and provide the content structure
    and skeletal structure of a page.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：这些将生物体包裹在布局中，并提供页面内容和骨骼结构。'
- en: '**Pages**: An instance of a template with real-world content in place.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面**：一个具有实际内容的模板实例。'
- en: Using atomic design when building components allows you to break your components
    down into smaller self-contained units. These can be tested and developed in isolation
    before importing them into your application, allowing for a more rigorous development
    process but also reducing the reliance on backend logic when conducting frontend
    development.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建组件时使用原子设计允许你将组件分解成更小的自包含单元。这些单元可以在导入到应用程序之前单独测试和开发，这既允许更严格的开发过程，也减少了在执行前端开发时对后端逻辑的依赖。
- en: Once we have defined our atomic design pattern, we can be far more flexible
    when working with styling. Changing an atom's style will also update the styles
    that any molecules and organisms were making use of.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的原子设计模式，我们在处理样式时就可以更加灵活。更改原子的样式也将更新任何分子和生物体所使用的样式。
- en: Depending on your styling implementation, it can also be a good idea to abstract
    commonly used tokens, such as brand colors, spacing rules, and font families.
    It's much easier to maintain a project with a single source of truth, rather than
    darting all over your application pasting hex values to modify your brand colors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的样式实现方式，抽象常用标记，如品牌颜色、间距规则和字体族，也是一个好主意。与在应用程序的各个地方粘贴十六进制值来修改品牌颜色相比，维护一个单一的真实来源的项目要容易得多。
- en: Using atomic design to organize your `components` folder can really help as
    things scale, so keep it in mind in future chapters as your application expands.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原子设计来组织你的`components`文件夹，当规模扩大时，这真的很有帮助，所以请记住在未来的章节中，随着你的应用程序的扩展。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how you can style a Gatsby site in a multitude
    of ways. This should aid you in making an informed choice about what way you will
    style your application going forward. We have seen how to style your Gatsby site
    using CSS, Sass, Tailwind.css, and Styled Components. You should have decided
    on one of these and implemented them. In future chapters, I will use Tailwind.css
    to style the application, but this is a personal preference. You should use whatever
    you feel is best for your site and your existing knowledge.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何以多种方式样式化 Gatsby 网站。这应该有助于你做出明智的选择，决定你将如何继续样式化你的应用程序。我们看到了如何使用 CSS、Sass、Tailwind.css
    和 Styled Components 来样式化你的 Gatsby 网站。你应该已经决定使用其中之一并实施它。在未来的章节中，我将使用 Tailwind.css
    来样式化应用程序，但这只是个人偏好。你应该使用你认为最适合你的网站和现有知识的方法。
- en: We also started creating the first reusable components that will make up the
    backbone of our site. While our `layout` component may seem primitive right now,
    we will be integrating it with content in the next chapter and adding imagery
    to bring it to life even further in [*Chapter 5*](B15983_05_ePub_RK.xhtml#_idTextAnchor080),
    *Working with Images*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还开始创建将构成我们网站骨架的第一个可重用组件。虽然我们的 `layout` 组件现在可能看起来很原始，但我们将在下一章将其与内容集成，并添加图像以进一步在
    [*第五章*](B15983_05_ePub_RK.xhtml#_idTextAnchor080)，*与图像一起工作* 中使其生动起来。
- en: Before continuing to the next chapter, I encourage you to spend time building
    on the styles outlined here until you have your existing pages looking how you
    want them to. While I think it's best to define your own styles, you can find
    an example of a completely styled version of the site in Tailwind.css in the code
    repository.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一章之前，我鼓励你花时间基于这里概述的样式进行构建，直到你的现有页面看起来是你想要的样子。虽然我认为定义你自己的样式是最好的，但你可以在代码仓库中的
    Tailwind.css 中找到一个完全样式化的网站示例。
- en: In the next chapter, we will begin sourcing content from local files, CMSes,
    and APIs. We will be using this data to start programmatically creating pages
    on our Gatsby site.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始从本地文件、CMS 和 API 中获取内容。我们将使用这些数据在 Gatsby 网站上程序化地创建页面。
