- en: Navigational Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航模式
- en: In this chapter, we'll explore some of the most useful navigational object-oriented
    patterns and learn how to apply them in the Angular way. Navigational patterns
    are used to organize events that are related to the navigation of our users on
    our apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些最有用的导航面向对象模式，并学习如何在 Angular 方式中应用它们。导航模式用于组织与用户在我们应用程序上的导航相关的事件。
- en: Angular is, by itself, an object-oriented framework, and it forces you to do
    most of your development in certain ways. For example, you are required to have
    components, services, pipes, and so on. Forcing these building blocks upon you contributes
    to building a good architecture, very much like what the Zend framework does for
    PHP, or Ruby on Rails for Ruby. Of course, in addition, frameworks are here to
    make your life easier and speed up development time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 本身是一个面向对象的框架，它强制你以某种方式进行大部分开发。例如，你需要有组件、服务、管道等。强制这些构建块对你有利，有助于构建良好的架构，就像
    Zend 框架对 PHP 或 Ruby on Rails 对 Ruby 所做的那样。当然，此外，框架还能让你的生活更轻松，加快开发时间。
- en: While the Angular way of designing things is way above average, we can always
    do better. I do not claim that what I present in this chapter are the ultimate
    designs and that you will be able to use them to resolve anything from bakery
    one-pagers to dashboards for the Mars One mission—such a design doesn't exist,
    unfortunately—but it will definitively improve your toolbelt.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Angular 的设计方式远远超出平均水平，但我们总是可以做得更好。我并不认为我在本章中提出的是最终设计，你将能够用它们解决从面包店单页到火星一号任务的仪表板的任何问题——不幸的是，这样的设计并不存在，但它肯定会提高你的工具箱。
- en: 'In this chapter, we will learn about the following patterns:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下模式：
- en: Model-view-controller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器
- en: Redux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux
- en: MVC
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC
- en: Oh MVC, good ol' MVC. You served us well for many years. Now, people want you
    to retire, without fuss if possible. Even I can see how younger, unidirectional
    user interface architectures can outsmart you and make you look like a relic from
    the past.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，MVC，老朋友 MVC。多年来你为我们效力。现在，人们希望你退休，最好不要闹腾。即使我也能看到，年轻的、单向的用户界面架构可以比你更聪明，让你看起来像过去的遗物。
- en: In this section, we'll first describe what the model-view-controller is, regardless
    of the programming language used to implement it, and then we'll see the shortcomings
    of applying MVC for frontend programming. Finally, I'll present a way of implementing
    an MVC that makes sense with Angular in terms of ease of implementation, maintenance,
    and performance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先描述模型-视图-控制器是什么，不管用什么编程语言来实现它，然后我们将看到将 MVC 应用于前端编程的缺点。最后，我将介绍一种在 Angular
    中实现 MVC 的方法，这种方法在实现、维护和性能方面是有意义的。
- en: Model-view-controller at large
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大型的模型-视图-控制器
- en: 'The whole principle behind the model-view-controller design pattern is relatively
    simple. Indeed, as shown in the following diagram, it''s composed of three blocks:
    Model, View, and Controller:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器设计模式背后的整个原则相对简单。事实上，如下图所示，它由三个块组成：模型、视图和控制器：
- en: '![](assets/04b1d7a0-5b88-441d-9609-ff9d10b06920.png)Model-view-controller overview'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/04b1d7a0-5b88-441d-9609-ff9d10b06920.png)模型-视图-控制器概述'
- en: 'The components are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 组件如下：
- en: The Model stores the data required by the application according to commands
    sent by the Controller.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型根据控制器发送的命令存储应用程序所需的数据。
- en: The Controller receives actions from the user (such as the click of a button)
    and directs model updates accordingly. It can also switch which view is used at
    any given moment.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器接收用户的操作（例如按钮的点击）并相应地指导模型更新。它还可以在任何给定时刻切换使用的视图。
- en: The View is generated and updated every time the model changes.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图在模型更改时生成并更新。
- en: And that's it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: Let's see what a simple MVC implementation would look like in pure TypeScript.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看纯TypeScript中简单的MVC实现会是什么样子。
- en: 'First, let''s define a `Movie` class like we did back in [Chapter 3](fac4936a-292a-4b12-ac60-394bacad0f16.xhtml),
    *Classical Patterns*. In this version of the `Movie` class, we only have two attributes:
    `title` and `release_year`, which are defined using a TypeScript constructor:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们像在[第3章](fac4936a-292a-4b12-ac60-394bacad0f16.xhtml)中那样定义一个`Movie`类，*经典模式*。在这个版本的`Movie`类中，我们只有两个属性：`title`和`release_year`，它们是使用TypeScript构造函数定义的：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we define a `Model` class that imports the `movie.ts` file, containing
    the `Movie` class, using the `reference` keyword. This model class, which will
    be responsible for updating the view, has a movie array and two methods. The first
    method, `addMovie(title:string, year:number)`, is `public` and appends a new movie
    at the end of the `movies` attribute. It also calls the second method of the class, `appendView(movie:Movie)`,
    which is `private`. This second method manipulates the view as per model-view-controller
    definition. The view manipulation is rather simple: we append a new `li` tag to
    the `#movie` element of the view. The content of the newly created `li` tag is
    a concatenation of the movie title and release year:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`Model`类，它使用`reference`关键字导入包含`Movie`类的`movie.ts`文件。这个模型类将负责更新视图，它有一个电影数组和两个方法。第一个方法`addMovie(title:string,
    year:number)`是`public`的，它在`movies`属性的末尾添加一个新电影。它还调用类的第二个方法`appendView(movie:Movie)`，这个方法是`private`的。这个第二个方法按照模型-视图-控制器的定义来操作视图。视图操作相当简单：我们在视图的`#movie`元素中添加一个新的`li`标签。新创建的`li`标签的内容是电影标题和发行年份的连接。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now define a controller for our pure TypeScript model-view-controller.
    The controller has a `private model:Model` attribute that is initiated in the
    constructor. In addition, a `click` method is defined. This method takes a `string`
    and a `number` in parameters for the title and the release year, respectively.
    As you can see, the `click` method forwards the title and the release year to
    the `addMovie` method of the model. Then, the controller''s job is done. It does
    not manipulate the view. You''ll also notice the last line of the `controller.ts`
    file: `let controller = new Controller();`. This line allows us to create an instance
    of the controller that the view can bind to:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为我们的纯TypeScript模型-视图-控制器定义一个控制器。控制器有一个`private model:Model`属性，在构造函数中初始化。此外，定义了一个`click`方法。此方法以参数形式接受`string`和`number`，分别用于标题和发行年份。正如你所看到的，`click`方法将标题和发行年份转发给模型的`addMovie`方法。然后，控制器的工作就完成了。它不操作视图。你还会注意到`controller.ts`文件的最后一行：`let
    controller = new Controller();`。这行允许我们创建一个控制器的实例，以便视图可以绑定到它：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last piece of our model-view-controller implementation would be the view.
    We have a bare-bones HTML form that, on submit, invokes the following: `controller.click(this.title.value,
    this.year.value); return false;`. `controller` has been defined in the `controller.ts`
    file with `let controller = new Controller();`. Then, for the parameters, we send
    `this.title.value` and `this.year.value`, where `this` refers to`<form>`. `title`
    and `year` refer to the fields for the title and the release year of the movie,
    respectively. We must also add `return false;` to prevent the page from reloading.
    Indeed, the default behavior of an HTML form, on submit, is to navigate to the
    action URL:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型-视图-控制器实现的最后一部分将是视图。我们有一个简单的HTML表单，提交时会调用以下操作：`controller.click(this.title.value,
    this.year.value); return false;`。`controller`已在`controller.ts`文件中定义为`let controller
    = new Controller();`。然后，对于参数，我们发送`this.title.value`和`this.year.value`，其中`this`指的是`<form>`。`title`和`year`分别指电影的标题和发行年份的字段。我们还必须添加`return
    false;`以防止页面重新加载。确实，HTML表单在提交时的默认行为是导航到操作URL：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the header, we add the `mvc.js` script generated by the following command:
    `tsc --out mvc.js controller.ts model.ts movie.ts`. The generated JavaScript looks
    like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在页眉中，我们添加了通过以下命令生成的“mvc.js”脚本：`tsc --out mvc.js controller.ts model.ts movie.ts`。生成的JavaScript如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the execution side, at loading time, the HTML page would look like it does
    in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行方面，在加载时，HTML页面将如下截图所示：
- en: '![](assets/9e02495c-ab05-4190-b945-0a5e2e4f1ff5.png)Model-view-controller at
    loading point'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 加载点处的模型-视图-控制器
- en: 'Then, if you use the form and add a movie, it''ll automatically impact the
    view and display the new movie:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您使用表单并添加电影，它将自动影响视图并显示新的电影：
- en: '![](assets/c74733ae-6571-4505-bf42-3c75716c554e.png)Model-view-controller after
    using the form'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表单后的模型-视图-控制器
- en: Model-view-controller limitations for the frontend
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端的模型-视图-控制器的限制
- en: 'So, why is the model-view-controller pattern not that widely used when it comes
    to frontend programming supported by frameworks such as Angular? First, if you
    are using Angular for an app that provides a service, you are likely to have a
    backend with which you exchange some sort of information. Then, if your backend
    also uses the model-view-controller design pattern, you''ll end up with the following
    hierarchy:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么模型-视图-控制器模式在前端编程中并不被广泛使用，尤其是在像Angular这样的框架支持的情况下？首先，如果您正在使用Angular开发提供服务的应用程序，您很可能会有一个后端，您需要与其交换某种信息。然后，如果您的后端也使用模型-视图-控制器设计模式，您将得到以下层次结构：
- en: '![](assets/48faf0b9-64c8-4aff-8760-9aa8e7e2623f.png)Model-view-controller frontend
    and backend'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端的模型-视图-控制器
- en: In this hierarchy, we have an MVC implementation on top of another MVC implementation.
    The implementations communicate with each other via an API service that sends
    requests to the backend controller and parses the resultant view. As a concrete
    example, if your user has to sign in to your app, they'll see the `signin` view
    on the frontend, which is powered by a `user` model and a `signin` controller.
    Once all of the information (email address, password) has been entered, the user
    clicks on the signin button. This click triggers a model update and the model
    then triggers an API call using the API service. The API service makes a request
    to the "user/signin" endpoint of your API. On the backend, the request is received
    by the `user` controller and forwarded to the `user` model. The backend `user`
    model will query your database to see if there is a matching user with the provided
    email address and password. Finally, a view will be output, containing the user
    information if the login was successful. Going back on the frontend, the API service
    will parse the produced view and return the relevant information to the frontend
    `user` model. In turn, the frontend `user` model will update the frontend `view`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次结构中，我们在另一个MVC实现的顶部有一个MVC实现。这些实现通过一个API服务进行通信，该服务向后端控制器发送请求并解析生成的视图。具体示例是，如果用户需要在您的应用程序中登录，他们将在前端看到“登录”视图，该视图由“用户”模型和“登录”控制器提供支持。一旦所有信息（电子邮件地址，密码）都已输入，用户点击登录按钮。这个点击触发了模型更新，然后模型使用API服务触发API调用。API服务向您的API的“用户/登录”端点发出请求。在后端，请求被“用户”控制器接收并转发到“用户”模型。后端“用户”模型将查询您的数据库，以查看是否有提供的电子邮件地址和密码匹配的用户。最后，如果登录成功，将输出一个视图，其中包含用户信息。回到前端，API服务将解析生成的视图并将相关信息返回给前端“用户”模型。然后，前端“用户”模型将更新前端“视图”。
- en: For some developers, that many layers and the fact that the architecture is
    kind of duplicated on the frontend and the backend just feels wrong, even though
    it brings maintainability through a well-defined separation-of-concerns.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些开发者来说，这么多层次以及架构在前端和后端之间的重复似乎有些不对，尽管它通过明确定义的关注点分离带来了可维护性。
- en: The dual model-view-controller isn't the only concern. Another problem is that
    the frontend models will not be *pure* models as they must account for variables
    regarding the UI itself such as visible tab, forms validity, and so on. Hence,
    your frontend models tend to become hideous blobs of code where UI variables rub
    shoulders with the actual representation of your user.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 双重模型-视图-控制器不是唯一的问题。另一个问题是，前端模型不会是*纯*模型，因为它们必须考虑到与UI本身相关的变量，比如可见标签、表单有效性等。因此，你的前端模型往往会变成代码的丑陋堆积，其中UI变量与用户的实际表示相互交织。
- en: Now, as always, you can avoid these traps and harness the advantages of the
    MVC pattern. Let's see how in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像往常一样，你可以避免这些陷阱，并利用MVC模式的优势。让我们在下一节中看看如何做到这一点。
- en: Angular's model-view-controller
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的模型-视图-控制器
- en: In this section, I present an architecture for the MVC in Angular that proved
    itself. I used this architecture for the past 18 months at `toolwatch.io` (web,
    Android, and iOS). Obviously, the features we propose on the web version or on
    the mobile apps are the same and work in the same way. What changes are the views
    and the navigation schema.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我提出了一个在Angular中证明有效的MVC架构。在过去的18个月里，我在`toolwatch.io`（Web、Android和iOS）上使用了这个架构。显然，我们在Web版本或移动应用上提出的功能是相同的，并且以相同的方式工作。改变的是视图和导航模式。
- en: 'The following diagram represents the overall architecture:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表代表了整体架构：
- en: '![](assets/5f5eae16-e4ec-49f1-b524-8fece9c61d58.png)MVC for Angular'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5f5eae16-e4ec-49f1-b524-8fece9c61d58.png)Angular的MVC'
- en: From top to bottom, we have the backend, the reusable pieces of the frontend,
    and the specialized frontend (mobile or web). As you can see, on the backend,
    nothing changes. We kept our classical MVC. Note that the frontend parts would
    work also with a non-MVC backend.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下，我们有后端、前端的可重用部分以及专门的前端（移动或Web）。正如你所看到的，在后端，没有任何变化。我们保持了我们经典的MVC。请注意，前端部分也可以与非MVC后端一起工作。
- en: Our model will use that service to get, put, and delete a plain TypeScript object
    from the remote database through a hypothetical; JSON API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型将使用该服务通过一个假设的JSON API从远程数据库获取、放置和删除一个普通的TypeScript对象。
- en: 'Here''s what our `user` TypeScript object looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`user` TypeScript对象如下所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nothing too fancy here; only a plain TypeScript object that contains two attributes:
    `email:_string` and `password:_string`. These two attributes are initialized in
    the constructor using the TypeScript inline declaration style. We also leverage
    the getter/setter of TypeScript in order to access the `_password:string` and
    `_email:string` attributes. You might have noticed that the TypeScript getters/setters
    look like C# properties. Well, Microsoft is one of the principal industrial investigators
    for TypeScript, so it makes sense.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的东西；只是一个包含两个属性的普通TypeScript对象：`email:_string`和`password:_string`。这两个属性在构造函数中使用TypeScript内联声明样式进行初始化。我们还利用了TypeScript的getter/setter来访问`_password:string`和`_email:string`属性。你可能已经注意到，TypeScript的getter/setter看起来像C#属性。嗯，微软是TypeScript的主要工业研究者之一，所以这是有道理的。
- en: I do like the conciseness of the writing, especially when combined with the
    inline attribute declaration in the constructor. What I don't like, however, is
    the necessity for underscored variables names. The problem is that, once again,
    this TypeScript will be transpiled to JavaScript, and in JavaScript, variables
    and functions are a bit more abstract than, let's say, Java or C#.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢写作的简洁性，特别是与构造函数中的内联属性声明相结合时。然而，我不喜欢的是需要使用下划线变量名。问题在于，再一次强调，这个TypeScript将被转译为JavaScript，在JavaScript中，变量和函数比如Java或C#更加抽象。
- en: 'Indeed, in our current example, we could invoke the getter of the `User` class
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在我们当前的示例中，我们可以调用`User`类的getter如下：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, TypeScript doesn''t care about the type of the target it''s
    calling. It can be a variable named `email` or a function named `email()`. Either
    way, it works. The underlying rationale behind these odd behaviors, for an object-oriented
    programmer that is that in JavaScript, is that it''s acceptable to do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，TypeScript并不关心它调用的目标的类型。它可以是一个名为`email`的变量，也可以是一个名为`email()`的函数。无论哪种方式，它都可以工作。这些奇怪行为背后的基本原理是，对于面向对象的程序员来说，在JavaScript中，可以做以下操作是可以接受的：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Consequently, we need to differentiate the actual variables of the function
    with different names, hence the `_`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要区分函数的实际变量与不同的名称，因此有了`_`。
- en: 'Let''s go back to our MVC implementation now that we have a fool-proof user
    object to manipulate. Now, we can have a `user` model that manipulates the `user`
    POTO (plain old TypeScript object) and the necessary variable for the graphical
    interface:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个经过验证的用户对象来操作，让我们回到我们的MVC实现。现在，我们可以有一个`user`模型来操作`user` POTO（普通的旧TypeScript对象）和图形界面所需的变量：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our model, named `UserModel`, receives an injection of an `APIService`. The
    implementation of the `APIService` is left to the reader as an exercise. In addition
    to the `APIService`, the `UserModel` owns the`user:User` and`loading:bool` attributes.
    The `user:User` represents the actual user with its password and email address.
    The `loading:bool`, however, will be used to determine whether or not a loading
    spinner should be visible in the view. As you can see, the `UserModel` defines
    the `signin` and `signup` methods. In these methods, we call the `getUser` and
    `postUser` methods of the `APIService`, which both take a user in an argument
    and return a promise containing said user that's been synchronized via the JSON
    API. On reception of these promises, we turn off the `loading:bool` spinner.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型，名为`UserModel`，接收一个`APIService`的注入。`APIService`的实现留给读者作为练习。除了`APIService`之外，`UserModel`拥有`user:User`和`loading:bool`属性。`user:User`代表具体的用户，包括密码和电子邮件地址。然而，`loading:bool`将用于确定视图中是否应该显示加载旋转器。正如你所看到的，`UserModel`定义了`signin`和`signup`方法。在这些方法中，我们调用`APIService`的`getUser`和`postUser`方法，两者都接受一个用户作为参数，并返回一个包含已通过JSON
    API同步的用户的promise。收到这些promise后，我们关闭`loading:bool`旋转器。
- en: 'Here''s the `APIService`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`APIService`：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `APIService` makes HTTP calls to parse a local JSON file containing the
    user:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIService`发出HTTP调用以解析包含用户信息的本地JSON文件：'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`getUser(email:string, password:string):Promise<User>` and `postUser(email:string,
    password:string):Promise<User>` are using promises, just like we showed you in
    the previous chapter.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUser(email:string, password:string):Promise<User>`和`postUser(email:string,
    password:string):Promise<User>`都使用了promise，就像我们在上一章中展示的那样。'
- en: 'Then, there is the controller, which will also be a component in an Angular
    environment, as Angular components control the view that is displayed and so on:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有控制器，它也将是Angular环境中的一个组件，因为Angular组件控制显示的视图等等：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the controller (component) is really simple. We only have a
    reference to the model and we receive an injected `APIService` to be transfered
    to the model. Then, we have the `signinClick` and `signupClick` methods which
    receive user input from the view and transfer them to the model. The last piece,
    the view, looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，控制器（组件）非常简单。我们只有一个对模型的引用，并且我们接收一个注入的`APIService`来传递给模型。然后，我们有`signinClick`和`signupClick`方法，它们从视图接收用户输入并将其传递给模型。最后一部分，视图，看起来像这样：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have two forms: one for the signin and one for the signup. The forms
    are alike except for the `onsubmit` method they use. The signin form uses the
    `signinClick` method of our controller and the signup form uses the `signupClick`
    method. In addition to these two forms, we also have, on each form, a *font awesome*
    spinner that is only visible when the user model is *loading*. We achieve this
    by using the `[hidden]`Angular directive: `[hidden]="!model.loading"`. Similarly,
    the submit buttons are hidden when the model is loading.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两种形式：一种用于登录，一种用于注册。这两种表单除了它们使用的`onsubmit`方法不同之外，它们是相似的。登录表单使用我们控制器的`signinClick`方法，注册表单使用`signupClick`方法。除了这两种表单，我们还在每个表单上有一个*font
    awesome*旋转器，只有当用户模型正在*加载*时才可见。我们通过使用`[hidden]`Angular指令来实现这一点：`[hidden]="!model.loading"`。同样，当模型正在加载时，提交按钮也是隐藏的。
- en: So, here it is, a functional MVC applied to Angular.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是一个应用于Angular的功能性MVC。
- en: As I said at the beginning of this section, for me, the true usefulness of the
    MVC pattern in Angular comes from its extensibility. Indeed, leveraging the object-oriented
    aspect (and what comes with it) of TypeScript allows us to specialize controllers
    and models for different Angular applications. For example, if you have an Angular
    website and an Angular mobile application, as I do with `toolwatch.io`, then you
    have business logic you can use on both sides. It would be a shame to have two
    signins, two signups, and two of everything to code and maintain over time when
    we could have only one!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节开头所说的，对我来说，Angular中MVC模式的真正用处来自于它的可扩展性。事实上，利用TypeScript的面向对象方面（以及随之而来的内容）允许我们为不同的Angular应用程序专门化控制器和模型。例如，如果你像我一样有一个Angular网站和一个Angular移动应用程序，那么你可以在两边使用业务逻辑。当我们可以只有一个时，如果随着时间的推移，我们需要编写和维护两个登录、两个注册和两个所有内容，那将是一件遗憾的事情！
- en: At `toolwatch.io`, for example, the web application uses standard Angular and
    we built the mobile applications using Ionic and Angular. Obviously, we have a
    lot of frontend logic shared between the mobile apps (Android and iOS) and the
    website. Ultimately, they tend to achieve the same purposes and functionalities.
    The only difference is the medium that's being used to utilize those functionalities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`toolwatch.io`，Web应用程序使用标准的Angular，我们使用Ionic和Angular构建了移动应用程序。显然，我们在移动应用程序（Android和iOS）和网站之间共享了大量前端逻辑。最终，它们倾向于实现相同的目的和功能。唯一的区别是使用的媒介来利用这些功能。
- en: 'In the following diagram, I loosely represent a more complete way of leveraging
    the MVC pattern with a focus on reusability and extensibility:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我粗略地表示了一种更完整地利用MVC模式的方式，重点放在可重用性和可扩展性上：
- en: '![](assets/76a03142-0e91-49ae-bae9-33027d6fd7ce.png)MVC for Angular'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/76a03142-0e91-49ae-bae9-33027d6fd7ce.png)Angular的MVC'
- en: 'Once again, the backend stays as is. We have the same MVC pattern there. As
    a reminder, the MVC pattern on the backend is entirely up to you, and you could
    take advantage of the frontend MVC pattern with a functional Go backend, for example.
    What differs from the previous version of the MVC exposed here is the introduction
    of the *Reusable Frontend* part. In this part, we still have an API service in
    charge of consuming our JSON API. Then, we have a model that implements the `IModel`
    interface:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，后端保持不变。我们在那里仍然有相同的MVC模式。作为提醒，后端的MVC模式完全取决于你，你可以利用前端的MVC模式与功能性的Go后端进行结合，例如。与此处公开的MVC的先前版本不同的是*可重用前端*部分的引入。在这部分中，我们仍然有一个负责消费我们的JSON
    API的API服务。然后，我们有一个实现了`IModel`接口的模型。
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This interface defines the `put`, `post`, `delete`, and `patch` methods that
    have to be implemented in the subsequent models. The `POTO` type that these methods
    take as parameters and return is the mother class for any domain model you have
    in your program. A domain model represents a synchronizable entity of your business
    logic such as the `User` we used before. The domain model and the model part of
    the model-view-controller are not to be confused. They are not the same thing
    at all. In this architecture, `User` would expend `POTO`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口定义了必须在后续模型中实现的`put`、`post`、`delete`和`patch`方法。这些方法所接受的参数和返回的`POTO`类型是你程序中任何领域模型的母类。领域模型代表了你的业务逻辑中的可同步实体，比如我们之前使用的`User`。领域模型和模型-视图-控制器中的模型部分不应混淆。它们根本不是同一回事。在这种架构中，`User`会扩展`POTO`。
- en: 'The model (of model-view-controller this time) contains a `POTO` in addition
    to implementing the `IModel` interface. It also contains the variables and methods
    you need to update your views. The implementation of the model itself is rather
    straightforward, as I showed earlier in this section. However, we can kick things
    up a notch by leveraging the generic aspect of TypeScript and envision the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的模型（模型-视图-控制器）除了实现`IModel`接口之外，还包含了一个`POTO`。它还包含了你需要更新视图的变量和方法。模型本身的实现相当简单，就像我在本节前面展示的那样。然而，我们可以通过利用TypeScript的泛型特性来提升一些东西，设想以下情况：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we have a generic `AbstractModel` that is constrained by `POTO`. This
    means that the actual instance of the `AbstractModel` generic class (known as
    a template in languages such as C++) is constrained to have a class specializing
    `POTO`. In other words, only domain models such as `User` can be used. So far,
    the separation of concern is excellent as well as its reusability. The last piece
    of the reusable part is the controller. In our signup/signin example, it would
    look very much like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个通用的`AbstractModel`，它受到`POTO`的约束。这意味着`AbstractModel`泛型类的实际实例（在诸如C++的语言中称为模板）受到了对专门化`POTO`的类的约束。换句话说，只有像`User`这样的领域模型才能被使用。到目前为止，关注点的分离以及其可重用性都非常出色。可重用部分的最后一部分是控制器。在我们的注册/登录示例中，它看起来会非常像这样：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, why do we need an additional building block here, and why can't we use
    a simple Angular component as we did for the simpler version of the Angular model-view-controller?
    Well, the thing is that, depending on what you use on top of your Angular core
    (Ionic, Meteor, and so on), the component isn't necessarily the main building
    block. For example, in the Ionic2 world, you use `Pages`, which are their custom
    version of the classical component.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们在这里需要一个额外的构建模块，为什么我们不能像我们在Angular模型-视图-控制器的简化版本中那样使用一个简单的Angular组件呢？嗯，问题在于，取决于你在Angular核心之上使用的是什么（Ionic、Meteor等），组件并不一定是主要的构建模块。例如，在Ionic2世界中，你使用`Pages`，这是他们对经典组件的自定义版本。
- en: 'So, for example, the mobile part would look like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，移动部分会是这样的：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If need be, you can also extend `UserModel` and add some specialization, as
    shown in the preceding diagram. On the browser side:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您还可以扩展`UserModel`并添加一些专业化，就像前面的图表所示的那样。在浏览器端：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, you can also extend `UserModel` and add some specialization. The
    only remaining block to cover is the view. To my despair, there is no way to use
    extends or a style file for that. Hence, we are doomed to have duplication of
    HTML files between clients unless the HTML file is exactly the same between the
    mobile app and the browser app. From experience, this doesn't happen very often.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以再次扩展`UserModel`并添加一些专业化。唯一剩下的要涵盖的部分是视图。令我绝望的是，没有办法使用extends或样式文件。因此，除非移动应用程序和浏览器应用程序之间的HTML文件完全相同，否则我们注定会在客户端之间存在HTML文件的重复。根据经验，这种情况并不经常发生。
- en: The whole reusable frontend can be shipped as a Git submodule, a standalone
    library, or as an `NgModule`. I personally use the git submodule approach as it
    allows me to have two separate repositories while enjoying auto-refresh on the
    client I am working on when I perform a modification on the shared frontend.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 整个可重用的前端可以作为Git子模块、独立库或`NgModule`进行发布。我个人使用git子模块方法，因为它允许我在执行对共享前端进行修改时，在我正在工作的客户端上享受自动刷新，同时拥有两个单独的存储库。
- en: Note that this model-view-controller also works if you have several frontends
    hitting the same backend instead of several types of frontends. For example, in
    an e-commerce setup, you may want to have differently branded websites to sell
    different products that are all managed in the same backend, like what's possible
    with Magento's views.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种模型-视图-控制器也适用于多个前端命中相同的后端，而不是多种类型的前端。例如，在电子商务设置中，您可能希望拥有不同品牌的网站来销售在同一个后端中管理的不同产品，就像Magento的视图所能实现的那样。
- en: Redux
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux
- en: Redux is a pattern that allows you to manage your event and application states
    in a safe way. It allows you to make sure that your application-wide states, resulting
    from navigation events or not, are managed in a single, non-accessible place.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一种模式，可以让您以安全的方式管理事件和应用程序状态。它可以确保您的应用程序范围的状态，无论是由导航事件还是其他事件引起的，都在一个单一的不可访问的地方进行管理。
- en: 'Usually, the states of your application are stored in a TypeScript interface.
    Following the example we used in the previous section, we will implement login/logout
    functionalities for a user using a custom `APIService` that consumes JSON. In
    our case, the application has only one state: `logged`. Consequently, the interface
    would look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序的状态存储在TypeScript接口中。根据我们在上一节中使用的示例，我们将使用自定义的`APIService`来为用户实现登录/注销功能，该服务消耗JSON。在我们的情况下，应用程序只有一个状态：`logged`。因此，接口看起来像这样：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This interface only contains a single logged boolean. It might seem like overkill
    to have an interface for such a common variable, but you'll find it handy when
    your applications start to grow. The state of our application can only be manipulated
    through `Action`. Actions are a type of event within the redux framework that
    are triggered and intercepted by a `Reducer`. The `Reducer` intercepts the actions
    and manipulates the state of our application. The `Reducer` is the only place
    where changes in state can happen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口只包含一个单一的logged布尔值。对于这样一个常见的变量来说，拥有一个接口可能看起来有点多余，但是当您的应用程序开始增长时，您会发现它很方便。我们的应用程序的状态只能通过`Action`来操作。`Action`是redux框架中的一种事件类型，由`Reducer`触发和拦截。`Reducer`拦截这些动作并操作我们应用程序的状态。`Reducer`是唯一可以发生状态变化的地方。
- en: 'Now that we have had a quick overview of the redux pattern, it''s time to dive
    into its implementation. First, we will need to create a new Angular project and
    install the required packages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速概述了redux模式，现在是时候深入其实现了。首先，我们需要创建一个新的Angular项目并安装所需的包：
- en: '`**ng new ng-redux**`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**ng new ng-redux**`'
- en: '`**cd ng-redux**`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**cd ng-redux**`'
- en: '`**npm install  – save redux @angular-redux/store**`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**npm install  – save redux @angular-redux/store**`'
- en: 'Next, we will create our actions. As a reminder, actions are triggered by the
    application and intercepted by the `reducer` in order to manipulate application
    states. In our application, we only have two actions, login and logout:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的操作。作为提醒，操作是由应用程序触发的，并被`reducer`拦截，以便操作应用程序状态。在我们的应用程序中，我们只有两个操作，登录和注销：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see in the preceding code, the `LoginAction` class is an Angular service
    in the sense that it is injectable. Consequently, any one part of our architecture
    could receive a list of actions through the automated dependency injection mechanisms
    of Angular that were presented in the previous chapter. Another thing to note
    is that our two actions are returning, well, `Actions`. The `action` class is
    composed of a `type` field, and we use static string variables to populate them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，`LoginAction`类是一个Angular服务，因为它是可注入的。因此，我们架构的任何一个部分都可以通过Angular的自动依赖注入机制接收操作列表，这些机制在前一章中已经介绍过。还要注意的一点是，我们的两个操作都返回`Actions`。`action`类由一个`type`字段组成，我们使用静态字符串变量来填充它们。
- en: 'The next item on the list is the reducer, which intercepts triggered actions
    and manipulates the states of our application accordingly. The reducer can be
    implemented as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表上的下一个项目是`reducer`，它拦截触发的操作，并相应地操作我们应用程序的状态。`reducer`可以这样实现：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For now, our reducer only manages two actions: login and logout. On reception
    of an action, we check the action type with a switch statement and simply reverse
    the value of the logged state. Because of our interface, this is the only place
    where we can modify the application states. At first sight, it can be perceived
    as a bottleneck and a poor separation of concerns. Now, the bottleneck part, in
    the sense that all happens there, is by design. The main idea behind Redux is
    that complex stateful JavaScript applications are hard to manage, because the
    states of the application can change in multiple ways. For example, an asynchronous
    call and a navigation event can both change the overall states of the application
    in subtle and hard-to-debug ways. Here, using the Redux functionalities, everything
    is managed in the same place. For the separation of concerns argument, which is
    very much valid, nothing prevents us from manipulating the state (for example,
    `return { logged: !lastState.logged };` in our case) in well-named, loosely coupled
    functions.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '目前，我们的`reducer`只管理两个操作：登录和注销。在接收到操作时，我们使用switch语句检查操作类型，然后简单地反转已登录状态的值。由于我们的接口，这是我们唯一可以修改应用程序状态的地方。乍一看，这可能被视为一个瓶颈和关注点分离不足。现在，瓶颈部分，也就是所有事情都发生在那里，是有意设计的。Redux背后的主要思想是，复杂的有状态JavaScript应用程序很难管理，因为应用程序的状态可以以多种方式改变。例如，异步调用和导航事件都可以以微妙且难以调试的方式改变应用程序的整体状态。在这里，使用Redux功能，一切都在同一个地方管理。至于关注点分离的论点，这是非常有效的，没有什么能阻止我们在良好命名的、松散耦合的函数中操作状态（例如，在我们的情况下`return
    { logged: !lastState.logged };`）。'
- en: 'Now that our store, Redux, and actions are implemented, we can start to manipulate
    them inside our component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的商店、Redux和操作已经实现，我们可以开始在我们的组件内操作它们：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A lot is happening here. Let''s break it down piece by piece. First, there''s
    the constructor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情。让我们一点一点地分解。首先是构造函数：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this constructor, we expect to receive an injection of `NgRedux<IAppState>`
    that manipulates our state and the `APIService` that is slightly modified from
    the previous section to accommodate our new pattern. Inside the constructor, we
    have the `ngRedux.select<boolean>('logged')` instruction, which allow us to access
    an observable of the logged variables from the `IAppState` interface. As you can
    see, by design, it's not possible to change the value of `logged` here, as you
    can only obtain an observable to it. Being an observable, we can subscribe to
    it and define a component when its value changes. In our case, we affect the value
    of the logged class member to the new value of the logged state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构造函数中，我们期望接收一个 `NgRedux<IAppState>` 的注入，它可以操作我们的状态，以及稍微修改过的 `APIService`，以适应我们的新模式。在构造函数内部，我们有
    `ngRedux.select<boolean>('logged')` 指令，它允许我们访问来自 `IAppState` 接口的 logged 变量的可观察对象。正如你所看到的，按设计，在这里无法更改
    `logged` 的值，因为你只能获取它的可观察对象。作为一个可观察对象，我们可以订阅它，并在其值发生变化时定义一个组件。在我们的情况下，我们将 logged
    类成员的值影响到 logged 状态的新值。
- en: 'Next comes the login and logout methods that serve as proxies to the `ApiService`
    calls:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是登录和注销方法，它们作为对 `ApiService` 调用的代理：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can see the implementation of the `ngOnDestroy` function made mandatory
    by implementing the `OnDestroy` interface. While not obligatory, the `ngOnDestroy`
    function unsubscribes from the logged observer, which will save us a few milliseconds
    if the logged state changes and the component does not exist anymore:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到 `ngOnDestroy` 函数的实现，这是通过实现 `OnDestroy` 接口而成为强制性的。虽然不是强制性的，`ngOnDestroy`
    函数会取消订阅 logged 观察者，这样如果 logged 状态发生变化并且组件不再存在，就会节省我们几毫秒：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s have a look at the HTML that''s linked to our component. It is fairly
    simple and only displays the value of the logged state and two buttons that, you''ve
    guessed it, allow us to log in and out of our application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下与我们的组件相关联的 HTML。它非常简单，只显示了 logged 状态的值和两个按钮，你猜对了，它们允许我们登录和退出我们的应用程序：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s what it looks like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是这样的：
- en: '![](assets/041bba5d-4211-471a-add8-a961cb2fb961.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/041bba5d-4211-471a-add8-a961cb2fb961.png)'
- en: 'The next item on the list is the modification of the `APIService` so that it
    uses our new patterns instead of the MVC:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个项目是修改 `APIService`，使其使用我们的新模式，而不是 MVC：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this version, we use the same technique except we do not return promises
    anymore. Indeed, in this version, we simply dispatch actions to our reducer with
    the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们使用相同的技术，只是不再返回 promises。实际上，在这个版本中，我们只是向我们的 reducer 分派动作，如下所示：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once again, the modification of the state is indirect; we simply dispatch an
    action that will be caught by the reducer rather than manipulate the state. In
    other words, it's safe and centralized to a single point.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，状态的修改是间接的；我们只是分派一个动作，这个动作将被 reducer 捕获，而不是直接操作状态。换句话说，这是安全的，并且集中在一个单一的点上。
- en: 'Finally, we need to adjust the main app module to reflect all our changes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调整主应用模块以反映所有我们的更改：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We first imported the `NgRedux` module and the `HttpModule`, which will be used
    in the application. Then, the constructor of the `AppModule` will receive an injected
    `NgRedux` instance and configure our Redux store. The store also receives a default
    state that we initialized earlier.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入了 `NgRedux` 模块和 `HttpModule`，它们将在应用程序中使用。然后，`AppModule` 的构造函数将接收一个注入的
    `NgRedux` 实例，并配置我们的 Redux 存储。存储还接收了我们之前初始化的默认状态。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we saw two patterns: Redux and MVC. Redux and the MVC can
    be used to achieve the same purposes (manage the states of our application in
    reaction to asynchronous events or user actions). Both patterns have advantages
    and shortcomings. The advantages of the MVC in the Angular application, from my
    point of view, is that everything is well defined and separated. Indeed, we have
    a domain object (`User`), a model (`UserModel`), and a view linked to a component.
    We saw that same model and domain object across many components and views in favor
    of reuse across apps. The problem is that it can get expensive to create new functionalities
    in our apps because you''ll have to create—or, at least, modify,—a good chunk
    of architecture.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看到了两种模式：Redux和MVC。Redux和MVC可以用来实现相同的目的（在异步事件或用户操作的反应中管理应用程序的状态）。这两种模式都有优点和缺点。在我的观点中，Angular应用程序中MVC的优点是一切都被很好地定义和分离。事实上，我们有一个领域对象（`User`），一个模型（`UserModel`），以及一个与组件相关联的视图。我们看到了相同的模型和领域对象在许多组件和视图中被重复使用。问题在于，在我们的应用程序中创建新功能可能会变得很昂贵，因为你将不得不创建或者至少修改大量的架构。
- en: Additionally, whether by mistake or by design, if you share models across several
    components and services, it can be extremely painful to identify and eradicate
    the source of a bug. The Redux pattern is more recent and, most of all, more adapted
    to the JavaScript ecosystem, as it has been created for it. It's relatively easy
    to add functionalities in terms of state in our applications and to manipulate
    them in a safe way. From experience, I can assure you that bugs that entire teams
    are mystified by for days are much less frequent when using the Redux patterns.
    However, the separation of concerns within the application is less clear and you
    can end up with a thousand lines of Redux in the most complex application. Sure,
    we can create several reducers in addition to the root one, separate our stores
    with big functionalities, and create helper functions to manipulate our states.
    As it's not imposed by the patterns, more often than not, I found myself reviewing
    enormous reducers that are costly to refactor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无论是出于错误还是设计，如果您在多个组件和服务之间共享模型，要识别和消除错误的来源可能会非常痛苦。Redux模式更加新颖，而且更适应JavaScript生态系统，因为它是为其创建的。在我们的应用程序中相对容易地添加状态功能，并以安全的方式操纵它们。根据经验，我可以向您保证，当使用Redux模式时，整个团队数天都被困惑的错误要少得多。然而，在应用程序内部的关注点分离不太明确，你可能最终会在最复杂的应用程序中得到一千行的Redux。当然，我们可以创建几个额外的reducer，将我们的存储与大功能分开，并创建辅助函数来操纵我们的状态。由于这些不是模式所强加的，我经常发现自己在审查昂贵的reducer时需要进行大量的重构。
- en: In the next chapter, we will investigate stability patterns for our Angular
    application, which will ensure that our applications continue to be usable when
    all odds are stacked against us.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究Angular应用程序的稳定性模式，这将确保我们的应用程序在面临一切困难时仍然可用。
