- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building a Weather Dashboard – Data Fetching and State Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建天气仪表板——数据获取和状态管理
- en: As we venture into [*Chapter 4*](B19760_04.xhtml#_idTextAnchor080) of our Nuxt
    3 exploration, we’re setting our sights on constructing a practical weather dashboard.
    Our journey starts with **Nuxt UI**, Nuxt’s official UI library, which simplifies
    the creation of stunning and responsive web applications. Nuxt UI offers a comprehensive
    collection of fully styled and customizable UI components, specifically designed
    for Nuxt. We’ll explore how to import Nuxt UI into our project and use its components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入 Nuxt 3 探索的 **第 4 章**，我们将目光投向构建一个实用的天气仪表板。我们的旅程从 **Nuxt UI** 开始，这是 Nuxt
    的官方 UI 库，它简化了令人惊叹且响应式网络应用程序的创建。Nuxt UI 提供了一个全面的、完全样式化和可定制的 UI 组件集合，专门为 Nuxt 设计。我们将探讨如何将
    Nuxt UI 导入我们的项目并使用其组件。
- en: Next, we’ll discuss data fetching in general. This will lay the groundwork for
    understanding how to retrieve and handle data dynamically in a Nuxt application.
    Specifically, we’ll use the **OpenWeatherMap** API in our project, providing a
    real-world context for our data fetching practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论一般的数据获取。这将为我们理解如何在 Nuxt 应用程序中动态检索和处理数据打下基础。具体来说，我们将在项目中使用 **OpenWeatherMap**
    API，为我们的数据获取实践提供一个现实世界的背景。
- en: Following this, we’ll master `$fetch` for efficient data fetching. By fetching
    real weather data from the OpenWeatherMap API, you’ll learn how to display this
    information effectively and responsively.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将掌握 `$fetch` 以实现高效的数据获取。通过从 OpenWeatherMap API 获取真实天气数据，您将学习如何有效地和响应式地显示这些信息。
- en: Finally, we will guide you through state management using **Pinia**. This approach
    centralizes and manages the state of your application’s data, facilitating easy
    access and manipulation of weather data across different components without the
    complexities of prop drilling.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将指导您使用 **Pinia** 进行状态管理。这种方法集中管理应用程序数据的状态，便于在不同组件之间轻松访问和操作天气数据，避免了属性钻取的复杂性。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up the weather dashboard application.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置天气仪表板应用程序。
- en: Integrating Nuxt UI in the weather dashboard
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在天气仪表板中集成 Nuxt UI
- en: Exploring data fetching with `$fetch` in Nuxt 3
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Nuxt 3 中使用 `$fetch` 进行数据获取
- en: Integrating with the Pinia store to monitor city and weather data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Pinia 存储与城市和天气数据集成
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter04](https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter04).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 [https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter04](https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter04)
    找到。
- en: The CiA video for this chapter can be found on [https://packt.link/1uNS1](https://packt.link/1uNS1)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在 [https://packt.link/1uNS1](https://packt.link/1uNS1) 找到
- en: Essential background – understanding Nuxt 3 Data Fetching and State Management
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的背景知识——理解 Nuxt 3 数据获取和状态管理
- en: 'Before diving into the practical application, let’s build a solid foundation
    in two key areas – data fetching with Nuxt UI and state management using Pinia:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实际应用之前，让我们在两个关键领域打下坚实的基础——使用 Nuxt UI 进行数据获取和利用 Pinia 进行状态管理：
- en: '`$fetch`, which simplifies the process of fetching and displaying data.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$fetch`，它简化了获取和显示数据的过程。'
- en: '**State management with Pinia**: Pinia is a state management library designed
    for Vue applications, offering a more intuitive and straightforward approach than
    its predecessor, Vuex. With Pinia, you can centralize and manage the application’s
    state, facilitating data sharing across components without prop drilling. Pinia
    also offers API-style composition. More details can be found on Pinia’s official
    websi[te at https://pinia.vuej](https://pinia.vuejs.org/)s.org/.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Pinia 进行状态管理**：Pinia 是一个为 Vue 应用程序设计的状态管理库，它比其前身 Vuex 提供了更直观和直接的方法。使用
    Pinia，您可以集中管理应用程序的状态，促进组件之间的数据共享，而无需进行属性钻取。Pinia 还提供了 API 风格的组合。更多详细信息可以在 Pinia
    的官方网站 [https://pinia.vuejs.org/](https://pinia.vuejs.org/) 上找到。'
- en: Now that we’ve covered those two areas, let’s start by setting up our weather
    dashboard application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了这两个领域，让我们开始设置我们的天气仪表板应用程序。
- en: 'First, let’s kick off by creating our new project named weather-sky:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们启动我们的新项目，命名为 weather-sky：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After initializing, navigate to the project directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，导航到项目目录：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we will incorporate `@nuxtjs/google-fonts` for our font needs. However,
    diverging from our usual path of adding Tailwind CSS, we’ll introduce Nuxt UI
    to our toolkit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的字体需求引入 `@nuxtjs/google-fonts`。然而，偏离我们通常的路径添加 Tailwind CSS，我们将 Nuxt
    UI 引入我们的工具箱。
- en: 'Let’s install these packages:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装这些包：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once installed, open `nuxt.config.ts` and add both `@nuxtjs/google-fonts` and
    `@nuxt/ui` to the `modules` array, integrating them into our project setup.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，打开 `nuxt.config.ts` 并将 `@nuxtjs/google-fonts` 和 `@nuxt/ui` 都添加到 `modules`
    数组中，将它们集成到我们的项目设置中。
- en: Before implementing Nuxt UI theming, we’ll create a `tailwind.config.ts` file
    and include our standard configurations. However, this time, we won’t define the
    colors in the Tailwind configuration. Instead, we’ll leverage Nuxt UI theming
    capabilities to set this color. We’ll learn how to do that in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 Nuxt UI 主题之前，我们将创建一个 `tailwind.config.ts` 文件并包含我们的标准配置。然而，这次，我们不会在 Tailwind
    配置中定义颜色。相反，我们将利用 Nuxt UI 主题功能来设置这个颜色。我们将在下一节中学习如何做到这一点。
- en: 'Here’s how the `tailwind.config.ts` might look without adding the colors option:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `tailwind.config.ts` 可能看起来没有添加颜色选项的情况：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, let’s integrate the Roboto font into our project. We do this by updating
    the `nuxt.config.ts` file, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将 Roboto 字体集成到我们的项目中。我们通过更新 `nuxt.config.ts` 文件来完成此操作，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s add a title in `app.vue` and see how it looks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `app.vue` 中添加一个标题，看看效果如何：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should be similar to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于这个：
- en: '![Figure 4.1: Weather Sky initial page](img/B19760_04_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：天气天空初始页面](img/B19760_04_01.jpg)'
- en: 'Figure 4.1: Weather Sky initial page'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：天气天空初始页面
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Nuxt UI uses the system’s default color scheme. As a result, you might notice
    that the color of your app appears dark instead of light if you do not specify
    a custom color. This behavior ensures that your app automatically aligns with
    the user’s preferred theme.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt UI 使用系统的默认颜色方案。因此，如果你没有指定自定义颜色，你可能会注意到你的应用程序颜色是暗的而不是亮的。这种行为确保了你的应用程序自动与用户的偏好主题保持一致。
- en: To verify the font, a handy Chrome extension called **WhatFont** can be used.
    WhatFont is an efficient tool for quickly identifying the fonts used on web pages.
    It’s a great aid for designers and developers to confirm font choices and styles.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证字体，可以使用一个方便的 Chrome 扩展程序，称为 **WhatFont**。WhatFont 是一个用于快速识别网页上使用的字体的有效工具。它是设计师和开发者确认字体选择和样式的绝佳助手。
- en: 'When using WhatFont on our website, if you click on the extension icon and
    select the title, it will display the font details. In our case, it should confirm
    the use of **Roboto** with a weight of **400**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当在网站上使用 WhatFont 时，如果你点击扩展图标并选择标题，它将显示字体详情。在我们的情况下，它应该确认使用 **Roboto** 字体，粗细为
    **400**：
- en: '![Figure 4.2: The WhatFont extension](img/B19760_04_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：WhatFont 扩展](img/B19760_04_02.jpg)'
- en: 'Figure 4.2: The WhatFont extension'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：WhatFont 扩展
- en: Now that we’ve set up our project, our next step is to integrate with Nuxt UI
    and make use of its features and components.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了项目，我们的下一步是集成 Nuxt UI 并利用其功能和组件。
- en: Integrating Nuxt UI in the weather dashboard
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在天气仪表板中集成 Nuxt UI
- en: 'Nuxt UI is an official UI library from Nuxt, designed to enhance the user interface
    experience in Nuxt applications. It offers a range of features, including fully
    styled and customizable components, support for dark mode, keyboard shortcuts,
    and support for both left-to-right and right-to-left languages. Built with Headless
    UI and Tailwind CSS, Nuxt UI provides a robust framework for creating intuitive
    and visually appealing user interfaces in Nuxt apps. You can read more about it
    on the official website: [https://ui.nuxt.com/](https://ui.nuxt.com/).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt UI 是 Nuxt 的官方 UI 库，旨在增强 Nuxt 应用程序的用户界面体验。它提供了一系列功能，包括完全样式化和可定制的组件、支持暗黑模式、键盘快捷键以及支持从左到右和从右到左的语言。Nuxt
    UI 使用 Headless UI 和 Tailwind CSS 构建，为在 Nuxt 应用程序中创建直观且视觉上吸引人的用户界面提供了一个强大的框架。你可以在官方网站上了解更多信息：[https://ui.nuxt.com/](https://ui.nuxt.com/)。
- en: 'Now, let’s go back to our project and start learning about Nuxt UI theming.
    We’ll utilize `app.config.ts` to define the primary color, integrating our design
    preferences within the Nuxt ecosystem. Here’s how we set it up:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的项目，开始学习 Nuxt UI 主题。我们将利用 `app.config.ts` 来定义主色，将我们的设计偏好整合到 Nuxt 生态系统内。以下是我们的设置方法：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `app.config.ts` file is a central UI configuration file, offering dynamic
    theming capabilities. This flexibility enables us to tailor our application’s
    theme and component styles on the fly. By setting theme colors and integrating
    with Tailwind CSS, we gain access to a broader color palette, enhancing our design
    options. Moreover, the `ui` property provides specific component customizations,
    allowing for a personalized and coherent user interface. As we progress, we will
    explore, in detail, how to use this file to customize our components’ design.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.config.ts`文件是一个中央UI配置文件，提供了动态主题功能。这种灵活性使我们能够动态调整应用程序的主题和组件样式。通过设置主题颜色并与Tailwind
    CSS集成，我们获得了更广泛的颜色调色板，增强了我们的设计选项。此外，`ui`属性提供了特定的组件定制，允许我们创建个性化的用户界面。随着我们的进展，我们将详细探讨如何使用此文件来定制组件的设计。'
- en: 'Let’s put our Nuxt UI integration to the test and start using some of its components
    in our `app.vue` file. The following code snippet shows how to create a basic
    layout with a weather card:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将Nuxt UI集成进行测试，并在我们的`app.vue`文件中开始使用其组件。以下代码片段显示了如何创建带有天气卡的简单布局：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this template, we use the `<u-container>` component from Nuxt UI, which provides
    a containerized space for our content. The `<u-card>` component within it is where
    we display our weather data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，我们使用了Nuxt UI的`<u-container>`组件，它为我们的内容提供了一个容器化空间。其中的`<u-card>`组件是我们展示天气数据的地方。
- en: 'Here’s the output of our updated Nuxt UI integration in the `app.vue` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`app.vue`文件中更新后的Nuxt UI集成的输出：
- en: '![Figure 4.3: Nuxt UI integration](img/B19760_04_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：Nuxt UI集成](img/B19760_04_03.jpg)'
- en: 'Figure 4.3: Nuxt UI integration'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：Nuxt UI集成
- en: Now, let’s consider enhancing our layout further. Suppose we want to add vertical
    spacing to the container. Typically, we could do this by adding the `py-6` class
    directly in our template. But what if we aim for a more streamlined approach,
    where this spacing becomes a default style for all containers in our application?
    This is where the power of component customization in Nuxt UI truly shines.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步增强我们的布局。假设我们想要为容器添加垂直间距。通常，我们可以通过直接在我们的模板中添加`py-6`类来完成此操作。但如果我们希望采取更简洁的方法，使这种间距成为我们应用程序中所有容器的默认样式，那么Nuxt
    UI组件定制的力量就真正显现出来了。
- en: 'Nuxt UI allows us to override and customize component styles globally via the
    `app.config.ts` file. By doing this, we ensure consistent styling across our application
    without repeatedly adding the same class in different components. Here’s how we
    can achieve this for our `container` component:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt UI允许我们通过`app.config.ts`文件全局覆盖和定制组件样式。通过这样做，我们确保了应用程序中的一致样式，而无需在多个组件中重复添加相同的类。以下是如何为我们`container`组件实现这一点的示例：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this configuration, we’ve added a padding `property` to the `container`
    configuration within the `ui` property, based on the configuration options available
    for the `u-container` component, which we can find detailed here: https://ui.nuxt.com/layout/container#config.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们根据`u-container`组件可用的配置选项，在`ui`属性内的`container`配置中添加了一个`padding`属性。这些详细信息可以在以下链接中找到：https://ui.nuxt.com/layout/container#config。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: After modifying the configuration, it may be necessary to restart your development
    server to apply and view the changes in your application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 修改配置后，可能需要重新启动开发服务器以应用并查看应用程序中的更改。
- en: Now, every time we use the `<u-container>` component in our application, it
    will automatically include this vertical padding, creating a consistent look and
    feel throughout the app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们在应用程序中使用`<u-container>`组件时，它将自动包含这个垂直填充，在整个应用程序中创建一致的外观和感觉。
- en: 'Let’s now customize the `u-card` component and remove the shadow. This is done
    via the `app.config.ts` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定制`u-card`组件并移除阴影。这是通过`app.config.ts`文件完成的：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this configuration, we’re setting the `base` property to `'overflow-visible
    mb-6'`. This adjusts the default layout of the card, allowing for visible overflow
    and adding a margin at the bottom. Additionally, we’re applying `'shadow-none'`
    to the `shadow` property, effectively removing the default shadow from all cards.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们将`base`属性设置为`'overflow-visible mb-6'`。这调整了卡片默认的布局，允许可见溢出并在底部添加边距。此外，我们还应用了`'shadow-none'`到`shadow`属性，从而有效地从所有卡片中移除了默认阴影。
- en: Next, we’ll explore data fetching with `$fetch` in Nuxt 3, diving into how to
    efficiently fetch and manage data in our applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索Nuxt 3中的数据获取`$fetch`，深入了解如何在我们的应用程序中高效地获取和管理数据。
- en: Exploring data fetching with $fetch in Nuxt 3
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Nuxt 3中使用$fetch探索数据获取
- en: 'In Nuxt 3, data fetching is a pivotal aspect that is managed using composables
    that work in both browser and server environments. Nuxt offers three primary tools
    for this purpose:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nuxt 3中，数据获取是一个关键方面，它使用在浏览器和服务器环境中工作的composables进行管理。Nuxt为此目的提供了三个主要工具：
- en: '`useFetch`: This is the most straightforward method for data fetching within
    a component’s setup function, typically used for retrieving essential data for
    the component’s initial state. But in our project, we’ll work with more complex
    methods: `useAsyncData` and `$fetch`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useFetch`：这是在组件的setup函数中进行数据获取的最直接方法，通常用于检索组件初始状态所需的基本数据。但在我们的项目中，我们将使用更复杂的方法：`useAsyncData`和$fetch。'
- en: '`useAsyncData`: This is like `useFetch` but includes additional logic for more
    complex data fetching scenarios.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAsyncData`：这类似于`useFetch`，但包括更复杂数据获取场景的附加逻辑。'
- en: '`$fetch`: This is a part of the `ofetch` library and is a versatile fetch API
    that works across Node.js, browsers, and workers. It features smart JSON parsing,
    automatic stringification for JSON bodies, user-friendly error handling, auto
    retry capabilities, and configurable timeouts. This makes `$fetch` a robust tool
    for efficient, reliable network requests in various environments. You can read
    more about it at https://github.com/unjs/ofetch.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$fetch`：这是`ofetch`库的一部分，是一个跨Node.js、浏览器和workers工作的通用fetch API。它具有智能JSON解析、自动JSON体字符串化、用户友好的错误处理、自动重试功能和可配置的超时。这使得$fetch成为在各种环境中进行高效、可靠网络请求的强大工具。您可以在https://github.com/unjs/ofetch上了解更多信息。'
- en: Now, let’s progress with the next steps in our Nuxt 3 project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行Nuxt 3项目的下一步。
- en: Creating an account on OpenWeatherMap
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在OpenWeatherMap上创建账户
- en: '**OpenWeatherMap** offers a comprehensive suite of weather APIs, providing
    real-time data for our weather dashboard.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenWeatherMap**提供了一套全面的天气API，为我们提供天气仪表板的实时数据。'
- en: 'Before we can fetch weather data, it’s essential to have access to OpenWeatherMap’s
    APIs. Begin by creating an account on OpenWeatherMap. Go to their sign-up page:
    [https://openweathermap.org/register](https://openweathermap.org/register), provide
    the required details, and create your account. Once your account is set up, go
    to the dropdown menu under your username and navigate to the **My API keys** page,
    then generate a new key. Remember to copy this key, as it will be crucial for
    accessing the APIs.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够获取天气数据之前，获取OpenWeatherMap的API访问权限是至关重要的。首先，在OpenWeatherMap上创建一个账户。访问他们的注册页面：[https://openweathermap.org/register](https://openweathermap.org/register)，提供所需详细信息，并创建您的账户。一旦您的账户设置完成，转到用户名下的下拉菜单，导航到**我的API密钥**页面，然后生成一个新的密钥。请记住复制此密钥，因为它对于访问API至关重要。
- en: 'We’ll focus on two APIs from OpenWeatherMap:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注OpenWeatherMap的两个API：
- en: '**Geocoding API**: This API enables location searches, allowing users to find
    specific cities or regions. You can find the full documentation here: [https://openweathermap.org/api/geocoding-api](https://openweathermap.org/api/geocoding-api).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地理编码API**：此API允许位置搜索，使用户能够找到特定的城市或地区。您可以在[https://openweathermap.org/api/geocoding-api](https://openweathermap.org/api/geocoding-api)找到完整的文档。'
- en: '**One Call API**: This provides detailed weather information for the searched
    location, offering current weather information, data forecasts, and more. For
    more info, visit [https://openweathermap.org/api/one-call-3](https://openweathermap.org/api/one-call-3).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性调用API**：它为搜索位置提供详细的天气信息，包括当前天气信息、数据预报等。更多信息请访问[https://openweathermap.org/api/one-call-3](https://openweathermap.org/api/one-call-3)。'
- en: Testing the API
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试API
- en: To utilize the Geocoding API from OpenWeatherMap, we’ll implement a test scenario
    using `$fetch` in our Nuxt application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用OpenWeatherMap的地理编码API，我们将在Nuxt应用程序中实现一个使用$fetch的测试场景。
- en: 'In `app.vue`, create a script, then define a function that will use `$fetch`
    to call the Geocoding API:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.vue`中创建一个脚本，然后定义一个函数，该函数将使用$fetch调用地理编码API：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the breakdown of the function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是函数的分解：
- en: This function performs a lookup for cities using the OpenWeatherMap Geocoding
    API
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数使用OpenWeatherMap地理编码API进行城市查找
- en: The `query` parameter is used to search for the name of the city or a part of
    it
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query`参数用于搜索城市名称或其部分'
- en: The `limit=5` parameter in the URL limits the number of results to five
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL中的`limit=5`参数将结果数量限制为五个
- en: Don’t forget to replace `apiKey` with your actual key.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`apiKey`替换为您的实际密钥。
- en: 'Then, invoke this function with a sample location query to test the API:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用一个示例位置查询调用此函数以测试API：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see a similar output to this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出：
- en: '![Figure 4.4: Geocoding API response](img/B19760_04_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：地理编码API响应](img/B19760_04_04.jpg)'
- en: 'Figure 4.4: Geocoding API response'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：地理编码API响应
- en: With the successful testing of the API, let’s define types for the responses
    from OpenWeatherMap.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功测试了API之后，让我们定义来自OpenWeatherMap的响应类型。
- en: Defining global types
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义全局类型
- en: Having previously discussed TypeScript types, we will now focus on defining
    them for the responses from OpenWeatherMap APIs. Anticipating the structure of
    the data we’ll receive from the API is crucial for type-safe development.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论了TypeScript类型之后，我们现在将专注于为来自OpenWeatherMap API的响应定义它们。预测我们将从API收到的数据结构对于类型安全开发至关重要。
- en: 'Inspecting the console output reveals that the `city` object contains specific
    fields. To handle this data effectively, we create an `index.ts` file in a `types`
    folder with the following type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 检查控制台输出可以发现，`city` 对象包含特定的字段。为了有效地处理这些数据，我们在 `types` 文件夹中创建了一个 `index.ts` 文件，并定义了以下类型：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we learned in the previous chapter, by exporting an empty object and declaring
    a global object that contains the `CityData` type, we’ve made these types globally
    available in our application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，通过导出一个空对象并声明一个包含 `CityData` 类型的全局对象，我们已经使这些类型在我们的应用程序中全局可用。
- en: Now, let’s enhance our application’s configuration strategy and find a way to
    save our API key.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们增强我们的应用程序配置策略，并找到一种保存我们的API密钥的方法。
- en: Utilizing useRuntimeConfig to expose configuration within the application
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 useRuntimeConfig 在应用程序中公开配置
- en: '`useRuntimeConfig` is a composable in Nuxt 3 designed for accessing runtime
    configurations. This feature enables the global and centralized management of
    configuration values, such as API keys, across your application.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRuntimeConfig` 是Nuxt 3中的一个可组合函数，用于访问运行时配置。这个特性使得配置值，如API密钥，可以在整个应用程序中进行全局和集中管理。'
- en: Runtime configurations are stored in `nuxt.config.ts` using the `runtimeConfig`
    attribute. You can define a secret key, which will be accessible only on the server,
    or public keys. In our case, we’ll define the API key as a public key to be accessible
    on the client side, too.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时配置存储在 `nuxt.config.ts` 中，使用 `runtimeConfig` 属性。你可以定义一个密钥，它只能在服务器上访问，或者公开密钥。在我们的例子中，我们将API密钥定义为公开密钥，以便在客户端也能访问。
- en: 'Update `nuxt.config.ts` by adding the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下内容来更新 `nuxt.config.ts`：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we’ll update the `citiesLookup` method to retrieve the API key via `useRuntimeConfig`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将更新 `citiesLookup` 方法，通过 `useRuntimeConfig` 来检索API密钥：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After updating, we’ll retest to ensure that the function remains effective with
    the new configuration setup. It should yield the same result. If you encounter
    a `401` error, it indicates an incorrect or invalid API key. In this case, debug
    the runtime configuration to verify that the key is displayed correctly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后，我们将重新测试以确保新配置设置下的函数仍然有效。它应该产生相同的结果。如果你遇到 `401` 错误，这表明API密钥不正确或无效。在这种情况下，调试运行时配置以验证密钥是否正确显示。
- en: Next, we’ll enhance our dashboard with a dynamic city search feature using Nuxt
    UI’s `SelectMenu` component.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Nuxt UI的 `SelectMenu` 组件增强我们的仪表板，添加动态城市搜索功能。
- en: Creating the CitiesLookup component
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建CitiesLookup组件
- en: 'We’ll build the `CitiesLookup` component, a key feature of our weather dashboard.
    Utilizing Nuxt UI’s `SelectMenu` component will enable users to dynamically search
    for cities. The integration of asynchronous search capabilities will create a
    seamless and intuitive user experience. First, let’s create the `CitiesLookup`
    component inside the `components` folder. Then, add the following template:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建 `CitiesLookup` 组件，这是我们的天气仪表板的一个关键特性。利用Nuxt UI的 `SelectMenu` 组件将使用户能够动态搜索城市。异步搜索功能的集成将创造一个无缝且直观的用户体验。首先，让我们在
    `components` 文件夹内创建 `CitiesLookup` 组件。然后，添加以下模板：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This part sets up the UI for city searching. `USelectMenu` is bound to `activeCity`
    for capturing the user’s selection. The `:searchable` attribute is linked to the
    `citiesLookup` function, which we will see in the `script` section:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分设置了城市搜索的UI。`USelectMenu` 绑定到 `activeCity` 以捕获用户的选择。`:searchable` 属性链接到 `citiesLookup`
    函数，我们将在 `script` 部分看到：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s the breakdown:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是分解过程：
- en: We started by employing `useRuntimeConfig` to access the API key.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先使用 `useRuntimeConfig` 来访问API密钥。
- en: We also defined `activeCity` to store and react to the user’s selection from
    the drop-down menu.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还定义了 `activeCity` 来存储和响应用户从下拉菜单中的选择。
- en: The `citiesLookup` function, which we initially tested in the previous section,
    is now adapted to fetch city data and format it for the `USelectMenu` component.
    First, we skip the fetch if the query is empty. The response from the Geocoding
    API is mapped to include a label for each city, combining the city name and country.
    This labeling is crucial for the `USelectMenu` component to display the options
    correctly.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在上一节中最初测试的`citiesLookup`函数现在被调整为获取城市数据并将其格式化为`USelectMenu`组件。首先，如果查询为空，则跳过获取。Geocoding
    API的响应被映射以包含每个城市的标签，结合城市名称和国家。这种标签对于`USelectMenu`组件正确显示选项至关重要。
- en: The `:searchable` prop on `USelectMenu` takes our `citiesLookup` function. This
    setup creates a dynamic, asynchronous search feature where the drop-down menu
    options update in real time based on the user’s input.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USelectMenu`上的`:searchable`属性接受我们的`citiesLookup`函数。这种设置创建了一个动态的、异步的搜索功能，其中下拉菜单选项根据用户的输入实时更新。'
- en: The `CityData` type is recognized directly without importing it, thanks to our
    global declaration approach.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CityData`类型可以直接识别，无需导入，这得益于我们的全局声明方法。'
- en: 'Now that we have our `CitiesLookup` component ready, let’s integrate it into
    the main application view. Here’s how we can incorporate it into `app.vue`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`CitiesLookup`组件，让我们将其集成到主应用视图中。以下是我们在`app.vue`中如何将其整合的方法：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the `CitiesLookup` component in place, users can now search for a city
    such as `London`. The following screenshot illustrates performing such a search:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CitiesLookup`组件到位后，用户现在可以搜索像`伦敦`这样的城市。以下截图展示了执行此类搜索的过程：
- en: '![Figure 4.5: CityLookup component](img/B19760_04_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：CityLookup组件](img/B19760_04_05.jpg)'
- en: 'Figure 4.5: CityLookup component'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：CityLookup组件
- en: Next, we will focus on displaying the weather data for the selected city. This
    will involve fetching the weather data from the OpenWeatherMap API and presenting
    it in a user-friendly format on our dashboard.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于显示所选城市的天气数据。这将涉及从OpenWeatherMap API获取天气数据，并以用户友好的格式在我们的仪表板上展示。
- en: 'To keep our application reactive, we need a mechanism to detect when a user
    selects a different city. This can be achieved by adding an event listener. `@update:modelValue`
    emits a `change` event whenever the `activeCity` value is updated. In `CitiesLookup`,
    update the template:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的应用程序响应式，我们需要一种机制来检测用户选择不同的城市。这可以通过添加事件监听器来实现。`@update:modelValue`在`activeCity`值更新时发出`change`事件。在`CitiesLookup`中更新模板：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This emit will dispatch the newly selected city, contained within the `$event`
    parameter, to the parent component. In the `<script>` section, we declare the
    event emitter like so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个发出的事件会将新选定的城市（包含在`$event`参数中）派发到父组件。在`<script>`部分，我们声明事件发射器如下：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `app.vue`, we’re set to catch the city selection updates. We listen for
    the `change` event emitted by our `CitiesLookup` component:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.vue`中，我们准备捕获城市选择更新。我们监听由我们的`CitiesLookup`组件发出的`change`事件：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Within the `<script>` section, we define the `onCityChanged` function, which
    will handle the event:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<script>`部分，我们定义了`onCityChanged`函数，该函数将处理事件：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Selecting **London** from the search results now logs the city details to the
    console, as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从搜索结果中选择**伦敦**现在会将城市详细信息记录到控制台，如下面的截图所示：
- en: '![Figure 4.6: Listening to CitiesLookup change](img/B19760_04_06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：监听CitiesLookup变化](img/B19760_04_06.jpg)'
- en: 'Figure 4.6: Listening to CitiesLookup change'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：监听CitiesLookup变化
- en: With this in place, we’re prepared to fetch and display the weather data using
    OpenWeatherMap’s One Call API for the chosen city.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们准备使用OpenWeatherMap的One Call API获取并显示所选城市的天气数据。
- en: Fetching the weather data
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取天气数据
- en: 'With the city selected, the next step is to retrieve the weather details. Using
    the latitude and longitude from the selected city’s data, we will call the One
    Call API from OpenWeatherMap. For more information, visit the One Call API documentation
    link: [https://openweathermap.org/api/one-call-3](https://openweathermap.org/api/one-call-3).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择城市后，下一步是检索天气详情。使用所选城市数据的纬度和经度，我们将从OpenWeatherMap调用One Call API。更多信息，请访问One
    Call API文档链接：[https://openweathermap.org/api/one-call-3](https://openweathermap.org/api/one-call-3)。
- en: 'Here is `app.vue` after implementing the `onCityChanged` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`onCityChanged`函数后，这是`app.vue`的代码：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s break the code down:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: '`weatherData` is a reactive `ref` that will hold the fetched weather information'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weatherData`是一个响应式的`ref`，它将保存获取的天气信息'
- en: '`loading` is a flag indicating whether the data fetching is in progress'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`是一个标志，表示数据获取是否正在进行'
- en: '`onCityChanged` is an async function triggered when a new city is selected'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCityChanged`是一个异步函数，当选择一个新的城市时被触发'
- en: The API request is made with the selected city’s latitude and longitude
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API请求使用所选城市的纬度和经度进行
- en: On success, `weatherData` is populated with the weather response; if there’s
    an error, it’s logged to the console
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时，`weatherData`会被填充上天气响应；如果有错误，它会被记录到控制台
- en: We print the result to the console to inspect it
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将其打印到控制台以检查它
- en: 'Now, in the application, by searching for `London` and selecting the first
    result, we observe the following output in the console:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在应用程序中，通过搜索`London`并选择第一个结果，我们在控制台中观察到以下输出：
- en: '![Figure 4.7: One Call API response](img/B19760_04_07.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：One Call API响应](img/B19760_04_07.jpg)'
- en: 'Figure 4.7: One Call API response'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：One Call API响应
- en: 'The response will contain three types of weather data:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将包含三种类型的天气数据：
- en: '**Current weather**: Immediate weather conditions'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前天气**：即时天气状况'
- en: '**Hourly forecast**: Weather predictions broken down by hour'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小时预报**：按小时分解的天气预测'
- en: '**Daily forecast**: Comprehensive weather outlook for the next 7 days'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每日预报**：未来7天的全面天气展望'
- en: You can find the full details about the response in the API documentation. After
    examining the One Call API response from OpenWeatherMap, I have crafted specific
    types to represent the structure of the weather data – `WeatherDataResponse`,
    `HourlyWeather`, `DailyWeather`, and `Weather` – and added them to the `types/index.ts`
    file. They can be found in the project repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在API文档中找到关于响应的完整详情。在检查了OpenWeatherMap的One Call API响应后，我已创建了特定的类型来表示天气数据结构——`WeatherDataResponse`、`HourlyWeather`、`DailyWeather`和`Weather`——并将它们添加到`types/index.ts`文件中。它们可以在项目仓库中找到。
- en: Each type reflects the various aspects of weather data, such as current conditions,
    hourly forecasts, and daily predictions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型都反映了天气数据的各个方面，如当前状况、小时预报和每日预测。
- en: This data, while accessible in the parent and child components, hints at increasing
    complexity as our application grows. To streamline state management and data flow,
    we turn to Pinia. This state management library offers a centralized store for
    our application’s reactive state, allowing for more organized and maintainable
    data handling. In the following section, we’ll delve into how Pinia can enhance
    our application’s architecture, then we’ll create components to display the weather
    data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些数据可以在父组件和子组件中访问，但随着我们应用程序的增长，这暗示着复杂性的增加。为了简化状态管理和数据流，我们转向Pinia。这个状态管理库为我们应用程序的响应式状态提供了一个集中的存储库，允许更组织化和可维护的数据处理。在下一节中，我们将深入了解Pinia如何增强我们的应用程序架构，然后我们将创建组件来显示天气数据。
- en: Integrating with the Pinia store to monitor city and weather data
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Pinia存储库集成以监控城市和天气数据
- en: 'As we’ve seen, managing data across components can get complex. To simplify
    this, we introduce Pinia: Vue’s state management solution that allows for a centralized
    and reactive state. For a deep dive into Pinia and its features, visit the official
    Pinia documentation: [https://pinia.vuejs.org/](https://pinia.vuejs.org/).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，跨组件管理数据可能会变得复杂。为了简化这一点，我们引入了Pinia：Vue的状态管理解决方案，它允许集中和响应式状态。要深入了解Pinia及其功能，请访问官方Pinia文档：[https://pinia.vuejs.org/](https://pinia.vuejs.org/)。
- en: Now, let’s apply our knowledge and create our first store with Pinia to manage
    city and weather data efficiently. This practice will improve data handling in
    our application, making it more efficient and maintainable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用我们的知识，并使用Pinia创建我们的第一个存储库来高效地管理城市和天气数据。这种做法将提高我们应用程序的数据处理效率，使其更加高效和可维护。
- en: Installing Pinia and creating the first store
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Pinia并创建第一个存储库
- en: 'First, install Pinia by running the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令安装Pinia：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, update `nuxt.config.ts` and Include Pinia in the `modules` array to ensure
    that it’s loaded into your Nuxt application:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新`nuxt.config.ts`并在`modules`数组中包含Pinia以确保它被加载到你的Nuxt应用程序中：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, create a new directory in the root folder of the project, call it `stores`,
    and add a `weather.ts` file in which we’ll define the store. Within the file,
    add the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在项目的根目录中创建一个新的目录，命名为`stores`，并在其中添加一个`weather.ts`文件，我们将在此文件中定义存储库。在文件中，添加以下代码：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Pinia offers two ways to define a store:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Pinia提供了两种定义存储库的方式：
- en: '**Options stores**: An object-based declaration, providing a familiar API for
    those used to Vue’s Options API'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项存储**：基于对象的声明，为熟悉 Vue 的选项 API 的用户提供了一个熟悉的 API'
- en: '**Setup stores**: Utilizes Vue’s Composition API, allowing for a more composable
    and reactive approach'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置存储**：利用 Vue 的组合 API，允许更可组合和反应的方法'
- en: For our weather application, we’ve chosen the setup store method, leveraging
    the Composition API’s full potential for a more flexible state management experience.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的天气应用程序，我们选择了设置存储方法，利用组合 API 的全部潜力，以获得更灵活的状态管理体验。
- en: Integrating Reactive States and Functions in Pinia Store
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Pinia 存储中集成反应状态和函数
- en: 'In our `weather.ts` store, we first establish reactive references – `activeCity`
    and `weatherData` – akin to how we would in the Composition API. These references
    will hold the currently selected city and weather information, respectively:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `weather.ts` 存储中，我们首先建立反应引用——`activeCity` 和 `weatherData`——类似于我们在组合 API
    中所做的那样。这些引用将分别持有当前选定的城市和天气信息：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we migrate the `citiesLookup` function from the `CitiesLookup` component
    to our store, ensuring that it retrieves the API key from the runtime configuration.
    This function fetches and formats city data for `SelectMenu`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `citiesLookup` 函数从 `CitiesLookup` 组件迁移到我们的存储中，确保它从运行时配置中检索 API 密钥。此函数获取并格式化城市数据以供
    `SelectMenu` 使用：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, we introduce `getWeatherData`, a function to fetch weather details
    based on the selected city (as we did in the `app.vue` file):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们引入了 `getWeatherData` 函数，该函数根据选定的城市获取天气详情（正如我们在 `app.vue` 文件中所做的那样）：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the final step, we make sure to return all these references and functions
    from the store, making them accessible throughout the application:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们确保从存储中返回所有这些引用和函数，使它们在整个应用程序中可访问：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the complete setup of our `weather.ts` store:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `weather.ts` 存储的完整设置：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Refactoring components for Pinia store integration
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Pinia 存储集成重构组件
- en: 'In our `CitiesLookup` component, thanks to `@nuxt/pinia`, all stores located
    in the `/stores` directory are automatically imported throughout the app. This
    eliminates the need for manual imports. By calling `useWeatherStore`, we gain
    access to the store defined in the Pinia store directly:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `CitiesLookup` 组件中，多亏了 `@nuxt/pinia`，所有位于 `/stores` 目录中的存储在应用程序中都是自动导入的。这消除了手动导入的需求。通过调用
    `useWeatherStore`，我们可以直接访问 Pinia 存储中定义的存储：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then replace the local `citiesLookup` function with the one from the store:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用存储中的函数替换本地的 `citiesLookup` 函数：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When integrating our components with the Pinia store, a key consideration is
    maintaining reactivity when using store properties. Directly destructuring properties
    from the store, as in the following code, can lead to a loss of reactivity:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当将我们的组件与 Pinia 存储集成时，一个关键考虑因素是使用存储属性时保持反应性。直接从存储中解构属性，如以下代码所示，可能导致反应性丢失：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is where `storeToRefs` from Pinia becomes crucial. `storeToRefs` is a
    method that ensures reactivity is preserved when we extract properties from a
    store. By using the following code, we can destructure properties such as `activeCity`
    while maintaining their reactive nature, as demonstrated in the updated `CitiesLookup`
    component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Pinia 的 `storeToRefs` 变得至关重要的地方。`storeToRefs` 是一种确保当我们从存储中提取属性时，反应性得以保留的方法。通过使用以下代码，我们可以解构如
    `activeCity` 这样的属性，同时保持它们的反应性，正如在更新的 `CitiesLookup` 组件中所展示的：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you use `@pinia/nuxt` version `0.5.1` or later, `storeToRefs` is automatically
    imported. There’s no need to import it manually into your components.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `@pinia/nuxt` 版本 `0.5.1` 或更高版本时，`storeToRefs` 会自动导入。无需手动将其导入到你的组件中。
- en: 'Here is the final version of `CitiesLookup.vue`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `CitiesLookup.vue` 的最终版本：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Refactoring `app.vue` to utilize our Pinia store involves updating the `onCityChanged`
    function. Here’s how the script now looks:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `app.vue` 代码重构以利用我们的 Pinia 存储，需要更新 `onCityChanged` 函数。以下是脚本现在的样子：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this refactored version, `activeCity` no longer needs to be passed as a parameter.
    Instead, we obtain a reactive reference to `activeCity` from the weather store
    using `storeToRefs`. Additionally, the weather data fetching is now handled directly
    by the `getWeatherData` method in the weather store, streamlining the component
    and centralizing the logic in the store. This approach simplifies `app.vue`, keeping
    it clean and focused on the UI logic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构版本中，`activeCity` 不再需要作为参数传递。相反，我们使用 `storeToRefs` 从天气存储中获取对 `activeCity`
    的响应式引用。此外，天气数据获取现在由天气存储中的 `getWeatherData` 方法直接处理，简化了组件并将逻辑集中在存储中。这种方法简化了 `app.vue`，使其保持清洁并专注于
    UI 逻辑。
- en: Now that we’ve refactored our components to use the Pinia store, it’s time to
    test the application and ensure that everything functions seamlessly. Once we
    confirm the smooth operation of these updates, we’ll move on to our next challenge.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将组件重构为使用 Pinia 存储，是时候测试应用程序并确保一切运行顺畅了。一旦我们确认这些更新的运行顺利，我们将继续面对下一个挑战。
- en: Implementing weather data widget components
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现天气数据小部件组件
- en: Having ensured that our application functions smoothly with the integrated Pinia
    store, we now turn our attention to developing the weather data display. As part
    of this process, we will be using `dayjs`, as we did in the previous chapter,
    to handle date and time formatting within our components.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保我们的应用程序与集成的 Pinia 存储运行顺畅后，我们现在将注意力转向开发天气数据显示。作为此过程的一部分，我们将使用 `dayjs`，就像我们在上一章中做的那样，来处理组件内的日期和时间格式。
- en: 'We begin by installing `dayjs`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装 `dayjs`：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then, let’s create `EmptyPlaceholder.vue`, a component that provides a friendly
    message when no weather data is available. This placeholder will be displayed
    if there’s no active city selected or while the weather data is loading.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `EmptyPlaceholder.vue`，这是一个在无天气数据时提供友好信息的组件。如果没有选择活动城市或天气数据正在加载时，将显示此占位符。
- en: 'Here’s the component’s template:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是组件的模板：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This component is then integrated into `app.vue`, specifically under the `u-card`
    section, ensuring that it’s only visible when there’s no weather data or during
    loading:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将该组件集成到 `app.vue` 中，特别是在 `u-card` 部分，确保仅在无天气数据或正在加载时可见：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To enhance the user experience during data loading, we’ll implement a `loading`
    skeleton card. This feature provides a visual cue that content is being loaded.
    Here’s the updated `app.vue` template:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在数据加载期间增强用户体验，我们将实现一个 `loading` 骨架卡片。此功能提供了一个视觉提示，表明内容正在加载。以下是更新后的 `app.vue`
    模板：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The added code creates a pulsing effect on two `div` elements, simulating the
    space where the weather data cards will appear once the data is loaded. `v-if="loading"`
    ensures that this skeleton is only visible during the loading phase.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的代码在两个 `div` 元素上创建了一个脉冲效果，模拟数据加载后天气数据卡片将出现的位置。`v-if="loading"` 确保此骨架仅在加载阶段可见。
- en: 'Moving forward, we’ll develop a comprehensive display of weather data in `app.vue`.
    This includes the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `app.vue` 中开发一个全面的天气数据显示。这包括以下内容：
- en: '**Current weather**: The current weather conditions, including temperature,
    weather description, and relevant icons.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前天气**：包括温度、天气描述和相关图标当前天气状况。'
- en: '**Hourly forecast**: A scrollable view of the hourly weather forecast. Each
    card in this section will detail the weather conditions for a specific hour.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每小时预报**：一个可滚动的每小时天气预报视图。本节中的每一张卡片都将详细说明特定小时的天气状况。'
- en: '**7-day forecast**: A grid layout presenting the 7-day weather forecast.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7天预报**：一个网格布局，展示7天的天气预报。'
- en: 'Let’s begin with the `CurrentWeatherData.vue` component:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `CurrentWeatherData.vue` 组件开始：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is a breakdown:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是分解：
- en: The `template` section displays the current temperature in a large, bold font.
    It also shows a description of the current weather, as well as an image of the
    weather icon, sourced from OpenWeatherMap, corresponding to the current weather
    condition.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template` 部分以大号粗体字体显示当前温度。它还显示了当前天气的描述，以及来自 OpenWeatherMap 的天气图标图片，对应于当前的天气状况。'
- en: The `script` section accesses the reactive version of `weatherData` from the
    weather store using `storeToRefs`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script` 部分使用 `storeToRefs` 从天气存储中访问 `weatherData` 的响应式版本。'
- en: 'Now, let’s proceed to `HourlyWeatherCard.vue`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到 `HourlyWeatherCard.vue`：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This component is structured as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的结构如下：
- en: It displays hourly forecasts in a `flex` container
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在一个 `flex` 容器中显示每小时预报
- en: It uses `dayjs` to convert and format the Unix timestamp, `(hour.dt)`, into
    a readable time format, `(HH:mm)`
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 `dayjs` 将 Unix 时间戳 `(hour.dt)` 转换和格式化为可读的时间格式 `(HH:mm)`
- en: It includes weather information such as an image and description for the specific
    hour
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括天气信息，如特定小时的图片和描述
- en: It utilizes `defineProps` to ensure that the component receives the correct
    `HourlyWeather` data type
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 `defineProps` 来确保组件接收正确的 `HourlyWeather` 数据类型
- en: This means that we need to loop over the hour data array in `app.vue` and call
    this component for each data item.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要在 `app.vue` 中遍历小时数据数组，并为每个数据项调用此组件。
- en: 'Next, let’s look at `ForecastCard.vue`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `ForecastCard.vue`：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Like `HourlyWeatherCard`, this component will be used in `app.vue`, looping
    over each item in the daily weather data array to dynamically present each day’s
    forecast.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `HourlyWeatherCard` 类似，此组件将在 `app.vue` 中使用，遍历每日天气数据数组中的每个项，以动态展示每天的预报。
- en: 'With all components created, let’s add them to `app.vue`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建所有组件后，让我们将它们添加到 `app.vue`：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is the breakdown:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是分解：
- en: '`u-card` displays the selected city’s name and country'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-card` 显示所选城市的名称和国家'
- en: The `current-weather-data` component shows the current weather conditions
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather-data` 组件显示了当前的天气状况'
- en: A horizontal slider, containing `hourly-weather-card` components, presents the
    hourly forecast
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 `hourly-weather-card` 组件的水平滑块展示了小时预报
- en: The 7-day forecast is laid out in a grid, with each `forecast-card` component
    representing a day’s weather
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 天预报以网格形式排列，每个 `forecast-card` 组件代表一天的天气
- en: 'Now, it’s time to test the application to ensure that all components are functioning
    as expected. Check the following scenarios:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候测试应用程序以确保所有组件按预期工作。检查以下场景：
- en: '**No active city**: Verify the display when no city is selected:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无活动城市**：验证未选择城市时的显示：'
- en: '![Figure 4.8: No active city](img/B19760_04_08.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8：无活动城市](img/B19760_04_08.jpg)'
- en: 'Figure 4.8: No active city'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：无活动城市
- en: '**Loading state**: Observe the loading skeleton when data is being fetched:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载状态**：观察数据获取时的加载骨架：'
- en: '![Figure 4.9: Loading state](img/B19760_04_09.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9：加载状态](img/B19760_04_09.jpg)'
- en: 'Figure 4.9: Loading state'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：加载状态
- en: '**Data display**: Ensure that all weather data is correctly displayed when
    a city is selected:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据显示**：确保选择城市时所有天气数据都正确显示：'
- en: '![Figure 4.10: Data display](img/B19760_04_10.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：数据显示](img/B19760_04_10.jpg)'
- en: 'Figure 4.10: Data display'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：数据显示
- en: With all the pieces now in place, our weather dashboard in `app.vue` stands
    as a testament to our combined efforts and technical prowess. Congratulations
    on reaching this significant milestone!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有部件都已就位，我们 `app.vue` 中的天气仪表板就是对我们共同努力和技术实力的证明。恭喜您达到这个重要的里程碑！
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the construction of a weather dashboard using Nuxt
    3, starting with the sleek and user-friendly Nuxt UI. Our journey included practical
    data fetching with the OpenWeatherMap API and efficient use of `$fetch` for dynamic
    data presentation. The chapter culminated with the integration of Pinia for centralized
    state management, making the handling of weather data across components simpler
    and more efficient. This chapter was designed to enhance your skills in building
    advanced, real-world applications with Nuxt 3.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Nuxt 3 构建天气仪表板的过程，从简洁且用户友好的 Nuxt UI 开始。我们的旅程包括使用 OpenWeatherMap
    API 进行实际的数据获取和利用 `$fetch` 进行动态数据展示的高效使用。本章以集成 Pinia 进行集中式状态管理结束，这使得跨组件处理天气数据变得更加简单和高效。本章旨在提高您使用
    Nuxt 3 构建高级、真实世界应用的能力。
- en: 'As we proceed to [*Chapter 5*](B19760_05.xhtml#_idTextAnchor101), we shift
    gears to a new challenge: constructing a community forum website with Nuxt 3\.
    This chapter will guide you through the intricacies of user registration, login,
    and post creation. We’ll dive into implementing robust authentication to secure
    the website, ensuring that features such as post creation are exclusive to registered
    users. You’ll learn practical skills such as form validation, exploring authentication
    strategies, and managing access tokens with cookies. Additionally, we’ll delve
    into configuring middleware for protected routes, cementing your understanding
    of web application security and user management in Nuxt 3.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入 [*第五章*](B19760_05.xhtml#_idTextAnchor101) 时，我们将注意力转向新的挑战：使用 Nuxt 3 构建一个社区论坛网站。本章将指导你了解用户注册、登录和发帖创建的复杂性。我们将深入实施强大的身份验证来保护网站，确保发帖等特性仅限于注册用户。你将学习到实际技能，如表单验证、探索身份验证策略以及使用
    cookies 管理访问令牌。此外，我们还将深入了解配置受保护路由的中介件，巩固你对 Nuxt 3 中 Web 应用程序安全和用户管理的理解。
- en: Practice questions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习题
- en: How do you integrate Nuxt UI into a Nuxt 3 project?
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 Nuxt UI 集成到 Nuxt 3 项目中？
- en: How do you customize the primary color in Nuxt UI?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何自定义 Nuxt UI 的主色调？
- en: What is `$fetch`?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 `$fetch`？
- en: How do you define a global type without needing to import it each time?
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义一个全局类型，而无需每次都导入它？
- en: What is the purpose of the `useRuntimeConfig` composable in Nuxt 3?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt 3 中 `useRuntimeConfig` 组合式的作用是什么？
- en: What are the benefits of using Pinia for state management in Nuxt?
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pinia 进行 Nuxt 状态管理的优势是什么？
- en: Explain the use of `storeToRefs` in a Nuxt 3 application.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释在 Nuxt 3 应用程序中 `storeToRefs` 的用法。
- en: How do you ensure reactivity when using a global state from a Pinia store?
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保使用 Pinia 存储的全局状态具有响应性？
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Nuxt UI: [https://ui.nuxt.com/](https://ui.nuxt.com/)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt UI：[https://ui.nuxt.com/](https://ui.nuxt.com/)
- en: 'Nuxt data fetching: [https://nuxt.com/docs/getting-started/data-fetching](https://nuxt.com/docs/getting-started/data-fetching)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt 数据获取：[https://nuxt.com/docs/getting-started/data-fetching](https://nuxt.com/docs/getting-started/data-fetching)
- en: 'Pinia: [https://pinia.vuejs.org](https://pinia.vuejs.org)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pinia：[https://pinia.vuejs.org](https://pinia.vuejs.org)
- en: 'OpenWeatherMap API: [https://openweathermap.org/api](https://openweathermap.org/api)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenWeatherMap API: [https://openweathermap.org/api](https://openweathermap.org/api)'
- en: 'JavaScript asynchronous programming and promises: [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 异步编程和承诺：[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous)
- en: 'Day.js documentation: [https://day.js.org/](https://day.js.org/)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Day.js 文档：[https://day.js.org/](https://day.js.org/)
