- en: '*Chapter 11*: Similarities and Differences between Three Global State Libraries'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：三个全局状态库的相似之处和不同之处'
- en: 'In this book, we introduced three global state libraries: Zustand, Jotai, and
    Valtio. Let''s discuss some similarities and differences between them. These three
    libraries have some comparable features.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们介绍了三个全局状态库：Zustand、Jotai和Valtio。让我们讨论一下它们之间的相似之处和不同之处。这三个库有一些可比较的功能。
- en: Zustand is similar to Redux (and React Redux) in terms of usage and the store
    model but, unlike Redux, it's not based on reducers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Zustand在用法和存储模型方面与Redux（以及React Redux）相似，但与Redux不同，它不是基于reducers的。
- en: Jotai is similar to Recoil ([https://recoiljs.org](https://recoiljs.org)) in
    terms of the API, but its goal is more to provide a minimal API for non-selector-based
    render optimization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai在API方面与Recoil ([https://recoiljs.org](https://recoiljs.org)) 相似，但其目标更多的是提供一个针对非选择器基础的渲染优化的最小API。
- en: Valtio is similar to MobX in terms of the mutating update model, but the level
    of similarity is only minor, and the render optimization implementation is very
    different.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Valtio在突变更新模型方面与MobX相似，但相似程度仅是微小的，并且渲染优化实现非常不同。
- en: All three libraries provide primitive features that fit with micro-state management.
    They differ in their coding style and approach to render optimization.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个库都提供了适合微状态管理的原始功能。它们在编码风格和渲染优化方法上有所不同。
- en: 'In this chapter, we discuss each library by pairing it with its comparable
    library and then discuss the similarities and differences between the three. We
    will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过将其与其可比较的库配对来讨论每个库，然后讨论这三个库之间的相似之处和不同之处。我们将涵盖以下主题：
- en: Differences between Zustand and Redux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zustand与Redux的区别
- en: Understanding when to use Jotai and Recoil
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解何时使用Jotai和Recoil
- en: Using Valtio and MobX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Valtio和MobX
- en: Comparing Zustand, Jotai, and Valtio
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较Zustand、Jotai和Valtio
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are expected to have a moderate knowledge of React, including React hooks.
    Refer to the official site, [https://reactjs.org](https://reactjs.org), to learn
    more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你对React有一定的了解，包括React hooks。参考官方网站，[https://reactjs.org](https://reactjs.org)，以了解更多信息。
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have a basic knowledge of it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些代码中，我们使用TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))，你应该对其有基本了解。
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_11](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_11).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可在GitHub上找到：[https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_11](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_11)。
- en: To run the code snippets, you need a React environment, for example, Create
    React App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码片段，你需要一个React环境，例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    或 CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: Differences between Zustand and Redux
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zustand与Redux的区别
- en: In some use cases, the developer experience can be similar in Zustand and Redux.
    Both are based on one-way data flow. In one-way data flow, we dispatch `action`,
    which represents a command to update a state, and after the state is updated with
    `action`, the new state is propagated to where it's needed. This separation of
    dispatching and propagating simplifies the flow of data and makes the entire system
    more predictable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些用例中，开发者的体验在Zustand和Redux中可能是相似的。它们都基于单向数据流。在单向数据流中，我们派发`action`，它代表一个更新状态的命令，在状态通过`action`更新后，新的状态被传播到需要它的地方。这种派发和传播的分离简化了数据流，并使整个系统更具可预测性。
- en: On the other hand, they differ in how to update states. Redux is based on reducers.
    A reducer is a pure function that takes a previous state and an `action` object
    and returns a new state. While updating states with reducers is a strict method,
    it leads to more predictability. Zustand takes a flexible approach and it doesn't
    necessarily use reducers to update states.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它们在更新状态的方式上有所不同。Redux基于reducers。Reducer是一个纯函数，它接受一个先前的状态和一个`action`对象，并返回一个新的状态。使用reducers更新状态是一种严格的方法，但它带来了更高的可预测性。Zustand采取了一种灵活的方法，并且不一定使用reducers来更新状态。
- en: In this section, we will see a comparison by converting an example with Redux
    into Zustand. Then we will see the differences between the two.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过将一个Redux示例转换为Zustand来展示比较。然后我们将看到两者之间的差异。
- en: Example with Redux and Zustand
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux和Zustand的示例
- en: 'Let''s look at one of the official Redux tutorials. This is the so-called modern
    Redux with the Redux toolkit: [https://redux-toolkit.js.org/tutorials/quick-start](https://redux-toolkit.js.org/tutorials/quick-start).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个官方的Redux教程。这是所谓的现代Redux，使用Redux Toolkit：[https://redux-toolkit.js.org/tutorials/quick-start](https://redux-toolkit.js.org/tutorials/quick-start)。
- en: 'To create a Redux store, we can use `configureStore` from the Redux Toolkit
    library:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Redux存储，我们可以使用Redux Toolkit库中的`configureStore`：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `configureStore` function takes reducers and returns a `store` variable.
    In this case, it uses one reducer – `counterReducer`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`configureStore`函数接受减少器并返回一个`store`变量。在这种情况下，它使用一个减少器——`counterReducer`。'
- en: '`counterReducer` is defined in a separate file, using `createSlice` from the
    Redux Toolkit library. First, we import `createSlice` and define `initialState`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`counterReducer`是在一个单独的文件中定义的，使用Redux Toolkit库中的`createSlice`。首先，我们导入`createSlice`并定义`initialState`：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then define `counterSlice` using `createSlice` and `initialState`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用`createSlice`和`initialState`定义`counterSlice`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `counterSlice` variable created with the `createSlice` function contains
    both a reducer and actions. To make them easily importable, we extract the reducer
    and action properties and export them separately:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`createSlice`函数创建的`counterSlice`变量包含一个减少器和动作。为了使它们易于导入，我们提取减少器和动作属性并分别导出：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next is the `Counter` component, which uses the created store. First, we import
    two hooks from the `react-redux` library and two actions from the `counterSlice`
    file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是使用创建的存储的`Counter`组件。首先，我们从`react-redux`库中导入两个钩子，从`counterSlice`文件中导入两个动作：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then define the `Counter` component:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后定义`Counter`组件：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This component uses useSelector and useDispatch hooks from the React Redux library.
    We use a selector function to get the count value from the store state. Notice
    that this component doesn't use the created store directly. The useSelector hook
    takes the store from Context.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件使用来自React Redux库的`useSelector`和`useDispatch`钩子。我们使用一个选择器函数从存储状态中获取计数值。注意，此组件没有直接使用创建的存储。`useSelector`钩子从Context中获取存储。
- en: 'Finally, the `App` component looks like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App`组件看起来如下：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We pass the `store` variable we created with the `Provider` component. This
    allows the `useSelector` hook in the `Counter` component to access the `store`
    variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`Provider`组件传递我们创建的`store`变量。这允许`Counter`组件中的`useSelector`钩子访问`store`变量。
- en: As shown in *Figure 11.1*, this works as expected. We have two `Counter` components
    in the `App` component, and they share the same `count` value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图11.1*所示，这按预期工作。我们在`App`组件中有两个`Counter`组件，它们共享相同的`count`值。
- en: '![Figure 11.1 – Screenshot of the app with Redux ](img/Figure_11.1_B17780.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 使用Redux的应用程序截图](img/Figure_11.1_B17780.jpg)'
- en: Figure 11.1 – Screenshot of the app with Redux
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 使用Redux的应用程序截图
- en: Now, let's see how this can be implemented in Zustand.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这如何在Zustand中实现。
- en: 'First, we create a store with the `create` function from the Zustand library.
    We begin with importing the Zustand library:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用Zustand库中的`create`函数创建一个存储。我们首先导入Zustand库：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then define `State` type for TypeScript:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为TypeScript定义`State`类型：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is a `store` definition. In Zustand, a hook `useStore` represents
    a `store`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`store`定义。在Zustand中，一个钩子`useStore`代表一个`store`：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This defines both the counter state and counter actions in the `store`. The
    reducer logic is implemented in the function body of the actions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`store`中的计数状态和计数操作。减少器逻辑是在动作函数体中实现的。
- en: 'Next is the `Counter` component, which uses the created store:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Counter`组件，它使用了创建的存储：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use the `useStore` hook to get the `count` value and the actions to update
    the `count` value. Notice that the `useStore` hook is directly imported from the
    store file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`useStore`钩子来获取`count`值和更新`count`值的动作。注意，`useStore`钩子直接从存储文件导入。
- en: 'Finally, the `App` component looks like the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App`组件看起来如下：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we don't use Context, we don't need a provider component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用Context，因此不需要提供者组件。
- en: Now, let's discuss a comparison of the two.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论两者的比较。
- en: Comparing examples of Redux and Zustand
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较Redux和Zustand的示例
- en: 'While two implementations of the example in the *Example with Redux and Zustand*
    section share some common concepts, there are notable differences:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*示例与Redux和Zustand*部分的两个实现共享一些共同的概念，但也有一些显著的不同：
- en: One of the biggest differences between the example of Redux and Zustand is the
    directory structure. Modern Redux suggests the `features` directory structure
    and the `createSlice` function is designed to follow the feature directory pattern.
    This is a useful pattern for large-scale apps. Zustand, on the other hand, is
    unopinionated regarding the structure. It's up to developers how to organize files
    and directories. While it's possible to follow the `features` directory structure
    with Zustand, there's no specific support from the library. Our Zustand example
    shows a pattern with `counterActions`, but it's only one possible pattern.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux和Zustand的示例之间最大的区别之一是目录结构。现代Redux建议使用`features`目录结构，`createSlice`函数被设计成遵循功能目录模式。这对于大型应用来说是一个有用的模式。另一方面，Zustand对结构没有意见。开发者如何组织文件和目录取决于他们。虽然使用Zustand可以遵循`features`目录结构，但库没有提供具体支持。我们的Zustand示例展示了`counterActions`的模式，但这只是其中一种可能。
- en: Another difference in the store creation code is the use of Immer ([https://immerjs.github.io/immer/](https://immerjs.github.io/immer/)).
    Immer allows a mutation style such as `state.value += 1;`. Modern Redux uses Immer
    by default. Zustand doesn't use it by default, and neither does our example. It
    is possible to use Immer in Zustand, but it's optional.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建存储代码中的另一个区别是使用了Immer ([https://immerjs.github.io/immer/](https://immerjs.github.io/immer/))。Immer允许使用类似`state.value
    += 1;`的突变风格。现代Redux默认使用Immer。Zustand默认不使用它，我们的例子也是如此。在Zustand中使用Immer是可选的。
- en: In terms of store propagation, Redux uses Context, whereas Zustand uses module
    imports. Context allows the store to be injected at runtime, which works better
    in some use cases. Zustand optionally supports Context usage.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储传播方面，Redux使用Context，而Zustand使用模块导入。Context允许在运行时注入存储，这在某些用例中效果更好。Zustand可选地支持Context的使用。
- en: Most importantly, Redux Toolkit is based on Redux, which is based on a one-way
    data flow. So, updating the state in Redux requires actions to be dispatched.
    This limitation is sometimes good for maintainability and scalability. Zustand
    is unopinionated regarding the data flow, and while it can be used for one-way
    data flow, there is no library support and developers need to take care of everything.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，Redux Toolkit基于Redux，而Redux基于单向数据流。因此，在Redux中更新状态需要分发动作。这种限制有时对可维护性和可扩展性有益。Zustand对数据流没有意见，虽然它可以用于单向数据流，但没有库支持，开发者需要处理所有事情。
- en: In summary, modern Redux is more opinionated about how to manage the state and
    Zustand is less opinionated about it. In the end, Zustand is a minimalistic library,
    while Redux and its family are a set of full-featured libraries. The usages of
    both modern Redux and Zustand seem similar, but the philosophies behind them are
    different.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，现代Redux对如何管理状态有更多的意见，而Zustand则较少。最终，Zustand是一个简约的库，而Redux及其家族则是一套功能齐全的库。现代Redux和Zustand的使用看起来很相似，但它们背后的哲学是不同的。
- en: In this section, we saw a comparison between modern Redux and Zustand. Next
    up, we will compare Recoil and Jotai.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了现代Redux和Zustand之间的比较。接下来，我们将比较Recoil和Jotai。
- en: Understanding when to use Jotai and Recoil
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解何时使用Jotai和Recoil
- en: Jotai's API is highly inspired by Recoil. In the beginning, it's intentionally
    designed to help migration from Recoil to Jotai. In this section, we will see
    a comparison by converting an example with Recoil into Jotai. Then, we will discuss
    the differences between the two.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai的API高度受到Recoil的启发。最初，它是故意设计来帮助从Recoil迁移到Jotai的。在本节中，我们将通过将Recoil的示例转换为Jotai来进行比较。然后，我们将讨论两者之间的差异。
- en: Example with Recoil and Jotai
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Recoil和Jotai的示例
- en: Let's look at the Recoil tutorial at [https://recoiljs.org/docs/introduction/getting-started](https://recoiljs.org/docs/introduction/getting-started)
    and see how an example in the Recoil tutorial is converted to Jotai.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看Recoil教程[https://recoiljs.org/docs/introduction/getting-started](https://recoiljs.org/docs/introduction/getting-started)，看看Recoil教程中的示例是如何转换为Jotai的。
- en: 'To start with the Recoil example, we need to import some functions from the
    Recoil library:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，以回弹（Recoil）为例，我们需要从Recoil库中导入一些函数：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are five of them used in this example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中使用了五个。
- en: 'The first state for the text string is created with the `atom` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字符串的第一个状态是通过`atom`函数创建的：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It takes two properties – the `key` string and the `default` value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受两个属性——`key` 字符串和 `default` 值。
- en: 'To use the defined state, we use the `useRecoilState` hook:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用定义的状态，我们使用 `useRecoilState` 钩子：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`useRecoilState` returns the same value as `useState`. Hence, the rest of the
    code should be familiar.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRecoilState` 返回的值与 `useState` 相同。因此，其余的代码应该很熟悉。'
- en: 'The second state is a derived state. We use the `selector` function to define
    a derived state:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个状态是一个派生状态。我们使用 `selector` 函数定义派生状态：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It takes two properties – a `key` string and a `get` function. The `get` property
    is a function that returns a derived value. Another `get` function within a `get`
    property returns the value of other states created by other `atom` and `selector`
    functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受两个属性——一个 `key` 字符串和一个 `get` 函数。`get` 属性是一个返回派生值的函数。`get` 属性内的另一个 `get` 函数返回由其他
    `atom` 和 `selector` 函数创建的其他状态值。
- en: 'To use the second state, we use the `useRecoilValue` hook, which returns only
    the value part of the state:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用第二个状态，我们使用 `useRecoilValue` 钩子，它只返回状态的部分值：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This component will re-render when `textState` changes because `charCountState`
    is derived from it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `textState` 发生变化时，此组件将重新渲染，因为 `charCountState` 是从它派生出来的。
- en: 'The `CharacterCounter` component is defined as follows to combine two components
    that are already defined:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharacterCounter` 组件如下定义，以组合已定义的两个组件：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we define the `App` component:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义 `App` 组件：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `App` component, we use the `RecoilRoot` component, which holds state
    values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App` 组件中，我们使用 `RecoilRoot` 组件，它包含状态值。
- en: 'As shown in *Figure 11.2*, this app works like this: if you type something
    in the text field, the text will be shown below the text field, and also the number
    of characters is shown as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11.2* 所示，此应用程序的工作方式如下：如果你在文本字段中输入某些内容，文本将显示在文本字段下方，并且字符数如下所示：
- en: '![](img/Figure_11.2_B17780.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2](img/Figure_11.2_B17780.jpg)'
- en: Figure 11.2 – Screenshot of the app with Recoil
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 使用 Recoil 的应用程序截图
- en: Now, let's convert this example code into Jotai.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此示例代码转换为 Jotai。
- en: 'We first import two functions from the Jotai library:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 Jotai 库中导入两个函数：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Jotai's API tries to be minimal, and the minimal usage requires two functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai 的 API 尝试保持最小化，最小使用需要两个函数。
- en: 'The first atom for the text string is created with the `atom` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字符串的第一个原子使用 `atom` 函数创建：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is almost the same as Recoil, except that it only has the `default` value
    because Jotai doesn't require the `key` string. Suffixing the variable name with
    `Atom` instead of `State` is a convention that is technically unimportant.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与 Recoil 相同，只是它只有 `default` 值，因为 Jotai 不需要 `key` 字符串。在变量名后缀 `Atom` 而不是 `State`
    是一个技术上不重要的约定。
- en: 'To use the defined atom, we use the `useAtom` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用定义的原子，我们使用 `useAtom` 函数：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `useAtom` function works like `useState`, and the rest of the code should
    be familiar to people who are used to `useState`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`useAtom` 函数的工作方式类似于 `useState`，其余的代码应该对习惯使用 `useState` 的人来说很熟悉。'
- en: 'The second atom is a derived atom, which is defined with the `atom` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原子是一个派生原子，它使用 `atom` 函数定义：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, we pass a function to the `atom` function. The internal function
    computes the derived value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将一个函数传递给 `atom` 函数。内部函数计算派生值。
- en: 'To use the second atom, we again use the `useAtom` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用第二个原子，我们再次使用 `useAtom` 函数：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's required to get the first part of the returned value with `[count]`. Other
    than that, the code and the behavior should be similar to Recoil.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要用 `[count]` 获取返回值的第一个部分。除此之外，代码和行为应该与 Recoil 相似。
- en: 'The `CharacterCounter` component is defined as follows to combine two components
    that are already defined:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharacterCounter` 组件如下定义，以组合已定义的两个组件：'
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we define the `App` component:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义 `App` 组件：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The minimal use case of Jotai doesn't require a `Provider` component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai 的最小使用案例不需要 `Provider` 组件。
- en: The conversion from the Recoil example to the Jotai example is mostly syntactic,
    and the behavior is the same.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Recoil 示例到 Jotai 示例的转换主要是语法上的，行为是相同的。
- en: Let's discuss some of the differences.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些差异。
- en: Comparing examples of Recoil and Jotai
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较 Recoil 和 Jotai 的示例
- en: 'Although there are many differences in terms of features we didn''t use in
    the example, we''ll keep our discussion within the scope of the example we showed,
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在示例中没有使用到许多功能方面存在许多差异，但我们将讨论范围限制在我们展示的示例中，如下所示：
- en: 'The biggest difference is the existence of the `key` string. One of the big
    motivations of developing Jotai is to omit the `key` string. Thanks to this feature,
    the `atom ({ key: "textState", default: "" })` atom definition in Recoil can be
    `atom("")` in Jotai. Technically, it looks straightforward, but this makes a huge
    difference to the developer experience. Naming is a hard task in coding, especially
    because the `key` property has to be unique. Implementation-wise, Jotai utilizes
    `WeakMap` and relies on the reference of atom objects. On the other hand, Recoil
    is based on the `key` strings, which don''t rely on object references. The benefit
    of `key` strings is that they''re serializable. This should facilitate implementing
    persistence, which requires serialization. Jotai would require some techniques
    to overcome serialization.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最大的差异是`key`字符串的存在。开发Jotai的一个主要动机是省略`key`字符串。多亏了这个特性，Recoil中的`atom ({ key: "textState",
    default: "" })`原子定义在Jotai中可以写成`atom("")`。从技术上讲，这看起来很简单，但这给开发者体验带来了巨大的差异。在编码中命名是一个困难的工作，尤其是因为`key`属性必须是唯一的。在实现上，Jotai利用`WeakMap`并依赖于原子对象的引用。另一方面，Recoil基于`key`字符串，不依赖于对象引用。`key`字符串的好处是它们是可序列化的。这应该有助于实现持久化，这需要序列化。Jotai将需要一些技术来克服序列化问题。'
- en: Another difference related to the `key` string is the unified `atom` function.
    The `atom` function in Jotai works for both `atom` and `selector` in Recoil. However,
    there's a downside. It can't be fully expressive and may require other functions
    in Jotai to support other use cases.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`key`字符串相关的另一个差异是统一的`atom`函数。Jotai中的`atom`函数在Recoil中的`atom`和`selector`上都适用。然而，也存在一个缺点。它不能完全表达，可能需要Jotai中的其他函数来支持其他用例。
- en: Last but not least, the provider-less mode in Jotai, which allows omission of
    the `Provider` component, is technically simple, but very developer-friendly to
    lower the mental barrier as regards using the library.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，Jotai的无提供者模式，允许省略`Provider`组件，在技术上很简单，但对开发者非常友好，有助于降低使用库的心理障碍。
- en: Basic functionalities are the same in both Recoil and Jotai and developers would
    need to make a choice based on other requirements or just their preference in
    terms of the API. Jotai's API is minimalistic, the same as Zustand.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Recoil和Jotai的基本功能相同，开发者需要根据其他需求或仅仅基于对API的偏好来做出选择。Jotai的API是极简的，与Zustand相同。
- en: In this section, we saw a comparison between Recoil and Jotai. Next up, we will
    see a comparison between MobX and Valtio.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了Recoil和Jotai之间的比较。接下来，我们将看到MobX和Valtio之间的比较。
- en: Using Valtio and MobX
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Valtio和MobX
- en: Although the motivation is quite different, Valtio is often compared to MobX
    ([https://mobx.js.org](https://mobx.js.org)). Usage-wise, there are some similarities
    in Valtio and MobX regarding their React binding. Both are based on mutable states
    and developers can directly mutate state, which results in similar usage. JavaScript
    is based on mutable objects, so the syntax of mutating an object is very natural
    and compact. This is a big win for mutable states compared to immutable states.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然动机相当不同，但Valtio经常与MobX ([https://mobx.js.org](https://mobx.js.org)) 相比较。在用法上，Valtio和MobX在它们的React绑定方面有一些相似之处。两者都基于可变状态，开发者可以直接修改状态，这导致了相似的用法。JavaScript基于可变对象，因此修改对象的语法非常自然和紧凑。与不可变状态相比，这是一个很大的优势。
- en: 'On the other hand, there is a difference in how they optimize renders. For
    render optimization, while Valtio uses a hook, MobX React uses a **higher-order
    component** (**HoC**): [https://reactjs.org/docs/higher-order-components.html](https://reactjs.org/docs/higher-order-components.html).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '另一方面，它们在渲染优化方面的差异。对于渲染优化，Valtio使用一个钩子，而MobX React使用**高阶组件**（**HoC**）: [https://reactjs.org/docs/higher-order-components.html](https://reactjs.org/docs/higher-order-components.html)。'
- en: In this section, we will convert a simple MobX example into Valtio. Then we
    will see the differences between the two.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把一个简单的MobX示例转换为Valtio。然后我们将看到两者之间的差异。
- en: Important Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Conceptually, Valtio is comparable to Immer ([https://immerjs.github.io/immer/](https://immerjs.github.io/immer/)).
    Both try to bridge immutable and mutable states. Valtio is based on mutable states
    and converts states to immutable ones, whereas Immer is based on immutable states
    and uses mutable states (drafts) temporarily.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，Valtio与Immer ([https://immerjs.github.io/immer/](https://immerjs.github.io/immer/))
    相当。两者都试图连接不可变状态和可变状态。Valtio基于可变状态并将状态转换为不可变状态，而Immer基于不可变状态并暂时使用可变状态（草稿）。
- en: Example involving MobX and Valtio
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 涉及MobX和Valtio的示例
- en: 'Let''s take an example from MobX''s documentation: [https://mobx.js.org/README.html#a-quick-example](https://mobx.js.org/README.html#a-quick-example).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从MobX文档中举一个例子：[https://mobx.js.org/README.html#a-quick-example](https://mobx.js.org/README.html#a-quick-example)。
- en: 'We first import some functions from the MobX libraries:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从MobX库中导入一些函数：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As the MobX library is framework-agnostic, the React-related function is imported
    from the MobX React library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MobX库是框架无关的，因此相关的React函数是从MobX React库导入的。
- en: 'The next step is to define the business logic, which is a timer. We create
    a class and then instantiate it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义业务逻辑，即计时器。我们创建一个类然后实例化它：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It has one property and two functions to mutate the property. `makeAutoObservable`
    is used to make the `myTimer` instance an observable object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个属性和两个用于修改属性的函数。`makeAutoObservable`用于将`myTimer`实例变为可观察对象。
- en: 'We can call the mutating function anywhere within the code. As an example,
    let''s set an interval:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码的任何地方调用这个可变函数。例如，让我们设置一个间隔：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will increase the `secondsPassed` property every second.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将每秒增加`secondsPassed`属性。
- en: 'Now, the component to use `timer` is the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`timer`的组件如下：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `observer` function is an HoC. It understands `timer.secondsPassed` is used
    in a render function, and will trigger re-renders when `timer.secondsPassed` changes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`observer`函数是一个高阶组件。它理解`timer.secondsPassed`在渲染函数中被使用，并且当`timer.secondsPassed`变化时将触发重新渲染。'
- en: 'Finally, the `App` component has the `TimerView` component with the `myTimer`
    instance:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App`组件包含`TimerView`组件和`myTimer`实例：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As *Figure 11.3* shows, if you run this app, it will show a button with a label
    showing the number of seconds that have passed. The label changes every second.
    Clicking this button will reset the number.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图11.3*所示，如果你运行这个应用，它将显示一个带有标签显示已过去秒数的按钮。标签每秒变化一次。点击此按钮将重置数值。
- en: '![](img/Figure_11.3_B17780.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.3_B17780.jpg)'
- en: Figure 11.3 – Screenshot of the app with MobX
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 使用MobX的应用截图
- en: Now, what would this look like with Valtio? Let's see the same example with
    Valtio.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用Valtio会是什么样子？让我们用Valtio查看相同的示例。
- en: 'We first import two functions from the Valtio library:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从Valtio库中导入两个函数：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Although Valtio is a library for React, it has a vanilla bundle for non-React
    use cases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Valtio是一个用于React的库，但它有一个用于非React用例的原生包。
- en: 'We use the `proxy` function to define a `myTimer` instance:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`proxy`函数来定义一个`myTimer`实例：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It has a `secondsPassed` property for a number value and two function properties
    to update the number value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个`secondsPassed`属性用于数值和一个用于更新数值的两个函数属性。
- en: 'We use one of the function properties to increase the `secondsPassed` property
    periodically:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用其中一个函数属性定期增加`secondsPassed`属性：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This `setInterval` usage is exactly the same as MobX.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`setInterval`的使用与MobX完全相同。
- en: 'Next is the `TimerView` component using `useSnapshot`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是使用`useSnapshot`的`TimerView`组件：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In Valtio, `useSnapshot` is a hook to understand how a state is used in a render
    function and will trigger re-renders when the used part in the state is changed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Valtio中，`useSnapshot`是一个钩子，用于理解状态在渲染函数中的使用情况，并且当状态中被使用部分发生变化时将触发重新渲染。
- en: 'Finally, the `App` component is the same as MobX:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App`组件与MobX相同：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the end, we should have the same behavior as MobX. It shows a button with
    a label. The label shows the number of seconds that have passed, and clicking
    the button will reset the value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该有与MobX相同的行为。它显示一个带有标签的按钮。标签显示已过去的秒数，点击按钮将重置值。
- en: Now, let's discuss some differences.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一些区别。
- en: Comparing examples of MobX and Valtio
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较MobX和Valtio的示例
- en: 'The two examples in MobX and Valtio look similar, but there are two major differences:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: MobX和Valtio中的两个示例看起来很相似，但有两个主要区别：
- en: The first difference is the updating method. Although both use mutations, the
    MobX example is class-based, whereas the Valtio example is object-based. It's
    mostly stylistic, and Valtio is not very opinionated regarding the styles.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个区别是更新方法。尽管两者都使用可变操作，但MobX示例是类基础的，而Valtio示例是对象基础的。这主要是风格上的，Valtio对风格并不强加。
- en: 'One of the styles Valtio allows is the separation of functions from the state
    object. The same example can be implemented in the following approach:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Valtio允许的一种样式是将函数与状态对象分离。同样的示例可以用以下方法实现：
- en: '[PRE36]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We define updating functions outside the state object defined by the `proxy`
    function. The benefit of this approach is that it allows code-splitting, minification,
    and dead code elimination. In the end, we can expect an optimized bundle size.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在由`proxy`函数定义的状态对象外部定义更新函数。这种方法的优点是它允许代码拆分、压缩和删除死代码。最终，我们可以期待一个优化的包大小。
- en: The second difference is the render optimization method. While MobX takes the
    observer approach, Valtio takes the hook approach. There are pros and cons to
    each. The observer approach is more predictable. The hook approach is more "concurrent
    rendering" friendly. Implementing this approach is likely very different. There's
    also a stylistic difference; some developers prefer the HoC style, while other
    developers prefer the hook style.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个不同点是渲染优化方法。虽然MobX采用观察者方法，Valtio采用钩子方法。每种方法都有其优缺点。观察者方法更可预测。钩子方法更“并发渲染”友好。实现这种方法可能非常不同。还有风格上的差异；一些开发者更喜欢HoC风格，而其他开发者更喜欢钩子风格。
- en: Important Note
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: As of the time of writing, we only have limited information about concurrent
    rendering. It's our best observation at this point, but it's not guaranteed whether
    the statement will hold in the future.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，关于并发渲染，我们只有有限的信息。这是我们的最佳观察，但并不能保证这个说法在未来是否成立。
- en: In this section, we saw a comparison between MobX and Valtio. Next up, we will
    discuss a comparison between Zustand, Jotai, and Valtio.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们比较了MobX和Valtio。接下来，我们将讨论Zustand、Jotai和Valtio之间的比较。
- en: Comparing Zustand, Jotai, and Valtio
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较Zustand、Jotai和Valtio
- en: 'In this chapter so far, we have compared the following pairs:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经比较了以下对：
- en: Zustand and Redux in the *Differences between Zustand and Redux* section
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*Zustand与Redux的区别*部分比较了Zustand和Redux
- en: Jotai and Recoil in the *Understanding when to use Jotai and Recoil* section
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*理解何时使用Jotai和Recoil*部分比较了Jotai和Recoil
- en: Valtio and MobX in the *Using Valtio and MobX* section
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用Valtio和MobX*部分比较了Valtio和MobX
- en: We compared these pairs because there are some similarities. In this section,
    we will compare Zustand, Jotai, and Valtio.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较这些对是因为它们有一些相似之处。在本节中，我们将比较Zustand、Jotai和Valtio。
- en: 'First of all, all three libraries are provided by the Poimandres GitHub organization
    ([https://github.com/pmndrs](https://github.com/pmndrs)). It''s a developer collective
    providing many libraries. Three micro-state management libraries from a single
    GitHub organization may sound counter-intuitive, but they are in different styles.
    There is also a philosophy that is common in the three libraries: their small
    API surfaces. All three libraries try their best to provide small API surfaces
    and let developers compose the APIs as they want.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这三个库都是由Poimandres GitHub组织提供的([https://github.com/pmndrs](https://github.com/pmndrs))。这是一个开发者集体，提供许多库。来自单个GitHub组织的三个微状态管理库听起来可能有些反直觉，但它们具有不同的风格。这三个库中也有一个共同的哲学：它们的API表面较小。所有三个库都尽力提供小的API表面，让开发者按需组合API。
- en: But then, what are the differences between the three libraries?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但那么，这三个库之间的区别是什么？
- en: 'There are two aspects:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个方面：
- en: '`countAtom`:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`countAtom`：'
- en: '[PRE37]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This `countAtom` variable holds a config object, and it doesn't hold a value.
    The atom values are stored in a `Provider` component. Hence, `countAtom` can be
    reused for multiple components. Implementing the same behavior is tricky with
    module states. With Zustand and Valtio, we would end up using React Context. On
    the other hand, accessing component states from outside React is technically not
    possible. We'll likely need some sort of module state to connect to the component
    states.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`countAtom`变量持有配置对象，并不存储值。原子值存储在`Provider`组件中。因此，`countAtom`可以被多个组件复用。使用模块状态实现相同的行为比较棘手。使用Zustand和Valtio，我们最终会使用React
    Context。另一方面，从React外部访问组件状态在技术上是不可能的。我们可能需要某种模块状态来连接到组件状态。
- en: Whether we use module states or component states depends on the app requirements.
    Usually, using either module states or component states for global states fulfills
    the app requirements, but in some rare cases, using both types of states may make
    sense.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们是否使用模块状态或组件状态取决于应用需求。通常，使用模块状态或组件状态作为全局状态可以满足应用需求，但在一些罕见情况下，同时使用这两种类型的状态可能是有意义的。
- en: '`state = { count: 0 }`. If you want to update the count in the immutable state
    model, you need to create a new object. Hence, incrementing the count by `1` should
    be `state = { count: state.count + 1 }`. In the mutable state mode, it could be
    `++state.count`. This is because JavaScript objects are mutable by nature. The
    benefit of the immutable model is that you can compare the object references to
    know whether anything has changed. It helps improve performance for large, nested
    objects. Because React is mostly based on the immutable model, Zustand with the
    same model has compatibility. Thus, Zustand is a very thin library. On the other
    hand, Valtio, with the mutable state model, requires filling the gap between the
    two models. In the end, Zustand and Valtio take different state updating styles.
    The mutable updating style is very handy, especially when an object is deeply
    nested. Revisit the example in *The pros and cons of this approach* section of
    [*Chapter 9*](B17780_09_Final_VK_ePub.xhtml#_idTextAnchor116), *Use Case Scenario
    3 – Valtio*.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state = { count: 0 }`。如果您想在不可变状态模型中更新count，您需要创建一个新的对象。因此，将计数增加`1`应该是`state
    = { count: state.count + 1 }`。在可变状态模式中，它可以是`++state.count`。这是因为JavaScript对象本质上是可变的。不可变模型的好处是您可以比较对象引用以了解是否发生了任何变化。这有助于提高大型嵌套对象的表现。因为React主要基于不可变模型，所以与具有相同模型的Zustand具有兼容性。因此，Zustand是一个非常薄的库。另一方面，具有可变状态模型的Valtio需要填补两个模型之间的差距。最终，Zustand和Valtio采用了不同的状态更新风格。可变更新风格非常方便，尤其是在对象深度嵌套时。回顾*第9章*中*这种方法的优势和劣势*部分的例子，*用例场景3
    – Valtio*。'
- en: Note Regarding the Use of Immer
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于Immer使用的注意事项
- en: It's possible to use Immer to allow mutations to update states in Zustand and
    Jotai. Compared to the combination of Zustand and Immer, Valtio is more optimized
    for the mutable state model. It has smaller API surfaces and it also optimizes
    re-renders. The combination of Jotai and Immer is useful for big objects, and
    the Jotai library provides a specific feature to integrate Immer. However, Jotai
    atoms are usually small, and in such a case, the immutable updating style is not
    a big issue.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Immer允许在Zustand和Jotai中更新状态，与Zustand和Immer的组合相比，Valtio在可变状态模型上进行了更多优化。它具有更小的API表面，并且还优化了重新渲染。Jotai和Immer的组合对于大对象很有用，并且Jotai库提供了一种特定功能来集成Immer。然而，Jotai原子通常很小，在这种情况下，不可变更新风格并不是一个大问题。
- en: There are some minor differences among the three libraries, but what's important
    is the fact that they are based on different principles. If we were to choose
    one of them, we would need to see which principle fits well with our app requirements
    and our mental model.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个库之间有一些细微的差别，但重要的是它们基于不同的原则。如果我们必须选择其中一个，我们需要看看哪个原则与我们的应用程序需求和我们的心智模型很好地匹配。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we summarized the differences between the three libraries for
    a global state we explained in this book. They are different because they are
    based on different models.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们总结了本书中解释的全局状态三个库之间的差异。它们之所以不同，是因为它们基于不同的模型。
- en: Essentially, micro-state management involves choosing the right solution and
    the right library for a specific problem. Micro state management requires you
    to understand what your problem is and what solutions are available for your problem.
    We hope that this book has covered some topics that will help developers find
    the right solution.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，微状态管理涉及为特定问题选择正确的解决方案和正确的库。微状态管理要求您了解您的问题是什么以及您的问题有哪些解决方案。我们希望这本书涵盖了一些可以帮助开发者找到正确解决方案的主题。
- en: Hi!
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗨！
- en: I am Daishi Kato, author of Micro State Management with React Hooks. I really
    hope you enjoyed reading this book and found it useful for increasing your productivity
    and efficiency in React Hooks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我是Daishi Kato，Micro State Management with React Hooks的作者。我真心希望您喜欢阅读这本书，并发现它对提高您在React
    Hooks中的生产力和效率很有用。
- en: It would really help me (and other potential readers!) if you could leave a
    review on Amazon sharing your thoughts on Micro State Management with React Hooks
    here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能在亚马逊上留下对Micro State Management with React Hooks的评论，分享您的想法，这将对我（以及其他潜在读者！）真的非常有帮助。
- en: 'Go to the link below or scan the QR code to leave your review:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下面的链接或扫描二维码留下您的评论：
- en: '[https://packt.link/r/1801812373](https://packt.link/r/1801812373)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/r/1801812373](https://packt.link/r/1801812373)'
- en: '![Qr code  Description automatically generated](img/QR_code_B17780.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![二维码  描述自动生成](img/QR_code_B17780.png)'
- en: Your review will help me to understand what's worked well in this book, and
    what could be improved upon for future editions, so it really is appreciated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您的评论将帮助我了解这本书哪些地方做得好，以及未来版本可以如何改进，所以这真的非常感谢。
- en: Best wishes,
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 祝好，
- en: '![](img/Author_photo.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![作者照片](img/Author_photo.png)'
- en: Daishi Kato
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 大地加藤
