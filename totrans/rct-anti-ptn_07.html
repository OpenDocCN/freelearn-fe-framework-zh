<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-101"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.2.1">Introducing Test-Driven Development with React</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to a chapter that could potentially revolutionize your approach to React development – </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">test-driven development</span></strong><span class="koboSpan" id="kobo.5.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">TDD</span></strong><span class="koboSpan" id="kobo.7.1"> for short). </span><span class="koboSpan" id="kobo.7.2">If you’ve been building React applications, you know</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.8.1"> how complex and intricate they can get. </span><span class="koboSpan" id="kobo.8.2">With various states to manage, components to juggle, and user interactions to facilitate, ensuring the reliability of your code base can be challenging. </span><span class="koboSpan" id="kobo.8.3">That’s where TDD comes in.</span></p>
<p><span class="koboSpan" id="kobo.9.1">In the ever-changing landscape of software development, where features are continuously added or modified, TDD serves as a lighthouse that guides you safely through the rough seas of bugs and regressions. </span><span class="koboSpan" id="kobo.9.2">By writing tests before your actual code, you not only confirm that your code does what it’s supposed to, but you also create a safety net that makes future changes less risky.</span></p>
<p><span class="koboSpan" id="kobo.10.1">This chapter aims to deepen your understanding of TDD and how to implement it effectively in React applications. </span><span class="koboSpan" id="kobo.10.2">We’ll introduce the core </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.11.1">principles of TDD, explore various styles, including unit test-driven development, </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">acceptance test-driven development</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">ATDD</span></strong><span class="koboSpan" id="kobo.15.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.18.1">BDD</span></strong><span class="koboSpan" id="kobo.19.1">), and even examine the nuanced differences between the Chicago</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.20.1"> and London styles of TDD.</span></p>
<p><span class="koboSpan" id="kobo.21.1">But we won’t stop at theory – to make these concepts come alive, we’ll walk you through a practical example of creating a pizza store menu page. </span><span class="koboSpan" id="kobo.21.2">From setting up the initial structure to managing complex features, we’ll guide you through each step with the TDD approach. </span><span class="koboSpan" id="kobo.21.3">By the end of this chapter, you’ll have a firm grasp of TDD’s capabilities, and you’ll be well equipped to start writing more reliable, robust React applications.</span></p>
<p><span class="koboSpan" id="kobo.22.1">So, get ready to dive into a world where tests lead the way and code follows, creating a harmonious balance that results in better, more reliable software.</span></p>
<p><span class="koboSpan" id="kobo.23.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">Understanding TDD</span></li>
<li><span class="koboSpan" id="kobo.25.1">Introducing tasking</span></li>
<li><span class="koboSpan" id="kobo.26.1">Introducing the online pizza store application</span></li>
<li><span class="koboSpan" id="kobo.27.1">Breaking down the application requirements</span></li>
<li><span class="koboSpan" id="kobo.28.1">Implementing the application headline</span></li>
<li><span class="koboSpan" id="kobo.29.1">Implementing the menu list</span></li>
<li><span class="koboSpan" id="kobo.30.1">Creating the shopping cart</span></li>
<li><span class="koboSpan" id="kobo.31.1">Adding items to the shopping cart</span></li>
<li><span class="koboSpan" id="kobo.32.1">Refactoring the shopping ca</span><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.33.1">rt</span></li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">A GitHub repository has been created to host all the code we’ll discuss in this book. </span><span class="koboSpan" id="kobo.35.2">For this chapter, you can find the recommended structure at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch7"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch7</span></a><span class="koboSpan" id="kobo.37.1">.</span></p>
<h1 id="_idParaDest-103"><span class="koboSpan" id="kobo.38.1">Understanding T</span><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.39.1">DD</span></h1>
<p><span class="koboSpan" id="kobo.40.1">TDD isn’t exactly a new kid</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.41.1"> on the block. </span><span class="koboSpan" id="kobo.41.2">Originating from </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">Extreme Programming</span></strong><span class="koboSpan" id="kobo.43.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.44.1">XP</span></strong><span class="koboSpan" id="kobo.45.1">), a software development methodology</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.46.1"> that encourages frequent releases in short cycles, TDD has roots going back to the late 1990s. </span><span class="koboSpan" id="kobo.46.2">It was Kent Beck, one of the original signatories of the Agile Manifesto, who popularized this practice as a core part of XP. </span><span class="koboSpan" id="kobo.46.3">The practice has since grown beyond the realm of XP and is now commonly utilized in various methodologies and frameworks, React inclu</span><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.47.1">ded.</span></p>
<p><span class="koboSpan" id="kobo.48.1">At the heart of TDD</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.49.1"> is a very simple, yet profoundly effective cycle known as the </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">Red-Green-Refactor loop</span></strong><span class="koboSpan" id="kobo.51.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.52.1"><img alt="Figure 7.1: The Red-Green-Refactor loop" src="image/B31103_07_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.53.1">Figure 7.1: The Red-Green-Refactor loop</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.54.1">As you can see, there are essentially</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.55.1"> three steps when practicing TDD:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Red</span></strong><span class="koboSpan" id="kobo.57.1">: At this stage, you write a test</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.58.1"> that defines a function or improvements of a function. </span><span class="koboSpan" id="kobo.58.2">This test should initially fail because the function isn’t implemented yet. </span><span class="koboSpan" id="kobo.58.3">In most test frameworks (for example, Jest), there will be some red text to indicate the failure.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Green</span></strong><span class="koboSpan" id="kobo.60.1">: At this stage, you write the minimum</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.61.1"> amount of code necessary to pass the test. </span><span class="koboSpan" id="kobo.61.2">The key here is to write as little code as possible to make the test pass and make the text turn green – no more than that.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.62.1">Refactor</span></strong><span class="koboSpan" id="kobo.63.1">: Finally, you need to clean up the code</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.64.1"> while keeping it functional. </span><span class="koboSpan" id="kobo.64.2">The refactor phase is about making the code efficient, readable, and understandable without changing its behavior. </span><span class="koboSpan" id="kobo.64.3">The tests that are written</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.65.1"> should still pass after the refactoring.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.66.1">When developers first encounter TDD, it often feels counter-intuitive, as the practice of writing tests before the actual code contradicts traditional development instincts. </span><span class="koboSpan" id="kobo.66.2">However, once you get past the initial discomfort, the advantages</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.67.1"> of TDD become hard to ignore:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Focused problem-solving</span></strong><span class="koboSpan" id="kobo.69.1">: By writing a test for a specific functionality first, you focus your attention solely on solving one problem at a time, making the development process less overwhelming.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.70.1">Predictable next steps</span></strong><span class="koboSpan" id="kobo.71.1">: When you follow a test-driven approach, you always know what to do next: make the test pass. </span><span class="koboSpan" id="kobo.71.2">This reduces the cognitive load, making it easier to focus on the task at hand.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.72.1">Simple, maintainable design</span></strong><span class="koboSpan" id="kobo.73.1">: The process naturally encourages the simplest code necessary to pass tests, resulting in a design that is as minimal as possible, and thereby easier to understand and maintain.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.74.1">Facilitates mental flow</span></strong><span class="koboSpan" id="kobo.75.1">: The loop provides a structured approach to coding that helps maintain a “mental flow,” helping you stay focused on tasks by reducing the constant context-switching that interrupts a productive coding session.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Automatic test coverage</span></strong><span class="koboSpan" id="kobo.77.1">: TDD ensures that your application has robust test coverage by default. </span><span class="koboSpan" id="kobo.77.2">You’re not adding tests as an afterthought; they’re integral to the development process, ensuring a more stable codebase.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.78.1">TDD is a practice deeply rooted in the principles of Agile and XP but has found relevance far beyond those methodologies. </span><span class="koboSpan" id="kobo.78.2">With its structured Red-Green-Refactor loop, TDD provides a solid framework for writing high-quality code. </span><span class="koboSpan" id="kobo.78.3">Although it may appear counter-intuitive initially, adopting TDD can result in more focused problem-solving, predictable development, simpler design, enhanced productivity, and robust test</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.79.1"> coverage.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.80.1">Different styles of TDD</span></h2>
<p><span class="koboSpan" id="kobo.81.1">The core principles of TDD</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.82.1"> have been adapted and extended into various styles, each offering different perspectives on how best to approach testing and development. </span><span class="koboSpan" id="kobo.82.2">Let’s explore some of these styles to understand how they can be applied to React d</span><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.83.1">evelopment.</span></p>
<p><span class="koboSpan" id="kobo.84.1">The original form of TDD, simply referred to as TDD, mainly focuses on unit tests. </span><span class="koboSpan" id="kobo.84.2">In this style, you write tests for the smallest pieces of your code – often individual methods or functions. </span><span class="koboSpan" id="kobo.84.3">The aim is to ensure that each part of your code base works as expected in isolation. </span><span class="koboSpan" id="kobo.84.4">While this is powerful for testing logic and algorithms, it may not fully capture how various parts interact, especially in a complex UI framework suc</span><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.85.1">h as React.</span></p>
<p><span class="koboSpan" id="kobo.86.1">ATDD extends TDD by beginning the development process with user acceptance tests. </span><span class="koboSpan" id="kobo.86.2">This means that before writing any code, you define what “done” looks like from a user’s perspective, often in collaboration with stakeholders. </span><span class="koboSpan" id="kobo.86.3">These acceptance tests are then used as the foundation for developing features. </span><span class="koboSpan" id="kobo.86.4">ATDD is particularly useful for ensuring that you’re building what the user needs and wants:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.87.1"><img alt="Figure 7.2: The ATDD loop" src="image/B31103_07_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.88.1">Figure 7.2: The ATDD loop</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.89.1">Note that when you write an acceptance test, it can usually be broken down into smaller unit tests. </span><span class="koboSpan" id="kobo.89.2">For example, a user logging into the system can be an acceptance test, but there will be forgotten passwords, incorrect passwords or usernames, remember me functions, and more to cover</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.90.1"> in the lower-level u</span><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.91.1">nit tests.</span></p>
<p><span class="koboSpan" id="kobo.92.1">BDD is a further refinement of TDD and ATDD, focusing on the behavior of an application for a given input. </span><span class="koboSpan" id="kobo.92.2">Rather than writing tests that check if a particular method returns an expected value, BDD tests check if a system behaves as expected when subjected to certain conditions. </span><span class="koboSpan" id="kobo.92.3">BDD often uses more descriptive language to define tests, making it easier for non-technical stakeholders to understand what is being tested.</span></p>
<p><span class="koboSpan" id="kobo.93.1">BDD often makes use of tools such as </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">Cucumber</span></strong><span class="koboSpan" id="kobo.95.1"> to define behavior specifications in a human-readable</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.96.1"> format. </span><span class="koboSpan" id="kobo.96.2">In a Cucumber test, you specify behavior using a plaintext language called </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Gherkin</span></strong><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">Here’s a simple example of a BDD test case using Cucumber for a pizza </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.99.1">ordering feature (we will continue working on this pizza example later in this chapter):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
Feature: Pizza Ordering
  Scenario: Customer orders a single pizza
    Given I'm on the PizzaShop website
    When I select the "Order Pizza" button
    And I choose a "Margherita" pizza
    And I add it to the cart
    Then the cart should contain 1 "Margherita" pizza
  Scenario: Customer removes a pizza from the cart
    Given I'm on the PizzaShop website
    And the cart contains 1 "Margherita" pizza
    When I remove the "Margherita" pizza from the cart
    Then the cart should be empty</span></pre> <p><span class="koboSpan" id="kobo.101.1">This Gherkin file defines the expected behavior of the pizza ordering functionality. </span><span class="koboSpan" id="kobo.101.2">Each line is called a step and can be interpreted as a statement in the test. </span><span class="koboSpan" id="kobo.101.3">The scenarios describe the test’s behavior in terms of the steps to be performed and the expected outcomes.</span></p>
<p><span class="koboSpan" id="kobo.102.1">Gherkin syntax is more than just readable documentation – it’s executable. </span><span class="koboSpan" id="kobo.102.2">Tools such as Cucumber can parse the Gherkin files and execute tests based on them – for example, </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">Given I’m on the PizzaShop website</span></strong><span class="koboSpan" id="kobo.104.1"> is transformed into </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">cypress.visit("</span></strong><a href="http://pizzashop.com"><span class="koboSpan" id="kobo.106.1">http://pizzashop.com</span></a><span class="koboSpan" id="kobo.107.1">"</span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">)</span></strong><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">This ensures that the software behaves exactly as described in the feature files, making it a source of truth that evolves along with the application.</span></p>
<p><span class="koboSpan" id="kobo.110.1">BDD feature files (Gherkin) serve as a form of living </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.111.1">documentation that gets updated as the application changes. </span><span class="koboSpan" id="kobo.111.2">This makes them incredibly valuable for new team members, or even for seasoned developers, to understand the expected behavior of the applic</span><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.112.1">ation quickly.</span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.113.1">Focusing on user value</span></h2>
<p><span class="koboSpan" id="kobo.114.1">Regardless of the style you choose, when working</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.115.1"> with React, it’s crucial to focus on the user’s perspective. </span><span class="koboSpan" id="kobo.115.2">React components are pieces of UI that users interact with, so your tests should reflect that interaction. </span><span class="koboSpan" id="kobo.115.3">The user doesn’t care about how your state is managed or how efficient your life cycle methods are; they care about whether clicking a button shows a dropdown, or whether a form submission produces the expected result.</span></p>
<p><span class="koboSpan" id="kobo.116.1">Kent C. </span><span class="koboSpan" id="kobo.116.2">Dodds, the creator of the React Testing Library, said “</span><i class="italic"><span class="koboSpan" id="kobo.117.1">The more your tests resemble the way your software is used, the more confidence they can give you.</span></i><span class="koboSpan" id="kobo.118.1">” This principle is universally applicable, irrespective of the framework or library you’re using. </span><span class="koboSpan" id="kobo.118.2">The focus should always be on the user’s experience.</span></p>
<p><span class="koboSpan" id="kobo.119.1">This user-centric approach aligns well with BDD and ATDD, where the focus is on the result of an interaction, not the minutiae of the implementation. </span><span class="koboSpan" id="kobo.119.2">By adhering to these principles, you can ensure your React components not only work well but also deliver the user experience you aim to achieve.</span></p>
<p><span class="koboSpan" id="kobo.120.1">Now that we’ve understood what TDD is and how its various styles can aid in delivering value to our customers, the next question to tackle is: how do we go about i</span><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.121.1">mplementing it?</span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.122.1">Introducing tasking</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.123.1">Tasking</span></strong><span class="koboSpan" id="kobo.124.1"> is an essential step in the TDD process</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.125.1"> that involves breaking down a feature</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.126.1"> or user story into small, manageable tasks, which then serve as the basis for your test cases. </span><span class="koboSpan" id="kobo.126.2">The goal of tasking is to create a clear roadmap for what you’re going to code, how you’ll test it, and in what ord</span><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.127.1">er you’ll proceed.</span></p>
<p><span class="koboSpan" id="kobo.128.1">Breaking the big requirement into smaller chunks</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.129.1"> has a lot of benefits:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.130.1">It clarifies scope</span></strong><span class="koboSpan" id="kobo.131.1">: Breaking down a feature into tasks helps establish a better understanding of what needs to be done and how to approach it</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.132.1">It simplifies the problem</span></strong><span class="koboSpan" id="kobo.133.1">: By dissecting a complex problem into smaller tasks, you make it easier to tackle</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.134.1">It prioritizes work</span></strong><span class="koboSpan" id="kobo.135.1">: Once the tasks have been laid out, they can be prioritized to deliver the most value first or to build logically upon one another</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.136.1">It focuses effort</span></strong><span class="koboSpan" id="kobo.137.1">: Tasking ensures that each test you write serves a clear, immediate purpose, making your TDD cycle more efficient</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.138.1">It facilitates collaboration</span></strong><span class="koboSpan" id="kobo.139.1">: Team members can pick up individual tasks, safe in the knowledge that they are all contributing t</span><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.140.1">o a cohesive whole</span></li>
</ul>
<p><span class="koboSpan" id="kobo.141.1">Now, you might be wondering, if it is so good and helpful, how can we do tasking? </span><span class="koboSpan" id="kobo.141.2">It’s not anything fancy – you might have already done it without noticing. </span><span class="koboSpan" id="kobo.141.3">You just follow these steps:</span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.142.1">Review the user story or requirement</span></strong><span class="koboSpan" id="kobo.143.1">: Understand the user story</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.144.1"> or feature you are supposed to implement.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.145.1">Identify logical components</span></strong><span class="koboSpan" id="kobo.146.1">: Break the story down into its logical components, which often correspond to domain concepts, business rules, or individual steps in a user workflow.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.147.1">Create a task list</span></strong><span class="koboSpan" id="kobo.148.1">: Write down a list of tasks. </span><span class="koboSpan" id="kobo.148.2">These tasks should be small enough that you can write a few test cases and the corresponding implementation code in a short amount of time (say, 15 to 30 minutes).</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.149.1">Sequence the tasks</span></strong><span class="koboSpan" id="kobo.150.1">: Determine the most logical order for completing these tasks, often starting with the “happy path” – the default scenario where everything goes as expected, without encountering any errors – and then moving on to edge cases and error handling.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.151.1">Map the tasks to tests</span></strong><span class="koboSpan" id="kobo.152.1">: For each task, identify the tests that will verify that part of the functionality. </span><span class="koboSpan" id="kobo.152.2">You don’t need to write the tests at this stage; you’re simply identifying</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.153.1"> what they’ll be.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.154.1">Tasking might be a part of your daily workflow without you even realizing it. </span><span class="koboSpan" id="kobo.154.2">It’s a systematic approach to problem-solving that involves breaking down a requirement into manageable, sequential tasks. </span><span class="koboSpan" id="kobo.154.3">These tasks should ideally be completable within a few minutes to an hour.</span></p>
<p><span class="koboSpan" id="kobo.155.1">The process of TDD is akin to the art of painting. </span><span class="koboSpan" id="kobo.155.2">You begin with a sketch or draft, outlining basic shapes and lines with a pencil, much like framing the initial structure of your code. </span><span class="koboSpan" id="kobo.155.3">In the beginning, the vision might be vague, a mere idea or concept in your mind. </span><span class="koboSpan" id="kobo.155.4">But as you draw – or write tests and code – the image begins to take shape. </span><span class="koboSpan" id="kobo.155.5">More elements are added, details emerge, and adjustments are made, allowing for continuous refinement. </span><span class="koboSpan" id="kobo.155.6">With each layer or iteration, clarity emerges, yet the exact final appearance remains a mystery until the very last stages. </span><span class="koboSpan" id="kobo.155.7">Just as an artist crafts a masterpiece through gradual development, TDD shapes a robust and elegant piece of software.</span></p>
<p><span class="koboSpan" id="kobo.156.1">All right, we have covered</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.157.1"> a lot of theory so far. </span><span class="koboSpan" id="kobo.157.2">Let’s look into a concrete example to fully understand how to do tasking and use tasks as a guideline for applying the Red</span><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.158.1">-Green-Refactor loop.</span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.159.1">Introducing the online pizza store application</span></h1>
<p><span class="koboSpan" id="kobo.160.1">In this section, we’ll be diving</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.161.1"> into the TDD process through a deliciously practical example: </span><i class="italic"><span class="koboSpan" id="kobo.162.1">The Code Oven</span></i><span class="koboSpan" id="kobo.163.1">, an online pizza store. </span><span class="koboSpan" id="kobo.163.2">Named to celebrate the fusion of coding and culinary arts, The Code Oven aims to serve both your appetite and your intellectual curiosity. </span><span class="koboSpan" id="kobo.163.3">This digital storefront will offer us a comprehensive sandbox where we can apply all the TDD principles and </span><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.164.1">techniques we discuss.</span></p>
<p><span class="koboSpan" id="kobo.165.1">Here’s what you can expect to see</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.166.1"> in The Code Oven:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.167.1">Pizza menu</span></strong><span class="koboSpan" id="kobo.168.1">: At the heart of The Code Oven is an appetizing menu of eight delectable pizzas. </span><span class="koboSpan" id="kobo.168.2">Each pizza is presented with its name and cost, designed to whet your appetite and inform your choice.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.169.1">An Add button</span></strong><span class="koboSpan" id="kobo.170.1">: Beside each mouth-watering option is an </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">Add</span></strong><span class="koboSpan" id="kobo.172.1"> button. </span><span class="koboSpan" id="kobo.172.2">This enables users to start the ordering process by adding their chosen pizzas to a virtual shopping cart.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.173.1">Shopping cart</span></strong><span class="koboSpan" id="kobo.174.1">: A designated section on the screen shows users their current shopping cart, complete with the names and prices of each selected pizza.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.175.1">Modify cart</span></strong><span class="koboSpan" id="kobo.176.1">: Should you get second thoughts or just want more pizza, The Code Oven allows you to modify your cart by adding or removing items dynamically.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.177.1">Order total</span></strong><span class="koboSpan" id="kobo.178.1">: There’s no need for manual calculations – The Code Oven’s cart automatically computes and displays the total price of your chosen items.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.179.1">A Place my order button</span></strong><span class="koboSpan" id="kobo.180.1">: A prominent </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">Place my order</span></strong><span class="koboSpan" id="kobo.182.1"> button serves as the final step, which would, in a real-world application, process the order for delivery or pick-up:</span></li>
</ul>
<figure>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.183.1"><img alt="Figure 7.3: The Code Oven" src="image/B31103_07_03.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.184.1">Figure 7.3: The Code Oven</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.185.1">As we build out The Code Oven, we’ll be applying</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.186.1"> TDD at every stage to ensure that our virtual pizzeria</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.187.1"> is not just functional but robust and easily maintainable. </span><span class="koboSpan" id="kobo.187.2">Get ready to roll up your sleeves, both for coding and for so</span><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.188.1">me virtual pizza-making!</span></p>
<h1 id="_idParaDest-108"><span class="koboSpan" id="kobo.189.1">Breaking down the </span><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.190.1">application requirements</span></h1>
<p><span class="koboSpan" id="kobo.191.1">There isn’t a universal right way to break down the requirements</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.192.1"> of the application you are making; however, there are typically two different styles – the bottom-up style and the top-down style.</span></p>
<p><span class="koboSpan" id="kobo.193.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">bottom-up</span></strong><span class="koboSpan" id="kobo.195.1"> style of TDD, developers start by writing tests</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.196.1"> and implementing functionality</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.197.1"> for the smallest and most fundamental components of the system. </span><span class="koboSpan" id="kobo.197.2">This approach emphasizes the construction of individual units or classes, thoroughly testing them before integrating them into higher-level components. </span><span class="koboSpan" id="kobo.197.3">It provides strong validation for the underlying parts of the system and helps in creating a robust foundation.</span></p>
<p><span class="koboSpan" id="kobo.198.1">However, this style might lead to challenges in integrating the components if the bigger picture and interactions</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.199.1"> between the units are not carefully considered.</span></p>
<p><span class="koboSpan" id="kobo.200.1">Back to the online pizza store, we can break the whole page down into the following tasks:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.201.1">Implement a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">PizzaItem</span></strong><span class="koboSpan" id="kobo.203.1"> component with a pizza name</span></li>
<li><span class="koboSpan" id="kobo.204.1">Add a price to </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">PizzaItem</span></strong></li>
<li><span class="koboSpan" id="kobo.206.1">Add a button to </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">PizzaItem</span></strong></li>
<li><span class="koboSpan" id="kobo.208.1">Implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">PizzaList</span></strong><span class="koboSpan" id="kobo.210.1"> component (render three items in a row, for example)</span></li>
<li><span class="koboSpan" id="kobo.211.1">Implement a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.213.1"> component with a button</span></li>
<li><span class="koboSpan" id="kobo.214.1">Support the ability to add/remove items to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.216.1"> component</span></li>
<li><span class="koboSpan" id="kobo.217.1">Add a calculation for the total number of pizzas</span></li>
<li><span class="koboSpan" id="kobo.218.1">Implement the whole application with these individual standalone components</span></li>
</ul>
<p><span class="koboSpan" id="kobo.219.1">As you can see, each task focuses on an individual component at a time. </span><span class="koboSpan" id="kobo.219.2">The components start simple, with only the minimal function; then, we incrementally add more features to them, including test cases to cover the functionality required, as well as other reasonable edge cases.</span></p>
<p><span class="koboSpan" id="kobo.220.1">So, we start from a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">PizzaItem</span></strong><span class="koboSpan" id="kobo.222.1"> component (which only has a name in it) and then give it a price, and then a button. </span><span class="koboSpan" id="kobo.222.2">After the individual items are built, we start to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">PizzaList</span></strong><span class="koboSpan" id="kobo.224.1">, and then </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.226.1">. </span><span class="koboSpan" id="kobo.226.2">Then, once </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">PizzaList</span></strong><span class="koboSpan" id="kobo.228.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.230.1"> are done, we integrate them and test a few overall functions from the user’s perspective.</span></p>
<p><span class="koboSpan" id="kobo.231.1">For example, as demonstrated in the following screenshot, we might start with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">PizzaItem</span></strong><span class="koboSpan" id="kobo.233.1"> component, implementing the component gradually without worrying about anything else in the application. </span><span class="koboSpan" id="kobo.233.2">Once we have a full implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">PizzaItem</span></strong><span class="koboSpan" id="kobo.235.1"> (with an image, name, price and </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Add</span></strong><span class="koboSpan" id="kobo.237.1"> button), we can move on to the next component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.239.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.240.1"><img alt="Figu﻿re 7.4: The bottom-up style" src="image/B31103_07_04.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.241.1">Figu</span><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.242.1">re 7.4: The bottom-up style</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.243.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">top-down</span></strong><span class="koboSpan" id="kobo.245.1"> style of TDD takes the opposite approach, beginning</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.246.1"> with the high-level architecture and overall functionality of the system. </span><span class="koboSpan" id="kobo.246.2">Developers first write tests and implement features for the main components and then gradually work their way down to the more detailed and specific functionalities.</span></p>
<p><span class="koboSpan" id="kobo.247.1">This style helps ensure</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.248.1"> that the system’s primary objectives and workflow are established early on, providing a clear roadmap for the development process. </span><span class="koboSpan" id="kobo.248.2">It can foster better integration and alignment with the overall goals but may sometimes require the use of temporary “stubs” or “mocks” to simulate lower-level components before they are developed. </span><span class="koboSpan" id="kobo.248.3">For instance, we could break the feature down into the following list:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.249.1">Implement the page title</span></li>
<li><span class="koboSpan" id="kobo.250.1">Implement a menu list containing the pizza names</span></li>
<li><span class="koboSpan" id="kobo.251.1">Implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.253.1"> component with only a button (disabled by default)</span></li>
<li><span class="koboSpan" id="kobo.254.1">Add an item to </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.256.1"> when the button is clicked, after which the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.258.1"> button is enabled</span></li>
<li><span class="koboSpan" id="kobo.259.1">Add a price to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.261.1"> component</span></li>
<li><span class="koboSpan" id="kobo.262.1">Add a total number of selected items to </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">ShoppingCart</span></strong></li>
<li><span class="koboSpan" id="kobo.264.1">Remove an item from </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.266.1">, with the total number changing accordingly</span></li>
</ul>
<p><span class="koboSpan" id="kobo.267.1">For the top-down approach, we don’t have a clear picture of the individual</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.268.1"> units but the working application as a whole – so we see the application from outside without knowing</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.269.1"> the implementation details.</span></p>
<p><span class="koboSpan" id="kobo.270.1">For example, there isn’t a </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">PizzaItem</span></strong><span class="koboSpan" id="kobo.272.1"> component at the beginning, and the smaller components are gradually extracted from the bigger component when we find that the component is too big. </span><span class="koboSpan" id="kobo.272.2">This means we will always have functional software running (even if we don’t have the small well-designed components up-front), allowing us to stop at any time without breaking the functionality.</span></p>
<p><span class="koboSpan" id="kobo.273.1">A possible breakdown with the top-down approach is shown in the following diagram. </span><span class="koboSpan" id="kobo.273.2">We start with an empty list, then a list with pizza names, and then a shopping cart that allows users to add items and proceed to the next step:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.274.1"><img alt="Figure 7.5: The top-down style" src="image/B31103_07_05.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.275.1">Figure 7.5: The top-down style</span></figcaption> </figure>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">(The textual detail in the previous figure is minimized and is not directly relevant to your understanding of it. </span><span class="koboSpan" id="kobo.276.2">If you would like to see the textual detail, please refer to the free downloadable eBook.)</span></p>
<p><span class="koboSpan" id="kobo.277.1">Both styles have contributed to the rich variety</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.278.1"> of methodologies in modern software development, and neither is definitively “right” or “wrong.” </span><span class="koboSpan" id="kobo.278.2">Instead, they offer different perspectives and tools that developers can choose from based on their particular needs and preferences.</span></p>
<p><span class="koboSpan" id="kobo.279.1">In the following parts of this chapter, we are going to use the top-down style as it forces us to think from the user’s perspective. </span><span class="koboSpan" id="kobo.279.2">We’ll explore the bottom-up approach in more detail in the following chapters when we i</span><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.280.1">ntroduce other design patterns.</span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.281.1">Implementing the application headline</span></h1>
<p><span class="koboSpan" id="kobo.282.1">Let’s start with the implementation</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.283.1"> of the pizza store application. </span><span class="koboSpan" id="kobo.283.2">If you have cloned the repository mentioned in the </span><i class="italic"><span class="koboSpan" id="kobo.284.1">Technical requirements</span></i><span class="koboSpan" id="kobo.285.1"> section, simply go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">react-anti-patterns-code/src/ch7</span></strong><span class="koboSpan" id="kobo.287.1"> folder.</span></p>
<p><span class="koboSpan" id="kobo.288.1">As we’re applying TDD, the first thing to do here is to write a test that fails. </span><span class="koboSpan" id="kobo.288.2">In the previous section, we mentioned what we want to test: implement the page title.</span></p>
<p><span class="koboSpan" id="kobo.289.1">So, let’s create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">App.test.tsx</span></strong><span class="koboSpan" id="kobo.291.1"> with the following code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.292.1">
import React from 'react';
import {render, screen} from '@testing-library/react';
describe('Code Oven Application', () =&gt; {
  it('renders application heading', () =&gt; {
    render(&lt;PizzaShopApp /&gt;);
    const heading = screen.getByText('The Code Oven');
    expect(heading).toBeInTheDocument();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.293.1">We’re writing a test for the yet-to-be-created </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.295.1"> React component. </span><span class="koboSpan" id="kobo.295.2">Using the React Testing Library, we will render this component and verify whether it includes a heading labeled </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">The Code Oven</span></strong><span class="koboSpan" id="kobo.297.1">. </span><span class="koboSpan" id="kobo.297.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">expect(heading).toBeInTheDocument();</span></strong><span class="koboSpan" id="kobo.299.1"> assertion confirms that the heading is successfully rendered.</span></p>
<p><span class="koboSpan" id="kobo.300.1">Now, let’s run the test with the following command in your terminal window:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
npm run test src/ch7</span></pre> <p><span class="koboSpan" id="kobo.302.1">An error will appear in the terminal saying </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">ReferenceError: PizzaShopApp is not defined</span></strong><span class="koboSpan" id="kobo.304.1">, like so:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.305.1"><img alt="Figure 7.6: The failed test" src="image/B31103_07_06.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.306.1">Figure 7.6: The failed test</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.307.1">We’re in the red stage</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.308.1"> of the Red-Green-Refactor loop now, so we need to make the code pass using the simplest code</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.309.1"> possible. </span><span class="koboSpan" id="kobo.309.2">A static component that returns </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">The Code Oven</span></strong><span class="koboSpan" id="kobo.311.1"> would be simple enough to make the test pass. </span><span class="koboSpan" id="kobo.311.2">This means we can simply define a function component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.313.1">, in the test file that returns just the string:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
import React from 'react';
import {render, screen} from '@testing-library/react';
function PizzaShopApp() {
  return &lt;&gt;The Code Oven&lt;/&gt;;
}
describe("Code Oven Application", () =&gt; {
  it("renders application heading", () =&gt; {
    render(&lt;PizzaShopApp /&gt;);
    const heading = screen.getByText("The Code Oven");
    expect(heading).toBeInTheDocument();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.315.1">When we re-run the test, it passes since </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.317.1"> does exactly the thing the test expects – it shows </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">The Code Oven</span></strong><span class="koboSpan" id="kobo.319.1">. </span><span class="koboSpan" id="kobo.319.2">Now, we’re at the green stage of the Red-Green-Refactor loop. </span><span class="koboSpan" id="kobo.319.3">Next, we can look into opportunities for improvement.</span></p>
<p><span class="koboSpan" id="kobo.320.1">We don’t want to write all our code inside the test file – instead, we can use the </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">Move Function</span></strong><span class="koboSpan" id="kobo.322.1"> refactoring method we learned about</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.323.1"> in the previous chapter and move </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.325.1"> into a separate file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">App.tsx</span></strong><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">Now, the implementation lives in its own file, allowing us to change the test and the component separately:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
import React from "react";
export function PizzaShopApp() {
  return &lt;&gt;The Code Oven&lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.329.1">Awesome! </span><span class="koboSpan" id="kobo.329.2">With that, we have done a complete Red-Green-Refactor loop. </span><span class="koboSpan" id="kobo.329.3">We can now remove that task from our task list</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.330.1"> and move on to the next one.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.331.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.332.1">The code doesn’t have to be perfect at the beginning as we know TDD is an iterative process; we always have a chance to make the code better a</span><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.333.1">s we have good tests protecting us.</span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.334.1">Implementing the menu list</span></h1>
<p><span class="koboSpan" id="kobo.335.1">Even a basic menu list featuring just the names of pizzas</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.336.1"> can be valuable for customers who are looking to browse and decide what to eat. </span><span class="koboSpan" id="kobo.336.2">While The Code Oven may not be set up for online ordering yet, it serves as a useful starting point.</span></p>
<p><span class="koboSpan" id="kobo.337.1">Looking at the second task on our list, we can write our second test like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
it("renders menu list", () =&gt; {
  render(&lt;PizzaShopApp /&gt;);
  const menuList = screen.getByRole('list');
  const menuItems = within(menuList).getAllByRole('listitem');
  expect(menuItems.length).toEqual(8);
});</span></pre> <p><span class="koboSpan" id="kobo.339.1">This test starts by rendering the component. </span><span class="koboSpan" id="kobo.339.2">Then, it identifies the HTML element tagged with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">list</span></strong><span class="koboSpan" id="kobo.341.1"> role from the rendered component. </span><span class="koboSpan" id="kobo.341.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">within</span></strong><span class="koboSpan" id="kobo.343.1"> function, it narrows down the search to only that list and locates all items within it tagged with </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">listitem</span></strong><span class="koboSpan" id="kobo.345.1">. </span><span class="koboSpan" id="kobo.345.2">Finally, it asserts that the number of such items should be equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">8</span></strong><span class="koboSpan" id="kobo.347.1"> (the number of items the pizza shop has to offer). </span><span class="koboSpan" id="kobo.347.2">Essentially, we want eight list items to show up on the page.</span></p>
<p><span class="koboSpan" id="kobo.348.1">Now, the test has failed. </span><span class="koboSpan" id="kobo.348.2">To make the test pass easily, we can hard-code eight empty list items on the page:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
import React from "react";
export function PizzaShopApp() {
  return &lt;&gt;
    &lt;h1&gt;The Code Oven&lt;/h1&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.350.1">It doesn’t look too good, but it makes</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.351.1"> the test pass all the same. </span><span class="koboSpan" id="kobo.351.2">This is important to remember – during TDD, we always want to make the test pass first and then look for opportunities to improve afterward. </span><span class="koboSpan" id="kobo.351.3">The advantage of this mindset forces us to think about delivery and production readiness; we should be able to stop coding at any point and release the app to production – even if the code isn’t perfect yet.</span></p>
<p><span class="koboSpan" id="kobo.352.1">Now, re-run the test to see if it passes; if so, we can start refactoring it. </span><span class="koboSpan" id="kobo.352.2">To reduce the long hard-coded </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.354.1"> (the list item tag in HTML), we can use an array with eight elements and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">map</span></strong><span class="koboSpan" id="kobo.356.1"> to generate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.358.1"> dynamically inside an ordered list (</span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">&lt;ol&gt;</span></strong><span class="koboSpan" id="kobo.360.1">):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
import React from "react";
export function PizzaShopApp() {
  return &lt;&gt;
    &lt;h1&gt;The Code Oven&lt;/h1&gt;
    &lt;ol&gt;
      {new Array(8).fill(0).map(x =&gt; &lt;li&gt;&lt;/li&gt;)}
    &lt;/ol&gt;
  &lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.362.1">Inside this list, an array with eight elements (all initialized to 0) is mapped over, generating eight empty list items (</span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.364.1">). </span><span class="koboSpan" id="kobo.364.2">This matches the test criteria of having a menu list with eight items and the tests pass with the new structure.</span></p>
<p><span class="koboSpan" id="kobo.365.1">With that, we’ve done another</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.366.1"> Red-Green-Refactor loop. </span><span class="koboSpan" id="kobo.366.2">Now, we can verify that the pizza names are displayed correctly. </span><span class="koboSpan" id="kobo.366.3">Let’s add a few more lines to the second test case:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
it("renders menu list", () =&gt; {
  render(&lt;PizzaShopApp /&gt;);
  const menuList = screen.getByRole('list');
  const menuItems = within(menuList).getAllByRole('listitem');
  expect(menuItems.length).toEqual(8);
  expect(within(menuItems[0]).getByText('Margherita Pizza')).
</span><span class="koboSpan" id="kobo.367.2">   toBeInTheDocument();
  expect(within(menuItems[1]).getByText('Pepperoni Pizza')).
</span><span class="koboSpan" id="kobo.367.3">   toBeInTheDocument();
  expect(within(menuItems[2]).getByText('Veggie Supreme Pizza')).
</span><span class="koboSpan" id="kobo.367.4">   toBeInTheDocument();
  //...
</span><span class="koboSpan" id="kobo.367.5">});</span></pre> <p><span class="koboSpan" id="kobo.368.1">To make all the newly added lines pass, we’ll need to define a list of pizza names in </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.370.1">, and then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">map</span></strong><span class="koboSpan" id="kobo.372.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">pizzas</span></strong><span class="koboSpan" id="kobo.374.1"> array to map through these names into list items:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
const pizzas = [
  "Margherita Pizza",
  "Pepperoni Pizza",
  "Veggie Supreme Pizza",
  "Chicken BBQ Pizza",
  "Spicy Meat Feast Pizza",
  "Pasta Primavera",
  "Caesar Salad",
  "Chocolate Lava Cake"
];
export function PizzaShopApp() {
  return &lt;&gt;
    &lt;h1&gt;The Code Oven&lt;/h1&gt;
    &lt;ol&gt;
      {pizzas.map((x) =&gt; &lt;li&gt;{x}&lt;/li&gt;)}
    &lt;/ol&gt;
  &lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.376.1">The tests are now successfully passing. </span><span class="koboSpan" id="kobo.376.2">While the code may be overly simplified, the passing tests give us the confidence to make further changes without having to worry about any accidental feature breaks.</span></p>
<p><span class="koboSpan" id="kobo.377.1">It’s great to have a menu list, but the purpose of The Code Oven</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.378.1"> is to help users order online. </span><span class="koboSpan" id="kobo.378.2">So, let’s look </span><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.379.1">into how we can create a shopping cart.</span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.380.1">Creating the shopping cart</span></h1>
<p><span class="koboSpan" id="kobo.381.1">To develop a </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.383.1"> component, we will start</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.384.1"> with a simple test that expects an empty container to show on the page. </span><span class="koboSpan" id="kobo.384.2">Inside the container, there should be a button for the user to place their order.</span></p>
<p><span class="koboSpan" id="kobo.385.1">To do this, we will start with a test that simply checks that the container and button are present:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.386.1">
it('renders a shopping cart', () =&gt; {
  render(&lt;PizzaShopApp /&gt;);
  const shoppingCartContainer = screen.getByTestId('shopping-cart');
  const placeOrderButton = within(shoppingCartContainer).
</span><span class="koboSpan" id="kobo.386.2">  getByRole('button');
  expect(placeOrderButton).toBeInTheDocument();
})</span></pre> <p><span class="koboSpan" id="kobo.387.1">The Jest test renders the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.389.1"> component and then locates a shopping cart container by its </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">data-testid</span></strong><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">Within this container, it looks for a button element by its role. </span><span class="koboSpan" id="kobo.391.3">The test concludes by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">toBeInTheDocument()</span></strong><span class="koboSpan" id="kobo.393.1"> matcher to verify that this button is present in the rendered output.</span></p>
<p><span class="koboSpan" id="kobo.394.1">To make this test pass, we can add an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">div</span></strong><span class="koboSpan" id="kobo.396.1"> as a container with </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">data-testid</span></strong><span class="koboSpan" id="kobo.398.1">, and put an empty button inside it:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
export function PizzaShopApp() {
  return &lt;&gt;
    &lt;h1&gt;The Code Oven&lt;/h1&gt;
    &lt;ol&gt;
      {pizzas.map((x) =&gt; &lt;li&gt;{x}&lt;/li&gt;)}
    &lt;/ol&gt;
    &lt;div data-testid="shopping-cart"&gt;
      &lt;button&gt;&lt;/button&gt;
    &lt;/div&gt;
  &lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.400.1">As the tests pass, we can add more details</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.401.1"> to the test, checking if the button is disabled by default.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.402.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.403.1">Observe how we oscillate between the test code and the actual implementation, especially in the beginning. </span><span class="koboSpan" id="kobo.403.2">As you become more accustomed to the Red-Green-Refactor cycle, you’ll be able to write increasingly complex tests and adjust your code to pass them. </span><span class="koboSpan" id="kobo.403.3">The key objective initially is to establish this rapid feedback loop.</span></p>
<p><span class="koboSpan" id="kobo.404.1">We should now add a few more details to the test, to check the button text and the disabled status by default – we want to make sure users cannot interact with the button:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
it('renders a shopping cart', () =&gt; {
  render(&lt;PizzaShopApp /&gt;);
  const shoppingCartContainer = screen.getByTestId('shopping-cart');
  const placeOrderButton = within(shoppingCartContainer).
</span><span class="koboSpan" id="kobo.405.2">   getByRole('button');
  expect(placeOrderButton).toBeInTheDocument();
  expect(placeOrderButton).toHaveTextContent('Place My Order');
  expect(placeOrderButton).toBeDisabled();
})</span></pre> <p><span class="koboSpan" id="kobo.406.1">With the new assertions added, the test failed again, waiting for us to add more details to the implementation. </span><span class="koboSpan" id="kobo.406.2">It’s straightforward to make the test pass by adding the text and </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">disabled</span></strong><span class="koboSpan" id="kobo.408.1"> status:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
export function PizzaShopApp() {
  return &lt;&gt;
    &lt;h1&gt;The Code Oven&lt;/h1&gt;
    &lt;ol&gt;
      {pizzas.map((x) =&gt; &lt;li&gt;{x}&lt;/li&gt;)}
    &lt;/ol&gt;
    &lt;div data-testid="shopping-cart"&gt;
      &lt;button disabled&gt;Place My Order&lt;/button&gt;
    &lt;/div&gt;
  &lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.410.1">The tests are all passing again, so that’s another task</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.411.1"> to tick off (note how maintaining a task list can help us focus and gradually shape our application code).</span></p>
<p><span class="koboSpan" id="kobo.412.1">Next, we will look at the next task – adding</span><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.413.1"> items from the menu to the shopping cart.</span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.414.1">Adding items to the shopping cart</span></h1>
<p><span class="koboSpan" id="kobo.415.1">Once we have the basic structure</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.416.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.418.1"> component, we need to add</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.419.1"> a few more assertions to verify it works. </span><span class="koboSpan" id="kobo.419.2">We will start by adding one item to the cart, which can be done with the following code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
it('adds menu item to shopping cart', () =&gt; {
  render(&lt;PizzaShopApp /&gt;);
  const menuList = screen.getByRole('list');
  const menuItems = within(menuList).getAllByRole('listitem');
  const addButton = within(menuItems[0]).getByRole('button');
  userEvent.click(addButton);
  const shoppingCartContainer = screen.getByTestId('shopping-cart');
  const placeOrderButton = within(shoppingCartContainer).
</span><span class="koboSpan" id="kobo.420.2">   getByRole('button');
  expect(within(shoppingCartContainer).getByText('Margherita Pizza')).
</span><span class="koboSpan" id="kobo.420.3">   toBeInTheDocument();
  expect(placeOrderButton).toBeEnabled();
})</span></pre> <p><span class="koboSpan" id="kobo.421.1">This test renders the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.423.1"> component, fetches the menu list, and grabs all the list items within it. </span><span class="koboSpan" id="kobo.423.2">Then, it simulates</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.424.1"> a user clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">Add</span></strong><span class="koboSpan" id="kobo.426.1"> button of the first menu item. </span><span class="koboSpan" id="kobo.426.2">Next, it locates</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.427.1"> the shopping cart container and checks two things:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.428.1">The added item, </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">Margherita Pizza</span></strong><span class="koboSpan" id="kobo.430.1">, appears in the cart</span></li>
<li><span class="koboSpan" id="kobo.431.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">Place My Order</span></strong><span class="koboSpan" id="kobo.433.1"> button is enabled</span></li>
</ul>
<p><span class="koboSpan" id="kobo.434.1">Let’s add the button to a menu item first, and then add a state to manage the user selection</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.435.1"> and enable the </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">Place My Order</span></strong><span class="koboSpan" id="kobo.437.1"> button according</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.438.1"> to the selection:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.439.1">
export function PizzaShopApp() {
  const [cartItems, setCartItems] = useState&lt;string[]&gt;([]);
  const addItem = (item: string) =&gt; {
    setCartItems([...cartItems, item]);
  }
  return &lt;&gt;
    &lt;h1&gt;The Code Oven&lt;/h1&gt;
    &lt;ol&gt;
      {pizzas.map((x) =&gt; &lt;li&gt;
        {x}
        &lt;button onClick={() =&gt; addItem(x)}&gt;Add&lt;/button&gt;
      &lt;/li&gt;)}
    &lt;/ol&gt;
    &lt;div data-testid="shopping-cart"&gt;
      &lt;ol&gt;
        {cartItems.map(x =&gt; &lt;li&gt;{x}&lt;/li&gt;)}
      &lt;/ol&gt;
      &lt;button disabled=&gt;Place My Order&lt;/button&gt;
    &lt;/div&gt;
  &lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.440.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.442.1"> function component uses React’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">useState</span></strong><span class="koboSpan" id="kobo.444.1"> Hook to manage an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">cartItems</span></strong><span class="koboSpan" id="kobo.446.1">. </span><span class="koboSpan" id="kobo.446.2">It defines a function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">addItem</span></strong><span class="koboSpan" id="kobo.448.1">, to add items to this cart. </span><span class="koboSpan" id="kobo.448.2">The component renders a list of pizzas, each with an </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">Add</span></strong><span class="koboSpan" id="kobo.450.1"> button. </span><span class="koboSpan" id="kobo.450.2">Clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">Add</span></strong><span class="koboSpan" id="kobo.452.1"> button invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">addItem</span></strong><span class="koboSpan" id="kobo.454.1"> function, adding the corresponding pizza to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">cartItems</span></strong><span class="koboSpan" id="kobo.456.1"> array.</span></p>
<p><span class="koboSpan" id="kobo.457.1">The shopping cart displays the items in </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">cartItems</span></strong><span class="koboSpan" id="kobo.459.1"> in a list. </span><span class="koboSpan" id="kobo.459.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">Place My Order</span></strong><span class="koboSpan" id="kobo.461.1"> button’s disabled state is controlled by the length of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">cartItems</span></strong><span class="koboSpan" id="kobo.463.1"> array. </span><span class="koboSpan" id="kobo.463.2">Specifically, the button is disabled when the cart is empty – </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">(cartItems.length === </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">0)</span></strong><span class="koboSpan" id="kobo.466.1">.</span></p>
<p><span class="koboSpan" id="kobo.467.1">The implementation looks great, but if we run</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.468.1"> the tests, something weird happens. </span><span class="koboSpan" id="kobo.468.2">The test failed</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.469.1"> in the terminal with the following error message: </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">TestingLibraryElementError: Found multiple elements with the role "list"</span></strong><span class="koboSpan" id="kobo.471.1">. </span><span class="koboSpan" id="kobo.471.2">This is because we have two lists (one in the menu and the other in the shopping cart) on the screen now, and the React Testing Library is confused about which one should look for the </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">Add</span></strong><span class="koboSpan" id="kobo.473.1"> button, and which one should look for the added items. </span><span class="koboSpan" id="kobo.473.2">We can fix that by adding a more specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">data-testid</span></strong><span class="koboSpan" id="kobo.475.1"> to the menu list and modifying the test accordingly.</span></p>
<p><span class="koboSpan" id="kobo.476.1">Firstly, let’s change our </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.478.1"> component and move the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">&lt;ol&gt;</span></strong><span class="koboSpan" id="kobo.480.1"> (the ordered list tag) into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">div</span></strong><span class="koboSpan" id="kobo.482.1"> element attributed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">data-testid="menu-list"</span></strong><span class="koboSpan" id="kobo.484.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.485.1">
&lt;div data-testid="menu-list"&gt;
  &lt;ol&gt;
    {pizzas.map((x) =&gt; &lt;li&gt;
      {x}
      &lt;button onClick={() =&gt; addItem(x)}&gt;Add&lt;/button&gt;
    &lt;/li&gt;)}
  &lt;/ol&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.486.1">Then, we must modify the test so that it looks as follows (note that we explicitly ask the React Testing Library to search inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">menu-list</span></strong><span class="koboSpan" id="kobo.488.1"> for all list items):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
it('adds menu item to shopping cart', () =&gt; {
  render(&lt;PizzaShopApp /&gt;);
  const menuItems = within(screen.getByTestId('menu-list')).
</span><span class="koboSpan" id="kobo.489.2">   getAllByRole('listitem');
  const addButton = within(menuItems[0]).getByRole('button');
  userEvent.click(addButton);
  const shoppingCartContainer = screen.getByTestId('shopping-cart');
  const placeOrderButton = within(shoppingCartContainer).
</span><span class="koboSpan" id="kobo.489.3">   getByRole('button');
  expect(within(shoppingCartContainer).getByText('Margherita Pizza')).
</span><span class="koboSpan" id="kobo.489.4">   toBeInTheDocument();
  expect(placeOrderButton).toBeEnabled();
})</span></pre> <p><span class="koboSpan" id="kobo.490.1">When we re-run the test, it fails again with this message: </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">TestingLibraryElementError: Unable to find an element with the text: Margherita Pizza</span></strong><span class="koboSpan" id="kobo.492.1">. </span><span class="koboSpan" id="kobo.492.2">This could be because the text is broken up by multiple elements. </span><span class="koboSpan" id="kobo.492.3">In this case, you can provide a function for your text matcher to make your matcher more flexible.</span></p>
<p><span class="koboSpan" id="kobo.493.1">The expected </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">Margherita Pizza</span></strong><span class="koboSpan" id="kobo.495.1"> doesn’t show up in the shopping</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.496.1"> cart. </span><span class="koboSpan" id="kobo.496.2">This is because we use an event to trigger React</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.497.1"> to re-render by modifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">cartItems</span></strong><span class="koboSpan" id="kobo.499.1"> state. </span><span class="koboSpan" id="kobo.499.2">But when React detects the state change and re-renders, the test isn’t waiting for that to happen. </span><span class="koboSpan" id="kobo.499.3">In other words, it’s too early for the test to see the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">cartItems</span></strong><span class="koboSpan" id="kobo.501.1">. </span><span class="koboSpan" id="kobo.501.2">We need to give React a bit of time to digest the change and re-render. </span><span class="koboSpan" id="kobo.501.3">We can mark the test case as </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">async</span></strong><span class="koboSpan" id="kobo.503.1"> and wait for </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">userEvent.click</span></strong><span class="koboSpan" id="kobo.505.1"> to make the state change:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
it('adds menu item to shopping cart',  async () =&gt; {
  render(&lt;PizzaShopApp /&gt;);
  const menuItems = within(screen.getByTestId('menu-list')).getAllByRole('listitem');
  const addButton = within(menuItems[0]).getByRole('button');
  await userEvent.click(addButton);
  const shoppingCartContainer = screen.getByTestId('shopping-cart');
  const placeOrderButton = within(shoppingCartContainer)
   .getByRole('button');
  expect(within(shoppingCartContainer).getByText('Margherita Pizza')).
</span><span class="koboSpan" id="kobo.506.2">   toBeInTheDocument();
  expect(placeOrderButton).toBeEnabled();
})</span></pre> <p><span class="koboSpan" id="kobo.507.1">In this code snippet, the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">async</span></strong><span class="koboSpan" id="kobo.509.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">await</span></strong><span class="koboSpan" id="kobo.511.1"> ensures that the asynchronous operations are completed </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.512.1">before they move on to the next step in the test. </span><span class="koboSpan" id="kobo.512.2">The test function</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.513.1"> itself is marked as async, making it return a Promise, which Jest will wait for before considering the test complete.</span></p>
<p><span class="koboSpan" id="kobo.514.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">await userEvent.click(addButton);</span></strong><span class="koboSpan" id="kobo.516.1"> line is particularly important here. </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">userEvent.click</span></strong><span class="koboSpan" id="kobo.518.1"> simulates a real user clicking a button and might trigger state updates or effects in your React component. </span><span class="koboSpan" id="kobo.518.2">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">await</span></strong><span class="koboSpan" id="kobo.520.1"> ensures that all associated updates and effects are fully completed before moving on to the subsequent lines of the test.</span></p>
<p><span class="koboSpan" id="kobo.521.1">By ensuring that </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">userEvent.click</span></strong><span class="koboSpan" id="kobo.523.1"> has been fully processed, the test will then safely proceed to query and assert against the updated DOM or state. </span><span class="koboSpan" id="kobo.523.2">This is crucial for preventing false negatives, where the test might fail not because the code is incorrect, but because the test</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.524.1"> is checking the DOM</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.525.1"> before all updates have occurred.</span></p>
<p><span class="koboSpan" id="kobo.526.1">Since all the tests are passing again, it’</span><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.527.1">s time to look into other opportunities for improvement.</span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.528.1">Refactoring the code</span></h1>
<p><span class="koboSpan" id="kobo.529.1">The code we have now isn’t too hard</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.530.1"> to understand, but it has some room for improvement. </span><span class="koboSpan" id="kobo.530.2">Let’s quickly look at what we have got so far:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
export function PizzaShopApp() {
  const [cartItems, setCartItems] = useState&lt;string[]&gt;([]);
  const addItem = (item: string) =&gt; {
    setCartItems([...cartItems, item]);
  }
  return &lt;&gt;
    &lt;h1&gt;The Code Oven&lt;/h1&gt;
    &lt;div data-testid="menu-list"&gt;
      &lt;ol&gt;
        {pizzas.map((x) =&gt; &lt;li&gt;
          {x}
          &lt;button onClick={() =&gt; addItem(x)}&gt;Add&lt;/button&gt;
        &lt;/li&gt;)}
      &lt;/ol&gt;
    &lt;/div&gt;
    &lt;div data-testid="shopping-cart"&gt;
      &lt;ol&gt;
        {cartItems.map(x =&gt; &lt;li&gt;{x}&lt;/li&gt;)}
      &lt;/ol&gt;
      &lt;button disabled={cartItems.length === 0}&gt;Place My Order
       &lt;/button&gt;
    &lt;/div&gt;
  &lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.532.1">Now, let’s make some changes. </span><span class="koboSpan" id="kobo.532.2">Firstly, we could use the </span><strong class="bold"><span class="koboSpan" id="kobo.533.1">Rename Variable</span></strong><span class="koboSpan" id="kobo.534.1"> refactoring to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">x</span></strong><span class="koboSpan" id="kobo.536.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">item</span></strong><span class="koboSpan" id="kobo.538.1">, to make it a bit more meaningful. </span><span class="koboSpan" id="kobo.538.2">Also, there is a warning in the terminal now, saying </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">Warning: Each child in a list should have a unique "key" prop</span></strong><span class="koboSpan" id="kobo.540.1"> – as React expects a unique key for each item it renders, we need to have a key for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.542.1"> element. </span><span class="koboSpan" id="kobo.542.2">For now, we can use the item (the pizza name) as the key</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.543.1"> to fix this issue:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
export function PizzaShopApp() {
  const [cartItems, setCartItems] = useState&lt;string[]&gt;([]);
  const addItem = (item: string) =&gt; {
    setCartItems([...cartItems, item]);
  }
  return &lt;&gt;
    &lt;h1&gt;The Code Oven&lt;/h1&gt;
    &lt;div data-testid="menu-list"&gt;
      &lt;ol&gt;
        {pizzas.map((item) =&gt; &lt;li key={item}&gt;
          {item}
          &lt;button onClick={() =&gt; addItem(item)}&gt;Add&lt;/button&gt;
        &lt;/li&gt;)}
      &lt;/ol&gt;
    &lt;/div&gt;
    &lt;div data-testid="shopping-cart"&gt;
      &lt;ol&gt;
        {cartItems.map(item =&gt; &lt;li key={item}&gt;{item}&lt;/li&gt;)}
      &lt;/ol&gt;
      &lt;button disabled={cartItems.length === 0}&gt;Place My Order
       &lt;/button&gt;
    &lt;/div&gt;
  &lt;/&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.545.1">As another change, the menu item</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.546.1"> list looks pretty self-contained and doesn’t depend on anything out of the context it lives in, so we can extract a new component here to encapsulate that logic:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.547.1">
const MenuList = ({
  onAddMenuItem,
}: {
  onAddMenuItem: (item: string) =&gt; void;
}) =&gt; {
  return (
    &lt;div data-testid="menu-list"&gt;
      &lt;ol&gt;
        {pizzas.map((item) =&gt; (
          &lt;li key={item}&gt;
            {item}
            &lt;button onClick={() =&gt; onAddMenuItem(item)}&gt;Add&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ol&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.548.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">MenuList</span></strong><span class="koboSpan" id="kobo.550.1"> component takes a single prop, </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">onAddMenuItem</span></strong><span class="koboSpan" id="kobo.552.1">, which is a function that accepts a string argument representing a menu item. </span><span class="koboSpan" id="kobo.552.2">The component renders a list of pizzas, which presumably is an array of strings. </span><span class="koboSpan" id="kobo.552.3">For each pizza, it creates a list item and an </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">Add</span></strong><span class="koboSpan" id="kobo.554.1"> button. </span><span class="koboSpan" id="kobo.554.2">When this button</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.555.1"> is clicked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">onAddMenuItem</span></strong><span class="koboSpan" id="kobo.557.1"> function is called with the corresponding pizza name as an argument. </span><span class="koboSpan" id="kobo.557.2">The component uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">data-testid="menu-list"</span></strong><span class="koboSpan" id="kobo.559.1"> attribute to make it easier to query this section during testing. </span><span class="koboSpan" id="kobo.559.2">Overall, this is a presentational component that’s designed to display a list of pizzas and handle the addition of menu items through the provided callback.</span></p>
<p><span class="koboSpan" id="kobo.560.1">Similarly, we can extract a new component for the shopping cart, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.561.1">
const ShoppingCart = ({ cartItems }: { cartItems: string[] }) =&gt; {
  return (
    &lt;div data-testid="shopping-cart"&gt;
      &lt;ol&gt;
        {cartItems.map((item) =&gt; (
          &lt;li key={item}&gt;{item}&lt;/li&gt;
        ))}
      &lt;/ol&gt;
      &lt;button disabled={cartItems.length === 0}&gt;Place My Order
       &lt;/button&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.562.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.564.1"> component takes an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">cartItems</span></strong><span class="koboSpan" id="kobo.566.1"> as its prop. </span><span class="koboSpan" id="kobo.566.2">This array holds the names of the items</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.567.1"> that have been added to the shopping cart. </span><span class="koboSpan" id="kobo.567.2">The component renders an ordered list (</span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">&lt;ol&gt;</span></strong><span class="koboSpan" id="kobo.569.1">) where each list item (</span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.571.1">) corresponds to an item in the cart. </span><span class="koboSpan" id="kobo.571.2">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">data-testid="shopping-cart"</span></strong><span class="koboSpan" id="kobo.573.1"> attribute to make it easier to identify this component in tests. </span><span class="koboSpan" id="kobo.573.2">Additionally, a </span><strong class="bold"><span class="koboSpan" id="kobo.574.1">Place My Order</span></strong><span class="koboSpan" id="kobo.575.1"> button is rendered at the bottom of the list. </span><span class="koboSpan" id="kobo.575.2">The button is disabled if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">cartItems</span></strong><span class="koboSpan" id="kobo.577.1"> array is empty, meaning there are no items in the cart. </span><span class="koboSpan" id="kobo.577.2">Overall, this component is designed to display the items in the shopping cart and provide an option to place an order.</span></p>
<p><span class="koboSpan" id="kobo.578.1">After these extractions, we can use these components in the main component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">PizzaShopApp</span></strong><span class="koboSpan" id="kobo.580.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
export function PizzaShopApp() {
  const [cartItems, setCartItems] = useState&lt;string[]&gt;([]);
  const addItem = (item: string) =&gt; {
    setCartItems([...cartItems, item]);
  };
  return (
    &lt;&gt;
      &lt;h1&gt;The Code Oven&lt;/h1&gt;
      &lt;MenuList onAddMenuItem={addItem} /&gt;
      &lt;ShoppingCart cartItems={cartItems} /&gt;
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.582.1">During these relatively big changes, our tests always stay in the green state – meaning no functions are broken. </span><span class="koboSpan" id="kobo.582.2">We haven’t implemented all the tasks we have broken down, but I believe you have got the idea of the Red-Green-Refactor loop. </span><span class="koboSpan" id="kobo.582.3">You can use the remaining tasks as exercises, making sure you always write the test first, with only the minimal code, and looking for improvements after the test passes.</span></p>
<p><span class="koboSpan" id="kobo.583.1">You may initially find this coding approach</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.584.1"> challenging as it requires you to resist the temptation to immediately delve into implementation. </span><span class="koboSpan" id="kobo.584.2">Instead, take incremental steps and savor the journey. </span><span class="koboSpan" id="kobo.584.3">You’ll soon discover the strength that lies in taking small steps, as well as how mainta</span><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.585.1">ining a steady rhythm can enhance your focus and productivity.</span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.586.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.587.1">In this chapter on TDD, we’ve explored various forms of TDD, emphasizing the importance of breaking down complex problems into manageable tasks through tasking. </span><span class="koboSpan" id="kobo.587.2">We delved into two key approaches – top-down and bottom-up, each with its distinct merits and use cases. </span><span class="koboSpan" id="kobo.587.3">To illustrate these concepts, we used a practical example of building a pizza shop application.</span></p>
<p><span class="koboSpan" id="kobo.588.1">This hands-on example helped solidify the theories and methodologies we discussed, providing a comprehensive understanding of how TDD can be employed effectively in different scenarios.</span></p>
<p><span class="koboSpan" id="kobo.589.1">In the upcoming chapter, we’ll delve deeper into the intricate world of data management in React applications. </span><span class="koboSpan" id="kobo.589.2">Specifically, we’ll explore various design patterns that are commonly adopted for efficient data access and manipulation.</span></p>
</section>


<section class="Content" epub:type="part" id="_idContainer045" role="doc-part">
<h1 id="_idParaDest-115"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.1.1">Part 3: Unveiling Business Logic and Design Patterns</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part looks at business logic and design patterns, which are essential in tackling common challenges in state management and adhering to principles, such as the single responsibility principle, in order to maintain a clean and efficient code base.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This part contains the following chapters:</span></p>
<ul>
<li><a href="B21103_08.xhtml#_idTextAnchor212"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Exploring Data Management in React</span></em></li>
<li><a href="B21103_09.xhtml#_idTextAnchor227"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Applying Design Principles in React</span></em></li>
<li><a href="B21103_10.xhtml#_idTextAnchor251"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Diving Deep into Composition Patterns</span></em></li>
</ul>
</section>
</body></html>