- en: Chapter 8. Deploying Your App to the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to create a production pipeline for our apps. This
    involves splitting your configuration files for development and production as
    well as making a production-ready instance of your Node.js server. First we'll
    look at how to set up a production-ready deployment of the Browserify scaffold
    from [Chapter 1](ch01.html "Chapter 1. Diving Headfirst into ReactJS"), *Diving
    Headfirst Into React*, and then we'll look at how to do the same with Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Using a cloud server is the most cost-efficient way to deploy your code. Before
    the cloud became a viable option, you would often have to deploy your code to
    your physical server, situated in a single data center. If you want to deploy
    your code to several data centers, you'd need to purchase or rent more physical
    servers, often at a significant cost.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud changes this because now you can deploy your code to a cloud provider
    who has data centers all over the world. The cost of deploying your app in the
    U.S. as well as in Europe and Asia is usually the same and relatively inexpensive
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics we''ll cover in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a cloud provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a Browserify app for the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a Webpack app for the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a cloud provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a vast number of decent cloud providers available to choose from.
    Among the most popular and mature providers are **Heroku**, **Microsoft Azure**,
    **Amazon**, **Google App Engine**, and **Digital Ocean**. All of them come with
    their own set of advantages and disadvantages, so it's well worth investigating
    each one of them before you decide to choose which one to go for.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we've used Heroku throughout to deploy our apps, and we'll set
    up our deployments to target this platform. Let's take a brief look at the advantages
    and disadvantages of using Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to use. After the initial sign-up, you usually only need to issue a single
    Git push to deploy your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to scale when traffic to your app increases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides great plugin support for third-party apps and cloud services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free basic tier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No infrastructure management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Can get pricey. Heroku offers a generous free tier, but the first rung of the
    price ladder is pretty steep.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vendor lock-in issue; it's a lot of work moving from Heroku to another cloud
    provider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic tier was sufficient for a while, but recently, Heroku has added a
    policy that the free instance must be inactive for 6 hours every 24 hours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment gets wiped irregularly. You can't log in to the instance and
    make local changes to the environment because they will be gone the next time
    the instance is refreshed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because it's relatively easy to get going with Heroku, we'll be using Heroku
    for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Start with signing up for a free account at [https://signup.heroku.com/](https://signup.heroku.com/).
    After you've done this, download the Heroku toolbelt from [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/).
    You also need to upload your SSH key. If you need help in generating an SSH key,
    visit [https://devcenter.heroku.com/articles/keys](https://devcenter.heroku.com/articles/keys).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the setup is done, you can create a Heroku app by issuing this command
    in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can omit the name, in which case Heroku will provide you with a random
    one. Note that Heroku requires Git. If you have a Git repository already, Heroku
    will automatically add the configuration parameters to your `.git/config` file.
    If not, you will have to do it manually later. The parameters look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can find the configuration file inside the `.git` folder (note the dot).
    The file is called `config`, so the full path is `.git/config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy your app, add the files to your repository and commit your changes.
    Then, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Your app will then be deployed, based on the master branch. You can deploy other
    branches by typing in `git push heroku yourbranch:master` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up cloud deployment with npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we try to publish our scaffold right off the bat, we'll probably end up with
    an error because we haven't told Heroku how to serve our app. Heroku will simply
    try running the app with `npm start`.
  prefs: []
  type: TYPE_NORMAL
- en: The `npm` package is the backbone of Node.js. We've covered it briefly in previous
    chapters, but as we're going to depend heavily on it now, it's time to take a
    closer look at what it can do for you.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of or even used task runners such as **Grunt**, **Gulp**,
    or **Broccoli**. They are great at automating tasks so that you can focus on writing
    code rather than performing repetitive tasks, such as minifying and bundling your
    code, copying and concatenating stylesheets, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, for most tasks, you're better off letting `npm` do the job for you. With
    `npm` scripts, you have all the power you need to automate common tasks, with
    less overhead and maintenance to boot.
  prefs: []
  type: TYPE_NORMAL
- en: The `npm` package comes with a few built-in commands, one of which is `npm run-script`
    (`npm run` for short). This command extracts the scripts object from `package.json`.
    The first argument passed to `npm run` refers to a property in the scripts object.
    For any property you create yourself, you need to run them with `npm run`. A few
    property names have been reserved, such as `start`, `stop`, `restart`, `install`,
    `publish`, `test`, and so on. They can be invoked by simply executing `npm start`
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important thing to note is that `npm run foo` will also run `prefoo` and
    `postfoo` if defined. You can run each stage separately by executing `npm run
    prefoo` or `postfoo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute `npm run` to see the available scripts; you''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is interesting. We haven't made a start script, yet `npm` `run` tells us
    that `npm start` will run `node server.js`. This is another default of node. If
    you haven't specified a start script and there is a `server.js` file in your root,
    then this will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku still won't run the scaffold because the express server is configured
    to start a develop session with Webpack and hot reloading. You need to create
    a production server in addition to your develop server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can approach this in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to introduce `environment` flags in your server code, such as
    this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The other option is to create an independent production `server` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either way is good, but it's arguably cleaner to use a separate file, so we'll
    go with that approach.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your Browserify app for cloud deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use the shop application we developed in [Chapter 2](ch02.html
    "Chapter 2. Creating a Web Shop"), *Creating a Web Shop*. The app uses Browserify
    to bundle the code and node to run the development server. We'll keep on using
    the node in production, but we'll need to set up a specific `server` file in order
    to make a production-ready app.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, this is how our shop app looks like before we start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll take these steps to make it cloud-ready:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a production server file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install production dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `package.json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transpile our code base to EcmaScript 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file called `server.prod.js` and put it in the root of your project.
    Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re defining an express server and setting up a host and a `port` variable.
    The defaults are port `8080` on `0.0.0.0`. This host address is functionally identical
    to localhost when running on your local machine, but it can make a difference
    when running on your server. If the server host has several IP addresses, specifying
    `0.0.0.0` as the host will match any request. Using a parameter such as localhost
    can result in a situation where the server will be unable to bind your app and
    fail to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re going to be serving files to the public, it''s worth compressing
    them with **GZIP** before serving them. For text and script files, the savings
    can be dramatic, up to 80-90 percent in many cases. For a low-traffic site, this
    implementation is good enough. For a high-traffic site, the best way to put compression
    in place is to implement it at a reverse proxy level, for instance, by using **nginx**.
    We''ll route all requests to our `public` folder and the desired filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the server will start with a debug message telling us the address
    of the deployed app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we need to do is create a `build` script to bundle our JavaScript
    code. When running the development server, the code is bundled automatically.
    This bundle is usually rather large. For instance, the development bundle for
    the shop app is 1.4 MB. Even with compression enabled, this file is arguably too
    large to present to your users. When deploying to production, we need to create
    a smaller bundle so that your app will download and be ready to use faster. Fortunately,
    this is rather easy.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use a combination of the CLI version of Browserify and UglifyJS.
    The latter is a compression tool that strips out newlines, shortens variable names,
    and strips out unused code from our bundle. We'll run it by first bundling our
    source files with Browserify, then we'll use the pipe operator (`|`) to send the
    output to UglifyJS. The result of this operation is then sent to a `bundle` file
    with the greater-than operator (`>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the sequence looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you run this, the entire bundle will be returned as a string output. You
    can optionally specify `-o bundle.js` in order to save the result to a bundle
    file. We don't want to do this because we have no use for a temporary bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the sequence looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have specified a few arguments, so let's look at what they do.
  prefs: []
  type: TYPE_NORMAL
- en: The `-p` argument skips the prefix for the original filenames that appear in
    the source name. The saving here is very small, but it's worth keeping in there
    nonetheless. The number after the argument is the number of relative paths dropped.
  prefs: []
  type: TYPE_NORMAL
- en: The `-c` option is short for compressor. By not specifying any compressor option,
    the default compress option will be used. This saves quite a few bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The next is `drop_console=true`. This tells UglifyJS to remove any console logs.
    This is useful if you've used this method for debugging your app and have forgotten
    to remove it from your code.
  prefs: []
  type: TYPE_NORMAL
- en: The next one is `-m`, which is short for mangle. This option changes and shortens
    your variable and function names and is a serious byte-saving factor.
  prefs: []
  type: TYPE_NORMAL
- en: The final two arguments won't save any bytes, but they're still useful. The
    `--max-line-len` argument will break up the uglified code if the line length is
    above a given value (defaults to 32,000 characters). This is useful when supporting
    older browsers that can't cope with very long lines. The `––inline-script` argument
    escapes the slash in the occurrences of `</script` in strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this command on its own won''t result in a compressed bundle because
    we haven''t specified an input. If you store the bundle in a temporary file, you
    could send the content to the preceding command by using the less-than operator
    and the filename like this: `< bundle.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll send the result to the output location we desire by using the
    greater-than operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full command sequence looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running the first part results in a bundle size that's approximately 1.4 MB.
    Passing it through UglifyJS results in a bundle size of about 548 KB. If you drop
    the options and go with vanilla UglifyJS, you'll end up with a bundle size that's
    about 871 KB.
  prefs: []
  type: TYPE_NORMAL
- en: After bundling and minifying, we're now ready to deploy our app to the cloud.
    Since we're using compression, the final bundle size will be approximately 130
    KB. That's a huge win when compared to the original file size of 1.4 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Before we deploy our code, we need to tell Heroku how to start our app. We'll
    do this by adding a single file called `Procfile`. This is a special file that
    Heroku will read and execute if it exists. If it doesn't exist, Heroku will try
    to execute `npm start` instead; if this fails, try to run `node server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Procfile` file with this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''ve done this, commit your code and push to Heroku by executing this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result should look identical to the local app, except that now you''re
    running it on the cloud. The example app is available on [https://reactjsblueprints-webshop.herokuapp.com/](https://reactjsblueprints-webshop.herokuapp.com/).
    The following screenshot displays the web page of the preceding link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The actual process](img/B04943_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's very tough to remember the entire command sequence for generating a minified
    Browserify bundle. We'll add it to `package.json` so we can execute it with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `package.json` and replace the contents in the `scripts` section with
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now you can run the bundle operation with `npm run bundle`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Webpack app to the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use the Webpack scaffold we developed in [Chapter 6](ch06.html
    "Chapter 6. Advanced React"), *Advanced React*. We'll need to add a few packages
    and make some modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, this is the file structure of our scaffold before we start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by renaming our `server.js` file to `server-development.js`. Then,
    create a new file called `server-production.js` in the root of the scaffold and
    add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we instruct the server to use the preconfigured variables for `PORT`
    and `HOST` or the default variables if these aren''t provided, just as we did
    with the Browserify server. Then, we add an error handler so that we are able
    to respond to errors gracefully. This could also be added to the Browserify server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We add compression as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we move on to the `assets` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll copy the `asset` files we need manually. We only have two, so it''s
    okay to do this manually. If we had many files to copy, another approach might
    be more beneficial. An option that is cross-compatible across different environments
    is **ShellJS**. With this extension, you can set up ordinary `shell` commands
    and have them executed in a JavaScript environment. We won''t do this in this
    project but it''s worth looking into. Now refer to the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we set the `environment` to `production`, and we let Express know that
    our static files are placed in the `./public/assets` folder using the `serve-static`
    middleware. This means we can refer to `/app.css` in our file, and Express will
    know to look for it in the correct `assets` folder. For low-traffic apps, this
    is a good implementation, but for a high-traffic app, it''s better to use a reverse
    proxy to serve static files. The main benefit of using a reverse proxy is to remove
    load from your dynamic server to other servers specially designed to handle assets.
    We route all requests to `index.html`. This will not apply to files that exist
    in the `static` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the `server` object so that we can pass it to the error handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we respond to errors and conditionally shut down the server. The `server`
    object is passed as an argument so that the error handler can shut it down gracefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we start the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you''ve noticed, we''ve added a few new packages. Install these with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All modules that are required in `server.prod.js` need to be moved to the `dependencies`
    section in `package.json`. Your dependencies section should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: All dependencies that Heroku needs must be put in the normal dependencies section
    because Heroku will omit all packages in `devDependencies`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dependency strategy for cloud deployment**'
  prefs: []
  type: TYPE_NORMAL
- en: Since downloading and installing packages from `npm` is rather slow, it's a
    good practice to put packages you only need when developing in `devDependencies`
    and vice-versa. We've been doing this throughout the entire book, so hopefully
    you're already following this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost done, but we need to create a production version of `webpack.config.js`,
    `index.html` and add the build scripts before we're ready.
  prefs: []
  type: TYPE_NORMAL
- en: Rename your existing `webpack.config.js` file to `Webpack-development.config.js`,
    and then create a file called `Webpack-production.config.js`. Note that this means
    you need to change the Webpack import in `server-development.js` to reflect this
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin reorders the packages so that the most used one is put at the top.
    This should reduce the file size and make the bundle more efficient. We specify
    that this is a production build so that Webpack utilizes the most byte-saving
    algorithm it has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also tell it to use UglifyJS to compress our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `production` configuration of Webpack, we remove the hot loader plugin
    since it only makes sense to have it included when developing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a file called `index-production.html` to `assets` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add these scripts to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These scripts let you build and deploy your app. We've stopped short from actually
    committing the changes to let you know that the deploy process is ready to commence.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the build argument, we add `NODE_ENV=production` in order to prevent
    Babel from trying to use the `hot` module replacement when building the code.
    The configuration that controls this is in `.babelrc`.
  prefs: []
  type: TYPE_NORMAL
- en: Your Webpack scaffold is now production-ready!
  prefs: []
  type: TYPE_NORMAL
- en: When developing, execute `npm run dev` and enjoy a slick development environment
    with hot reloading.
  prefs: []
  type: TYPE_NORMAL
- en: On `npm deploy`, the build script is executed and it lets you know when it's
    ready to publish your changes. You need to add the changes yourself via `git add`
    and `git commit` and then run `git push heroku master`. You can, of course, automate
    this in the deploy script.
  prefs: []
  type: TYPE_NORMAL
- en: The build script can also be triggered by issuing `npm run build`. Before building
    the script, we will first execute `rimraf public`. **Rimraf** is an environment-safe
    command that deletes the `public` folder and all its contents. It's the same as
    running `rm -rf public` on Mac/Linux. This command doesn't exist on Windows, so
    running `rm` on that platform won't work, but running `rimraf` will work on either
    platform. Finally, the script executes `webpack` and builds a production bundle
    that is put in `public/assets/bundle.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, Webpack is slightly more efficient at removing unused code, so the
    final bundle sizes will be smaller than the ones generated by Browserify. The
    bundle generated in this example is about 132 KB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this is not an apples-to-apples comparison because the app we bundled
    in the Browserify section was much larger.
  prefs: []
  type: TYPE_NORMAL
- en: The final result is available at [https://reactjsblueprints-wpdeploy.herokuapp.com/](https://reactjsblueprints-wpdeploy.herokuapp.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a Webpack app to the cloud](img/B04943_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For reference, our file structure now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It's still quite manageable. Admittedly, separating the files in `prod` and
    `dev` requires a bit more handholding, but it's arguably better than switching
    the code with `if…else` loops inside different files. However, code organization
    is admittedly a thorny issue, and there is no general setup that will please everyone.
    For small modifications spanning just a few files, `if…else` statements are probably
    preferable to break up the files in production and development versions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added cloud deployment to the two scaffolds we developed
    throughout this book. A preview of both examples are available online.
  prefs: []
  type: TYPE_NORMAL
- en: Generating cloud-deployable apps generally means bundling our code as tight
    as possible. With the era of HTTP/2 upon us, this strategy may have to be revisited
    as it may be more beneficial to generate a set of files that can be downloaded
    in parallel instead of a single bundle, however small it may be. It's worth noting
    that very small files won't benefit much from *gzipping*.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to split your code bundles with Webpack. For more on code
    splitting with Webpack, take a look at [https://webpack.github.io/docs/code-splitting.html](https://webpack.github.io/docs/code-splitting.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll develop a streaming server-rendered app based on
    the production Webpack setup we just made in this chapter.
  prefs: []
  type: TYPE_NORMAL
