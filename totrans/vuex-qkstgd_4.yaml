- en: Coding the EveryNote App Using Vuex State Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will develop an application to take notes, called *EveryNote*,
    from scratch. In the first part of the chapter we will analyze and design the
    application, as well as preparing the folder structure for the project.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will build the application incrementally through tests and code.
    This application will be developed while writing this chapter, providing a real-world
    Vuex development example.
  prefs: []
  type: TYPE_NORMAL
- en: The application can be downloaded by cloning the `https://github.com/PacktPublishing/-Vuex-Condensed`
    Git repository. Each section of this chapter has a corresponding Git tag that
    can be used to download the code that has been written for that section.
  prefs: []
  type: TYPE_NORMAL
- en: 'While reading this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Design and develop an application exploiting Vuex features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Vuex inside Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test Vue/Vuex components effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use actions to handle asynchronous operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-4](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/QaPP1Q](https://goo.gl/QaPP1Q)'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the EveryNote web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to start designing an application is by creating mock-ups of the user
    interfaces. This way, you can present your mock-ups to your stakeholders, discuss
    them, update your mock-ups accordingly, and resubmit them to stakeholders. This
    can be done before you start developing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The EveryNote app will look like the following mock-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbfb3a8a-4524-4637-bd18-ef9729a75f07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: EveryNote mock-up interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show all notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update an existing note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save notes to `LocalStorage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After basic features are implemented, we will also add two more features:'
  prefs: []
  type: TYPE_NORMAL
- en: Search among notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin a note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a real-world application, you may need user stories to better define what
    the behaviors expected are and, thus, what programmers should code. These stories
    can be tested, and this type of test is called an acceptance test.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the EveryNote features are simple and well defined, so we can
    begin by picking a feature and starting to develop it.
  prefs: []
  type: TYPE_NORMAL
- en: Application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vuex proposes an application-generic structure, which we will adopt. The following
    is the folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are now going to create the project scaffold by adding some files to the
    `notes-app` folder we created at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file to be created is `index.html`. As for any Vue.js application,
    we need to put the root container for the Vue/Vuex application inside the body
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second file is `main.js`. It contains the code to startup the Vue.js part
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the Vue application is ready, we can add Vuex to it by creating `index.js`
    inside the `store` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create the root Vue component of the *EveryNote* app as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Clone the `book` repository and use `git checkout step-0_project-scaffold` to
    see all the project files for this step.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the project scaffold is ready, we can start coding the first feature.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the EveryNote app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following paragraphs, I will develop the application using test-driven
    development. You don't need to know TDD to understand what I will be doing. You
    will first be presented with a test asserting what the code should do as if it
    were already implemented, and then, just after, you will see the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: But why use TDD in this book?
  prefs: []
  type: TYPE_NORMAL
- en: One reason is that I think it is easier to understand what the code is supposed
    to do by reading assertions about its behavior inside the test code, rather than
    inferring its behavior from implementation code.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is that it is easier to understand how to test a component while
    writing the component rather than having a (boring) chapter on testing components.
  prefs: []
  type: TYPE_NORMAL
- en: Using a to-do list to help the development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I find that writing a to-do list in a file is useful for reminding me what needs
    to be done. I also find it helpful to note down doubts and simple notes on things
    I need to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: This to-do list is a simple `.txt` file that changes over time, and will hopefully
    be empty when the app is finished. I also put this file under `Git revision`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial `To-do` list looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I use the `*` symbol to mark the current feature under development.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a list of notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I will start by displaying a list of notes because the other features depend
    on it. Another possible feature to start with is the ability to create a new note.
  prefs: []
  type: TYPE_NORMAL
- en: In order to display a list of notes, we need to add that list to the application's
    `Vuex.Store`. Then we need a Vue component that uses the store to display the
    notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test is about defining a note list inside the application''s main
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, you will first see a frame detailing a component''s tests, and,
    just after, a frame with the code implementation. You will be provided with a
    description of test-driven development later on in this chapter. For now, it is
    important that you understand that TDD has a pace: one test, one piece of production
    code, one test, one piece of production code, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also referred to as red, green, refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red**: You write a small test and the result of executing it is a test failing—you''ll
    see red in the test console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: You make the test pass in the easiest way—you''ll see green in the
    test console. Duplicating code in this step is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactor**: You remove code duplication and improve code quality if you feel
    it is necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is creating a Vue component `noteList` to show the list of notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Even though I put together all of these tests in one place for better readability,
    I didn't write the three tests and then the code. I wrote the first test, then
    the code, then the next test, and so on. Remember the red-green-refactor pattern!
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write the `NoteList` code I needed three tests:'
  prefs: []
  type: TYPE_NORMAL
- en: The first test checks that there is a computed property named `notes` that exposes
    `state.store.NoteList`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test ensures that each note inside `notes` is rendered in the template
    section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the last test ensures that the note's title and content are rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, there is some code to set up the test environment in order to mock
    the store and create the component. Each item being tested should be isolated.
    This means that we cannot use the real store, and we need to provide a mocked
    one for each component being tested.
  prefs: []
  type: TYPE_NORMAL
- en: There is a framework, `vue-test-utils`, that can be used to test Vue components.
    I decided not to use it for the sake of keeping the examples in this book simple.
    You may want to use it when writing your applications.
  prefs: []
  type: TYPE_NORMAL
- en: We can now proceed to the next feature, but I would first like to see some notes
    actually shown in the browser before moving on. To achieve this, we can temporarily
    add two notes to the store and add the `NoteList` component to `App.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/538f970e-6aad-49d0-8b8e-ac8a05d2e794.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: List of notes'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the result is ugly; I will add some CSS to make it much better looking
    after all the main features are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code at this stage by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating new notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, the `To-do` list looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next feature I will implement is the ability to create new notes. For this
    feature, we need a `NoteEditor` component, a store property named `currentNote`,
    an action named `addNote`, and two mutations: `UPDATE_CURRENT_NOTE` and `ADD_NOTE`.'
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that when a user writes in the note editor, the `currentNote` store
    property gets updated. When he taps on the Add note button, the `addNote` action
    is fired, resulting in the new note added to the note list. Let's add the `currentNote`
    property to the application store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You may wonder why I added a test just to verify that the `currentNote` field
    is inside the app store. The idea here is that I am not writing tests to test
    that the application works properly—I am writing tests to write production code.
    In order to modify any line of the application code, I need a test to justify
    the fact that I am writing production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first of the three TDD rules (by Robert C. Martin, aka Uncle Bob):'
  prefs: []
  type: TYPE_NORMAL
- en: You are not allowed to write any production code unless it makes a failing unit
    test pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other two are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You are not allowed to write any more of a unit test that is sufficient to fail,
    and compilation failures are failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are not allowed to write any more production code that is sufficient to
    pass the one failing unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So why didn't I write any tests when I added two fake notes to the store and
    modified `App.vue` to use the `NoteList` component? Because that is temporary
    code and not production code. I will remove those modifications before the app
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that `currentNote` is defined, I can write an `UPDATE_CURRENT_NOTE` mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, create the `NoteEditor` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In order to code the `NoteEditor` component, I tested that the computed `content`
    and `title` properties were properly linked to `$store.state.currentNote`, and
    that these properties were used in the `template` section.
  prefs: []
  type: TYPE_NORMAL
- en: As with the tests for the `NoteList` component, the first part of the `test`
    file is just some code to create the component under `test`. I will avoid repeating
    that part from now on.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is creating the `addNote` action and the corresponding mutation
    so that I can update `NoteEditor` to dispatch this action when a user presses
    the Add note button. Following is the `ADD_NOTE` mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `addNote` action tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, I can update `NoteEditor` to dispatch the `addNote` action and see
    that the note list gets updated. First, let's update `NoteEditor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add `actions` to the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: and `NoteEditor` to `App.vue`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After having added some CSS to the components and restyling the application
    a bit, it now looks like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/831c78fb-1eda-4d3e-8e19-5f3d3626785a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: EveryNote restyled'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code at this stage by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Deleting existing notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next feature I am going to implement is the ability to delete notes. The
    following is the updated `To-do` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In order to let users delete notes, I need to update the note frame to have
    a delete button, add a `deleteNote` action, and add a `DELETE_NOTE` mutation.
    Finally, I will extract the note frame code from `NoteList` and create a `Note`
    component. Let's create the `DELETE_NOTE` mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Then let's add `deleteNote` to the actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s refactor the `NoteList` component to use a new component named `Note`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we move the test of the note rendering from the `NoteList` to the `Note`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s write the new `Note` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can add a delete button to the `Note` component, which will dispatch
    a `deleteNote` action upon being clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the updated `Note.vue` code that will make the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In order to run the preceding code, you need a `delete.svg` file. You can find
    it in the Git repository of this book, or you can use another image.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code at this stage by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Updating existing notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to edit an existing note, we could reuse the `NoteEditor` component.
    Right now, this component is linked to the `currentNote` property of the main
    store, but we could use a property to pass the note to be edited, thereby removing
    its dependency from the main store. This kind of generalization is common while
    developing Vuex applications, and often leads to two kinds of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dumb components**: These do not alter or handle application states; they
    just receive input through properties and dispatch events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart components**: These serve as containers for the dumb components; they
    handle interactions between child components and are dependent on Vuex elements,
    such as application states and actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dumb component should be designed to be reusable, whereas a smart component
    should be designed to be application dependent.
  prefs: []
  type: TYPE_NORMAL
- en: '`NoteEditor` can be refactored into a `dumb` component, letting its parent
    link it to the application''s state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I noted down these considerations on the `To-do` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, I am also considering transforming `NoteList` into
    a dumb component so that it can be used to show different lists of notes, such
    as the pinned notes or the notes that match certain search keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by refactoring `NoteEditor` into a `dumb` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the tests do not need to use Vuex anymore, and the tests regarding
    the `currentNote` state property will be moved to its container, which will be
    developed just after this component.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I decided not to test the `<template>` part of `NoteEditor.vue` because
    the views change often, and I don't want the tests to slow me down when changing
    some part of the UI. In my opinion, it is better to reduce the number of unit
    tests regarding the UI to very few or none. Remember that TDD is about writing
    code, not about testing existing code. You can write automated tests on a piece
    of UI when that piece has settled down and is unlikely to change soon. If you
    agree with me on not testing the views, remember to avoid putting a lot of logic
    in the `<template>` part of a Vue component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `NoteEditor` implementation looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need a container for this component, which is the `App.vue` component,
    plus the code that links `NoteEditor` to the `currentNote` state property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the code that will make the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need the `editNote` and `updateNote` actions and the corresponding
    mutations. The first one will set the current note under editing and the last
    one will persist changes to the note we just edited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The tests are similar to the other action tests that we completed, so I will
    not repeat them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to update the `Note` component to dispatch an `editNote` action
    when the user presses the edit icon of a note:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we modify the `App` component to show the note to be edited when
    `editNote` is dispatched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can download the code at this stage by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Other features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is the updated `To-do` list that shows what we''ve done and what''s
    remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: I will not discuss the other features in this book because I think it is now
    clear how Vuex development works and how Vuex applications can be tested. You
    can find the complete application code in the book's repository at `https://github.com/PacktPublishing/-Vuex-Condensed`.
  prefs: []
  type: TYPE_NORMAL
- en: When persisting notes to `localStorage`, instead of saving only the list of
    notes, we will use a Vuex plugin to save all the application states. You will
    read about this in the last chapter of this book, which will introduce you to
    `vuex-persistedstate`, a plugin to persist the Vuex application state with `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Recap and some considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We implemented the so-called CRUD functions, create, read, update, and delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The EveryNote application, at this stage, looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/701b0ccc-04f1-4bfc-ae15-a33242d583b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: EveryNote app with CRUD operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'When tapping on the pencil icon, the note editor opens. The following is a
    screenshot of the application in editing mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd40c9f4-9abf-4957-b93e-ebad593f2715.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: EveryNote editing dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to reach this stage of *EveryNote* development, we used a TDD approach
    and an incremental design and development process. As I promised in the introduction,
    I developed this application while writing this chapter. This means that I did
    not follow an optimal development path—in fact, I had to change some code and
    even delete some tests. That is normal while developing. At any rate, spend more
    time during the design phase in order to avoid architectural mistakes and save
    time during the development phase. In fact, a good design is fundamental, but
    it is also important not to go into too much detail while in this phase. Sometimes,
    people think that TDD bypasses design. That''s completely false—in fact, you will
    pay twice for a mistake: Once in the production code and once in the test code.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing with a remote server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing the *EveryNote* application, I decided to write an action for
    each mutation. If an action only commits a mutation, you may avoid writing this
    action and commit the corresponding mutation inside the components. Like Google
    Keep, the *EveryNote* application can be empowered by persisting notes to a remote
    server so that a user can read his or her notes from any computer or mobile device.
    In that case, actions come in handy because they can perform asynchronous operations
    to keep the application state synchronized with a server.
  prefs: []
  type: TYPE_NORMAL
- en: I will not implement the code to persist the application state with a remote
    server, but I would like to show you an example of how the list of notes can be
    fetched from a remote server when the app gets loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that when `App.vue` is loaded, we can fire a `loadNotesFromServer`
    action that will update the saved state into the `localStorage` with the list
    of notes from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `loadNotesFromServer` action tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The action code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It is a simplistic implementation—in a real case, you may need to merge the
    list of notes from the server with the notes saved in the `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we alter `App.vue` to dispatch the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a mock implementation of the API, moving the two notes from
    the store to the mock API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can download the code at this stage by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed the *EveryNote* application, going through the
    Vuex concepts and looking at how to use Vuex in a real application's development.
    We also looked at the TDD basics and saw how Vue/Vuex elements can be tested.
  prefs: []
  type: TYPE_NORMAL
- en: But what about debugging? Even with tests, a debug is sometimes needed. The
    next chapter will explain how web applications can be debugged using browser developer
    tools, as well as how to use `vue-devtools` to easily debug Vue/Vuex applications.
  prefs: []
  type: TYPE_NORMAL
