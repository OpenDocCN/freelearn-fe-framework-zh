- en: '*Chapter 1*: Exploring React Testing Library'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**React Testing Library** is a modern tool for testing the UI output of React
    components. It abstracts a lot of boilerplate code, allowing you to write code
    that is easier to read, and allows you to test the code. The library encourages
    you to move away from testing implementation details, to avoid many false negative
    and false positive test cases. Instead, the library''s API of tools makes it easy
    for you to write tests that simulate actual users'' behaviors with your components,
    yielding confidence that the application works as expected for users. Also, because
    the library urges you to focus on the user when writing tests, you don''t need
    to continuously update tests that fail when you refactor the code''s implementation
    details. The React Testing Library allows you to write tests that fail when critical
    functionality unexpectedly changes, thus providing more value.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand what the implementation details
    are and the disadvantages they bring regarding maintenance and value in your test
    cases. For many years, it has been common for teams to test their components by
    focusing on the code's implementation details. Many teams still use this approach
    today. However, there are better ways to test the components that we will cover
    in this chapter. You will learn how to add confidence to your test case planning
    by understanding how to shift your thinking toward testing from the user's perspective.
    We will introduce you to the ideas behind the **Document Object Model** (**DOM**)
    Testing Library to ease the task of testing before transitioning to the primary
    focus, the React version of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn about the Jest testing framework, tasked with executing
    and asserting our tests' output. Finally, you will learn how to install and use
    the `jest-dom` utility to enhance test assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the DOM Testing Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the role of Jest in testing React applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the advantages of using `jest-dom` to test React applications
    with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the disadvantages of implementation detail-focused testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lessons of this chapter will set the foundation for understanding how you
    will use React Testing Library throughout this book to write better tests that
    focus on the user's perspective. The skills gained in this chapter will help whether
    you are new to writing tests for React applications or are an experienced tester
    looking for better ways to verify that your code works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the examples in this chapter, you will need to have Node.js installed on
    your machine. You can find the code examples for this chapter here: [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter01](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter01).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the DOM Testing Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **DOM Testing Library** is a collection of tools created by Kent C. Dodds
    and numerous contributors to make our lives easier when our goal is to test our
    applications' UI from real users' perspectives. This section will give you an
    overview of how the library can help make testing efforts focused on users' perspectives
    a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: What is the DOM Testing Library?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DOM Testing Library makes it easier to test the UI of applications like
    real users to gain confidence that the application works as expected for users.
    There are no methods to get the component's state value or directly invoke component
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library encourages you to select DOM elements in ways that are available
    to all users. The library''s API includes accessibility-focused query methods
    allowing you to interact with the DOM like users with disabilities who require
    tools such as screen readers or other forms of assistive technology to navigate
    applications. For example, say you want to select the following element in your
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have an input element of type `"text"`. You could
    select the input on the screen by its placeholder value of `"First Name..."` with
    the DOM Testing Library like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `getByPlaceholderText` method is used from the screen object to select the
    DOM element by its placeholder value in the preceding code. The screen object
    allows you to select elements attached to the body element of the DOM. Notice
    the regular expression used in the query. It is doubtful that a user would care
    if the text were in upper or lowercase, so the DOM Testing Library allows you
    to search for elements by text values regardless of the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the ability to select elements by text value regardless of their case
    increases the test''s ability to maintain a passing result despite changes to
    implementation details of the element. The use of the `getByPlaceholderText` method
    is a great way to select elements, but we can be even more specific by refactoring
    the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added a `label` element and an accessible `name`
    attribute to the input. Now all users, including those using screen readers, can
    access the element. We can select the input element in our test like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `getByRole` method to select the element by
    its role of a textbox with the name `first name`. Selecting an element by its
    role is the preferred way to select elements with the DOM Testing Library when
    available.
  prefs: []
  type: TYPE_NORMAL
- en: The library is very flexible in that you can use it with any JavaScript test
    runner, such as Mocha or Jest, that provides APIs to access the DOM. We will run
    our tests with Jest in this book and learn more about it in the next section.
    There are many specific versions of the DOM Testing Library for popular UI frameworks
    and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The particular versions add extra features to the DOM Testing Library''s API
    for more comfortable use. For example, to place a React component under test into
    the DOM, we can use the `render` method of `ReactDOM` to place the component into
    an element attached to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, first, we create a `div` element. Next, we attach `SomeComponent`
    to the `div` element. Then, we attach `div` to the `body` element of the DOM.
    Finally, we use the `getByText` method of the DOM Testing Library''s `screen`
    object to find an element with the text value of `Login`. If we use React Testing
    Library, we can replace the first three lines from the preceding code with the
    `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use React Testing Library's `render` method to automatically
    render the component under test into the DOM for us. We will show you how to use
    the React version of the library throughout this book. There is even support for
    many popular end-to-end testing frameworks, such as Cypress ([https://www.cypress.io/](https://www.cypress.io/)),
    which we will cover in [*Chapter 7*](B16887_07_Final_PG_ePub.xhtml#_idTextAnchor109),
    *End-to-End UI Testing with Cypress*. The library provides a utility to enhance
    test assertions with Jest, which we will cover later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover the guiding principles behind the DOM Testing Library.
  prefs: []
  type: TYPE_NORMAL
- en: Guiding principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The DOM Testing Library is driven by providing easy-to-use APIs to test your
    rendered applications in the DOM. The tools help give you confidence that your
    tests represent actions that actual users are likely to take. For example, you
    might build an email form allowing customers to subscribe to your newsletter such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Subscription form component](img/Figure_1.1_B16887.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Subscription form component
  prefs: []
  type: TYPE_NORMAL
- en: Because you want to be sure that the form works, you'll think about the steps
    a potential subscriber would take while interacting with the form. You think to
    yourself, *If I were a user, first, I might look for a label named Email Address
    or a placeholder that has the text "enter an email."* The DOM Testing Library
    has a method called `getByLabelText` to quickly find the email input by the label
    displayed on the screen. The DOM Testing Library has another method called `getByPlaceholderText`
    that allows you to locate an input via its placeholder value.
  prefs: []
  type: TYPE_NORMAL
- en: After entering the email, you think to yourself, *Next, I would look for a button
    with the text "Subscribe" and click it*. The DOM Testing Library provides a method
    called `getByText` that allows you to find a button by its text value. Also, the
    library provides a method called `getByRole` that enables you to query the DOM
    specifically for an element with the role of `button` with the `subscribe` text
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the DOM Testing Library's general concepts, we will
    discuss the framework we will use to execute our test cases in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Executing test cases with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jest** is a JavaScript testing framework created by the team at Facebook.
    In this section, we will cover a brief overview of Jest and how we can use it
    to verify the output of test cases for React components.'
  prefs: []
  type: TYPE_NORMAL
- en: Running tests with Jest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most React projects are tested with Jest, so it makes sense to introduce this
    tool alongside learning React Testing Library. When we write our tests using React
    Testing Library, we need a test runner to execute the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install Jest in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will run our React tests using Jest. At a high level, Jest provides the `describe`,
    `it`, `test`, and `expect` functions to organize and execute tests. You can think
    of the `describe` function as a test suite. Use the `describe` function to group
    related tests for specific components. The `it` and `test` functions are for specific
    tests. The `it` and `test` functions are interchangeable functions used to house
    and run the code for individual test cases. Use the `expect` function to assert
    the expected output. Jest also provides mock functions to handle code outside
    the realm of tests and coverage reporting. A test written with Jest can be as
    simple as testing the output of a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use the `test` and `expect` functions to assert
    the total number of characters in a provided name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example test that will assert the details of a `Profile`
    component created with a class-style React component. The `Profile` component
    accepts employee information and displays it as a card-style element in the DOM.
    A user can click a button to hide or show the employee''s details on the screen.
    Here is a screenshot of the component''s DOM output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Profile component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Profile component
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code for the `Profile` component. We create a `state`
    object with the `showDetails` property initially set to `true`. Next, we create
    a `setDetails` method that will update the `state` value of `showDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `render` method, we display the `name` and `title` properties passed
    into the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `src` image just has a placeholder image, but ideally would accept
    a passed-in value such as the `name` and `title` property values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have a button that invokes the `setDetails` method when clicked.
    The button''s text is set to either `Hide Details` or `Display Details` based
    on the value of `state.showDetails`. Also, the employee details are displayed
    based on the value of `state.showDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the code for a `Profile` component test that verifies the
    button with the text `"display details"` is shown when the button with the text
    `"hide details"` is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create a `div` element to later use with the component
    under test. Next, we use the `render` method of `ReactDOM` to render the `Profile`
    component with passed-in properties into `div`. Finally, we add `div` with the
    component to the `body` element of the DOM. Next, we perform actions on the resulting
    DOM output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, first we grab the button with the name `hide details`.
    Next, we fire a click event on the `hide details` button. Then, we grab the button
    with the name `display details`. Next, we will make assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, first, we expect the `display details` button to be *truthy*,
    meaning the element is found in the DOM. Then, we do some test cleanup by removing
    `div` from the DOM's `body` element, allowing successive tests to start from a
    clean slate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the previous test again by focusing on the Jest parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code for a specific test lives inside an `it` or `test` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This method and others in the test file will execute when Jest is run with
    the `npm`) test. Jest will find your test file, execute tests within it, and show
    the test results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Profile test passed console output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Profile test passed console output
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had multiple tests for a component, we could organize them together in
    the `describe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part of a test is the assertion. In Jest, you can assert
    the output of the test using the `expect` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `toBeTruthy` method chained off the `expect` method is one of many matcher
    methods that Jest provides to verify the expected result of the code passed into
    `expect`.
  prefs: []
  type: TYPE_NORMAL
- en: Now you understand the role Jest plays in testing React applications. You can
    install the framework and use its API to organize, write, and execute test cases.
    Next, you will learn about a utility provided by the Testing Library to add enhanced
    Jest assertion matchers to help with testing React components.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing Jest assertions with jest-dom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`jest-dom` is a utility tool from the DOM Testing Library that provides extra
    Jest assertions to use in tests. In this section, you will learn how to install
    `jest-dom` and understand the advantages of using `jest-dom` with Jest.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding jest-dom to a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add `jest-dom` to a project that includes Jest using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the package using `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following snippet to the top of your test file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After installing and importing `jest-dom` into your test file, you can start
    using the extra assertions as they are now chained off the `expect` method. You
    will see detailed illustrated use cases in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using jest-dom with Jest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can enhance user-focused testing goals by including `jest-dom` in React
    projects that use Jest. `jest-dom` provides two significant enhancements for Jest
    assertions. First, `jest-dom` provides over 20 custom DOM matchers that create
    more descriptive test code. Second, `jest-dom` also provides better context-specific
    error messages. We will show you examples of both advantages in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: jest-dom descriptive test code examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To illustrate the benefits of using `jest-dom`, first, we will revisit our
    `Profile` component test file from the previous section, *Introducing the DOM
    Testing Library*. Note that we will only focus on the assertion code in the test.
    We asserted the text value of an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The syntax of the previous code may not be as clear to some developers who are
    unfamiliar with the code base. It may not be evident that we are verifying the
    element is found in the DOM. `jest-dom` has a `toBeInTheDocument()` method to
    provide a more straightforward syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will refactor our code using use the `jest-dom` `toBeInTheDocument()`
    method to make the code more descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from the syntax it is more apparent that we are expecting the element
    to be in the DOM. We could also assert that the `hide details` button is removed
    from the DOM when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Jest's `toBeFalsy()` method was used to return a `null` value, which evaluates
    to `false` in JavaScript. For the test, this means the element was not found in
    the DOM. However, the syntax is not clear that using `toBeFalsy()` indicates the
    element wasn't found in the DOM as expected and may confuse some developers looking
    at the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `toBeInTheDocument()` method again to provide a more straightforward
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, from the syntax in the previous code it is more apparent that we expect
    the element to not be in the DOM. Notice that Jest's `not` property is used before
    the `jest-dom` method. The `not` property is used to return the opposite value.
    If we did not use the `not` property, we would be asserting the element is in
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For another example, let''s say we have the following login form we want to
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Login component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Login component
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous screenshot, we have a login form feature that allows a user
    to enter a username and password and check a `disabled` state until the user enters
    values for the `username` and `password` fields. The login form in this example
    is currently still in development, so at the moment, nothing happens when a user
    clicks the **Login** button. However, we can write a test to verify the functionality
    of the **Login** button being enabled when a user enters credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set up our test by rendering the `Login` component
    into the `div` tag and attaching it to the `body` element in the DOM. Next, we
    grab all the form elements, which include the `username`, `password`, `rememberMe`,
    and `login` buttons, and place them in variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will perform user actions on the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create a `fakeData` object with values to use in
    the test. Next, we use `fireEvent` to add values to the `username` and `password`
    fields and finally, to click the `rememberMe` checkbox. Next, we will make assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we assert that `loginBtn` has a `disabled` attribute
    set to `false`. However, we can use a `jest-dom` assertion method for a cleaner
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use the `toBeDisabled()` method to verify the `jest-dom`
    methods to verify the expected state of the form after entering values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `toHaveFormValues()` method to verify the
    form inputs have the entered `fakeData` values using an easy-to-read syntax. The
    great thing about our previous test is that as long as the functionality stays
    the same, we can continue building out the login form or refactor the internal
    code without concerns that our current tests will break.
  prefs: []
  type: TYPE_NORMAL
- en: Now you understand how `jest-dom` methods allow you to write more descriptive
    test code. Next, we will use the same examples to illustrate how `jest-dom` methods
    provide better context-specific error messages.
  prefs: []
  type: TYPE_NORMAL
- en: jest-dom error message example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we asserted that the `username` and `password` credentials
    for the `Login` component. We could have also asserted that the `jest-dom assertion`
    method, we could have mistakenly typed `disable` instead of `disabled` in the
    `hasAttribute` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The typo in the previous code would lead to the following test result output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Login component false negative test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – Login component false negative test
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, the results indicate the test failed from receiving
    a false value at the point where we expect the `true`. The result is a false negative
    because the source code was correct, but our test code was incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message does not make it obvious that the assertion code had a typo
    causing our test not to receive the expected result. We could make a similar test
    code error by mistakenly using the `not` property with the `jest-dom` `toBeDisabled`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we mistakenly assert the **Login** button is not disabled
    at the point in the test when it should be disabled. The test code mistake in
    the previous code would lead to the following test result output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Second login component false negative test](img/Figure_1.6_B16887.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Second login component false negative test
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, the results indicate the test fails, but we also
    receive helpful feedback for pinpointing the error while debugging. The test output
    informs us that the received element is disabled and logs the element to the console
    to view all the attributes. The `disabled` attribute is shown in the `element`
    output, which helps us understand that we need to debug our test code to know
    why we didn't receive the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how `jest-dom`'s methods provide better context-specific error
    messages to resolve issues faster. In the next section, we will learn about the
    disadvantages of including implementation details in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing implementation details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Implementation details** include the component state''s current value or
    explicitly invoking a method attached to a button in the DOM. Implementation details
    are the *under-the-hood* parts of components abstracted away from the user when
    they use the component. As an analogy, we can think of the experience of driving
    a car. To move, you must use the key to start the car, put the car into drive,
    and press the gas pedal. You don''t need to know how everything is wired together
    in the engine under the vehicle''s hood. You probably do not even care. All you
    care about is that you can drive the car when you perform the behaviors mentioned.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will explore the disadvantages of focusing on implementation
    details in your tests. We will show you examples of tests with implementation
    details. Finally, you will learn how to shift your focus away from thinking about
    implementation details when testing.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with implementation detail-focused tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write tests that focus on your code's internal details, you create
    a scenario that increases the chance you have of refactoring your tests whenever
    you change those details. For example, if you have a state object property named
    `value` and you write a test to assert that `state.value === 3`, that test will
    fail if you change the name of the state property to `currentValue`. Having your
    test code rely on the state object property's name is a problem because it adds
    a lot of unnecessary extra maintenance and slows down your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is that executing this test case yields a false negative because
    its functionality did not change; only the state name changed. Your tests should
    give you confidence that the most valuable pieces of your application related
    to user behavior function as expected and quickly let you know why this is not
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: Testing implementation details does not verify application code from the most
    valuable testers' perspective, that of actual users. For example, if you build
    an account creation form component and ship it to production, an end user interacting
    with the form via the UI will care about filling out the form and clicking `onChange`
    method or updates to the state object property named `usernameVal` when the user
    enters new text.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can reduce risk for users if you test that when a user fills out
    the form, and they click the **Submit** button, the expected results happen. A
    user will not directly interact with methods or state objects; therefore, our
    tests can be more valuable by focusing on how users will interact with the form
    in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In another example, using the same component, a software engineer is a user
    who will add the account creation form to the application code along with the
    required dependencies. The engineer user cares that the component renders as expected
    when they attempt to use it. Again, you could test the same implementation details
    mentioned in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can gain more confidence that the component will work as expected
    for users if you test that when an engineer renders the form with the required
    data, the data is present. Keep in mind that this does not mean you should never
    test the implementation details of your code. In most scenarios, tests that focus
    on the user provide more confidence than tests that focus on implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will show you an example of testing implementation details to illustrate
    this further.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation detail-focused test example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at an example test to illustrate further problems with testing
    the implementation details of components. The test will assert the details of
    a `Profile` component created with a class-style React component. The `Profile`
    component accepts employee information and displays it as a card-style element
    in the DOM. A user can click a button to hide or show the employee''s details
    on the screen. Here is a screenshot of the component''s DOM output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Profile component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Profile component
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code for the `Profile` component. We create a state
    object with the `showDetails` property initially set to `true`. Next, we create
    a `setDetails` method that will update the state value of `showDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `render` method, we display the `name` and `title` properties passed
    into the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `src` image just has a placeholder image, but ideally would accept
    a passed-in value such as the `name` and `title` property values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have a button that invokes the `setDetails` method when clicked.
    The button''s text is set to either `Hide Details` or `Display Details` based
    on the value of `state.showDetails`. Also, employee details are displayed based
    on the value of `state.showDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the test code for the `Profile` component. The test is created
    using Enzyme, which is a React testing utility that makes it difficult to avoid
    testing implementation details and Jest. In the test file, we have one test with
    four assertions for the `Profile` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mount the `Profile` component into the DOM with values set for the required
    dependencies. We set the `name` property to `"John Doe"`, the `title` property
    to `"Team Lead"`, and the `details` property to `"This is my 5th year and I love
    helping others"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we make assertions on the resulting DOM output of the `Profile` component.
    We assert the value of the `showDetails` state property. We search the DOM for
    an element with the`.card-text.details` class and assert the value of its text.
    Then, we invoke the component''s `setDetails` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we assert that the `showDetails` state property has changed and that
    the element with the`.card-text.details` class is no longer in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize, the test makes assertions on the following implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: The state object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setDetails` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The element with the class `.card-text.details`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one of the state object's properties changes, our test will break. If the
    `setDetails` method's name is changed or replaced with some other code without
    affecting the functionality, our test will fail. Lastly, if the class name the
    test uses to select the element changes, our test will break.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the test's assertions can yield false negative results if the
    implementation details change as compared to functionality changes. This increases
    the likelihood of a need to update the test often, and not test based on actual
    users' behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the disadvantages of testing implementation details,
    let's look at better ways to test.
  prefs: []
  type: TYPE_NORMAL
- en: How to move away from implementation detail testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you understand the disadvantages of implementation detail-focused
    testing, how do you write tests to ensure that they will work as expected for
    users? Simply create your tests as if the software under test was a black box.
    Your thought process should be, *What are the expectations a software engineer
    or end user may have while using this piece of software?* Let''s look at the following
    `Counter` component with **Add** and **Subtract** buttons, which display the current
    value. The value is increased or decreased by 1 based on the clicked button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Counter component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.8_B16887.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – Counter component
  prefs: []
  type: TYPE_NORMAL
- en: Try to think of as many black-box scenarios a software engineer or end user
    may perform while using the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few sample scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When the `Counter` component is rendered, the counter is displayed in the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user clicks the **Add** button, the current value is increased by 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user clicks the **Subtract** button, the current value is decreased by
    1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These scenarios provide assurance that our application works as expected for
    users compared to focusing on things such as state changes or method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to move away from implementation detail-focused test cases
    and instead focus on actual users. We have seen numerous examples applying the
    user-focused test approach from previous sections in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the DOM Testing Library and how it is designed
    to help you write user-focused tests. You now understand how the design of the
    DOM Testing Library can help you gain confidence that your software works as intended
    for users. You learned how to install Jest and understand that it is a test runner
    and the tool we will use to test React code. You learned about `jest-dom`. You
    know how it can add better error messages and descriptive DOM matchers for your
    test assertions. You can now install and use `jest-dom` in a project that uses
    Jest. Finally, you have gained an understanding of the disadvantages of implementation
    detail-focused testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to install and start writing tests for
    React components using React Testing Library.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install all the tools mentioned in this chapter and write a simple test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for examples of tests online that focus on implementation details. Identify
    all implementation details and create a refactored version of the tests using
    the DOM Testing Library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search MDN Web Docs for articles about ARIA roles. Next, practice writing tests
    using the `getByRole` query to select various elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
