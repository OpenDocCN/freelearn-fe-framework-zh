- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Making Our HTML Dynamic
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的 HTML 动态化
- en: The theoretical chapters have now come to an end. It is time to start building
    our Companion App and learn about Vue.js. As we build our application, one step
    at a time, we will also learn about Vue.js. The idea of this approach of learning
    by doing is most effective when you follow along and build the application alongside
    me.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理论章节现已结束。是时候开始构建我们的伴侣应用程序并学习 Vue.js 了。随着我们一步一步地构建应用程序，我们也将学习 Vue.js。这种通过实践学习的方法，当你跟随并与我一起构建应用程序时，效果最为显著。
- en: To help you grasp complicated topics and ensure that you have learned the basics
    of Vue.js, you will also be asked to complete some extra tasks that can either
    be applied to the Companion App or used as a standalone project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您掌握复杂主题并确保您已经掌握了 Vue.js 的基础知识，您还将被要求完成一些额外任务，这些任务可以应用于伴侣应用程序或作为独立项目使用。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building your first Vue project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的第一个 Vue 项目
- en: Creating our first components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个组件
- en: Introducing properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍属性
- en: Learning about Vue.js reactive data with Refs and Reactive
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Vue.js 的 Refs 和响应式数据
- en: The goal of this chapter is to introduce you to the basics of Vue.js. You will
    learn how to create a project from scratch to understand how a Vue component is
    structured. At the end of the chapter, you will be able to create Vue components,
    define attributes using props, and handle private state with Refs and Reactive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您介绍 Vue.js 的基础知识。您将学习如何从头创建项目，以了解 Vue 组件的结构。在本章结束时，您将能够创建 Vue 组件，使用 props
    定义属性，并使用 Refs 和响应式处理私有状态。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: From this point onward, all chapters will require you to check out a specific
    version of the code from our repository. We installed our repository back in [*Chapter
    1*](B21130_01.xhtml#_idTextAnchor015), when we downloaded the application and
    ran it for the first time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有章节都将要求您从我们的仓库中检出特定版本的代码。我们是在[*第一章*](B21130_01.xhtml#_idTextAnchor015)中安装我们的仓库，当时我们下载了应用程序并首次运行它。
- en: Using that same repository, which is available at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners),
    we can jump between chapters using the various branches. Having one individual
    branch per chapter ensures that our starting point matches, preventing possible
    code issues or missing parts that would make the learning complicated.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的仓库，该仓库可在 [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)
    找到，我们可以使用各种分支在章节之间跳转。每个章节都有一个单独的分支，确保我们的起点一致，防止可能出现的问题或缺失的部分，这会使学习变得复杂。
- en: 'In this chapter, the branch is called CH03\. To pull this branch, run the following
    command or use the GUI of choice to support you in this operation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，分支被命名为 CH03。要检出此分支，请运行以下命令或使用您选择的 GUI 来支持此操作：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Do not forget that to run the application after switching the branch, you have
    to ensure all dependencies are installed and run the dev server. This can be achieved
    with the following two commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在切换分支后运行应用程序之前，您必须确保所有依赖项都已安装并运行开发服务器。这可以通过以下两个命令实现：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Please note that we won’t need the repository until the *Creating our first*
    *component* section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要仓库，直到到达 *创建我们的第一个* *组件* 部分。
- en: Building your first Vue.js project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的第一个 Vue.js 项目
- en: The time has come to start and build our companion application. If you are already
    familiar with Vue.js and how you create a new project using it, you can skip this
    section, pull the code from our repository, and start building the application
    in the next chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始构建我们的伴侣应用程序了。如果您已经熟悉 Vue.js 以及如何使用它创建新项目，您可以跳过本节，从我们的仓库中拉取代码，并在下一章开始构建应用程序。
- en: When we create a new project using the `vue create` command, which we will see
    soon, we use the Vite build tool behind the scenes. Until recently, the best build
    tool was Webpack, and all frameworks, including Vue 2, used it to build their
    applications. But things have now changed, and Vite has taken over due to its
    no-config approach and extremely fast development server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `vue create` 命令创建新项目时，我们将很快看到，我们使用的是 Vite 构建工具。直到最近，最好的构建工具是 Webpack，包括
    Vue 2 在内的所有框架都使用它来构建他们的应用程序。但现在情况已经改变，Vite 由于其无配置方法和极快的开发服务器而接管了市场。
- en: 'On its official site, Vite is described as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在其官方网站上，Vite 被描述如下：
- en: “Vite (French word for “quick”, pronounced /vit/, like “veet”) is a build tool
    that aims to provide a faster and leaner development experience for modern web”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “Vite（法语中意为“快速”，发音为/vit/，类似于“veet”）是一个旨在为现代网页提供更快、更精简的开发体验的构建工具”
- en: Vite was created by Evan You (yes, the author of Vue) in an attempt to improve
    the development experience. Vite has been around for just a few years, but it
    has quickly gained popularity due to its low configuration and fast development
    server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Vite 是由 Evan You（是的，Vue 的作者）创建的，旨在改善开发体验。Vite 仅仅存在了几年，但由于其低配置和快速的开发服务器，它已经迅速获得了人气。
- en: Vite, like Vue.js, is fully open source, and it also supports all major frameworks
    out of the box. Creating a project with Vite is quite simple, all you need is
    an IDE and a terminal.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Vue.js 一样，Vite 是完全开源的，并且它也支持所有主流框架。使用 Vite 创建项目相当简单，你只需要一个 IDE 和一个终端。
- en: Vue CLI GUI
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Vue CLI 图形界面
- en: You have probably heard that Vue CLI offered a visual tool that helped you manage
    the Vue application. Unfortunately, that project was linked to Webpack and has
    yet to be imported to Vue 3 and Vite.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过 Vue CLI 提供了一个可视化工具，帮助你管理 Vue 应用程序。不幸的是，该项目与 Webpack 相关，并且尚未导入 Vue 3 和
    Vite。
- en: Create Vue command
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Vue 命令
- en: Because it is not possible to create a project in an existing folder, we are
    not able to re-use our previously downloaded application. We are going to complete
    this step in a different folder to ensure that you are able to get a project started
    from scratch. In the next chapter, we will pull the code directly from the companion
    application repository.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法在现有文件夹中创建项目，我们无法重用之前下载的应用程序。我们将在这个不同的文件夹中完成这一步，以确保你能够从头开始创建项目。在下一章中，我们将直接从配套应用程序仓库中拉取代码。
- en: 'To create a new project with Vue, we first need to access the folder in which
    the project will be created. Please be assured that the CLI will create a new
    folder for your project, so you do not need to create a folder manually now, but
    just access the main folder in which the project should live. For example, I like
    to create all my projects in the `Document` folder, so I am going to access it
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Vue 创建新项目，我们首先需要访问项目将要创建的文件夹。请放心，CLI 将为你的项目创建一个新的文件夹，所以你现在不需要手动创建文件夹，只需访问项目应该存在的父文件夹即可。例如，我喜欢在我的“文档”文件夹中创建所有项目，所以我将这样访问它：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we are in the correct folder, we can call the Terminal command required
    to create a new Vite project:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处于正确的文件夹中，我们可以调用创建新 Vite 项目所需的终端命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the preceding command will generate a request to install the create-vue
    package:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令将生成一个安装 create-vue 包的请求：
- en: '![Figure 3.1: The installation message triggered by the create vue command](img/B21130_03_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：由 create vue 命令触发的安装信息](img/B21130_03_01.jpg)'
- en: 'Figure 3.1: The installation message triggered by the create vue command'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：由 create vue 命令触发的安装信息
- en: To successfully install the project, we need to press *y* and proceed with the
    installation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功安装项目，我们需要按 *y* 并继续安装。
- en: 'After a few seconds, the CLI will start and ask us questions that will help
    it scaffold the project to align with our needs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，CLI 将启动并询问一些问题，这些问题将帮助它根据我们的需求搭建项目：
- en: '![Figure 3.2: The Vue CLI questions](img/B21130_03_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：Vue CLI 的问题](img/B21130_03_02.jpg)'
- en: 'Figure 3.2: The Vue CLI questions'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：Vue CLI 的问题
- en: 'As you can see, Vue projects come with a nice set of presets that help it to
    create a strong foundation for your next Vue project. Vue CLI provides options
    for the following settings:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Vue 项目附带了一套预设，有助于为你的下一个 Vue 项目打下坚实的基础。Vue CLI 提供了以下设置的选项：
- en: '**Project Name**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目名称**'
- en: '**Typescript**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**'
- en: '**JSX support**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSX 支持**'
- en: '**Router**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**'
- en: '**State Management**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态管理**'
- en: '**Unit tests**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: '**End to** **End tests**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束** **单元测试**'
- en: '**Code quality**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码质量**'
- en: '**Code formatting**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码格式化**'
- en: The choices for these settings are completely up to you, and you should follow
    your personal needs and requirements. The ones that you see in *Figure 3**.2*
    are the settings that I have used to create the Companion App that we will use
    in the next chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置的选项完全取决于你，你应该遵循你个人的需求和要求。你在 *图 3.2* 中看到的设置是我用来创建下一章我们将使用的配套应用程序的设置。
- en: After pressing *Enter* and waiting for a few seconds, we should get some information
    about how to run our project. This requires us to access the folder, install the
    required packages, and run the development server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下 *Enter* 并等待几秒钟后，我们应该会得到一些有关如何运行我们的项目的信息。这需要我们访问文件夹，安装所需的包，并运行开发服务器。
- en: 'First, let’s navigate to the folder that was created as part of our Vue project
    initialization, that is equal to your project name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导航到作为我们的 Vue 项目初始化一部分创建的文件夹，即等于你的项目名称：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, install all the packages required for the project to function. I have
    used npm in this instance, but you can use Yarn or PNPM:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，安装项目运行所需的所有包。在这个例子中，我使用了 npm，但你也可以使用 Yarn 或 PNPM：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Last, we just need to run this command to run the development server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需运行这个命令来运行开发服务器：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After these two commands, in less than a second you should see the following
    message displayed in your console:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这两个命令后，不到一秒钟你应该会在你的控制台中看到以下消息：
- en: '![Figure 3.3: Vite output of a successful run of the Vue development environment](img/B21130_03_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：Vue 开发环境成功运行时的 Vite 输出](img/B21130_03_03.jpg)'
- en: 'Figure 3.3: Vite output of a successful run of the Vue development environment'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：Vue 开发环境成功运行时的 Vite 输出
- en: Vite projects act differently from the previous Webpack projects that were run
    on port 3000 and run on port 5173\. The local URL will be displayed in the console,
    as shown in *Figure 3**.3*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Vite 项目与之前在 3000 端口运行的 Webpack 项目表现不同，它们运行在 5173 端口上。本地 URL 将在控制台中显示，如图 *图 3.3*
    所示。
- en: 'In our case, accessing the browser on `localhost:5173` will show the following
    website:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，访问 `localhost:5173` 上的浏览器将显示以下网站：
- en: '![Figure 3.4: Welcome page of a newly built Vue project](img/B21130_03_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4：新构建的 Vue 项目的欢迎页面](img/B21130_03_04.jpg)'
- en: 'Figure 3.4: Welcome page of a newly built Vue project'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：新构建的 Vue 项目的欢迎页面
- en: Congratulations on creating your first Vue project. This is going to be the
    first of many projects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你创建了你的第一个 Vue 项目。这将是你众多项目中的第一个。
- en: Vue project folder structure
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vue 项目文件夹结构
- en: In this section, we are going to quickly cover the structure of a new Vue project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速介绍新 Vue 项目的结构。
- en: 'When a new project is created, it comes with a well-defined structure that
    can be used as a strong foundation for future development:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新项目时，它自带一个定义良好的结构，可以作为未来开发的坚实基础：
- en: '![Figure 3.5: Folder structure of a newly created Vue project](img/B21130_03_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：新创建的 Vue 项目的文件夹结构](img/B21130_03_05.jpg)'
- en: 'Figure 3.5: Folder structure of a newly created Vue project'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：新创建的 Vue 项目的文件夹结构
- en: We are going to explain the different folders and files to help you find anything
    you need from your new Vue project. We are going to do this in no particular order.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释不同的文件夹和文件，帮助你从你的新 Vue 项目中找到所需的一切。我们将按无特定顺序进行。
- en: Root folder
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根目录
- en: The root folder of a Vue project includes a few configuration files. These are
    preset and pre-generated by the Vue creation package and do not need any further
    attention for the application to run smoothly. During the course of this book
    and your career, you will slowly be exposed to each of these configuration files
    and learn about their various options.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 项目的根目录包含一些配置文件。这些文件是由 Vue 创建包预设和预生成的，并且为了使应用程序顺利运行，不需要进一步的关注。在本书的进程和你的职业生涯中，你将逐渐接触到这些配置文件的每一个，并了解它们的各种选项。
- en: No touch zones
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可触碰区域
- en: There are a couple of folders, such as `.vscode`, `node_modules`, and `dist`,
    that are what I call “no touch” folders. You may already be aware of these folders
    as they are created and managed by tools and software that you may have already
    used, such as Visual Studio Code, npm, or Vite, and should not be modified manually.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个文件夹，如 `.vscode`、`node_modules` 和 `dist`，是我所说的“不可触碰”文件夹。你可能已经熟悉这些文件夹，因为它们是由你可能已经使用的工具和软件创建和管理的，例如
    Visual Studio Code、npm 或 Vite，并且不应手动修改。
- en: Public
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Public
- en: The content of the public folder is going to be copied directly into the output
    folder after the project is built. This folder is very rarely touched by a developer
    but is very useful when there are files that are needed in the build output and
    not part of the Vue compilation. Example files for this folder are favicon and
    service worker.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目构建后，public 文件夹的内容将被直接复制到输出文件夹中。这个文件夹很少被开发者触及，但在需要包含在构建输出中但不是 Vue 编译部分的文件时非常有用。这个文件夹的示例文件包括
    favicon 和 service worker。
- en: Cypress
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cypress
- en: As shown in the installation guide, the newly created project comes with a preset
    **end-to-end** (**E2E**) testing framework using the tool of your choice. In our
    case, I selected Cypress and the CLI has created a folder and a sample test for
    me ready to be used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如安装指南所示，新创建的项目附带了一个预设的 **端到端**（**E2E**）测试框架，使用您选择的工具。在我们的例子中，我选择了 Cypress，CLI
    已经为我创建了一个文件夹和一个示例测试，供我使用。
- en: SRC
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SRC
- en: 'This is where your source code lives. This is the main content of our application,
    and it is where you will spend most of your day-to-day work. Due to the importance
    of the folder, we are going to see its content and make sure we know how its files
    are structured:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您的源代码所在的地方。这是我们应用程序的主要内容，您将在日常工作中的大部分时间在这里工作。由于文件夹的重要性，我们将查看其内容并确保我们知道其文件的结构：
- en: '![Figure 3.6: Content of the SRC folder from a newly created Vue project](img/B21130_03_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6：新创建的 Vue 项目的 SRC 文件夹内容](img/B21130_03_06.jpg)'
- en: 'Figure 3.6: Content of the SRC folder from a newly created Vue project'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：新创建的 Vue 项目的 SRC 文件夹内容
- en: As before, let’s start from the root of the folder. This includes two files,
    `main.js` and `App.vue`. `Main.js` is the entry file of our application. This
    file is used to add new packages to our Vue instance and to load and set up global
    plugins, composable (function that leverages Vue’s Composition API to encapsulate
    and reuse stateful logic that we will introduce later in the book) and components.
    Next, we have App.vue. This is the first Vue entry point and is the component
    that will load and handle the rest of the Vue application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们从文件夹的根目录开始。这包括两个文件，`main.js` 和 `App.vue`。`Main.js` 是我们应用程序的入口文件。此文件用于向我们的
    Vue 实例添加新包，并加载和设置全局插件、组合式（利用 Vue 的组合式 API 封装和重用我们在本书后面将要介绍的有状态逻辑的函数）和组件。接下来，我们有
    `App.vue`。这是第一个 Vue 入口点，是负责加载和处理 Vue 应用程序其余部分的组件。
- en: Next up, we have the `assets` folder. This folder is used to load any assets,
    such as images, PDFs, and videos. The content of this folder is also copied in
    the output artifact of our build.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `assets` 文件夹。此文件夹用于加载任何资产，例如图片、PDF 和视频。此文件夹的内容也会复制到我们的构建输出工件中。
- en: Further down the list, we have the `components` folder. This folder contains
    not only the set of components already available within the app, but also the
    `__tests__` folder, which includes our unit tests.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的下方，我们有 `components` 文件夹。此文件夹不仅包含应用程序中已提供的组件集合，还包括 `__tests__` 文件夹，其中包含我们的单元测试。
- en: The next two folders are `router` and `stores`. As the name suggests, they include
    the `vue-router` and the `Pinia` store code respectively. These are two core packages
    provided by the Vue.js core team and will be covered in detail in [*Chapter 10*](B21130_10.xhtml#_idTextAnchor135)
    and [*Chapter 11*](B21130_11.xhtml#_idTextAnchor153). Vue-router will be used
    to create navigation routes for our clients and help us manage our growing application,
    while Pinia will be used to create and manage data within the application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个文件夹是 `router` 和 `stores`。正如其名所示，它们分别包含 `vue-router` 和 `Pinia` 存储代码。这两个是
    Vue.js 核心团队提供的核心包，将在 [*第 10 章*](B21130_10.xhtml#_idTextAnchor135) 和 [*第 11 章*](B21130_11.xhtml#_idTextAnchor153)
    中详细介绍。Vue-router 将用于为我们的客户端创建导航路由，并帮助我们管理不断增长的应用程序，而 Pinia 将用于在应用程序中创建和管理数据。
- en: Last but not least we have `views`. If you have had time to investigate this
    folder, you would have noticed that it contains simple Vue components. The reason
    for this folder is to separate simple component units (the ones stored in the
    `components` folder) actual routing pages. Making this separation helps to keep
    the code clean and delineate the routing of the application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们有 `views` 文件夹。如果你有时间调查这个文件夹，你会注意到它包含简单的 Vue 组件。这个文件夹的原因是为了将简单的组件单元（存储在
    `components` 文件夹中的那些）与实际的路由页面分开。这种分离有助于保持代码整洁并界定应用程序的路由。
- en: Your private playground
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您的私人游乐场
- en: Even if the app we just created is not needed for the rest of the book, it could
    be useful to keep and use it as a playground to practice the topic that we will
    cover in the course of the book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们所创建的应用程序对于本书的其余部分不是必需的，但它可能作为练习本书过程中将要涵盖的主题的游乐场而有用。
- en: We have concluded our Vue project explanation, and you should now have the knowledge
    required to create a new Vue project from scratch. You should also know a little
    bit about Vite and be able to navigate the folder structure of a newly created
    Vue project. In the next section, we will dive into the code and start to build
    our first Vue.js component.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 Vue 项目的解释，你现在应该具备从头创建 Vue 项目的知识。你也应该对 Vite 有一些了解，并且能够导航新创建的 Vue 项目的文件夹结构。在下一节中，我们将深入代码并开始构建我们的第一个
    Vue.js 组件。
- en: Creating our first component
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个组件
- en: As you may remember from the first chapter, in which we introduced the Companion
    App, we are planning to build a clone of the social application called X (former
    Twitter). To start our building journey in style, we are going to build the most
    iconic component of the application, a post.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从第一章中记得的，我们在其中介绍了伴随应用程序，我们计划构建一个名为 X（前身为 Twitter）的社会应用程序的克隆。为了以优雅的方式开始我们的构建之旅，我们将构建应用程序中最标志性的组件，一个帖子。
- en: '![Figure 3.7: Example of a X.com post component](img/B21130_03_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：X.com 帖子组件的示例](img/B21130_03_07.jpg)'
- en: 'Figure 3.7: Example of a X.com post component'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：X.com 帖子组件的示例
- en: In this chapter, we are going to learn how to switch between the different branches
    within the book repository. We are then going to create our first SFC (`Refs`
    and `Reactive`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在书库的不同分支之间切换。然后我们将创建我们的第一个 SFC (`Refs` 和 `Reactive`）。
- en: Creating Post.vue
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Post.vue
- en: Back in [*Chapter 1*](B21130_01.xhtml#_idTextAnchor015), we mentioned that we
    were going to break down components into different layers (atoms, molecules, organisms,
    and so on) and `SocialPost.vue` is going to be part of the molecules layer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [*第一章*](B21130_01.xhtml#_idTextAnchor015)，我们提到我们将把组件分解成不同的层级（原子、分子、生物体等），而
    `SocialPost.vue` 将成为分子层的一部分。
- en: 'So, let’s create a folder called `molecules` in the `component` folder and
    then add a file called `SocialPost.vue`. Once you’ve done this, your folders should
    look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在 `component` 文件夹中创建一个名为 `molecules` 的文件夹，然后添加一个名为 `SocialPost.vue` 的文件。一旦完成这些，你的文件夹应该看起来像这样：
- en: '![Figure 3.8: File tree of the src folder of the companion app](img/B21130_03_08.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：伴随应用程序的 src 文件夹的文件树](img/B21130_03_08.jpg)'
- en: 'Figure 3.8: File tree of the src folder of the companion app'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：伴随应用程序的 src 文件夹的文件树
- en: 'There are two things to notice about the new file we have created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们创建的新文件，有两点需要注意：
- en: The name is made up of two words. This is not just to provide more context,
    but also because one letter component, like `post.vue`, are discouraged due to
    possible future collision with native HTML components like `<button>` or `<table>`
    (eg. If a new HTML element called <post> is introduced in future HTML releases
    it could clash with our custom component)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称由两个单词组成。这不仅仅是为了提供更多上下文，还因为像 `post.vue` 这样的单字母组件是不被推荐的，因为它们可能与未来的原生 HTML 组件（如
    `<button>` 或 `<table>`）发生冲突（例如，如果未来 HTML 版本中引入了一个名为 <post> 的新 HTML 元素，它可能会与我们的自定义组件冲突）。
- en: Component names are written in PascalCase, a naming convention in which each
    word that makes up the variable is capitalized.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件名称以 PascalCase 编写，这是一种命名约定，其中变量组成的每个单词的首字母都大写。
- en: 'As our file is empty, let’s open it and start to create the basic structure
    of a Vue component by adding the `<template>`, `<script>`, and `<``style>` tags:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的文件是空的，让我们打开它，并通过添加 `<template>`、`<script>` 和 `<style>` 标签来创建 Vue 组件的基本结构：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is going to be our standard Vue starter template. It defines an empty template
    where we will encapsulate our `setup` attribute, which allows us to write JavaScript
    logic using the Composition API, and a `style` section, in which we select **SCSS**
    as our preprocessor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们标准的 Vue 启动模板。它定义了一个空模板，我们将在这里封装我们的 `setup` 属性，这允许我们使用组合式 API 编写 JavaScript
    逻辑，以及一个 `style` 部分，在其中我们选择 **SCSS** 作为我们的预处理器。
- en: We are now going to define the HTML and the CSS required for our post to be
    displayed. This is going to be a very simple design for now; we will add more
    in the course of the book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义用于显示我们的帖子所需的 HTML 和 CSS。目前这将是一个非常简单的设计；我们将在本书的后续内容中添加更多。
- en: 'Our first draft of the component is going to include a header image, the name
    of the user followed by the ID of the user, and the post’s description. All of
    this is also going to include some basic styles. Let’s look at the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件的第一个草稿将包括一个头部图片，用户的名称和用户 ID，以及帖子的描述。所有这些也将包括一些基本样式。让我们看看代码：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you have probably noticed, the preceding component does not have anything
    special. There’s no `script` tag, no special tag in the HTML, and nothing special
    in the CSS, but it is still a perfectly normal Vue component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你很可能注意到的，前面的组件没有什么特别之处。没有 `script` 标签，HTML 中没有特殊的标签，CSS 中也没有什么特殊之处，但它仍然是一个完全正常的
    Vue 组件。
- en: 'Let’s highlight a few important aspects of this component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们突出这个组件的几个重要方面：
- en: '`<div class="SocialPost">`: It is good practice to always assign a class equal
    to the component name, that in our case is SocialPost, to the root element of
    the component. This will help us scope the style without needing to use the `scoped`
    attribute.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="SocialPost">`：将类名设置为组件名，在我们的例子中是 SocialPost，分配给组件的根元素是一个好习惯。这将帮助我们限制样式范围，而无需使用
    `scoped` 属性。'
- en: '`<style lang="scss">`: In our examples, we are going to use **SCSS**. This
    is specified here. As you will see in the following section, this needs to be
    configured in our Vite project. You do not need to add a pre-processor, but I
    am adding one to show you how to add and use it in case you are used to writing
    your style with one.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<style lang="scss">`：在我们的示例中，我们将使用 **SCSS**。这在这里指定了。正如你将在下一节中看到的那样，这需要在我们的
    Vite 项目中进行配置。你不需要添加预处理器，但我添加了一个，以便向你展示如何添加和使用它，以防你习惯于使用预处理器编写样式。'
- en: '`.SocialPost{`: We can use the class we attached to the component name to scope
    our CSS by wrapping all the styles into it. This will ensure that our style will
    not bleed into other components.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.SocialPost{`：我们可以使用附加到组件名的类来限制我们的 CSS，通过将所有样式包装在它里面。这将确保我们的样式不会渗透到其他组件中。'
- en: Now that the component is ready, it is time to test it out. To do so, we need
    to load the component somewhere in the application. We can do so by loading the
    component in `TheWelcome.vue`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件已经准备好了，是时候测试它了。为了做到这一点，我们需要在应用程序的某个地方加载组件。我们可以在 `TheWelcome.vue` 中加载组件。
- en: To successfully load a Vue custom component, we need to complete two simple
    actions. First, we need to import the component, and second, we need to call it
    in the HTML as if it was a native component.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功加载 Vue 自定义组件，我们需要完成两个简单的操作。首先，我们需要导入组件，其次，我们需要在 HTML 中调用它，就像它是原生组件一样。
- en: 'To load the component, we import it like a normal JavaScript file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载组件，我们需要像导入普通 JavaScript 文件一样导入它：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that the component is loaded, we can simply use it in our HTML like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件已经加载，我们可以在 HTML 中简单地这样使用它：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that our component has been fully developed and loaded, it is time to try
    it out. To do so, let’s run our application using the `npm run dev` command. Now,
    access the localhost site shown in the terminal (`http://localhost:5173/`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全开发并加载了组件，是时候尝试它了。为了做到这一点，让我们使用 `npm run dev` 命令运行我们的应用程序。现在，访问终端中显示的本地站（`http://localhost:5173/`）。
- en: 'Unfortunately, the browser output is not what we expected; we are presented
    with an error:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，浏览器输出并不是我们预期的；我们遇到了一个错误：
- en: '![Figure 3.9: Error message displayed by Vite](img/B21130_03_09.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9：Vite 显示的错误信息](img/B21130_03_09.jpg)'
- en: 'Figure 3.9: Error message displayed by Vite'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：Vite 显示的错误信息
- en: 'Luckily for us, the error is expected. As I mentioned before, SASS requires
    us to do further configuration. I wanted to show you how Vite would react if something
    was misconfigured. As displayed in the error message, Vite noticed that we are
    using SASSand is also providing us with the command required to install it. So,
    let’s go and run this command in the terminal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个错误是预期的。正如我之前提到的，SASS 要求我们进行进一步的配置。我想向你展示如果配置错误，Vite 会如何反应。如错误信息所示，Vite
    注意到我们正在使用 SASS，并且还提供了安装它的命令。所以，让我们在终端中运行这个命令：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After running this command and refreshing the browser, our application should
    now display our component:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令并刷新浏览器后，我们的应用程序现在应该会显示我们的组件：
- en: '![Figure 3.10: Vite welcome screen displaying a newly created custom component](img/B21130_03_10.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10：Vite 欢迎屏幕显示新创建的自定义组件](img/B21130_03_10.jpg)'
- en: 'Figure 3.10: Vite welcome screen displaying a newly created custom component'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：Vite 欢迎屏幕显示新创建的自定义组件
- en: Congratulations! You have just written your first working Vue component. This
    was just a small step, but it is important to celebrate every achievement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚编写了你的第一个工作 Vue 组件。这只是一个小步骤，但庆祝每一个成就都很重要。
- en: As you may have noted from the file that we just created, Vue.js allows you
    to write simple components made up of just HTML and CSS. This is a great way to
    slowly get started with Vue using your existing development knowledge.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我们刚刚创建的文件中注意到的，Vue.js 允许您编写由 HTML 和 CSS 组成的简单组件。这是使用您现有的开发知识慢慢开始使用 Vue 的好方法。
- en: Your turn
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您的回合
- en: Try to add another component of your own, for example, to ensure that you have
    understood how a component is created and added. You should try and create a static
    footer for our application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加另一个您自己的组件，例如，以确保您已经理解了组件是如何创建和添加的。您应该尝试创建一个静态页脚为我们应用程序。
- en: In this section, we learned how to create and load a Vue component, we debugged
    our first issue with Vite and learned how to install new plugins, and finally,
    we found a new way to scope style to our component by wrapping its CSS. In the
    next section, we are going to learn how to make our component dynamic by introducing
    a feature called **properties**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建和加载 Vue 组件，我们解决了 Vite 的第一个问题，并学习了如何安装新插件，最后，我们通过包裹其 CSS 找到了一种新的方法来将样式范围限定到我们的组件。在下一节中，我们将通过介绍一个称为**属性**的功能来学习如何使我们的组件变得动态。
- en: Introducing properties
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍属性
- en: As you have noticed, the component we created in the previous section is static
    and could not be used in a real-life application because it would always display
    the same information and not the actual post.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，我们在上一节中创建的组件是静态的，不能在实际应用中使用，因为它总是显示相同的信息，而不是实际的帖子。
- en: In the following section, we are going to add some dynamic features to our component.
    To ensure each topic is understood fully, we will add a small feature in each
    section and ensure that we take enough time to reiterate the features over the
    course of the book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将向我们的组件添加一些动态功能。为了确保每个主题都能被充分理解，我们将在每个部分添加一个小功能，并确保我们在整本书的过程中有足够的时间来重复这些功能。
- en: In this section, we are going to change the structure of our post component
    by exposing properties. Properties are simply attributes that are exposed by the
    component to allow users to customize its behavior or style.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过公开属性来改变我们的帖子组件的结构。属性仅仅是组件暴露的属性，允许用户自定义其行为或样式。
- en: If you have ever used HTML, you are probably already familiar with Vue.js props.
    Many native HTML elements have attributes that are used to modify components,
    such as an `<input>` tag as an attribute of `Type` to change its look, a `<textarea>`
    tag as an attribute of `column` and `rows`, and an `<img>` tag as an attribute
    of `src` to define the URL for its image.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过 HTML，您可能已经对 Vue.js 的 props 很熟悉了。许多原生 HTML 元素都有用于修改组件的属性，例如，将 `<input>`
    标签的 `Type` 属性用作改变其外观，将 `<textarea>` 标签的 `column` 和 `rows` 属性用作改变其外观，以及将 `<img>`
    标签的 `src` 属性用作定义其图像的 URL。
- en: Vue.js properties (usually referred to as props) allow you to define this attribute
    in our component, enabling us to turn our static component into dynamic and flexible
    building blocks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 属性（通常称为 props）允许我们在组件中定义这个属性，使我们能够将我们的静态组件转变为动态和灵活的构建块。
- en: In this section, we are going to pick our previously created post component
    and expose some Vue.js properties to allow us to use it multiple times with different
    values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将选择我们之前创建的帖子组件，并公开一些 Vue.js 属性，以便我们可以使用不同的值多次使用它。
- en: 'After revisiting our post component, it seems clear that the following variables
    should be changed to be dynamic entries:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新审视我们的帖子组件后，很明显以下变量应该被更改为动态条目：
- en: '`Username`: Twitter username'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Username`: Twitter 用户名'
- en: '`UserId`: Twitter ID'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserId`: Twitter ID'
- en: '`AvatarSrc`: Source of the avatar image'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AvatarSrc`: 头像图片的来源'
- en: '`Post`: The content of the post'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Post`: 帖子的内容'
- en: Declaring props in Vue.js
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Vue.js 中声明 props
- en: 'The first step required for us to use props is to declare them in the component.
    Declaring a property means defining its name and its type. To do so, we can use
    a compiler macro used `defineProps`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 props 的第一步是在组件中声明它们。声明属性意味着定义其名称和类型。为此，我们可以使用 `defineProps` 编译器宏：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown here, the `defineProps` macros accept an object with our properties.
    In our case, these are all `String`, but other types, such as `Number`, `Object`,
    `Array`, and `Boolean`, are also accepted.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，`defineProps` 宏接受一个包含我们属性的对象。在我们的例子中，这些都是 `String` 类型，但其他类型，如 `Number`、`Object`、`Array`
    和 `Boolean`，也是接受的。
- en: When we declare a property, we inform the component and its users that this
    component is happy to accept this extra data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个属性时，我们通知组件及其用户，这个组件愿意接受这些额外的数据。
- en: It is now time to learn how to access these properties in our SFC.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何在我们的SFC中访问这些属性了。
- en: Accessing properties in a Vue.js SFC
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Vue.js SFC中访问属性
- en: Properties can be accessed in multiple places. They can be read directly in
    the HTML as a play string, they can be used within an HTML element declaration,
    or they could be used in the `script` tag as part of our component logic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以在多个地方访问。它们可以直接在HTML中以播放字符串的形式读取，它们可以在HTML元素声明中使用，或者它们可以在`script`标签中作为我们组件逻辑的一部分使用。
- en: All these methods have a different syntax, but even if it seems like a lot,
    it is going to be quite easy to remember because it is consistent with the Vue
    writing style.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都有不同的语法，但即使看起来很多，由于它与Vue的编写风格一致，所以将很容易记住。
- en: 'First, we are going to learn how to use a prop as plain text. This is done
    using two curly braces: `{{` `props name` `}}`. Applying this to our template
    will produce the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何将属性用作纯文本。这是通过使用两个大括号`{{` `props name` `}}`来完成的。将此应用于我们的模板将生成以下代码：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the values of `username`, `userId`, and `post` are not hardcoded
    anymore and it is now using properties under the hood.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`username`、`userId`和`post`的值不再是硬编码的，现在它们正在使用底层的属性。
- en: Next up, we are going to learn how to use variables in our template. I used
    the generic word variable instead of props because this notion applies to all
    variables and not just props. To use a dynamic value in our template, for example,
    as an HTML element attribute, we just need to prepend the attribute with the symbol
    `:`. So, in our scenario, the image attribute `src="img/..."` will become `:src="img/avatarSrc"`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何在模板中使用变量。我使用了通用的单词变量而不是属性，因为这个概念适用于所有变量，而不仅仅是属性。要在模板中使用动态值，例如作为HTML元素属性，我们只需要在属性前加上符号`:`。所以，在我们的场景中，图像属性`src="img/..."`将变成`:src="img/avatarSrc"`。
- en: 'Our `<img>` element looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`<img>`元素看起来像这样：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Prepending an attribute with `:` informs Vue that the value is not a plain string
    but an actual JavaScript variable. So, in the proceeding example, the class is
    evaluated as a string, but the value of `src` is not going to be literally `avatarSrc`
    but the JavaScript variable associated with that name.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性前加上`:`告诉Vue该值不是一个普通的字符串，而是一个实际的JavaScript变量。所以，在接下来的示例中，类被评估为一个字符串，但`src`的值不会是字面上的`avatarSrc`，而是与该名称关联的JavaScript变量。
- en: Lastly, we are going to learn how to access properties within the `script` tag.
    This is achieved by using the return value of the `defineProps`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习如何在`script`标签中访问属性。这是通过使用`defineProps`的返回值来实现的。
- en: 'Let’s put into practice what we just learned by trying to use our properties
    by logging the value of `username` when the component is mounted. The code should
    look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过尝试在组件挂载时记录`username`的值来将我们刚刚学到的知识付诸实践。代码应该看起来像这样：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code shows how to access properties by using `defineProps`. This
    function accepts an object of properties (in our case `username`, `userId`, `avatarSrc`
    and `post`) and will return a variable that includes all the reactive properties
    that have been passed when the component was initialized (eg. `<MyComponent username="simone"
    />`). Next, we introduced another new feature of Vue.js, `onMounted`. This was
    introduced in the second chapter as part of the Vue lifecycle. `OnMounted` is
    specifically triggered when the component is fully rendered on the page.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码展示了如何使用`defineProps`来访问属性。这个函数接受一个属性对象（在我们的例子中是`username`、`userId`、`avatarSrc`和`post`），并将返回一个变量，该变量包含在组件初始化时传递的所有响应式属性（例如`<MyComponent
    username="simone" />`）。接下来，我们介绍了Vue.js的另一个新特性`onMounted`。它在第二章中作为Vue生命周期的一部分被引入。`OnMounted`专门在组件完全渲染到页面上时触发。
- en: defineProps cannot be destructured
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineProps`不能被解构'
- en: The returned value of `defineProps` cannot be destructured. Destructuring the
    return object would result in non-reactive values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineProps`返回的值不能被解构。解构返回的对象会导致非响应式值。'
- en: Because we have removed the hardcoded strings and changed our component to use
    properties, we need to do one more step before we can test it in the browser.
    Just like HTML elements that accept attributes, we need to define our properties
    when creating a component instance, which in our case was happening in `TheWelcome.vue`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们移除了硬编码的字符串，并将组件改为使用属性，在我们能够在浏览器中测试它之前，我们需要做一步额外的工作。就像接受属性的HTML元素一样，我们需要在创建组件实例时定义我们的属性，在我们的例子中是在`TheWelcome.vue`中发生的。
- en: 'Let’s see how to update our component to include our newly created properties:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何更新我们的组件以包含我们新创建的属性：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Just like a normal HTML element, we are able to pass our properties directly
    into the HTML tag. The names of the properties used here are the same as the ones
    defined in the component. They not only have to match word for word, but they
    are also case sensitive.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通的HTML元素一样，我们能够直接将属性传递到HTML标签中。这里使用的属性名与组件中定义的属性名相同。它们不仅需要逐字匹配，而且还需要区分大小写。
- en: Now that our component has been fully updated, we are able to access our application
    by running the CLI command to start the dev server (`npm run dev`) and check the
    browser (`http://localhost:5173/`).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全更新了组件，我们可以通过运行CLI命令来启动开发服务器（`npm run dev`）并检查浏览器（`http://localhost:5173/`）来访问我们的应用程序。
- en: 'Our application should not look any different from the previous version of
    the component. In fact, most of the work that we did was to change how the component
    behaves behind the scenes, but not how it looks. This section included multiple
    topics and Vue features. Let’s recap what we learned so far:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序应该看起来与组件的前一个版本没有区别。实际上，我们大部分的工作是改变组件在幕后如何表现，而不是它的外观。本节包含了多个主题和Vue特性。让我们回顾一下到目前为止我们学到了什么：
- en: How to declare props
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何声明props
- en: How to use props
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用props
- en: How to use props as plain strings
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将props用作普通字符串
- en: How to use props as HTML attributes
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将props用作HTML属性
- en: How to use props within the script tag
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在script标签中使用props
- en: How to use our first Vue lifecycle, `onMounted`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用我们的第一个Vue生命周期，`onMounted`
- en: Remember, properties in Vue js are just like HTML attributes. They allow you
    to make your component dynamic by exposing values that can be used in any shape
    or form to make your component unique. These properties can be accessed within
    multiple parts of your component.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Vue.js中的属性就像HTML属性一样。它们允许你通过暴露可以以任何形式使用的值来使组件动态化，从而使组件具有独特性。这些属性可以在组件的多个部分中访问。
- en: 'In the next section, we are going to learn how to create one or multiple instances
    of our component and introduce a new concept: reactive data.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何创建一个或多个组件实例，并介绍一个新概念：响应式数据。
- en: Your turn
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你的回合
- en: Continue to expand the footer component you created in the first section but
    change the values to be dynamic using props.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 继续扩展你在第一部分创建的页脚组件，但使用props将值改为动态的。
- en: Learning Vue.js reactive data with Refs and Reactive
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Refs和响应式学习Vue.js的响应式数据
- en: In the previous section, we started to make our component dynamic, but that
    was just the first of two steps required for our component to be fully reusable.
    It is time to learn about component state, also known as Data (term used in the
    Option API) or Refs and Reactive (terms used in the composition API). Being able
    to set private component information, together with the ability to define component
    properties, will be our toolset for dynamic and flexible components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们开始使我们的组件动态化，但这只是使组件完全可重用的两个步骤中的第一个。现在是时候学习组件状态了，也称为数据（在Option API中使用术语）或Refs和响应式（在组合API中使用术语）。能够设置私有组件信息，以及定义组件属性的能力，将是我们构建动态和灵活组件的工具集。
- en: Before we jump into data, we need to go back to the previous section and take
    a look at the component we just created. If you look carefully, the versions of
    `SocialPost.vue` look similar, and there seems to be no actual difference between
    the hardcoded version and the dynamic version.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入数据之前，我们需要回到上一节，看看我们刚刚创建的组件。如果你仔细看，`SocialPost.vue`的版本看起来很相似，并且似乎硬编码版本和动态版本之间没有实际的区别。
- en: So, why have we gone through the trouble of making all those changes if nothing
    changed? Well, the change is there, we have just not used it yet.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们费尽心机做出所有这些改变，而实际上没有什么改变呢？嗯，改变是存在的，我们只是还没有使用它。
- en: 'Let’s think for a minute about our Companion App and try to understand how
    the `SocialPost` component would be used. When using a real social platform, we
    would never expect a single hardcoded post on screen; our timeline will eventually
    display a large number of dynamic posts. In our first version of the component,
    the one that held hardcoded values, creating the component multiple times would
    have just resulted in the same post author and title showing over and over again.
    But with the dynamic version that we have created, we have the chance to pass
    different values to our props, allowing us to create multiple unique posts. Let’s
    see how this would look in practice by creating a second post:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微思考一下我们的伴侣应用，并尝试理解`SocialPost`组件将如何被使用。当使用真实的社交平台时，我们永远不会期望屏幕上只有一个硬编码的帖子；我们的时间线最终将显示大量动态帖子。在我们组件的第一个版本中，即包含硬编码值的版本，多次创建组件只会导致相同的作者和标题反复显示。但有了我们创建的动态版本，我们有传递不同值给props的机会，从而允许我们创建多个独特的帖子。让我们通过创建第二个帖子来看看这将在实践中看起来如何：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating dynamic components is a very powerful tool in web development. It allows
    us to reuse the same component and simplify our development efforts. Even if making
    the component dynamic is a step forward from our initial hardcoded example, it
    is still in need of some improvement. It is time to learn about reactive data
    and see how it can help us simplify the HTML of our component.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动态组件是Web开发中的一个非常强大的工具。它允许我们重用相同的组件并简化我们的开发工作。即使使组件动态化比我们最初的硬编码示例前进了一步，但它仍然需要一些改进。是时候学习响应式数据以及它如何帮助我们简化组件的HTML了。
- en: Keep the logic away from the HTML
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑与HTML分离
- en: A clean component is one that has most of its logic encapsulated within the
    `<script>` tag and has very clean HTML. It may be tempting to add some of the
    logic into the HTML, but this results in hard-to-maintain components.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个干净的组件是指其大部分逻辑都封装在`<script>`标签内，并且具有非常干净的HTML。虽然将一些逻辑添加到HTML中可能很有吸引力，但这会导致组件难以维护。
- en: Adding Refs or Reactive to our component allows us to remove static data from
    the `<template>` section of our SFC and allows us to add some dynamicity to our
    code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将Refs或Reactive添加到我们的组件中，使我们能够从SFC的`<template>`部分中移除静态数据，并使我们的代码具有一些动态性。
- en: The definition of Refs and Reactive can be a set of primitive data, objects
    and arrays used by a component instance to define private reactive data (state).”
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Refs和Reactive的定义可以是一组原始数据、对象和数组，这些数据由组件实例使用来定义私有响应式数据（状态）。”
- en: This notion is not new. In fact, native HTML components hold their own state
    too. For example, a video component may hold a state of started or stopped, while
    a dropdown may hold its selected value or an internal state of expanded or collapsed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念并不新鲜。事实上，原生的HTML组件也持有它们自己的状态。例如，视频组件可能持有开始或停止的状态，而下拉菜单可能持有其选中的值或展开或折叠的内部状态。
- en: In Vue.js and other major frameworks, reactive data is not only used to declare
    a state (eg. Holding the current state of a sidebar visibility of open or closed)
    but also to hold component data that is used internally by the component to provide
    a specific feature.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue.js和其他主要框架中，响应式数据不仅用于声明状态（例如，保持侧边栏的当前状态为打开或关闭），还用于存储组件内部使用的组件数据，以提供特定功能。
- en: In our case, we are going to use private data to try and move the information
    on the individual posts into an array. This will allow us, in future chapters,
    to use an external tool, such as an API, to fetch this data dynamically.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用私有数据尝试将单个帖子的信息移动到数组中。这将允许我们在未来的章节中使用外部工具，如API，来动态获取这些数据。
- en: 'Before we jump into the actual implementation details, let’s define the difference
    between Refs and Reactive:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实际实现细节之前，让我们定义一下Refs和Reactive之间的区别：
- en: '**Refs**: Allows the declaration of primitive values such as string, number,
    and Boolean and more complex types such as arrays and objects'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Refs**：允许声明原始值，如字符串、数字和布尔值，以及更复杂的数据类型，如数组和对象'
- en: '**Reactive**: Allows the declaration of objects and arrays and cannot be used
    for primitive values'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactive**：允许声明对象和数组，但不能用于原始值'
- en: '![Figure 3.11: Table of supported and unsupported types for Refs and Reactive](img/B21130_03_11_BW.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：支持的和不支持的Refs和Reactive类型表](img/B21130_03_11_BW.jpg)'
- en: 'Figure 3.11: Table of supported and unsupported types for Refs and Reactive'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：支持的和不支持的Refs和Reactive类型表
- en: Using objects
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象
- en: Some developers prefer to use Refs for everything, while others like to split
    the usage depending on the type being assigned. What I am going to show you may
    be opinionated, and you are free to change your usage to better align with your
    preferences.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者喜欢将 Refs 用于所有事情，而另一些开发者则喜欢根据分配的类型来分割使用。我将要展示的可能是主观的，你可以自由地根据你的偏好更改你的使用方式。
- en: In the course of this book, we are going to use Refs for primitive values such
    as string, numbers, and Booleans and reactive for arrays and objects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将使用 Refs 来处理原始值，如字符串、数字和布尔值，以及使用 Reactive 来处理数组和对象。
- en: The main differences between Refs and Reactive are not only in the values that
    they can hold but also in the way they are used. We are going to make two changes
    to our component to better understand the difference between Refs and Reactive.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Refs 和 Reactive 之间的主要区别不仅在于它们可以持有的值，还在于它们的使用方式。我们将对我们的组件进行两次修改，以更好地理解 Refs 和
    Reactive 之间的区别。
- en: First, we are going to introduce Refs by modifying the `SocialPost` component
    by adding a new feature to it. Then, we are going to learn about Reactive by moving
    the post information (`userId`, `avatar`, `name`, and `post`) into an array to
    simplify our HTML.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过修改 `SocialPost` 组件并为其添加一个新功能来介绍 Refs。然后，我们将通过将帖子信息（`userId`、`avatar`、`name`
    和 `post`）移动到一个数组中来简化我们的 HTML，来学习关于 Reactive 的知识。
- en: Adding Refs to SocialPost.vue
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Refs 添加到 SocialPost.vue
- en: Having the ability to define private data for a component is very powerful.
    We have seen how a component may need to receive information from its parent by
    defining properties, but there are times when the component needs to handle its
    own state. In this section, we are going to make some modifications to our component,
    `SocialPost.vue`, by providing it with the ability to be selected.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 能够为组件定义私有数据是非常强大的。我们已经看到组件可能需要通过定义属性从其父组件接收信息，但有时组件需要处理自己的状态。在本节中，我们将通过提供选择能力来对我们的组件
    `SocialPost.vue` 进行一些修改。
- en: 'For this feature to be implemented, we need to make three changes to our component:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，我们需要对我们的组件进行三个修改：
- en: We are going to create a private variable called `selected`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `selected` 的私有变量
- en: We are going to assign a specific style when the component is selected
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件被选中时，我们将为其分配一个特定的样式
- en: We are going to modify the value of `selected` when the component is clicked
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件被点击时，我们将修改 `selected` 的值
- en: 'Let’s start by creating our first private variable. As mentioned earlier, this
    will be done using `ref`. This is a method provided by the Vue library that accepts
    a value that is used to initialize it. For example, if I would like to generate
    a variable for my name, I would write `const name = ref("Simone")`. In our case,
    `selected` is going to be a Boolean, and it is going to be initialized with the
    value `false` because the component is expected not to be selected when first
    rendered:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建第一个私有变量开始。如前所述，这将使用 `ref` 来完成。这是 Vue 库提供的一个方法，它接受一个用于初始化的值。例如，如果我想为我的名字生成一个变量，我会写
    `const name = ref("Simone")`。在我们的情况下，`selected` 将是一个布尔值，并且它将被初始化为 `false`，因为组件在首次渲染时预期不会被选中：
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As displayed in the preceding code snippets, declaring `ref` is quite simple.
    First, we import it from Vue, and then we can call it by passing it the initial
    value of our variable. The rest of the component is omitted but is unchanged from
    the previous sections.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，声明 `ref` 非常简单。首先，我们从 Vue 中导入它，然后我们可以通过传递变量的初始值来调用它。组件的其余部分被省略，但与前几节相同。
- en: 'Next, we create a style for our `selected` state and find a way for this style
    to be added dynamically when the value of `selected` changes. Let’s start by creating
    a new class called `SocialPost__selected` and adding a white border when this
    class is active:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为 `selected` 状态创建一个样式，并找到一种方法，当 `selected` 的值发生变化时动态地添加这个样式。让我们首先创建一个新的类
    `SocialPost__selected`，并在这个类激活时添加一个白色边框：
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are going to add our new style to `SocialPost.vue`. Thanks to the help of
    SCSS,`&` helper in `&__selected`. If you have never seen this syntax before, it
    is a SASS feature that will automatically replace the `&` with the name of the
    parent declaration. So, in our case, `__selected` is going to be prepended with
    `.SocialPost`, creating `.SocialPost__selected`. SASS is not required, and you
    can achieve these styles using plain CSS, but I have decided to add it to show
    you the flexibility of Vue with Vite and to help you experience what a real application
    may utilize.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把新的样式添加到`SocialPost.vue`中。多亏了SCSS的帮助，`&`辅助在`&__selected`中。如果你以前从未见过这种语法，这是一个SASS特性，它将自动将`&`替换为父声明的名称。因此，在我们的情况下，`__selected`将被`.SocialPost`前缀，创建`.SocialPost__selected`。SASS不是必需的，你可以使用纯CSS实现这些样式，但我决定添加它来展示Vue与Vite的灵活性，并帮助你体验真实应用可能利用的功能。
- en: To make the selected post stand out, we just declare a white border around the
    component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使选中的帖子突出，我们只需在组件周围声明一个白色边框。
- en: 'Now it is time to assign this class to our component, but we want to do this
    dynamically depending on the value of `selected`. Our code is going to look like
    this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将这个类分配给我们的组件了，但我们要根据`selected`的值动态地完成这个任务。我们的代码将看起来像这样：
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have just introduced a new feature of Vue.js. In fact, assigning dynamic
    classes is not possible with plain HTML, but Vue has just the right feature for
    us.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了Vue.js的一个新特性。实际上，使用纯HTML无法动态分配类，但Vue正好为我们提供了这个特性。
- en: In *Accessing properties in a Vue.js SFC* , we mentioned that prepending an
    attribute with `:` allows us to provide it dynamic value, and in the case of the
    `class` attribute, allows us to assign one or more dynamic classes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在*在Vue.js SFC中访问属性*中，我们提到，在属性前加上`:`允许我们提供动态值，在`class`属性的情况下，允许我们分配一个或多个动态类。
- en: The `:class` attribute accepts an object that is applied to a specific class
    if its value is truthy. So, in our case, it is going to assign a class of `SocialPost__selected`
    if the value of `selected` is `true`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`:class`属性接受一个对象，如果其值为真，则应用于特定的类。因此，在我们的情况下，如果`selected`的值为`true`，它将分配一个名为`SocialPost__selected`的类。'
- en: We are now ready for our last step, the last part of our component enhancement
    that will allow us to toggle our component and show its selected state.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好进行最后一步，这是我们的组件增强的最后部分，它将使我们能够切换组件并显示其选中状态。
- en: 'So far, we have created a specific style and declared a variable that stores
    our state. What remains is to modify our state variable, `selected`, when the
    component is clicked. We are going to do this by using the `@click` attribute
    in the root of our component:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个特定的样式并声明了一个存储我们状态的变量。剩下要做的就是当组件被点击时修改我们的状态变量`selected`。我们将通过在组件的根目录中使用`@click`属性来完成这项工作：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using the native `@click` event handler and some basic JavaScript, we are
    able to modify our `selected` variables and update our component state.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用原生的`@click`事件处理程序和一些基本的JavaScript，我们能够修改我们的`selected`变量并更新我们的组件状态。
- en: If you are not familiar with the syntax used here, by writing `selected = !selected`,
    we are changing the value of `selected` to be the opposite of the current value.
    So, if the current value is `true`, it will set it to `false`, and vice versa.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个语法不熟悉，通过编写`selected = !selected`，我们正在将`selected`的值更改为当前值的相反。所以如果当前值是`true`，它将设置为`false`，反之亦然。
- en: 'If we run our application and click on one of the components, we should see
    the following result:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的应用程序并点击其中一个组件，我们应该看到以下结果：
- en: '![Figure 3.12: Companion App displaying two posts one of which in a selected
    state with a white border.](img/B21130_03_12.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12：Companion App显示两个帖子，其中一个处于选中状态，带有白色边框。](img/B21130_03_12.jpg)'
- en: 'Figure 3.12: Companion App displaying two posts one of which in a selected
    state with a white border.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：Companion App显示两个帖子，其中一个处于选中状态，带有白色边框。
- en: We have now learned how to declare and use R`efs` to define a component state.
    In the next section, we will move on to our parent component, `TheWelcome.vue`,
    and learn how to use **Reactive**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何声明和使用R`efs`来定义组件状态。在下一节中，我们将继续学习父组件`TheWelcome.vue`，并学习如何使用**响应式**。
- en: Using Reactive to host our post information
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用响应式来托管我们的帖子信息
- en: 'Keeping clean HTML is the key to a maintainable application, so in this section,
    we are going to use Reactive to improve `TheWelcome.vue`. We are going to declare
    a private variable of the `array` type. As we already mentioned above, we are
    going to use Reactive to declare and manage Arrays:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 保持干净的 HTML 是可维护应用程序的关键，因此在本节中，我们将使用 Reactive 来改进 `TheWelcome.vue`。我们将声明一个 `array`
    类型的私有变量。正如我们上面提到的，我们将使用 Reactive 来声明和管理数组：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The use of Reactive is very similar to Ref because it needs to be imported from
    the Vue library and initialized with a base value. In our case, we have assigned
    our variable a name of `posts`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Reactive 的方式与 Ref 非常相似，因为它需要从 Vue 库中导入并使用一个基本值进行初始化。在我们的例子中，我们给我们的变量命名为 `posts`。
- en: 'In the preceding code, the value assigned is an empty array, but we need to
    change this to include the value of the actual posts currently held in the HTML.
    Our Reactive initialization will be changed to the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，分配的值是一个空数组，但我们需要将其更改为包含当前在 HTML 中持有的实际帖子值。我们的 Reactive 初始化将更改为以下内容：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that our variable is ready, it is time to change the content of HTML to
    use our Reactive value. Just like properties and Refs, we can use this directly
    in the HTML.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了变量，是时候更改 HTML 的内容以使用我们的 Reactive 值了。就像属性和 Refs 一样，我们可以在 HTML 中直接使用它。
- en: 'We will access the information in the first post by using `posts[0].username`,
    `posts[0].avatar`, and so on. Just like we did previously, we are going to inform
    Vue.js that the value of our props is dynamic by prepending it with `:`. The component
    should look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 `posts[0].username`、`posts[0].avatar` 等方式访问第一篇帖子的信息。就像我们之前做的那样，我们将通过在前面加上
    `:` 来通知 Vue.js 我们的 props 值是动态的。组件应该看起来像这样：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our template has now been cleaned from the hardcoded value, which has been replaced
    with dynamic values declared using Reactive. Defining components using dynamic
    values with Refs and Reactive will be the foundation of your Vue components for
    the rest of your career.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经从模板中清理了硬编码的值，它已经被使用 Reactive 声明的动态值所替代。使用 Refs 和 Reactive 定义组件将是您整个职业生涯中
    Vue 组件的基础。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced you to some basic Vue features, and we have defined
    the first component for our Companion App. We started the chapter by learning
    how to create a Vue application using the CLI and looked at its folder structure.
    We then created our first Vue component. By doing so, we learned how to write
    and use components with the SFC syntax. We then changed our static component to
    make use of dynamic properties. Finally, we learned about component state and
    learned how to use Refs and Reactive data by enhancing the functionality of our
    components.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了 Vue 的一些基本功能，并为我们伴侣应用程序定义了第一个组件。我们通过学习如何使用 CLI 创建 Vue 应用程序并查看其文件夹结构开始了本章。然后我们创建了我们的第一个
    Vue 组件。通过这样做，我们学习了如何使用 SFC 语法编写和使用组件。然后我们将我们的静态组件更改为使用动态属性。最后，我们学习了组件状态，并通过增强组件的功能学习了如何使用
    Refs 和 Reactive 数据。
- en: Your turn
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 轮到你了
- en: Use the notion of Ref and Reactive in another component. This could be done
    in the `footer.vue` file that you previously created by moving the `link` value
    and `src` into a Reactive property, just like we did for our posts.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个组件中使用 Ref 和 Reactive 的概念。这可以通过将之前创建的 `footer.vue` 文件中的 `link` 值和 `src` 移动到
    Reactive 属性中来实现，就像我们为帖子所做的那样。
- en: In the next chapter, we are going to continue our mission to learn Vue by introducing
    Vue directives. Directives are Vue-specific attributes that give us the ability
    to meet complex requirements with simple code. We are going to first introduce
    the notion of directives and then create new components or update existing ones
    to learn about the different built-in directives available within the Vue framework.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续学习 Vue 的使命，通过介绍 Vue 指令。指令是 Vue 特有的属性，它赋予我们使用简单代码满足复杂需求的能力。我们将首先介绍指令的概念，然后创建新的组件或更新现有的组件来了解
    Vue 框架中可用的不同内置指令。
