- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing Data between Angular Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing data between components is a very common use case in web applications.
    Angular provides many approaches for communicating between parent and child components,
    such as the popular `@Input()` and `@Output()` decorator patterns. The `@Input()`
    decorator allows parent components to provide data to their child components,
    while the `@Output()` decorator allows the child component to send data to a parent
    component. That’s great, but when data needs to be shared between components that
    are either deeply nested or not immediately connected, those kinds of techniques
    become less efficient and difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s the best way to share data between sibling components? This is the
    heart of this chapter. We will start by explaining the sharing data requirement,
    before walking through the different steps to implement the reactive pattern for
    sharing data between sibling components in our app. Finally, we will introduce
    Angular’s new Deferrable Views feature to maximize our app’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the sharing data requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the reactive pattern to share data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Deferrable Views in Angular 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have a basic understanding of RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of this chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the sharing data requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we have four components – **C1**, **C2**, **C3**, and **C4**
    – that do not have any relationship with each other, and there is information
    – **DATA** – shared between those components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Shared data between components](img/B21180_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Shared data between components
  prefs: []
  type: TYPE_NORMAL
- en: The components can update and consume **DATA** at the same time. But at any
    time during the process, the components should be able to access the last value
    of **DATA**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s make that explanation clearer with a more concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe application, when the user clicks on one recipe, it gets selected,
    but we want all components to have access to the last selected recipe by the user.
    In that case, the selected recipe represents our shared data.
  prefs: []
  type: TYPE_NORMAL
- en: One of the components that will need access to the selected recipe is the `RecipeDetailsComponent`
    component, as it will display the details of the selected recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, in the next section, let’s see how we can make this data
    available to everyone in a reactive way.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the reactive pattern to share data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular services are powerful and efficient for creating common references to
    share both data and business logic between components. We will combine Angular
    services with Observables – more specifically, `BehaviorSubject` instances – to
    create stateful, reactive services that will allow us to synchronize the state
    efficiently across an entire application. So, in the following subsections, let’s
    explain the steps to implement a reactive pattern to share data between unrelated
    or sibling components.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Creating a shared service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create an Angular service called `SharedDataService` using the
    Angular CLI, as usual under the `src/app/core/services` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Here, we named the service `SharedDataService` for demonstration purposes. While
    it’s true that we already have a service named `RecipesService` that could have
    accommodated the shared data, the purpose of this chapter is to underscore the
    broader concept of data sharing. Therefore, we chose a more generic term. However,
    in your own application, it’s recommended to use specific and descriptive names
    such as `RecipesService` or another name that accurately reflects the role and
    domain of the service. A name that accurately reflects the purpose of your service
    is crucial for clarity and maintainability, especially in a framework such as
    Angular where conventions can guide developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `SharedDataService` class, we need to create the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A private `BehaviorSubject` instance called `selectedRecipeSubject` that emits
    the value of the currently selected recipe, which represents the data to be shared:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `selectedRecipeSubject` has `Recipe` as the type and `undefined` as the
    initial value since initially, we don’t have any selected value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, `selectedRecipeSubject` is declared as `private` to ensure that it’s only
    accessible within `SharedDataService`, where it’s defined, protecting it from
    external manipulation. Otherwise, any external process could have access to the
    property and consequently call the next method and change the emissions, which
    is dangerous. This encapsulation is important for maintaining control over the
    state and preventing unintended changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A public Observable, named `selectedRecipe$`, extracted from `selectedRecipeSubject`
    to handle data as an Observable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used the `asObservable()` method available in the `Subject` type to
    derive a read-only Observable from `selectedRecipeSubject`. This ensures that
    the emissions of `selectedRecipeSubject` are only consumed in read-only mode,
    preventing external processes from altering the `selectedRecipeSubject` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A method called `updateSelectedRecipe` that will update the shared data, which
    is the selected recipe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method only calls `next` on `selectedRecipeSubject` to notify all subscribers
    of the last selected recipe passed as a parameter. The process that updates the
    selected recipe will call this method, which we will discuss in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is what the service looks like after putting all the pieces together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have prepared the groundwork by creating our shared data service
    and defined the behavior subject that will hold the shared data, let’s see how
    we can update the shared data in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Updating the last selected recipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should update the shared `selectedRecipe` instance when the user clicks
    on one of the recipe cards in the `RecipesListComponent` component. As a reminder,
    here are the recipe cards in our `Recipe` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – List of recipes](img/B21180_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – List of recipes
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to update the shared `selectedRecipe` instance when the user clicks
    on the card, we need to incorporate the `(click)` event output in the `RecipesListComponent`
    HTML template, which triggers the execution of the `editRecipe(recipe)` method.
    This is the HTML code required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `(click)` event binding is applied to each card, ensuring that when clicked,
    the `editRecipe(recipe)` method is invoked to update the `selectedRecipe` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `RecipesListComponent`, we implement the `editRecipe` method as follows
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `editRecipe` method takes the selected recipe as the input and performs
    two actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It notifies `selectedRecipeSubject` that the value of `selectedRecipe` has
    changed by calling the `updateSelectedRecipe(recipe:Recipe)` method, available
    in `SharedDataService`. So, we should inject the `SharedDataService` service in
    `RecipesListComponent` as follows :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It displays the details of the recipe by routing to `RecipeDetailsComponent`,
    the standalone component responsible for rendering and displaying the details
    of a recipe. We’ve added a route configuration in the `app-routing-module.ts`
    file as follows :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we have put in place the mechanism that updates the value of
    the shared data. Now, all that is left is to listen to the shared data and consume
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Consuming the last selected recipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `RecipeDetails` component, we need to consume the last selected recipe
    in order to display its details. So, again, we need to inject `SharedDataService`
    and define the `selectedRecipe$` Observable – which will emit the last selected
    recipe – as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will subscribe to the `selectedRecipe$` Observable using the `async`
    pipe in the `RecipeDetailsComponent` HTML template in order to display the selected
    recipe’s details, as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it – this is how you can share data between unrelated components
    throughout the application!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the latest value of the recipe everywhere – we only have to
    inject `SharedDataService` into the component that needs the shared data and subscribe
    to the public Observable that emits the read-only value. For example, we can add
    this code in `HeaderComponent` to display the title of the last selected recipe
    in the application’s header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we change the shared value in this component, all other components that listen
    to the shared data will get notified to update their processes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We used this pattern in [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083), *Combining
    Streams*, to share the value of the filter in `RecipesFilterComponent` with `RecipesListComponent`
    instances, and then we combined the streams to display the filtered results.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up the data-sharing reactive pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize everything, here’s a wrap-up of the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by creating an Angular service that will be shared across components.
    Within this service, define a private `BehaviorSubject` instance that will emit
    the shared value to its subscribers, remembering to specify the type of data emitted
    by `BehaviorSubject` and initialize it with the initial value of the shared data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s important to note that we use `BehaviorSubject` for two primary reasons:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It allows us to broadcast shared data to multiple observers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It stores the latest value emitted to its observers, and any new subscriber
    immediately receives the last emitted value upon subscription.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, define a public Observable within the shared service to hold the read-only
    shared value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an `update` method within the shared service to update the shared
    value by calling the `next` method of the `Subject` type to emit the updated value
    to subscribers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inject the shared service in the component responsible for updating the value
    of the shared data and call the `update` method implemented in the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inject the shared service in the component that consumes the value of the shared
    data and subscribe to the exposed Observable in the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This reactive sharing data pattern has many benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It improves the sharing of data between unrelated components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It manages mutability risk. In fact, as we only expose the read-only extracted
    Observable to other consumers and keep `BehaviorSubject` private, we prevent shared
    data from being modified by subscribers, which can lead to data corruption and
    unexpected behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes communication between components easier as you will only have to inject
    the shared service where you need it and just take care of updating the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As far as I’m concerned, this is the simplest way to share data between unrelated
    components in Angular and manage the application state. This works perfectly in
    many situations, but for big applications where there are a lot of user interactions
    and multiple data sources, managing states in services can become complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In those cases, we can use a state management library to manage the state of
    our application. There are many great state management libraries out there to
    manage states in Angular, all with one thing in common – they are built on top
    of RxJS Observables, and the state is stored in `BehaviorSubject`. The most popular
    state management library is NgRx, which you can find out more about here: [https://ngrx.io/guide/store](https://ngrx.io/guide/store).'
  prefs: []
  type: TYPE_NORMAL
- en: Data-sharing mechanisms facilitate communication between different components
    and improve the user experience, as well as the responsiveness of your application.
    Before ending this chapter, I want to shed light on a new feature introduced in
    Angular 17, Deferrable Views, which can complement data sharing and contribute
    to creating more responsive and efficient applications. Let’s see this in action
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Deferrable Views in Angular 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Deferrable Views** allow you to declaratively mark parts of your templates
    as non-essential for immediate rendering. It is kind like delaying the rendering
    of certain parts of a page to improve the perceived performance of your application,
    as well as optimize the initial bundle size and loading times.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of real-world scenarios where defer rendering can help to
    achieve faster load times such as e-commerce product pages – in this example,
    you can initially display the essential product details and then lazy load additional
    content such as reviews when the user clicks on a **Read more** button or scrolls
    down the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly see how this works. To lazy load a component, you need to use
    a Standalone component, otherwise deferring won’t work. Then you want to wrap
    up the Standalone component in a `@defer` block, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define conditions for when exactly the deferred component should
    load. You can do this by using **triggers**, which specify events or situations
    that initiate loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `on viewport` trigger is used to display the `delayed-component` when
    it enters the viewport area of the user’s browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `on viewport`, there are other triggers that can be used such as `on
    hover`, which only initiates the content to load when the user’s mouse hovers
    over the delayed content. You can find a full list of available triggers here:
    [https://angular.dev/guide/defer#triggers](https://angular.dev/guide/defer#triggers).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the `@defer` block has some important sub-blocks. For example,
    you can display alternative content before the deferred content loads using the
    `@placeholder` sub-block, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to `@placeholder`, `@defer` also offers two other sub-blocks –
    `@loading` and `@``error` :'
  prefs: []
  type: TYPE_NORMAL
- en: The `@loading` block is similar to the `@placeholder` block, but it specifically
    shows content like a loading message while the actual content is being prepared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@error` block is displayed if there is an error while fetching or processing
    the deferred content. This allows you to provide a user-friendly error message,
    or alternative content, in case something goes wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s look at how we can utilize defer rending in our Recipe app. Given
    that the images for each recipe have a high resolution, let’s delay the rendering
    of the images in `RecipesListComponent` HTML template so that they are only shown
    when the user hovers over the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we surrounded the code block displaying the image with a `@defer`
    block, and used the `on hover` trigger. Then we used the `@placeholder` block
    to specify some text that should be displayed while the deferred content is not
    yet loaded. In this case, inside the <div> element, we added the text, **Hover
    to load** **the image**.
  prefs: []
  type: TYPE_NORMAL
- en: For more details about the Deferrable Views feature, refer to [https://angular.dev/guide/image-optimization](https://angular.dev/guide/image-optimization).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained the motivation behind sharing data between components
    and learned how to implement it in a reactive way. First, we learned how we can
    use `BehaviorSubject` combined with Angular services to share data between unrelated
    components and manage our application state. Then, we highlighted the advantages
    of the sharing data reactive pattern. Finally, we explored Angular’s new Deferrable
    Views feature.
  prefs: []
  type: TYPE_NORMAL
- en: The features covered in this chapter will help you implement a good architecture
    for your web application, making it more reactive and performant, improving load
    times, and reducing the cost of maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Now, get ready for an exciting journey, because in the next chapter, we delve
    into a brand-new feature called Angular Signals! We’ll cover some reactive patterns
    using Signals and even integrate them into what we’ve learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: The Power of Angular Signals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dive into the exciting world of Angular Signals!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will discover the core functionalities and advantages of
    Angular Signals, as well as unlock the potential of reactivity by leveraging Angular
    Signals and RxJS together. We will also go through the latest Angular Signals
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21180_08.xhtml#_idTextAnchor119), *Mastering Reactivity with
    Angular Signals*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
