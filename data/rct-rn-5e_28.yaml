- en: '26'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '26'
- en: Using Animations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画
- en: Animations can be used to improve the user experience in mobile applications.
    They usually help users to quickly recognize that something has changed, or help
    them focus on what is important. They improve the user experience and user satisfaction.
    Also, animations are simply fun to look at. For example, the heartbeat reaction
    in the Instagram app when you like a post or the Snapchat ghost animation when
    refreshing a page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 动画可以用来提升移动应用程序的用户体验。它们通常帮助用户快速识别出变化，或者帮助他们关注重要的事情。它们提升了用户体验和用户满意度。此外，动画看起来也很有趣。例如，在
    Instagram 应用中点赞帖子时的心跳反应，或者在 Snapchat 刷新页面时的幽灵动画。
- en: There are a couple of different approaches to processing and controlling animations
    in React Native. Firstly, we will take a look at animation tools that we can use,
    discover their pros and cons, and compare them. Then, we will implement several
    examples to get to know APIs better.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 中处理和控制动画有几种不同的方法。首先，我们将看看我们可以使用的动画工具，发现它们的优缺点，并进行比较。然后，我们将实现几个示例，以更好地了解
    API。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个章节中，我们将涵盖以下主题：
- en: Using React Native Reanimated
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Native Reanimated
- en: Animating layout components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化布局组件
- en: Animating component styles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化组件样式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter26](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter26).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到这个章节的代码文件，链接为 [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter26](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter26)。
- en: Using React Native Reanimated
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Native Reanimated
- en: In the React Native world, we have a lot of libraries and approaches to animate
    our components, including the built-in **Animated API**. But in this chapter,
    I would like to opt for a library called **React Native Reanimated** and compare
    it with the Animated API to learn why it is the best choice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 世界中，我们有大量的库和方案来动画化我们的组件，包括内置的 **Animated API**。但在这个章节中，我想要选择一个名为
    **React Native Reanimated** 的库，并将其与 Animated API 进行比较，以了解为什么它是最佳选择。
- en: The Animated API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Animated API
- en: The **Animated API** is the most common tool used to animate components in React
    Native. It has a set of methods that help you to create an animation object, control
    its state, and process it. The main benefit is that it can be used with any component,
    and not just animated components such as View or Text.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Animated API** 是在 React Native 中用于动画化组件最常用的工具。它提供了一系列方法，帮助你创建动画对象，控制其状态，并处理它。主要好处是它可以与任何组件一起使用，而不仅仅是像
    View 或 Text 这样的动画组件。'
- en: But, at the same time, this API has been implemented in the old architecture
    of React Native. Asynchronous communications between JavaScript and UI Native
    threads are used with the Animated API, delaying updates by at least one frame
    and lasting approximately 16 ms. Sometimes, the delay may last even longer if
    the JavaScript thread is running React’s diff algorithm and comparing or processing
    network requests simultaneously. The problem of dropped or delayed frames can
    be solved with the React Native Reanimated library, which is based on the new
    architecture and processes all business logic from the JavaScript thread in the
    UI thread.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，同时，这个 API 已经在 React Native 的旧架构中实现了。JavaScript 和 UI Native 线程之间的异步通信使用 Animated
    API，导致更新至少延迟一帧，持续大约 16 毫秒。有时，如果 JavaScript 线程正在运行 React 的 diff 算法，同时比较或处理网络请求，延迟可能会更长。React
    Native Reanimated 库可以解决这个问题，它基于新的架构，并在 UI 线程中从 JavaScript 线程处理所有业务逻辑。
- en: React Native Reanimated
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Native Reanimated
- en: '**React Native Reanimated** can be utilized to provide a more exhaustive abstraction
    of the Animated API to use with React Native. It provides an imperative API with
    multistage animations and custom transitions, while at the same time providing
    a declarative API that can be used to describe simple animations and transitions
    in a similar way to how CSS transitions work. It’s built on top of React Native
    Animated and reimplements it on the Native thread. This allows you to use the
    familiar JavaScript language while taking advantage of the most high performance
    and simple API.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Native Reanimated** 可以用来提供对 Animated API 的更全面的抽象，以便与 React Native 一起使用。它提供了一个具有多阶段动画和自定义过渡的命令式
    API，同时提供了一个声明式 API，可以用来以类似 CSS 过渡的方式描述简单的动画和过渡。它是建立在 React Native Animated 之上的，并在原生线程上重新实现了它。这允许你在使用最高性能和最简单的
    API 的同时，利用熟悉的 JavaScript 语言。'
- en: 'Furthermore, React Native Reanimated defines worklets, which are JavaScript
    functions that can be synchronously executed within the UI thread. This allows
    instant animations without having to wait for a new frame. Let’s take a look at
    what a simple worklet looks like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React Native Reanimated 定义了 worklets，这些是可以在 UI 线程中同步执行的 JavaScript 函数。这允许在不等待新帧的情况下进行即时动画。让我们看看一个简单的
    worklet 是什么样子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The only thing that is needed for the `simpleWorklet` function to get called
    inside the UI thread is to add the `worklet` directive at the top of the `function`
    block.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 UI 线程内调用 `simpleWorklet` 函数，只需在 `function` 块的顶部添加 `worklet` 指令即可。
- en: 'React Native Reanimated provides a variety of hooks and methods that help us
    handle animations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: React Native Reanimated 提供了各种钩子和方法，帮助我们处理动画：
- en: '`useSharedValue`: This hook returns a `SharedValue` instance, which is the
    main stateful data object that lives in the UI thread context and has a similar
    concept to `Animated.Value` in the core Animated API. A Reanimated animation is
    triggered when `SharedValue` is changed. The key benefit is that updates to shared
    values can be synchronized across the React Native and UI threads without triggering
    a re-render. This enables complex animations to run smoothly at 60 FPS without
    blocking the JS thread.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useSharedValue`：这个钩子返回一个 `SharedValue` 实例，这是在 UI 线程上下文中存在的主要有状态数据对象，其概念与核心
    Animated API 中的 `Animated.Value` 类似。当 `SharedValue` 发生变化时，会触发 Reanimated 动画。主要好处是共享值的更新可以在
    React Native 和 UI 线程之间同步，而不会触发重新渲染。这使复杂的动画能够在 60 FPS 下平稳运行，而不会阻塞 JS 线程。'
- en: '`useDerivedValue`: This hook creates a new shared value that automatically
    updates whenever the shared values used in its calculation change. It allows you
    to create shared values that depend on other shared values, while keeping them
    all reactive. `useDerivedValue` is used to create a **derived** state in a worklet
    that runs on the UI thread based on updates to the source shared values. This
    derived state can then drive animations or other side effects without triggering
    a re-render on the JS thread.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDerivedValue`：这个钩子创建了一个新的共享值，当其计算中使用的共享值发生变化时，它会自动更新。它允许你创建依赖于其他共享值的共享值，同时保持它们的所有反应性。`useDerivedValue`
    用于在 UI 线程上运行的 worklet 中创建 **派生** 状态，该状态基于源共享值的更新。然后，这个派生状态可以驱动动画或其他副作用，而不会在 JS
    线程上触发重新渲染。'
- en: '`useAnimatedStyle`: The hook allows you to create a style object with the ability
    to animate its properties based on shared values. It maps shared value updates
    to the corresponding view properties. `useAnimatedStyle` is the main way to connect
    shared values to views and enable smooth animations running on the UI thread.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAnimatedStyle`：这个钩子允许你创建一个可以基于共享值动画其属性的风格对象。它将共享值更新映射到相应的视图属性。`useAnimatedStyle`
    是将共享值连接到视图并启用在 UI 线程上运行的平滑动画的主要方式。'
- en: '`withTiming`, `withSpring`, `withDecay`: These are animation utility methods
    that update a shared value in a smooth, animated way using various curves and
    physics. They allow you to define animations declaratively by specifying the target
    value and animation configuration.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withTiming`、`withSpring`、`withDecay`：这些是动画实用方法，它们使用各种曲线和物理方式以平滑、动画的方式更新共享值。它们允许你通过指定目标值和动画配置来声明式地定义动画。'
- en: We have learned what React Native Reanimated is and how it is different from
    the Animated API. Next, let’s try to install it and apply it to our app.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 React Native Reanimated 是什么以及它与 Animated API 的不同之处。接下来，让我们尝试安装它并将其应用到我们的应用中。
- en: Installing the React Native Reanimated library
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 React Native Reanimated 库
- en: 'To install the React Native Reanimated library, run this command inside your
    Expo project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 React Native Reanimated 库，请在您的 Expo 项目内部运行此命令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the installation is complete, we need to add the **Babel** plugin to
    `babel.config.js`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要将 **Babel** 插件添加到 `babel.config.js` 文件中：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main purpose of that plugin is to convert our JavaScript worklet functions
    into functions that will work in the UI thread.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件的主要目的是将我们的 JavaScript worklet 函数转换为将在 UI 线程中工作的函数。
- en: 'After you add the Babel plugin, restart your development server and clear the
    bundler cache:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 Babel 插件后，重新启动您的开发服务器并清除 bundler 缓存：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This section has introduced us to the React Native Reanimated library. We have
    found out why it is better than the built-in Animated API. In the next sections,
    we will use it in real examples.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向我们介绍了 React Native Reanimated 库。我们了解到为什么它比内置的 Animated API 更好。在下一节中，我们将使用实际示例来展示它。
- en: Animating layout components
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局组件的动画
- en: A common use case is animating the entering and exiting layouts of your components.
    This means that when your component renders for the first time and when you unmount
    your component, it appears animated. React Native Reanimated is an API that lets
    you animate layouts and add animations such as `FadeIn`, `BounceIn`, and `ZoomIn`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是动画化组件的进入和退出布局。这意味着当您的组件首次渲染时以及当您卸载组件时，它将以动画形式出现。React Native Reanimated
    是一个 API，允许您动画化布局并添加如 `FadeIn`、`BounceIn` 和 `ZoomIn` 等动画。
- en: 'React Native Reanimated also provides a special `Animated` component that is
    the same as the `Animated` component in the Animated API, but with additional
    props:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React Native Reanimated 还提供了一个特殊的 `Animated` 组件，它与 Animated API 中的 `Animated`
    组件相同，但具有额外的属性：
- en: '`entering`: Accepts a predefined animation when the component mounts and renders'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entering`：在组件挂载和渲染时接受预定义的动画'
- en: '`exiting`: Accepts the same animation object, but it will be called when the
    component unmounts'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exiting`：接受相同的动画对象，但将在组件卸载时被调用'
- en: Let’s create a simple to-do list with a button for creating tasks and a feature
    that allows us to delete tasks when we click on them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的待办事项列表，其中包含创建任务的按钮和允许我们在点击时删除任务的功能。
- en: It’s impossible to see animations in screenshots, so I suggest you open the
    code and try to implement the animations to see the results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 截图中无法看到动画，所以我建议你打开代码并尝试实现动画以查看结果。
- en: 'Firstly, let’s take a look at the main screen of our to-do list app and how
    the items are rendering at the moment:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的待办事项应用的主屏幕以及当前项目是如何渲染的：
- en: '![Picture 1](img/B19636_26_01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](img/B19636_26_01.png)'
- en: 'Figure 26.1: To-do list'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26.1：待办事项列表
- en: 'This is a simple example with a list of task items and one button for adding
    new tasks. When we quickly press the **Add** button several times, the list items
    come from the left side of the screen with an animation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，包含任务项列表和一个用于添加新任务的按钮。当我们快速多次按下 **添加** 按钮时，列表项会以动画形式从屏幕左侧出现：
- en: '![Picture 2](img/B19636_26_02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2](img/B19636_26_02.png)'
- en: 'Figure 26.2: To-do list with animated rendering'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26.2：具有动画渲染的待办事项列表
- en: 'The magic is implemented in the `TodoItem` component. Let’s take a look at
    it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法是在 `TodoItem` 组件中实现的。让我们看看它：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, there is no complicated logic, and there isn’t too much code.
    We just take the `Animated` component as the root of animation and pass predefined
    animations from the React Native Reanimated library to the `entering` and `exiting`
    props.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有复杂的逻辑，代码也不是很多。我们只是将 `Animated` 组件作为动画的根组件，并将 React Native Reanimated
    库中预定义的动画传递给 `entering` 和 `exiting` 属性。
- en: 'To see how the items disappear from the screen, we need to press the to-do
    items so the exiting animation will run. I’ve pressed a few items and tried to
    catch the result in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到项目如何从屏幕上消失，我们需要按下待办事项项目，这样退出动画就会运行。我已经按下了几个项目，并尝试在下面的屏幕截图中捕捉结果：
- en: '![Picture 3](img/B19636_26_03.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3](img/B19636_26_03.png)'
- en: 'Figure 26.3: Deleting to-do items from the screen'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26.3：从屏幕上删除待办事项
- en: 'Let’s examine the `App` component to see the entire picture:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `App` 组件以了解整个情况：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have created a `todoList` state using the `useState` hook and handler functions
    for adding and deleting tasks. Next, let’s take a look at how the animation will
    be applied to the layout:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `useState` 钩子和添加和删除任务的处理器函数创建了一个 `todoList` 状态。接下来，让我们看看动画将如何应用于布局：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we learned a simple way to apply animations to make our app
    look better. However, the React Native Reanimated library is a lot more powerful
    than we imagined. The next example illustrates how we can animate and create our
    own animations by applying them directly to the styles of our components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们学习了一种简单的方法来应用动画，使我们的应用看起来更好。然而，React Native Reanimated库比我们想象的要强大得多。下一个示例将说明我们如何通过直接将动画应用于组件的样式来动画化和创建自己的动画。
- en: Animating component styles
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件样式动画
- en: In a more complex example, I suggest creating a button with beautiful tappable
    feedback. This button will be built using the `Pressable` component that we learned
    about in *Chapter 23*, *Responding to User Gestures*. This component accepts the
    `onPressIn`, `onLongPress`, and `onPressOut` events. As a result of these events,
    we will be able to see how our touches will be reflected on the button.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更复杂的示例中，我建议创建一个具有美丽可触摸反馈的按钮。这个按钮将使用我们在第23章“响应用户手势”中学到的`Pressable`组件来构建。该组件接受`onPressIn`、`onLongPress`和`onPressOut`事件。由于这些事件，我们将能够看到我们的触摸如何在按钮上反映。
- en: 'Let’s start by defining `SharedValue` and `AnimatedStyle`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义`SharedValue`和`AnimatedStyle`：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to animate style properties, we have created a `SharedValue` object
    using the `useSharedValue` hook. It takes default values as an argument. Next,
    we created the style object with the `useAnimatedStyle` hook. The hook accepts
    the callback that should return a style object. The `useAnimatedStyle` hook is
    similar to the `useMemo` hook, but all calculations are performed in the UI thread
    and all `SharedValue` changes will invoke the hook to recalculate the style object.
    The background color of the button was created using `useDerivedValue` by interpolating
    between orange and red to provide a smooth transition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动画化样式属性，我们使用`useSharedValue`钩子创建了一个`SharedValue`对象。它接受默认值作为参数。接下来，我们使用`useAnimatedStyle`钩子创建了样式对象。该钩子接受一个回调，该回调应返回一个样式对象。`useAnimatedStyle`钩子与`useMemo`钩子类似，但所有计算都在UI线程中执行，并且所有`SharedValue`的变化都将触发钩子重新计算样式对象。按钮的背景色是通过`useDerivedValue`创建的，通过在橙色和红色之间插值来提供平滑的过渡。
- en: 'Next, let’s create handler functions that will update the style properties
    in relation to the pressing state of the button:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建处理函数，这些函数将根据按钮的按下状态更新样式属性：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first handler, `onPressIn`, updates `borderRadius`, `opacity`, and `scale`
    from their default values. We also update these values using `withSpring`, which
    makes updating styles smoother. Like the first handler, other ones will also update
    the style of the button but in different ways. `onLongPress` turns the button
    red and makes it smaller. `onPressOut` resets all values to their default values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个处理函数`onPressIn`将`borderRadius`、`opacity`和`scale`从它们的默认值更新。我们同样使用`withSpring`来更新这些值，这使得更新样式更加平滑。像第一个处理函数一样，其他处理函数也会以不同的方式更新按钮的样式。`onLongPress`将按钮变为红色并使其变小。`onPressOut`将所有值重置为它们的默认值。
- en: 'We’ve implemented all necessary logic and can now apply it to the layout:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了所有必要的逻辑，现在可以将其应用于布局：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, let’s take a look at the result:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看结果：
- en: '![Picture 4](img/B19636_26_04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4](img/B19636_26_04.png)'
- en: 'Figure 26.4: Button with default, pressed, and long-pressed styles'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.4：具有默认、按下和长按样式的按钮
- en: 'In *Figure 26.4*, you can see the three states of the button: default, pressed,
    and long-pressed.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图26.4*中，你可以看到按钮的三个状态：默认、按下和长按。
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve learned how to use the React Native Reanimated library
    to add animations to the layout and components. We’ve gone through the basic principles
    of the library and found out how it works under the hood and how it executes code
    inside the UI thread without using Bridge to connect JavaScript and Native layers
    of the app.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用React Native Reanimated库向布局和组件添加动画。我们了解了库的基本原理，并发现了它在底层的工作方式以及它是如何在不使用Bridge连接应用JavaScript和原生层的情况下在UI线程中执行代码的。
- en: We also went through two examples using the React Native Reanimated library.
    In the first example, we learned how to apply a layout animation using predefined
    declarative animations to get our component to appear and disappear beautifully.
    In the second example, we animated the button’s styles with the `useSharedValue`
    and `useAnimatedStyle` hooks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过两个使用React Native Reanimated库的示例进行了说明。在第一个示例中，我们学习了如何使用预定义的声明式动画来应用布局动画，使我们的组件以美丽的方式出现和消失。在第二个示例中，我们使用`useSharedValue`和`useAnimatedStyle`钩子来动画化按钮的样式。
- en: Skills to animate components and layout will help you make your app more beautiful
    and responsive. In the next chapter, we’ll learn about controlling images in our
    apps.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 动画组件和布局的技巧将帮助您使您的应用更加美观和响应。在下一章中，我们将学习如何在我们的应用中控制图像。
