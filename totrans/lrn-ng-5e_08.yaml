- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communicating with Data Services over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A real-world scenario for enterprise Angular applications is to connect to remote
    services and APIs to exchange data. The Angular HTTP client provides out-of-the-box
    support for communicating with services over HTTP. The interaction of an Angular
    application with the HTTP client is based on RxJS observable streams, giving developers
    a rich set of capabilities for data access.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to connect to APIs through HTTP. In this book, we will only
    scratch the surface. Still, the insights covered in this chapter will give you
    all you need to connect your Angular applications to HTTP services in no time,
    leaving all you can do with them up to your creativity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating data over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Angular HTTP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a backend API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling CRUD data in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization with HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapter contains various code samples to walk you through the concept of
    the Angular HTTP client. You can find the related source code in the `ch08` folder
    of the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating data over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into describing the Angular HTTP client and how to use it to
    communicate with servers, let’s talk about native HTTP implementations first.
    Currently, if we want to communicate with a server over HTTP using JavaScript,
    we can use the JavaScript-native `fetch` API. It contains all the necessary methods
    to connect with a server and exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an example of how to fetch data in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although the `fetch` API is promise-based, the promise it returns is not rejected
    if there is an error. Instead, the request is unsuccessful when the `ok` property
    is not in the `response` object.
  prefs: []
  type: TYPE_NORMAL
- en: If the request to the remote URL is completed, we can use the `text()` method
    of the `response` object to return the response text inside a new promise. Finally,
    in the second `then` callback, we display either the response text or a specific
    error message to the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the `fetch` API, check out the official documentation at
    [https://developer.mozilla.org/docs/Web/API/fetch](https://developer.mozilla.org/docs/Web/API/fetch)
    .
  prefs: []
  type: TYPE_NORMAL
- en: We have already learned that observables are flexible for managing asynchronous
    operations. You are probably wondering how we can apply this pattern when consuming
    information from an HTTP service. So far, you will be becoming used to submitting
    asynchronous requests to AJAX services and then passing the response to a callback
    or a promise. Now, we will handle the call by returning an observable. The observable
    will emit the server response as an event in the context of a stream, which can
    be funneled through RxJS operators to better digest the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s convert the previous example with the `fetch` API to an observable. We
    use the `Observable` class to wrap the `fetch` call in an observable stream and
    replace the `console` methods with the appropriate `observer` object methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we use the following `observer` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next` : This returns the response data to subscribers when they arrive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complete` : This notifies subscribers that no other data will be available
    in the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error` : This alerts subscribers that an error has occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s it! We have now built a custom HTTP client. Of course, this isn’t much.
    Our custom HTTP client only handles a **GET** operation to get data from a remote
    endpoint. We are not handling many other operations of the HTTP protocol, such
    as **POST** , **PUT** , and **DELETE** . It was, however, essential to realize
    all the heavy lifting the HTTP client in Angular is doing for us. Another important
    lesson is how easy it is to turn an asynchronous API into an observable API that
    fits nicely with the rest of our asynchronous concepts. So, let’s continue with
    Angular’s implementation of an HTTP service.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Angular HTTP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP client of the Angular framework is a separate Angular library that
    resides in the `@angular/common` npm package under the `http` namespace. The Angular
    CLI installs this package by default when creating a new Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: You will need the source code of the Angular application we created in *Chapter
    6* , *Reactive Patterns in Angular* , to follow along with the rest of the chapter.
    After you get the code, we suggest you remove the `key-logger` folder for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using the Angular HTTP client, we need to import the `provideHttpClient`
    method in the `app.config.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we want to use the HTTP client in applications built with older versions
    of Angular. In that case, we need to import an Angular module, called `HttpClientModule`
    , from the `@angular/common/http` namespace into one of the modules of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `provideHttpClient` method exposes various Angular services we can use
    to handle asynchronous HTTP communication. The most basic is the `HttpClient`
    service, which provides a robust API and abstracts all operations required to
    handle asynchronous connections through the following HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get` : This performs a **GET** operation to fetch data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post` : This performs a **POST** operation to add new data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put` / `patch` : This performs a **PUT** / **PATCH** operation to update existing
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete` : This performs a **DELETE** operation to remove existing data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous HTTP methods constitute the primary operations for **Create, Read,
    Update, Delete** ( **CRUD** ) applications. All the earlier methods of the Angular
    HTTP client return an observable data stream. Angular components can use the RxJS
    library to subscribe to those methods and interact with a remote API.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular team is currently investigating and experimenting to see if they
    can make the use of RxJS optional in the framework. In that case, we might see
    an HTTP implementation that is based on signals. For the rest of this chapter,
    we will stick with observables because the Angular HTTP client does not support
    signals out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explore how to use these methods and communicate
    with a remote API.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a backend API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web CRUD application usually connects to a server and uses an HTTP backend
    API to perform operations on data. It fetches existing data, updates it, creates
    new data, or deletes it.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world scenario, you will most likely interact with a real backend
    API service through HTTP. In this book, we will use a fake API called **Fake Store
    API** .
  prefs: []
  type: TYPE_NORMAL
- en: The official Fake Store API documentation can be found at [https://fakestoreapi.com](https://fakestoreapi.com)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fake Store API is a backend REST API available online that you can use
    when you need fake data for an e-commerce or e-shop web application. It can manage
    products, shopping carts, and users available in the JSON format. It exposes the
    following main endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '**products** : This manages a set of product items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cart** : This manages the shopping cart of a user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**user** : This manages a collection of application users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**login** : This handles user authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will work only with the products and login endpoints. However,
    we will revisit the cart endpoint later in the book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All operations that modify data do not persist them physically in a database.
    However, they return an indication of whether the operation was successful. All
    operations that get data return a predefined collection of items.
  prefs: []
  type: TYPE_NORMAL
- en: Handling CRUD data in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CRUD applications are widely used in the Angular world. You will hardly find
    any web application that does not follow this pattern. Angular does a great job
    of supporting this type of application by providing the `HttpClient` service.
    In this section, we will explore the Angular HTTP client by interacting with the
    products endpoint of the Fake Store API.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data through HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ProductListComponent` class uses the `ProductsService` class to fetch
    and display product data. Data is currently hardcoded into the `products` property
    of the `ProductsService` class. In this section, we will modify our Angular application
    to work with live data from the Fake Store API:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `app.component.ts` file and remove the `providers` property from the
    `@Component` decorator. We will provide `APP_SETTINGS` directly through the application
    configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we can also remove the `title` property, the `title$` observable,
    the `setTitle` property, and the `constructor` of the component class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.html` file and modify the `<header>` HTML element so
    that it uses the `settings` object directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.config.ts` file and add the `APP_SETTINGS` provider as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We provide `APP_SETTINGS` from the application configuration file because we
    want it to be accessible globally in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.settings.ts` file and add a new property in the `AppSettings`
    interface that represents the URL of the Fake Store API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The URL of a backend API can also be added in environment files, as we will
    learn in *Chapter 14* , *Bringing Applications to Production* .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and modify the `import` statements accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following property in the `ProductsService` class that represents
    the API products endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `constructor` to inject the `HttpClient` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `getProducts` method so that it uses the `HttpClient` service to
    get the list of products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we use the `get` method of the `HttpClient` class and
    pass the products endpoint of the API as a parameter. We also define the `Product`
    as a generic type in the `get` method to indicate that the response from the API
    contains a list of `Product` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert the `products` property to an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use this for local cache purposes later, in the *Modifying data through
    HTTP* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.html` file and modify the `@if` block so that
    it checks if the `products` template variable exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to check if the variable exists because data is now fetched from the
    Fake Store API and there will be a network delay before the variable has a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the application using the `ng serve` command, we should see an extended
    list of products from the API similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B21418_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Product list from the Fake Store API'
  prefs: []
  type: TYPE_NORMAL
- en: 'The products endpoint supports passing a request parameter to limit the results
    returned from the API. As indicated at [https://fakestoreapi.com/docs#p-limit](https://fakestoreapi.com/docs#p-limit)
    , we can use a query parameter named **limit** to accomplish that task. Let’s
    see how we can pass query parameters in the Angular HTTP client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and import the `HttpParams` class from
    the `@angular/common/http` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `HttpParams` class is used to pass query parameters in an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following variable inside the `getProducts` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `HttpParams` class is immutable. The following would not work because every
    operation returns a new instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set` method of the `HttpParams` class creates a new query parameter. If
    we wanted to pass additional parameters, we should chain more `set` methods, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the second parameter of the `get` method to pass query parameters using
    the `params` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your changes, wait for the application to reload, and observe the application’s
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Product list'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding list, all products are displayed with the same tag icon, which
    is the default one according to the `@switch` block in the `product-list.component.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `@switch` block relies on the product `title` property. We will change it
    so that it is based on the `category` property, which comes from the products
    endpoint of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product.ts` file and replace the `categories` property with the following
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-list.component.html` file and modify the `@switch` block
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to modify the `product-detail.component.html` file because we
    replaced the `categories` property in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your changes, wait for the application to reload, and observe the application’s
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![img](img/B21418_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Product list with categories'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on a product in the list, you will notice that the product details
    are shown correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Product details'
  prefs: []
  type: TYPE_NORMAL
- en: 'The product details component continues to work as expected because we pass
    the selected product as an input property from the product list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will change the previous behavior and get the product details directly from
    the API using an HTTP GET request. The Fake Store API contains an endpoint method
    that we can use to get the details for a specific product based on its ID:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and create a new `getProduct` method that
    accepts the product `id` as a parameter and initiates a GET request to the API
    based on that `id` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method uses the `get` method of the `HttpClient` service. It accepts
    the products endpoint URL followed by the product `id` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.ts` file and modify the `import` statements
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following property in the `ProductDetailComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `id` component property will be used to pass the ID of the selected product
    from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `product` input property with the following observable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `product$` property will be used to call the `getProduct` method from the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `constructor` in the `ProductDetailComponent` class and inject `ProductsService`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `OnChanges` in the list of implemented interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ngOnChanges` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we assign the value of the `getProduct` method from
    `ProductsService` to the `product$` component property every time a new `id` is
    passed using the input binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.html` file and modify its content so that
    it uses the `product$` observable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, open the `product-list.component.html` file and bind the `id` of the
    `selectedProduct` property to the `id` input binding of the `<app-product-detail>`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run the application using the `ng serve` command and select a product
    from the list, we will verify that the product detail is displayed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to get a list of items and a single item from a backend
    API and covered the **Read** part of a CRUD operation. In the following section,
    we cover the remaining parts of a CRUD operation, which are mainly concerned with
    modifying data.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying data through HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modifying data in a CRUD application usually refers to adding new data and
    updating or deleting existing data. To demonstrate how to implement such functionality
    in an Angular application using the HTTP client, we will make the following changes
    to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Angular component to add new products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the product detail component to change the price of an existing product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a button in the product detail component to delete an existing product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already mentioned that no HTTP operations persist data physically in
    the Fake Store API, so we need to implement a local cache mechanism for our product
    data and interact with it directly in the products service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and import the `map` RxJS operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `getProducts` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method fills the `products` array with data from the API and returns
    product data as an observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `getProduct` method so that it uses the `products` array to return
    a product object instead of the Fake Store API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have our products service in place and can start building the component
    for adding new products.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a new product through our application, we need to send its details to
    the Fake Store API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `post` method of the `HttpClient` class
    and pass the products endpoint of the API along with a new product object as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We define the new product as `Partial` because new products do not have an ID.
  prefs: []
  type: TYPE_NORMAL
- en: The generic type defined in the `post` method indicates that the returned product
    from the API is a `Product` object. We also add the new product into the local
    cache and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following Angular CLI command to create a new component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-create.component.ts` file and add the following `import`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `constructor` and inject the `ProductsService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to the component class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We do not need to unsubscribe when interacting with the Angular HTTP client
    because the framework will do it automatically for us.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding method accepts the product details as parameters and calls the
    `addProduct` method of the `ProductsService` class. We use the native `Number`
    function to convert the price value to a number because it will be passed as a
    string from the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.html` file and replace its content with
    the following HTML template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding template, we bind the `createProduct` method to the `click`
    event of the `Create` button and pass the value of the `<input>` and `<select>`
    HTML elements using the respective template reference variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the global `styles.css` file and add the following CSS style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, move the button-related styles from the `product-detail.component.css`
    file in the global CSS styles file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.css` file and add the following CSS styles
    to give a nice look and feel to our new component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-list.component.ts` file and import the `ProductCreateComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, open the `product-list.component.html` file and add the following
    snippet at the end of the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we now run our Angular application using the `ng serve` command, we should
    see the component for adding new products at the end of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Create a product'
  prefs: []
  type: TYPE_NORMAL
- en: To experiment, try to add a new product by filling in its details, clicking
    on the **Create** button, and verifying that the new product has been added to
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: The next feature we will add to our application is to modify data by changing
    the price of an existing product.
  prefs: []
  type: TYPE_NORMAL
- en: Updating product price
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The price of a product in an e-commerce application may need to change at some
    point. We need to provide a way for our users to update that price through our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and add a new method for updating a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we use the `patch` method of the `HttpClient` class
    to send the details of the product that we want to modify to the API. We also
    update the price of the selected product in the local cache of products and return
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could have used the `put` method of the HTTP client. The `patch`
    method should be used when we want to update only a subset of an object, whereas
    the `put` method interacts with all object properties. In this case, we do not
    want to update the product title, so we use the `patch` method. Both methods accept
    the API endpoint and the object we want to update as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the `ProductDetailComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method accepts an existing `product` and its new `price` as parameters
    and calls the `updateProduct` method of the `ProductsService` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.html` file and add an `<input>` and a `<button>`
    element after the paragraph element of the price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `<input>` element is used to enter the new price of the product and defines
    the `price` template reference variable. The `click` event of the `<button>` element
    is bound to the `changePrice` method that passes the current `product` object
    and the value of the `price` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open the `product-detail.component.css` file and add the following
    CSS styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `ng serve` command to start the Angular application and select a product
    from the list. The product details should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Product details'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a price in the **New price** input box and click the **Change** button.
    The existing price should be updated to reflect the change, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Product details with changed price'
  prefs: []
  type: TYPE_NORMAL
- en: We can now modify a product by changing its price.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that changes in products that come from the Fake Store API are not
    physically persisted. If you change the price and refresh the browser, it will
    restore the initial price.
  prefs: []
  type: TYPE_NORMAL
- en: The next and final step of our CRUD application will be to delete an existing
    product.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deleting a product from an e-shop application is not very common. However,
    we need to provide functionality for it in case users enter incorrect or invalid
    data and want to delete it afterward. In our application, deleting an existing
    product will be done with the product details component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and import the `tap` operator from the
    `rxjs` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to the `ProductsService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we use the `delete` method of the `HttpClient` class,
    passing the products endpoint and the product `id` we want to delete in the API.
    We are also using the `splice` method of the `products` array to remove the product
    from the local cache.
  prefs: []
  type: TYPE_NORMAL
- en: The return type of the method is set to `Observable<void>` because we are not
    currently interested in the result of the HTTP request. We only need to know if
    it was successful or not. We also use the `tap` RxJS operator because we are not
    altering the returned value from the observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.ts` file and create a new output property
    in the `ProductDetailComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding property will notify the `ProductListComponent` that the selected
    product has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following method, which calls the `deleteProduct` method of the
    `ProductsService` class and triggers the `deleted` output event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-detail.component.html` file, create a `<button>` element,
    and bind its `click` event to the `emit` method of the `deleted` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we grouped the two buttons in a `<div>` HTML element
    so that they appear side by side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an appropriate style for the new button and the button group in the `product-detail.component.css`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-list.component.html` file and add a binding to the `deleted`
    event of the `<app-product-detail>` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the application using the `ng serve` command and select a product
    from the list, we should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Product details'
  prefs: []
  type: TYPE_NORMAL
- en: The product detail component now has a **Delete** button that deletes the product
    and removes it from the list when it is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that changes in products that come from the Fake Store API are not
    physically persisted. If you delete a product and refresh the browser, the product
    will appear again on the list.
  prefs: []
  type: TYPE_NORMAL
- en: The e-shop application we have built so far has an **Add to cart** button that
    we can use to add a product to a shopping cart. The button does not do much yet,
    but we will implement the full cart functionality in the following chapters. According
    to the documentation of the Fake Store API, shopping carts are only available
    to authenticated users, so we must ensure that the **Add to cart** button will
    only be available to them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: In an Angular enterprise application, the product management feature must also
    be protected from unauthorized users. In this case, we would implement a more
    granular authorization scheme with user roles, allowing only administrators to
    change and add products. We will not implement this feature, but we encourage
    you to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn about authentication and authorization
    in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization with HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fake Store API provides an endpoint for authenticating users. It contains
    a login method that accepts a username and a password as parameters and returns
    an authentication token. We will use the authentication token in our application
    to differentiate between a logged-in user and a guest.
  prefs: []
  type: TYPE_NORMAL
- en: A predefined pool from the users endpoint at [https://fakestoreapi.com/users](https://fakestoreapi.com/users)
    provides the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following authentication and authorization topics in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with a backend API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorizing users for certain features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorizing HTTP requests using interceptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with the topic of authenticating with the Fake Store API.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with a backend API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Angular real-world applications, we usually create an Angular component,
    allowing users to log in and out of the application. An Angular service will communicate
    with the API and handle all authentication tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started by creating the authentication service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new Angular service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `auth.service.ts` file and modify the `import` statements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following properties in the `AuthService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, the `accessToken` signal will store the authentication
    token from the API, and the `isLoggedIn` signal indicates whether the user is
    logged in. The logged-in status of the user depends on whether the `accessToken`
    property has a value.
  prefs: []
  type: TYPE_NORMAL
- en: Signals can be used not only in Angular components but also inside services.
  prefs: []
  type: TYPE_NORMAL
- en: The `authUrl` property points to the authentication endpoint URL of the Fake
    Store API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inject the `HttpClient` class in the `constructor` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `login` method to allow users to log in to the Fake Store API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method initiates a POST request to the API, using the login endpoint
    and passing `username` and `password` in the request body. The observable returned
    from the POST request is passed to the `tap` operator, which updates the `accessToken`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `logout` method that resets the `accessToken` signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have already set up the business logic for authenticating users in our Angular
    application. In the following section, we will learn how to use it to control
    authorization in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing user access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create an authentication component that will allow our users
    to log in and out of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new Angular component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `auth.component.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject `AuthService` in the component’s `constructor` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `public` access modifier to inject `AuthService`
    because we want it to be accessible from the component’s template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following methods in the `AuthComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, the `login` method uses predefined credentials from
    the users endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `auth.component.html` file and replace its content with the following
    HTML template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding template contains two `<button>` HTML elements for login/logout
    purposes. Each button is displayed conditionally according to the value of the
    `isLoggedIn` signal of the `AuthService` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now leverage the `isLoggedIn` signal in the product detail component
    and toggle the visibility of the **Add to cart** button:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.ts` file and add the following `import`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject `AuthService` in the `constructor` of the `ProductDetailComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-detail.component.html` file and use an `@if` block to display
    the **Add to cart** button conditionally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.ts` file and import the `AuthComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.html` file and add the `<app-auth>` tag inside the
    `<header>` HTML element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To try the authentication feature in the application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ng serve` command to start the application and navigate to `http://localhost:4200`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a product from the list and verify that the **Add to cart** button is
    not visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Login** button in the top-left corner of the page. The text should
    change to **Logout** after you have logged in successfully to the Fake Store API,
    and the **Add to cart** button should appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have added basic authentication and authorization patterns
    to your Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: It is common in enterprise applications to perform authorization in the business
    logic layer while communicating with the backend API. The backend API often requires
    certain method calls to pass the authentication token in each request through
    headers. We will learn how to work with **HTTP headers** in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fake Store API does not require authorization while communicating with
    its endpoints. However, suppose we are working with a backend API that expects
    all HTTP requests to contain an authentication token using HTTP headers. A common
    pattern in web applications is to include the token in an **Authorization** header.
    We can use HTTP headers in an Angular application by importing the `HttpHeaders`
    class from the `@angular/common/http` namespace and modifying our methods accordingly.
    Here is an example of how the `getProducts` method should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, we are using a hardcoded value for the authentication token.
    In a real-world scenario, we may get it from the local storage of the browser
    or some other means.
  prefs: []
  type: TYPE_NORMAL
- en: All `HttpClient` methods accept an optional object as a parameter for passing
    additional options to an HTTP request, including HTTP headers. To set headers,
    we use the `headers` property of the `options` object and create a new instance
    of the `HttpHeaders` class as a value. The `HttpHeaders` object is a key-value
    pair that defines custom HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine what will happen if we need to pass the authentication token in
    all methods of the `ProductsService` class. We should go to each of them and write
    the same code repeatedly. Our code could quickly become cluttered and difficult
    to test. Luckily, the Angular HTTP client has another feature we can use to help
    us in such a situation called **interceptors** .
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP interceptor is an Angular service that intercepts HTTP requests and
    responses that pass through the Angular HTTP client. It can be used in the following
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When we want to pass custom HTTP headers in every request, such as an authentication
    token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we want to display a loading indicator while we wait for a response from
    the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we want to provide a logging mechanism for every HTTP communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we can create an interceptor for passing the authentication token
    to each HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new interceptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.config.ts` file and import the `withInterceptors` function from
    the `@angular/common/http` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `withInterceptors` function is used to register an interceptor with the
    HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the interceptor we created in the previous step using the following
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `provideHttpClient` method to register the `authInterceptor` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `withInterceptors` function accepts a list of registered interceptors,
    and their order matters. In the following diagram, you can see how interceptors
    process HTTP requests and responses according to their order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, διάγραμμα, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Execution order of Angular interceptors'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the last interceptor before sending the request to the server is
    a built-in Angular service named **HttpBackend** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `auth.interceptor.ts` file and modify the arrow function of the `authInterceptor`
    function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The arrow function accepts the following parameters: `req` , which indicates
    the current request, and `next` , which is the next interceptor in the chain.
    In the preceding snippet, we use the `clone` method to modify the existing request
    because HTTP requests are immutable by default. Similarly, due to the immutable
    nature of HTTP headers, we use the `setHeaders` method to update them. Finally,
    we delegate the request to the next interceptor using the `handle` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interceptors can use the `inject` method to get dependencies that they may
    need from the Angular DI mechanism. For example, if we wanted to use the `AuthService`
    class inside the interceptor, we could modify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In applications built with older versions of the Angular framework, you may
    notice that interceptors are TypeScript classes instead of pure functions. To
    register an interceptor with the HTTP client, we need to add the following `provide`
    object literal in the `providers` array of the module, which also provides the
    `HttpClientModule` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, `HTTP_INTERCEPTORS` is an injection token that can
    be provided multiple times as indicated by the `multi` property.
  prefs: []
  type: TYPE_NORMAL
- en: Angular interceptors have many uses, and authorization is one of the most basic.
    Passing authentication tokens during HTTP requests is a common scenario in enterprise
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise web applications must exchange information with a backend API almost
    daily. The Angular framework enables applications to communicate with an API over
    HTTP using the Angular HTTP client. In this chapter, we explored the essential
    parts of the Angular HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to move away from the traditional `fetch` API and use observables
    to communicate over HTTP. We explored the basic parts of a CRUD application using
    the Fake Store API as our backend. We investigated how to implement authentication
    and authorization in Angular applications. Finally, we learned what Angular interceptors
    are and how to use them to authorize HTTP calls.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to consume data from a backend API in our components, we
    can further improve the user experience of our application. In the next chapter,
    we will learn how to load our components through navigation using the Angular
    router.
  prefs: []
  type: TYPE_NORMAL
