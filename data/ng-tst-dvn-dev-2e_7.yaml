- en: Chapter 7. Flip Flop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。翻转
- en: At this point, we should be confident about performing the initial implementation
    of an Angular application using TDD. Also, we should be familiar with using the test-first
    approach. The test-first approach is very good for the learning stage, but sometimes
    it's a time suck when we get a lot of errors. For simple and known behavior, it
    may not be good to go for the test-first approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该对使用 TDD 进行 Angular 应用程序的初始实现有信心。我们还应该熟悉使用测试优先方法。测试优先方法在学习阶段非常好，但有时当我们遇到很多错误时，它可能会浪费时间。对于简单和已知的行为，可能不是采用测试优先方法的最佳选择。
- en: We have already seen how the test-first approach works, so we can skip those
    steps by checking any feature without creating those components. Besides that,
    we can go one step further to make us more confident in writing our components
    faster. We can have our components ready and then write end-to-end test specs
    to test the expected behavior. If the e2e test fails, we can trigger an error
    in the Protractor debugger.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了测试优先方法是如何工作的，因此我们可以通过检查任何功能而不创建这些组件来跳过这些步骤。除此之外，我们可以更进一步，使我们更有信心更快地编写组件。我们可以让组件准备好，然后编写端到端测试规范来测试预期的行为。如果
    e2e 测试失败，我们可以在 Protractor 调试器中触发错误。
- en: 'In this chapter, we will continue to expand our knowledge of applying TDD (but
    not the test-first approach) with Angular. We will not discuss the details of
    the basic Angular component ecosystem here; rather, we will go a step ahead and include more
    Angular features. We will take our knowledge further by looking at the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续扩展我们应用 TDD（但不是测试优先方法）与 Angular 的知识。在这里，我们不会讨论基本 Angular 组件生态系统的细节；相反，我们将更进一步，包括更多
    Angular 功能。我们将通过以下主题进一步扩展我们的知识：
- en: Angular routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 路由
- en: Navigating to routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到路由
- en: Communicating with route parameter data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与路由参数数据通信
- en: "Protractor location references with CSS and \LHTML elements"
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CSS 和 HTML 元素进行 Protractor 位置引用
- en: Fundamentals of TDD
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD 的基础
- en: 'In this chapter, we will walk-through applying TDD to routes and navigation
    for a search application. Before getting into the walk-through, we need to be
    aware of some of the techniques, configurations, and functions that will be used
    throughout this chapter, which include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步介绍将 TDD 应用于搜索应用的路线和导航。在开始逐步介绍之前，我们需要了解本章中将使用的一些技术、配置和函数，包括以下内容：
- en: Protractor locators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protractor 定位器
- en: Headless browser testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头浏览器测试
- en: After reviewing these concepts, we can move on to the walk-through.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了这些概念之后，我们可以继续进行逐步介绍。
- en: Protractor locators
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Protractor 定位器
- en: Protractor locators are key components where everybody should spend some time
    to learn. In the previous Protractor chapters, we understood some commonly used
    locators with working examples. We will provide some examples of the Protractor
    `Locator` here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 定位器是每个人都应该花时间学习的关键组件。在之前的 Protractor 章节中，我们通过一些工作示例了解了一些常用定位器。在这里，我们将提供一些
    Protractor `Locator` 的示例。
- en: 'Protractor locators allow us to find elements within an HTML page. In this
    chapter, we will see the CSS, HTML, and Angular-specific locators in action. Locators
    are passed to the `element` function. The `element` function will find and return
    the elements on a page. The generic locator syntax is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 定位器允许我们在 HTML 页面中查找元素。在本章中，我们将看到 CSS、HTML 和 Angular 特定定位器的实际应用。定位器被传递给
    `element` 函数。`element` 函数将找到并返回页面上的元素。通用的定位器语法如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `<LOCATOR>` is a placeholder. The following sections
    describe a couple of these locators.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`<LOCATOR>` 是一个占位符。以下几节将描述这些定位器中的几个。
- en: CSS locators
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS 定位器
- en: 'CSS is used to add layout, color, formatting, and style to an HTML page. From
    an end-to-end testing perspective, the look and style of an element may be part
    of a specification. As an example, consider the following HTML snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 用于向 HTML 页面添加布局、颜色、格式化和样式。从端到端测试的角度来看，一个元素的看起来和样式可能是一个规范的一部分。例如，考虑以下 HTML
    片段：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All these four selections will select the `div` element.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这四个选择都将选择 `div` 元素。
- en: Button and link locators
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮和链接定位器
- en: 'Besides being able to select and interpret the way something looks, it is also
    important to be able to find buttons and links within a page. This will allow
    a test to interact with the site easily. Here are a couple of examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够选择和解释某物的外观方式外，也很重要能够找到页面中的按钮和链接。这将允许测试轻松地与网站交互。以下是一些示例：
- en: '`buttonText` locator:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buttonText` 定位器：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`linkText` locator:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linkText` 定位器：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: URL location references
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL 位置引用
- en: 'When testing Angular routes, we need to be able to test the URL of our test.
    By adding tests around the URL and location, we have to ensure that the application
    works with specific routes. This is important because routes provide an interface
    to our application. Here is how to get the URL reference in a Protractor test:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试 Angular 路由时，我们需要能够测试我们测试的 URL。通过在 URL 和位置周围添加测试，我们必须确保应用程序与特定的路由一起工作。这很重要，因为路由为我们提供了应用程序的接口。以下是如何在
    Protractor 测试中获得 URL 引用的方法：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have seen how to use the different locators, it is time to put the
    knowledge to use.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用不同的定位器，是时候将知识付诸实践了。
- en: Preparing an Angular project
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 Angular 项目
- en: It is important to get a process and method to set up your projects quickly.
    The less time you spend on thinking about the structure of the directory and the
    required tools, the more time you can spend developing!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 获得快速设置项目的过程和方法很重要。你花在思考目录结构和所需工具上的时间越少，你可以在开发上花的时间就越多！
- en: For this reason, in the previous chapters, we looked at how to get simple existing
    projects for Angular developed as `quickstart` projects ([https://github.com/angular/quickstart](https://github.com/angular/quickstart)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的章节中，我们探讨了如何获取作为 `quickstart` 项目开发的简单现有 Angular 项目 [https://github.com/angular/quickstart](https://github.com/angular/quickstart)。
- en: However, some people use the `angular2-seed` ([https://github.com/mgechev/angular2-seed](https://github.com/angular/angular-seed))
    project, Yeoman, or create a custom template. Although these techniques are useful
    and have their merits, when starting out in Angular, it is essential to understand
    what it takes to build an application from the ground up. By building the directory
    structure and installing tools by ourselves, we will understand Angular better.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些人使用 `angular2-seed` [https://github.com/mgechev/angular2-seed](https://github.com/angular/angular-seed)
    项目、Yeoman 或创建自定义模板。尽管这些技术很有用，并且有其优点，但在 Angular 的入门阶段，理解从头开始构建应用程序所需的东西是至关重要的。通过自己构建目录结构和安装工具，我们将更好地理解
    Angular。
- en: You will be able to make layout decisions based on your specific application
    and needs, as opposed to fitting them into some other module. As you grow and
    become a better Angular developer, this step may not be needed and will become
    second nature to you.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够根据你特定的应用和需求做出布局决策，而不是将它们适应到某个其他模块中。随着你的成长和成为更好的 Angular 开发者，这一步可能不再需要，并且会变得自然而然。
- en: Loading the existing project
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载现有项目
- en: 'To start off, we will clone the project from the Angular `quickstart` project
    at [https://github.com/angular/quickstart](https://github.com/angular/quickstart),
    rename it as `angular-flip-flop`, and our project folder structure will look as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从 Angular 的 `quickstart` 项目 [https://github.com/angular/quickstart](https://github.com/angular/quickstart)
    克隆项目，将其重命名为 `angular-flip-flop`，我们的项目文件夹结构将如下所示：
- en: '![Loading the existing project](img/image_07_001.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](img/image_07_001.jpg)'
- en: In the previous chapters, we discussed how to set up the project, understood the
    different components involved, and walked through the entire process. We will
    skip these details and assume that you can recall how to perform the necessary
    installation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了如何设置项目，理解了涉及的不同组件，并走过了整个过程。我们将跳过这些细节，并假设你可以回忆起如何执行必要的安装。
- en: Preparing the project
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备项目
- en: 'This `quickstart` project doesn''t included the base `href` in the project''s
    landing page (`index.html`). We will need that to proceed perfectly with routing,
    so let''s add a single line (`base href`) to the `<head>` section of `index.html`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `quickstart` 项目没有在项目的着陆页（`index.html`）中包含基本 `href`。为了完美地进行路由，我们需要这个 `href`，所以让我们在
    `index.html` 的 `<head>` 部分添加一行（`base href`）：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, our bootstrapping component is in the application component and the HTML
    template is in the component itself. We should separate the template to a new
    file before proceeding.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的引导组件位于应用程序组件中，HTML 模板位于组件本身中。在继续之前，我们应该将模板分离到一个新文件中。
- en: 'For that, we will update our application component (`app/app.component.ts`),
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们将更新我们的应用程序组件（`app/app.component.ts`），如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s create our separate template file at `app/app.component.html`. And the
    code will look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `app/app.component.html` 创建我们的单独模板文件。代码将如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the project
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行项目
- en: 'Let''s proceed with it and get ready to run using the following commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行，并准备好使用以下命令运行：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To confirm the installation and run the project, the application will automatically
    run in the web browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认安装并运行项目，应用程序将自动在网页浏览器中运行。
- en: 'Here is the expected output after running the project:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目后的预期输出如下：
- en: '![Running the project](img/image_07_002.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![运行项目](img/image_07_002.jpg)'
- en: Restructuring the project
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构项目
- en: Let's change the project structure a bit, not much though. By default, it has
    included unit testing in the same location as the components file and separated
    the e2e testing file outside the `app/` folder in the `e2e/` folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下项目结构，但不是很多。默认情况下，它已经将单元测试包含在组件文件相同的目录中，并将端到端测试文件分离到`app/`文件夹外的`e2e/`文件夹中。
- en: However, we will keep all the tests in the same location, that is, outside of
    `app`; we will keep all the tests as `spec/e2e` and `spec/unit`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将保持所有测试在同一位置，即`app`之外；我们将保持所有测试在`spec/e2e`和`spec/unit`。
- en: The goal is to separate the test specs from the component. This way, we can
    keep our unit tests file outside in the `spec/unit` folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将测试规范与组件分离。这样，我们可以将单元测试文件放在`spec/unit`文件夹的外部。
- en: 'So, our current folder structure will look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们当前的项目结构将看起来像这样：
- en: '![Restructuring the project](img/image_07_003.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![重构项目](img/image_07_003.jpg)'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As long as we have changed the path for both unit and e2e tests, we should have
    to change the path in the Karma configuration and Protractor configuration files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们更改了单元和端到端测试的路径，我们就需要在Karma配置文件和Protractor配置文件中更改路径。
- en: Setting up headless browser testing for Karma
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Karma设置无头浏览器测试
- en: In the previous chapters, we were running Karma using the default configuration.
    The default Chrome configuration launches Chrome on every test. Testing against
    the actual code and browser that the application will run in is a powerful tool.
    However, when launching, a browser may not always know how you want it to behave.
    From a unit test perspective, you may not want the browser to be launched in a
    window. The reason could be that tests may take a long time to run or you may
    not always have a browser installed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用默认配置运行Karma。默认的Chrome配置会在每次测试时启动Chrome。针对应用程序将运行的实际代码和浏览器进行测试是一个强大的工具。然而，在启动时，浏览器可能并不总是知道你希望它如何表现。从单元测试的角度来看，你可能不希望浏览器在窗口中启动。原因可能是测试可能需要很长时间才能运行，或者你可能并不总是安装了浏览器。
- en: Luckily, Karma comes equipped with the ability to easily configure PhantomJS,
    a headless browser. A headless browser runs in the background and will not display
    web pages in a UI. The PhantomJS headless browser is a really great tool to use
    for testing. It can even be set up to take screenshots of your tests! Read more
    about how this is done and about the WebKit used on the PhantomJS site at [http://phantomjs.org/](http://phantomjs.org/).
    The following setup configuration will show us how to set up PhantomJS with Karma
    for headless browser testing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Karma配备了轻松配置PhantomJS（一个无头浏览器）的能力。无头浏览器在后台运行，不会在UI中显示网页。PhantomJS无头浏览器是用于测试的真正出色的工具。它甚至可以设置来对测试进行截图！有关如何进行此操作以及PhantomJS网站上使用的WebKit的更多信息，请参阅[http://phantomjs.org/](http://phantomjs.org/)。以下设置配置将展示如何使用Karma设置PhantomJS进行无头浏览器测试。
- en: Preconfiguration
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预配置
- en: When Karma is installed, it automatically includes the PhantomJS browser plugin.
    For further reference, the plugin is located at [https://github.com/karma-runner/karma-phantomjs-launcher](https://github.com/karma-runner/karma-phantomjs-launcher).
    There shouldn't be any more installation or configuration required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当Karma安装时，它将自动包含PhantomJS浏览器插件。有关进一步参考，插件位于[https://github.com/karma-runner/karma-phantomjs-launcher](https://github.com/karma-runner/karma-phantomjs-launcher)。不应需要更多的安装或配置。
- en: 'However, if your setup states that it is missing `karma-phantomjs-launcher`,
    you can easily install it using `npm`, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的设置表明它缺少`karma-phantomjs-launcher`，你可以很容易地使用`npm`安装它，如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Configuration
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'PhantomJS is configured in the `browsers` section of the Karma configuration.
    Open the `karma.conf.js` file and update it with the following details:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS已在Karma配置的`browsers`部分进行配置。打开`karma.conf.js`文件，并使用以下详细信息更新它：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Do that in the `plugins` option as well:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在`plugins`选项中进行设置：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that the project has been initialized and configured with headless browser
    testing, you can see it in action through the following walk-throughs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经初始化并配置了无头浏览器测试，你可以通过以下步骤查看其运行情况。
- en: Walk-through of Angular routes and navigation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular路由和导航的概述
- en: This walk-through will leverage Angular routes. Routes are an extremely useful
    feature of Angular, as they were in Angular 1.x before it, but more powerful.
    They allow us to control certain aspects of the application using different components.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将利用Angular路由。路由是Angular的一个极其有用的功能，就像在Angular 1.x中一样，但更强大。它们允许我们使用不同的组件来控制应用程序的某些方面。
- en: 'This walk-through will flip between components to show us how to use TDD to
    build routes. The following are the specifications. There will be a navigation
    menu, which has two menu items, **View1** and **View2**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将切换组件以展示如何使用TDD（测试驱动开发）来构建路由。以下是一些规范。将有一个导航菜单，其中包含两个菜单项，**View1**和**View2**：
- en: In the navigation menu, click on label **View1**
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航菜单中，点击标签**View1**
- en: The content area (router outlet) will load/flip **View1** content
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容区域（路由出口）将加载/切换**View1**内容
- en: 'And here''s the second part:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是第二部分：
- en: In the navigation menu, click on label **View2**
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航菜单中，点击标签**View2**
- en: The content area (router outlet) will load/flip **View2** content
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容区域（路由出口）将加载/切换**View2**内容
- en: Essentially, this will be an application that does a flip/flop between two views.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这将是一个在两个视图之间切换的应用程序。
- en: Setting up Angular routes
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Angular路由
- en: The router is an optional service in Angular, so it's not included in the Angular
    core. If we need to use the router, we will have to install the Angular `router`
    service in our application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是Angular中的一个可选服务，因此它不包括在Angular核心中。如果我们需要使用路由，我们必须在我们的应用程序中安装Angular的`router`服务。
- en: 'As long as we have cloned our project from `quickstart`, we should be okay
    because it has recently added the Angular router to its dependencies, but we should check
    and confirm. If it doesn''t have `@angular/router` in its dependencies in `package.json`,
    we can install the Angular router using `npm`, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们从`quickstart`克隆了我们的项目，我们就应该没问题，因为它最近已经将其依赖项中的Angular路由添加了进来，但我们应该检查并确认。如果`package.json`中的依赖项中没有`@angular/router`，我们可以使用`npm`安装Angular路由，如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Defining directions
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义方向
- en: A route specifies a location and expects a result. From an Angular perspective,
    the routes must first be specified and then associated with certain components.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个路由指定了一个位置并期望一个结果。从Angular的角度来看，路由必须首先指定，然后与某些组件相关联。
- en: To implement a router in our application, we will need to import the router
    module in the application module, where it will register the router in the application.
    After that, we will need to configure all the routes and pass that configuration
    to the application module.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中实现路由，我们需要在应用程序模块中导入路由模块，在那里它将在应用程序中注册路由。之后，我们需要配置所有路由并将该配置传递给应用程序模块。
- en: The router module
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由模块
- en: 'To implement a router in the application, we will need to import the `RouterModule`
    in our application module, located at `app/app.module.ts`, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中实现路由，我们需要在我们的应用程序模块`app/app.module.ts`中导入`RouterModule`，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will just make the `router` module available in the application system,
    but we will have to have a router configuration to define all the possible routers
    in the entire application and then import that configuration to the application
    ecosystem via the application module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使`router`模块在应用程序系统中可用，但我们将必须有一个路由配置来定义整个应用程序中所有可能的路由，然后通过应用程序模块将此配置导入到应用程序生态系统中。
- en: Configuring routes
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置路由
- en: A router is useless until we configure it, and to do so, we first need to import
    the `router` component. Configuration will mainly contain a list of arrays, where
    route paths and related components live as key-value pairs. We can add the configuration
    array to the application module, or we can create a separate configuration file
    and include the app module in it. We will go for the second option so that route
    configuration will be separated from the app module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 路由在没有配置之前是无用的，为此，我们首先需要导入`router`组件。配置将主要包含一个数组列表，其中路由路径和相关组件作为键值对存在。我们可以将配置数组添加到应用程序模块中，或者我们可以创建一个单独的配置文件并将应用程序模块包含在内。我们将选择第二种方法，以便将路由配置与应用程序模块分离。
- en: 'Let''s create the router configuration file in the application root as `app/app.routes.ts`.
    There, at first, we will need to import the Angular `Routes` from the Angular
    service, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序根目录中创建一个名为`app/app.routes.ts`的路由配置文件。在那里，首先，我们需要从Angular服务中导入Angular的`Routes`，如下所示：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'From the router config file, we will need to export the configuration array,
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从路由配置文件中，我们需要导出配置数组，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Routers in the application
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序中的路由器
- en: We've already imported the `router` module to our application module, located
    at `app/app.module.ts`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `router` 模块导入到位于 `app/app.module.ts` 的应用程序模块中。
- en: 'Then, we will need to import the router configuration file (`rootRouterConfig`)
    to this application module file, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将路由配置文件 (`rootRouterConfig`) 导入到这个应用程序模块文件中，如下所示：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the application module, we know `NgModule` imports the optional modules to
    the application ecosystem, and similarly, to include the router in the application,
    `RouterModule` has a function known as `RouterModule.forRoot(RouterConfig)`, which
    accepts the `routerConfiguration` to implement a router in the entire application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序模块中，我们知道 `NgModule` 将可选模块导入到应用程序生态系统中，同样地，为了将路由包含在应用程序中，`RouterModule`
    有一个名为 `RouterModule.forRoot(RouterConfig)` 的函数，它接受 `routerConfiguration` 以在整个应用程序中实现路由。
- en: 'The application module (`app/app.module.ts`) will import that `RouterModule`
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序模块 (`app/app.module.ts`) 将如下导入 `RouterModule`：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Routes in the config
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置中的路由
- en: Now, let's add some routes to our `Routes` configuration array, which is located
    at `app/app.routes.ts`. The route configuration array contains some objects as
    key-value pairs, with mostly two to three elements in every object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向我们的 `Routes` 配置数组添加一些路由，该数组位于 `app/app.routes.ts`。路由配置数组包含一些作为键值对的对象，每个对象中通常有两个到三个元素。
- en: The first element in the array object contains the `path`, and the second one
    contains the relevant `component` to load for that `path`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象中的第一个元素包含 `path`，第二个元素包含为该 `path` 加载的相关 `component`。
- en: 'Let''s add two routes to our configuration array, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在配置数组中添加两条路由，如下所示：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, two routes, `view1` and `view2`, are defined, and two components have
    been assigned to load for that route.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义了两个路由 `view1` 和 `view2`，并为该路由分配了两个组件。
- en: In some cases, we may need to redirect from one route to another. For example,
    for the root path of the application (`''`), we may plan to redirect to the `view1`
    route. For that, we have to set the `redirectTo` element in the object and assign
    some route name as its value. We will also need to add one extra element as `pathMatch`
    and set its value to `full` so it will match the full path before redirecting
    to some other route.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要从一个路由重定向到另一个路由。例如，对于应用程序的根路径 (`''`)，我们可能计划重定向到 `view1` 路由。为此，我们必须在对象中设置
    `redirectTo` 元素，并将其值指定为某个路由名称。我们还需要添加一个额外的元素作为 `pathMatch` 并将其值设置为 `full`，这样它将在重定向到其他路由之前匹配完整路径。
- en: 'The code will look as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, yes, our initial route configuration is ready to go. Now, the full configuration
    will look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是的，我们的初始路由配置已经准备就绪。现在，完整的配置将如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I should mention here that we have to import the `view1` and `view2` components
    as we have used them in the router config.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该在这里提到，我们必须导入 `view1` 和 `view2` 组件，因为我们已经在路由配置中使用了它们。
- en: To learn more in detail about Angular routes, refer to [https://angular.io/docs/ts/latest/guide/router.html](https://angular.io/docs/ts/latest/guide/router.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解 Angular 路由，请参阅 [https://angular.io/docs/ts/latest/guide/router.html](https://angular.io/docs/ts/latest/guide/router.html)。
- en: Hands-on routes
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践路由
- en: So far, we have installed and imported a router module, configured routes, and
    included things in the application ecosystem. We still need to do some related
    tasks, such as creating a router outlet, creating navigation, and creating the
    component defined in the route, to have hands-on experience with routes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经安装并导入了一个路由模块，配置了路由，并将一些内容包含在应用程序生态系统中。我们还需要做一些相关任务，例如创建路由出口、创建导航以及创建在路由中定义的组件，以便获得对路由的实践经验。
- en: Defining the router outlet
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义路由出口
- en: As long as the route is configured in `appComponent`, we need a placeholder
    to load the route's navigated components, which Angular defines as the route outlet.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 只要路由在 `appComponent` 中配置，我们就需要一个占位符来加载路由的导航组件，Angular 将其定义为路由出口。
- en: A `RouterOutlet` is a placeholder that Angular dynamically fills based on the
    application's route.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterOutlet` 是一个占位符，Angular 根据应用程序的路由动态填充。'
- en: 'For our application, we will place the `router-outlet` in the `appComponent`
    template, located at (`/app/app.component.html`), like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将在 `appComponent` 模板中放置 `router-outlet`，该模板位于 (`/app/app.component.html`)，如下所示：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Preparing the navigation
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备导航
- en: In the route configuration, we have set two paths, `/view1` and `/view2`, for
    our application. Now, let's create the navigation menu with two route paths to
    make navigation easy. For that, we can create a separate simple component so that
    navigation can be isolated for the entire application component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由配置中，我们为我们的应用程序设置了两个路径，`/view1`和`/view2`。现在，让我们创建一个带有两个路由路径的导航菜单，以便于导航。为此，我们可以创建一个单独的简单组件，以便在整个应用程序组件中隔离导航。
- en: 'Create a new component file for the `NavbarComponent` at `/app/nav/navbar.component.ts`,
    as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/app/nav/navbar.component.ts`中创建一个新的`NavbarComponent`组件文件，如下所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, create a template for the navigation component at (`/app/nav/navbar.component.html`),
    as shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建导航组件的模板（`/app/nav/navbar.component.html`），如下所示：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't bother about the `members` link in in the navigation for now; I'll tell
    you what it is in a later section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心导航中的`members`链接；我将在稍后的部分告诉你它是什么。
- en: 'Let''s create the basic CSS style for the navigation component for a better
    look at `/app/nav/navbar.component.css`, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`/app/nav/navbar.component.css`中创建导航组件的基本CSS样式，以便更好地查看，如下所示：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have a navigation component. Now we will have to bind that to our app component,
    which is our application landing page.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个导航组件。现在我们将需要将其绑定到我们的应用程序组件，即我们的应用程序着陆页。
- en: 'To do so, we have to append the following to the `appComponent` template, located
    at `/app/app.component.html`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须将以下内容添加到位于`/app/app.component.html`的`appComponent`模板中：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Preparing the components
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备组件
- en: For each defined route, we will need to create an individual component as every
    route will be associated with a component.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个定义的路由，我们需要创建一个单独的组件，因为每个路由都将与一个组件相关联。
- en: Here, we have two defined routes, and we will need to create two individual
    components to work on the routes' navigation. We will create `View1Component`
    and `View2Component` as per our requirement.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个定义的路由，我们需要为每个路由创建两个单独的组件来处理导航。我们将根据我们的要求创建`View1Component`和`View2Component`。
- en: 'Create a new component file for the `View 1` component at `/app/view/view1.component.ts`,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/app/view/view1.component.ts`中创建一个新的`View 1`组件文件，如下所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create another component file for the `View 2` component (`/app/view/view2.component.ts`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/app/view/view2.component.ts`中创建另一个`View 2`组件文件：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are ready with our routes and related components (`Navigation`, `View1`,
    and `View2`). Hopefully, everything's working as expected and we can see the application
    output in the browser.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了我们的路由和相关组件（`Navigation`、`View1`和`View2`）。希望一切都能按预期工作，我们可以在浏览器中看到应用程序的输出。
- en: Wait, before looking at the expected output in the browser, let's test the expected
    result with end-to-end testing. Now we know the expected behavior, and we will
    write out the e2e test specs based on our expectation. Once we're ready with the
    e2e test specs, we will see how it fulfills our expectation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，在查看浏览器中的预期输出之前，让我们使用端到端测试来测试预期结果。现在我们知道了预期的行为，我们将根据我们的期望编写e2e测试规范。一旦我们准备好了e2e测试规范，我们将看到它是如何满足我们的期望的。
- en: Assembling the flip/flop test
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组装翻转/切换测试
- en: 'Following the first of the 3 As, *assemble*, these steps will show us how to
    assemble the test:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 按照三个A中的第一个A，*组装*，这些步骤将向我们展示如何组装测试：
- en: 'Start with the Protractor base template, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Protractor基础模板开始，如下所示：
- en: '[PRE28]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Navigate to the root of the application using the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导航到应用程序的根目录：
- en: '[PRE29]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `beforeEach` method needs to confirm that the correct component''s view
    is being displayed. This can be done using a CSS locator to look for the `div`
    tag of `view1`. The expectation will look as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeEach`方法需要确认显示的是正确的组件视图。这可以通过使用CSS定位器查找`view1`的`div`标签来实现。期望结果如下所示：'
- en: '[PRE30]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, add an expectation that `view2` is not visible:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个期望，即`view2`不可见：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then add further confirmation by getting the entire text of the `view1` component:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过获取`view1`组件的整个文本来进一步确认：
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Flipping to the next view
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换到下一个视图
- en: 'The preceding test needs to confirm that when the `view2` link will be clicked
    in the navigation, the `view2` component''s content will load. In order to test
    this, we can use the `by.linkText` locator. Here is what it will look like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试需要确认当在导航中点击`view2`链接时，`view2`组件的内容将加载。为了进行测试，我们可以使用`by.linkText`定位器。它将看起来像这样：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `beforeEach` function is now complete and looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`函数现在已完成，如下所示：'
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, we will add the assertion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加断言。
- en: Asserting a flip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言翻转
- en: 'The assertion will again use Protractor''s CSS locator, as shown here, to find
    whether `view2` is available:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 断言将再次使用Protractor的CSS定位器，如下所示，以查找`view2`是否可用：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to confirm that `view1` is no longer available. Add the expectation
    that `view1` should not exist, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确认`view1`不再可用。添加期望，`view1`不应存在，如下所示：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Also, to make sure, we can check whether the `view2` contents have been loaded,
    as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保无误，我们还可以检查`view2`的内容是否已加载，如下所示：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we have the test about to switch from the `view1` to `view2` component by
    clicking on the `view2` link in the navigation, let''s go back to the `view1`
    component by clicking on the `view1` link in the navigation, hoping things work
    as expected:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们即将通过点击导航中的`view2`链接来切换测试从`view1`组件到`view2`组件，让我们通过点击导航中的`view1`链接回到`view1`组件，希望一切按预期工作：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The test has now been assembled.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在已经组装完成。
- en: Running the flip/flop test
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行翻转/翻转测试
- en: Our test spec is ready, and it's time to run it and see the result.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试规范已经准备好，现在是时候运行它并查看结果了。
- en: 'First, we will have to keep our project running via the HTTP server, with the
    following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须通过HTTP服务器保持我们的项目运行，使用以下命令：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we have to run Protractor. Be sure about the port number of the running
    application and Protractor configuration file; just to be sure, update the running
    server port in the configuration. To run Protractor, use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须运行Protractor。确保运行中的应用程序的端口号和Protractor配置文件正确；为了确保无误，更新配置中的运行服务器端口号。要运行Protractor，请使用以下命令：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The results should be as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该如下所示：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Protractor tests have passed as per our expectations. Now we can have a
    look at the browser to check whether things are working the same way as the e2e
    test results.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的预期，Protractor测试已经通过。现在我们可以查看浏览器，检查事情是否与e2e测试结果一样工作。
- en: Opening the app in a browser
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在浏览器中打开应用
- en: As long as we've run the `npm start` command for e2e testing, our application
    could run on a specific port, `3000`,  on the localhost. By default, it will open
    in the browser.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们为e2e测试运行了`npm start`命令，我们的应用程序就可以在本地主机的特定端口`3000`上运行。默认情况下，它将在浏览器中打开。
- en: 'The expected output is shown in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出显示在以下屏幕截图：
- en: '![Opening the app in a browser](img/B05405_07_04-1.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![在浏览器中打开应用](img/B05405_07_04-1.jpg)'
- en: Searching the TDD way
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以TDD方式搜索
- en: 'This walk-through will show us how to build a simple search application. It has
    two components: the first discusses a search query component, and the second uses
    routes to display search result details.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程将展示我们如何构建一个简单的搜索应用程序。它有两个组件：第一个讨论搜索查询组件，第二个使用路由来显示搜索结果详情。
- en: Walk-through of the search query
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索查询的流程
- en: 'The application being built is a search application. The first step is to set
    up the search area with search results. Imagine that I am performing a search.
    In this case, the following actions will occur:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正在构建的应用程序是一个搜索应用程序。第一步是设置搜索区域和搜索结果。想象一下我正在进行搜索。在这种情况下，以下操作将会发生：
- en: A search query is typed in
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入搜索查询
- en: The results are displayed at the bottom of the search box
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果显示在搜索框的底部
- en: This piece of the application is very similar to the test, layout, and approach
    we have seen in [Chapter 6](ch06.html "Chapter 6. The First Step"), *The* *First
    Step*. The application will need to use an input, respond to a click, and confirm
    the resulting data. Since the tests and code use the same functionality as the
    previous example, it is not worth providing a complete walk-through of the search
    functionality. Instead, the following subsections will show the required code
    with a few explanations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分应用与我们在[第6章](ch06.html "第6章。第一步")中看到的测试、布局和方法的相似性非常高，*第一步*。应用需要使用输入，响应用户点击，并确认结果数据。由于测试和代码使用与上一个示例相同的函数，因此没有必要提供完整的搜索功能流程。相反，以下小节将展示所需的代码和一些解释。
- en: The search query test
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索查询测试
- en: 'The following code represents the test for the search query functionality:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示搜索查询功能的测试：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We should notice a parallel to the previous tests. The functionality is written
    to mirror the behavior of a user typing in the search box. The test finds the
    input field, types a value, and then selects the button that says **Search**.
    The assertion confirms that the result contains a single value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意到与之前的测试有相似之处。功能被编写来模拟用户在搜索框中输入的行为。测试找到输入字段，输入一个值，然后选择显示**搜索**的按钮。断言确认结果包含单个值。
- en: The search application
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索应用程序
- en: To perform a search operation, we will need to create a search component that
    will contain an input field to accept the user input (search query) and a button
    to perform user action with a click event. Besides that, it may have a placeholder
    to contain the search result.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行搜索操作，我们需要创建一个包含用于接受用户输入（搜索查询）的输入字段和用于执行用户动作的点击事件的按钮的搜索组件。除此之外，它可能还有一个占位符来包含搜索结果。
- en: As long as our application already has the router included, we can place the
    search component for a specific route.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的应用程序已经包含了路由器，我们就可以为特定的路由放置搜索组件。
- en: Note that we have called our search component as `MembersComponent`, since we
    worked with some member data in the search component. And routes will be configured
    based on that as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已将我们的搜索组件命名为`MembersComponent`，因为我们已经在搜索组件中处理了一些成员数据。并且路由也将根据这一点进行配置。
- en: 'So, in our existing `app.routes.ts` file, we will add the following search
    routes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的现有`app.routes.ts`文件中，我们将添加以下搜索路由：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The search component
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索组件
- en: The search component (`MembersComponent`) will be the main class for the search
    functionality here. It will perform a search and return the search result.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件（`MembersComponent`）将是此处搜索功能的主要类。它将执行搜索并返回搜索结果。
- en: During the initial loading of the search component, it will not have any search
    query, so we have set the behavior to return all the data. Then, after the search
    trigger, it will return data based on a search query.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索组件的初始加载过程中，它将没有任何搜索查询，因此我们已将行为设置为返回所有数据。然后，在搜索触发后，它将根据搜索查询返回数据。
- en: 'The search component will be placed in `app/members/members.compoennt.ts`.
    In the code, at first, we will have to import the required Angular services, as
    shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件将被放置在`app/members/members.compoennt.ts`。在代码中，一开始，我们不得不导入所需的Angular服务，如下所示：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will use the `Http` service for the AJAX call, and by default, in Angular,
    the `Http` service returns an observable object. However, it''s easier to handle
    a promise than an observable object. So, we will convert this observable object
    to a promise. Angular suggests using the `rxjs` module, which has the `toPromise`
    method, used to convert an observable object to a promise. So, we will import
    the `rxjs` module, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Http`服务进行AJAX调用，默认情况下，在Angular中，`Http`服务返回一个可观察对象。然而，处理一个承诺比处理一个可观察对象更容易。因此，我们将这个可观察对象转换为承诺。Angular建议使用`rxjs`模块，它包含用于将可观察对象转换为承诺的`toPromise`方法。因此，我们将导入`rxjs`模块，如下所示：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Angular introduced the `ngOnInit()` method to be executed while initializing
    the component, similar to the contractor method in any class, but it's helpful
    to run the test spec. For that, we have imported the `OnInit` interface from the
    Angular core, and the `Component` class will implement the `OnInit` interface
    to get the `ngOnInit` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了`ngOnInit()`方法，在初始化组件时执行，类似于任何类中的构造函数方法，但它有助于运行测试规范。为此，我们已从Angular核心导入`OnInit`接口，`Component`类将实现`OnInit`接口以获取`ngOnInit`方法。
- en: 'Besides that, the `Component` class should inject the required module, such
    as `Http` and `Router`, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Component`类应该注入所需的模块，例如`Http`和`Router`，如下所示：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As discussed, we will use the `ngOnInit()` method, and from that, we will initialize
    the searching mechanism, like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用`ngOnInit()`方法，并从那里初始化搜索机制，如下所示：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we will apply the `search` feature on a member list, and for that, we
    have some dummy data at `app/data/people.json`. We will retrieve the data from
    here and perform a search operation on the data. Let''s see how:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将对成员列表应用`search`功能，为此，我们在`app/data/people.json`中有些示例数据。我们将从这里检索数据并在数据上执行搜索操作。让我们看看如何：
- en: The `getData()` method will retrieve the data from the API and will return a
    promise.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getData()`方法将从API检索数据，并将返回一个承诺。'
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `searchQuery()` method will resolve the returned promise and will make
    a data array based on the search query. If no search query is provided, it will
    return the complete dataset as an array:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchQuery()` 方法将解析返回的承诺，并根据搜索查询创建一个数据数组。如果没有提供搜索查询，它将返回完整的数据集作为数组：'
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `search()` method will prepare the dataset for the template to bind to
    in the frontend:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()` 方法将为前端绑定模板准备数据集：'
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have one more optional method here, which is used to navigate to the member
    details component. We''ve called that the `person` component. Here, the `viewDetails()`
    method will pass the member ID, and the `router.navigate()` method will navigate
    the application to the `person` component with the ID as a parameter, as shown
    here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还有一个可选的方法，用于导航到成员详情组件。我们将其称为 `person` 组件。在这里，`viewDetails()` 方法将传递成员 ID，`router.navigate()`
    方法将使用 ID 作为参数将应用程序导航到 `person` 组件，如下所示：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The complete code of `MembersComponent` will be as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`MembersComponent` 的完整代码如下：'
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `search` component template contains the search form and the list of search
    results when there are results to show.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当有结果要显示时，`search` 组件模板包含搜索表单和搜索结果列表。
- en: 'The template looks as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 模板如下所示：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding Angular components are similar to what has already been shown
    in the previous chapters.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的 Angular 组件与之前章节中展示的类似。
- en: We are using a dummy dataset from the `people.json` file, which contains information
    about people with addresses. We want to split the information in two parts, one
    as summary information and the other with address details. As we will work with
    this dataset, it will be easy to make an object model for this dataset.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用来自 `people.json` 文件的模拟数据集，该数据集包含有关带地址的人的信息。我们希望将信息分成两部分，一部分为摘要信息，另一部分为地址详情。由于我们将使用此数据集，因此将很容易为该数据集创建一个对象模型。
- en: The summary dataset will be defined as a `Person` object, and address details
    will be defined as `Address`. Let's create a person object at `app/members/person/person.component.ts`
    and place both object models in the same file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要数据集将被定义为 `Person` 对象，地址详情将被定义为 `Address`。让我们在 `app/members/person/person.component.ts`
    中创建一个人员对象，并将两个对象模型放在同一文件中。
- en: 'The two object model classes for `Person` and `Address` look like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 和 `Address` 的两个对象模型类如下所示：'
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Show me the search results!
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示我搜索结果！
- en: Now that the **Search** button is set with the required features, the result
    should contain the data only based on the search query, instead of everything.
    Let's look at the user specification.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**搜索**按钮已设置所需的功能，结果应仅包含基于搜索查询的数据，而不是所有内容。让我们看看用户规范。
- en: 'Given a set of search results:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组搜索结果：
- en: We will have the member list based on the search query
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将根据搜索查询拥有成员列表
- en: We will click on any member's name and navigate to the details component for
    details
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将点击任何成员的姓名，并导航到详情组件以获取详细信息
- en: Following the top-down approach, the first step will be the Protractor test,
    followed by the necessary steps to get the application fully functional.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 采用自顶向下的方法，第一步将是 Protractor 测试，然后是使应用程序完全功能所需的必要步骤。
- en: Testing the search results
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试搜索结果
- en: 'As the specification states, we will need to leverage the existing search results.
    Instead of creating a test from scratch, we can add to the existing search query
    test. Start with a base test embedded in the search query test, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，我们需要利用现有的搜索结果。我们不必从头创建测试，可以添加到现有的搜索查询测试中。从以下嵌入在搜索查询测试中的基本测试开始：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The next step is building the test.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建测试。
- en: Assembling the search result test
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装搜索结果测试
- en: In this case, the search results are already available from the search query
    test. We don't have to add any more setup steps for the test.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，搜索结果已从搜索查询测试中获取。我们不需要为测试添加任何更多设置步骤。
- en: Selecting a search result
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择搜索结果
- en: 'The object under testing is the result. The test is that the result is selected
    and the application must then do something. The steps to writing this in Protractor
    are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的对象是结果。测试是结果被选中，然后应用程序必须执行某些操作。在 Protractor 中编写此测试的步骤如下：
- en: 'Select the `resultItem`. As we will be representing the details using a route,
    we will create a link to the details page and click on the link. Here is how to
    create a link:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `resultItem`。由于我们将使用路由来表示详情，我们将创建一个指向详情页面的链接并点击该链接。以下是创建链接的方法：
- en: 'Select the link within the `resultItem`. This uses the currently selected element
    and then finds any subelements that meet the criteria. The code for this is as
    follows:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `resultItem` 内选择链接。这使用当前选定的元素，然后找到任何符合标准子元素。此代码如下所示：
- en: '[PRE56]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, to select the link, add the following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要选择链接，请添加以下代码：
- en: '[PRE57]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Confirming a search result
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认搜索结果
- en: 'Now that the search item has been selected, we will need to verify that the
    result details page is visible. The simplest solution at this point is to ensure
    that the details view is visible. This can be done using Protractor''s CSS locator
    to look for the search detail view. The following is the code to be added for
    confirming a search result:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在搜索项已被选择，我们需要验证结果详情页面是否可见。目前最简单的解决方案是确保详情视图是可见的。这可以通过使用 Protractor 的 CSS 定位器来查找搜索详情视图来完成。以下是要添加以确认搜索结果的代码：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is the complete test:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的测试：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that the test is set up, we can continue to the next phase of the life cycle
    and run it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经设置好了，我们可以继续到生命周期的下一阶段并运行它。
- en: The search result component
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索结果组件
- en: The search result component (the one we named `Person`) will route to accept
    the person ID from the `params` route and will search data based on that ID.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们命名的 `Person` 搜索结果组件将路由到接受 `params` 路由中的人员 ID，并将根据该 ID 搜索数据。
- en: 'The search result component will be placed in `app/members/person/person.component.ts`.
    In the code, at first, we will have to import the required Angular services, as
    shown here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果组件将被放置在 `app/members/person/person.component.ts` 中。在代码中，首先，我们必须导入所需的 Angular
    服务，如下所示：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ve already seen some of these Angular services in the `members` component.
    Here, we will mainly discuss the `ActivatedRoute`, as it''s new. This is an Angular
    router module, which is used to interact with the current/activated route: when
    we need to access the `params` in the current route, we''ll access them through this.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `members` 组件中看到了一些这些 Angular 服务。在这里，我们将主要讨论 `ActivatedRoute`，因为它很新。这是一个
    Angular 路由模块，用于与当前/激活的路由交互：当我们需要访问当前路由的 `params` 时，我们将通过它来访问。
- en: 'As we discussed, we will need `ActivatedRoute` while initializing the component;
    therefore, we have called `ActivatedRoute` on the `ngOnInit()` method. It will
    provide the current route params for us, and we will have our expected ID, which
    will be used to retrieve that specific `Person` from the demo members dataset,
    as shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的那样，在初始化组件时，我们需要 `ActivatedRoute`；因此，我们在 `ngOnInit()` 方法中调用了 `ActivatedRoute`。它将为我们提供当前的路由参数，我们将得到预期的
    ID，这将用于从演示成员数据集中检索特定的 `Person`，如下所示：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We have some dummy data at `app/data/people.json`. This is the same data used
    in the `members` component. We will retrieve the data based on the selected ID,
    like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `app/data/people.json` 中有一些模拟数据。这是与 `members` 组件中使用的相同数据。我们将根据所选 ID 检索数据，如下所示：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `getData()` method will retrieve the data from the API and will return
    a promise:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`getData()` 方法将从 API 获取数据，并将返回一个承诺：'
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `getPerson()` method will resolve the returned promise and will return the
    `Person` object based on the selected ID.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPerson()` 方法将解析返回的承诺，并根据所选 ID 返回 `Person` 对象。'
- en: 'The complete code regarding `PersonComponent` will be as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `PersonComponent` 的完整代码如下：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `search` component template contains the search form and the list of search
    results when there are some results to show.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当有搜索结果要显示时，`search` 组件模板包含搜索表单和搜索结果列表。
- en: 'The template looks as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 模板如下所示：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Search results in the route
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由中的搜索结果
- en: We have the search result/`Person` component, but we forgot to include that
    in the router configuration. Without that, we will have an exception as it will
    not be possible to navigate to the `Person` component from the `members` list
    without having it in the route.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了搜索结果/`Person` 组件，但我们忘记将其包含在路由配置中。没有它，我们将遇到异常，因为我们无法在没有它在路由中的情况下从 `members`
    列表中导航到 `Person` 组件。
- en: 'So, in our existing `app.routes.ts` file, we will add the following search
    routes:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的现有 `app.routes.ts` 文件中，我们将添加以下搜索路由：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Running the search wheel
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行搜索轮
- en: Our application is ready with the restructure, route configuration, e2e testing,
    and components with their child components. We will look at the current file structure
    and output of the project.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序经过重构、路由配置、端到端测试以及组件及其子组件的准备，我们将查看当前的项目文件结构和输出。
- en: App structure
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序结构
- en: We have two major folders in our application, one is the `app` directory and
    the other is the `spec/test` directory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中有两个主要文件夹，一个是`app`目录，另一个是`spec/test`目录。
- en: 'Let''s see the current structure of our `app` directory:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前`app`目录的结构：
- en: '![App structure](img/B05405_07_05.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![应用结构](img/B05405_07_05.jpg)'
- en: 'And here''s the `test` directory:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`test`目录：
- en: '![App structure](img/B05405_07_06.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![应用结构](img/B05405_07_06.jpg)'
- en: Let's run
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们运行
- en: Our search feature is ready to run. If we run `npm start`, our application will
    run in the browser on the port `3000` by default. Let's navigate to **Members**
    to get the output of the search feature. The search feature URL is `http://localhost:3000/members`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们搜索功能已经准备好运行。如果我们运行`npm start`，我们的应用程序将默认在端口`3000`上在浏览器中运行。让我们导航到**成员**以获取搜索功能的输出。搜索功能URL是`http://localhost:3000/members`。
- en: 'When we land on the **Members** page, it will actually load all the data as
    the search input is empty, which means there is no search query. The output should
    look as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达**成员**页面时，实际上会加载所有数据，因为搜索输入为空，这意味着没有搜索查询。输出应该如下所示：
- en: '![Let''s run](img/image_07_007.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![让我们运行](img/image_07_007.jpg)'
- en: 'Now let''s check the **Members** page with a search query. If we type `Thomas`
    as the query and search, it will give us only one data row, as shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查带有搜索查询的**成员**页面。如果我们输入`Thomas`作为查询并搜索，它将只给我们一条数据行，如下所示：
- en: '![Let''s run](img/image_07_008.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![让我们运行](img/image_07_008.jpg)'
- en: 'We have one row in the data list. Now it''s time to see the details of the
    data. After clicking on **Thomas**, we will see detailed information about Thomas,
    with the address, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 数据列表中有一行。现在是我们查看数据详情的时候了。点击**Thomas**后，我们将看到关于Thomas的详细信息，包括地址，如下所示：
- en: '![Let''s run](img/image_07_009.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![让我们运行](img/image_07_009.jpg)'
- en: Hurray! The complete application is running in the browser as expected.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼！完整的应用程序按预期在浏览器中运行。
- en: How's e2e now!
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在端到端测试（e2e）怎么样了！
- en: The project is running in the browser, and we've done e2e testing for every
    component. Let's see how the e2e test reacts when we run the whole application's
    e2e test together.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 项目正在浏览器中运行，我们已经为每个组件进行了端到端测试。让我们看看当我们一起运行整个应用程序的端到端测试时，端到端测试是如何反应的。
- en: 'Let''s run `npm run e2e`; the output is as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`npm run e2e`；输出如下所示：
- en: '![How''s e2e now!](img/B05405_07_10.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![现在端到端测试怎么样了！](img/B05405_07_10.jpg)'
- en: Self-test questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: Q1\. Which custom placeholder is used to load the component after navigation?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 在导航后加载组件时，使用哪种自定义占位符？
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Q2\. Given the following Angular component, how would you select the `element`
    and simulate a click?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 给定以下Angular组件，你会如何选择`element`并模拟点击？
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Q3\. When using routes with Angular, you need to install `@angular/router`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 在使用Angular的路由时，你需要安装`@angular/router`。
- en: 'True'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showed us how to use TDD to build an Angular application. The approach,
    up to this point, has focused on the specification from a user perspective and
    using TDD with a top-down approach. This technique helps us get usable and small
    components tested and completed for the users.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了如何使用TDD构建Angular应用程序。到目前为止，这种方法一直侧重于从用户角度的规范，并采用自上而下的TDD方法。这种技术帮助我们为用户测试和完成可用的且小的组件。
- en: As applications grow, so does their complexity. In the next chapter, we will
    explore the bottom-up approach and see when to use that technique over the top-down
    approach.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，它们的复杂性也在增加。在下一章中，我们将探讨自下而上的方法，并看看何时使用这种方法而不是自上而下的方法。
- en: This chapter showed us how TDD can be used to develop a component-based application
    with navigation by routers. Routes allow us to get a nice separation of our components
    and views. We looked at the usage of several Protractor locators, from CSS to
    repeaters, link text, and inner locators. Besides using Protractor, we also learned
    how to configure Karma with a headless browser, and we got to see it in action.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了如何使用测试驱动开发（TDD）来开发一个通过路由器进行导航的组件化应用程序。路由使我们能够很好地分离我们的组件和视图。我们探讨了几个Protractor定位器的使用，从CSS到重复器、链接文本和内部定位器。除了使用Protractor，我们还学习了如何配置Karma以使用无头浏览器，并看到了它的实际应用。
