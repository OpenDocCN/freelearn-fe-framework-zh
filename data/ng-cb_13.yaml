- en: '*Chapter 13*: Building PWAs with Angular'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：使用Angular构建PWAs'
- en: '**PWAs** or **Progressive Web Apps** are web applications at their core. Although
    they are built with enhanced features and experiences that are supported by modern
    browsers, if a PWA is run in a browser that doesn''t support the modern features/enhancements,
    the user still gets the core experience of the web application. In this chapter,
    you''re going to learn how to build Angular apps as PWAs. You''ll learn some techniques
    to make your apps **installable, capable, fast, and reliable**. The following
    are the recipes we''re going to cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PWAs或渐进式Web应用程序本质上是Web应用程序。尽管它们使用现代浏览器支持的增强功能和体验构建，但如果在不支持现代功能/增强功能的浏览器中运行PWA，则用户仍然可以获得Web应用程序的核心体验。在本章中，您将学习如何将Angular应用程序构建为PWA。您将学习一些技术，使您的应用程序具有可安装、功能强大、快速和可靠的特性。以下是本章中要涵盖的内容：
- en: Converting an exsisting Angular app into a PWA with the Angular CLI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CLI将现有的Angular应用程序转换为PWA
- en: Modifying the theme color for your PWA
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改您的PWA的主题颜色
- en: Using Dark Mode in your PWA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的PWA中使用深色模式
- en: Providing a custom installable experience in your PWA
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的PWA提供自定义可安装体验
- en: Precaching requests using an Angular service worker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular服务工作者预缓存请求
- en: Creating an App Shell for your PWA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的PWA创建应用程序外壳
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. You also
    need to install the `http-server` package globally. You can install it by running
    `npm install -g http-server` in your terminal. The code for this chapter can be
    found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter13](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter13).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，请确保您的计算机上已安装Git和Node.js。您还需要安装`@angular/cli`包，可以在终端中使用`npm install -g
    @angular/cli`来安装。您还需要全局安装`http-server`包。您可以在终端中运行`npm install -g http-server`来安装它。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter13](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter13)找到。
- en: Converting an existing Angular app into a PWA with the Angular CLI
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular CLI将现有的Angular应用程序转换为PWA
- en: A PWA involves a few interesting components, two of which are the service worker
    and the web manifest file. The service worker helps to cache the static resources
    and caching requests, and the web manifest file contains information about app
    icons, the theme color of the app, and so on. In this recipe, we'll convert an
    existing Angular application to a PWA. The principles apply to a fresh Angular
    app as well if you were to create it from scratch. For the sake of the recipe,
    we're going to convert an existing Angular app. We'll see what changed in our
    Angular web app and how the `@angular/pwa` package converts it into a PWA. Also,
    how it helps to cache the static resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PWA涉及一些有趣的组件，其中两个是服务工作者和Web清单文件。服务工作者有助于缓存静态资源和缓存请求，而Web清单文件包含有关应用程序图标、应用程序的主题颜色等信息。在本示例中，我们将把现有的Angular应用程序转换为PWA。这些原则也适用于从头开始创建的新Angular应用程序。为了示例，我们将转换一个现有的Angular应用程序。我们将看到我们的Angular
    Web应用程序中发生了什么变化，以及`@angular/pwa`包如何将其转换为PWA。还有它如何帮助缓存静态资源。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter13/start_here/angular-pwa-app`
    inside the cloned repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于克隆存储库中的`chapter13/start_here/angular-pwa-app`中：
- en: Open the project in Visual Studio Code.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng build --configuration production`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng build --configuration production`。
- en: Now run `http-server dist/angular-pwa-app -p 4200`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行`http-server dist/angular-pwa-app -p 4200`。
- en: 'This should run the app at `http://localhost:4200` in production mode, and
    should look as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该以生产模式在`http://localhost:4200`上运行应用程序，并且应该如下所示：
- en: '![Figure 13.1 – angular-pwa-app running on http://localhost:4200'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 - angular-pwa-app在http://localhost:4200上运行'
- en: '](image/Figure_13.01_B15150.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.01_B15150.jpg)'
- en: Figure 13.1 – angular-pwa-app running on http://localhost:4200
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 - angular-pwa-app在http://localhost:4200上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看到食谱的步骤。
- en: How to do it
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到
- en: 'The app we''re working with is a simple counter application. It has a min and
    max value, and some buttons that can increment, decrement, and reset the counter''s
    value. The app saves the value of the counter in `localStorage` but it is not
    a PWA yet. Let''s convert it into a PWA:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的应用程序是一个简单的计数器应用程序。它有一个最小值和最大值，以及一些按钮，可以增加、减少和重置计数器的值。该应用程序将计数器的值保存在`localStorage`中，但它还不是PWA。让我们将其转换为PWA：
- en: First, let's see if our application works offline at all, because that's one
    of the traits of PWAs. Open Chrome DevTools for the app. Go to the **Network**
    tab and change **Throttling** to **Offline** as follows:![Figure 13.2 – Changing
    network throttling to Offline to see the offline experience
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的应用程序是否根本可以离线工作，因为这是PWA的特征之一。为应用程序打开Chrome DevTools。转到**网络**选项卡，并将**限速**更改为**离线**，如下所示：![图13.2
    - 将网络限速更改为离线以查看离线体验
- en: '](image/Figure_13.2_B15150.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.2_B15150.jpg)'
- en: Figure 13.2 – Changing network throttling to Offline to see the offline experience
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 - 将网络限速更改为离线以查看离线体验
- en: Now stop the `http` server by exiting the process from your terminal. Once done,
    refresh the app's page. You should see that the app doesn't work anymore, as shown
    in the following figure:![Figure 13.3 – App not working offline
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过退出终端中的进程停止`http`服务器。完成后，刷新应用程序的页面。您应该看到应用程序不再工作，如下图所示：![图13.3 - 应用程序在离线状态下无法工作
- en: '](image/Figure_13.03_B15150.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.03_B15150.jpg)'
- en: Figure 13.3 – App not working offline
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 - 应用程序在离线状态下无法工作
- en: 'To convert this app into a PWA, open a new terminal window/tab and make sure
    you''re inside the `chapter13/start_here/angular-pwa-app` folder. Once inside,
    run the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此应用程序转换为PWA，请打开一个新的终端窗口/选项卡，并确保您在`chapter13/start_here/angular-pwa-app`文件夹内。进入后，运行以下命令：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should see a bunch of files created and updated as the process from the
    command finishes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令完成时，您应该看到一堆文件被创建和更新。
- en: Now build the app again by running `ng build --configuration production`. Once
    done, serve it using the `http-server dist/angular-pwa-app -p 4200` command.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次构建应用程序，运行`ng build --configuration production`。完成后，使用`http-server dist/angular-pwa-app
    -p 4200`命令进行服务。
- en: Now make sure you have turned off throttling by switching to the **Network**
    tab and setting **No throttling** as the selection option, as shown in *Figure
    13.4*. Also, notice that the **Disable cache** option is turned off:![Figure 13.4
    – Turning off network throttling
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在确保您已经通过切换到**网络**选项卡并将**无限制**设置为选择选项来关闭限速，如*图13.4*所示。还要注意**禁用缓存**选项已关闭：![图13.4
    - 关闭网络限速
- en: '](image/Figure_13.04_B15150.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.04_B15150.jpg)'
- en: Figure 13.4 – Turning off network throttling
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 - 关闭网络限速
- en: Now refresh the app once. You should see the app working and the network logs
    showing that assets such as JavaScript files were loaded from the server as shown
    in *Figure 13.5*:![Figure 13.5 – Assets downloaded from the source (Angular server)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在刷新应用程序一次。您应该看到应用程序正在工作，并且网络日志显示从服务器加载了JavaScript文件等资产，如*图13.5*所示：![图13.5 -
    从源下载的资产（Angular服务器）
- en: '](image/Figure_13.05_B15150.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.05_B15150.jpg)'
- en: Figure 13.5 – Assets downloaded from the source (Angular server)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 - 从源（Angular服务器）下载的资产
- en: Now refresh the app once again and you'll see that the same assets are now downloaded
    from the cache using the service worker, as shown in *Figure 13.6*:![Figure 13.6
    – Assets downloaded from the cache using the service worker
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次刷新应用程序，你会看到相同的资产现在是使用服务工作线程从缓存中下载的，如*图13.6*所示：![图13.6 - 使用服务工作线程从缓存中下载的资产
- en: '](image/Figure_13.06_B15150.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.06_B15150.jpg)'
- en: Figure 13.6 – Assets downloaded from the cache using the service worker
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 - 使用服务工作线程从缓存中下载的资产
- en: Now is the moment we've been waiting for. Change the network throttling back
    to **Offline** to go into the **Offline** mode and refresh the app. You should
    still see the app working in the **Offline** mode because of the service worker,
    as shown in *Figure 13.7*:![Figure 13.7 – Angular app working offline as a PWA
    using a service worker
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是我们一直在等待的时刻。将网络限制改回**离线**以进入**离线**模式，然后刷新应用程序。你应该仍然看到应用程序在**离线**模式下工作，因为服务工作线程，如*图13.7*所示：![图13.7
    - 使用服务工作线程作为PWA离线工作的Angular应用程序
- en: '](image/Figure_13.07_B15150.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.07_B15150.jpg)'
- en: Figure 13.7 – Angular app working offline as a PWA using a service worker
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 - 使用服务工作线程作为PWA离线工作的Angular应用程序
- en: 'What''s more, you can actually install this PWA now on your machine. Since
    I''m using a MacBook, it is installed as a Mac app. If you''re using Chrome, the
    installation option should be around the address bar, as shown in *Figure 13.8*:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而且，你现在实际上可以在你的机器上安装这个PWA。由于我使用的是MacBook，它被安装为Mac应用程序。如果你使用的是Chrome，安装选项应该在地址栏附近，如*图13.8*所示：
- en: '![Figure 13.8 – Installing the Angular PWA from Chrome'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8 - 从Chrome安装Angular PWA'
- en: '](image/Figure_13.08_B15150.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.08_B15150.jpg)'
- en: Figure 13.8 – Installing the Angular PWA from Chrome
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 - 从Chrome安装Angular PWA
- en: 'Kaboom! Just by using the `@angular/pwa` package, with zero configuration done
    ourselves, we converted our existing Angular app into a PWA. We are now able to
    run our application offline, and we can install it as a PWA on our devices. See
    *Figure 13.9* to see how the app looks – just like a native app on macOS X:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！只需使用`@angular/pwa`包，我们就将现有的Angular应用程序转换为PWA，而且没有进行任何配置。我们现在能够离线运行我们的应用程序，并且可以在我们的设备上安装它作为PWA。看看*图13.9*，看看应用程序的外观
    - 就像在macOS X上的本机应用程序一样：
- en: '![Figure 13.9 – How our Angular PWA looks as a native app on macOS X'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9 - 我们的Angular PWA在macOS X上作为本机应用程序的外观'
- en: '](image/Figure_13.09_B15150.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.09_B15150.jpg)'
- en: Figure 13.9 – How our Angular PWA looks as a native app on macOS X
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 - 我们的Angular PWA在macOS X上作为本机应用程序的外观
- en: Cool, right? Now that you know how to build a PWA with the Angular CLI, see
    the next section to understand how it works.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？现在你知道如何使用Angular CLI构建PWA了，看看下一节，了解它是如何工作的。
- en: How it works
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The Angular core team and the community have done an amazing job with the `@angular/pwa`
    package and, in general, with the `ng add` command, which allows us to add different
    packages to our applications using Angular schematics. In this recipe, when we
    run `ng add @angular/pwa`, it uses schematics to generate the app icons along
    with the web app manifest. If you look at the changed files, you can see the new
    files, as shown in *Figure 13.10*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Angular核心团队和社区在`@angular/pwa`包以及通常的`ng add`命令方面做得非常出色，这使我们能够使用Angular原理图向我们的应用程序添加不同的包。在这个示例中，当我们运行`ng
    add @angular/pwa`时，它使用原理图生成应用程序图标以及Web应用程序清单。如果你查看更改的文件，你可以看到新文件，如*图13.10*所示：
- en: '![Figure 13.10 – Web manifest file and the app icon files'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.10 - Web清单文件和应用图标文件'
- en: '](image/Figure_13.10_B15150.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.10_B15150.jpg)'
- en: Figure 13.10 – Web manifest file and the app icon files
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 - Web清单文件和应用图标文件
- en: The `manifest.webmanifest` file is a file that contains a JSON object. This
    object defines the manifest for the PWA and contains some information. The information
    includes the name of the app, the short name, the theme color, and the configuration
    for different icons, for different devices. Imagine this PWA installed on your
    Android phone. You definitely need an icon in your home drawer to tap on the icon
    to open the app. This file holds the information regarding which icon to use based
    on different device sizes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`manifest.webmanifest`文件是一个包含JSON对象的文件。这个对象定义了PWA的清单并包含一些信息。这些信息包括应用的名称、简称、主题颜色以及不同设备的不同图标的配置。想象一下这个PWA安装在你的安卓手机上。你肯定需要一个图标在你的主屏幕上，点击图标打开应用。这个文件包含了关于根据不同设备尺寸使用哪个图标的信息。'
- en: 'We also see the file `ngsw-config.json`, which contains the configuration for
    the service worker. Behind the scenes, while the `ng add` command is running the
    schematics, it also installs the `@angular/service-worker` package in our project.
    If you open the `app.module.ts` file, you''ll see the code to register our service
    worker as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会看到`ngsw-config.json`文件，其中包含了服务工作者的配置。在幕后，当`ng add`命令运行原理时，它也会在我们的项目中安装`@angular/service-worker`包。如果你打开`app.module.ts`文件，你会看到注册我们服务工作者的代码如下：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code registers a new service worker file named `ngsw-worker.js`. This file
    uses the configuration from the `ngsw-config.json` file to decide which resource
    to cache and using which strategies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码注册了一个名为`ngsw-worker.js`的新服务工作者文件。这个文件使用`ngsw-config.json`文件中的配置来决定缓存哪些资源以及使用哪些策略。
- en: Now that you know how the recipe works, see the next section for further reading.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道这个配方是如何工作的了，看下一节以获取更多信息。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular service worker intro ([https://angular.io/guide/service-worker-intro](https://angular.io/guide/service-worker-intro))
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular服务工作者介绍（[https://angular.io/guide/service-worker-intro](https://angular.io/guide/service-worker-intro))
- en: What are PWAs? ([https://web.dev/what-are-pwas/](https://web.dev/what-are-pwas/))
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是PWA？（[https://web.dev/what-are-pwas/](https://web.dev/what-are-pwas/))
- en: Modifying the theme color for your PWA
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改PWA的主题颜色
- en: In the previous recipe, we learned how to convert an Angular app into a PWA.
    And when we do so, the `@angular/pwa` package creates the web app manifest file
    with a default theme color, as shown in *Figure 13.9*. However, almost every web
    app has its own branding and style. And if you want to theme your PWA's title
    bar according to your branding, this is the recipe for you. We'll learn how to
    modify the web app manifest file to customize the PWA's theme color.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们学习了如何将一个Angular应用转换为PWA。当我们这样做时，`@angular/pwa`包会创建带有默认主题颜色的Web应用清单文件，如*图13.9*所示。然而，几乎每个Web应用都有自己的品牌和风格。如果你想根据自己的品牌主题化PWA的标题栏，这就是你需要的配方。我们将学习如何修改Web应用清单文件来自定义PWA的主题颜色。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter13/start_here/pwa-custom-theme-color`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的项目位于`chapter13/start_here/pwa-custom-theme-color`：
- en: Open the project in Visual Studio Code.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng build --configuration production`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng build --configuration production`。
- en: Now run `http-server dist/pwa-custom-theme-color -p 5300` to serve it.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行`http-server dist/pwa-custom-theme-color -p 5300`来提供服务。
- en: Open `localhost:5300` to view the application.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`localhost:5300`来查看应用程序。
- en: Finally, install the PWA as shown in *Figure 13.8*.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照*图13.8*中所示安装PWA。
- en: 'If you open the PWA, it should look as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开PWA，它应该如下所示：
- en: '![Figure 13.11 – PWA Custom Theme Color app'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.11 - PWA自定义主题颜色应用'
- en: '](image/Figure_13.11_B15150.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.11_B15150.jpg)'
- en: Figure 13.11 – PWA Custom Theme Color app
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 - PWA自定义主题颜色应用
- en: Now that we have the app running, let's see the steps of the recipe in the next
    section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序正在运行，让我们在下一节中看看食谱的步骤。
- en: How to do it
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'As you can see in *Figure 13.11*, the header of the app has a bit of a different
    color than the app''s native header (or toolbar). Due to this difference, the
    app looks a bit weird. We''ll modify the web app manifest to update the theme
    color. Let''s get started:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如*图13.11*中所示，应用程序的标题栏与应用程序的原生标题栏（或工具栏）颜色有些不同。由于这种差异，应用程序看起来有点奇怪。我们将修改Web应用程序清单以更新主题颜色。让我们开始吧：
- en: 'Open the `src/manifest.webmanifest` file in your editor and change the theme
    color as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`src/manifest.webmanifest`文件，并按照以下方式更改主题颜色：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also have `theme-color` set in our `index.html` file. By default, that has
    precedence over the web app manifest file. Therefore, we need to update it. Open
    the `index.html` file and update it as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`index.html`文件中也设置了`theme-color`。默认情况下，它优先于Web应用程序清单文件。因此，我们需要更新它。打开`index.html`文件，并按照以下方式更新它：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, build the app again using the `ng build --configuration production` command.
    Then serve it using `http-server` as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`ng build --configuration production`命令再次构建应用程序。然后使用`http-server`进行服务，如下所示：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open the PWA app again and uninstall it as shown in *Figure 13.12*. Make sure
    to check the box that says **Also clear data from Chrome (...)** when prompted:![Figure
    13.12 – Uninstalling the pwa-custom-theme-color app
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开PWA应用程序，并按照*图13.12*中所示卸载它。确保在提示时勾选“也清除Chrome中的数据(...)”的复选框：![图13.12 – 卸载pwa-custom-theme-color应用程序
- en: '](image/Figure_13.12_B15150.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.12_B15150.jpg)'
- en: Figure 13.12 – Uninstalling the pwa-custom-theme-color app
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – 卸载pwa-custom-theme-color应用程序
- en: Now open the Angular app in a new Chrome tab at `http://localhost:5300` and
    install the app again as a PWA as shown in *Figure 13.8*.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在新的Chrome标签页中打开Angular应用程序，网址为`http://localhost:5300`，并按照*图13.8*中所示再次安装该应用程序作为PWA。
- en: 'The PWA should already be opened. If not, open it from your applications and
    you should see the updated theme color as shown in *Figure 13.13*:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PWA应该已经打开了。如果没有，请从你的应用程序中打开它，你应该会看到更新后的主题颜色，就像*图13.13*中所示：
- en: '![Figure 13.13 – PWA app with the updated theme color'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.13 – 带有更新主题颜色的PWA应用程序'
- en: '](image/Figure_13.13_B15150.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.13_B15150.jpg)'
- en: Figure 13.13 – PWA app with the updated theme color
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 – 带有更新主题颜色的PWA应用程序
- en: Awesomesauce! You've just learned how to update the theme color for an Angular
    PWA. Now that you've finished the recipe, see the next section for further reading.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你刚刚学会了如何为Angular PWA更新主题颜色。完成了这个食谱后，查看下一节以获取更多阅读材料。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Creating a PWA with the Angular CLI ([https://web.dev/creating-pwa-with-angular-cli/](https://web.dev/creating-pwa-with-angular-cli/))
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CLI创建PWA ([https://web.dev/creating-pwa-with-angular-cli/](https://web.dev/creating-pwa-with-angular-cli/))
- en: Using Dark Mode in your PWA
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的PWA中使用深色模式
- en: In the modern age of devices and applications, the preferences of end users
    have evolved a bit as well. With the increased usage of screens and devices, health
    is one of the major concerns. And we know that almost all screen devices now support
    dark mode. Considering this fact, if you're building a web app, you might want
    to provide dark mode support for it. And if it is a PWA that presents itself as
    a native app, the responsibility is much greater. In this recipe, you'll learn
    how to provide a dark mode for your Angular PWA.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代设备和应用程序时代，最终用户的偏好也有所发展。随着屏幕和设备的使用增加，健康成为了一个主要关注点。我们知道现在几乎所有屏幕设备都支持深色模式。考虑到这一事实，如果你正在构建一个Web应用程序，你可能希望为其提供深色模式支持。如果它是一个以原生应用程序形式呈现的PWA，那责任就更大了。在这个食谱中，你将学习如何为你的Angular
    PWA提供深色模式。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter13/start_here/pwa-dark-mode`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的项目位于`chapter13/start_here/pwa-dark-mode`中：
- en: Open the project in Visual Studio Code.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng build --configuration production`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng build --configuration production`。
- en: Now run `http-server dist/pwa-dark-mode -p 6100` to serve it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行 `http-server dist/pwa-dark-mode -p 6100` 进行服务。
- en: Finally, install the PWA as shown in *Figure 13.8*
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照 *图 13.8* 所示安装 PWA
- en: Now make sure you have the Dark theme enabled on your machine. If you're running
    macOS X, you can open **Settings** | **General** and select the **Dark** appearance
    as shown in *Figure 13.14*:![Figure 13.14 – Changing the system appearance to
    Dark mode in macOS X
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在确保您的计算机上启用了暗色主题。如果您正在运行 macOS X，您可以打开 **设置** | **通用** 并选择 **暗色** 外观，如 *图 13.14*
    所示：![图 13.14 – 在 macOS X 中更改系统外观为暗模式
- en: '](image/Figure_13.14_B15150.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.14_B15150.jpg)'
- en: Figure 13.14 – Changing the system appearance to Dark mode in macOS X
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14 – 在 macOS X 中更改系统外观为暗模式
- en: 'Once done, open the PWA as the native app and you should see it as shown in
    *Figure 13.15*:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，以原生应用程序的形式打开 PWA，您应该会看到它如 *图 13.15* 所示：
- en: '![Figure 13.15 – PWA Custom Theme Color app in System Dark Mode appearance'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.15 – PWA 自定义主题颜色应用程序在系统暗模式下的外观'
- en: '](image/Figure_13.15_B15150.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.15_B15150.jpg)'
- en: Figure 13.15 – PWA Custom Theme Color app in System Dark Mode appearance
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 – PWA 自定义主题颜色应用程序在系统暗模式下的外观
- en: Now that we have the PWA running as a native app, and the Dark mode applied
    to the system, let's see the steps of the recipe in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 PWA 作为原生应用程序运行，并将暗模式应用于系统，让我们在下一节中看到食谱的步骤。
- en: How to do it
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'As you can see, the Angular app doesn''t have support for dark mode at the
    moment. We''ll begin by serving the app in development mode and by adding different
    colors for dark mode. Let''s get started:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，目前 Angular 应用程序不支持暗模式。我们将从以开发模式运行应用程序开始，并为暗模式添加不同的颜色。让我们开始吧：
- en: Serve the app in development mode by running the command `ng serve -o --port
    9291`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以开发模式运行应用程序，运行命令 `ng serve -o --port 9291`。
- en: This should serve the app in a new browser tab at `http://localhost:4200`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器选项卡中为应用程序提供服务，网址为 `http://localhost:4200`。
- en: 'Now, open the `styles.scss` file to use the `prefers-color-scheme` media query.
    We''ll use a different value for our global CSS variables to create a different
    view for dark mode. Update the file as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `styles.scss` 文件以使用 `prefers-color-scheme` 媒体查询。我们将为全局 CSS 变量使用不同的值，以创建暗模式的不同视图。按照以下方式更新文件：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you refresh the app again in the browser tab, you''ll see a different dark
    mode view based on the `prefers-color-scheme` media query as shown in *Figure
    13.16*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器选项卡中再次刷新应用程序，您将看到基于 `prefers-color-scheme` 媒体查询的不同暗模式视图，如 *图 13.16* 所示：
- en: '![Figure 13.16 – The dark mode view using the prefers-color-scheme media query'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.16 – 使用 prefers-color-scheme 媒体查询的暗模式视图'
- en: '](image/Figure_13.16_B15150.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.16_B15150.jpg)'
- en: Figure 13.16 – The dark mode view using the prefers-color-scheme media query
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – 使用 prefers-color-scheme 媒体查询的暗模式视图
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is possible that you already have run a PWA at `localhost:4200`; that is
    why in *step 1* we're targeting port `9291`. If even that has been used earlier,
    please make sure to clear the application cache and then refresh.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能您已经在 `localhost:4200` 上运行了 PWA；这就是为什么在 *步骤 1* 中我们将目标端口设为 `9291`。如果甚至那个端口也被使用过，请确保清除应用程序缓存，然后刷新。
- en: Let's simulate the dark and light modes using Chrome DevTools as it provides
    a really nice way to do so. Open Chrome DevTools and then open the **Command**
    menu. On macO SX, the keys are *Cmd* + *Shift* + *P*. On Windows, it is *Ctrl*
    + *Shift* + *P*. Then type `Render` and select the **Show Rendering** option as
    shown in *Figure 13.17*:![Figure 13.17 – Open the rendering view using the Show
    Rendering option
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用Chrome DevTools模拟深色和浅色模式，因为它提供了一个非常好的方法来做到这一点。打开Chrome DevTools，然后打开“命令”菜单。在macOS上，键是*Cmd*
    + *Shift* + *P*。在Windows上，它是*Ctrl* + *Shift* + *P*。然后输入`Render`，并选择“显示渲染”选项，如图13.17所示：![图13.17
    - 使用“显示渲染”选项打开渲染视图
- en: '](image/Figure_13.17_B15150.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.17_B15150.jpg)'
- en: Figure 13.17 – Open the rendering view using the Show Rendering option
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17 - 使用“显示渲染”选项打开渲染视图
- en: Now, in the **Rendering** tab, toggle the `prefers-color-scheme` emulation for
    light and dark modes as shown in *Figure 13.18*:![Figure 13.18 – Simulate prefers-color-scheme
    modes
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在“渲染”选项卡中，切换`prefers-color-scheme`仿真为浅色和深色模式，如图13.18所示：![图13.18 - 模拟prefers-color-scheme模式
- en: '](image/Figure_13.18_B15150.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.18_B15150.jpg)'
- en: Figure 13.18 – Simulate prefers-color-scheme modes
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 - 模拟prefers-color-scheme模式
- en: Now that we've tested both modes. We can create the production build and re-install
    the PWA. Run the `ng build --configuration production` command to build the app
    in production mode.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经测试了两种模式。我们可以创建生产版本并重新安装PWA。运行`ng build --configuration production`命令以在生产模式下构建应用程序。
- en: Now uninstall the existing PWA by opening it and then selecting the **Uninstall**
    option from the **More** menu as shown in *Figure 13.12*. Make sure to check the
    box that says **Also clear data from Chrome (...)** when prompted.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过打开现有的PWA并从“更多”菜单中选择“卸载”选项来卸载它，如图13.12所示。在提示时确保勾选“同时清除Chrome中的数据（...）”的复选框。
- en: 'Run the following command to serve the built app on the browser and then navigate
    to `http://localhost:6100`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令在浏览器上提供构建的应用程序，然后导航到`http://localhost:6100`：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Wait for a few seconds for the **Install** button to show up in the address
    bar. Then install the PWA similar to *Figure 13.8*.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，直到地址栏中出现“安装”按钮。然后安装PWA，类似于图13.8。
- en: 'As soon as you run the PWA now, you should see the dark mode view as shown
    in *Figure 13.19*, if your system''s appearance is set to dark mode:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你运行PWA时，如果你的系统外观设置为深色模式，你应该看到深色模式视图，如图13.19所示：
- en: '![Figure 13.19 – Our PWA supporting dark mode out of the box'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.19 - 我们的PWA支持开箱即用的深色模式'
- en: '](image/Figure_13.19_B15150.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.19_B15150.jpg)'
- en: Figure 13.19 – Our PWA supporting dark mode out of the box
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 - 我们的PWA支持开箱即用的深色模式
- en: Awesome! If you switch your system appearance from dark mode to light mode or
    vice versa, you should see the PWA reflecting the appropriate colors. Now that
    you know how to support dark mode in your PWA, see the next section to see links
    for further reading.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如果你将系统外观从深色模式切换到浅色模式，或者反之亦然，你应该看到PWA反映出适当的颜色。现在你知道如何在你的PWA中支持深色模式了，看看下一节，看看更多阅读的链接。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Prefers color scheme ([https://web.dev/prefers-color-scheme/](https://web.dev/prefers-color-scheme/))
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 喜欢颜色方案（[https://web.dev/prefers-color-scheme/](https://web.dev/prefers-color-scheme/)）
- en: Using color scheme with prefers-color-scheme ([https://web.dev/color-scheme/](https://web.dev/color-scheme/))
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用prefers-color-scheme的颜色方案（[https://web.dev/color-scheme/](https://web.dev/color-scheme/)）
- en: Providing a custom installable experience in your PWA
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的PWA中提供自定义可安装体验
- en: We know that PWAs are installable. This means they can be installed on your
    devices like a native application. However, when you first open the app in the
    browser, it totally depends on the browser how it shows the **Install** option.
    It varies from browser to browser. And it also might not be very prompt or clearly
    visible. And also, you might want to show the **Install** prompt at some point
    in the app instead of the app launch, which is annoying for some users. Luckily,
    we have a way to provide our own custom dialog/prompt for the installation option
    for our PWAs. And that is what we'll learn in this recipe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道PWA是可安装的。这意味着它们可以像本机应用程序一样安装在您的设备上。然而，当您首次在浏览器中打开应用时，它完全取决于浏览器如何显示**安装**选项。这因浏览器而异。而且它也可能不太及时或清晰可见。而且，您可能希望在应用程序启动之后的某个时刻显示**安装**提示，这对一些用户来说是很烦人的。幸运的是，我们有一种方法为我们的PWA提供自定义的安装选项对话框/提示。这就是我们将在本节中学习的内容。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter13/start_here/pwa-custom-install-prompt`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的项目位于`chapter13/start_here/pwa-custom-install-prompt`中：
- en: Open the project in Visual Studio Code.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng build --configuration production`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng build --configuration production`。
- en: Now run `http-server dist/pwa-custom-install-prompt -p 7200` to serve it.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行`http-server dist/pwa-custom-install-prompt -p 7200`来提供服务。
- en: 'Navigate to `http://localhost:7200`. Wait for a while and you should see the
    install prompt as shown in *Figure 13.20*:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:7200`。等待一会儿，您应该会看到安装提示，如*图13.20*所示：
- en: '![Figure 13.20 – pwa-custom-install-prompt running at http://localhost:7200'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.20 - pwa-custom-install-prompt在http://localhost:7200上运行'
- en: '](image/Figure_13.20_B15150.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.20_B15150.jpg)'
- en: Figure 13.20 – pwa-custom-install-prompt running at http://localhost:7200
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20 - pwa-custom-install-prompt在http://localhost:7200上运行
- en: Now that we have the app running, let's see the steps of the recipe in the next
    section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序正在运行，让我们在下一节中看看这个配方的步骤。
- en: How to do it
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'We have the Dice Guesser application in which you roll the dice and guess the
    output. For this recipe, we''ll prevent the default installation prompt and will
    show it only when the user has made a correct guess. Let''s begin:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为Dice Guesser的应用程序，您可以在其中掷骰子并猜测结果。对于本节，我们将阻止默认的安装提示，并仅在用户猜对时显示它。让我们开始吧：
- en: 'First of all, create a service that will show our custom installable prompt
    in the next steps. In the project root, run the following command:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个服务，将在接下来的步骤中显示我们的自定义可安装提示。在项目根目录中，运行以下命令：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now open the created file, `installable-prompt.service.ts`, and update the
    code as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开创建的文件`installable-prompt.service.ts`，并按以下方式更新代码：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s build the custom dialog/prompt we''ll show to the user. We''re
    going to use the **Material** dialog from the `@angular/material` package that
    we already have installed in the project. Open the `app.module.ts` file and update
    it as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建我们将向用户显示的自定义对话框/提示。我们将使用`@angular/material`包中已经安装在项目中的**Material**对话框。打开`app.module.ts`文件，并按以下方式更新它：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s create a component for the **Material** dialog. In the project root,
    run the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为**Material**对话框创建一个组件。在项目根目录中，运行以下命令：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll use this component in `InstallablePromptService` now. Open the `installable-prompt.service.ts`
    file and update the code as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在`InstallablePromptService`中使用这个组件。打开`installable-prompt.service.ts`文件，并按以下方式更新代码：
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to show the browser''s prompt based on our selection from our
    custom installable prompt. For example, if the user clicks the **Yes** button,
    it means they want to install the app as a PWA. In this case, we''ll show the
    browser''s prompt. Update the `installable-prompt.service.ts` file further as
    follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要根据我们自定义可安装提示的选择来显示浏览器的提示。例如，如果用户点击**是**按钮，这意味着他们想将应用程序安装为PWA。在这种情况下，我们将显示浏览器的提示。按照以下方式进一步更新`installable-prompt.service.ts`文件：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have set up the main code for the browser''s prompt. Let''s work
    on the template of our custom installable prompt. Open the `installable-prompt.component.html`
    file and replace the template with the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为浏览器的提示设置了主要代码。让我们来处理我们自定义可安装提示的模板。打开`installable-prompt.component.html`文件，并用以下代码替换模板：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, let''s show this prompt whenever the user makes a correct guess. Open
    the `game.component.ts` file and update it as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，每当用户猜对时，让我们显示这个提示。打开`game.component.ts`文件，并按照以下方式更新它：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s test the application now. Build the app in production mode and serve
    it using the `http-server` package on port `7200` by using the following commands:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们测试应用程序。使用以下命令在生产模式下构建应用程序，并使用`http-server`包在端口`7200`上提供服务：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before we test it out, you might want to clear the app's cache and unregister
    the service worker. You can do it by opening Chrome DevTools and navigating to
    the **Application** tab. Then click the **Clear site data** button as shown in
    *Figure 13.21*. Make sure the option **Unregister service workers** is checked:![Figure
    13.21 – Clearing site data including service workers
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们测试之前，您可能想要清除应用程序的缓存并注销服务工作者。您可以通过打开Chrome DevTools并导航到**应用程序**选项卡来执行此操作。然后点击*图13.21*所示的**清除站点数据**按钮。确保选中**注销服务工作者**选项：![图13.21
    - 清除站点数据，包括服务工作者
- en: '](image/Figure_13.21_B15150.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.21_B15150.jpg)'
- en: Figure 13.21 – Clearing site data including service workers
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21 - 清除站点数据，包括服务工作者
- en: 'Now play the game until you guess one right answer. As soon as you get it,
    you''ll see the custom installable prompt as shown in *Figure 13.22*. Click the
    **Sure** button and you should see the browser''s prompt:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在玩游戏，直到您猜对一个答案。一旦您猜对，您将看到自定义可安装提示，如*图13.22*所示。点击**确定**按钮，您应该会看到浏览器的提示：
- en: '![Figure 13.22 – Custom installable prompt for our PWA'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.22 - 我们PWA的自定义可安装提示'
- en: '](image/Figure_13.22_B15150.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.22_B15150.jpg)'
- en: Figure 13.22 – Custom installable prompt for our PWA
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.22 - 我们PWA的自定义可安装提示
- en: Awesome! You can now play around with the app by installing and uninstalling
    the PWA a few times and trying out all the combinations of the user choosing to
    install or not to install the app. It's all fun and games. And now that you know
    how to implement a custom installation prompt for an Angular PWA, see the next
    section to understand how it works.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在您可以通过安装和卸载几次PWA应用程序并尝试用户选择安装或不安装应用程序的所有组合来玩转应用程序。这都是有趣的游戏。现在您知道如何为Angular
    PWA实现自定义安装提示，接下来请查看下一节以了解其工作原理。
- en: How it works
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The heart of this recipe is the `beforeinstallprompt` event. It is a standard
    browser event that is supported in the latest version of Chrome, Firefox, Safari,
    Opera, UC Browser (Android version), and Samsung Internet, that is, almost all
    major browsers. The event has a `prompt()` method that shows the browser's default
    prompt on the device. In the recipe, we create `InstallablePromptService` and
    store the event in its `local` property. This is so we can use it later on-demand
    when the user has guessed a correct roll value. Note that as soon as we receive
    the `beforeinstallprompt` event, we remove the event listener from the `window`
    object so we only save the event once. That is when the app starts. And if the
    user chooses not to install the app, we don't show the prompt again within the
    same session. However, if the user refreshes the app, they will still get the
    prompt one time for the first correct guess. We could go one step further to save
    this state in `localStorage` to avoid showing the prompt after the page refreshes,
    but that's not a part of this recipe.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的核心是`beforeinstallprompt`事件。这是一个标准的浏览器事件，在最新版本的Chrome、Firefox、Safari、Opera、UC浏览器（Android版本）和Samsung
    Internet中都得到支持，也就是几乎所有主要浏览器。该事件有一个`prompt()`方法，在设备上显示浏览器的默认提示。在这个示例中，我们创建了`InstallablePromptService`并将事件存储在其`local`属性中。这样我们可以在用户猜对正确的值时随需使用它。请注意，一旦我们收到`beforeinstallprompt`事件，就会从`window`对象中移除事件侦听器，这样我们只保存一次事件。这是在应用程序启动时。如果用户选择不安装应用程序，我们在同一会话中不会再次显示提示。但是，如果用户刷新应用程序，他们仍然会在第一次猜对时获得一次提示。我们可以进一步将这个状态保存在`localStorage`中，以避免在页面刷新后再次显示提示，但这不是这个示例的一部分。
- en: 'For the custom installation prompt, we use the `MatDialog` service from the
    `@angular/material` package. This service has an `open()` method, which takes
    two parameters: the component to show as a Material dialog and `MatDialogConfig`.
    In the recipe, we create the `InstallablePromptComponent`, which uses some HTML
    elements with directives from the `@angular/material/dialog` package. Note that
    on the buttons, we use the attribute `[mat-dialog-close]` in the `installable-prompt.component.html`
    file. And the values are set to `true` and `false` for the **Sure** and **No Thanks**
    buttons respectively. These attributes help us send the respective value from
    this modal to `InstallablePromptService`. Notice the usage of `dialogRef.afterClosed().subscribe()`
    in the `installable-prompt.service.ts` file. That''s where the values are passed
    back. If the value is `true`, then we use the event, that is, the `this.installablePrompt`
    property''s `.prompt()` method to show the browser''s prompt. Note that we set
    the `installablePrompt` property''s value to `null` after its usage. This is so
    we don''t show the prompt again in the same session until the user refreshes the
    page.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义安装提示，我们使用`@angular/material`包中的`MatDialog`服务。该服务有一个`open()`方法，接受两个参数：要显示为Material对话框的组件和`MatDialogConfig`。在这个示例中，我们创建了`InstallablePromptComponent`，它使用了来自`@angular/material/dialog`包的一些带指令的HTML元素。请注意，在按钮上，我们在`installable-prompt.component.html`文件中使用了属性`[mat-dialog-close]`。值分别设置为`true`和`false`，用于**确定**和**不，谢谢**按钮。这些属性帮助我们将相应的值从此模态发送到`InstallablePromptService`。请注意在`installable-prompt.service.ts`文件中使用了`dialogRef.afterClosed().subscribe()`。这是值被传递回去的地方。如果值为`true`，那么我们使用事件，也就是`this.installablePrompt`属性的`.prompt()`方法来显示浏览器的提示。请注意，在使用后我们将`installablePrompt`属性的值设置为`null`。这样我们在同一会话中不会再次显示提示，直到用户刷新页面。
- en: Now that you understand how it all works, see the next section to see links
    for further reading.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了所有的工作原理，可以查看下一节以获取进一步阅读的链接。
- en: See also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular Material Dialog examples (https://material.angular.io/components/dialog/examples)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Material对话框示例（https://material.angular.io/components/dialog/examples）
- en: MatDialogConfig (https://material.angular.io/components/dialog/api#MatDialogConfig)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MatDialogConfig (https://material.angular.io/components/dialog/api#MatDialogConfig)
- en: How to provide your own app-install experience (web.dev) (https://web.dev/customize-install/)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提供自己的应用安装体验（web.dev）(https://web.dev/customize-install/)
- en: Precaching requests using an Angular service worker
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular服务工作者预缓存请求
- en: With the addition of service workers in our previous recipes, we've seen that
    they already cache the assets and serve them using the service worker if we go
    into **Offline** mode. But what about network requests? If the user goes offline
    and refreshes the application right now, the network requests fail because they're
    not cached with the service worker. This results in a broken offline user experience.
    In this recipe, we'll configure the service worker to precache network requests
    so the app works fluently in **Offline** mode as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中添加了服务工作者，我们已经看到它们已经缓存了资产，并在**离线**模式下使用服务工作者提供它们。但是网络请求呢？如果用户离线并立即刷新应用程序，网络请求将失败，因为它们没有与服务工作者一起缓存。这导致了破碎的离线用户体验。在这个示例中，我们将配置服务工作者来预缓存网络请求，以便应用程序在**离线**模式下也能流畅运行。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter13/start_here/precaching-requests`
    inside the cloned repository:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的`chapter13/start_here/precaching-requests`中：
- en: Open the project in Visual Studio Code.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Once done, run `ng build --configuration production`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng build --configuration production`。
- en: Now run `http-server dist/precaching-requests -p 8300` to serve it.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行`http-server dist/precaching-requests -p 8300`来提供服务。
- en: 'Navigate to `http://localhost:8300`. Refresh the app once. Then switch to **Offline**
    mode as shown in *Figure 13.2*. If you go to the **Network** tab and filter the
    requests using the query `results`, you should see that the requests fail as shown
    in *Figure 13.23*:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:8300`。刷新应用程序一次。然后按照*图13.2*所示切换到**离线**模式。如果您转到**网络**选项卡并使用查询`results`过滤请求，您应该看到请求失败，如*图13.23*所示：
- en: '![Figure 13.23 – Offline experience broken due to not caching the network request'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.23 - 由于未缓存网络请求而导致的离线体验破碎'
- en: '](image/Figure_13.23_B15150.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.23_B15150.jpg)'
- en: Figure 13.23 – Offline experience broken due to not caching the network request
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.23 - 由于未缓存网络请求而导致的离线体验破碎
- en: Now that we see the network requests failing, lets see the steps of the recipe
    in the next section to fix this.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到网络请求失败了，让我们在下一节中看看修复这个问题的步骤。
- en: How to do it
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'For this recipe, we have the users list and search app that fetches some users
    from an API endpoint. As you can see in *Figure 13.23*, if we go into **Offline**
    mode, the `fetch` call fails as well as the call for the request to the service
    worker. This is because the service worker isn''t configured yet to cache the
    data request. Let''s get started with the recipe to fix this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们有用户列表和搜索应用程序，从API端点获取一些用户。正如您在*图13.23*中所看到的，如果我们进入**离线**模式，`fetch`调用以及对服务工作者的请求也会失败。这是因为服务工作者尚未配置为缓存数据请求。让我们开始修复这个问题的示例：
- en: 'In order to cache the network requests, open the `ngsw-config.json` file and
    update it as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了缓存网络请求，打开`ngsw-config.json`文件并进行如下更新：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s test the application now. Build the app in production mode and serve
    it using the `http-server` package on port `8300` by using the following commands:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们测试一下应用程序。使用以下命令以生产模式构建应用程序，并使用`http-server`包在端口`8300`上提供服务：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now navigate to http://localhost:8300\. Make sure you're not using **Network
    throttling** at this moment. That is, you are not in **Offline** mode.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导航到http://localhost:8300\. 确保此时没有使用**网络限速**。也就是说，你没有处于**离线**模式。
- en: Clear the app data using Chrome DevTools as shown in *Figure 13.21*. Once done,
    refresh the app page.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Chrome DevTools清除应用程序数据，如*图13.21*所示。完成后，刷新应用程序页面。
- en: 'In Chrome DevTools, go to the **Network** tab and switch to **Offline** mode
    as shown in *Figure 13.2*. Now filter the network requests using the query `results`.
    You should see the results despite being offline. And the network call is served
    from the service worker as shown in *Figure 13.24*:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome DevTools中，转到**网络**选项卡，并切换到**离线**模式，如*图13.2*所示。现在使用查询`results`过滤网络请求。即使处于离线状态，您也应该看到结果。网络调用是由service
    worker提供的，如*图13.24*所示：
- en: '![Figure 13.24 – Network call working offline using the service worker'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.24 – 使用service worker离线工作的网络调用'
- en: '](image/Figure_13.24_B15150.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.24_B15150.jpg)'
- en: Figure 13.24 – Network call working offline using the service worker
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24 – 使用service worker离线工作的网络调用
- en: And boom! Even if you click a card now, you should still see the app working
    flawlessly because all the pages use the same API call, hence, served from the
    service worker. And with that, you've just learned how to configure a service
    worker in an Angular app to cache network/data requests. And you can install the
    PWA and use it even if you're offline. Awesome! Right?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！即使现在点击一个卡片，您仍然应该看到应用程序无缝运行，因为所有页面都使用相同的API调用，因此由service worker提供。通过这样，您刚刚学会了如何在Angular应用程序中配置service
    worker以缓存网络/数据请求。即使离线，您也可以安装PWA并使用它。很棒，对吧？
- en: Now that we've finished the recipe, let's see in the next section how it all
    works.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个教程，让我们在下一节中看看它是如何工作的。
- en: How it works
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The heart of this recipe is the `ngsw-config.json` file. This file is used
    by the `@angular/service-worker` package when generating the service worker file.
    The file already contains a JSON object out of the box when we use the `@angular/pwa`
    schematics by running `ng add @angular/pwa`. This JSON contains a property called
    `assetGroups`, which basically configures the caching of the assets based on the
    provided configuration. For this recipe, we wanted to cache network requests along
    with the assets. Therefore, we added the new property `dataGroups` in the JSON
    object. Let''s have a look at the configuration:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程的核心是`ngsw-config.json`文件。当使用`@angular/service-worker`包生成service worker文件时，该文件将被`@angular/pwa`原理图使用时，该文件已经包含一个JSON对象。该JSON包含一个名为`assetGroups`的属性，基本上根据提供的配置来配置资产的缓存。对于这个教程，我们希望缓存网络请求以及资产。因此，我们在JSON对象中添加了新属性`dataGroups`。让我们看看配置：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, `dataGroups` is an array. We can provide different configuration
    objects as elements to it. Each configuration has a `name`, an array of `urls`,
    and a `cacheConfig` that defines the caching strategy. For our configuration,
    we use a wildcard with the API URL, that is, we use `urls:` `["`https://api.randomuser.me/?results*`"]`.
    For the `cacheConfig`, we're using the `"freshness"` strategy, which means the
    app will always fetch the data from its origin first. If the network is unavailable,
    then it will use the response from the service worker cache. An alternate strategy
    is `"performance"`, which first looks up the service worker for a cached response.
    If there's nothing in the cache for the particular URL (or URLs), then it fetches
    the data from the actual origin. The `maxSize` property defines how many requests
    can be cached for the same pattern (or set of URLs). And the `maxAge` property
    defines how long the cached data would live in the service worker cache.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，`dataGroups` 是一个数组。我们可以将不同的配置对象作为其元素提供。每个配置都有一个`name`，一个`urls`数组，以及定义缓存策略的`cacheConfig`。对于我们的配置，我们使用了API
    URL的通配符，也就是说，我们使用了`urls: ["https://api.randomuser.me/?results*"]`。对于`cacheConfig`，我们使用了`"freshness"`策略，这意味着应用程序将始终首先从其原始位置获取数据。如果网络不可用，那么它将使用来自服务工作器缓存的响应。另一种策略是`"performance"`，它首先查找服务工作器以获取缓存的响应。如果缓存中没有特定URL（或URL）的内容，那么它将从实际原始位置获取数据。`maxSize`属性定义了可以为相同模式（或一组URL）缓存多少个请求。`maxAge`属性定义了缓存数据在服务工作器缓存中存活多长时间。'
- en: Now that you know how the recipe works, see the next section for links for further
    reading.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道这个示例是如何工作的，请参阅下一节以获取进一步阅读的链接。
- en: See also
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular Service Worker Intro (https://angular.io/guide/service-worker-intro)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Service Worker Intro (https://angular.io/guide/service-worker-intro)
- en: Angular Service Worker Config (https://angular.io/guide/service-worker-config)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Service Worker Config (https://angular.io/guide/service-worker-config)
- en: Creating an offline fallback page (web.dev) (https://web.dev/offline-fallback-page/)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建离线回退页面 (web.dev) (https://web.dev/offline-fallback-page/)
- en: Creating an App Shell for your PWA
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的PWA创建一个应用外壳
- en: When it comes to building fast user experiences for web apps, one of the major
    challenges is minimizing the critical rendering path. This includes loading the
    most critical resources for the target page, parsing and executing JavaScript,
    and so on. With an App Shell, we have the ability to render a page, or a portion
    of the app, at build time rather than runtime. This means the user will see the
    pre-rendered content initially, until JavaScript and Angular kick in. This means
    the browser doesn't have to work and wait a while for the first meaningful paint.
    In this recipe, you'll create an App Shell for an Angular PWA.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Web应用程序的快速用户体验时，最大的挑战之一是最小化关键渲染路径。这包括加载目标页面的最关键资源，解析和执行JavaScript等。通过应用外壳，我们有能力在构建时而不是运行时渲染页面或应用的一部分。这意味着用户最初将看到预渲染的内容，直到JavaScript和Angular开始运行。这意味着浏览器不必为了第一个有意义的绘制而工作和等待一段时间。在这个示例中，您将为Angular
    PWA创建一个应用外壳。
- en: Getting ready
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project that we are going to work with resides in `chapter13/start_here/pwa-app-shell`
    inside the cloned repository:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库内的`chapter13/start_here/pwa-app-shell`中：
- en: Open the project in Visual Studio Code.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open a tab and run the app at `http://localhost:4200` as shown
    in *Figure 13.25*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该打开一个选项卡，并在`http://localhost:4200`上运行应用程序，如*图13.25*所示：
- en: '![Figure 13.25 – pwa-app-shell running on http://localhost:4200'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.25 - 在http://localhost:4200上运行的pwa-app-shell'
- en: '](image/Figure_13.25_B15150.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.25_B15150.jpg)'
- en: Figure 13.25 – pwa-app-shell running on http://localhost:4200
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25 - pwa-app-shell运行在http://localhost:4200
- en: 'Now we''ll disable JavaScript to simulate taking a lot of time to parse JavaScript.
    Or, to simulate that there''s no App Shell in place yet. Open Chrome DevTools
    and open the command panel. The shortcut is *Cmd* + *Shift* + *P* on macOS X and
    *Ctrl* + *Shift* + *P* on Windows. Type `Disable JavaScript`, select the option,
    and hit *Enter*. You should see the message that follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将禁用JavaScript以模拟解析JavaScript需要很长时间。或者，模拟尚未放置App Shell。打开Chrome DevTools并打开命令面板。在macOS
    X上的快捷键是*Cmd* + *Shift* + *P*，在Windows上是*Ctrl* + *Shift* + *P*。输入`Disable JavaScript`，选择该选项，然后按*Enter*。您应该看到以下消息：
- en: '![Figure 13.26 – No App Shell present in the app'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.26 - 应用程序中没有App Shell'
- en: '](image/Figure_13.26_B15150.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.26_B15150.jpg)'
- en: Figure 13.26 – No App Shell present in the app
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26 - 应用程序中没有App Shell
- en: Now that we have checked the absence of the App Shell, let's see the steps of
    the recipe in the next section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了App Shell的缺失，让我们在下一节中看到该配方的步骤。
- en: How to do it
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We have an Angular application that fetches some users from an API. We will
    create an App shell for this app so it can provide the first meaningful paint
    faster as a PWA. Let''s get started:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个从API获取一些用户的Angular应用程序。我们将为此应用程序创建一个App Shell，以便作为PWA更快地提供第一个有意义的绘制。让我们开始吧：
- en: 'First, create the App Shell for the app by running the following command from
    the project root:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过从项目根目录运行以下命令为应用程序创建App Shell：
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Update `app.module.ts` to export the components so we can use them to render
    the **Users** page in the App Shell. The code should look as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app.module.ts`以导出组件，以便我们可以使用它们在App Shell中呈现**Users**页面。代码应如下所示：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now open the `app-shell.component.html` file and use the `<app-users>` element
    so we render the whole `UsersComponent` in the App Shell. The code should look
    as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`app-shell.component.html`文件，并使用`<app-users>`元素，以便在App Shell中呈现整个`UsersComponent`。代码应如下所示：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have the code written for the App Shell. Let''s create it. Run
    the following command to generate the App Shell in development mode:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为App Shell编写了代码。让我们创建它。运行以下命令以在开发模式下生成App Shell：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the App Shell is generated in *Step 4*, run the following command to serve
    it using the `http-server` package:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在*步骤4*中生成了App Shell，请运行以下命令使用`http-server`包来提供它：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Make sure that the JavaScript is still turned off for the app. If not, open
    Chrome DevTools and press *Cmd* + *Shift* + *P* for macOS X to open the Command
    Panel (*Ctrl* + *Shift* + *P* on Windows). Then type `Disable Javascript` and
    hit *Enter* selecting the option as shown in *Figure 13.27*:![Figure 13.27 – Disable
    JavaScript using Chrome DevTools
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序的JavaScript仍然关闭。如果没有，请打开Chrome DevTools，按下macOS X上的*Cmd* + *Shift* + *P*以打开命令面板（Windows上的*Ctrl*
    + *Shift* + *P*）。然后输入`Disable Javascript`，按*Enter*选择如*图13.27*所示的选项：![图13.27 -
    使用Chrome DevTools禁用JavaScript
- en: '](image/Figure_13.27_B15150.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.27_B15150.jpg)'
- en: Figure 13.27 – Disable JavaScript using Chrome DevTools
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 - 使用Chrome DevTools禁用JavaScript
- en: Refresh the app while JavaScript is disabled. You should now see the app still
    showing the pre-rendered users page, despite JavaScript being disabled as shown
    in *Figure 13.28*. Woohoo!![Figure 13.28 – App Shell showing the pre-rendered
    Users page
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在禁用JavaScript的情况下刷新应用程序。现在，尽管JavaScript被禁用，您应该看到应用程序仍然显示了预渲染的用户页面，如*图13.28*所示。哇哦！![图13.28
    - App Shell显示了预渲染的用户页面
- en: '](image/Figure_13.28_B15150.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.28_B15150.jpg)'
- en: Figure 13.28 – App Shell showing the pre-rendered Users page
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 - App Shell显示了预渲染的用户页面
- en: To verify that we are pre-rendering the users page at build time, inspect the
    generated code at `<project-root>/dist/pwa-app-shell/browser.index.html`. You
    should see the entire rendered page inside the `<body>` tag as shown in *Figure
    13.29*:![Figure 13.29 – index.html file containing the pre-rendered Users page
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证我们是否在构建时预渲染了用户页面，请检查`<project-root>/dist/pwa-app-shell/browser.index.html`中生成的代码。您应该在`<body>`标签内看到整个渲染的页面，如*图13.29*所示：![图13.29
    - 包含预渲染用户页面的index.html文件
- en: '](image/Figure_13.29_B15150.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.29_B15150.jpg)'
- en: Figure 13.29 – index.html file containing the pre-rendered Users page
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.29 - 包含预渲染用户页面的index.html文件
- en: 'Create the production build with the App Shell and serve it on port `1020`
    by running the following commands:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建带有App Shell的生产构建，并在端口`1020`上提供服务：
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Navigate to `http://localhost:1020` in your browser and install the app as
    a PWA as shown in *Figure 13.8*. Once done, run the PWA and it should look as
    follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到`http://localhost:1020`，并按照*图13.8*所示安装应用程序作为PWA。完成后，运行PWA，它应该如下所示：
- en: '![Figure 13.30 – pwa-app-shell running as a native app after installation'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.30 - 安装后作为本机应用程序运行的pwa-app-shell'
- en: '](image/Figure_13.30_B15150.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_13.30_B15150.jpg)'
- en: Figure 13.30 – pwa-app-shell running as a native app after installation
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.30 - 安装后作为本机应用程序运行的pwa-app-shell
- en: Great!!! You now know how to create an App Shell for your Angular PWAs. Now
    that you've finished the recipe, see the next section on how it works.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何为你的Angular PWA创建一个App Shell。现在您已经完成了这个食谱，请查看下一节关于它是如何工作的。
- en: How it works
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The recipe begins with disabling JavaScript for our application. This means
    when the app runs, we only show static HTML and CSS since there's no JavaScript
    execution. We see a message about JavaScript not being supported, as shown in
    *Figure 13.26*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱始于为我们的应用程序禁用JavaScript。这意味着当应用程序运行时，我们只显示静态的HTML和CSS，因为没有JavaScript执行。我们看到一个关于不支持JavaScript的消息，如*图13.26*所示。
- en: 'We then run the `ng generate app-shell` command. This Angular CLI command does
    the following things for us:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行`ng generate app-shell`命令。这个Angular CLI命令为我们做了以下几件事情：
- en: Creates a new component named `AppShellComponent` and generates its relevant
    files.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`AppShellComponent`的新组件，并生成其相关文件。
- en: Installs the `@angular/platform-server` package in the project.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目中安装了`@angular/platform-server`包。
- en: Updates the `app.module.ts` file to use the `BrowserModule.withServerTransition()`
    method so we can provide the `appId` property for server-side rendering.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`app.module.ts`文件以使用`BrowserModule.withServerTransition()`方法，这样我们就可以为服务器端渲染提供`appId`属性。
- en: Adds some new files, namely `main.server.ts` and `app.server.module.ts`, to
    enable server-side rendering (build time rendering for our App Shell, to be exact).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一些新文件，即`main.server.ts`和`app.server.module.ts`，以启用服务器端渲染（确切地说是我们的App Shell的构建时渲染）。
- en: Most importantly, it updates the `angular.json` file to add a bunch of schematics
    for server-side rendering as well as for generating the `app-shell`.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，它更新了`angular.json`文件，添加了一堆用于服务器端渲染的原理图，以及用于生成`app-shell`的原理图。
- en: In the recipe, we export the components from `AppModule` so we can use them
    in the App Shell. This is because the App Shell is not part of the `AppModule`.
    Instead, it is part of the newly created `AppServerModule` in the `app.server.module.ts`
    file. As you can see, in the file, we have `AppModule` already being imported.
    Although, we can't use the components unless we export them from `AppModule`.
    After exporting the components, we update the `app-shell.component.html` (the
    App Shell template) to use the `<app-users>` selector, which reflects the `UsersComponent`
    class. That is the entire Users page.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们从`AppModule`中导出组件，这样我们就可以在应用外壳中使用它们。这是因为应用外壳不是`AppModule`的一部分。相反，它是在`app.server.module.ts`文件中新创建的`AppServerModule`的一部分。正如您所看到的，在这个文件中，我们已经导入了`AppModule`。尽管如此，除非我们从`AppModule`中导出它们，否则我们无法使用这些组件。在导出组件之后，我们更新了`app-shell.component.html`（应用外壳模板），以使用`<app-users>`选择器，这反映了`UsersComponent`类。这就是整个用户页面。
- en: We verify the App Shell by running the `ng run pwa-app-shell:app-shell` command.
    This command generates an Angular build in development mode with the App Shell
    (non-minified code). Note that in a usual build, we would generate the `pwa-app-shell`
    folder inside the `dist` folder. And inside, we would have `index.html`. However,
    in this case, we create two folders inside the `pwa-app-shell` folder, that is,
    the `browser` folder and the `server` folder. And our `index.html` resides in
    the `browser` folder. As shown in *Figure 13.29*, we have the code of the entire
    Users page inside the `<body>` tag in the `index.html` file. This code is pre-rendered
    at build time. This means Angular opens up the app, makes the network call, and
    then pre-renders the UI as the App Shell at build time. So as soon as the app
    opens, the content is pre-rendered.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行`ng run pwa-app-shell:app-shell`命令来验证应用外壳。这个命令会生成一个带有应用外壳（非最小化代码）的开发模式下的Angular构建。请注意，在通常的构建中，我们会在`dist`文件夹内生成`pwa-app-shell`文件夹。在这个文件夹内，我们会有`index.html`。然而，在这种情况下，我们在`pwa-app-shell`文件夹内创建了两个文件夹，即`browser`文件夹和`server`文件夹。我们的`index.html`位于`browser`文件夹内。如*图13.29*所示，我们在`index.html`文件的`<body>`标签内有整个用户页面的代码。这段代码是在构建时预渲染的。这意味着Angular打开应用程序，进行网络调用，然后在构建时将UI预渲染为应用外壳。因此，一旦应用程序打开，内容就会被预渲染。
- en: To generate the production build with the App Shell, we run the `ng run pwa-app-shell:app-shell:production`
    command. This generates the production Angular build with minified code for the
    App Shell as well. And finally, we install the PWA to test it out.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成带有应用外壳的生产构建，我们运行`ng run pwa-app-shell:app-shell:production`命令。这将生成带有应用外壳的生产Angular构建，并进行了最小化处理。最后，我们安装PWA进行测试。
- en: Now that you know how the recipe works, see the next section for links for further
    reading.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了这个食谱是如何工作的，请查看下一节以获取进一步阅读的链接。
- en: See also
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Angular App Shell Guide (https://angular.io/guide/app-shell)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular应用外壳指南（https://angular.io/guide/app-shell）
- en: The App Shell Model (Web Fundamentals by Google) (https://developers.google.com/web/fundamentals/architecture/app-shell)
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用外壳模型（Google的Web基础知识）（https://developers.google.com/web/fundamentals/architecture/app-shell）
