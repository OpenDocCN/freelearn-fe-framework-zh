<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Component-Based User Interfaces" id="aid-DB7S1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Component-Based User Interfaces</h1></div></div></div><p>Although we'll cover a lot of Angular-related topics in this book, the focus will be mainly on creating component-based user interfaces. It's one thing to understand a framework, such as Angular 2, but it's a whole different thing to establish an effective workflow using a component-based architecture. In this book, I'll try to explain the core concepts behind Angular 2 components and how we can leverage this architecture to create modern, efficient, and maintainable user interfaces.</p><p>Besides learning all the necessary concepts behind Angular 2, we will together create a task-management application from scratch. This will allow us to explore different approaches to solve common UI problems using the component system that is provided by Angular 2.</p><div class="mediaobject"><img src="../Images/image00298.jpeg" alt="Component-Based User Interfaces"/><div class="caption"><p>A preview of the task management application that we are going to build</p></div></div><p style="clear:both; height: 1em;"> </p><p>In this chapter, we will take a look at how component-based user interfaces help us build greater applications. Over the course of this book, we will build an Angular 2 application together, where we will use the component-based approach to its full potential. This chapter will also introduce you to the technologies that are used in this book. The topics that we will cover in this chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">An introduction to component-based user interfaces</li><li class="listitem">Encapsulation and composition using component-based user interfaces</li><li class="listitem">Evolution of UI frameworks</li><li class="listitem">The standard and Web components</li><li class="listitem">An introduction to the Angular 2 component system</li><li class="listitem">Writing your first Angular 2 component</li><li class="listitem">An overview and history of ECMAScript and TypeScript</li><li class="listitem">ECMAScript 7 decorators as meta annotations</li><li class="listitem">An introduction to Node.js-based tooling using JSPM and SystemJS</li></ul></div><div class="section" title="Thinking of organisms"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Thinking of organisms</h1></div></div></div><p>Today's user interfaces do not consist of just a bunch of form elements that are cobbled together onto a screen. Modern users experience design and innovative visual presentations <a id="id0" class="indexterm"/>of interactive content challenges technology more than ever.</p><p>Sadly, we almost always tend to think in pages when we flesh out concepts for web applications, such as the pages within a printed book. Well, this is probably the most efficient way to convey information for this kind of content and medium. You can skim through the pages one by one without any real physical effort, read paragraph by paragraph, and just scan through the chapters that you don't find interesting.</p><p>The problem with thinking in pages too much is that this concept, which is borrowed from books, does not really translate well to how things work in the real world. The world is created from organisms that form a system of organisms together. This system itself forms an organism again, just on a higher level.</p><p>Take our bodies as an example. We mostly consist of independent organs that interact with each other using electrical and chemical signals. Organs themselves consist of proteins that on their own work like a machine to form a system. Down to the molecules, atoms, protons, and quarks, we can't really tell where one starts and where it ends. What we can tell for sure is that it's all about systems of organisms with interdependencies, and it is not about pages.</p><p>I like to view user interfaces as systems of organisms. Whether if, where, and how they are distributed to pages is subordinate while designing them. Also, they should work independently, and <a id="id1" class="indexterm"/>they should interact with each other on an interdependent level.</p></div></div>
<div class="section" title="Components &#x2013; The organs of user interfaces"><div class="titlepage" id="aid-E9OE2"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Components – The organs of user interfaces</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"We're not designing pages, we're designing systems of components."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Stephen Hay</em></span></span></td></tr></table></div><p>This quote by<a id="id2" class="indexterm"/> Stephen Hay from BDConf in Orlando 2012 brings it to the point. Interface design is really not about pages. To create efficient user interfaces for not only the users but also the developers who maintain them, we need to think in systems of components. Components are independent, but they can interact with each other and create larger components when they are arranged together. We need to look at user interfaces holistically and using components enables us to do this.</p><p>In the following topics, we're going to explore a few fundamental aspects of components. Some of these<a id="id3" class="indexterm"/> are already known from other concepts, such as <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>), but they appear in a slightly different light when thinking about components.</p><div class="section" title="Encapsulation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Encapsulation</h2></div></div></div><p>Encapsulation<a id="id4" class="indexterm"/> is a very important factor when thinking<a id="id5" class="indexterm"/> about maintenance in a system. Having a classical OOP background, I've learned that encapsulation means bundling logic and data together into an isolated container. This way, we can operate on the container from the outside and treat it like a closed system.</p><p>There are many positive aspects of this approach when it comes to maintainability and accessibility. Dealing with closed systems is important for the organization of our code. However, this is even more importantly because we can organize ourselves while working with code.</p><div class="mediaobject"><img src="../Images/image00299.jpeg" alt="Encapsulation"/></div><p style="clear:both; height: 1em;"> </p><p>I have a <a id="id6" class="indexterm"/>pretty bad memory, and it's very important<a id="id7" class="indexterm"/> for me to find the right focus level when working on code. Immediate memory research told us that the human brain can remember about seven items at once on an average. Therefore, it's crucial for us to write code in such a way that it allows us to focus on fewer and smaller pieces at once.</p><p>A clear encapsulation helps us in organizing our code. We can maybe forget all the internals of the closed system and about the kind of logic and data that we've put into it. We can focus only on its surface, which allows us to work on a higher-abstraction level. Similar to the previous figure, without using a hierarchy of encapsulated components, we'd have all our code cobbled together on the same level.</p><p>Encapsulation encourages us to isolate small and concise components and build a system of components. During development, we can focus on the internals of one component and only deal with the interface of other components.</p><p>Sometimes, we forget that all the organization of the coding we actually perform is for ourselves and not for the computer that runs this code. If this was for the computer, then we would probably all start writing in machine language again. A strong encapsulation helps us access specific code easily, focus on one layer of the code, and trust the underlying implementations within capsules.</p><p>The following JavaScript example shows you how to use encapsulation to write maintainable applications. Let's assume that we are in a T-shirt factory, and we need some code to produce T-shirts with a background and foreground color. This example uses some new language features of ECMAScript 6. If you're not familiar with the language features of ECMAScript 6, don't worry too much at this point. We will learn about these later in this chapter:</p><div class="informalexample"><pre class="programlisting">// This class implements data and logic to represent a colour
// which establishes clean encapsulation.
class Colour {
  constructor(red, green, blue) {
    Object.assign(this, {red, green, blue});
  }
  
  // Using this function we can convert the internal colour values
  // to a hex colour string like #ff0000 (red).
  getHex() {
    return '#' + Colour.getHexValue(this.red) + Colour.getHexValue(this.green) +
      Colour.getHexValue(this.blue);
  }
  
  // Static function on Colour class to convert a number from
  // 0 to 255 to a hexadecimal representation 00 to ff
  static getHexValue(number) {
    const hex = number.toString(16);
    return hex.length === 2 ? hex : '0' + hex;
  }
}

// Our TShirt class expects two colours to be passed during
// construction that will be used to render some HTML
class TShirt {
  constructor(backgroundColour, foregroundColour) {
    Object.assign(this, {backgroundColour, foregroundColour});
  }
  
  // Function that returns some markup which represents our 
  // T-Shirts
  getHtml() {
    return `
      &lt;t-shirt style="background-color: ${this.backgroundColour.getHex()}"&gt;
        &lt;t-shirt-text style="color: ${this.foregroundColour.getHex()}"&gt;
          Awesome Shirt!
        &lt;/t-shirt-text&gt;
      &lt;/t-shirt&gt;
    `;
  }
}

// Instantiate a blue colour
const blue = new Colour(0, 0, 255);
// Instantiate a red colour
const red = new Colour(255, 0, 0);
// Create a new shirt using the above colours
const awesomeShirt = new TShirt(blue, red);
// Adding the generated markup of our shirt to our document
document.body.innerHTML = awesomeShirt.getHtml();</pre></div><p>Using a<a id="id8" class="indexterm"/> clean encapsulation, we can now work with<a id="id9" class="indexterm"/> the abstraction of color in our T-shirt. We don't need to worry about how to calculate the hexadecimal representation of colors at the T-shirt level because this is already done by the <code class="literal">Colour</code> class. This makes your application maintainable and keeps it very open for change.</p><p>I really recommend that you read about the SOLID principles if you haven't done so already. As the name already suggests, this assembly of principles is a solid power tool that can change the way you organize code tremendously. You can learn more about the SOLID principles in the book, <span class="emphasis"><em>Agile Principles, Patterns</em></span>,<span class="emphasis"><em> and Practices,</em></span> by Robert C. Martin.</p></div><div class="section" title="Composability"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Composability</h2></div></div></div><p>Composition is a special kind of reusability. You don't extend an existing component, but you create a new larger component by composing many smaller components together into a system<a id="id10" class="indexterm"/> of components.</p><p>In OOP languages, composition is often used to get around the multiple inheritance issues that most<a id="id11" class="indexterm"/> OOP languages have. Subclass polymorphism is always great until you reach the point where your design does not match the latest requirements in your project. Let's look at a simple example that illustrates this problem.</p><p>You have a <code class="literal">Fisher</code> class and a <code class="literal">Developer</code> class, both of which hold specific behaviors. Now, you'd want to create a <code class="literal">FishingDeveloper</code> class that inherits both from <code class="literal">Fisher</code> and <code class="literal">Developer</code>. Unless you're using a language that supports multiple inheritance (such as C++ does to a certain extent), you will not be able to reuse this functionality using inheritance. There is no way to tell the language that your new class should inherit from both super classes. Using composition, you can easily solve this problem. Instead of using inheritance, you're composing a new <code class="literal">FishingDeveloper</code> class that delegates all behavior to an internal <code class="literal">Developer</code> and <code class="literal">Fisher</code> instance:</p><div class="informalexample"><pre class="programlisting">class Developer {
  code() {
    console.log(`${this.name} writes some code!`);
  }
}

class Fisher {
  fish() {
    console.log(`${this.name} catches a big fish!`);
  }
}

class FishingDeveloper {
  constructor(name) {
    this.name = name;
    this.developerStuff = new Developer();
    this.fisherStuff = new Fisher();
  }
  
  code() {
    this.developerStuff.code.bind(this)();
  }
  
  fish() {
    this.fisherStuff.fish.bind(this)();
  }
}

var bob = new FishingDeveloper('Bob');
bob.code();
bob.fish();</pre></div><p>Experience <a id="id12" class="indexterm"/>has taught us that composition is <a id="id13" class="indexterm"/>probably the most efficient way to reuse code. In contrast to inheritance, decoration, and other approaches to gain reusability, composition is probably the least intrusive and the most flexible.</p><p>Recent versions of some languages also support a pattern called traits, that is, <code class="literal">mixins</code>. Traits allow you to reuse certain functionality and attributes from other classes in a way that is similar to multiple inheritance.</p><p>If we think about the concept of composition, it's nothing more than designing organisms. We have the two <code class="literal">Developer</code> and <code class="literal">Fisher</code> organisms, and we unify their behaviors into a single <code class="literal">FishingDeveloper</code> organism.</p></div><div class="section" title="Components, invented by nature"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Components, invented by nature</h2></div></div></div><p>Components, embracing encapsulation, and composition are an effective way to build maintainable <a id="id14" class="indexterm"/>applications. Composed from components, applications are very resistant to the negative implications of change, and change is a necessary thing that will happen to every application. It's only a matter of time until your design will be challenged by the effects of change; therefore, it's very important to write code that can handle change as smoothly as possible.</p><p>Nature is the<a id="id15" class="indexterm"/> best teacher. Almost all the achievements in technological developments have their origin in observations of how nature solves problems. If we look at evolution, it's an ongoing redesign of matter by adapting to outer forces and constraints. Nature solves this by constant change using mutation and natural selection.</p><p>If we project the concept of evolution onto developing an application, we can say that nature does actually refactor its code in every single moment. This is actually the dream of every product manager—an application that can undergo constant change but does not lose any of its efficiency.</p><p>I believe that there are two key concepts that play a major role in nature that allows it to apply constant change in its design without losing much efficiency. This uses encapsulation and composition. Coming back to the example of our bodies, we can actually tell that our organs use a very clear encapsulation. They use membranes to create isolation, veins to transport nutrition, and synapses to send messages. Also, they have interdependencies, and they communicate with electrical and chemical messages. Most obviously, they form larger systems, which is the core concept of composition.</p><p>Of course, there are many other factors, and I'm not a professor in biology. However, I think it's a fascinating thing to see that we have learned to organize our code very similarly to how nature organizes matter.</p><p>The idea of creating reusable UI components is quite old, and it was implemented in various languages and frameworks. One of the earliest systems that used UI components was probably the Xerox Alto system back in 1970s. It used reusable UI components that allowed developers to create an application by composing them on a screen where users could interact with them.</p><div class="mediaobject"><img src="../Images/image00300.jpeg" alt="Components, invented by nature"/><div class="caption"><p>The user interface of file manager on the Xerox Alto system from the 1970s.</p></div></div><p style="clear:both; height: 1em;"> </p><p>Early frontend UI frameworks, such as DHTMLX, Ext JS, or jQuery UI implemented components<a id="id16" class="indexterm"/> in a more limited fashion that didn't provide great flexibility or extensibility. Most of these frameworks just provided widget libraries. The problem with UI widgets is that they mostly don't embrace the pattern of composition enough. You can arrange widgets on a page and they provide encapsulation, but with most toolkits, you can't create larger components by nesting them inside each other. Some toolkits solve this by providing a special kind of widget which was mostly called a <a id="id17" class="indexterm"/>container. However, this is not the same as a full-fledged component tree that allows you to create systems within systems. Containers were actually meant to provide a visual layout container rather than a composite container to form a larger system.</p><p>Usually when working with widgets on a page of our application, we'd have a large controller that controls all these widgets, user input, and states. However, we are left with two levels of composition, and there's no way that we can structure our code more granularly. There is the page and there are the widgets. Having a bunch of UI widgets is simply not enough, and we are almost back to the state where we create pages plastered with form elements.</p><p>I've been a user of JavaServer Faces for years, and besides all its problems, the concept of having reusable custom elements was groundbreaking. Using XHTML, one could write so-called <a id="id18" class="indexterm"/>composite components that consisted of other composite components or native HTML elements. A developer could gain a fantastic level of reusability using composition. The big issue in my view with this technology was that it did not address the concerns in the frontend enough to become really usable for complex user interactions. In fact, a framework like this should live completely within the frontend.</p><div class="section" title="My UI framework wishlist"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>My UI framework wishlist</h3></div></div></div><p>Usually when UI frameworks get compared, they get measured against each other based on metrics, such as widget count, theming capabilities, and asynchronous data retrieval features. Every framework has its strengths and weaknesses, but leaving all the extra features aside and reducing it to the core concerns of a UI framework, I only have a few metrics left that I'd like to be assessed. These metrics are, of course, not the only ones that are important in today's UI development, but they also are the main factors toward building a clean <a id="id19" class="indexterm"/>architecture that supports the principle of change:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">I can create encapsulated components with clear interfaces</li><li class="listitem">I can create larger components by composition</li><li class="listitem">I can make components interact with each other within their hierarchy</li></ul></div><p>If you're looking for a framework which enables you to take full advantage of component-based UI development, you should look for these three key measures.</p><p>First of all, I think it's very important to understand the main purpose of the web and how it evolved. If we think of the web in its early days in the 1990s, it was probably only about hypertext. There were very basic semantics that could be used to structure information and display them to a user. HTML was created to hold structure and information. The need for custom visual presentation of information led to the development of CSS right after HTML started being widely used.</p><p>It was in the mid 1990s when Brendan Eich invented JavaScript, and it was first implemented in Netscape Navigator. By providing a way to implement behavior and state, JavaScript was the last missing piece for a full web customization:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Technology</p>
</th><th valign="bottom">
<p>Concern</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>HTML</p>
</td><td valign="top">
<p>Structure and information</p>
</td></tr><tr><td valign="top">
<p>CSS</p>
</td><td valign="top">
<p>Presentation</p>
</td></tr><tr><td valign="top">
<p>JavaScript</p>
</td><td valign="top">
<p>Behavior and state</p>
</td></tr></tbody></table></div><p>We have learned to keep these concerns as separate as possible in order to maintain a clean architecture. Although there are different opinions on this and some recent technologies also move away from this principle, I believe that a clean separation of these concerns is very important to create a maintainable application.</p><p>Leaving this view<a id="id20" class="indexterm"/> aside, the standard definition of encapsulation from OOP is just concerned about coupling and isolation of logic and data. This probably applies well to classic software components. However, as soon as we consider a user interface as part of an architecture, there is a new dimension that is added.</p><p>Classical MVC frameworks are view centric, and developers organize their code based on pages. You'll probably go ahead and create a new view that represents a page. Of course, your view needs a controller and model, so you'll also create them. The problem with organization by pages is that there's little to no gain of reusability. Once you've created a page and you'd like to reuse only some parts of the page, you will need a way to encapsulate only a specific part of this model—the view and the controller.</p><p>UI components solve this problem nicely. I like to see them as a modular approach to MVC. Although they still embrace the MVC pattern, they also establish encapsulation and composability. This way a view is a component itself, but it also consists of components. By composing views of components, one can gain a maximum amount of reusability:</p><div class="mediaobject"><img src="../Images/image00301.jpeg" alt="My UI framework wishlist"/><div class="caption"><p>UI components embrace MVC, but they also support encapsulation and composition on a much lower level</p></div></div><p style="clear:both; height: 1em;"> </p><p>Technically, there are some challenges when implementing components with web technologies. JavaScript was always flexible enough to implement different patterns and paradigms. Working with encapsulation and composition isn't an issue at all, and the controlling part and the model of components can easily be implemented. Approaches, such as the revealing module pattern, namespaces, prototypes, or the recent ECMAScript 6 modules, provide all the tools that are needed from the JavaScript side.</p><p>However, for the <a id="id21" class="indexterm"/>view part of our components, we face some limitations. Although HTML supports great flexibility in terms of composability because the DOM tree is nothing else than a big composition, we have no way to reuse these compositions. We can only create one large composition, which is the page itself. HTML being only the final view that was delivered from the server, this was never really a real concern. Today's applications are much more demanding, and we need to have a fully-encapsulated component running in the browser, which also consists of a partial view.</p><p>We face the same problem with CSS. There is no real modularization and encapsulation while writing CSS, and we need to use namespaces and prefixes in order to segregate our CSS styles. Still, the whole cascading nature of CSS can easily destroy all encapsulation that we try to bring in place using CSS-structuring patterns.</p></div></div><div class="section" title="Time for new standards"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Time for new standards</h2></div></div></div><p>Web standards have been evolving immensely in the last couple of years. There are so many new standards, and the browser became such a big multimedia framework, that it's hard for other<a id="id22" class="indexterm"/> platforms to compete with this.</p><p>I'd even go as far as to say that web technology will actually replace other frameworks in the future, and it probably will be renamed to multimedia technology or something similar. There's no reason why we need to use different native frameworks to create user interfaces and presentations. Web technologies embed so many features that it's hard to find a reason not to use them for any kind of application. Just look at the Firefox OS or the Chrome OS, which are designed to run with web technologies. I think it's only a matter of time until more operating systems and embedded devices make use of web technologies to implement their software. This is why I believe that at some point it will be questionable whether the term <span class="emphasis"><em>web technologies</em></span> is still appropriate or whether we should replace it with a more general term.</p><p>Although we usually just see new features appear in browsers, there is a very open and long-winded standardization process behind them. It's very important to standardize features, but this takes a lot of time, especially when people disagree about different approaches to solving problems.</p><p>Coming back to the concept of components, this is something where we really need support from web standards to break the current limitations. Fortunately, the W3C thought the same, and a group of developers started to work on specifications under the hood of an umbrella specification called <span class="emphasis"><em>web components</em></span>.</p><p>The following <a id="id23" class="indexterm"/>topics will give you a brief overview over two specifications that also play a role in Angular 2 components. One of Angular 2's core strengths is that it acts more like a superset of web standards rather than being a complete isolated framework.</p><div class="section" title="Template elements"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Template elements</h3></div></div></div><p>Template elements<a id="id24" class="indexterm"/> allow you to define regions <a id="id25" class="indexterm"/>within your HTML, which will not be rendered by the browser. You can then instantiate these document fragments with JavaScript and then place the resulting DOM within your document.</p><p>While the browser is actually parsing the template content, it only does so in order to validate the HTML. Any immediate actions that the parser would usually execute will not be taken. Within the content of template elements, images will not be loaded and scripts won't be executed. Only after a template is instantiated, the parser will take the necessary actions, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
<span class="strong"><strong>&lt;template id="template"&gt;</strong></span>
<span class="strong"><strong>  &lt;h1&gt;This is a template!&lt;/h1&gt;</strong></span>
<span class="strong"><strong>&lt;/template&gt;</strong></span>
&lt;/body&gt;</pre></div><p>This simple HTML example of a template element won't display the heading on your page. As the heading is inside a template element, we first need to instantiate the template and add the resulting DOM into our document:</p><div class="informalexample"><pre class="programlisting">var template = document.querySelector('#template');
var instance = document.importNode(template.content, true);
document.body.appendChild(instance);</pre></div><p>Using these three lines of JavaScript, we can instantiate the template and append it into our document.</p></div><div class="section" title="Shadow DOM"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Shadow DOM</h3></div></div></div><p>This part of the <a id="id26" class="indexterm"/>web components specification was the <a id="id27" class="indexterm"/>missing piece to create proper DOM encapsulation and composition. With shadow DOM, we can create isolated parts of the DOM that are protected against regular DOM operations from the outside. Also, CSS will not reach into shadow DOM automatically, and we can create local CSS within our component.</p><div class="note" title="Note"><h3 class="title"><a id="tip02"/>Tip</h3><p>If you add a <code class="literal">style</code> tag inside shadow DOM, the styles are scoped to the root within the shadow DOM, and they will not leak outside. This enables a very strong encapsulation for CSS.</p></div><p>Content insertion <a id="id28" class="indexterm"/>points make it easy to control content<a id="id29" class="indexterm"/> from the outside of a shadow DOM component, and it provides some kind of an interface to pass in content.</p><p>At the time of writing this book, shadow DOM is supported by most browsers although it still needs to be enabled in Firefox.</p></div></div></div>
<div class="section" title="Angular's component architecture" id="aid-F8901"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Angular's component architecture</h1></div></div></div><p>For me, the concept of directives from the first version of Angular changed the game in frontend UI frameworks. This was the first time that I felt that there was a simple yet powerful concept that allowed the creation of reusable UI components. Directives could communicate with<a id="id30" class="indexterm"/> DOM events or messaging services. They <a id="id31" class="indexterm"/>allowed you to follow the principle of composition, and you could nest directives and create larger directives that solely consisted of smaller directives arranged together. Actually, directives were a very nice implementation of components for the browser.</p><p>In this section, we'll look into the component-based architecture of Angular 2 and how the things we've learned about components will fit into Angular.</p><div class="section" title="Everything is a component"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Everything is a component</h2></div></div></div><p>As an early<a id="id32" class="indexterm"/> adopter of Angular 2 and while talking to other people about it, I got frequently asked what the biggest difference is to the first version. My answer to this question was always the same. Everything is a component.</p><div class="mediaobject"><img src="../Images/image00302.jpeg" alt="Everything is a component"/></div><p style="clear:both; height: 1em;"> </p><p>For me, this paradigm<a id="id33" class="indexterm"/> shift was the most relevant change that both simplified and enriched the framework. Of course, there are a lot of other changes with Angular 2. However, as an advocate of component-based user interfaces, I've found that this change is the most interesting one. Of course, this change also came with a lot of architectural changes.</p><p>Angular 2 supports the idea of looking at the user interface holistically and supporting composition with components. However, the biggest difference to its first version is that now your pages are no longer global views, but they are simply components that are assembled from other components. If you've been following this chapter, you'll notice that this is exactly what a holistic approach to user interfaces demands. No more pages but systems of components.</p><div class="note" title="Note"><h3 class="title"><a id="tip03"/>Tip</h3><p>Angular 2 still uses the concept of directives, although directives are now really what the name suggests. They are orders for the browser to attach a given behavior to an element. Components are a special kind of directives that come with a view.</p></div></div></div>
<div class="section" title="Your first component"><div class="titlepage" id="aid-G6PI2"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Your first component</h1></div></div></div><p>Keeping up the tradition, before we start building a real application together, we should write our <a id="id34" class="indexterm"/>first <code class="literal">hello world</code> component with Angular:</p><div class="informalexample"><pre class="programlisting">// Decorators allow us to separate declarative logic from our
// component implementation logic.
@Component({
  selector: 'hello-world',
  template: '&lt;div&gt;Hello {{name}}&lt;/div&gt;'
})
class HelloWorld {
  constructor() {
    this.name = 'World';
  }
}</pre></div><p>This is already a fully-working Angular 2 application. We used ECMAScript 6 classes to create the necessary encapsulation required for a component. You can also see a meta-annotation that is used to declaratively configure our component. This statement, which looks like a function call that is prefixed with an <span class="emphasis"><em>at</em></span> symbol actually comes from the ECMAScript 7 decorator proposal.</p><div class="note" title="Note"><h3 class="title"><a id="note02"/>Note</h3><p>ECMAScript 7 decorators are still very experimental at the time of writing this book. For the code in this book, we actually use the TypeScript transpiler version 1.5 that already implements decorators with a slight twist to the original specification. TypeScript 1.5 is also used by the Angular 2 team to develop the core of Angular.</p></div><p>It's important to understand that an element can only be bound to one single component. As a component always comes with a view, there is no way that we can bind more than one component to an element. On the other hand, an element can be bound to many directives, as directives don't come with a view but they only attach behavior.</p><p>In the <code class="literal">Component</code> decorator, we need to configure everything that is relevant to describe our component for Angular. This, of course, also includes our template for the view. In the preceding example, we are specifying our template directly within JavaScript as a string. We can also use the <code class="literal">templateUrl</code> property to specify a URL where the template should be loaded from.</p><p>Now, let's enhance our example a little bit so that we can see how we can compose our application from smaller components:</p><div class="informalexample"><pre class="programlisting">// Using decorators we can declaratively define our component used
// to write bold text
@Component({
  selector: 'shout-out',
  template: '&lt;strong&gt;{{words}}&lt;/strong&gt;'
})
class ShoutOut {
  @Input() words;
}

// This component will be our main application component that
// makes use of the above shout-out component (composition)
@Component({
  selector: 'hello-world'
  template: '&lt;shout-out words="Hello, {{name}}!"&gt;&lt;/shout-out&gt;',
  directives: [ShoutOut]
})
class HelloWorld {
  constructor() {
    this.name = 'World';
  }
}</pre></div><p>You can see that <a id="id35" class="indexterm"/>we have now created a small component that allows us to shout out words as we like. In our <span class="emphasis"><em>Hello World</em></span> application, we make use of this component to shout out <span class="strong"><strong>Hello, World!</strong></span></p><div class="note" title="Note"><h3 class="title"><a id="tip04"/>Tip</h3><p>Every directive or component that is used inside a components view template needs to be explicitly declared in the directives property of the view annotation. Otherwise, the compiler will not recognize the directive when it encounters the element in the template.</p></div><p>Over the course of this book and while writing our task management application, we will learn a lot more about the configuration and implementation of components. However, before we start with this in the second chapter, we should take a look at some tools and language features that we'll use during this book.</p><div class="section" title="JavaScript of the future"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>JavaScript of the future</h2></div></div></div><p>It was not<a id="id36" class="indexterm"/> so long ago that somebody asked <a id="id37" class="indexterm"/>me whether we should really use the bind function of ECMAScript 5.1, as then we'd probably run into browser compatibility issues. The web moves very fast, and we need to keep up the pace. We can't write code that does not use the latest features even if this would cause issues in old browsers.</p><p>The fantastic people from TC39, the technical committee that is responsible for writing the ECMAScript specification, have done a great job progressively enhancing the JavaScript language. This, and the fact that JavaScript is so flexible, allows us to use so-called polyfills and shims to make our code run in older browsers.</p><p>ECMAScript 6 (also referred to as ECMAScript 2015) was published in June 2015, exactly four years <a id="id38" class="indexterm"/>after its predecessor. There is a massive <a id="id39" class="indexterm"/>amount of new API additions as well as a whole bunch of new language features. The language features are syntactic sugar, and ECMAScript 6<a id="id40" class="indexterm"/> can be transpiled to its previous version where it runs<a id="id41" class="indexterm"/> perfectly in older browsers. At the time of writing this book, none of the current browser versions have fully implemented ECMAScript 6, but there's absolutely no reason not to use it for production applications.</p><div class="note" title="Note"><h3 class="title"><a id="tip05"/>Tip</h3><p>Syntactic sugar is a design approach where we evolve a programming language while not breaking backwards compatibility. This allows language designers to come up with new syntax, which enriches developer experience but does not break the web. Every new feature needs to be translatable to the old syntax. This way, so-called transpilers can be used to convert code to older versions.</p></div><div class="section" title="I speak JavaScript, translate, please!"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>I speak JavaScript, translate, please!</h3></div></div></div><p>While compilers compile from a higher-level language to a lower-level language, a transpiler or transcompiler acts more like a converter. It is a source-to-source compiler that translates code <a id="id42" class="indexterm"/>to run in a different interpreter.</p><p>Recently, there's a real battle among new languages that are transpiled to JavaScript and can run in the browser. I used Google Dart for quite some time, and I must admit, I really loved the language features. The problem with nonstandardized languages is that they depend heavily on community adoption and the hype. Also, it's almost certain that they will never run natively within the browser. This is also the reason why I prefer standard JavaScript, and the JavaScript of the future uses transpilers that allow me to do this.</p><p>Some people argue that transpilers introduce code that does not run very performant and, therefore, recommend that you do not use ECMAScript 6 and transpilers at all. I don't agree with this because of many reasons. Usually, this is about performance in micro or even nanosecond areas where this often really does not matter for most applications.</p><p>I don't say performance doesn't matter, but performance needs to always be discussed within a context. If you're trying to optimize a loop within your application by reducing processing time from 10 microseconds to five microseconds where you'd never iterate over more than 100 items, then you're probably spending your time on the wrong things.</p><p>Also, a very important fact is that transpiled code is designed by people who understand micro performance optimization much better than I do, and I'm sure their code runs faster than mine. On top of this, a transpiler is probably also the right place where you'd want to do performance optimization because this code is automatically generated and you don't lose maintainability of your code through performance quirks.</p><p>I'd like to quote <a id="id43" class="indexterm"/>Donald Knuth here and say that premature optimization is the root of all evil. I really recommend that you read his paper on this topic (Donald Knuth, December 1974, <span class="emphasis"><em>Structured Programming with go to Statements</em></span>). Just because the <code class="literal">goto</code> statements got banished from all modern programming languages, it doesn't mean this is less of a good read.</p><p>Later on in this chapter, you'll learn about tools that help you use transpilers easily within your project, and we'll take a look at the decisions and directions Angular went with their source code.</p><p>Let's look at a few language features that come with ECMAScript 6 and make our life much easier.</p></div><div class="section" title="Classes"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Classes</h3></div></div></div><p>Classes were <a id="id44" class="indexterm"/>among one the most requested features in JavaScript, and I <a id="id45" class="indexterm"/>was one of the people voting for it. Well, coming from an OOP background and being used to organizing everything within classes, it was hard for me to let go. Although, after working with modern JavaScript for some time, you'll reduce their use to the bare minimum and to exactly what they are made for—inheritance.</p><p>Classes in ECMAScript 6 provide you with syntactic sugar to deal with prototypes, constructor functions, super calls, and object property definitions in a way that you have the illusion that JavaScript could be a class-based OOP language:</p><div class="informalexample"><pre class="programlisting">class Fruit {
  constructor(name) { this.name = name; }
}
const apple = new Fruit('Apple');</pre></div><p>As we learned in the previous topic about transpilers, ECMAScript 6 can be de-sugared to ECMAScript 5. Let's take a look at what a transpiler would produce from this simple example:</p><div class="informalexample"><pre class="programlisting">function Fruit(name) { this.name = name; }
var apple = new Fruit('Apple');</pre></div><p>This simple example can easily be built using ECMAScript 5. However, once we use the more complex features of class-based object-oriented languages, the de-sugaring gets quite complicated.</p><p>ECMAScript 6 classes introduce simplified syntax to write class member functions (static functions), the use of the super keyword, and inheritance using the <code class="literal">extends</code> keyword.</p><p>If you would like to read more about the features in classes and ECMAScript 6, I highly recommend <a id="id46" class="indexterm"/>that <a id="id47" class="indexterm"/>you read the articles <a id="id48" class="indexterm"/>of Dr. Axel Rauschmayer (<a class="ulink" href="http://www.2ality.com/">http://www.2ality.com/</a>).</p></div><div class="section" title="Modules"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Modules</h3></div></div></div><p>Modules <a id="id49" class="indexterm"/>provide a way to encapsulate your code and create privacy. In <a id="id50" class="indexterm"/>object-oriented languages, we usually use classes for this. However, I actually believe this is an antipattern rather than a good practice. Classes should be used where inheritance is desired and not just to structure your code.</p><p>I'm sure that you've encountered a lot of different module patterns in JavaScript already. One of the most popular ones that creates privacy using a function closure of an <span class="strong"><strong>immediately invoked function expression</strong></span> (<span class="strong"><strong>IIFE</strong></span>) is probably the revealing module pattern. If <a id="id51" class="indexterm"/>you'd like to read more about this and may be other great patterns, I recommend the book, <span class="emphasis"><em>Learning JavaScript Design Patterns,</em></span> by Addy Osmani.</p><p>Within ECMAScript 6, we can now use modules to serve this purpose. We simply create one file per module, and then we use the import and export keywords to connect our modules together.</p><p>Within the ECMAScript 6 module specification, we can actually export as many things as we like from each module. We can then import these named exports from any other module. We can have one default export per module, which is especially easy to import. Default exports don't need to be named, and we don't need to know their name when importing them:</p><div class="informalexample"><pre class="programlisting">import SomeModule from './some-module.js';
var something = SomeModule.doSomething();
export default something;</pre></div><p>There are many combinations on how to use modules. We will discover some of these together while working on our task management application during the upcoming chapters. If you'd like to see more examples on how to use modules, I can recommend the Mozilla Developer<a id="id52" class="indexterm"/> Network documentation (<a class="ulink" href="https://developer.mozilla.org">https://developer.mozilla.org</a>) on the <code class="literal">import</code> and <code class="literal">export</code> keywords.</p></div><div class="section" title="Template strings"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Template strings</h3></div></div></div><p>Template strings<a id="id53" class="indexterm"/> are a very simple, but they are an extremely <a id="id54" class="indexterm"/>useful addition to the JavaScript syntax. They serve three main purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Writing multiline strings</li><li class="listitem">String interpolation</li><li class="listitem">Tagged template strings</li></ul></div><p>Before template strings, it was quite verbose to write multiline strings. You needed to concatenate pieces of strings and append a new-line character yourself to the line endings:</p><div class="informalexample"><pre class="programlisting">const header = '&lt;header&gt;\n' +
  '  &lt;h1&gt;' + title + '&lt;/h1&gt;\n' +
  '&lt;/header&gt;';</pre></div><p>Using template <a id="id55" class="indexterm"/>strings, we can simplify this example a lot. We <a id="id56" class="indexterm"/>can write multiline strings, and we can also use the string interpolation functionality for our title variable that we used to concatenate earlier:</p><div class="informalexample"><pre class="programlisting">const header = '
  &lt;header&gt;
    &lt;h1&gt;${title}&lt;/h1&gt;
  &lt;/header&gt;
`;</pre></div><p>Note the back ticks instead of the previous single quotes. Template strings are always written between back ticks, and the parser will interpret all characters in between them as part of the resulting string. This way, the new-line characters present in our source file will also be part of the string automatically.</p><p>You can also see that we have used the dollar sign, followed by curly brackets to interpolate our strings. This allows us to write arbitrary JavaScript within strings and helps a lot while constructing HTML template strings.</p><p>You can read more about template strings on the Mozilla Developer Network.</p></div><div class="section" title="ECMAScript or TypeScript?"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>ECMAScript or TypeScript?</h3></div></div></div><p>TypeScript <a id="id57" class="indexterm"/>was created in 2012 by Anders Hejlsberg with<a id="id58" class="indexterm"/> the intention to implement the future standard of ECMAScript 6 but also to provide a superset of syntax and features that was not part of the specification.</p><p>There are many features in TypeScript as a superset to the ECMAScript 6 standard, including, but not limited to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Optional static typing with type annotations</li><li class="listitem">Interfaces</li><li class="listitem">Enum types</li><li class="listitem">Generics</li></ul></div><p>It's important to understand that all of the features that TypeScript provides as a superset are optional. You can write pure ECMAScript 6 and not take advantage of the additional features that TypeScript provides. The TypeScript compiler will still transcompile pure ECMAScript 6 code to ECMAScript 5 without any errors.</p><div class="note" title="Note"><h3 class="title"><a id="note03"/>Note</h3><p>Most of the features that are seen in TypeScript are actually already present in other languages, such as Java and C#. One goal of TypeScript was to provide language features that support workflows and better maintainability for large-scale applications.</p></div><p>The problem <a id="id59" class="indexterm"/>with any nonstandard language is that nobody can <a id="id60" class="indexterm"/>tell how long the language will be maintained and how fast the momentum of the language will be in the future. In terms of support, the chances are high that TypeScript, with its sponsor Microsoft, will actually have a long life. However, there's still no guarantee that the momentum and trend of the language will keep moving at a reasonable pace. This problem does obviously not exist for standard ECMAScript 6 because it's what the web of the future is made of and what browsers will speak natively.</p><p>Still, there are valid reasons to use the extended features of TypeScript if you'd want to address the following concerns that clearly outweigh the negative implications of an uncertain future in your project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Large applications that undergo a huge amount of changes and refactoring</li><li class="listitem">Large teams that require a strict governance while working on code</li></ul></div><p>In this book, we'll use a TypeScript compiler, but we will work with standard ECMAScript 6 code with one exception that is covered in the next topic about decorators.</p></div><div class="section" title="Decorators"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Decorators</h3></div></div></div><p>Decorators are<a id="id61" class="indexterm"/> not part of the ECMAScript 6 specification, but <a id="id62" class="indexterm"/>they were proposed to the ECMAScript 7 standard for 2016. They provide us with a way to decorate classes and properties during design time. This allows a developer to use meta-annotations while writing classes, and declaratively attach functionality to the class and its properties.</p><p>Decorators are named after the decorator pattern that was initially described in the book <span class="emphasis"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em></span> of Erich Gamma and his colleagues, also known as the <span class="strong"><strong>Gang of Four</strong></span> (<span class="strong"><strong>GoF</strong></span>).</p><p>The principle of decoration is that an existing<a id="id63" class="indexterm"/> procedure is intercepted and the decorator has the chance to either delegate, provide an alternative procedure, or do a mix from both.</p><div class="mediaobject"><img src="../Images/image00303.jpeg" alt="Decorators"/><div class="caption"><p>Visualization of decoration in a dynamic environment with the example of a simple access procedure</p></div></div><p style="clear:both; height: 1em;"> </p><p>Decorators in <a id="id64" class="indexterm"/>ECMAScript 7 can be used to annotate classes and class <a id="id65" class="indexterm"/>properties. Note that this also includes class methods, as class methods are also properties of the class prototype object. Decorators get defined as regular functions, and they can be attached to classes or class properties with the <span class="emphasis"><em>at</em></span> symbol. Our decorator function will then be called with contextual information about the location of inclusion every time that the decorator is placed.</p><p>Let's take a look at a simple example that illustrates the use of a decorator:</p><div class="informalexample"><pre class="programlisting">function logAccess(obj, prop, descriptor) {
  const delegate = descriptor.value;
  descriptor.value = function() {
    console.log(`${prop} was called!`);
    return delegate.apply(this, arguments);
  };
}

class MoneySafe {
  @logAccess
  openSafe() {
    this.open = true;
  }
}

const safe = new MoneySafe();
safe.openSafe(); // openSafe was called!</pre></div><p>We have<a id="id66" class="indexterm"/> created a <code class="literal">logAccess</code> decorator that will log all function calls <a id="id67" class="indexterm"/>that are tagged with the decorator. If we look at the <code class="literal">MoneySafe</code> class, you can see that we have decorated the <code class="literal">openSafe</code> method with our <code class="literal">logAccess</code> decorator.</p><p>The <code class="literal">logAccess</code> decorator function will be executed for each annotated property within our code. This enables us to intercept the property definition of the given property. Let's take a look at the signature of our decorator function. Decorator functions that are placed on class properties will be called with the target object of the property definition as a first parameter. The second parameter is the actual property name that is defined, followed by the last parameter, which is the descriptor object that is supposed to be applied to the object.</p><p>The decorator gives us the opportunity to intercept the property definition. In our case, we use this ability to exchange the descriptor value (which is the annotated function) with a proxy function that will log the function call before calling the origin function (delegation). For simplification purposes, we've implemented a very simple yet incomplete function proxy. For real-world scenarios, it would be advisable to use a better proxy implementation, such as the ECMAScript 6 proxy object.</p><p>Decorators are a great feature to leverage aspect-oriented concepts and declaratively add behavior to our code at design time.</p><p>Let's look at a second example where we use an alternative way to declare and use decorators. We can treat decorators like function expressions where our decorator function is rewritten as a factory function. This form of usage is especially useful when you need to pass along configuration to the decorator, which is made available in the decorator factory function:</p><div class="informalexample"><pre class="programlisting">function delay(time) {
  return function(obj, prop, descriptor) {
    const delegate = descriptor.value;
    descriptor.value = function() {
      const context = this;
      const args = arguments;
      return new Promise(function(success) {
        setTimeout(function() {
          success(delegate.apply(context, arguments));
        }, time);
      });
    };
  };
}

class Doer {
  @delay(1000)
  doItLater() {
    console.log('I did it!');
  }
}

const doer = new Doer();
doer.doItLater(); // I did it! (after 1 second)</pre></div><p>We have now<a id="id68" class="indexterm"/> learned how ECMAScript 7 decorators can help you to<a id="id69" class="indexterm"/> write declarative code that has an aspect-oriented twist to it. This simplifies development a lot because we can now think of behavior that we add to our classes during design time when we actually think about the class as a whole and write the initial stub of the class.</p><p>Decorators in TypeScript are slightly different than the decorators from ECMAScript 7. They are not limited to classes and class properties, but they can also be placed on parameters within the class methods. This allows you to annotate function parameters, which can be useful in some cases:</p><div class="informalexample"><pre class="programlisting">class TypeScriptClass {
  constructor(@ParameterDecorator() param) {}
}</pre></div><p>Angular uses this feature to simplify dependency injection on class constructors. As all directive, component, and service classes get instantiated from Angular dependency injection and not by us directly, these annotations help Angular find the correct dependencies. For this use-case, function parameter decorators actually make a lot of sense.</p><div class="note" title="Note"><h3 class="title"><a id="note04"/>Note</h3><p>Currently, there are still issues with the implementation of decorators on class method parameters, which is also why ECMAScript 7 does not support it. As this feature is crucial to build an Angular 2 application, we'll use the TypeScript compiler to transpile the code of our application. This is the only TypeScript-specific feature that we'll use in this book.</p></div></div></div></div>
<div class="section" title="Tools" id="aid-H5A41"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Tools</h1></div></div></div><p>In order to make <a id="id70" class="indexterm"/>use of all these future technologies, we need some tools to support us. We were already talking about ECMAScript 6 and decorators, where we actually prefer TypeScript decorators, as they support the function parameter decorators that are used by Angular 2. Although the ECMAScript 6 syntax supports modules, we still <a id="id71" class="indexterm"/>need some sort of a module loader that will actually load the required modules in the browser or help us generate an executable bundle.</p><div class="section" title="Node.js and NPM"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Node.js and NPM</h2></div></div></div><p>Node.js is<a id="id72" class="indexterm"/> JavaScript on steroids. Initially, a fork of the V8 JavaScript <a id="id73" class="indexterm"/>engine from the Google Chrome browser, Node.js was<a id="id74" class="indexterm"/> extended with more functionality, specifically to <a id="id75" class="indexterm"/>make JavaScript useful on the server-side. File handling, streams, system APIs, and a huge ecosystem of user-generated packages are just some of the facts that make this technology an outstanding partner for your web development.</p><p>The node package manager, NPM, is a door to over 200,000 packages and libraries that help you build your own application or library. The Node.js philosophy is very similar to the UNIX philosophy, where packages should stay small and sharp, but they should use composition to achieve greater goals.</p><p>To build our application, we will rely on Node.js as the host for the tools that we're going to use. We should, therefore, make sure that we install Node.js on our machine so that we are prepared for the next chapter, where we start to craft our task management application.</p><div class="note" title="Note"><h3 class="title"><a id="note05"/>Note</h3><p>You can get Node.js<a id="id76" class="indexterm"/> from their website at <a class="ulink" href="https://nodejs.org">https://nodejs.org</a>, and it should be a breeze to install this on any kind of operating system by following the instructions on their website.</p></div><p>Once you've installed Node.js, we can perform a simple test to check whether everything is up and running. Open a terminal console and execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node -e "console.log('Hello World');" </strong></span>
</pre></div></div><div class="section" title="SystemJS and JSPM"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>SystemJS and JSPM</h2></div></div></div><p>There are <a id="id77" class="indexterm"/>many module formats and module loaders out there, but there's one<a id="id78" class="indexterm"/> that rules them all in my opinion. SystemJS is built on top of an<a id="id79" class="indexterm"/> ES6 module loader polyfill and, therefore, moves very close to an <a id="id80" class="indexterm"/>upcoming standard. I strongly believe in standardization and, therefore, prefer SystemJS over other module loaders, such as RequireJS, Browserify, or webpack. We should stop using libraries where possible and rely on polyfills that make our browser capable of running the code of the future.</p><p>SystemJS is a universal module loader that is capable of loading many different module formats, such as AMD, CommonJS, and ECMAScript 6, and it also supports a very flexible shiming mechanism to modularize global JavaScript.</p><p>SystemJS also <a id="id81" class="indexterm"/>supports the most popular transpilers, including ECMAScript <a id="id82" class="indexterm"/>6 and TypeScript. This means that you can actually load ECMAScript 6<a id="id83" class="indexterm"/> code directly in your browser, where it's transpiled by<a id="id84" class="indexterm"/> SystemJS in runtime. This is great during development, especially because you're allowed to load modules from any location, including remote HTTP locations, such as GitHub or the NPM repository.</p><div class="section" title="JSPM"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>JSPM</h3></div></div></div><p>The JavaScript package manager is not just another package manager for JavaScript. This is basically a mediator and manager for SystemJS that helps you look up packages from package repositories, such as Bower or NPM, and it creates the necessary configuration for SystemJS. JSPM is written in Node.js and does not come with its own remote package repository. As SystemJS needs URLs and module mappings to know where to load modules from, JSPM is your tool to create this necessary configuration and simplify package installation.</p></div><div class="section" title="Getting started with JSPM"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Getting started with JSPM</h3></div></div></div><p>Let's create a <a id="id85" class="indexterm"/>simple application together using JSPM. First of all, we need to install two global modules with NPM. Besides JSPM, we'll also install a tool called live-server, which will help us during development by providing an HTTP server that serves static files. It also has file change detection built-in, and it will reload your browser automatically once a file change has been detected. This provides a very short feedback loop and makes development a very fast process:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the following command on your command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install -g jspm live-server</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip06"/>Tip</h3><p>Note that on UNIX-like systems, such as Linux or Mac OS X, it's sometimes required to run NPM as a super user. It's also recommended that you use the <span class="strong"><strong>Node Version Manager</strong></span> (<span class="strong"><strong>NVM</strong></span>) to<a id="id86" class="indexterm"/> get around those issues (<a class="ulink" href="https://github.com/creationix/nvm">https://github.com/creationix/nvm</a>).</p></div></li><li class="listitem">After installing JSPM and the <code class="literal">live-server</code> package, we can go ahead and create our first application using JSPM.</li><li class="listitem">Create a new directory for the application, and open a terminal console within this directory.</li><li class="listitem">You can now execute the following command on your terminal console to install JSPM locally and initialize a new JSPM project:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install jspm --save-dev</strong></span>
<span class="strong"><strong>jspm init </strong></span>
</pre></div></li><li class="listitem">JSPM will <a id="id87" class="indexterm"/>start a wizard that guides you though the initialization steps. You can answer all questions with the default answer (just hit <span class="emphasis"><em>Enter</em></span>) except for the question about which transpiler you'd like to use that you should answer with TypeScript.</li><li class="listitem">After JSPM installs all the necessary packages, we can go ahead and create our <code class="literal">index.html</code> file. Navigate to your project folder and create a new file, <code class="literal">index.html</code>, in your favorite editor:<div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;script src="jspm_packages/system.js"&gt;&lt;/script&gt;
&lt;script src="config.js"&gt;&lt;/script&gt;
&lt;script&gt;
  System.import('main.js');
&lt;/script&gt;</pre></div></li><li class="listitem">This very minimalistic HTML is already the foundation for our JSPM Hello World application. After including the <code class="literal">SystemJS</code> library and the <code class="literal">config.js</code> file that was generated by JSPM, we only need to bootstrap our application by telling <code class="literal">SystemJS</code> which file to import.</li><li class="listitem">Before we create our main application file, we will quickly install jQuery as a package, just to demonstrate how easily third-party libraries can be installed and used with <code class="literal">SystemJS</code> and JSPM:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jspm install jquery</strong></span>
</pre></div></li><li class="listitem">After installing jQuery, we can go ahead and create our <code class="literal">main.js</code> file inside of the application folder:<div class="informalexample"><pre class="programlisting">import $ from 'jquery';

class HelloWorld {
  constructor() {
    $(document.body).append('&lt;h1&gt;Hello World!&lt;/h1&gt;');
  }
}
const helloWorld = new HelloWorld();</pre></div></li><li class="listitem">In order to run this example in the browser, we can now start our live server with the following command executed inside of the application folder:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>live-server</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>After following the preceding steps, you should have a working example with ECMAScript 6 and SystemJS using the TypeScript transpiler. Using LiveReload, your browser should automatically open and display our Hello World application. You can also try now to modify the code a bit and change the sentence that is written to the DOM. You'll notice<a id="id88" class="indexterm"/> that once you save your changes, the browser will immediately reload the page.</p></div></div></div>
<div class="section" title="Summary" id="aid-I3QM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>In this chapter, we looked at a component-based approach to structure user interfaces, and we talked about the necessary aspects of its background to understand why we are moving in this direction with the web standard and frameworks, such as Angular. We also ensured that we are prepared with all the technology that we will use in the upcoming chapters in this book. You created your first simple example using JSPM, SystemJS, ECMAScript 6, and the TypeScript transpiler. Now, we are ready to start building our task-management system using a component-based architecture to its full potential.</p><p>In the next chapter, we're going to start building our task management application using Angular 2 components. We'll look at the initial steps that are required to create an Angular 2 application from scratch and flesh out the first few components in order to build a task list.</p></div></body></html>