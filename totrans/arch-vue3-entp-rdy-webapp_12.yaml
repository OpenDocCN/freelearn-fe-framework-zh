- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Enterprise-Ready Vue.js 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored everything related to **end-to-end** (**e2e**)
    testing. We learned in depth how to perform e2e testing on a Vue.js 3 component
    and pages. In addition, we also learned about end-to-end testing tools such as
    Cypress and Puppeteer, and how to use them to test an enterprise project effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to deploy Vue.js 3 projects to the AWS cloud.
    We will learn the best practices for deploying to AWS. In addition, we will learn
    how enterprise companies deploy their enterprise Vue.js 3 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will learn about and explore different deployment options and
    best practices to deploy your Vue.js 3 project to various cloud providers. We
    will learn how to deploy the app to AWS and Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a deployment pipeline?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, I recommend reading through [*Chapter 11*](B17237_11.xhtml#_idTextAnchor420),
    *Industry Standard End-to-End Testing*, where we explored the concept of e2e testing
    and what to test from an array of components and methods available. We will rely
    heavily on the knowledge of that chapter in this chapter to learn about Vue.js
    3 enterprise unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: All the code files of this chapter can be found at [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-12](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-12).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing an enterprise-level application is easy, but constantly deploying
    newly developed changes, bug fixes, or features to your users is a daunting process,
    especially if done frequently, and especially for enterprise-ready applications.
    In addition, as your application, teams, and deployment infrastructure grows in
    complexity, continuously releasing and deploying new changes, features, and products
    to customers can be a complicated process.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the complicated process of developing, testing, and releasing software
    quickly and consistently, three related but distinct strategies have been created
    by developers and organizations to manage and automate these processes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore these three pillars, called CI/CD, and
    explain each of these strategies and how they relate to each other. Most importantly,
    we will explore how to build and incorporate these strategies into our enterprise
    application life cycle so that it can transform our software development and release
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CI**/**CD** stands for **continuous integration**/**continuous delivery**.
    It is a strategy that allows enterprise teams to ship software faster and more
    efficiently. It enables a streamlined approach for getting products to the market
    more quickly than ever before, allowing for a steady stream of code to be released
    into production and providing a steady stream of new features and bug fixes through
    the most efficient means of delivery.'
  prefs: []
  type: TYPE_NORMAL
- en: A CI/CD pipeline is written to automate the software delivery process from the
    development stage to the production environment. It builds, tests, and safely
    deploys a new version of an application.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of automated pipelines is that it removes the manual errors
    that can be detected during deployment and provides standardized feedback loops
    to developers for faster product iterations.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD is a combination of different strategies and pillars that come together
    to create a strong pipeline for delivering enterprise software; we will explore
    these strategies in detail in this section.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.1 – CI/CD\uFEFF](img/Figure_12.01_B17237.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – CI/CD
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI is a process that allows developers in a team to frequently integrate their
    code into a shared repository. These developers can write their code in isolation
    and integrate it using a continuous integration process. This practice encourages
    each developer to build in isolation and integrate code with the shared repository
    multiple times throughout the day.
  prefs: []
  type: TYPE_NORMAL
- en: When code is integrated early in the development cycle, developers can discover
    conflicts at the boundaries between new and existing code early. This process
    minimizes the cost of integration by making it an early consideration.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing a proper continuous integration strategy, development teams
    can reduce integration costs and respond to defects early.
  prefs: []
  type: TYPE_NORMAL
- en: For an enterprise team to succeed in robust, automated, and fast integration,
    deployment, and delivery of enterprise software, the culture of frequent iteration
    and responsiveness to build issues must be cultivated.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CD is an extension of continuous integration that is aimed at streamlining the
    software delivery process and allowing teams to deploy their code to production
    with ease and assurance. It seeks to reduce the difficulty of the deployment or
    release process by automating the steps necessary to deploy a build, thus enabling
    code to be released securely at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, continuous delivery is a process that allows for the automated
    transfer of finished code to various settings, such as testing and development.
    It provides a reliable and automated method for the code to be sent to these areas.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, continuous delivery encompasses the provisioning and deployment
    of infrastructure, which can be done manually and involve multiple steps. This
    type of delivery usually automates these processes with the involvement of the
    entire team.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery relies on a deployment pipeline to automate the process
    of running increasingly comprehensive test suites against a build, with each stage
    being a sequential step. If the build fails the test, the team is notified, but
    if it passes, it is automatically advanced to the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential for enterprise software teams to implement continuous delivery,
    as it automates the process between committing code to the repository and determining
    whether to deploy well-tested, functional builds to the production environment.
    This step helps ensure that the quality and accuracy of the code are automated,
    while the ultimate decision of what to release is left up to the engineering team.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous deployment is an extension of continuous delivery that deploys each
    build that passes the full test cycle without manual intervention. This is beneficial,
    as manual deployment can cause delays and irregular deployment. A continuous deployment
    system will deploy any build that has gone through the deployment pipeline that
    was set up during the continuous delivery stage.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, deploying your code automatically doesn’t mean that new features
    cannot be activated or deactivated conditionally. In fact, continuous deployment
    can be configured to only deploy a specific feature to a subset of users or be
    activated conditionally at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: The debate surrounding continuous deployment is often focused on the safety
    of automated deployment and whether the risk it poses is worth the reward. Nevertheless,
    it can also be advantageous for organizations, as they can receive constant feedback
    on new features and quickly detect any errors before too much time and energy
    is wasted.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored the concept of CI/CD and how to automate deploying and releasing
    enterprise projects. In the next section, we will explore the deployment pipeline
    and how to create an enterprise-ready deployment pipeline for the enterprise Vue.js
    3 application.
  prefs: []
  type: TYPE_NORMAL
- en: What is a deployment pipeline?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The deployment pipeline streamlines the deployment and delivery of your enterprise
    application. It compiles the code, executes all the tests, and securely deploys
    a new version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Automating your deployment and delivery processes using deployment pipelines
    removes manual errors, provides standardized feedback loops to developers, and
    enables fast product iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, when building enterprise products, your organizational structure
    and development team and pattern will determine the strategies used to create
    your deployment pipeline, as it can differ from project to project.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are different strategies already used in enterprise projects
    that can be adopted and modified if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In deployment pipelines, there are required stages (or elements) that make up
    a CI/CD pipeline. In the next section, we are going to explore these elements
    and learn how to set up our deployment pipeline for our demo enterprise project.
  prefs: []
  type: TYPE_NORMAL
- en: Elements of a deployment pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A deployment pipeline is composed of executable instructions that any developer
    must follow in order to release a new version of a software product.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of an automated deployment pipeline is that it replaces the manual
    process of carrying out the exact specification laid out for the deployment and
    delivery of enterprise software by automating the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the typical software release stages in most enterprise
    software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Elements of a deployment pipeline](img/Figure_12.02_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Elements of a deployment pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'These stages can be performed manually, provided each step is followed accordingly.
    However, the downside is enormous, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time-consuming**: Manual deployment can take a long time to complete, especially
    if there are multiple components that need to be deployed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error-prone**: Manual deployment is prone to human errors, which can lead
    to costly mistakes and downtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of scalability**: Manual deployment is not easily scalable, as it requires
    manual intervention for each component that needs to be deployed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid this, an automated deployment pipeline has been created to carry out
    the stages and alert the responsible developer of any errors, or to send notifications
    through email, Slack, and so on. Additionally, the pipeline can also notify the
    whole team when a successful deployment to production has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine each of the stages to understand what goes in. This will
    aid us in understanding how to develop a good deployment pipeline for our enterprise
    Vue.js 3 application.
  prefs: []
  type: TYPE_NORMAL
- en: Source stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the source stage, a pipeline is typically initiated by a source code repository.
    Whenever there is a change in the code, it notifies the CI/CD process to execute
    the related pipeline. Additionally, other common triggers include user-initiated
    workflows and automated scheduled workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Build stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the build stage, we combine the source code and all its dependencies to build
    a runnable instance of the project that is intended to ship to the users. At this
    stage, the software is compiled or bundled together with its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The build phase attempts to package the project to make it deployable. If the
    build stage encounters any problems, this is a sign of an underlying issue with
    the project’s setup or configuration and should be taken care of right away.
  prefs: []
  type: TYPE_NORMAL
- en: Test stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the build stage is finished successfully, the next step is to conduct the
    test stage. This stage involves running automated tests to make sure the code
    is accurate and the project is functioning correctly. This stage serves as a safeguard
    to ensure that any bugs that can be easily reproduced are not sent to the end
    users or passed through the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, all the test cases written by developers (including, but not
    limited to, unit tests, integration tests, e2e testing, etc.) are all tested and
    checked to make sure they all pass before allowing the current build to proceed
    to the deployment stage.
  prefs: []
  type: TYPE_NORMAL
- en: The testing stage is critical for identifying any issues with the code that
    the developer may have overlooked. This feedback is important to the developer
    as it is provided while the problem is still fresh in their mind. If any failures
    occur during the test stage, they can reveal problems in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to this stage, the pipeline has created a functioning version of the new
    code or modifications that have passed all the predetermined tests and is now
    ready to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, there are multiple deployment environments that have been established
    for the development team, such as a “staging” environment for the product team,
    a “development” environment for the development team, and a “production” environment
    for the end users.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the team, organization, and model chosen, various deployment environments
    can be established. Teams that have adopted the Agile model of development, which
    is based on tests and real-time observation, often deploy to the staging environment
    for further manual testing and examination before pushing out accepted modifications
    to production for the end users.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of a deployment pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to explore a practical example of a deployment
    pipeline. Pipelines are the reflection of the complexity of a project. Therefore,
    configuring a pipeline that runs on every code change will save a team many pains
    and repetitive tasks in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows a clear example of a deployment pipeline and the
    different jobs that need to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: The `source` stage is triggered when changes are pushed to a specific branch
    that the CI/CD is activated on and it moves to the build stage where it compiles
    that code using a compiler, if any, or uses a `docker build` process to build
    the project’s image.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the testing stage runs all the necessary and activated test cycles, such
    as unit tests, integration tests, and end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: After successful testing, the pipeline moves to the deploy stage, where the
    code is deployed to a live staging environment for further testing before finally
    deploying to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Example of a deployment pipeline](img/Figure_12.03_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Example of a deployment pipeline
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we have explored the overview of a deployment pipeline,
    the different stages, and what goes under the hood of each different stage. In
    this section, we have explored deployment pipelines and the different stages that
    are involved in them. Next, we will discuss how to deploy our Pinterest demo to
    the AWS cloud using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of CI/CD, there are numerous tools have been created to automate
    the process of building, testing, and deploying projects. GitHub Actions happens
    to be one of those tools and has greatly gained popularity.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions is a CI/CD platform that allows developers to automate the process
    of building, testing, and running deployment pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions became popular because it is directly integrated into GitHub
    and can be configured to create workflows that build and test every pull request
    to your repository or deploy merged pull requests to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are tons of concepts to learn about GitHub Actions: the different terminologies,
    concepts, benefits, and advantages of using GitHub Actions over other CI/CD platforms.
    You can learn all this from the official documentation at [https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we will show you how to create a deployment pipeline for the Pinterest
    demo project we developed in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an enterprise project is tedious and requires lots of checks to make
    sure that frequent bugs do not surface in production.
  prefs: []
  type: TYPE_NORMAL
- en: There are many factors to check before deploying an enterprise project, from
    linting, formatting, and styling, to testing. The list is endless and sometimes
    depends on your team and how the development workflow is set up.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to explore the different stages or checks
    the project needs to pass before deploying to production.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs in the deployment pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The jobs in the deployment pipeline vary from project to project and from team
    to team. In the following subsection, we look at some of the important jobs you
    can build into your deployment pipeline to completely check your project before
    deploying to production.
  prefs: []
  type: TYPE_NORMAL
- en: Linting (Eslint, Stylelint, Prettier)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linting is a process in which a linter program reviews the source code of a
    particular programming language or code base to detect any potential issues such
    as errors, bugs, stylistic errors, and suspicious constructs. This is beneficial
    in recognizing both common and uncommon mistakes that can be made when coding.
    Furthermore, linting will go through your source code to identify any formatting
    discrepancies, check for compliance with coding standards and conventions, and
    pinpoint potential logical errors in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Also, linting helps with developer experience in a team by creating a consistent
    code base throughout the development team.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to set up linting in our pipeline to enforce consistency between
    the style guide, formatting, and naming conventions in our deployment pipeline,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Lighthouse budget checks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lighthouse is an open source, automated tool for improving the quality of web
    pages. This tool allows you to run tests against web pages (public or requiring
    authentication). It helps developers audit web pages for performance, accessibility,
    SEO, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can automate this process by adding it to your deployment pipeline
    to test for performance of your web page before deploying it to the users. This
    process allows enterprise-ready application developers to automate the process
    of testing the performance of the application in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The action allows us to set numerous options, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing against multiple paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a budget path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of runs (how many times the CI should audit an URL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to set up the Lighthouse bot ([https://github.com/ebidel/lighthousebot](https://github.com/ebidel/lighthousebot))
    with GitHub Actions to audit our deployment and User Experience (UX) integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a snippet of the job setup for Lighthouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is used to add the Lighthouse plugin to the deployment pipeline,
    and the plugin uses the `actions/checkout` plugin to access the repository workspace
    in other to access the `budget.json` file, which contains the task that Lighthouse
    should perform. This Lighthouse GitHub Action is extremely beneficial for websites
    that depend on Google search traffic. If not addressed early on, it is very common
    for the bundle sizes to become larger as a website is developed, resulting in
    a lower Lighthouse score. This action allows us to monitor any discrepancies with
    each commit.
  prefs: []
  type: TYPE_NORMAL
- en: Automated software testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Software testing is a vital factor for determining the status of your enterprise
    application and making sure it conforms to the project requirements. As explored
    in the previous chapters, we have developed three major types of software testing
    and have practiced how to create better testing suites for our Pinterest application
    demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we are going to set up three jobs to run the entire software testing
    suites for our demo application. In our demo, the software testing suite comprises
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration (component) testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2e testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The job will run each of these tests and respond accordingly. If the test fails,
    it will pause the deployment and report the problem to the development team via
    Slack notifications or emails. Otherwise, if the test passes, it will continue
    to the next stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the snippet of all the test setups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The script sets up the testing stage, which contains scripts to run different
    testing cycles such as unit testing, integration testing, and e2e testing. In
    each of the pipeline jobs, we use `actions/checkout` to check out the workspace
    repository, and next, we run the `yarn` command to install all the packages before
    proceeding to run the `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: Netlify deployment for staging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Netlify is a comprehensive platform that enables you to integrate your preferred
    tools and APIs to construct the fastest websites, stores, and applications for
    the composable web. It allows you to utilize any frontend framework to construct,
    preview, and deploy to the worldwide network from Git.
  prefs: []
  type: TYPE_NORMAL
- en: You can deploy your enterprise application to several environments, such as
    development, staging, and production, depending on your team’s setup.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions allows you to create several workflows for deploying to these
    different environments. Within each environment, you can set up different jobs
    to be performed. For instance, you might not want to check for Lighthouse performance
    again since it was already tested when deploying to staging environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a snippet to set up the job to deploy to Netlify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script uses the Netlify GitHub Action plugin to deploy the Vue.js
    3 application to Netlify. It requires a Netlify token and secrets (which are added
    in the Secrets section of our GitHub repository) and finally, it provides the
    preview URL after deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to create a complete deployment pipeline with
    GitHub Actions to set up a staging application for more manual testing before
    pushing it to the master branch, which will trigger the production deployment
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the deployment pipeline with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a deployment pipeline with GitHub Actions, we need to create configuration
    files for each pipeline configuration environment.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the steps mentioned next to create your first deployment pipeline for
    your staging environment using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Pinterest demo application or clone it from the official repository
    for this chapter to see a complete setup of the GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re following along, create a new file called `staging.yml` inside the
    `.``github/workflows` folder.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the name of the folders must be exactly the same
    for GitHub Actions to pick the configuration up when pushing to your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline for the staging environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the `staging.yml` file and add the following scripts to create a deployment
    pipeline for the staging environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we discussed in detail how to automate the process of deploying
    your enterprise applications. We learned about deployment pipelines and how to
    create one with GitHub Actions. In the next section, we will learn how to deploy
    our app to **AWS** (**Amazon Web Services**) production by automating the process
    using deployment pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to implement continuous deployment for the Vue.js
    3 application with GitHub Actions and AWS App Runner.
  prefs: []
  type: TYPE_NORMAL
- en: This process can be triggered manually after thoroughly checking the staging
    application to make sure it satisfies all requirements before pushing it to production.
    However, it can also be automated to happen immediately after the staging is completed.
  prefs: []
  type: TYPE_NORMAL
- en: In this demo, we are going to create the deployment pipeline for deploying to
    the AWS production server using AWS App Runner and also automate the process at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It’s advisable to trigger the deployment process manually, which gives room
    to manually check all the requirements on the staging environment before deploying
    a new release to production.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy to AWS, you will need an AWS account and an AWS IAM account with proper
    permissions. In this section, we explored how to create pipelines and deploy our
    project to AWS. In the next section, we will continue deploying our project using
    Docker and the Dockerfile we created in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B17237_07.xhtml#_idTextAnchor230)*, Dockerizing a Vue 3 App*
    we discussed the nitty-gritty involved in Dockerizing your Vue.js 3 project. In
    addition, we learned about the best practices and industry standards to Dockerize
    and deploy an enterprise Vue.js 3 web application.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Dockerfile we created for this project so that we can run it
    on AWS infrastructure as a containerized application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the Dockerfile we created before with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the same Dockerfile we used in the previous chapter to Dockerize our
    project. You can refer back to the chapter to learn more about Dockerizing your
    Vue.js 3 application.
  prefs: []
  type: TYPE_NORMAL
- en: The base image will be `nginx:stable-alpine` and the application will be listening
    on port `80`. For step-by-step Dockerizing guidelines, please refer to the official
    documentation from Vue.js at [https://v2.vuejs.org/v2/cookbook/dockerize-vuejs-app.html?redirect=true](https://v2.vuejs.org/v2/cookbook/dockerize-vuejs-app.html?redirect=true).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the application container using the following Docker Compose command
    since we have already defined the `docker-compose.yml` file in [*Chapter 7*](B17237_07.xhtml#_idTextAnchor230)*,
    Dockerizing a Vue* *3 App*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After running the application container successfully, you should be able to
    access the dashboard via the same address as the `npm run dev` command. Next,
    let’s provision AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning AWS resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use GitHub Actions to deploy our Vue.js 3 application to AWS continuously,
    so we need to create an IAM account and a user-managed role on AWS, which will
    be used in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This IAM account will be used by GitHub Actions agents. Access the console at
    [https://us-east-1.console.aws.amazon.com/iamv2/home#/home](https://us-east-1.console.aws.amazon.com/iamv2/home#/home)
    and create an IAM account and a user-managed role on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Creating a new user in IAM for GitHub Actions](img/Figure_12.04_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Creating a new user in IAM for GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Next: Permissions** option and click the **Create User** button.
    Lastly, click on **Download.csv** to download the credential for the new user
    and save it somewhere—we will need to use it soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a role for the IAM user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this demonstration, we will be making a new role called `app-runner-service-role`
    and attaching the `AWSAppRunnerServicePolicyForECRAccess` policy. This role will
    be used by AWS App Runner services to give them access to Elastic Container Register
    (ECR) in order to manage our Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a service role, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Role** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Create Role** button, select the **Custom Trusted Policy** option,
    and enter the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code snippet is a JSON file that is used to create a custom trusted policy
    for deploying to Amazon **Elastic Container** **Service** (**ECS**).
  prefs: []
  type: TYPE_NORMAL
- en: After successfully creating `app-runner-service-role`, as shown in the following
    figure, make sure to copy and note the Amazon Resourse Name (ARN), as it will
    be used later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Creating app-runner-service-role](img/Figure_12.05_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Creating app-runner-service-role
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we worked through the step-by-step process of creating `app-runner-service-role`
    and the Amazon IAM permission for ECS deployment. In the next section, we will
    be creating a policy for the IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a policy for the IAM user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Navigate to the `github-vue-pinterest-demo` IAM permission and attach the following
    inline policy, which will grant permission to GitHub Actions (via the IAM role)
    to work with ECR and App Runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By updating the IAM policy to be more specific (i.e., ARN-specific instead of
    wildcard), the security concerns associated with the preceding JSON can be addressed
    by creating a policy and attaching it to the IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ECR private repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re almost there; one final step is to create a private repository on ECR
    to manage our Docker images. Add a repository name of your choice into the box
    provided, and click on the **Create** button, leaving the remaining options as
    their defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Creating a private repository named vue-pinterest-demo](img/Figure_12.06_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Creating a private repository named vue-pinterest-demo
  prefs: []
  type: TYPE_NORMAL
- en: After creating your ECR instance, head over to your GitHub repository and add
    all the secrets and environment variables needed to deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created the ECR instance and added our secrets to our GitHub
    repository, along with all the environment variables needed. In the next section,
    we will look at how to work with GitHub Actions to automate the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GitHub Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will be working with GitHub Actions and automating the
    process of deploying your application to Amazon ECR. We will start by adding the
    Amazon secrets to our GitHub repository. Follow these steps to add your secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Settings** | **Secrets** | **Actions** in your GitHub repository and
    add all the necessary secret variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `new_user_credentials.csv` file you downloaded when you created the
    IAM user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the values for **AWS_ACCESS_KEY_ID** and **AWS_SECRET_ACCESS_KEY** and
    paste them into your GitHub Secrets as your environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, you can use `us-east-1 for AWS_REGION` and your ARN of `app-runner-service-role`
    for `ROLE_ARN`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding your credentials successfully, in the next section, we will create
    a pipeline for deploying the enterprise project to AWS App Runner using ECR to
    manage our Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline for the production environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `production.yml` file and add the following scripts to create a deployment
    pipeline for the production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If everything is successful, navigate to the App Runner service console; there
    will be a service with the name you specified. You can click on the default domain
    name to preview your application or set up a custom domain name.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.\uFEFF7 – Preview of the Pinterest demo application](img/Figure_12.07_B17237.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Preview of the Pinterest demo application
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to deploy Vue.js 3 projects to the AWS cloud
    and some of the best practices for deploying to AWS. We explored continuous integration
    and continuous delivery by exploring deployment pipelines, showing the different
    deployment staging, and how to configure each of them to perform specific jobs.
    We also examined how each stage performs and how to deploy to a staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explored different deployment options and how to deploy using
    Docker with Amazon ECR. We learned practically how to create an account and set
    up Amazon ECR with Docker and finally, we implemented automated deployment using
    CI/CD, Docker, Amazon ECR, and GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the definitive guide to Nuxt.js. You will
    learn the nitty-gritty of Nuxt.js and how to build and deliver enterprise SSR
    projects with Vue.js 3\. We will explore the definitive guide to Gridsome, and
    you will learn the nitty-gritty of Gridsome and how to build and deliver enterprise
    CSR projects with Vue.js 3.
  prefs: []
  type: TYPE_NORMAL
