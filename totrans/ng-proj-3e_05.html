<html><head></head><body>
  <div id="_idContainer102" class="Basic-Text-Frame">
    <h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-83" class="chapterTitle">Building a WYSIWYG Editor for the Desktop Using Electron</h1>
    <p class="normal">Web applications are traditionally built with HTML, CSS, and JavaScript. Their use has also widely spread to server development<a id="_idIndexMarker238"/> using <strong class="keyWord">Node.js</strong>. Various tools and frameworks have emerged in recent years that use HTML, CSS, and JavaScript to create applications for desktop and mobile. In this chapter, we will investigate how to create desktop applications using Angular and <strong class="keyWord">Electron</strong>.</p>
    <p class="normal">Electron is a<a id="_idIndexMarker239"/> JavaScript framework used to build native desktop applications with web technologies. Combining it with the Angular framework allows us to create fast and highly performant web applications. In this chapter, we will build a desktop <strong class="keyWord">WYSIWYG</strong> editor<a id="_idIndexMarker240"/> and cover the following topics:</p>
    <ul>
      <li class="bulletList">Adding a WYSIWYG editor library for Angular</li>
      <li class="bulletList">Integrating Electron in the workspace</li>
      <li class="bulletList">Communicating between Angular and Electron</li>
      <li class="bulletList">Packaging a desktop application</li>
    </ul>
    <h1 id="_idParaDest-84" class="heading-1">Essential background theory and context</h1>
    <p class="normal">Electron is a <a id="_idIndexMarker241"/>cross-platform framework used to build Windows, Linux, and Mac desktop applications. Many popular applications, such as Visual Studio Code, Skype, and Slack, are made with Electron. The Electron framework is built on top of Node.js and Chromium. Web developers can leverage their existing HTML, CSS, and JavaScript skills to create desktop applications without learning a new language like C++ or C#.</p>
    <div class="packt_tip">
      <p class="normal">Electron applications have many similarities with PWA applications. Consider building an Electron application for scenarios such as advanced filesystem manipulation or when you need a more native look and feel for your application. Another use case is when you build a complementary tool for your primary desktop product and want to ship them together.</p>
    </div>
    <p class="normal">An Electron application consists of two processes:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Main</strong>: This <a id="_idIndexMarker242"/>interacts with the native local resources using the Node.js API.</li>
      <li class="bulletList"><strong class="keyWord">Renderer</strong>: This is responsible <a id="_idIndexMarker243"/>for managing the user interface of the application.</li>
    </ul>
    <p class="normal">An Electron application can have only one main process that communicates with one or more renderer processes. Each renderer process operates in complete isolation from the others.</p>
    <p class="normal">The<a id="_idIndexMarker244"/> Electron framework <a id="_idIndexMarker245"/>provides the <strong class="keyWord">ipcMain</strong> and <strong class="keyWord">ipcRenderer</strong> interfaces, which we can use to interact with these processes. The interaction is accomplished using <strong class="keyWord">Inter-Process Communication (IPC)</strong>, a mechanism<a id="_idIndexMarker246"/> that exchanges messages securely and asynchronously over a common channel via a Promise-based API.</p>
    <h1 id="_idParaDest-85" class="heading-1">Project overview</h1>
    <p class="normal">In this project, we<a id="_idIndexMarker247"/> will build a desktop WYSIWYG editor that keeps its content local to the filesystem. Initially, we will build it as an Angular application <a id="_idIndexMarker248"/>using <strong class="keyWord">ngx-wig</strong>, a popular WYSIWYG Angular library. We will then convert it to a desktop application using Electron and learn how to synchronize content between Angular and Electron. We will also see how to persist the content of the editor into the filesystem. Finally, we will package our application as a single executable file that can be run in a desktop environment. The following diagram describes an architectural overview of the project:</p>
    <figure class="mediaobject"><img src="../Images/B18465_05_01.png" alt="Εικόνα που περιέχει διάγραμμα  Περιγραφή που δημιουργήθηκε αυτόματα"/></figure>
    <p class="packt_figref">Figure 5.1 – Project architecture</p>
    <p class="normal">Build time: 1 hour.</p>
    <h1 id="_idParaDest-86" class="heading-1">Getting started</h1>
    <p class="normal">The following <a id="_idIndexMarker249"/>software tools are required to complete this project:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Angular CLI</strong>: A command-line <a id="_idIndexMarker250"/>interface for Angular that you can find at <a href="https://angular.io/cli"><span class="url">https://angular.io/cli</span></a>.</li>
      <li class="bulletList"><strong class="keyWord">Visual Studio Code</strong>: A code<a id="_idIndexMarker251"/> editor that you can download from <a href="https://code.visualstudio.com"><span class="url">https://code.visualstudio.com</span></a>.</li>
      <li class="bulletList"><strong class="keyWord">GitHub material</strong>: The code for this chapter can be found in the <code class="inlineCode">Chapter05</code> folder at <a href="https://github.com/PacktPublishing/Angular-Projects-Third-Edition"><span class="url">https://github.com/PacktPublishing/Angular-Projects-Third-Edition</span></a>.</li>
    </ul>
    <h1 id="_idParaDest-87" class="heading-1">Adding a WYSIWYG editor library for Angular</h1>
    <p class="normal">We will<a id="_idIndexMarker252"/> kick off our project by creating a <a id="_idIndexMarker253"/>WYSIWYG editor as a Angular application. Use the Angular CLI to create a new Angular application from scratch:</p>
    <pre class="programlisting con"><code class="hljs-con">ng new my-editor --defaults
</code></pre>
    <p class="normal">We pass the following options to the <code class="inlineCode">ng new</code> command:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">my-editor</code>: Defines the name of the application</li>
      <li class="bulletList"><code class="inlineCode">--defaults</code>: Defines CSS as the preferred stylesheet format of the application and disables routing because our application will consist of a single component that will host the editor</li>
    </ul>
    <p class="normal">A WYSIWYG editor is a rich text editor, such as Microsoft Word. We could create one from scratch using the Angular framework, but it would be time-consuming, and we would only reinvent the wheel. The Angular ecosystem contains a wide variety of libraries for this purpose. One of them is the ngx-wig library, which has no external dependencies, just <a id="_idIndexMarker254"/>Angular! Let’s add the library to our<a id="_idIndexMarker255"/> application and learn how to use it:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Use the <code class="inlineCode">npm</code> client to install <code class="inlineCode">ngx-wig</code> from the npm package registry:
        <pre class="programlisting con"><code class="hljs-con">npm install ngx-wig
</code></pre>
      </li>
      <li class="numberedList">Open the <code class="inlineCode">app.module.ts</code> file and add <code class="inlineCode">NgxWigModule</code> to the <code class="inlineCode">imports</code> array of the <code class="inlineCode">@NgModule</code> decorator:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title">BrowserModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { </strong><strong class="hljs-title-slc">NgxWigModule</strong><strong class="hljs-slc"> } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'</strong><strong class="hljs-string-slc">ngx-wig'</strong><strong class="hljs-slc">;</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">AppComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;
<span class="hljs-meta">@NgModule</span>({
  <span class="hljs-attr">declarations</span>: [
    <span class="hljs-title">AppComponent</span>
  ],
  <span class="hljs-attr">imports</span>: [
    <span class="hljs-title">BrowserModule</span>,
    <span class="code-highlight"><strong class="hljs-title-slc">NgxWigModule</strong></span>
  ],
  <span class="hljs-attr">providers</span>: [],
  <span class="hljs-attr">bootstrap</span>: [<span class="hljs-title">AppComponent</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> { }
</code></pre>
    <p class="normal"><code class="inlineCode">NgxWigModule</code> is the main module of the ngx-wig library.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Create a new Angular component that will host our WYSIWYG editor:
        <pre class="programlisting con"><code class="hljs-con">ng generate component editor
</code></pre>
      </li>
      <li class="numberedList">Open the template file of the newly generated component, <code class="inlineCode">editor.component.html</code>, and replace its content with the following HTML snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">ngx-wig</span><span class="hljs-tag"> </span><span class="hljs-attr">placeholder</span><span class="hljs-tag">=</span><span class="hljs-string">"Enter your content"</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">ngx-wig</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal"><code class="inlineCode">NgxWigModule</code> exposes a set of Angular services and components we can use in our application. The main component of the module is the <code class="inlineCode">&lt;ngx-wig&gt;</code> component, which displays the actual WYSIWYG editor. It exposes a collection of input properties that we can set, such as the placeholder of the editor. </p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Open the <code class="inlineCode">app.component.html</code> file and replace its content with the <code class="inlineCode">&lt;app-editor&gt;</code> component:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">app-editor</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">app-editor</span><span class="hljs-tag">&gt;</span>
</code></pre>
      </li>
      <li class="numberedList">Open the <code class="inlineCode">styles.css</code> file, which <a id="_idIndexMarker256"/>contains global styles <a id="_idIndexMarker257"/>for the Angular application, and add the following styles to make the editor dockable and take up the full page:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
}
<span class="hljs-selector-class">.ng-wig</span>, <span class="hljs-selector-class">.nw-editor-container</span>, <span class="hljs-selector-class">.nw-editor</span>  {
  <span class="hljs-attribute">display</span>: flex <span class="hljs-meta">!important</span>;
  <span class="hljs-attribute">flex-direction</span>: column;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span> <span class="hljs-meta">!important</span>;
  <span class="hljs-attribute">overflow</span>: hidden;
}
</code></pre>
      </li>
      <li class="numberedList">Open the main HTML file of the Angular application, <code class="inlineCode">index.html</code>, and remove the <code class="inlineCode">&lt;base&gt;</code> tag from the <code class="inlineCode">&lt;head&gt;</code> element. The browser uses the <code class="inlineCode">&lt;base&gt;</code> tag to reference scripts and CSS files with a relative URL. Leaving it as is will make our desktop application fail because it will load all necessary assets directly from the local filesystem. We will learn more in the <em class="italic">Integrating Angular with Electron</em> section.</li>
    </ol>
    <p class="normal">Let’s see what we have <a id="_idIndexMarker258"/>achieved so far. Run <code class="inlineCode">ng serve</code> and <a id="_idIndexMarker259"/>navigate to <code class="inlineCode">http://localhost:4200</code> to preview the application:</p>
    <figure class="mediaobject"><img src="../Images/B18465_05_02.png" alt="Figure 5.1 – Application output"/></figure>
    <p class="packt_figref">Figure 5.2 – Application output</p>
    <p class="normal">Our application consists of the following:</p>
    <ul>
      <li class="bulletList">A toolbar with buttons that allows us to apply different styles to the content of the editor</li>
      <li class="bulletList">A text area that is used as the main container to add content to the editor</li>
    </ul>
    <p class="normal">We have now <a id="_idIndexMarker260"/>created a web application using <a id="_idIndexMarker261"/>Angular with a fully operational WYSIWYG editor. In the following section, we will learn how to convert it into a desktop one using Electron.</p>
    <h1 id="_idParaDest-88" class="heading-1">Integrating Electron in the workspace</h1>
    <p class="normal">The Electron framework <a id="_idIndexMarker262"/>is an npm package that we can install using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install -D electron
</code></pre>
    <p class="normal">The previous command will install the latest version of the <code class="inlineCode">electron</code> npm package in the Angular CLI workspace. It will also add a respective entry into the <code class="inlineCode">devDependencies</code> section of the <code class="inlineCode">package.json</code> file of our project.</p>
    <div class="note">
      <p class="normal">Electron is added to the <code class="inlineCode">devDependencies</code> section of the <code class="inlineCode">package.json</code> file because it is a development dependency of our application. It is used only to prepare and build our application as a desktop one and not during runtime.</p>
    </div>
    <p class="normal">Electron applications run on the Node.js runtime and use the Chromium browser to render. A Node.js application has at least a JavaScript file, usually called <code class="inlineCode">index.js</code> or <code class="inlineCode">main.js</code>, which is the main entry point of the application. Since we are using Angular and TypeScript as our development stack, we will start by creating a separate TypeScript file that will be finally compiled in JavaScript:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a folder named <code class="inlineCode">electron</code> inside the <code class="inlineCode">src</code> folder of the Angular CLI workspace. The <code class="inlineCode">electron</code> folder will contain any source code that is related to Electron.
    <div class="packt_tip">
      <p class="normal">We can think of our application as two different platforms. The web platform is the Angular application, which resides in the <code class="inlineCode">src\app</code> folder. The desktop platform is the Electron application, which resides in the <code class="inlineCode">src\electron</code> folder. This approach has many benefits, including that it enforces the separation of concerns in our application and allows each one to develop independently from the other. From now on, we will refer to them as the Angular and Electron applications.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Create<a id="_idIndexMarker263"/> a <code class="inlineCode">main.ts</code> file inside the <code class="inlineCode">electron</code> folder with the following content:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { app, <span class="hljs-title">BrowserWindow</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'electron'</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span> () {
  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> <span class="hljs-title">BrowserWindow</span>({
    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>
  });
  mainWindow.<span class="hljs-title">loadFile</span>(<span class="hljs-string">'index.html'</span>);
}
app.<span class="hljs-title">whenReady</span>().<span class="hljs-title">then</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title">createWindow</span>();
});
</code></pre>
    <p class="normal">In the preceding code, we first import the <code class="inlineCode">BrowserWindow</code> and <code class="inlineCode">app</code> artifacts from the <code class="inlineCode">electron</code> npm package. The <code class="inlineCode">BrowserWindow</code> class is used to create a desktop window for our application. We define the window dimensions, passing an <code class="inlineCode">options</code> object in its constructor that sets the <code class="inlineCode">width</code> and <code class="inlineCode">height</code> values of the window. We then call the <code class="inlineCode">loadFile</code> method, passing the HTML file we want to load inside the window as a parameter.</p>
    <div class="note">
      <p class="normal">The <code class="inlineCode">index.html</code> file that we pass in the <code class="inlineCode">loadFile</code> method is the main HTML file of the Angular application. It is loaded using the <strong class="keyWord">file</strong> protocol, which is why we removed the <code class="inlineCode">&lt;base&gt;</code> tag in the <em class="italic">Adding a WYSIWYG editor library for Angular</em> section.</p>
    </div>
    <p class="normal">The <code class="inlineCode">app</code> object is the<a id="_idIndexMarker264"/> global object of our desktop application, just like the <code class="inlineCode">window</code> object on a web page. It exposes a <code class="inlineCode">whenReady</code> Promise that, when resolved, allows us to run any initialization logic for our application, including creating the window.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Create a <code class="inlineCode">tsconfig.json</code> file inside the <code class="inlineCode">electron</code> folder and add the following contents:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"extends"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"../../tsconfig.json"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"importHelpers"</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span>
  <span class="hljs-punctuation">},</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"**/*.ts"</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">main.ts</code> file must be compiled into JavaScript because browsers do not understand TypeScript. The compilation<a id="_idIndexMarker265"/> process is called <strong class="keyWord">transpilation</strong> and requires a TypeScript configuration file. The configuration file contains options that drive the <a id="_idIndexMarker266"/>TypeScript <strong class="keyWord">transpiler</strong>, which is responsible for the transpilation process.</p>
    <p class="normal">The preceding TypeScript configuration file defines the path of the Electron source code files, using the <code class="inlineCode">include</code> property, and sets the <code class="inlineCode">importHelpers</code> property to <code class="inlineCode">false</code>.</p>
    <div class="note">
      <p class="normal">If we enable the <code class="inlineCode">importHelpers</code> flag, it will include helpers from the <strong class="keyWord">tslib</strong> library<a id="_idIndexMarker267"/> in our application, resulting in a larger bundle size.</p>
    </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Run the following command to install <a id="_idIndexMarker268"/>the <strong class="keyWord">Webpack CLI</strong>:
        <pre class="programlisting con"><code class="hljs-con">npm install -D webpack-cli
</code></pre>
    <p class="normal">The<a id="_idIndexMarker269"/> Webpack CLI invokes <strong class="keyWord">webpack</strong>, a popular<a id="_idIndexMarker270"/> module bundler, from the command line. We will use webpack to build and bundle our Electron application.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Install the <code class="inlineCode">ts-loader</code> npm package using the following command:
        <pre class="programlisting con"><code class="hljs-con">npm install -D ts-loader
</code></pre>
      </li>
    </ol>
    <p class="normal">The <strong class="keyWord">ts-loader</strong> library<a id="_idIndexMarker271"/> is a webpack plugin that can load TypeScript files.</p>
    <p class="normal">We have created all the pieces needed to convert our Angular application into a desktop one using Electron. We only need to put them together to build and run our desktop application. The main piece that orchestrates the Electron application is the webpack configuration file that we need to create in the root folder of our Angular CLI workspace:</p>
    <p class="normal"><code class="inlineCode">webpack.config.js</code></p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> src = path.<span class="hljs-title">join</span>(process.<span class="hljs-title">cwd</span>(), <span class="hljs-string">'src'</span>, <span class="hljs-string">'electron'</span>);
<span class="hljs-variable">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'source-map'</span>,
  <span class="hljs-attr">entry</span>: path.<span class="hljs-title">join</span>(src, <span class="hljs-string">'main.ts'</span>),
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title">join</span>(process.<span class="hljs-title">cwd</span>(), <span class="hljs-string">'dist'</span>, <span class="hljs-string">'my-editor'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'shell.js'</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'ts-loader'</span>,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">configFile</span>: path.<span class="hljs-title">join</span>(src, <span class="hljs-string">'tsconfig.json'</span>)
        }
      }
    ]
  },
  <span class="hljs-attr">target</span>: <span class="hljs-string">'electron-main'</span>
};
</code></pre>
    <p class="normal">The preceding file <a id="_idIndexMarker272"/>configures webpack in our application using the following options:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">mode</code>: Indicates that we are currently running in a <code class="inlineCode">development</code> environment.</li>
      <li class="bulletList"><code class="inlineCode">devtool</code>: Enables source map file generation for debugging purposes.</li>
      <li class="bulletList"><code class="inlineCode">entry</code>: Indicates the main entry point of the Electron application, which is the <code class="inlineCode">main.ts</code> file.</li>
      <li class="bulletList"><code class="inlineCode">output</code>: Defines the path and the filename of the Electron bundle that will be generated from webpack. The <code class="inlineCode">path</code> property points to the same folder used by the Angular CLI to create the bundle of the Angular application. The <code class="inlineCode">filename</code> property is set to <code class="inlineCode">shell.js</code> because the default one generated from webpack is <code class="inlineCode">main.js</code>, and it will cause a conflict with the <code class="inlineCode">main.js</code> file generated from the Angular application.</li>
      <li class="bulletList"><code class="inlineCode">module</code>: Instructs webpack to load the <code class="inlineCode">ts-loader</code> plugin to handle TypeScript files.</li>
      <li class="bulletList"><code class="inlineCode">target</code>: Indicates that we are currently running in the main process of Electron.</li>
    </ul>
    <p class="normal">The webpack module bundler now contains all the information needed to build and bundle the Electron application. On the other hand, the Angular CLI takes care of building the Angular application. Let’s see how we can combine them and run our desktop application:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Run the following command to install the <code class="inlineCode">concurrently</code> npm package:
        <pre class="programlisting con"><code class="hljs-con">npm install -D concurrently
</code></pre>
    <p class="normal">The <strong class="keyWord">concurrently</strong> library<a id="_idIndexMarker273"/> enables us to execute multiple processes together. In our case, it will allow us to run the Angular and Electron applications in parallel.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Open the <code class="inlineCode">package.json</code> file and add a new entry in the <code class="inlineCode">scripts</code> property:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ng"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng serve"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"</span><span class="hljs-string">ng build"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"watch"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng build --watch --configuration development"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng test"</span><span class="hljs-punctuation">,</span>
  <span class="code-highlight"><strong class="hljs-attr-slc">"start:desktop"</strong><strong class="hljs-punctuation-slc">:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"concurrently \"ng build --delete-output-path=false --watch\" \"webpack --watch\""</strong></span>
<span class="code-highlight"><strong class="hljs-punctuation-slc">}</strong></span>
</code></pre>
    <p class="normal">The <code class="inlineCode">start:desktop</code> script builds the Angular application, using the <code class="inlineCode">ng build</code> command of the Angular CLI, and the Electron application, using the <code class="inlineCode">webpack</code> command. Both applications run in watch mode using the <code class="inlineCode">--watch</code> option, so every time we change the code, the application will rebuild to reflect the change. </p>
    <p class="numberedList">The Angular CLI will delete the <code class="inlineCode">dist</code> folder by default whenever we <a id="_idIndexMarker274"/>modify the Angular application. We can prevent this behavior using the <code class="inlineCode">--delete-output-path=false</code> option because the Electron application is also built in the same folder.</p>
    <div class="note">
      <p class="normal">We did not pass the webpack configuration file to the <code class="inlineCode">webpack</code> command because it assumes the <code class="inlineCode">webpack.config.js</code> filename by default.</p>
    </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Click on the <strong class="screenText">Run</strong> menu that exists in the sidebar of Visual Studio Code:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18465_05_03.png" alt="Figure 5.2 – Run menu"/></figure>
    <p class="packt_figref">Figure 5.3 – Run menu</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In the <strong class="screenText">RUN AND DEBUG</strong> pane that appears, select the <strong class="screenText">Add Configuration…</strong> option<a id="_idIndexMarker275"/> from the drop-down menu:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18465_05_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.4 – RUN AND DEBUG pane</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Visual Studio Code will open a drop-down menu that allows us to select the environment to run our application. Select the <strong class="screenText">{} Node.js: Electron Main</strong> configuration.</li>
      <li class="numberedList">In the <code class="inlineCode">launch.json</code> file that opens, set the value of the <code class="inlineCode">program</code> property to <code class="inlineCode">${workspaceFolder}/dist/my-editor/shell.js</code>. The <code class="inlineCode">program</code> property points to the absolute path of the Electron bundle file.</li>
    </ol>
    <p class="normal">We are now ready to <a id="_idIndexMarker276"/>run our desktop application and preview it. Run the following command to build the application:</p>
    <pre class="programlisting con"><code class="hljs-con">npm run start:desktop
</code></pre>
    <p class="normal">The previous command will first build the Electron application and then the Angular one. Wait for the Angular build to finish, select the <strong class="screenText">Electron Main</strong> option from the drop-down menu of the <strong class="screenText">RUN AND DEBUG</strong> pane, and click the <em class="italic">Play</em> button to preview the application:</p>
    <figure class="mediaobject"><img src="../Images/B18465_05_05.png" alt="Figure 5.4 – Application window"/></figure>
    <p class="packt_figref">Figure 5.5 – Application window</p>
    <p class="normal">In the preceding screenshot, we can see that our Angular application with the WYSIWYG editor is hosted inside a native desktop window. It contains the following characteristics that we usually find in desktop applications:</p>
    <ul>
      <li class="bulletList">The header with an icon</li>
      <li class="bulletList">The main menu</li>
      <li class="bulletList">The minimize, maximize, and close buttons</li>
    </ul>
    <p class="normal">The Angular <a id="_idIndexMarker277"/>application is rendered inside the Chromium browser. To verify that, click the <strong class="screenText">View</strong> menu item and select the <strong class="screenText">Toggle Developer Tools</strong> option.</p>
    <p class="normal">Well done! You have successfully managed to create your own desktop WYSIWYG editor. In the following section, we will learn how to interact between Angular and Electron.</p>
    <h1 id="_idParaDest-89" class="heading-1">Communicating between Angular and Electron</h1>
    <p class="normal">According to the <a id="_idIndexMarker278"/>specifications of the project, the content of the WYSIWYG editor needs to be persisted in the local filesystem. Additionally, the content will be loaded from the filesystem upon application startup.</p>
    <p class="normal">The Angular application handles any interaction between the WYSIWYG editor and its data using the renderer process, whereas the Electron application manages the filesystem with the main process. Thus, we need to establish an IPC mechanism to communicate between the two Electron processes as follows:</p>
    <ul>
      <li class="bulletList">Configuring the Angular CLI workspace</li>
      <li class="bulletList">Interacting with the editor</li>
      <li class="bulletList">Interacting with the filesystem</li>
    </ul>
    <p class="normal">Let’s start by setting up the Angular CLI project to support the desired communication mechanism.</p>
    <h2 id="_idParaDest-90" class="heading-2">Configuring the Angular CLI workspace</h2>
    <p class="normal">We need to modify <a id="_idIndexMarker279"/>several files to configure the workspace of our<a id="_idIndexMarker280"/> application:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Open the <code class="inlineCode">main.ts</code> file that exists in the <code class="inlineCode">src\electron</code> folder and set the <code class="inlineCode">webPreferences</code> property in the <code class="inlineCode">BrowserWindow</code> constructor accordingly:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span> () {
  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> <span class="hljs-title">BrowserWindow</span>({
    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,
    <span class="code-highlight"><strong class="hljs-attr-slc">webPreferences</strong><strong class="hljs-slc">: {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">nodeIntegration</strong><strong class="hljs-slc">: </strong><strong class="hljs-literal-slc">true</strong><strong class="hljs-slc">,</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">contextIsolation</strong><strong class="hljs-slc">: </strong><strong class="hljs-literal-slc">false</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    }</strong></span>
  });
  mainWindow.<span class="hljs-title">loadFile</span>(<span class="hljs-string">'index.html'</span>);
}
</code></pre>
    <p class="normal">The preceding flags will enable Node.js in the renderer process and expose the <code class="inlineCode">ipcRenderer</code> interface, which we will need to communicate with the main process.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Run the following command to install the <code class="inlineCode">ngx-electronyzer</code> npm package:
        <pre class="programlisting con"><code class="hljs-con">npm install ngx-electronyzer
</code></pre>
      </li>
    </ol>
    <p class="normal">The <strong class="keyWord">ngx-electronyzer</strong> library allows<a id="_idIndexMarker281"/> us to integrate the Electron API <a id="_idIndexMarker282"/>into an Angular <a id="_idIndexMarker283"/>application.</p>
    <p class="normal">The Angular and Electron applications are now ready to interact with each other using the IPC mechanism. Let’s start implementing the necessary logic in the Angular application first.</p>
    <h2 id="_idParaDest-91" class="heading-2">Interacting with the editor</h2>
    <p class="normal">The Angular application is <a id="_idIndexMarker284"/>responsible for managing the WYSIWYG editor. The content of the editor is kept in sync with the filesystem using the renderer process of Electron. Let’s find out how to use the renderer process:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new Angular service using the following command of the Angular CLI:
        <pre class="programlisting con"><code class="hljs-con">ng generate service editor
</code></pre>
      </li>
      <li class="numberedList">Open the <code class="inlineCode">editor.service.ts</code> file and inject the <code class="inlineCode">ElectronService</code> class from the <code class="inlineCode">ngx-electronyzer</code> npm package:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { </strong><strong class="hljs-title-slc">ElectronService</strong><strong class="hljs-slc"> } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'ngx-electronyzer'</strong><strong class="hljs-slc">;</strong></span>
<span class="hljs-meta">@Injectable</span>({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EditorService</span> {
  <span class="hljs-title">constructor</span>(<span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-params-slc"> electronService: ElectronService</strong></span>) { }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">ElectronService</code> class exposes part of the Electron API, including the <code class="inlineCode">ipcRenderer</code> interface we are currently interested in.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Create a method that will be called to get the content of the editor from the filesystem:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">getContent</span>(): <span class="hljs-title">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">electronService</span>.<span class="hljs-property">ipcRenderer</span>.<span class="hljs-title">invoke</span>(<span class="hljs-string">'getContent'</span>);
}  
</code></pre>
    <p class="normal">We use the <code class="inlineCode">invoke</code> method of the <code class="inlineCode">ipcRenderer</code> property, passing the name of the communication channel as a parameter. The result of the <code class="inlineCode">getContent</code> method is a <code class="inlineCode">Promise</code> object of the <code class="inlineCode">string</code> type, since the content of the editor is raw text data. The <code class="inlineCode">invoke</code> method initiates a connection with the main process through the <code class="inlineCode">getContent</code> channel. In the <em class="italic">Interacting with the filesystem</em> section, we will see how to set up the main process to respond to the <code class="inlineCode">invoke</code> method call in that channel.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Create a method that will be called to save the content of the editor to the filesystem:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">setContent</span>(<span class="hljs-params">content: </span><span class="hljs-built_in">string</span>) {
  <span class="hljs-variable">this</span>.<span class="hljs-property">electronService</span>.<span class="hljs-property">ipcRenderer</span>.<span class="hljs-title">invoke</span>(<span class="hljs-string">'setContent'</span>, content);
}  
</code></pre>
    <p class="normal">The <code class="inlineCode">setContent</code> method <a id="_idIndexMarker285"/>calls the <code class="inlineCode">invoke</code> method of the <code class="inlineCode">ipcRenderer</code> object again but with a different channel name. It also uses the second parameter of the <code class="inlineCode">invoke</code> method to pass data to the main process. In this case, the <code class="inlineCode">content</code> parameter will contain the content of the editor. We will see how to configure the main process to handle data in the <em class="italic">Interacting with the filesystem</em> section.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Open the <code class="inlineCode">editor.component.ts</code> file and create a <code class="inlineCode">myContent</code> property to hold editor data. Also, inject <code class="inlineCode">EditorService</code> in the <code class="inlineCode">constructor</code> of the <code class="inlineCode">EditorComponent</code> class, and add the <code class="inlineCode">OnInit</code> interface from the <code class="inlineCode">@angular/core</code> npm package:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">Component</span>, <span class="code-highlight"><strong class="hljs-title-slc">OnInit</strong></span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { </strong><strong class="hljs-title-slc">EditorService</strong><strong class="hljs-slc"> } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'../editor.service'</strong><strong class="hljs-slc">;</strong></span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-editor'</span>,
  <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">'./editor.component.html'</span>,
  <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">'./editor.component.css'</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EditorComponent</span> <span class="code-highlight"><strong class="hljs-keyword-slc">implements</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">OnInit</strong></span> {
  <span class="code-highlight"><strong class="hljs-slc">myContent = </strong><strong class="hljs-string-slc">''</strong><strong class="hljs-slc">;</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-title-slc">constructor</strong><strong class="hljs-slc">(</strong><strong class="hljs-keyword-slc">private</strong><strong class="hljs-params-slc"> editorService: EditorService</strong><strong class="hljs-slc">) {}</strong></span>
}
</code></pre>
      </li>
      <li class="numberedList">Create a method that calls the <code class="inlineCode">getContent</code> method of the <code class="inlineCode">editorService</code> variable and executes it inside the <code class="inlineCode">ngOnInit</code> method:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">ngOnInit</span>(): <span class="hljs-built_in">void</span> {
  <span class="hljs-variable">this</span>.<span class="hljs-title">getContent</span>();
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title">getContent</span>() {
  <span class="hljs-variable">this</span>.<span class="hljs-property">myContent</span> = <span class="hljs-keyword">await</span> <span class="hljs-variable">this</span>.<span class="hljs-property">editorService</span>.<span class="hljs-title">getContent</span>();
}
</code></pre>
    <p class="normal">We use the <code class="inlineCode">async</code>/<code class="inlineCode">await</code> syntax, which allows the synchronous execution of our code in <a id="_idIndexMarker286"/>Promise-based method calls.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Create a method that calls the <code class="inlineCode">setContent</code> method of the <code class="inlineCode">editorService</code> variable:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">saveContent</span>(<span class="hljs-params">content: </span><span class="hljs-built_in">string</span>) {
  <span class="hljs-variable">this</span>.<span class="hljs-property">editorService</span>.<span class="hljs-title">setContent</span>(content);
}
</code></pre>
      </li>
      <li class="numberedList">Let’s bind those methods that we have created with the template of the component. Open the <code class="inlineCode">editor.component.html</code> file and add the following bindings:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">ngx-wig</span><span class="hljs-tag"> </span><span class="hljs-attr">placeholder</span><span class="hljs-tag">=</span><span class="hljs-string">"Enter your content"</span><span class="hljs-tag"> </span><span class="code-highlight"><strong class="hljs-tag-slc">[</strong><strong class="hljs-attr-slc">ngModel</strong><strong class="hljs-tag-slc">]=</strong><strong class="hljs-string-slc">"myContent"</strong><strong class="hljs-tag-slc"> (</strong><strong class="hljs-attr-slc">contentChange</strong><strong class="hljs-tag-slc">)=</strong><strong class="hljs-string-slc">"saveContent($event)"</strong></span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">ngx-wig</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal">We use the <code class="inlineCode">ngModel</code> directive to bind the model of the editor to the <code class="inlineCode">myContent</code> component property, which will be used to display the content initially. We also use the <code class="inlineCode">contentChange</code> event binding to save the content of the editor whenever it changes, that is, while the user types.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="9">The <code class="inlineCode">ngModel</code> directive is part of the <code class="inlineCode">@angular/forms</code> npm package. Import <code class="inlineCode">FormsModule</code> into the <code class="inlineCode">app.module.ts</code> file to use it:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title">BrowserModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { </strong><strong class="hljs-title-slc">FormsModule</strong><strong class="hljs-slc"> } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'@angular/forms'</strong><strong class="hljs-slc">;</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">NgxWigModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ngx-wig'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title">AppComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'</span><span class="hljs-string">./app.component'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title">EditorComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./editor/editor.component'</span>;
<span class="hljs-meta">@NgModule</span>({
  <span class="hljs-attr">declarations</span>: [
    <span class="hljs-title">AppComponent</span>,
    <span class="hljs-title">EditorComponent</span>
  ],
  <span class="hljs-attr">imports</span>: [
    <span class="hljs-title">BrowserModule</span>,
    <span class="hljs-title">NgxWigModule</span>,
    <span class="code-highlight"><strong class="hljs-title-slc">FormsModule</strong></span>
  ],
  <span class="hljs-attr">providers</span>: [],
  <span class="hljs-attr">bootstrap</span>: [<span class="hljs-title">AppComponent</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> { }
</code></pre>
      </li>
    </ol>
    <p class="normal">We have<a id="_idIndexMarker287"/> implemented all the logic for our Angular application to communicate with the main process. It is time to implement the other end of the communication mechanism, the Electron application, and its main process.</p>
    <h2 id="_idParaDest-92" class="heading-2">Interacting with the filesystem</h2>
    <p class="normal">The main process <a id="_idIndexMarker288"/>interacts with the filesystem using the <strong class="keyWord">fs</strong> library, which is built into the Electron framework. Let’s see how we can use it:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Open the <code class="inlineCode">main.ts</code> file that exists in the <code class="inlineCode">src\electron</code> folder and import the following artifacts:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { app, <span class="hljs-title">BrowserWindow</span>, <span class="code-highlight"><strong class="hljs-slc">ipcMain</strong></span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'electron'</span>;
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> * </strong><strong class="hljs-keyword-slc">as</strong><strong class="hljs-slc"> fs </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'fs'</strong><strong class="hljs-slc">;</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> * </strong><strong class="hljs-keyword-slc">as</strong><strong class="hljs-slc"> path </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'path'</strong><strong class="hljs-slc">;</strong></span>
</code></pre>
    <p class="normal">The <code class="inlineCode">fs</code> library is responsible for interacting with the filesystem. The <code class="inlineCode">path</code> library provides utilities for working with file and folder paths. The <code class="inlineCode">ipcMain</code> object allows us to work with the main process of Electron.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Create a variable that holds the path of the file containing the content of the editor:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> contentFile = path.<span class="hljs-title">join</span>(app.<span class="hljs-title">getPath</span>(<span class="hljs-string">'userData'</span>), <span class="hljs-string">'content.html'</span>);
</code></pre>
    <p class="normal">The file <a id="_idIndexMarker289"/>that keeps the content of the editor is the <code class="inlineCode">content.html</code> file that exists inside the reserved <code class="inlineCode">userData</code> folder. The <code class="inlineCode">userData</code> folder is an alias for a special purpose system folder, different for each OS, and it is used to store application-specific files such as configuration. You can find more details about the <code class="inlineCode">userData</code> folder and other system folders at <a href="https://www.electronjs.org/docs/api/app#appgetpathname"><span class="url">https://www.electronjs.org/docs/api/app#appgetpathname</span></a>.</p>
    <div class="note">
      <p class="normal">The <code class="inlineCode">getPath</code> method of the <code class="inlineCode">app</code> object works cross-platform and is used to get the path of special folders, such as the home directory of a user or the application data.</p>
    </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Call the <code class="inlineCode">handle</code> method of the <code class="inlineCode">ipcMain</code> object to start listening for requests in the <code class="inlineCode">getContent</code> channel:
        <pre class="programlisting code"><code class="hljs-code">ipcMain.<span class="hljs-title">handle</span>(<span class="hljs-string">'getContent'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (fs.<span class="hljs-title">existsSync</span>(contentFile)) {
    <span class="hljs-keyword">const</span> result = fs.<span class="hljs-title">readFileSync</span>(contentFile);
    <span class="hljs-keyword">return</span> result.<span class="hljs-title">toString</span>();
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
});
</code></pre>
    <p class="normal">When the main process receives a request in this channel, it uses the <code class="inlineCode">existsSync</code> method of the <code class="inlineCode">fs</code> library to check whether the file with the content of the editor exists already. If it exists, it reads it using the <code class="inlineCode">readFileSync</code> method and returns its content to the renderer process.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Call the <code class="inlineCode">handle</code> method again, but this time for the <code class="inlineCode">setContent</code> channel:
        <pre class="programlisting code"><code class="hljs-code">ipcMain.<span class="hljs-title">handle</span>(<span class="hljs-string">'setContent'</span>, <span class="hljs-function">(</span><span class="hljs-params">{}, content: </span><span class="hljs-built_in">string</span><span class="hljs-function">) =&gt;</span> {
  fs.<span class="hljs-title">writeFileSync</span>(contentFile, content);
});
</code></pre>
    <p class="normal">In the preceding snippet, we use the <code class="inlineCode">writeFileSync</code> method of the <code class="inlineCode">fs</code> library to write the value of the <code class="inlineCode">content</code> property in the file.</p>
      </li>
    </ol>
    <p class="normal">Now that we have connected the Angular and the Electron application, it is time to preview our WYSIWYG desktop application:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Execute the <code class="inlineCode">start:desktop</code> npm script, and press <em class="keystroke">F5</em> to run the application.</li>
      <li class="numberedList">Use the editor and its toolbar to enter some content, such as the following:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18465_05_06.png" alt="Figure 5.5 – Editor content"/></figure>
    <p class="packt_figref">Figure 5.6 – Editor content</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Close the application window and rerun the application. If everything worked <a id="_idIndexMarker290"/>correctly, you should see the content you entered inside the editor.</li>
    </ol>
    <p class="normal">Congratulations! You have enriched your WYSIWYG editor by adding persistence capabilities to it. In the following section, we will take the last step toward creating our desktop application and learn how to package and distribute it.</p>
    <h1 id="_idParaDest-93" class="heading-1">Packaging a desktop application</h1>
    <p class="normal">Web applications are usually <a id="_idIndexMarker291"/>bundled and deployed to a hosting web server. On the other hand, desktop applications are bundled and packaged as a single executable file that can be easily distributed. Packaging our WYSIWYG application requires<a id="_idIndexMarker292"/> the following steps:</p>
    <ul>
      <li class="bulletList">Configuring webpack for production mode</li>
      <li class="bulletList">Using an Electron bundler</li>
    </ul>
    <p class="normal">We will look at them in more detail in the following sections.</p>
    <h2 id="_idParaDest-94" class="heading-2">Configuring webpack for production</h2>
    <p class="normal">We have already <a id="_idIndexMarker293"/>created a webpack configuration file for the development environment. We now need to create a new one for production. Both configuration files will share some functionality, so let’s start by creating a common one:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a <code class="inlineCode">webpack.dev.config.js</code> file in the root folder of the Angular CLI workspace with the following content:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.config'</span>);
<span class="hljs-variable">module</span>.<span class="hljs-property">exports</span> = {
  ...baseConfig,
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'source-map'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title">join</span>(process.<span class="hljs-title">cwd</span>(), <span class="hljs-string">'dist'</span>, <span class="hljs-string">'my-editor'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'shell.js'</span>
  }
};
</code></pre>
      </li>
      <li class="numberedList">Remove the <code class="inlineCode">mode</code>, <code class="inlineCode">devtool</code>, and <code class="inlineCode">output</code> properties from the <code class="inlineCode">webpack.config.js</code> file.</li>
      <li class="numberedList">Open the <code class="inlineCode">package.json</code> file and pass the new webpack development configuration file at the <code class="inlineCode">start:desktop</code> script:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">"start:desktop"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"concurrently \"ng build --delete-output-path=false --watch\" \"webpack </span><span class="code-highlight"><strong class="hljs-string-slc">--config webpack.dev.config.js</strong></span><span class="hljs-string"> --watch\""</span>
</code></pre>
      </li>
      <li class="numberedList">Create a <code class="inlineCode">webpack.prod.config.js</code> file in the root folder of the Angular CLI workspace with the following content:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.config'</span>);
<span class="hljs-variable">module</span>.<span class="hljs-property">exports</span> = {
  ...baseConfig,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title">join</span>(process.<span class="hljs-title">cwd</span>(), <span class="hljs-string">'dist'</span>, <span class="hljs-string">'my-editor'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'main.js'</span>
  }
};
</code></pre>
    <p class="normal">The main <a id="_idIndexMarker294"/>difference with the webpack configuration file for the development environment is that we changed the <code class="inlineCode">filename</code> of the <code class="inlineCode">output</code> bundle to <code class="inlineCode">main.js</code>. The Angular CLI adds a hashed number in the <code class="inlineCode">main.js</code> file of the Angular application in production, so there will be no conflicts.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Add a new entry in the <code class="inlineCode">scripts</code> property of the <code class="inlineCode">package.json</code> file to build our application in production mode:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"ng"</span>: <span class="hljs-string">"ng"</span>,
  <span class="hljs-string">"start"</span>: <span class="hljs-string">"ng serve"</span>,
  <span class="hljs-string">"build"</span>: <span class="hljs-string">"ng build"</span>,
  <span class="hljs-string">"watch"</span>: <span class="hljs-string">"ng build --watch --configuration development"</span>,
  <span class="hljs-string">"test"</span>: <span class="hljs-string">"ng test"</span>,
  <span class="hljs-string">"start:desktop"</span>: <span class="hljs-string">"concurrently \"ng build --delete-output-path=false --watch\" \"webpack --config webpack.dev.config.js --watch\""</span>,
  <span class="code-highlight"><strong class="hljs-string-slc">"build:electron"</strong><strong class="hljs-slc">: </strong><strong class="hljs-string-slc">"ng build &amp;&amp; webpack --config webpack.prod.config.js"</strong></span>
}
</code></pre>
    <p class="normal">The <code class="inlineCode">build:electron</code> script builds the Angular and Electron application in production <a id="_idIndexMarker295"/>mode simultaneously.</p>
      </li>
    </ol>
    <p class="normal">We have completed all the configurations needed to package our desktop application. In the following section, we will learn how to convert it into a single bundle specific to each OS.</p>
    <h2 id="_idParaDest-95" class="heading-2">Using an Electron bundler</h2>
    <p class="normal">The Electron<a id="_idIndexMarker296"/> framework has various tools created and maintained by the open-source community. One of these tools <a id="_idIndexMarker297"/>is the <strong class="keyWord">electron-packager</strong> library, which we can use to package our desktop application as a single executable file for each OS (Windows, Linux, and macOS). Let’s see how we can integrate it into our development workflow:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Run the following command to install <code class="inlineCode">electron-packager</code> as a development dependency for our project:
        <pre class="programlisting con"><code class="hljs-con">npm install -D electron-packager
</code></pre>
      </li>
      <li class="numberedList">Add a new entry in the <code class="inlineCode">scripts</code> property of the <code class="inlineCode">package.json</code> file to package our application:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ng"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng serve"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"</span><span class="hljs-attr">build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng build"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"watch"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng build --watch --configuration development"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"test"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng test"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"start:desktop"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"concurrently \"ng build --delete-output-path=false --watch\" \"webpack --config webpack.dev.config.js --watch\""</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"build:electron"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ng build &amp;&amp; webpack --config webpack.prod.config.js"</span><span class="hljs-punctuation">,</span>
  <span class="code-highlight"><strong class="hljs-attr-slc">"package"</strong><strong class="hljs-punctuation-slc">:</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">"electron-packager dist/my-editor --out=dist --asar"</strong></span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">In the preceding script, <code class="inlineCode">electron-packager</code> will read all files in the <code class="inlineCode">dist/my-editor</code> folder, package them, and output the final bundle in the <code class="inlineCode">dist</code> folder. The <code class="inlineCode">--asar</code> option instructs the packager to archive all files in the <strong class="keyWord">ASAR</strong> format, similar to a ZIP or TAR file.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Create<a id="_idIndexMarker298"/> a <code class="inlineCode">package.json</code> file in the <code class="inlineCode">src\electron</code> folder and add the following content:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"my-editor"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"</span><span class="hljs-attr">main"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"main.js"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">electron-packager</code> library requires a <code class="inlineCode">package.json</code> file to be present in the output folder, which points to the main entry file of the Electron application.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Open the <code class="inlineCode">webpack.prod.config.js</code> file and add the <code class="inlineCode">CopyWebpackPlugin</code> in the <code class="inlineCode">plugins</code> property:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.config'</span>);
<span class="code-highlight"><strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">CopyWebpackPlugin</strong><strong class="hljs-slc"> = </strong><strong class="hljs-built_in-slc">require</strong><strong class="hljs-slc">(</strong><strong class="hljs-string-slc">'copy-webpack-plugin'</strong><strong class="hljs-slc">);</strong></span>
<span class="hljs-variable">module</span>.<span class="hljs-property">exports</span> = {
  ...baseConfig,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title">join</span>(process.<span class="hljs-title">cwd</span>(), <span class="hljs-string">'dist'</span>, <span class="hljs-string">'my-editor'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'main.js'</span>
  },
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-attr-slc">plugins</strong><strong class="hljs-slc">: [</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">CopyWebpackPlugin</strong><strong class="hljs-slc">({</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-attr-slc">patterns</strong><strong class="hljs-slc">: [</strong></span>
<span class="code-highlight"><strong class="hljs-slc">        {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          </strong><strong class="hljs-attr-slc">context</strong><strong class="hljs-slc">: path.</strong><strong class="hljs-title-slc">join</strong><strong class="hljs-slc">(process.</strong><strong class="hljs-title-slc">cwd</strong><strong class="hljs-slc">(), </strong><strong class="hljs-string-slc">'src'</strong><strong class="hljs-slc">,</strong></span>
<span class="code-highlight"><strong class="hljs-slc">           </strong><strong class="hljs-string-slc">'electron'</strong><strong class="hljs-slc">),</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          </strong><strong class="hljs-attr-slc">from</strong><strong class="hljs-slc">: </strong><strong class="hljs-string-slc">'</strong><strong class="hljs-string-slc">package.json'</strong></span>
<span class="code-highlight"><strong class="hljs-slc">        }</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      ]</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    })</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  ]</strong></span>
};
</code></pre>
    <p class="normal">We use<a id="_idIndexMarker299"/> the <code class="inlineCode">CopyWebpackPlugin</code> to copy the <code class="inlineCode">package.json</code> file from the <code class="inlineCode">src\electron</code> folder into the <code class="inlineCode">dist\my-editor</code> folder while building the application in production mode.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Run the following command to build the application in production mode:
        <pre class="programlisting con"><code class="hljs-con">npm run build:electron
</code></pre>
      </li>
      <li class="numberedList">Now run the following <code class="inlineCode">npm</code> command to package it:
        <pre class="programlisting con"><code class="hljs-con">npm run package
</code></pre>
    <p class="normal">The preceding command will package the application for the OS you currently run on, which is the default behavior of the <code class="inlineCode">electron-packager</code> library. You can alter this behavior by passing additional options, which you will find in the GitHub repository of the library, listed in the <em class="italic">Further reading</em> section.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Navigate to the <code class="inlineCode">dist</code> folder of the Angular CLI workspace. You will find a folder called <code class="inlineCode">my-editor-{OS}</code>, where <code class="inlineCode">{OS}</code> is your current OS and its architecture. For example, in Windows, it will be <code class="inlineCode">my-editor-win32-x64</code>. Open the folder, and you will get the following files:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18465_05_07.png" alt="Figure 5.6 – Application package (Windows)"/></figure>
    <p class="packt_figref">Figure 5.7 – Application package (Windows)</p>
    <p class="normal">In the <a id="_idIndexMarker300"/>preceding screenshot, the <code class="inlineCode">my-editor.exe</code> file is the executable file of our desktop application. Our application code is not included in this file but in the <code class="inlineCode">app.asar</code> file, which exists in the <code class="inlineCode">resources</code> folder.</p>
    <p class="normal">Run the executable file, and the desktop application should open normally. You can take the whole folder and upload it to a server, or distribute it by any other means. Your WYSIWYG editor can now reach many more users, such as those that are offline most of the time. Awesome!</p>
    <h1 id="_idParaDest-96" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we built a WYSIWYG editor for the desktop using Angular and Electron. Initially, we created an Angular application and added <code class="inlineCode">ngx-wig</code>, a popular Angular WYSIWYG library. Then, we learned how to build an Electron application and implemented a communication mechanism to exchange data between the Angular and Electron applications. Finally, we learned how to bundle our application for packaging and get it ready for distribution.</p>
    <p class="normal">In the next chapter, we will learn how to build a mobile photo geotagging application with Angular and Ionic.</p>
    <h1 id="_idParaDest-97" class="heading-1">Practice questions</h1>
    <p class="normal">Let’s take a look at a few practice questions:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Which class is responsible for creating a desktop window in Electron?</li>
      <li class="numberedList">How do we communicate between the main and renderer processes in Electron?</li>
      <li class="numberedList">Which flags enable the use of Node.js in the renderer process?</li>
      <li class="numberedList">How do we load Electron in an Angular application?</li>
      <li class="numberedList">Which interface do we use to interact with Electron in an Angular application?</li>
      <li class="numberedList">How do we pass data to the main Electron process from an Angular application?</li>
      <li class="numberedList">Which package do we use for filesystem manipulation in Electron?</li>
      <li class="numberedList">Which library do we use to package an Electron application?</li>
    </ol>
    <h1 id="_idParaDest-98" class="heading-1">Further reading</h1>
    <p class="normal">Here are some links to build upon what we learned in the chapter:</p>
    <ul>
      <li class="bulletList">Electron: <a href="https://www.electronjs.org"><span class="url">https://www.electronjs.org</span></a></li>
      <li class="bulletList">Electron quick start: <a href="https://www.electronjs.org/docs/tutorial/quick-start"><span class="url">https://www.electronjs.org/docs/tutorial/quick-start</span></a></li>
      <li class="bulletList"><code class="inlineCode">ngx-wig</code>: <a href="https://www.npmjs.com/package/ngx-wig"><span class="url">https://www.npmjs.com/package/ngx-wig</span></a> </li>
      <li class="bulletList">Webpack configuration: <a href="https://webpack.js.org/configuration"><span class="url">https://webpack.js.org/configuration</span></a></li>
      <li class="bulletList"><code class="inlineCode">ts-loader</code>: <a href="https://webpack.js.org/guides/typescript"><span class="url">https://webpack.js.org/guides/typescript</span></a></li>
      <li class="bulletList"><code class="inlineCode">ngx-electronyzer</code>: <a href="https://www.npmjs.com/package/ngx-electronyzer"><span class="url">https://www.npmjs.com/package/ngx-electronyzer</span></a> </li>
      <li class="bulletList">Filesystem API: <a href="https://nodejs.org/api/fs.html"><span class="url">https://nodejs.org/api/fs.html</span></a></li>
      <li class="bulletList"><code class="inlineCode">electron-packager</code>: <a href="https://www.npmjs.com/package/electron-packager"><span class="url">https://www.npmjs.com/package/electron-packager</span></a> </li>
      <li class="bulletList"><code class="inlineCode">concurrently</code>: <a href="https://www.npmjs.com/package/concurrently"><span class="url">https://www.npmjs.com/package/concurrently</span></a> </li>
    </ul>
  </div>
</body></html>