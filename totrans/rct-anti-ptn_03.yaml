- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Organizing Your React Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织你的 React 应用程序
- en: Welcome to a chapter dedicated to unraveling the various strategies to structure
    a React project. Here, we’ll take a step beyond code and delve into the fascinating
    world of application architecture – an essential aspect of software development
    that often doesn’t receive as much attention in the frontend world as it should.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到一个专门探讨如何构建 React 项目的策略的章节。在这里，我们将超越代码，深入到应用架构的迷人世界——这是软件开发的一个基本方面，在前端领域往往没有得到应有的关注。
- en: In this chapter, you will learn about different React project structuring strategies
    – including the feature-based structure, component-based structure, atomic design
    structure, and **Model-View-ViewModel** (**MVVM**) structure – and the unique
    advantages and potential pitfalls that each approach brings to the table. You’ll
    also be exposed to practical examples of these structures, gain insights into
    when to use one over another, and explore the trade-offs that come with each decision.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解不同的 React 项目结构策略——包括基于功能的结构、基于组件的结构、原子设计结构和 **模型-视图-视图模型**（**MVVM**）结构——以及每种方法带来的独特优势和潜在陷阱。你还将接触到这些结构的实际例子，了解何时使用一种而非另一种，并探索每个决策带来的权衡。
- en: But why should we care about project structure in the first place? A well-structured
    project can significantly enhance code maintainability, make it easier for new
    team members to understand the system and improve scalability, and even influence
    the overall success of the project. In contrast, an inefficient structure can
    lead to code smells and increased complexity, and it can become a source of technical
    debt.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们首先应该关心项目结构呢？一个结构良好的项目可以显著提高代码的可维护性，使新团队成员更容易理解系统，并提高可扩展性，甚至影响项目的整体成功。相反，一个低效的结构可能导致代码问题、增加复杂性，并可能成为技术债务的来源。
- en: By understanding these structuring strategies, you’ll be better equipped to
    make decisions that can have a long-lasting impact on your project’s health and
    success. You’ll be able to assess your project’s specific needs and constraints
    and use these strategies as a guiding light, enabling you to create a structure
    that improves code quality, fosters a productive development environment, and
    ultimately leads to a successful project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些结构策略，你将更好地做出决策，这些决策可以对项目的健康和成功产生长远的影响。你将能够评估你项目的具体需求和限制，并利用这些策略作为指导，使你能够创建一个提高代码质量、促进高效开发环境，并最终导致项目成功的结构。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the problem of a less-structured project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解结构不清晰的项目问题
- en: Understanding the complications of frontend applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解前端应用程序的复杂性
- en: Exploring common structures in React applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 React 应用程序中的常见结构
- en: Keeping your project structure organized
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持项目结构有序
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch3](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch3).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个 GitHub 仓库来托管本书中讨论的所有代码。对于本章，你可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch3](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch3)找到推荐的架构。
- en: Understanding the problem of a less-structured project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解结构不清晰的项目问题
- en: 'The rapid growth of a project can be astonishing, leading to a sense of things
    spiraling out of control. Initializing a frontend project is typically straightforward,
    and for small-scale projects, there may be little concern regarding file structure
    since the number of files to manage is minimal. However, as the project expands,
    the need for proper file organization becomes apparent:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的快速增长可能会令人惊讶，导致事物失控的感觉。初始化前端项目通常是直接的，对于小型项目，由于要管理的文件数量很少，因此对文件结构的关注可能很小。然而，随着项目的扩展，对适当文件组织的需求变得明显：
- en: '![Figure 3.1: A simple project might not need a structure](img/B21103_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：一个简单的项目可能不需要结构](img/B21103_03_01.jpg)'
- en: 'Figure 3.1: A simple project might not need a structure'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：一个简单的项目可能不需要结构
- en: 'The problem with having a less-structured project is that it can lead to several
    challenges and difficulties in managing and maintaining the code base effectively.
    Some of the key problems that arise from a lack of structure are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个结构较松散的项目的问题在于，它可能导致管理和维护代码库的有效性出现几个挑战和困难。以下是一些由于缺乏结构而产生的主要问题：
- en: '**Code disorganization**: Without a clear structure, it becomes harder to locate
    specific code files or components. This can result in wasted time and effort spent
    searching for relevant code, especially as the project becomes larger.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码组织混乱**: 没有清晰的架构，定位特定的代码文件或组件变得更加困难。这可能导致在寻找相关代码时浪费时间和精力，尤其是在项目规模扩大时。'
- en: '**Poor code reusability**: Without a proper structure, it becomes challenging
    to identify reusable components or functions. This can lead to code duplication
    and a lack of consistency, making it harder to maintain and update the code base
    in the long run.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码复用性差**: 没有合适的结构，识别可重用组件或函数变得具有挑战性。这可能导致代码重复和一致性不足，长期来看，使得维护和更新代码库变得更加困难。'
- en: '**Difficulty in collaboration**: When team members are working on a less-structured
    project, it becomes harder to understand and navigate each other’s code. This
    can lead to communication gaps, slower development, and an increased risk of introducing
    bugs or conflicts.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作困难**: 当团队成员在一个结构较松散的项目上工作时，理解和导航彼此的代码变得更加困难。这可能导致沟通差距、开发速度减慢，以及引入错误或冲突的风险增加。'
- en: '**Scalability issues**: As the project expands and new features are added,
    the lack of structure can make it challenging to integrate new components seamlessly.
    This can result in a tangled code base that is difficult to extend or modify,
    leading to decreased productivity and increased development time.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性问题**: 随着项目的扩展和新功能的添加，缺乏结构可能会使无缝集成新组件变得具有挑战性。这可能导致难以扩展或修改的混乱代码库，从而导致生产力下降和开发时间增加。'
- en: '**Maintenance complexity**: Without a clear organization, maintaining the code
    base becomes more complex. Making changes or fixing issues can become a time-consuming
    task as there may be a lack of consistency in how code is structured or named.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护复杂性**: 没有清晰的组织，维护代码库变得更加复杂。进行更改或修复问题可能成为耗时的工作，因为代码的结构或命名可能缺乏一致性。'
- en: Before proposing a recommended project structure, let’s look at the typical
    components of a modern frontend project. Understanding these components will provide
    a foundation for designing an effective project structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在提出推荐的项目结构之前，让我们先看看现代前端项目的典型组件。了解这些组件将为设计有效的项目结构提供基础。
- en: Understanding the complications of frontend applications
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解前端应用的复杂性
- en: In a medium-sized frontend project, you may be surprised by the multitude of
    components required for its successful implementation. Alongside the core features,
    numerous other elements contribute to the project’s functionality.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个中等规模的前端项目中，你可能会对成功实施所需的众多组件感到惊讶。除了核心功能外，还有许多其他元素有助于项目的功能实现。
- en: 'The folder structure of a React project provides a glimpse into the various
    aspects you’ll need to manage within a typical React code base:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React 项目的文件夹结构为你在典型的 React 代码库中需要管理的各个方面提供了一个概览：
- en: '**Source code**: This is the heart of your application and contains the JavaScript/TypeScript
    files that contain your application’s logic, HTML files for structure, and style
    files for appearance. Everything that defines the operation and user interface
    of your application is found here.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码**: 这是应用的核心，包含包含应用逻辑的 JavaScript/TypeScript 文件、用于结构的 HTML 文件和用于外观的样式文件。定义应用操作和用户界面的所有内容都可以在这里找到。'
- en: '**Assets**: This category holds all the static files, such as images, videos,
    and fonts, that are utilized by your application. These files are essential in
    enhancing the visual experience and interaction of your application, contributing
    to its overall look and feel.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产**: 这个类别包含了应用中使用的所有静态文件，例如图片、视频和字体。这些文件对于增强应用的视觉体验和交互至关重要，有助于提升应用的整体外观和感觉。'
- en: '`package.json` and environment-specific variables to the rules for building
    your project, these files are crucial for the operation and deployment of your
    application.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json` 和环境特定的变量到构建项目的规则中，这些文件对于应用的运行和部署至关重要。'
- en: '**Tests**: This category is dedicated to ensuring the correctness and stability
    of your application. It holds all the unit, integration, and **end-to-end tests**
    that simulate user behavior, validate interactions, and check the functionality
    of your application, helping to catch and prevent potential bugs.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：这个类别致力于确保应用程序的正确性和稳定性。它包含所有单元、集成和**端到端测试**，这些测试模拟用户行为、验证交互并检查应用程序的功能，有助于捕捉和预防潜在的错误。'
- en: '`README` file providing an overview of the project to the API documentation
    and the style guide for coding, these documents help maintain consistency, understanding,
    and ease of use for anyone interacting with the project.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README` 文件提供了对项目的概述，包括 API 文档和编码风格指南，这些文档有助于维护一致性、理解和易用性，对于与项目交互的任何人都有帮助。'
- en: '**Build artifacts**: These are the outputs of the build process, including
    bundled and optimized JavaScript, CSS, and HTML files ready for deployment, and
    other temporary or diagnostic files that help debug build issues. They’re key
    to distributing your application to end users.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建工件**：这是构建过程的输出，包括打包和优化的 JavaScript、CSS 和 HTML 文件，以及准备部署的文件，以及其他帮助调试构建问题的临时或诊断文件。它们对于将您的应用程序分发给最终用户至关重要。'
- en: '**Development tools and configurations**: This is the toolkit that enforces
    code quality, formatting, and version control and facilitates automated testing
    and deployment processes. They work in the background, ensuring a smooth, error-free,
    and efficient development process.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发工具和配置**：这是强制执行代码质量、格式化和版本控制，并促进自动化测试和部署流程的工具包。它们在后台工作，确保开发过程平稳、无错误且高效。'
- en: Collectively, these diverse components form the foundation of a typical React
    code base, highlighting the complexity and breadth of considerations involved
    in medium-sized frontend projects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多样化的组件共同构成了典型 React 代码库的基础，突显了中型前端项目中涉及的复杂性和广泛性。
- en: 'Exploring each feature folder can be an enjoyable experience as it unravels
    a variety of elements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 探索每个功能文件夹可以是一次愉快的体验，因为它会展开各种元素：
- en: Common components, such as modal dialogs, navigation menus, buttons, and cards
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用组件，如模态对话框、导航菜单、按钮和卡片
- en: Dedicated components tailored to specific features, such as `SpecialOffer` for
    special offers that only display on the menu page or `PayWithApple` for pay with
    ApplePay
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门针对特定功能的组件，例如 `SpecialOffer`（仅在菜单页面上显示的特殊优惠）或 `PayWithApple`（使用 ApplePay 支付）
- en: Style definitions using CSS-in-JS or SCSS/LESS code
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CSS-in-JS 或 SCSS/LESS 代码定义样式
- en: Various types of testing code, including unit tests and browser tests
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种类型的测试代码，包括单元测试和浏览器测试
- en: Calculation logic encapsulated within utility/helper functions
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装在实用/辅助函数内的计算逻辑
- en: Custom Hooks for reusable functionality
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于可重用功能的自定义钩子
- en: Contexts for security, **internationalization** (**i18n**), and other specific
    needs
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全、**国际化**（**i18n**）和其他特定需求的上下文
- en: Additional configuration files such as `eslint config`, `jest config`, `webpack
    settings`, and more
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 `eslint config`、`jest config`、`webpack settings` 等更多的附加配置文件
- en: Given the multitude of files, how can we arrange them in a manner that facilitates
    easy navigation and quick access for modifications? While there is no one-size-fits-all
    solution, consistently organizing the code base can greatly assist in this endeavor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到文件众多，我们如何以方便导航和快速修改的方式组织它们？虽然没有一种适合所有情况的解决方案，但持续地组织代码库可以极大地帮助这一努力。
- en: Consistency is paramount when it comes to naming and structuring code elements.
    Regardless of the approach that’s chosen, it is crucial to maintain uniformity
    throughout the project. For example, if you decide to place style files alongside
    their respective components, it is essential to adhere to this convention across
    all components in the code base.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名和结构代码元素方面，一致性至关重要。无论选择哪种方法，在整个项目中保持一致性都是至关重要的。例如，如果您决定将样式文件放置在与它们相应的组件旁边，那么在代码库中的所有组件中坚持这一约定是至关重要的。
- en: Similarly, if a `tests` folder is being used to house test files, ensure to
    maintain this convention consistently across the entire code base. For instance,
    other naming patterns such as `__tests__` or `specs` should be avoided to prevent
    confusion and maintain uniformity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果使用 `tests` 文件夹来存放测试文件，确保在整个代码库中一致地维护这一约定。例如，应避免使用 `__tests__` 或 `specs`
    等其他命名模式，以防止混淆并保持一致性。
- en: Having grasped the complexity inherent in medium to large-sized projects, and
    acknowledging the challenges that a disorganized code base can pose, it’s time
    we explore some tried-and-tested approaches to structuring our code. These strategies
    aim to simplify the development process and make life easier for developers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了中到大型项目固有的复杂性，并认识到无序的代码库可能带来的挑战后，是时候探索一些经过验证的方法来构建我们的代码结构了。这些策略旨在简化开发过程，并为开发者提供便利。
- en: Exploring common structures in React applications
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索React应用程序中的常见结构
- en: 'There are many different ways of organizing a large React application. In the
    following subsections, we will discuss the four most common structures:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 组织大型React应用程序有许多不同的方式。在接下来的小节中，我们将讨论四种最常见结构：
- en: Feature-based structure
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于功能的结构
- en: Component-based structure
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件化结构
- en: Atomic design structure
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子化设计结构
- en: MVVM structure
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM结构
- en: Each structure has its own set of benefits and drawbacks, and the choice depends
    on the specific requirements and complexity of the project. Sometimes, we might
    need to mix them in some way so that they fit our project-specific needs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每种结构都有其自身的优点和缺点，选择取决于项目的具体需求和复杂性。有时，我们可能需要以某种方式混合它们，以便它们符合我们项目的特定需求。
- en: To explore these different structure methods further, we’ll use an online shopping
    application as an example since it’s relatively complicated and you should have
    some familiarity with that domain already. The application also contains elements
    such as API calls, routers, and state management.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探索这些不同的结构方法，我们将以在线购物应用程序为例，因为它相对复杂，并且你应该已经对该领域有所了解。该应用程序还包含API调用、路由和状态管理等元素。
- en: Feature-based structure
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于功能的结构
- en: '**Feature-based structure** means the application is organized based on features
    or modules. Each feature contains its own set of components, views, API calls,
    and state management, allowing for clear separation and encapsulation of functionality.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于功能的结构**意味着应用程序是根据功能或模块组织的。每个功能都包含其自己的组件集、视图、API调用和状态管理，从而实现功能的清晰分离和封装。'
- en: 'With a feature-based architecture in the context of online shopping, you can
    organize your files and folders as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线购物的背景下，采用基于功能的架构，你可以按照以下方式组织你的文件和文件夹：
- en: '![Figure 3.2: Feature-based structure](img/B21103_03_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：基于功能的结构](img/B21103_03_02.jpg)'
- en: 'Figure 3.2: Feature-based structure'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：基于功能的结构
- en: 'Let’s take a closer look at this structure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个结构：
- en: The `features` directory represents different features of the application, such
    as `Home`, `Cart`, `ProductDetails`, `Checkout`, `Profile`, and more
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`features` 目录代表应用程序的不同功能，例如 `Home`、`Cart`、`ProductDetails`、`Checkout`、`Profile`
    等'
- en: Each feature has a folder containing `components`, `containers`, `pages`, `services`,
    `types`, and `utils` related to that feature
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个功能都有一个包含与该功能相关的 `components`、`containers`、`pages`、`services`、`types` 和 `utils`
    的文件夹
- en: The `shared` directory contains reusable `components`, `containers`, `services`,
    `types`, and `utils` that can be shared across multiple features
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared` 目录包含可重用的 `components`、`containers`、`services`、`types` 和 `utils`，这些可以在多个功能之间共享'
- en: The `api` directory houses modules for making API calls
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api` 目录包含用于发起API调用的模块'
- en: The `store` directory contains modules for state management (for example, Redux)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store` 目录包含状态管理模块（例如，Redux）'
- en: The `router` directory contains the routing configuration and related components
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router` 目录包含路由配置和相关组件'
- en: The `App.tsx` file serves as the entry point of the application
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.tsx` 文件是应用程序的入口点'
- en: 'This method has the following benefits:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有以下优点：
- en: '**Clear separation of concerns**: Each feature has a folder, making it easier
    to locate and modify related code'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点的清晰分离**：每个功能都有一个文件夹，便于定位和修改相关代码'
- en: '**Modularity**: Features are self-contained, allowing for easier testing, maintenance,
    and reuse'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：功能是自包含的，便于测试、维护和重用'
- en: '**Scalability**: New features can be added without directly impacting existing
    code'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：添加新功能时不会直接影响现有代码'
- en: '**Team collaboration**: Developers can work on different features concurrently
    with minimal conflicts'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队协作**：开发者可以同时在不产生最小冲突的情况下工作在不同的功能上'
- en: 'However, it has the following drawback:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它有以下缺点：
- en: '**Potential duplication**: Features may share similar components or logic,
    leading to some duplication. Careful planning and refactoring can help mitigate
    this.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在的重复**：功能可能共享相似组件或逻辑，导致一些重复。仔细规划和重构可以帮助减轻这种情况。'
- en: Component-based structure
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于组件的结构
- en: '**Component-based structure** means the application is organized around reusable
    components. Components are categorized based on their functionality and can be
    composed together to build larger views.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于组件的结构**意味着应用是围绕可重用组件组织的。组件根据其功能进行分类，可以组合在一起构建更大的视图。'
- en: 'With a component-based architecture in the context of online shopping, you
    can organize your files and folders as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线购物背景下，基于组件的架构下，你可以按照以下方式组织你的文件和文件夹：
- en: '![Figure 3.3: Component-based structure](img/B21103_03_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：基于组件的结构](img/B21103_03_03.jpg)'
- en: 'Figure 3.3: Component-based structure'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：基于组件的结构
- en: 'Let’s take a closer look at this structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个结构：
- en: The `components` folder contains individual components related to various features
    of the online shopping application. Each component is organized into a folder,
    which may contain child components as necessary.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components` 文件夹包含与在线购物应用各种功能相关的单个组件。每个组件都组织到一个文件夹中，可能包含必要的子组件。'
- en: The `routes` folder handles frontend routing in the application. It includes
    the main `AppRouter.tsx` file, which configures the routing logic, and the `routes.tsx`
    file, which defines the individual routes and their corresponding components.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes` 文件夹处理应用的前端路由。它包括配置路由逻辑的 `AppRouter.tsx` 主文件，以及定义单个路由及其对应组件的 `routes.tsx`
    文件。'
- en: The `api` folder contains separate files for different API domains or functionalities.
    These files, such as `products.ts`, `cart.ts`, `auth.ts`, and `payment.ts`, handle
    the API calls related to their respective domains.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api` 文件夹包含针对不同 API 域或功能的单独文件。这些文件，如 `products.ts`、`cart.ts`、`auth.ts` 和 `payment.ts`，处理与其相应域相关的
    API 调用。'
- en: The example also assumes the use of a state management library such as Redux
    or React Context API for managing the global application state.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该示例还假设使用 Redux 或 React Context API 等状态管理库来管理全局应用状态。
- en: 'This method has the following benefits:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有以下优点：
- en: '**Modularity**: The component-based structure promotes modularity by organizing
    components into separate files and folders based on their functionality. This
    enhances code maintainability and reusability.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：基于功能的组件结构通过将组件组织到单独的文件和文件夹中，促进了模块化。这增强了代码的可维护性和可重用性。'
- en: '**Separation of concerns**: Each component focuses on its specific functionality,
    leading to clearer code and easier debugging. The separation of concerns improves
    code readability and maintainability.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：每个组件专注于其特定的功能，导致代码更清晰且易于调试。关注点分离提高了代码的可读性和可维护性。'
- en: '**Code reusability**: With components organized in a modular structure, it
    becomes easier to reuse components across the application or in future projects,
    leading to improved development efficiency.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重用性**：通过模块化组织组件，可以更容易地在应用或未来的项目中重用组件，从而提高开发效率。'
- en: 'However, it has the following drawbacks:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它有以下缺点：
- en: '**Project complexity**: As the project grows, maintaining a complex component
    structure can become challenging. It requires careful planning and adherence to
    best practices to avoid component sprawl and keep the structure manageable.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目复杂性**：随着项目的增长，维护复杂的组件结构可能会变得具有挑战性。它需要仔细规划和遵循最佳实践，以避免组件蔓延并保持结构可管理。'
- en: '**Learning curve**: The initial learning curve for component-based development
    and TypeScript may be steeper for developers who are new to these concepts. However,
    the benefits that are gained in terms of code organization and maintainability
    outweigh the initial learning.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线**：对于新接触这些概念的开发者来说，基于组件的开发和 TypeScript 的初始学习曲线可能更陡峭。然而，在代码组织和可维护性方面获得的好处超过了初始的学习成本。'
- en: '`components` folder, you may find smaller elements that are identical or closely
    resemble those in other component folders. The more you break down these components
    into finer parts, the greater the likelihood of identifying components that can
    be reused. When such reusable components emerge, it’s a good practice to place
    them in a “shared” folder, like what is shown in a feature-based structure.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中，你可能找到与其它组件文件夹中相同或相似的小元素。你将这些组件分解得越细，就越有可能识别出可重用的组件。当出现这样的可重用组件时，将它们放置在“共享”文件夹中是一个好习惯，就像在基于功能的结构中展示的那样。
- en: Atomic design structure
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子设计结构
- en: '**Atomic design** is a methodology for designing and organizing user interfaces.
    It emphasizes the construction of user interfaces by breaking them down into small,
    reusable components called atoms, which are combined to form molecules, organisms,
    templates, and pages.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子设计**是一种设计和组织用户界面的方法。它强调通过将用户界面分解成称为原子的小型、可重用组件来构建用户界面，这些原子组合成分子、有机体、模板和页面。'
- en: The key idea behind atomic design is to create a systematic approach to building
    UI components that encourages reusability, scalability, and maintainability. It
    provides a clear structure for organizing and naming components, making it easier
    to understand and navigate the UI code base.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 原子设计背后的关键思想是创建一种系统化的方法来构建UI组件，该方法鼓励可重用性、可扩展性和可维护性。它为组织和命名组件提供了一个清晰的框架，使得理解和使用UI代码库变得更加容易。
- en: 'Here’s how the atomic design methodology categorizes UI components:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原子设计方法对UI组件的分类方式：
- en: '**Atoms**: Atoms are the smallest building blocks of a UI and represent individual
    elements such as buttons, inputs, icons, or labels. They are typically simple
    and self-contained.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子**：原子是UI的最小构建块，代表单个元素，如按钮、输入、图标或标签。它们通常是简单且自包含的。'
- en: '**Molecules**: Molecules are combinations of atoms and represent more complex
    UI components. They encapsulate a group of atoms working together to form a functional
    unit, such as a form field or a navigation bar.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分子**：分子是原子的组合，代表更复杂的UI组件。它们封装了一组协同工作的原子，形成一个功能单元，例如表单字段或导航栏。'
- en: '**Organisms**: Organisms are larger components that combine molecules and/or
    atoms to create more significant sections of a UI. They represent distinct sections
    of a user interface, such as a header, sidebar, or card component.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有机体**：有机体是较大的组件，它们结合分子和/或原子来创建UI的更重要的部分。它们代表用户界面的不同部分，如页眉、侧边栏或卡片组件。'
- en: '**Templates**: Templates provide a layout structure for arranging organisms
    and/or molecules. They define the overall skeleton of a page or a specific section
    of a UI.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：模板为安排有机体和/或分子提供布局结构。它们定义了页面或UI特定部分的总体骨架。'
- en: '**Pages**: Pages represent complete user interface screens that are composed
    of templates, organisms, molecules, and atoms. They represent the final output
    visible to the user.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面**：页面代表由模板、有机体、分子和原子组成的完整用户界面屏幕。它们代表用户可见的最终输出。'
- en: 'With an atomic design architecture in the context of online shopping, you can
    organize your files and folders as follows:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在在线购物背景下，使用原子设计架构，你可以按照以下方式组织你的文件和文件夹：
- en: '![Figure 3.4: Atomic design structure](img/B21103_03_04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：原子设计结构](img/B21103_03_04.jpg)'
- en: 'Figure 3.4: Atomic design structure'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：原子设计结构
- en: 'Let’s take a closer look at this structure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个结构：
- en: The `atoms`, `molecules`, `organisms`, `templates`, and `pages` directories
    represent the different levels of component composition and abstraction
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atoms`、`molecules`、`organisms`、`templates`和`pages`目录代表组件组合和抽象的不同层次。'
- en: The `api` directory contains the API-related files for making API calls
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`目录包含用于进行API调用的API相关文件。'
- en: The `views` directory contains the individual views that render the components
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`目录包含渲染组件的单独视图。'
- en: The `routes` directory handles the routing configuration
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`目录处理路由配置。'
- en: 'This method has the following benefits:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有以下优点：
- en: '**Reusability**: Components can be easily reused across the application, promoting
    code efficiency'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：组件可以轻松地在应用程序中重用，从而提高代码效率。'
- en: '**Consistency**: The structure encourages a consistent design language and
    UI pattern'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这种结构鼓励一致的设计语言和UI模式。'
- en: '**Scalability**: The modular approach allows for easy scaling and the addition
    of new components'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：模块化方法允许轻松扩展并添加新组件。'
- en: '**Maintainability**: Components are organized in a logical hierarchy, making
    them easier to locate and update'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：组件按照逻辑层次结构组织，这使得它们更容易定位和更新'
- en: '**Collaboration**: The atomic design structure facilitates collaboration between
    designers and developers as it provides a common language for discussing UI components'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：原子设计结构促进了设计师和开发者之间的协作，因为它为讨论 UI 组件提供了一个共同的语言'
- en: 'However, it has the following drawbacks:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它有以下缺点：
- en: '**Learning curve**: It may require some initial learning and adaptation to
    understand and implement the atomic design principles effectively'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线**：可能需要一些初始的学习和适应，才能有效地理解和实现原子设计原则'
- en: '**Complexity**: As the application grows, managing a large number of components
    and their relationships can become challenging'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：随着应用程序的增长，管理大量组件及其关系可能会变得具有挑战性'
- en: '**Overengineering**: It’s important to strike a balance between component reusability
    and overengineering as excessive abstraction can introduce unnecessary complexity'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度设计**：在组件可重用性和过度设计之间取得平衡很重要，因为过度的抽象可能会引入不必要的复杂性'
- en: The MVVM structure
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM 结构
- en: 'The **MVVM structure** is a software architectural pattern that’s primarily
    used in building user interfaces:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVVM 结构** 是一种主要用于构建用户界面的软件架构模式：'
- en: The *Model* represents the actual data and/or information we are dealing with.
    This could be a database, a file, a web service, or even a simple object.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Model** 代表我们实际处理的数据和/或信息。这可能是数据库、文件、Web 服务，甚至是简单的对象。'
- en: The *View* is what the user sees and interacts with. It’s the user interface
    that presents the Model to the user.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**View** 是用户看到并与之交互的内容。它是向用户展示模型的用户界面。'
- en: The *ViewModel* is where most of the logic resides in this pattern. It is an
    abstraction of the View that exposes public properties and commands, bridging
    the gap between the View and the Model, and processes the data from the Model
    into a format that is easy for the View to handle. It can perform operations on
    the data and decide how it should be presented to the View.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewModel** 是在这个模式中逻辑主要存在的位置。它是视图的抽象，暴露公共属性和命令，架起了视图和模型之间的桥梁，并将模型中的数据处理成视图易于处理的形式。它可以对数据进行操作并决定如何将其呈现给视图。'
- en: 'To structure a React application with the MVVM architecture in the context
    of online shopping, you can organize your files and folders as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线购物背景下，使用 MVVM 架构来结构化 React 应用程序，你可以按照以下方式组织你的文件和文件夹：
- en: '![Figure 3.5: The MVVM structure](img/B21103_03_05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：MVVM 结构](img/B21103_03_05.jpg)'
- en: 'Figure 3.5: The MVVM structure'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：MVVM 结构
- en: 'Let’s take a closer look at this structure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个结构：
- en: The `components` directory contains reusable UI components, organized by their
    respective features
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components` 目录包含按其相应功能组织的可重用 UI 组件'
- en: The `models` directory includes the data models or entities representing the
    application’s domain objects, such as `CartItemModel` and `ProductModel`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models` 目录包含表示应用程序领域对象的数据库、文件、Web 服务或简单对象的数据模型或实体，例如 `CartItemModel` 和 `ProductModel`'
- en: The `viewmodels` directory holds the Hooks responsible for managing the state,
    logic, and interactions of the views
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewmodels` 目录包含负责管理视图状态、逻辑和交互的钩子'
- en: The `services` directory contains modules for handling API calls and other external
    services
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services` 目录包含处理 API 调用和其他外部服务的模块'
- en: The `views` directory includes the view components that display the UI based
    on the `ViewModel` state
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views` 目录包括基于 `ViewModel` 状态显示 UI 的视图组件'
- en: The `routers` directory houses the routing configuration and components
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routers` 目录包含路由配置和组件'
- en: The `App.tsx` file serves as the entry point of the application
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.tsx` 文件作为应用程序的入口点'
- en: 'This method has the following benefits:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有以下优点：
- en: '**Separation of concerns**: The ViewModel separates the business logic from
    the UI components, promoting cleaner and more maintainable code'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：ViewModel 将业务逻辑与 UI 组件分离，促进了更干净、更易于维护的代码'
- en: '**Testability**: The ViewModel can be easily unit tested without the need for
    the actual UI components'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：ViewModel 可以很容易地进行单元测试，而无需实际的 UI 组件'
- en: '**Reusability**: Components, models, and services can be reused across different
    features and views'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：组件、模型和服务可以在不同的功能和视图中重用'
- en: '**Scalability**: New features and views can be added while reusing existing
    ViewModel and service modules'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：可以在重用现有的 ViewModel 和服务模块的同时添加新功能和视图'
- en: 'However, it has the following drawbacks:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它有以下缺点：
- en: '**Complexity**: Implementing the MVVM pattern may introduce additional layers
    of abstraction and complexity to the application, especially for smaller projects'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：实现MVVM模式可能会给应用程序引入额外的抽象层和复杂性，尤其是在较小的项目中'
- en: '**Learning curve**: Developers need to understand the concepts and principles
    of MVVM to effectively structure and manage the application'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线**：开发者需要理解MVVM的概念和原则，以有效地构建和管理应用程序'
- en: Now that we have explored these four popular structures, let’s delve into the
    continuous evolution of our application’s structure. This ongoing process ensures
    that the structure remains beneficial for developers in terms of easy navigation,
    seamless addition of new features, and the ability to maintain scalability over
    time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了这四种流行的结构，让我们深入了解我们应用程序结构的持续演变。这一持续过程确保结构在开发者方面保持有益，便于导航，无缝添加新功能，并能够在长时间内保持可扩展性。
- en: Keeping your project structure organized
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持您的项目结构有序
- en: The feature-based structure is always a good starting point. As the project
    expands and patterns of duplication start to emerge, an additional layer can be
    introduced to eliminate redundancy.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 基于功能的结构始终是一个好的起点。随着项目的扩展和重复模式的出现，可以引入一个额外的层来消除冗余。
- en: 'For instance, let’s use the online shopping application again. It contains
    various pages:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们再次使用在线购物应用程序。它包含各种页面：
- en: Home page
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页
- en: Log in/sign up
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录/注册
- en: Store address search
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储地址搜索
- en: Product list
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品列表
- en: Shopping cart
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: Order details
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单详情
- en: Payment
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付
- en: Profile
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人资料
- en: Coupon
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优惠券
- en: In the initial stages, organizing pages based on their features is a common
    approach. We can create a folder for each feature and put all the related components,
    styles, and tests inside that folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始阶段，根据功能组织页面是一种常见的方法。我们可以为每个功能创建一个文件夹，并将所有相关组件、样式和测试放入该文件夹中。
- en: Implementing the initial structure
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施初始结构
- en: 'The initial folder structure in the `src` directory is quite straightforward
    and follows a feature-based approach, with each page having its own folder:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`目录中的初始文件夹结构非常简单，遵循基于功能的方法，每个页面都有自己的文件夹：
- en: '[PRE0]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, as the project evolves, you may encounter duplication of components
    or functionalities across different pages. To address this, it becomes necessary
    to introduce an additional layer of abstraction.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着项目的演变，您可能会在不同页面之间遇到组件或功能重复的情况。为了解决这个问题，引入一个额外的抽象层变得必要。
- en: For example, if both the `Login` and `Order` pages require a `Button` component,
    it would be impractical to have separate implementations of the button on each
    page. Instead, you can extract the `Button` component into a separate layer, such
    as a components or shared folder. This way, `Button` can be reused across multiple
    pages without duplication.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`Login`和`Order`页面都需要一个`Button`组件，那么在每一页上分别实现按钮是不切实际的。相反，您可以将`Button`组件提取到一个单独的层，例如组件或共享文件夹。这样，`Button`就可以在多个页面之间重用，而不会出现重复。
- en: Adding an extra layer to remove duplicates
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加额外层以去除重复项
- en: By adding this extra layer, you promote reusability and maintainability in your
    code base. It helps in eliminating redundancy, streamlining development efforts,
    and ensuring consistency throughout the application. As the project expands, this
    modular approach allows for easy management and scalability, making it easier
    to add new features or make changes without impacting the entire code base.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这一额外层，您可以在代码库中提高可重用性和可维护性。这有助于消除冗余，简化开发工作，并确保应用程序的一致性。随着项目的扩展，这种模块化方法允许轻松管理并实现可扩展性，使得添加新功能或进行更改时不会影响整个代码库。
- en: 'So, you can create a `components` folder for all the reusable components and
    a `pages` folder for all the feature pages, like so:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以创建一个`components`文件夹来存放所有可重用组件，以及一个`pages`文件夹来存放所有功能页面，如下所示：
- en: '[PRE1]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the project expands, it becomes necessary to create a separate components
    folder to house reusable components that are shared across different pages. In
    this structure, each component is organized within its respective folder, promoting
    modularity and code reuse. Additionally, you can introduce nested folders to represent
    component hierarchies, such as the `Offer` folder, which contains a specific component
    called `SpecialOffer`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的扩展，有必要创建一个单独的组件文件夹来存放跨不同页面共享的可重用组件。在这种结构中，每个组件都组织在其各自的文件夹中，促进了模块化和代码重用。此外，你可以引入嵌套文件夹来表示组件层次结构，例如包含特定组件`SpecialOffer`的`Offer`文件夹。
- en: Alongside the `components` folder, you may need folders for other essential
    elements. The `pages` folder contains feature-specific pages, while the `hooks`
    folder houses React Hooks that provide reusable logic and functionality. The `context`
    folder is used for managing the global state and provides different contexts that
    can be shared throughout the application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`components`文件夹外，你可能还需要为其他基本元素创建文件夹。`pages`文件夹包含特定功能的页面，而`hooks`文件夹则存放React
    Hooks，它们提供可重用的逻辑和功能。`context`文件夹用于管理全局状态，并提供可以在整个应用程序中共享的不同上下文。
- en: It’s important to note that not all components need to be moved to the `components`
    folder. Only components that exhibit duplication across different pages should
    be lifted to the shared folder, ensuring that you maintain a balance between modularity
    and unnecessary complexity.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，并非所有组件都需要移动到`components`文件夹。只有那些在不同页面中表现出重复的组件才应该提升到共享文件夹，以确保在模块化和不必要的复杂性之间保持平衡。
- en: This file structure allows for better organization, code reuse, and scalability
    as the project grows. It promotes maintainability by reducing redundancy and ensuring
    consistency across the application. Additionally, having a separate folder for
    Hooks and contexts helps centralize related code and makes it easier to manage
    and maintain global state and reusable logic.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文件结构允许在项目增长时更好地组织、代码重用和可扩展性。它通过减少冗余并确保应用程序的一致性来促进可维护性。此外，为Hooks和上下文创建单独的文件夹有助于集中相关代码，并使管理全局状态和可重用逻辑变得更加容易。
- en: Naming files
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件命名
- en: In an individual component, there are different approaches to naming files,
    and each approach has its advantages and considerations. Let’s explore two approaches.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个组件中，命名文件有不同的方法，每种方法都有其优点和考虑因素。让我们探讨两种方法。
- en: Naming files with index.tsx and explicit component names
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用index.tsx和明确的组件名称命名文件
- en: 'In this approach, each file within the component folder has an explicit name
    that corresponds to the component it represents:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，组件文件夹内的每个文件都有一个明确的名称，与它所代表的组件相对应：
- en: '[PRE2]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `index.tsx` file serves as the default export file, allowing you to import
    the component from the folder directly. `Button.tsx` is the JSX for the component,
    and `Button.test.tsx` is the corresponding test file, while `style.css` defines
    CSS styles.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.tsx`文件作为默认导出文件，允许你直接从文件夹中导入组件。`Button.tsx`是组件的JSX，而`Button.test.tsx`是对应的测试文件，`style.css`定义CSS样式。'
- en: This approach promotes clear and self-descriptive filenames, making it easier
    to understand the purpose and content of each file. However, it can result in
    a long list of index files when browsing or searching for components in an editor
    or file explorer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法促进了清晰且自我描述的文件名，使得理解每个文件的目的和内容变得更容易。然而，在编辑器或文件浏览器中浏览或搜索组件时，可能会导致索引文件列表过长。
- en: Naming files with kebab case
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用短横线命名法命名文件
- en: 'In this approach, the files within the `components` folder are named using
    **kebab case**, a naming convention where words are lowercase and separated by
    hyphens. If there is only one word, simply use lowercase – this follows a consistent
    convention that’s used in the JavaScript community:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，`components`文件夹内的文件使用**短横线命名法**命名，这是一种命名约定，其中单词为小写，并由连字符分隔。如果只有一个单词，只需使用小写即可——这遵循JavaScript社区中使用的持续一致的约定：
- en: '[PRE3]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The filename of the component is explicitly named using kebab case (for example,
    `button.tsx`) to match the component’s name.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的文件名明确使用短横线命名法（例如，`button.tsx`）来匹配组件的名称。
- en: This approach maintains consistency with the convention of kebab case filenames
    and promotes a unified naming structure throughout the project. However, it may
    require specifying the filename explicitly when importing the component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与kebab case文件名约定保持一致，并在整个项目中促进统一的命名结构。然而，在导入组件时可能需要明确指定文件名。
- en: Both approaches have their merits, and the choice depends on personal preference
    and the project’s requirements or team conventions. It is crucial to establish
    and maintain consistency within the project to enhance collaboration and understanding
    among team members.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其优点，选择取决于个人偏好和项目需求或团队规范。在项目中建立和维护一致性对于增强团队成员之间的协作和理解至关重要。
- en: 'Either way, you can use ESlint and FolderLint to ensure your team has the same
    naming standard for files and folders. For example, the following screenshot shows
    that filenames should be in the kebab case and suggests changing `Button.tsx`
    into `button.tsx`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，您都可以使用ESLint和FolderLint来确保您的团队在文件和文件夹的命名标准上保持一致。例如，以下截图显示文件名应使用短横线分隔法，并建议将`Button.tsx`改为`button.tsx`：
- en: "![Figure 3.6: ESlint c\uFEFFhecks](img/B21103_03_06.jpg)"
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6：ESLint检查](img/B21103_03_06.jpg)'
- en: 'Figure 3.6: ESlint checks'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：ESLint检查
- en: Exploring a more customized structure
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索更定制化的结构
- en: As your application grows and different types of abstractions are added, it
    becomes necessary to organize the project structure accordingly. Relying solely
    on any previously discussed structure may not be ideal for your specific scenario.
    It’s often necessary to customize the structure so that it aligns well with your
    project’s needs. Remember, the primary goal of establishing a project structure
    is to simplify and streamline the development process for developers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长和不同类型抽象的增加，相应地组织项目结构变得必要。仅依赖于之前讨论的结构可能不适合您的特定场景。通常需要根据项目需求定制结构，以便与项目需求良好地匹配。记住，建立项目结构的主要目标是简化并优化开发过程。
- en: 'Starting with the feature-based structure, we need to adjust our current folder
    structure to the following folder structure to reflect this evolution:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从基于功能的结构开始，我们需要调整我们当前的文件夹结构到以下结构，以反映这种演变：
- en: '`api`: This folder represents the module or directory for managing API-related
    code, including functions for making network requests, handling responses, and
    interacting with the backend services.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`: 这个文件夹代表管理API相关代码的模块或目录，包括用于发起网络请求、处理响应以及与后端服务交互的函数。'
- en: '`components`: This folder contains reusable UI components that can be used
    across different pages or features of the application. It includes components
    such as `Accordion`, `Button`, `GenericCard`, `Modal`, `Offer`, and `StackView`.
    These components can be organized into subfolders based on their functionality
    or purpose.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`: 这个文件夹包含可重用的UI组件，可以在应用程序的不同页面或功能中使用。它包括`Accordion`、`Button`、`GenericCard`、`Modal`、`Offer`和`StackView`等组件。这些组件可以根据其功能或目的组织到子文件夹中。'
- en: '`context`: This folder represents the module or directory for managing React
    context, which allows for global state management and data sharing across components.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`: 这个文件夹代表管理React上下文的模块或目录，它允许跨组件进行全局状态管理和数据共享。'
- en: '`hooks`: This folder contains custom React Hooks that encapsulate reusable
    logic and behavior. These Hooks can be shared across different parts of the application.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hooks`: 这个文件夹包含封装可重用逻辑和行为的自定义React Hooks。这些Hooks可以在应用程序的不同部分之间共享。'
- en: '`mocks`: This folder holds mock data or mock implementations for testing purposes.
    It includes subfolders for `graphql` and `rest`, which represent mocks for GraphQL
    and REST APIs, respectively.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mocks`: 这个文件夹包含用于测试目的的模拟数据或模拟实现。它包括`graphql`和`rest`子文件夹，分别代表GraphQL和REST API的模拟。'
- en: '`pages`: This folder represents the different pages or features of the application.
    Each page or feature has a folder. The folders that are included are `Address`,
    `Home`, `Login`, `Order`, `Payment`, `Product`, `Profile`, `SignUp`, as well as
    their respective subfolders. The subfolders may contain additional components,
    Hooks, or context related to that specific page or feature.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages`: 这个文件夹代表应用程序的不同页面或功能。每个页面或功能都有一个文件夹。包含的文件夹有`Address`、`Home`、`Login`、`Order`、`Payment`、`Product`、`Profile`、`SignUp`以及它们各自的子文件夹。子文件夹可能包含与该特定页面或功能相关的附加组件、Hooks或上下文。'
- en: By structuring the project in this way, you can achieve a modular and organized
    code base that facilitates code reuse, separation of concerns, and scalability.
    Each directory represents a specific aspect of the application, making it easier
    to locate and manage code related to that particular functionality.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建项目，您可以实现模块化和组织化的代码库，这有助于代码重用、关注点分离和可扩展性。每个目录代表应用程序的特定方面，这使得定位和管理与该特定功能相关的代码变得更加容易。
- en: 'You can see this in the following figure, where we are returning to our shopping
    example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的图中看到这一点，我们回到了我们的购物示例：
- en: '![Figure 3.7: A mixed structure for an online shopping application](img/B21103_03_07.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7：在线购物应用程序的混合结构](img/B21103_03_07.jpg)'
- en: 'Figure 3.7: A mixed structure for an online shopping application'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：在线购物应用程序的混合结构
- en: While this structure provides a solid foundation, it’s important to adapt it
    based on the specific needs and scale of your project. Regularly reviewing and
    refactoring the structure can help maintain its effectiveness and accommodate
    future changes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种结构提供了一个坚实的基础，但根据你项目的具体需求和规模对其进行调整是很重要的。定期审查和重构结构可以帮助保持其有效性，并适应未来的变化。
- en: As the application becomes larger, it may be beneficial to extract the `components`
    folder into a shared library that can be used across multiple projects or as an
    internal design system. This approach promotes code reuse, consistency, and maintainability.
    The shared library can be hosted on an internal registry or published to *npmjs
    Registry* ([https://www.npmjs.com/](https://www.npmjs.com/)) for easy distribution
    and consumption.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序变大，将`components`文件夹提取到一个可跨多个项目或作为内部设计系统使用的共享库可能是有益的。这种方法促进了代码重用、一致性和可维护性。共享库可以托管在内部注册表中，或发布到*npmjs
    Registry* ([https://www.npmjs.com/](https://www.npmjs.com/))以方便分发和消费。
- en: Also, as your application evolves and new features are introduced, the existing
    structure may no longer fully meet your requirements. In such cases, it can be
    beneficial to incorporate architectural patterns such as MVVM, which follows a
    layered approach. This allows for better separation of concerns and facilitates
    the management of complex features and state in a more organized manner. We’ll
    have an in-depth discussion about using layered architecture in [*Chapter 11*](B21103_11.xhtml#_idTextAnchor286).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着你的应用程序发展和新功能的引入，现有的结构可能不再完全满足你的需求。在这种情况下，引入如MVVM这样的架构模式可能是有益的，它遵循分层方法。这有助于更好地分离关注点，并更有序地管理复杂的功能和状态。我们将在[*第11章*](B21103_11.xhtml#_idTextAnchor286)中深入讨论使用分层架构。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the challenges that arise when managing a large
    React application and the importance of establishing a solid project structure.
    We discussed various styles of structuring a React application, including feature-based,
    component-based, MVVM, and atomic design. Each approach offers its benefits and
    considerations, allowing developers to choose the most suitable structure for
    their specific project requirements.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了管理大型React应用程序时出现的挑战以及建立稳固项目结构的重要性。我们讨论了构建React应用程序的各种结构风格，包括基于功能、基于组件、MVVM和原子设计。每种方法都提供了其自身的优势和考虑因素，使开发者能够为他们的特定项目需求选择最合适的结构。
- en: Additionally, we proposed a continuously evolving approach to shaping the folder
    structure as the project grows. Starting with a simple initial structure, we emphasized
    the need to adapt and introduce new layers and abstractions to reduce duplication
    and maintain code organization. By continuously refining the structure and adhering
    to consistent conventions, developers can navigate, add new features, and maintain
    scalability effectively.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们提出了一种随着项目增长而不断演进的文件夹结构塑造方法。从简单的初始结构开始，我们强调了适应和引入新层和抽象以减少重复并保持代码组织的需求。通过不断精炼结构并遵守一致的约定，开发者可以有效地导航、添加新功能并维护可伸缩性。
- en: Throughout this chapter, we highlighted the importance of keeping the project
    structure flexible and evolving to meet the changing needs of the application.
    By staying proactive in shaping the folder structure, developers can mitigate
    the challenges of managing a large React application and ensure maintainability
    and scalability in the long run.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们强调了保持项目结构灵活和不断演进以满足应用程序变化需求的重要性。通过积极塑造文件夹结构，开发者可以减轻管理大型React应用程序的挑战，并确保长期的可维护性和可伸缩性。
- en: In the forthcoming chapter, we will delve into prevalent design patterns and
    strategies for component implementation. These techniques will allow us to craft
    code that is amenable to feature additions, intuitive to comprehend, and requires
    less maintenance effort.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨流行的组件实现设计模式和策略。这些技术将使我们能够编写易于添加功能、易于理解且维护工作量较小的代码。
