<html><head></head><body>
<div id="_idContainer029">
<h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-61"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.2.1">TypeScript Patterns for Angular</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Since version 2 of the framework, Angular is based on TypeScript for its development, both internally and for those who use it to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">build applications.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This was a controversial decision at the time, as this JavaScript superset, created by Microsoft, was new. </span><span class="koboSpan" id="kobo.5.2">Nowadays, most web frameworks, such as React, Vue.js, and Svelte, support TypeScript, and some web frameworks actively recommend TypeScript as the language </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will study the best practices and patterns for using TypeScript with Angular and beyond; these techniques can be applied to Node.js backend development and even other web frameworks, such as React </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and Vue.js.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We’ll learn how to better declare our application’s methods and functions and how to leverage TypeScript’s type inference mechanism to make our classes </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">less verbose.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’re going to cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Creating classes </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and types</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Creating methods </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and functions</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Decreasing verbosity: </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">type inference</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Validating types: </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">type guards</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Using a better alternative to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">any</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.23.1"> type</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.24.1">By the end of the chapter, you will be able to better apply TypeScript resources in your projects, improving the quality of your code and the productivity of </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">your team.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.26.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.27.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.29.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.30.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.31.1">VS </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.32.1">Code</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">) (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch3"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch3</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.44.1">Creating classes and types</span></h1>
<p><span class="koboSpan" id="kobo.45.1">The basis of application development using Angular is object-oriented programming, so it is important for us to delve into how to create classes and instantiate objects. </span><span class="koboSpan" id="kobo.45.2">Using TypeScript instead of pure JavaScript, we have another powerful element in our toolbox </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">of types.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">By typifying variables and objects, the TypeScript transpiler is able to carry out checks and alerts, preventing errors that could occur at runtime during development if this process did </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">not exist.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Bear in mind that after transpiling (a process that transforms TypeScript code into JavaScript), the code delivered to the client’s browser is pure JavaScript, including some optimizations; that is, code written in TypeScript is no less performant than code written directly </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">in JavaScript.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">To start with the fundamentals, let’s explore primitive and </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">basic types.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.53.1">Primitive and basic types</span></h2>
<p><span class="koboSpan" id="kobo.54.1">JavaScript, despite not being a </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.55.1">strongly typed language, has three types </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">called primitives:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">boolean</span></strong><span class="koboSpan" id="kobo.58.1">: Represents </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.59.1">the two binary values </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">false</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.61.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">true</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">string</span></strong><span class="koboSpan" id="kobo.64.1">: Represents a </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.65.1">set of characters such </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">as words</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">number</span></strong><span class="koboSpan" id="kobo.68.1">: Represents</span><a id="_idIndexMarker144"/> <span class="No-Break"><span class="koboSpan" id="kobo.69.1">numerical values</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.70.1">For each of these primitive types, TypeScript already has a datatype that represents them, namely, </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Boolean</span></strong><span class="koboSpan" id="kobo.72.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">String</span></strong><span class="koboSpan" id="kobo.74.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">Number</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">, respectively.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.77.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.78.1">The first letter of the primitive types in TypeScript is in uppercase to differentiate it from the primitive JavaScript types. </span><span class="koboSpan" id="kobo.78.2">If you want to check a type at runtime using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">typeof</span></strong><span class="koboSpan" id="kobo.80.1"> function, use the names of the primitives </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">in lowercase.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">To declare the variables of </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.83.1">these types, just use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">:</span></strong><span class="koboSpan" id="kobo.85.1"> symbol in front of the variable declaration, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.87.1">
export function primitive_example() {
  let name: string;
  let age: number;
  let isAlive: boolean;
  name = "Mario";
  age = 9;
  isAlive = true;
  console.log(`Name:${name} Age:${age} is alive:${isAlive ? </span><span class="koboSpan" id="kobo.87.2">"yes" : "no"}`);
}</span></pre> <p><span class="koboSpan" id="kobo.88.1">In the preceding example, we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">name</span></strong><span class="koboSpan" id="kobo.90.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">age</span></strong><span class="koboSpan" id="kobo.92.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">isAlive</span></strong><span class="koboSpan" id="kobo.94.1"> variables as </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">string</span></strong><span class="koboSpan" id="kobo.96.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">number</span></strong><span class="koboSpan" id="kobo.98.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">boolean</span></strong><span class="koboSpan" id="kobo.100.1">, respectively. </span><span class="koboSpan" id="kobo.100.2">Note that we can use JavaScript type names in TypeScript because TypeScript allows both forms for these </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">primitive types.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">In JavaScript, it is very common to use the </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.103.1">array data structure. </span><span class="koboSpan" id="kobo.103.2">This structure allows us to store and manipulate a list of values for our applications. </span><span class="koboSpan" id="kobo.103.3">TypeScript has a type for this structure called </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">Array</span></strong><span class="koboSpan" id="kobo.105.1">, where it is possible not only to create a variable with that type but also to typify what kind of values the array </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">will contain:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
export function array_example() {
  let names: Array&lt;string&gt;;
  let surnames: string[];
  names = ["Mario", "Gabriel", "Lucy"];
  surnames = ["Camillo", "Smith"];
  names.forEach((name) =&gt; console.log(`Name:${name}`));
  surnames.forEach((surname) =&gt; console.log(`Surname:${surname}`));
}</span></pre> <p><span class="koboSpan" id="kobo.108.1">In this function, we</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.109.1"> declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">names</span></strong><span class="koboSpan" id="kobo.111.1"> array using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">Array</span></strong><span class="koboSpan" id="kobo.113.1"> type and declare that it is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">string</span></strong><span class="koboSpan" id="kobo.115.1"> list because we are informing it between square braquets.. </span><span class="koboSpan" id="kobo.115.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">surnames</span></strong><span class="koboSpan" id="kobo.117.1"> array declaration, we make the same declaration but use a TypeScript syntax sugar using </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">[]</span></strong><span class="koboSpan" id="kobo.119.1"> after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">string</span></strong><span class="koboSpan" id="kobo.121.1"> type. </span><span class="koboSpan" id="kobo.121.2">This way of declaring has the same effect; it’s just </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">more succinct.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">At the end of the example, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Array</span></strong><span class="koboSpan" id="kobo.125.1">’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">foreach</span></strong><span class="koboSpan" id="kobo.127.1"> method to print the elements of the array. </span><span class="koboSpan" id="kobo.127.2">Finally, another basic type that is widely used is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">any</span></strong><span class="koboSpan" id="kobo.129.1"> type. </span><span class="koboSpan" id="kobo.129.2">This type tells the TypeScript transpiler not to perform any type checking on it, and its content can be type-changed anywhere in the code, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
export function any_example(){
  let information:any;
  information = 'Mario';
  console.log(`Name: ${information}`);
  information = 7;
  console.log(`Age: ${information</span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.132.1">}`);
}</span></pre> <p><span class="koboSpan" id="kobo.133.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">information</span></strong><span class="koboSpan" id="kobo.135.1"> variable is declared as </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">any</span></strong><span class="koboSpan" id="kobo.137.1"> and then we put the </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">Mario</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.139.1">string</span></strong><span class="koboSpan" id="kobo.140.1"> in it. </span><span class="koboSpan" id="kobo.140.2">We subsequently redefine the variable with the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">value </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">By default, in TypeScript, every variable that does not have its type declared, or that has its value defined in its declaration, is of </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">any</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">This language rule allows, for example, a project with JavaScript code to be incrementally converted to TypeScript by initially declaring all variables of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">any</span></strong><span class="koboSpan" id="kobo.150.1"> type. </span><span class="koboSpan" id="kobo.150.2">Another use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">any</span></strong><span class="koboSpan" id="kobo.152.1"> type</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.153.1"> is when your code needs the flexibility of JavaScript for some more general </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">algorithm types.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">However, it is recommended that Angular developers avoid using </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">any</span></strong><span class="koboSpan" id="kobo.157.1"> because it partially disables the checks that TypeScript performs in your code, without taking advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">its power.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">We’ll see alternatives throughout the chapter, should you need the flexibility of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">any</span></strong><span class="koboSpan" id="kobo.161.1"> type, without sacrificing type checking and </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">TypeScript inf</span><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.163.1">erence.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.164.1">Classes</span></h2>
<p><span class="koboSpan" id="kobo.165.1">Building on our knowledge of basic types, let’s now create more complex data types. </span><span class="koboSpan" id="kobo.165.2">The first one we’re going to explore</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.166.1"> is </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">classes</span></strong><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">An essential element of object-oriented programming, the class represents a model, which can be real, such as a person or vehicle, or abstract, such as a text box on a </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">web page.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">From the class, we create the objects that are the elements that our systems will manipulate to execute a business rule, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
class Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}
export function basic_class() {
  let client: Person = new Person("Mario", 7);
  console.log(`Name:${client.name} Age:${client.age}`);
}</span></pre> <p><span class="koboSpan" id="kobo.173.1">First, we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Person</span></strong><span class="koboSpan" id="kobo.175.1"> class with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">name</span></strong><span class="koboSpan" id="kobo.177.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">age</span></strong><span class="koboSpan" id="kobo.179.1"> properties by typing the properties, and then we create a method for the class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">constructor</span></strong><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">This method is special because it defines the rule for how the object will be instantiated from </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">this class.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">basic_class</span></strong><span class="koboSpan" id="kobo.185.1"> function, we instantiate an</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.186.1"> object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">client</span></strong><span class="koboSpan" id="kobo.188.1">, which is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Person</span></strong><span class="koboSpan" id="kobo.190.1"> type with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">new</span></strong><span class="koboSpan" id="kobo.192.1"> keyword. </span><span class="koboSpan" id="kobo.192.2">To retrieve the properties of this instantiated object, we use the notation </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">client.name</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.194.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">client.age</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">This declaration and use of class in TypeScript is almost the same as JavaScript except for typing the attributes of </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">The same example in pure JavaScript would be </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.201.1">
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
function basic_class() {
  let client = new Person("Mario", 7);
  console.log(`Name:${client.name} Age:${client.age}`);
}</span></pre> <p><span class="koboSpan" id="kobo.202.1">Notice that the process of declaring the class and instantiating an object from it changes very little from TypeScript. </span><span class="koboSpan" id="kobo.202.2">However, as we will see in the following code block, TypeScript provides more resources for the use of the class in </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">our projects.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">In addition to attributes, classes </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.205.1">also define methods, which are functions that an object can perform. </span><span class="koboSpan" id="kobo.205.2">In the example we are working on, we are now going to add </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">a method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
class Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  toString(){
    return `Name:${this.name} Age:${this.age}`;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.208.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">toString</span></strong><span class="koboSpan" id="kobo.210.1"> method returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">string</span></strong><span class="koboSpan" id="kobo.212.1"> that represents the object, so it accesses the attribute of the object instance using the reserved JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">word </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">There is a concept in object-oriented </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.217.1">programming called the </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">encapsulation of attributes</span></strong><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">This consists of defining which attributes are accessible to the function that instantiates a </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">given object.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">This concept, important for the correct use of some design patterns, does not exist in its entirety in JavaScript. </span><span class="koboSpan" id="kobo.221.2">Every class attribute is public, but in TypeScript it is implemented and validated by the transpiler, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
class Person {
  name: string;
  age: number;
  private id:number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
    this.id =Math.floor(Math.random() * 1000);
  }
  toString(){
    return `Name:${this.name} Age:${this.age} ID: ${this.id}`;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.224.1">Here, we create a property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">id</span></strong><span class="koboSpan" id="kobo.226.1"> that is generated when the object is instantiated, and we use the reserved word </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">private</span></strong><span class="koboSpan" id="kobo.228.1">, indicating that it should not be accessed from outside the</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.229.1"> class. </span><span class="koboSpan" id="kobo.229.2">Note that in class methods, this attribute is </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">accessed normally.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">Let’s try to force access from outside as in the following example to see </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">what happens:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
export function basic_class() {
  let client: Person = new Person("Mario", 7);
  console.log(client.toString());
  client.id = 100;
}</span></pre> <p><span class="koboSpan" id="kobo.234.1">In this function, we instantiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">client</span></strong><span class="koboSpan" id="kobo.236.1"> object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">Person</span></strong><span class="koboSpan" id="kobo.238.1"> class and then we try to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">id</span></strong><span class="koboSpan" id="kobo.240.1"> attribute. </span><span class="koboSpan" id="kobo.240.2">When trying to run the code, the TypeScript will indicate the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">following error:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.242.1"><img alt="Figure 3.1 – Error message when accessing a private attribute" src="image/B19562_03_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.243.1">Figure 3.1 – Error message when accessing a private attribute</span></p>
<p><span class="koboSpan" id="kobo.244.1">Another object-oriented programming concept is inheritance. </span><span class="koboSpan" id="kobo.244.2">It defines an </span><em class="italic"><span class="koboSpan" id="kobo.245.1">is a</span></em><span class="koboSpan" id="kobo.246.1"> relationship between classes, as in, </span><em class="italic"><span class="koboSpan" id="kobo.247.1">a customer is </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">a person</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">In practice, it makes a </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.251.1">class have all the attributes and methods of the extended class, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
class Client extends Person {
  address: string;
  constructor(name: string, age: number, address: string) {
    super(name, age);
    this.address = address;
  }
  toString(): string {
    return `${super.toString()} Address: ${this.address}`;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.254.1">Here, we are creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Client</span></strong><span class="koboSpan" id="kobo.256.1"> class, which extends from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">Person</span></strong><span class="koboSpan" id="kobo.258.1"> class. </span><span class="koboSpan" id="kobo.258.2">We add an attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">address</span></strong><span class="koboSpan" id="kobo.260.1"> and create the constructor. </span><span class="koboSpan" id="kobo.260.2">As it is a class derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Person</span></strong><span class="koboSpan" id="kobo.262.1">, it is necessary to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">super</span></strong><span class="koboSpan" id="kobo.264.1"> method, which is the way we access the methods and attributes of the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">ori</span><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.266.1">ginal class.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">When using inheritance, we can optionally rewrite a method of the original class as we do with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">toString</span></strong><span class="koboSpan" id="kobo.269.1"> method. </span><span class="koboSpan" id="kobo.269.2">This concept exists in JavaScript, but with TypeScript, the rules for the constructor and method rewrite are checked at compile time, giving us more confidence in </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">our </span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.271.1">development.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.272.1">Interfaces</span></h2>
<p><span class="koboSpan" id="kobo.273.1">In TypeScript, we have another way of typifying the structure of an object called an </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">interface</span></strong><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">The following </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.276.1">example demonstrates </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">its use:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
export interface Animal {
  species: string;
  kingdom: string;
  class: string;
 }</span></pre> <p><span class="koboSpan" id="kobo.279.1">To declare an interface, we use the reserved word </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">interface</span></strong><span class="koboSpan" id="kobo.281.1"> and declare its properties as a class as we </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">saw earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">To use </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">interface</span></strong><span class="koboSpan" id="kobo.285.1">, we can proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
import { Animal } from "./animals";
export function basic_interface() {
  let chicken: Animal = {
    kingdom: "Animalia",
    species: "Gallus",
    class: "birds",
  };
  console.log(
    `kingdom:${chicken.kingdom} species:${chicken.species} class:${chicken.class}`
  );
}</span></pre> <p><span class="koboSpan" id="kobo.288.1">Note that to use a class, we just type the variable and declare its values, without using the reserved word </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">new</span></strong><span class="koboSpan" id="kobo.290.1">. </span><span class="koboSpan" id="kobo.290.2">This happens because the interface is not a JavaScript element and is only used by the TypeScript transpiler to check whether the object contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">defined properties.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">To prove that the </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.293.1">interface does not exist, if we transpile the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">interface</span></strong><span class="koboSpan" id="kobo.295.1"> file, a blank file will be generated </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">by TypeScript!</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">We can also make use of interfaces to create contracts for classes, should a class require certain methods and attributes. </span><span class="koboSpan" id="kobo.297.2">Let’s see the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
export interface Animal {
  species: string;
  kingdom: string;
  class: string;
}
export interface DoSound {
  doASound: () =&gt; string;
}
export class Duck implements DoSound {
  public doASound(){
    return 'quack';
  }
}
export class Dog implements DoSound {
  public doASound(){
    return 'bark';
  }
}</span></pre> <p><span class="koboSpan" id="kobo.300.1">To define that a certain class follows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">DoSound</span></strong><span class="koboSpan" id="kobo.302.1"> contract, we use the reserved word </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">implements</span></strong><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">TypeScript then requires that a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">doASound</span></strong><span class="koboSpan" id="kobo.306.1"> be defined and that this method returns </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">a string.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">This feature of the</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.309.1"> interface facilitates the use of a very important capability of the object-oriented language, which</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.310.1"> is </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">polymorphism</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">Let’s see </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">the example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
export function animalDoSound() {
  let duck = new Duck();
  let dog = new Dog();
  makeSound(duck);
  makeSound(dog);
}
function makeSound(animal: DoSound) {
  console.log(`The animal make this sound:${animal.doASound()}`);
}</span></pre> <p><span class="koboSpan" id="kobo.315.1">We create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">makeSound</span></strong><span class="koboSpan" id="kobo.317.1"> function, which receives an animal that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">DoSound</span></strong><span class="koboSpan" id="kobo.319.1"> contract. </span><span class="koboSpan" id="kobo.319.2">The function is not concerned with the type of animal or its attributes; it just needs to follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">DoSound</span></strong><span class="koboSpan" id="kobo.321.1"> interface contract, as it will invoke one of </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">its methods.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Angular uses this characteristic of TypeScript interfaces a lot, as we can see in the declaration of </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">a component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
export class SimulationComponent implements OnInit {</span></pre> <p><span class="koboSpan" id="kobo.326.1">When we inform </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.327.1">Angular that the component implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">OnInit</span></strong><span class="koboSpan" id="kobo.329.1"> interface, it will execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.331.1"> method required at the beginning of the component’s lifecycle (we will study this in more detail in </span><a href="B19562_04.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.332.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.333.1">, </span><em class="italic"><span class="koboSpan" id="kobo.334.1">Compo</span><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.335.1">nents </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.336.1">and Pages</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">).</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.338.1">Type aliases</span></h2>
<p><span class="koboSpan" id="kobo.339.1">The last way to type a </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.340.1">variable that we will see in this chapter is the simplest one, which is to create </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">type aliases</span></strong><span class="koboSpan" id="kobo.342.1">. </span><span class="koboSpan" id="kobo.342.2">Like interfaces, type aliases only exist in TypeScript, and we can use them as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
type Machine = {
  id: number;
  description: string;
  energyOutput: number;
};
export function basic_type() {
  let car: Machine = {
    id: 123,
    description: "Car",
    energyOutput: 1000,
  };
  console.log(
    `ID:${car.id} Description:${car.description} Energy Output:${car.energyOutput} `
 );
}</span></pre> <p><span class="koboSpan" id="kobo.345.1">In this code, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Machine</span></strong><span class="koboSpan" id="kobo.347.1"> type, describing the object we want to represent, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">basic_type</span></strong><span class="koboSpan" id="kobo.349.1"> function, we instantiate a variable with </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">that type.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">Note that we use the attributes of this variable just like the previous examples. </span><span class="koboSpan" id="kobo.351.2">This demonstrates how much TypeScript maintains the flexibility of JavaScript while giving more possibilities to </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">the developer.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">A well-used feature of </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.354.1">type aliases is the creation of a type from other types. </span><span class="koboSpan" id="kobo.354.2">One of the most common is the union of types, as we can see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.356.1">
type ID = string | number;
type Machine = {
  id: ID;
  description: string;
   energyOutput: number;
};</span></pre> <p><span class="koboSpan" id="kobo.357.1">Here, we are creating a type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">id</span></strong><span class="koboSpan" id="kobo.359.1">, which can be </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">string</span></strong><span class="koboSpan" id="kobo.361.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">number</span></strong><span class="koboSpan" id="kobo.363.1">. </span><span class="koboSpan" id="kobo.363.2">For this, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">|</span></strong><span class="koboSpan" id="kobo.365.1"> symbol, which is the same as used in JavaScript to indicate the </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">conditional </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.367.1">OR</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">This feature was important for the use of more advanced techniques, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">guard</span></strong><span class="koboSpan" id="kobo.371.1"> type, which we will s</span><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.372.1">ee in </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">this chapter.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.374.1">When to use classes, interfaces, or types</span></h2>
<p><span class="koboSpan" id="kobo.375.1">With all these ways of creating typed objects, you must be wondering in which situations we should use each one. </span><span class="koboSpan" id="kobo.375.2">Based on the characteristics of each form, we can categorize the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">each one:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.377.1">Type alias</span></strong><span class="koboSpan" id="kobo.378.1">: The </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.379.1">simplest form of creation, recommended for typing input parameters and </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">function returns.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.381.1">Interfaces</span></strong><span class="koboSpan" id="kobo.382.1">: Recommended </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.383.1">for representing JSON data objects, where we won’t have methods, just the data representation. </span><span class="koboSpan" id="kobo.383.2">An example is the return of an API that we will use in our Angular project. </span><span class="koboSpan" id="kobo.383.3">The interface can also be used to define class contracts using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">implements</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.385.1"> keyword.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.386.1">Classes</span></strong><span class="koboSpan" id="kobo.387.1">: The basis </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.388.1">of object orientation, also present in JavaScript. </span><span class="koboSpan" id="kobo.388.2">We should use it whenever we need an object with methods and attributes. </span><span class="koboSpan" id="kobo.388.3">In Angular, all components and services are ultimately objects created </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">from classes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.390.1">Remember that in TypeScript, it is possible to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">alias</span></strong><span class="koboSpan" id="kobo.392.1"> type that behaves as an interface, as well as indicate an interface as a parameter and return of a function, but the recommendations here advise you to use the best for each type of situation and also explain how they are normally used in </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">Angular apps.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Now that we have a good understanding of the different ways of creating more complex variables as objects, let’s get to know how to create functions and me</span><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.395.1">thods </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">with TypeScript.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.397.1">Creating methods and functions</span></h1>
<p><span class="koboSpan" id="kobo.398.1">One of the best ways </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.399.1">used by TypeScript to improve the developer experience in Angular application development is through the ability to type parameters and return </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.400.1">functions </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">and methods.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">Both for developers who create libraries and frameworks and for those who consume these software components, knowing what a function expects and what the expected return is allows us to reduce the time spent reading and looking for documentation, especially the runtime bugs that our system </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">may encounter.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">To carry out the typing of the parameters and the return of a function, let’s consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
interface invoiceItem {
  product: string;
  quantity: number;
  price: number;
}
type Invoice = Array&lt;invoiceItem&gt;;
function getTotalInvoice(invoice: Invoice): number {
  let invoiceTotal = invoice.reduce(
    (total, item) =&gt; total + item.quantity * item.price,
    0
  );
  return invoiceTotal;
}
export function invoiceExample() {
  let example: Invoice = [
    { product: "banana", price: 1.5, quantity: 3 },
    { product: "apple", price: 0.5, quantity: 5 },
    { product: "pinaple", price: 3, quantity: 12 },
  ];
  console.log(`Invoice Total:${getTotalInvoice(example)}`);
}</span></pre> <p><span class="koboSpan" id="kobo.407.1">In this example, we start by defining an interface that represents an invoice item and then we create a type that will represent an invoice, which in this simplification is an array </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">of items.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">This demonstrates </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.410.1">how we can use interfaces and types to better express our TypeScript</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.411.1"> code. </span><span class="koboSpan" id="kobo.411.2">Soon after, we create a function that returns the total value of the invoice; as an input parameter, we receive a value with the invoice type, and the return of the function will be </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">number</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">Finally, we create an example function to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">getTotalInvoice</span></strong><span class="koboSpan" id="kobo.417.1"> function. </span><span class="koboSpan" id="kobo.417.2">Here, in addition to type checking, if we use an editor with TypeScript support such as VS Code, we have basic documentation and autocomplete, as shown in </span><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.418.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.420.1"><img alt="Figure 3.2 – Documentation generated by TypeScript and visualized by VS Code" src="image/B19562_03_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.421.1">Figure 3.2 – Documentation generated by TypeScript and visualized by VS Code</span></p>
<p><span class="koboSpan" id="kobo.422.1">In addition to </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.423.1">primitive types and objects, functions must also be prepared to handle</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.424.1"> null data or undefined variables. </span><span class="koboSpan" id="kobo.424.2">In the next section, we will exp</span><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.425.1">lore how to </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">implement this.</span></span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.427.1">Working with null values</span></h2>
<p><span class="koboSpan" id="kobo.428.1">In TypeScript, by default, all function </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.429.1">and method parameters are required and checked by </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">the transpiler.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">If any parameter is optional, we can define it in the type it represents, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
function applyDiscount(
  invoice: Invoice,
  discountValue: number,
  productOfDiscount?: string
) {
  discountValue = discountValue / 100;
  let newInvoice = invoice.map((item) =&gt; {
    if (productOfDiscount === undefined || item.product === productOfDiscount) {
      item.price = item.price - item.price * discountValue;
    }
    return item;
  });
  return newInvoice;
  }</span></pre> <p><span class="koboSpan" id="kobo.434.1">Within this function of applying a discount to the invoice, we created an optional parameter that allows the user of the function to determine a product to apply the discount. </span><span class="koboSpan" id="kobo.434.2">If the parameter is not defined, the discount is applied to the </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">entire invoice.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">To define an optional parameter, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">?</span></strong><span class="koboSpan" id="kobo.438.1"> character. </span><span class="koboSpan" id="kobo.438.2">In TypeScript, optional parameters must be the last to be defined in a function. </span><span class="koboSpan" id="kobo.438.3">If we change the position of the function parameters the following error is thrown by </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">the transpiler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
error TS1016: A required parameter cannot follow an optional parameter.</span></pre> <p><span class="koboSpan" id="kobo.441.1">Additionally, TypeScript </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.442.1">allows you to define a default value for </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">the parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
function applyDiscount(
  invoice: Invoice,
  discountValue = 10,
  productOfDiscount?: string
)</span></pre> <p><span class="koboSpan" id="kobo.445.1">When </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.446.1">assigning a value in the parameter declaration, if the function user does not use the parameter, a 10% discount will be applied to the </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">invoice items.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">We’ve seen how we can use TypeScript to typify function parameters and returns. </span><span class="koboSpan" id="kobo.448.2">Now let’s discuss type inference and how we can use it to red</span><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.449.1">uce the verbosity of </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">our code.</span></span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.451.1">Decreasing verbosity – type inference</span></h1>
<p><span class="koboSpan" id="kobo.452.1">In this chapter, we saw the best</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.453.1"> TypeScript capabilities that help in the development of our Angular projects. </span><span class="koboSpan" id="kobo.453.2">We were typing all the variables and relying on the TypeScript transpiler to avoid errors that would otherwise occur in our </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">user’s runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Let’s now explore TypeScript’s powerful inference mechanisms. </span><span class="koboSpan" id="kobo.455.2">Through it, TypeScript identifies the types of variables by content, not requiring you to define the type explicitly. </span><span class="koboSpan" id="kobo.455.3">Let’s observe the </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.457.1">
export function primitive_example() {
  let name = "Mario";
  let age = 9;
  let isAlive = true;
  console.log(`Name:${name} Age:${age} is alive:${isAlive ? </span><span class="koboSpan" id="kobo.457.2">"yes" : "no"}`);
}</span></pre> <p><span class="koboSpan" id="kobo.458.1">This example is the same as in </span><em class="italic"><span class="koboSpan" id="kobo.459.1">Primitive and basic types</span></em><span class="koboSpan" id="kobo.460.1">, but we directly inform the values in the variables. </span><span class="koboSpan" id="kobo.460.2">This way of declaring the variable has the same effect as the explicit method. </span><span class="koboSpan" id="kobo.460.3">If you change the value of a variable to another type, TypeScript will perform the validation as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
TSError: ⨯ Unable to compile TypeScript:
src/basic_types/primitive.ts:6:3 - error TS2322: Type 'number' is not assignable to type 'string'.</span></pre> <p><span class="koboSpan" id="kobo.463.1">TypeScript can also infer complex types, such as arrays and function returns. </span><span class="koboSpan" id="kobo.463.2">A good practice here is to use the inference capability to write less code and type only object</span><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.464.1">s from interfaces, </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">for example.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.466.1">Validating types – type guards</span></h2>
<p><span class="koboSpan" id="kobo.467.1">Now that we know the TypeScript inference mechanism, we can understand another feature present in it, </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">type guards</span></strong><span class="koboSpan" id="kobo.469.1">. </span><span class="koboSpan" id="kobo.469.2">Let’s </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.470.1">consider these in the </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.472.1">
function getDiscount(value: string | number) {
  if (typeof value === "number") {
    return value;
  } else {
    return parseInt(value);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.473.1">In this function, we can receive a value that can be of the primitive types </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">string</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.475.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">number</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">As they are primitive types, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">typeof</span></strong><span class="koboSpan" id="kobo.480.1"> function to define whether the variable is numeric; otherwise, it is a string and we must convert it </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">to numeric.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">The TypeScript transpiler can interpret the context of this conditional and within each one, it treats the value as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">number</span></strong><span class="koboSpan" id="kobo.484.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">string</span></strong><span class="koboSpan" id="kobo.486.1">, including in VS </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">Code’s autocomplete.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.488.1"><img alt="Figure 3.3 – Inside the conditional TypeScript, which recognizes the variable as a number" src="image/B19562_03_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.489.1">Figure 3.3 – Inside the conditional TypeScript, which recognizes the variable as a number</span></p>
<p><span class="koboSpan" id="kobo.490.1">The VS Code plugin in the figure is running the transpiler in the background and identifies that the variable inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">if</span></strong><span class="koboSpan" id="kobo.492.1"> statement can only be </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">number</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.496.1"><img alt="Figure 3.4 – Inside the conditional else TypeScript, which recognizes the variable as a string" src="image/B19562_03_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.497.1">Figure 3.4 – Inside the conditional else TypeScript, which recognizes the variable as a string</span></p>
<p><span class="koboSpan" id="kobo.498.1">As they are primitive types, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">typeof</span></strong><span class="koboSpan" id="kobo.500.1"> function to define whether the variable is numeric; otherwise, it is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">string</span></strong><span class="koboSpan" id="kobo.502.1">, and we must convert it </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">to numeric.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">For more complex </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.505.1">data types such as objects, this guard using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">typeof</span></strong><span class="koboSpan" id="kobo.507.1"> function is not possible because it will always recognize the variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">object</span></strong><span class="koboSpan" id="kobo.509.1"> type. </span><span class="koboSpan" id="kobo.509.2">However, we can create our own custom type </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">guard functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
interface Person {
  socialSecurityNumber: number;
  name: string;
}
interface Company {
  corporateNumber: number;
  name: string;
}
type Client = Person | Company;
function isPerson(client: Client): client is Person {
  return (client as Person).socialSecurityNumber !== undefined;
}
function getID(client: Client) {
  if (isPerson(client)) {
    return client.socialSecurityNumber;
  } else {
    return client.corporateNumber;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.512.1">Here we have two interfaces, </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">Person</span></strong><span class="koboSpan" id="kobo.514.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Company</span></strong><span class="koboSpan" id="kobo.516.1">, and we create a type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">Client</span></strong><span class="koboSpan" id="kobo.518.1">. </span><span class="koboSpan" id="kobo.518.2">For each type of object that follows the interfaces, we have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">id</span></strong><span class="koboSpan" id="kobo.520.1"> type </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">socialSecurityNumber</span></strong><span class="koboSpan" id="kobo.522.1"> for people and </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">corporateNumber</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.524.1">for companies.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">To carry</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.526.1"> out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">guard</span></strong><span class="koboSpan" id="kobo.528.1"> type, we created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">isPerson</span></strong><span class="koboSpan" id="kobo.530.1"> function. </span><span class="koboSpan" id="kobo.530.2">The difference regarding this function is that we put the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">client is Person</span></strong><span class="koboSpan" id="kobo.532.1"> expression in the definition of the return of </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">In it, we define the rule to consider an object as a person and use it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">getID</span></strong><span class="koboSpan" id="kobo.536.1"> function. </span><span class="koboSpan" id="kobo.536.2">Not only do we have a function that checks the object at runtime, but in this way, the TypeScript transpiler checks at compile time whether the </span><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.537.1">operation has reported </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">an error.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.539.1">Using a better alternative to the any type</span></h2>
<p><span class="koboSpan" id="kobo.540.1">In the development of TypeScript applications, we may have situations where we do not know which type of parameter we are going to receive, such as the return of </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">an API.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">What is trafficked can be defined by creating an interface that represents the data, (for more details, see </span><a href="B19562_05.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.543.1">Chapter 5</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.544.1">, Angular Services and the Singleton Pattern</span></em><span class="koboSpan" id="kobo.545.1">). </span><span class="koboSpan" id="kobo.545.2">It is not possible to guarantee this because pure text is trafficked on </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">In these cases, we can </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.548.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">any</span></strong><span class="koboSpan" id="kobo.550.1"> type, which prevents TypeScript from doing the </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">type checking.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">In this example, we can see the use </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">any</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.556.1">
interface Products {
  id: number;
   description: string;
}
type ListOfProducts = Array&lt;Products&gt;;
const exampleList: ListOfProducts = [
  { id: 1, description: "banana" },
  { id: 2, description: "apple" },
  { id: 3, description: "pear" },
];
function getProductById(id: any) {
  return exampleList.find((product) =&gt; product.id === id);
}</span></pre> <p><span class="koboSpan" id="kobo.557.1">In the preceding code sample, we create an interface that represents a product and a type that represents a list of products. </span><span class="koboSpan" id="kobo.557.2">We then create a function that receives an </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">id</span></strong><span class="koboSpan" id="kobo.559.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">any</span></strong><span class="koboSpan" id="kobo.561.1"> type and searches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">Array</span></strong><span class="koboSpan" id="kobo.563.1">, returning an item from the list </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">of products.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">In these simple examples, we can assume that there is no bug, but let’s create a function that will use this snippet and see </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">what happens:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
export function getProductTest() {
  const id = '2';
  const item = getProductById(id);
  if (item !== undefined) {
    console.log(`ID:${item.id} Description:${item.description}`);
  } else {
    console.log("No product found");
  }
}</span></pre> <p><span class="koboSpan" id="kobo.568.1">In this example, the item was not found because the variable we passed was a </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">string</span></strong><span class="koboSpan" id="kobo.570.1">. </span><span class="koboSpan" id="kobo.570.2">This could happen if the data we are passing to the function came from an API or external call, and the data was not </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">properly formatted.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Running the code, we get the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">following result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.574.1"><img alt="Figure 3.5 – Function returned No product found due to the id variable typing" src="image/B19562_03_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.575.1">Figure 3.5 – Function returned No product found due to the id variable typing</span></p>
<p><span class="koboSpan" id="kobo.576.1">When we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">any</span></strong><span class="koboSpan" id="kobo.578.1"> type, we give up the advantage of type checking and this type of bug can occur in our application. </span><span class="koboSpan" id="kobo.578.2">But how can we have the flexibility of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">any</span></strong><span class="koboSpan" id="kobo.580.1"> type without losing TypeScript’s </span><a id="_idIndexMarker179"/><span class="No-Break"><span class="koboSpan" id="kobo.581.1">type checking?</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">In these cases, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">unknown</span></strong><span class="koboSpan" id="kobo.584.1"> type. </span><span class="koboSpan" id="kobo.584.2">This type has the same flexibility as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">any</span></strong><span class="koboSpan" id="kobo.586.1"> type, but with one detail: TypeScript forces you to perform type guarding before using </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">the variable.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">Let’s refactor our </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">example function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.590.1">
function getProductById(id: unknown) {
  if (typeof id === 'string'){
    id = parseInt(id);
  } else if (typeof id !== 'number'){
    return
  }
  return exampleList.find((product) =&gt; product.id === id);
}</span></pre> <p><span class="koboSpan" id="kobo.591.1">Here we declare</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.592.1"> that </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">id</span></strong><span class="koboSpan" id="kobo.594.1"> will be of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">unknown</span></strong><span class="koboSpan" id="kobo.596.1"> type and, right after that, we make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">guard</span></strong><span class="koboSpan" id="kobo.598.1"> type in this variable, dealing with the possible scenario of the variable </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">being numerical.</span></span></p>
<p><span class="koboSpan" id="kobo.600.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">any</span></strong><span class="koboSpan" id="kobo.602.1"> type will still be used in your application, but consider using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">unknown</span></strong><span class="koboSpan" id="kobo.604.1"> type to ensure correct type handling when you are not</span><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.605.1"> sure who will call </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">your function.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.607.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.608.1">In this chapter, we saw how we can use TypeScript to create better-quality code with less effort, increasing our productivity. </span><span class="koboSpan" id="kobo.608.2">We learned about basic TypeScript types, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">number</span></strong><span class="koboSpan" id="kobo.610.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">string</span></strong><span class="koboSpan" id="kobo.612.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">Array</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">We also studied creating classes, interfaces, and type aliases, and how we can choose and mix these types of structures to make our code cleaner and </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">more maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">Finally, we learned about TypeScript’s type inference mechanism and how we can use the concept of type guards to further improve the type-checking mechanism. </span><span class="koboSpan" id="kobo.618.2">With these concepts, we also became familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">unknown</span></strong><span class="koboSpan" id="kobo.620.1"> type, which provides a better alternative to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">any</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">In the next chapter we will learn about the basics of the interfaces of an Angular project, that is, </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">the Components.</span></span></p>
</div>
</body></html>