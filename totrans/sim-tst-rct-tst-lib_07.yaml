- en: '*Chapter 7*: End-to-End UI Testing with Cypress'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：使用 Cypress 进行端到端 UI 测试'
- en: In previous chapters, we learned how to test applications at the component level
    using React Testing Library. In this chapter, we will learn how to test applications
    at the system level by executing end-to-end testing using Cypress. End-to-end
    tests play an essential role in helping teams gain the confidence their applications
    will work as expected for end users in production. By including end-to-end tests
    in test strategies, teams can gain a lot of knowledge about how applications behave
    when all dependencies work together. Cypress is a modern, JavaScript end-to-end
    testing framework that can handle anything that runs in the browser, including
    applications built with popular frameworks such as React, Angular, and Vue. Cypress
    features allow teams to install, write, run, and debug tests within minutes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用 React Testing Library 在组件级别测试应用程序。在本章中，我们将学习如何通过使用 Cypress
    执行端到端测试来在系统级别测试应用程序。端到端测试在帮助团队获得信心，确保应用程序在生产环境中按预期为最终用户工作方面发挥着至关重要的作用。通过在测试策略中包含端到端测试，团队可以了解应用程序在所有依赖项协同工作时如何表现。Cypress
    是一个现代的 JavaScript 端到端测试框架，可以处理在浏览器中运行的任何内容，包括使用 React、Angular 和 Vue 等流行框架构建的应用程序。Cypress
    的功能允许团队在几分钟内安装、编写、运行和调试测试。
- en: In addition to system-level testing, it provides the ability to write unit and
    integration tests, making the framework great for developers and quality engineers.
    Also, Cypress differs from tools such as Selenium by running tests directly in
    the browser versus requiring browser drivers, automatically waiting for commands
    and assertions before proceeding, providing visual feedback for each test command
    when run, and access to recorded test runs via the Cypress Dashboard.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统级测试外，它还提供了编写单元和集成测试的能力，这使得框架非常适合开发人员和质量工程师。此外，Cypress 与 Selenium 等工具不同，它直接在浏览器中运行测试，而不是需要浏览器驱动程序，在执行命令和断言之前自动等待，在运行时为每个测试命令提供视觉反馈，并通过
    Cypress Dashboard 访问记录的测试运行。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Installing Cypress in an existing project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有项目中安装 Cypress
- en: Enhancing Cypress DOM queries with `cypress-testing-library`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cypress-testing-library` 增强 Cypress DOM 查询
- en: Using Cypress to implement test-driven development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 实现测试驱动开发
- en: Reviewing Cypress design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习 Cypress 设计模式
- en: Executing API testing with Cypress
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 执行 API 测试
- en: Implementing Gherkin-style tests with Cucumber
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cucumber 实现的 Gherkin 风格测试
- en: The knowledge gained in this chapter will add additional test strategies to
    complement skills learned with React Testing Library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中获得的知识将为您的测试策略添加额外的策略，以补充与 React Testing Library 学习的技能。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the examples in this chapter, you will need to have Node.js installed on
    your machine. We will be using the `create-react-app` CLI tool and the Next.js
    React framework ([https://nextjs.org/](https://nextjs.org/)) for all code examples.
    Please familiarize yourself with Next.js before starting the chapter if needed.
    Code snippets will be provided throughout the chapter to help you understand the
    code under test, but the objective is understanding how to test the code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，您需要在您的机器上安装 Node.js。我们将使用 `create-react-app` CLI 工具和 Next.js React 框架
    ([https://nextjs.org/](https://nextjs.org/)) 来展示所有代码示例。如果需要，请在开始本章之前熟悉 Next.js。本章将提供代码片段以帮助您理解待测试的代码，但目标是理解如何测试代码。
- en: 'You can find code examples for this chapter here: [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter07](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter07).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码示例：[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter07](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter07)。
- en: Getting started with Cypress
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Cypress
- en: 'In this section, you will learn how to install and set up **Cypress** in an
    existing project. We will also write a test for a user flow. Use the following
    command at the command line to install Cypress:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在现有项目中安装和设置 **Cypress**。我们还将编写一个用户流程的测试。在命令行中使用以下命令来安装 Cypress：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command will install Cypress as a development dependency in your
    project. Once Cypress is installed, run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在您的项目中将 Cypress 安装为开发依赖项。Cypress 安装完成后，运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command runs the Cypress interactive Test Runner. The Test Runner
    allows us to manually do things such as select specific tests to run, pick a browser
    to use for test execution, and see the browser output alongside each associated
    Cypress command. When we run Cypress in interactive mode for the first time, it
    creates a suggested folder structure for Cypress projects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令运行 Cypress 交互式测试运行器。测试运行器允许我们手动执行诸如选择要运行的特定测试、选择用于测试执行的浏览器以及查看与每个相关 Cypress
    命令一起的浏览器输出。当我们第一次以交互模式运行 Cypress 时，它为 Cypress 项目创建了一个建议的文件夹结构：
- en: '![Figure 7.1 – First Cypress open run'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 第一次 Cypress 运行'
- en: '](img/Figure_7.1_B16887.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B16887.jpg)'
- en: Figure 7.1 – First Cypress open run
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 第一次 Cypress 运行
- en: In the preceding screenshot, Cypress informs us that it automatically created
    a `cypress` folder structure on our behalf in the root of the project that includes
    the following sub-folders – `fixtures`, `integration`, `plugins`, and `support`.
    The sub-folders allow us to quickly get up and running without needing to do any
    manual configuration. The `fixtures` folder is used to create static data typically
    used for stubbing network data in tests. The `integration` folder is used to create
    test files. Inside the `integration` folder, Cypress provides an `examples` folder
    with numerous examples of using Cypress to test applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，Cypress 通知我们它已自动在我们项目的根目录中为我们创建了一个 `cypress` 文件夹结构，包括以下子文件夹 - `fixtures`、`integration`、`plugins`
    和 `support`。这些子文件夹使我们能够快速启动并运行，而无需进行任何手动配置。`fixtures` 文件夹用于创建在测试中通常用于模拟网络数据的静态数据。`integration`
    文件夹用于创建测试文件。在 `integration` 文件夹内部，Cypress 提供了一个 `examples` 文件夹，其中包含使用 Cypress
    测试应用程序的多个示例。
- en: The `plugins` folder is used to extend the behavior of Cypress in many ways,
    such as programmatically changing the config file, generating reports in HTML
    format after test runs, or adding support for automated visual testing, just to
    name a few. Cypress provides many *out-of-the-box* commands such as `click`, `type`,
    and assertions from third-party tools such as **Mocha** ([https://mochajs.org/](https://mochajs.org/)),
    **Chai** ([https://www.chaijs.com/](https://www.chaijs.com/)), and **jQuery**
    ([https://jquery.com/](https://jquery.com/)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugins` 文件夹用于以多种方式扩展 Cypress 的行为，例如通过编程方式更改配置文件，在测试运行后生成 HTML 格式的报告，或添加对自动化视觉测试的支持，仅举几例。Cypress
    提供了许多开箱即用的命令，如 `click`、`type` 和来自第三方工具（如 **Mocha** ([https://mochajs.org/](https://mochajs.org/))）、**Chai**
    ([https://www.chaijs.com/](https://www.chaijs.com/)) 和 **jQuery** ([https://jquery.com/](https://jquery.com/)))
    的断言。'
- en: The `support` folder is used to create custom commands or add third-party commands
    with tools such as `cypress.json` file at the root of the project folder. The
    `cypress.json` file is used to set global settings such as the global base URL
    Cypress will use in tests, set custom timeouts for elements to appear in the DOM,
    or even change the folder location of our test files from `integration` to `e2e`,
    for example. There are numerous settings we can configure in the `cypress.json`
    file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`support` 文件夹用于创建自定义命令或使用如项目文件夹根目录中的 `cypress.json` 文件等工具添加第三方命令。`cypress.json`
    文件用于设置全局设置，例如 Cypress 在测试中使用的全局基础 URL，为元素在 DOM 中出现设置自定义超时，或者甚至将我们的测试文件文件夹位置从 `integration`
    更改为 `e2e`，例如。我们可以在 `cypress.json` 文件中配置许多设置。'
- en: 'In the top-right corner of the Cypress Test Runner is a drop-down list allowing
    you to select the browser to use for test runs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 测试运行器的右上角有一个下拉列表，允许您选择用于测试运行的浏览器：
- en: '![Figure 7.2 – Cypress browser dropdown'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – Cypress 浏览器下拉菜单'
- en: '](img/Figure_7.2_B16887.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B16887.jpg)'
- en: Figure 7.2 – Cypress browser dropdown
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – Cypress 浏览器下拉菜单
- en: In the preceding screenshot, the **Chrome 88**, **Firefox 80**, **Edge 88**,
    and **Electron 87** version browsers are available to use for test runs. Available
    browsers are based on Cypress-compatible browsers installed on the user's machine.
    The Cypress-supported browsers are Firefox and Chrome-family browsers such as
    Edge and Electron. The Electron browser is available by default in Cypress and
    is also used for running tests in headless mode, meaning without the browser UI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，可供使用的浏览器版本有 **Chrome 88**、**Firefox 80**、**Edge 88** 和 **Electron
    87**，可用于测试运行。可用的浏览器基于用户机器上安装的与 Cypress 兼容的浏览器。Cypress 支持的浏览器是 Firefox 和 Chrome
    家族的浏览器，如 Edge 和 Electron。Electron 浏览器在 Cypress 中默认可用，也用于在无头模式下运行测试，这意味着没有浏览器 UI。
- en: 'To execute a test, simply click the test name from the list of available tests:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试，只需从可用测试列表中单击测试名称：
- en: '![Figure 7.3 – Example test run'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 示例测试运行'
- en: '](img/Figure_7.3_B16887.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16887.jpg)'
- en: Figure 7.3 – Example test run
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 示例测试运行
- en: In the preceding screenshot, the `actions.spec.js` test file located in the
    `examples` folder was run. The screen's right side displays the state of the application
    in the browser throughout each step of the test. The left side of the screen shows
    the result of each test within the test file. If we wanted to, we could click
    into each test, hover over each Cypress command, and see the resulting DOM state
    before and after the command was executed. Being able to hover over each command
    to view the resulting DOM output is a great feature.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，运行了位于 `examples` 文件夹中的 `actions.spec.js` 测试文件。屏幕的右侧显示了在测试的每个步骤中浏览器中应用程序的状态。屏幕的左侧显示了测试文件中每个测试的结果。如果我们想的话，我们可以点击每个测试，悬停在每个
    Cypress 命令上，并查看在命令执行前后产生的 DOM 状态。能够悬停在每个命令上查看产生的 DOM 输出是一个很棒的功能。
- en: 'Cypress makes debugging easier as compared to other end-to-end testing frameworks.
    For example, if Cypress cannot find an element in the browser specified in our
    test, it provides helpful error messages:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他端到端测试框架相比，Cypress 使得调试更加容易。例如，如果 Cypress 在我们的测试中找不到浏览器指定的元素，它会提供有用的错误信息：
- en: '![Figure 7.4 – Cypress error output](img/Figure_7.4_B16887.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – Cypress 错误输出](img/Figure_7.4_B16887.jpg)'
- en: Figure 7.4 – Cypress error output
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – Cypress 错误输出
- en: In the preceding screenshot, Cypress provides feedback by informing us that
    an input element named `firSDFstName` was never found after 4 seconds inside the
    Test Runner. Cypress also allows us to click a link to open our code editor at
    the line where the error occurred.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，Cypress 通过告知我们在测试运行器内部 4 秒后找不到名为 `firSDFstName` 的输入元素来提供反馈。Cypress
    还允许我们点击一个链接，在错误发生的行打开我们的代码编辑器。
- en: 'Now that we understand the basics of installing, running, and executing tests
    with the Cypress Test Runner, we will write a checkout flow test next. When a
    user checks out, the application progresses through four screens. The first screen
    is for the shipping address:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了使用 Cypress 测试运行器安装、运行和执行测试的基本知识，我们将编写一个结账流程测试。当用户结账时，应用程序会经过四个屏幕。第一个屏幕是送货地址：
- en: '![Figure 7.5 – Shipping address Checkout screen'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – 送货地址结账屏幕'
- en: '](img/Figure_7.5_B16887.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B16887.jpg)'
- en: Figure 7.5 – Shipping address Checkout screen
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 送货地址结账屏幕
- en: 'In the preceding screenshot, a form is shown where a user can enter their shipping
    address information. The second screen is for the payment details:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，显示了一个用户可以输入他们的送货地址信息的表单。第二个屏幕是支付详情：
- en: '![Figure 7.6 – Payment details Checkout screen ](img/Figure_7.6_B16887.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 支付详情结账屏幕](img/Figure_7.6_B16887.jpg)'
- en: Figure 7.6 – Payment details Checkout screen
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 支付详情结账屏幕
- en: 'In the preceding screenshot, a form is shown where a user can enter their payment
    information. The third screen is for reviewing the order:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，显示了一个用户可以输入他们的支付信息的表单。第三个屏幕是查看订单：
- en: '![Figure 7.7 – Review your order Checkout screen ](img/Figure_7.7_B16887.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 查看您的订单结账屏幕](img/Figure_7.7_B16887.jpg)'
- en: Figure 7.7 – Review your order Checkout screen
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 查看您的订单结账屏幕
- en: 'In the preceding screenshot, a summary displaying all form values entered on
    previous screens is shown. Note, for the purposes of this demonstration, the purchased
    items **T-shirt**, **Denim Jeans**, and **Nike Free Runner** are hardcoded in
    the application and will not be a focus in the test we will write. The last screen
    is the order submitted screen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，显示了一个总结，显示了在之前的屏幕上输入的所有表单值。注意，为了演示目的，购买的物品**T恤衫**、**牛仔布牛仔裤**和**耐克自由跑鞋**在应用程序中是硬编码的，不会是我们将要编写的测试的重点。最后一个屏幕是订单提交屏幕：
- en: '![Figure 7.8 – Order submitted Checkout screen'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 订单提交结账屏幕'
- en: '](img/Figure_7.8_B16887.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B16887.jpg)'
- en: Figure 7.8 – Order submitted Checkout screen
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 订单提交结账屏幕
- en: In the preceding screenshot, a confirmation is shown, displaying a **Thank you**
    message, an order number, and information informing the customer about email communication
    for order updates.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，显示了一个确认信息，显示了一条**感谢**信息、一个订单号以及通知客户有关订单更新的电子邮件通信信息。
- en: 'For the purposes of this demonstration, the order number is hardcoded and will
    not be a focus of our test. Now that we understand the user flow, we can write
    the test code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，订单号是硬编码的，不会是我们测试的重点。现在我们了解了用户流程，我们可以编写测试代码：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we first import a `user` object to use in the test. The
    `user` object simply provides fake values to enter into each `form` input, so
    we don't have to hardcode each value. Next, we use the `visit` command via the
    global `cy` variable to visit the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先导入一个`user`对象用于测试。`user`对象简单地提供了一些假值，以便输入到每个`form`输入中，这样我们就不必为每个值硬编码。接下来，我们通过全局`cy`变量使用`visit`命令来访问应用程序。
- en: 'All available Cypress methods are chained off the `cy` variable. Note that
    the `''/''` used in the `visit` method represents the URL relative to our tests''
    base URL. By using a relative URL, we don''t have to enter the full URL in our
    tests. We can set the `baseURL` property via the `cypress.json` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 Cypress 方法都是通过`cy`变量链式调用的。请注意，在`visit`方法中使用的`'/'`代表相对于我们测试的基础 URL 的 URL。通过使用相对
    URL，我们不必在我们的测试中输入完整的 URL。我们可以通过`cypress.json`文件设置`baseURL`属性：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we set `baseUrl` to `http://localhost:3000`, allowing
    us to use `'/'` when we want to visit the index page or other pages relative to
    the index page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`baseUrl`设置为`http://localhost:3000`，这样当我们想要访问索引页或其他相对于索引页的页面时，可以使用`'/'`。
- en: 'Next, we will write the code to complete the **Shipping address** screen:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写代码来完成**运输地址**屏幕：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we use the `get` command to select each input element
    via its `name` attribute. We also use the `type` command to enter a value for
    each input. Next. We use the `contains` command to select the button element with
    the text `next` and click it using the `click` command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`get`命令通过其`name`属性选择每个输入元素。我们还使用`type`命令为每个输入输入一个值。接下来，我们使用`contains`命令选择带有文本`next`的按钮元素，并使用`click`命令点击它。
- en: 'Next, we will enter values for the **Payment details** screen:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为**支付详细信息**屏幕输入值：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we use the `get` and `type` commands to select and enter
    values in each input. Then, we use the `contains` command to click the **next**
    button.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`get`和`type`命令选择和输入每个输入的值。然后，我们使用`contains`命令点击**下一个**按钮。
- en: 'Next, we will verify entered values for shipping and payment details on the
    **Review your order** screen:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在**查看您的订单**屏幕上验证输入的运输和支付详细信息：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the `contains` command to select each element via form values entered
    on previous screens in the preceding code. We also use the `should` command to
    assert that each element is visible on the screen. Then, we use the `contains`
    command to select the button with the text `place order` and click it using the
    `click` command.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`contains`命令通过之前屏幕上输入的表单值选择每个元素。我们还使用`should`命令断言每个元素在屏幕上是可见的。然后，我们使用`contains`命令选择带有文本`place
    order`的按钮，并使用`click`命令点击它。
- en: 'Finally, we verify the application lands on the order submitted screen:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们验证应用程序是否成功跳转到了订单提交屏幕：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we use the `contains` and `should` commands to verify
    an element with the text `npx cypress open command` directly at the command line
    as previously learned at the beginning of this section, but we can also create
    an `npm` script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`contains`和`should`命令来验证带有文本`npx cypress open command`的元素，直接在命令行中，正如在本节开头所学的，但我们也可以创建一个`npm`脚本：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we create a `cy:open` script to run the Cypress Test
    Runner. We can also create another script to run tests in headless mode:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`cy:open`脚本来运行 Cypress 测试运行器。我们也可以创建另一个脚本来在无头模式下运行测试：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We create a `cy:run` script to run Cypress in headless mode via the `cypress
    run` command in the preceding code. We can use the `cy:run` script in situations
    where we don''t want to use the interactive mode, such as running via a `cy:open`
    interactive mode, we get the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`cy:run`脚本来通过前面的代码中的`cypress run`命令在无头模式下运行 Cypress。在不需要使用交互模式的情况下，例如通过`cy:open`交互模式运行，我们会得到以下输出：
- en: '![Figure 7.9 – Checkout flow test results'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9 – 结账流程测试结果]'
- en: '](img/Figure_7.9_B16887.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.9_B16887.jpg)'
- en: Figure 7.9 – Checkout flow test results
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 结账流程测试结果
- en: In the previous screenshot, the test run indicates the `checkOutFlow` test passed
    as expected. Now you know how to install and use Cypress to test a user flow.
    In the next section, we will install a plugin to enhance our element selector
    commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，测试运行指示`checkOutFlow`测试按预期通过。现在你知道了如何安装和使用 Cypress 来测试用户流程。在下一节中，我们将安装一个插件来增强我们的元素选择器命令。
- en: Enhancing Cypress commands with the Cypress Testing Library
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cypress 测试库增强 Cypress 命令
- en: 'In the previous section, we learned how to install and write a user flow test
    using Cypress. In this section, we will learn how to install and configure the
    **Cypress Testing Library** to add enhanced query selectors. The Cypress Testing
    Library will allow us to use DOM Testing Library query methods in Cypress. Install
    the library using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用 Cypress 安装和编写用户流程测试。在本节中，我们将学习如何安装和配置 **Cypress 测试库**以添加增强的查询选择器。Cypress
    测试库将允许我们在 Cypress 中使用 DOM 测试库查询方法。使用以下命令安装库：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code installs `@testing-library/cypress` as a development dependency
    in your project. After the library is installed, we can add it to the Cypress
    `commands` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将 `@testing-library/cypress` 作为开发依赖项安装到你的项目中。在库安装完成后，我们可以将其添加到 Cypress 的
    `commands` 文件中：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we extended the Cypress commands with those from the
    Cypress Testing Library. Now that we have the Cypress Testing Library installed,
    we can use it in our tests. It should be noted that only `findBy*` methods from
    the DOM Testing Library are included to support the Cypress retry-ability feature
    that retries commands a number of times before timing out.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们通过 Cypress 测试库扩展了 Cypress 命令。现在我们已经安装了 Cypress 测试库，我们可以在测试中使用它。需要注意的是，仅包含
    DOM 测试库中的 `findBy*` 方法以支持 Cypress 的重试功能，该功能在超时之前会重试命令多次。
- en: 'In the *Getting started with Cypress* section of this chapter, we wrote a test
    for a checkout flow. We can refactor element queries in that test with those from
    the Cypress Testing Library. For example, we can refactor the code for the **Shipping
    address** screen like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 *Cypress 入门* 部分，我们为结账流程编写了一个测试。我们可以使用 Cypress 测试库中的代码重构该测试中的元素查询。例如，我们可以这样重构
    **收货地址** 屏幕的代码：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous code, we updated all selectors to find `input` elements by
    their `findByRole` queries. ARIA attributes are used by individuals using assistive
    technology to locate elements. We also updated the selector for the `findByText`
    query. The same refactoring pattern is used for the **Payment details** and **Review
    your order** screens. Finally, we can refactor the code for the order submitted
    screen like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将所有选择器更新为通过 `findByRole` 查询查找 `input` 元素。ARIA 属性被辅助技术使用人员用来定位元素。我们还更新了
    `findByText` 查询的选择器。相同的重构模式也用于 **支付详情** 和 **查看您的订单** 屏幕。最后，我们可以这样重构订单提交屏幕的代码：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code, we updated the two selectors to find elements by their
    heading role using the `findByRole` query. Our test code now queries elements
    in ways that are more accessible, providing more confidence that the application
    will work for all users, including those using assistive technology such as screen
    readers. Also, the test code reads better when viewing each line in the Test Runner
    screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将两个选择器更新为通过 `findByRole` 查询使用标题角色查找元素。我们的测试代码现在以更可访问的方式查询元素，这增加了我们确信应用程序将为所有用户工作的信心，包括使用屏幕阅读器等辅助技术的用户。此外，当在测试运行器屏幕中查看每一行时，测试代码的阅读性也更好。
- en: Now you know how to install the Cypress Testing Library and refactor existing
    tests using queries that avoid using implementation details. In the next section,
    we will learn how to use test-driven development with Cypress to add features
    to a blog application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何安装 Cypress 测试库并使用避免使用实现细节的查询来重构现有测试。在下一节中，我们将学习如何使用 Cypress 进行测试驱动开发来向博客应用添加功能。
- en: Cypress-driven development
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cypress 驱动的开发
- en: In the previous section, we installed the Cypress Testing Library and refactored
    an existing test for a checkout flow. In this section, we will use Cypress to
    drive the development of new features for an existing blog application created
    with **Next.js**. Next.js is a popular framework that provides a pleasant experience
    for teams to build static or server-rendered React applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们安装了 Cypress 测试库并对一个现有的结账流程测试进行了重构。在本节中，我们将使用 Cypress 驱动一个使用 **Next.js**
    创建的现有博客应用的新功能开发。Next.js 是一个流行的框架，它为团队构建静态或服务器端渲染的 React 应用提供了愉悦的体验。
- en: 'Example features that Next.js provides are *out-of-the-box* routing, built-in
    CSS support, and API routes. Please see the Next.js documentation ([https://nextjs.org/](https://nextjs.org/))
    for more details. The **MY BLOG** application currently has two pages, a **Home**
    page displaying all blog posts and a page to display blog details. The page that
    displays a list of posts looks as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js提供的示例功能包括**开箱即用**的路由、内置的CSS支持和API路由。请参阅Next.js文档（[https://nextjs.org/](https://nextjs.org/)）以获取更多详细信息。**MY
    BLOG**应用程序目前有两个页面，一个**主页**显示所有博客帖子，一个页面用于显示博客详情。显示帖子列表的页面如下所示：
- en: '![Figure 7.10 – Blog home page'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.10 – 博客主页'
- en: '](img/Figure_7.10_B16887.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 7.10](img/Figure_7.10_B16887.jpg)'
- en: Figure 7.10 – Blog home page
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 博客主页
- en: In the previous screenshot, the **Home** page displays two blog posts, **I love
    React** and **I love Angular**. Blog data is stored in a MongoDB database and
    sent to the frontend via the API once the application loads. Each blog post displays
    a category, title, published date, an excerpt, and a **Continue Reading** link
    from top to bottom.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，**主页**显示了两个博客帖子，**我爱React**和**我爱Angular**。博客数据存储在MongoDB数据库中，并在应用程序加载后通过API发送到前端。每个博客帖子从上到下显示一个类别、标题、发布日期、摘要和一个**继续阅读**链接。
- en: 'To view a blog''s details, a user can click either the blog title or the **Continue
    Reading** link. For example, we see the following after clicking the **I love
    React** title:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看博客的详细信息，用户可以点击博客标题或**继续阅读**链接。例如，点击**我爱React**标题后，我们看到以下内容：
- en: '![Figure 7.11 – Blog detail page'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.11 – 博客详情页面'
- en: '](img/Figure_7.11_B16887.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 7.11](img/Figure_7.11_B16887.jpg)'
- en: Figure 7.11 – Blog detail page
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 博客详情页面
- en: We see the full content of the `POST` request to the API or directly adding
    new posts to the database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到发送到API的`POST`请求的完整内容或直接添加新帖子到数据库。
- en: 'We need to add a feature that allows users to add new posts via the UI. We
    can use Cypress to write a test for the expected behavior and build out the UI
    little by little until the feature is complete and the test passes. The following
    test shows the final expected behavior:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个功能，允许用户通过UI添加新帖子。我们可以使用Cypress编写测试以验证预期行为，并逐步构建UI，直到功能完成且测试通过。以下测试显示了最终的预期行为：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code, first, we import `fakePost`, a custom method that will
    generate unique test data for each test run and set it as the value for the variable
    post. We don't want to create identical blog posts, so the custom method helps
    by always creating unique data. Next, we visit the **Home** page and click a link
    with the name **New Post**. The **New Post** link should navigate us to a page
    where we can enter values for a new post.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们导入`fakePost`，这是一个自定义方法，将为每次测试运行生成唯一的测试数据，并将其设置为变量`post`的值。我们不希望创建相同的博客帖子，所以自定义方法通过始终创建唯一数据来帮助。接下来，我们访问**主页**并点击名为**新建帖子**的链接。**新建帖子**链接应该将我们导航到一个可以输入新帖子值的页面。
- en: 'Next, we test the code for entering values for the new post:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试为新帖子输入值的代码：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we find each `textbox` element by its unique name and
    enter associated values via the custom `post` method. Finally, we create the last
    pieces of the test:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过其唯一的名称找到每个`textbox`元素，并通过自定义的`post`方法输入相关值。最后，我们创建测试的最后部分：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we click the **submit** button. Once we click the **submit**
    button, the data should be sent to the API, saved to the database, and then the
    application should navigate us back to the **Home** page. Finally, once on the
    **Home** page, we verify the title for the post we created is visible on the screen.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们点击**提交**按钮。一旦我们点击**提交**按钮，数据应该被发送到API，保存到数据库，然后应用程序应该将我们导航回**主页**。最后，一旦在**主页**上，我们验证我们创建的帖子的标题是否可见在屏幕上。
- en: 'We will run the test using the Cypress Test Runner to utilize its interactive
    features and keep it open throughout building the feature. Our test will fail
    as expected when run:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Cypress测试运行器来运行测试，以利用其交互功能，并在构建功能的过程中保持其开启状态。当运行测试时，我们的测试将如预期那样失败：
- en: '![Figure 7.12 – Blog Flow test failure](img/Figure_7.12_B16887.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 博客流程测试失败](img/Figure_7.12_B16887.jpg)'
- en: Figure 7.12 – Blog Flow test failure
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 博客流程测试失败
- en: In the previous screenshot, the first step succeeded in navigating to the `link`
    element with the name **New Post** was not found after 4 seconds in the second
    test step. Four seconds is the default time that Cypress will continue to query
    for the element before timing out.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，第一步成功导航到具有名称 `New Post` 的 `link` 元素，但在第二个测试步骤中 4 秒后未找到。4 秒是 Cypress
    在超时前继续查询元素默认的时间。
- en: 'We also see a helpful message from the DOM Testing Library informing us which
    accessible elements are visible in the DOM. Further, we can look at the browser
    at the point of test failure and see that the **New Post** link is not visible.
    Now we can update the UI to make the second test step pass:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了 DOM 测试库提供的有用信息，告知我们哪些可访问元素在 DOM 中可见。此外，我们可以在测试失败的点查看浏览器，并看到 `New Post`
    链接不可见。现在我们可以更新 UI 以使第二个测试步骤通过：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code, we added a link that will navigate the user to an `hyperlink`
    element is wrapped in a `Link` component. The `Link` component allows for client-side
    route navigation. The Test Runner automatically reruns when we save the test file.
    Since we already wrote all the necessary test code, we can trigger a test run
    by saving the file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们添加了一个链接，该链接将用户导航到一个被 `Link` 组件包裹的 `hyperlink` 元素。`Link` 组件允许客户端路由导航。测试运行器在保存测试文件时自动重新运行。由于我们已经编写了所有必要的测试代码，我们可以通过保存文件来触发测试运行。
- en: 'We will need to perform this action after each UI change. Now we get the following
    output when the test runs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次 UI 更改后执行此操作。现在，当测试运行时，我们得到以下输出：
- en: '![Figure 7.13 – Blog Flow add page failure'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.13 – 博客流程添加页面失败'
- en: '](img/Figure_7.13_B16887.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.13_B16887.jpg)'
- en: Figure 7.13 – Blog Flow add page failure
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 博客流程添加页面失败
- en: 'In the previous screenshot, our test code can now successfully open the `title`
    and role `textbox` was not found at step `input` element with the name `title`
    and the `textbox` role:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，我们的测试代码现在可以成功打开 `title`，但在 `input` 元素名称为 `title` 且具有 `textbox` 角色的步骤中未找到
    `role`：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the previous code, we add a `Title label` element and an associated `input`
    element of type `text`. Although not demonstrated in the last code, we also went
    ahead and added the `Category`, `Image link`, and `Content` input elements similar
    in structure to the `Title input` element. Now we get the following output when
    we trigger a test run:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们添加了一个 `Title 标签` 元素和一个关联的 `text` 类型的 `input` 元素。尽管在上次代码中没有演示，我们也继续添加了与
    `Title input` 元素结构相似的 `Category`、`Image link` 和 `Content` 输入元素。现在，当我们触发测试运行时，我们得到以下输出：
- en: '![Figure 7.14 – Blog Flow add page input element refactor ](img/Figure_7.14_B16887.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 博客流程添加页面输入元素重构](img/Figure_7.14_B16887.jpg)'
- en: Figure 7.14 – Blog Flow add page input element refactor
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 博客流程添加页面输入元素重构
- en: 'In the previous screenshot, our test code can now successfully open the `Title`,
    `Category`, `Image link`, and `Content` `input` elements on the `Submit` button
    was not found at step `Submit` button:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，我们的测试代码现在可以成功打开 `Title`、`Category`、`Image link` 和 `Content` 的 `input`
    元素，但在 `Submit` 按钮步骤中未找到 `Submit` 按钮：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We created and added a `Submit` button to the `Submit` button is part of the
    `form` element and, when clicked, calls a method that sends the form data to the
    API and, ultimately, the database. Although not a focus for our test, we also
    added a `cancel` `button` element in the UI. Now we get the following output when
    we trigger a test run:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并添加了一个 `Submit` 按钮，该按钮是 `form` 元素的一部分，当点击时，会调用一个方法将表单数据发送到 API，最终发送到数据库。尽管这不是我们测试的重点，但我们还在
    UI 中添加了一个 `cancel` 按钮。现在，当我们触发测试运行时，我们得到以下输出：
- en: '![Figure 7.15 – Blog Flow add page completed refactor'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.15 – 博客流程添加页面完成重构'
- en: '](img/Figure_7.15_B16887.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B16887.jpg)'
- en: Figure 7.15 – Blog Flow add page completed refactor
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 博客流程添加页面完成重构
- en: In the previous screenshot, the output indicates the test finally passes. We
    can see the new blog post in the browser created by our test on the screen's right
    side. With the last refactor, we have completed all the feature steps that allow
    users to add new posts via the UI.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，输出指示测试最终通过。我们可以在屏幕右侧看到由我们的测试创建的新博客文章。通过最后的重构，我们已经完成了所有允许用户通过 UI 添加新帖子的功能步骤。
- en: 'For our next feature, we want users to have the ability to delete blog posts
    via the UI. We will add a `delete` link to the blog detail page that makes a `DELETE`
    request to the API when clicked. The application''s current state only allows
    blog posts to be deleted via a `DELETE` request to the API or directly in the
    database. Our previous test can be updated to perform actions to delete the new
    blog post after creation like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个功能，我们希望用户能够通过UI删除博客帖子。我们将向博客详情页添加一个 `delete` 链接，当点击时会对API发送 `DELETE`
    请求。应用程序的当前状态仅允许通过向API发送 `DELETE` 请求或直接在数据库中直接删除博客帖子。我们可以更新之前的测试以在创建后执行删除新博客帖子的操作，如下所示：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, first, we click the title of the blog post to delete
    to navigate to its detail page. Next, we find and click the link with the text
    `delete post`. Finally, we verify the post is no longer in the list of blog posts
    on the **Home** page. We get the following output when we trigger a test run by
    saving the file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们点击要删除的博客帖子的标题以导航到其详情页。接下来，我们找到并点击带有文本 `delete post` 的链接。最后，我们验证帖子不再在
    **主页** 上的博客帖子列表中。当我们通过保存文件来触发测试运行时，我们得到以下输出：
- en: '![Figure 7.16 – Blog Flow delete post test failure](img/Figure_7.16_B16887.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16 – 博客流程删除帖子测试失败](img/Figure_7.16_B16887.jpg)'
- en: Figure 7.16 – Blog Flow delete post test failure
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – 博客流程删除帖子测试失败
- en: 'In the previous screenshot, the output indicates the test failed at step `delete
    post` could not be found. We can update the UI by creating the missing element:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图，输出指示测试在步骤 `delete post` 找不到时失败。我们可以通过创建缺失的元素来更新UI：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we add a `hyperlink` element with the text `Delete post`.
    When the hyperlink is clicked, it calls a `handleDelete` method to send a `DELETE`
    request to the API and ultimately remove the blog post from the database. We get
    the following output when we save the test file to trigger a test run:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个带有文本 `Delete post` 的 `hyperlink` 元素。当点击超链接时，它会调用 `handleDelete`
    方法向API发送 `DELETE` 请求，并最终从数据库中删除博客帖子。当我们保存测试文件以触发测试运行时，我们得到以下输出：
- en: '![Figure 7.17 – Blog Flow delete post completed refactor'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.17 – 博客流程删除帖子完成重构'
- en: '](img/Figure_7.17_B16887.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.17_B16887.jpg)'
- en: Figure 7.17 – Blog Flow delete post completed refactor
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 – 博客流程删除帖子完成重构
- en: In the previous screenshot, the output indicates the test finally passes with
    the blog post deleted. With the addition of the `delete` link, we have completed
    all the feature steps that allow users to delete blog posts via the UI. Now you
    know how to develop features using Cypress-driven development.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图，输出指示测试最终通过，博客帖子已被删除。通过添加 `delete` 链接，我们已经完成了所有允许用户通过UI删除博客帖子的功能步骤。现在你知道如何使用Cypress驱动的开发来开发功能。
- en: The approach can be beneficial when you want to see the application in a specific
    state as you build out a feature. In the next section, we will cover Cypress design
    patterns.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望在构建功能时看到应用程序的特定状态时，这种方法可能是有益的。在下一节中，我们将介绍Cypress设计模式。
- en: Writing Tests using Cypress design patterns
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cypress设计模式编写测试
- en: In the previous section, we learned how to use Cypress to drive the development
    of new features to a blog application. In this section, we will look at two design
    patterns to structure our Cypress code. Design patterns help teams by providing
    solutions to problems such as writing maintainable code or designing responsive
    websites. First, we will look at the Page Object Model, followed by custom commands.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用Cypress驱动博客应用程序新功能的开发。在本节中，我们将探讨两种设计模式来结构我们的Cypress代码。设计模式通过提供解决方案来帮助团队解决诸如编写可维护的代码或设计响应式网站等问题。首先，我们将查看页面对象模型（Page
    Object Model），然后是自定义命令。
- en: Creating page objects in Cypress
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Cypress中创建页面对象
- en: The `class` representation for each page in an application, including custom
    methods to select and interact with various page elements. An advantage of using
    the POM model is abstracting away multiple lines of test code inside a single
    method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中每个页面的 `class` 表示，包括用于选择和与各种页面元素交互的自定义方法。使用POM模型的优势在于将多行测试代码抽象到单个方法中。
- en: 'Also, page objects serve as a single source of truth for actions performed
    on specific pages. In the *Cypress-driven development* section, we added a feature
    to allow users to create a new blog post through the UI. We can refactor the test
    code using the POM pattern. First, we will create a page object for the **Home**
    page:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，页面对象作为在特定页面上执行操作的单一真相来源。在 *Cypress 驱动的开发* 部分，我们添加了一个功能，允许用户通过 UI 创建新的博客文章。我们可以使用
    POM 模式重构测试代码。首先，我们将为 **主页** 创建一个页面对象：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, first, we create a page object for the `navigateToHomePage`,
    `navigateToAddPage`, and `getBlogPost` methods. Then, we export a new instance
    of the object to use in test files. Next, we will create a page object for the
    **Add** page:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们创建了 `navigateToHomePage`、`navigateToAddPage` 和 `getBlogPost` 方法的页面对象。然后，我们导出了一个新实例以供测试文件使用。接下来，我们将为
    **添加** 页创建一个页面对象：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we create a page object for the `createNewPost` method
    that accepts a `newPost` object with data to enter for the new post. The page
    object is exported for use in test files. Now that we have page objects representing
    the **Home** and **Add** pages, we can use them in a test:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为 `createNewPost` 方法创建了一个页面对象，该方法接受一个包含要输入的新文章数据的 `newPost` 对象。页面对象被导出以供测试文件使用。现在，我们有了代表
    **主页** 和 **添加** 页面的页面对象，我们可以在测试中使用它们：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, first, we import the fake `post` method to generate
    unique post data in the test. Next, we import the `addPage` and `homePage` page
    objects. Next, we will write the main test code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们导入了模拟的 `post` 方法以在测试中生成唯一的文章数据。接下来，我们导入了 `addPage` 和 `homePage`
    页面对象。接下来，我们将编写主要的测试代码：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, first, we navigate to the `post` method. Finally, we
    get the new post on the **Home** page and verify that it is visible on the screen.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们导航到 `post` 方法。最后，我们在 **主页** 上获取新的文章并验证它在屏幕上可见。
- en: 'In the *Cypress-driven development* section, we added another feature to delete
    blog posts through the UI. We can add a method for this feature in our page objects
    and verify our test''s behavior. First, we will add a new method to the `homePage`
    page object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Cypress 驱动的开发* 部分，我们添加了另一个功能，允许通过 UI 删除博客文章。我们可以在页面对象中添加一个用于此功能的方法，并验证测试的行为。首先，我们将向
    `homePage` 页面对象添加一个新方法：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous code, we added a `navigateToPostDetail` method that accepts
    a `post` argument when called. Next, we will create a page object for the **Post
    Detail** page:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个 `navigateToPostDetail` 方法，该方法在调用时接受一个 `post` 参数。接下来，我们将为 **文章详情**
    页创建一个页面对象：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we created a page object for the `deletePost` method.
    We also exported an instance of the page object to use in tests. Now we can use
    the new page object methods in our existing test:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为 `deletePost` 方法创建了一个页面对象。我们还导出了一个页面对象的实例以供测试使用。现在，我们可以在现有的测试中使用新的页面对象方法：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the previous code, first, we import the `postDetailPage` page object similar
    to how we did with other page objects. Next, we will add the associated methods
    to delete the post:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们以与其他页面对象类似的方式导入了 `postDetailPage` 页面对象。接下来，我们将添加删除文章的相关方法：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we invoked the `navigateToPostDetail` and `deletePost`
    methods and verified the post no longer exists on the **Home** page. Now our task
    of refactoring the test code to page objects is completed. Our test code is shorter
    and abstracts away many test step details.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们调用了 `navigateToPostDetail` 和 `deletePost` 方法，并验证该文章不再出现在 **主页** 上。现在，我们将测试代码重构为页面对象的任务已经完成。我们的测试代码更短，并且抽象了许多测试步骤的细节。
- en: 'However, our page object design does present an issue if we split the *add
    blog post* and *delete blog post* features into two different tests. The first
    test will create a blog post:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把 *添加博客文章* 和 *删除博客文章* 功能拆分成两个不同的测试，我们的页面对象设计就会存在一个问题。第一个测试将创建一个博客文章：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, the test `''POM: allows a user to create a new blog
    post''` creates a blog post. Next, we will create the test to delete the blog
    post:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，测试 `''POM: 允许用户创建新的博客文章''` 创建了一个博客文章。接下来，我们将创建删除博客文章的测试：'
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, the test `''POM: allows a user to delete a new blog
    post''` deletes a blog post. The **Delete** test''s problem is that we have to
    write many of the same test steps from the previous test and the actions most
    important to the test to delete the post. As a testing best practice, we want
    to avoid writing the same test steps in multiple tests.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，测试 `''POM: 允许用户删除一篇新的博客文章''` 用于删除博客文章。**删除** 测试的问题是我们必须从上一个测试中复制许多相同的测试步骤以及最重要的测试动作来删除文章。作为测试的最佳实践，我们希望避免在多个测试中重复编写相同的测试步骤。'
- en: In the next section, we will learn how to resolve this problem with custom Cypress
    commands.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何通过自定义 Cypress 命令来解决此问题。
- en: Creating custom Commands in Cypress
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Cypress 中创建自定义命令
- en: 'In the previous section, we learned how to write tests using the POM pattern.
    However, we came across an issue where we had to write the same test steps in
    a different test. Cypress provides a custom command feature to resolve the issue.
    Custom commands allow us to add additional commands to Cypress. In the *Enhancing
    Cypress commands with the Cypress Testing Library* section, we added third-party
    custom commands. Now we will learn how to write our own custom commands. First,
    we will create a custom method to create a new blog post:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们学习了如何使用 POM 模式编写测试。然而，我们遇到了一个问题，即我们必须在不同的测试中编写相同的测试步骤。Cypress 提供了一个自定义命令功能来解决此问题。自定义命令允许我们向
    Cypress 添加额外的命令。在 *使用 Cypress 测试库增强 Cypress 命令* 部分，我们添加了第三方自定义命令。现在我们将学习如何编写我们自己的自定义命令。首先，我们将创建一个自定义方法来创建新的博客文章：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, we add a custom `createBlogPost` command to Cypress
    via the `Commands.add` method inside the `commands.js` file. Next, we will use
    the custom method in our test:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过 `commands.js` 文件内的 `Commands.add` 方法向 Cypress 添加了一个自定义的 `createBlogPost`
    命令。接下来，我们将在我们的测试中使用这个自定义方法：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we replace the previous code that creates a new blog
    post with the custom `createBlogPost` method we created. The custom method eliminates
    the need to explicitly write the same code lines to create a blog post. We can
    use the custom method in any future test when needed. However, for our specific
    test to delete a blog post, we can go a step further.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们用我们创建的自定义 `createBlogPost` 方法替换了创建新博客文章的先前代码。自定义方法消除了显式编写相同的代码行来创建博客文章的需要。我们可以在需要时在未来的任何测试中使用自定义方法。然而，对于我们的特定测试，即删除博客文章，我们可以更进一步。
- en: Although our custom `createBlogPost` method eliminates the need to write duplicate
    lines of code, we are still performing the same steps to create a new blog post
    via the UI. Executing the same steps in multiple tests is a bad testing practice
    as we are repeating steps we've already tested. If we have controllable access
    to our application's API, we can reduce repeated steps through the UI.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的自定义 `createBlogPost` 方法消除了编写重复代码行的需要，但我们仍然在通过 UI 执行相同的步骤来创建新的博客文章。在多个测试中执行相同的步骤是糟糕的测试实践，因为我们正在重复已经测试过的步骤。如果我们能够控制访问我们应用程序的
    API，我们可以通过 UI 减少重复步骤。
- en: 'Cypress provides an HTTP `request client` that we can use to communicate with
    the API directly. Using the `request client`, we can bypass the UI to avoid repeating
    steps already tested and speed up our test. We can refactor our custom `createBlogPost`
    method like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 提供了一个 HTTP `客户端`，我们可以用它直接与 API 通信。使用 `客户端`，我们可以绕过 UI 以避免重复已测试的步骤并加快我们的测试速度。我们可以这样重构我们的自定义
    `createBlogPost` 方法：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the previous code, we use the `request` method to make a `POST` request
    to the API at `/api/add` and send a `post` object containing values for the new
    post. Then we assert the server sends back the message `The blog "blog title here"
    was successfully added`, indicating the new post was added to the database. Note
    that `"blog title here"` in the message would be replaced with the blog post''s
    real title when the request is made. Now we can update our test code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `request` 方法向 `/api/add` API 发送一个 `POST` 请求，并发送一个包含新文章值的 `post`
    对象。然后我们断言服务器返回消息 `The blog "blog title here" was successfully added`，表示新文章已添加到数据库中。注意，消息中的
    `"blog title here"` 将在请求时被替换为实际的博客文章标题。现在我们可以更新我们的测试代码：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the previous code, our test looks almost identical to the previous version.
    The only change is the implementation of the `createBlogPost` method and adding
    the `navigateToHomePage` method. However, now the test will run faster because
    we skip creating a new blog post through the UI. Although we used the POM pattern
    along with custom commands in this section, it should be noted that we could have
    solely used custom commands.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的测试看起来几乎与上一个版本相同。唯一的区别是实现了`createBlogPost`方法，并添加了`navigateToHomePage`方法。然而，现在测试将运行得更快，因为我们跳过了通过UI创建新的博客帖子。尽管我们在本节中使用了POM模式以及自定义命令，但应注意的是，我们完全可以仅使用自定义命令。
- en: We only need to test the *add blog post* and *delete blog post* features in
    one unique test to add the confidence they will work as expected for users. If
    tagged as critical user flows, the tests could run again in regression test suites
    to ensure the features continue to work as new features are added. We could write
    the Cypress commands to interact with the application directly without using the
    POM pattern and use custom commands in situations where we have to rerun the same
    steps.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在一个独特的测试中测试`添加博客帖子`和`删除博客帖子`功能，以增加它们按预期为用户工作的信心。如果标记为关键用户流程，这些测试可以在回归测试套件中再次运行，以确保在添加新功能时这些功能仍然正常工作。我们可以编写Cypress命令直接与应用程序交互，而不使用POM模式，并在需要重新执行相同步骤的情况下使用自定义命令。
- en: Now you know how to structure maintainable test code and reduce duplicate steps
    by implementing the POM pattern and custom Cypress commands.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何通过实现POM模式（Page Object Model）和自定义Cypress命令来构建可维护的测试代码，并减少重复步骤。
- en: In the next section, we will build our knowledge of the Cypress `request client`
    by testing our application's API routes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过测试我们的应用程序的API路由来加深我们对Cypress `request client`的了解。
- en: Testing APIs with Cypress
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cypress测试API
- en: In the previous section, we learned how to structure test code using the POM
    and custom commands design patterns. We also learned that we could use Cypress
    to interact with our application's API directly. In this section, we will build
    on the previous section's learnings by testing the API of the blog application
    previously introduced in the *Cypress-driven development* section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用POM和自定义命令设计模式来构建测试代码。我们还了解到可以使用Cypress直接与我们的应用程序API交互。在本节中，我们将基于前一节的所学知识，测试在“Cypress驱动开发”部分中先前引入的博客应用程序的API。
- en: 'The blog application accepts four API requests: a `GET` request to get all
    posts, a `POST` request to add a post, a `POST` request to get a single post,
    and a `DELETE` request to delete a post. First, we will test the `GET` request
    for all posts:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 博客应用程序接受四个API请求：一个用于获取所有帖子的`GET`请求，一个用于添加帖子的`POST`请求，一个用于获取单个帖子的`POST`请求，以及一个用于删除帖子的`DELETE`请求。首先，我们将测试获取所有帖子的`GET`请求：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, first, we import the `fakePost` method used to generate
    dynamic post data for each test run and assign it to the variable post. Next,
    we create three test setup methods: `getAllPosts`, `deletePost`, and `deleteAllPosts`.
    Before each test run, we want to start with an empty database.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们导入用于为每个测试运行生成动态帖子数据的`fakePost`方法，并将其分配给变量`post`。接下来，我们创建了三个测试设置方法：`getAllPosts`、`deletePost`和`deleteAllPosts`。在每个测试运行之前，我们希望从一个空数据库开始。
- en: 'The `deleteAllPosts` method will get all current posts from the database via
    `getAllPosts`, which calls `deletePost` to delete each post. Finally, we pass
    `deleteAllPosts` to `beforeEach`, which will call `deleteAllPosts` before each
    test run. Next, we will write the main code for the *get all posts* request:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteAllPosts`方法将通过`getAllPosts`从数据库获取所有当前帖子，`getAllPosts`调用`deletePost`来删除每个帖子。最后，我们将`deleteAllPosts`传递给`beforeEach`，这样在每个测试运行之前都会调用`deleteAllPosts`。接下来，我们将编写`获取所有帖子`请求的主要代码：'
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we first use the `request` method to add a new blog post
    to the API to save in the database. Next, we use `request` to get all posts from
    the database. Since we wiped the database before the test, we should receive the
    one blog post we just created from the database.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先使用`request`方法向API添加一个新的博客帖子以保存到数据库中。接下来，我们使用`request`从数据库中获取所有帖子。由于我们在测试之前清空了数据库，我们应该从数据库中接收到我们刚刚创建的那个博客帖子。
- en: 'We use the `as` method, a Cypress feature that allows us to save a code line
    as an alias. Then, we use the `get` method to access the alias using the required
    `@` symbol before the alias name to verify the API server''s response status code
    is `200`. Finally, we assert that the length of the `posts` body is `1`. Next,
    we will test the *create new blog post* request:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding code, first, we created a new blog post and saved the result
    as an alias labeled `newPost`. Then, we verify the API response status is `200`
    and that the response message is `The blog "title here" was successfully added`,
    where `"title here"` would be equal to the actual title in the test. Next, we
    will test the *delete a post* request:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, we add a new post similar to what we did in previous
    tests. Then, we use `getAllPosts` to requests all current posts, which is only
    one, and make a `DELETE` request to remove each one from the application. Then,
    we verify the API sends a status of 200 indicating successful deletion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we verify the API sends a response message that provides textual confirmation
    that the post has been deleted. For the final test, we will verify the *get a
    single post* request:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, first, we create a new post similar to previous tests.
    Then, we get all posts and verify the post `title` sent back from the API matches
    the `title` of the created post. Now you know how to test APIs using Cypress.
    It is great knowing that Cypress provides features to perform end-to-end testing
    for the API and UI, all in the same framework.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to create Gherkin-style test scenarios
    using Cucumber.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Writing Gherkin-style tests with Cucumber
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to use Cypress to test API responses.
    In this section, we will learn how to create Gherkin-style tests with **Cucumber**.
    **Gherkin** is a behavior-driven development language used by Cucumber to describe
    test scenarios' behavior in a *plain-English* format. Tests written in Gherkin
    also make it easier for software teams to communicate and provide context for
    test cases with business leaders.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Gherkin uses the following keywords: `Feature`, `Scenario`, `Given`, `When`,
    and `Then`. `Feature` is used to describe the thing to build, such as a login
    page, for example. `Scenario` describes the user flow for the feature. For example,
    a user can enter a username, password, and click **Login** to navigate to their
    profile page.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Given`, `When`, and `Then` keywords describe the scenario at different
    stages. We could write a complete Gherkin test for a login feature like so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the previous code, we created a Gherkin test for a login feature. We can
    use the `cypress-cucumber-preprocessor` plugin to write Gherkin-style tests using
    Cypress. Install the plugin using the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The previous command installs the `cucumber` plugin as a development dependency
    in your project. Once the plugin is installed, we can configure it for use in
    our Cypress project:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding code, we add the `cucumber` plugin to the Cypress plugins
    file. Now the `cucumber` plugin features can be used in our tests. Next, we will
    add the plugin''s `feature` file type to our global configuration file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding code, we configure Cypress to use files with the `feature`
    extension as the test files. Next, we will add a section to our `package.json`
    file specifically to load the configuration for the `cucumber` plugin in our project
    and tell the plugin where to find our feature files:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding code, we added the necessary configuration code to our `package.json`
    file. Now that Cucumber is configured in our project, we will use it to write
    a test for the user flow of creating and deleting a blog post for the blog application
    previously introduced in the *Cypress-driven development* section. First, we will
    create a feature file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding code, we create a feature file for the scenario where a user
    creates a blog post. Next, we will write the associated code for the Gherkin steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code, first, we import the `Given`, `Then`, and `When` methods
    from the Cypress Cucumber library. Next, we import the fake `post` method to generate
    test data. Since each test step will live in its own method, we store the `fake
    post` data to maintain the same post throughout the test. Then, we use the `Given`
    method to create the first test step. The step name: `I am on the home page` must
    match the feature file''s same words. Inside the `Given` method, we write the
    Cypress code associated with the step. Next, use the `When` method to create the
    next step. Next, we will add the following step definitions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding code, we used the `When` method to write the associated code
    for the `I fill out the new blog form` and `I click "Submit"` steps. Finally,
    we use the `Then` method to create the final step definition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, we use the `Then` method to create the associated code
    for the `I see the new post on the home page` step. We will create a Cucumber
    test for the *delete a blog post* user flow for the next test.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make the Gherkin feature scenario:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding code, we create a scenario for deleting a blog post. Next,
    we will write the associated step definitions:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we use the `When` method to add the associated test
    code for the `I click the blog post name link` and `I click the delete link` steps.
    Finally, we use the `Then` method to create the `the post is removed from the
    home page` step:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, we add the test code associated with the last step to
    verify the deleted post is removed from the `I am on the home page` step. Cucumber
    is smart enough to use any step definition that matches the string of text in
    the feature file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to write Gherkin-style tests in Cypress using Cucumber. You
    can do other things with Cucumber, such as adding tags to run specific tests and
    creating data tables that allow you to test multiple arguments for similar Gherkin
    steps.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Using React Developer Tools with Cypress
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to write tests using Cucumber. In this
    section, we will learn how to install **React Developer Tools** for development.
    React Developer Tools is a great tool to have while developing React applications.
    It enables you to inspect the hierarchy of components rendered in the DOM and
    do things such as viewing and editing component props and state. There are Chrome
    and Firefox extensions available to install React Developer Tools. There is also
    a standalone Electron app version, which is useful, such as when you want to debug
    React applications in Safari or mobile browsers. We will also learn how to use
    the standalone version with Cypress.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install via the command line:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding command will install `react-devtools` as a development dependency
    in your project. Next, we need to add a script that will connect `react-devtools`
    to your application. If you are building a Next.js application, install the special
    `<script src="img/localhost:8097">` script in the `Head` component in the `_document.js`
    file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding code, we added the script inside the `Head` component. The
    script ensures React Developer Tools connects to your Next.js application. If
    you are building an application using `create-react-app`, install the special
    script in the `head` element of the `index.html` file located in the `public`
    folder:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, we add the script as the first thing inside the `head`
    element. We need to remember to remove the special `react-devtools` script before
    deploying the application to production because it is a development tool that
    would add unnecessary code to our production-versioned application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'After the script has been added, next we will create an `npm` script in the
    `package.json` file to start the tool:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding code, we added a `devtools` script to run `react-devtools`.
    Now that we have a script to run the tool, the last thing we need to do is start
    our application, the Cypress interactive tool, and `react-devtools`: each in a
    separate tab at the command line.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'For Next.js applications, use the following command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We ran the preceding command to start the Next.js application in development.
    For `create-react-app` applications, use the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We ran the preceding command to start the `create-react-app` application in
    development. In the *Getting started with Cypress* section, we created a `"cy:open"`
    script to start Cypress in interactive mode. We can run the script like so:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding command, we ran the script to start Cypress. The next thing
    we need to do is run the `react-devtools` script:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding command, we ran the script to start `react-devtools`. When
    run, `react-devtools` opens its application on our computer:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – React Developer Tools application](img/Figure_7.18_B16887.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – React Developer Tools application
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, `react-devtools` opens and listens for our application
    to run to connect to it. Once we run any of our Cypress tests via the interactive
    mode, the applications component tree will populate inside of the `react-devtools`
    application:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – React Developer Tools component tree view](img/Figure_7.19_B16887.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – React Developer Tools component tree view
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the `react-devtools` application displays the
    resulting component tree of the running test. With the application running, we
    have many tools available, such as clicking on component names to view related
    information:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – React Developer Tools component details'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.20_B16887.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.20 – React Developer Tools component details
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we select one of the `Link` components on the left
    side of the `react-devtools` screen. When we click the component, it displays
    associated information on the `react-devtools` screen's right side, such as `props`
    and `hooks`. We also see the Cypress interactive mode screen on the right side
    of the screenshot.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to use React Developer Tools with Cypress. In addition to the
    debugging tools provided by Cypress, you now have an extra tool to debug React
    applications while running Cypress.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned new strategies to test applications using
    Cypress. You can write end-to-end tests to verify critical user flows for applications.
    You learned how to implement API testing. You now know the benefits of using Cypress-driven
    development to create new features. You understand the POM and custom command
    design patterns to structure and organize test code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how to use Cucumber to write Gherkin-style tests that enhance
    communication with non-technical team members.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have reached the end of our journey and now know about
    numerous strategies and tools to simplify testing React applications! The concepts
    and skills gained in this book will help you write quality code no matter what
    JavaScript project you tackle in the future.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Good luck, and always remember, no great software is built without a foundation
    of great tests.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Find a previous project and install and write a suite of end-to-end tests with
    Cypress.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a CRUD API and test it using Cypress.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a full-stack React application and write as many tests as you can think
    of using as many different strategies gained from this book as possible.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
