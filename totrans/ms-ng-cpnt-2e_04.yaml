- en: Thinking in Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to think bigger. So far, we've created everything within our application
    around the concept of a simple task list. However, we want to build something
    bigger than that. Users should be able to organize their tasks into projects.
    Within this chapter, we're going to introduce a frame around our task list and
    make it feel like a full-blown application. With the introduction of a project
    component, the main navigation, tabbed interfaces, and a user area, we are moving
    a big step closer to our final application look.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a reusable in-place editor component, which we will put into
    action on many existing areas within our application. With the help of this editor,
    the user experience of our system will increase tremendously, and our users will
    start to feel the underlying reactive architecture.
  prefs: []
  type: TYPE_NORMAL
- en: During this chapter, we will also create a commenting system that we build in
    a way that allows us to place it anywhere we'd like for our users to put comments.
  prefs: []
  type: TYPE_NORMAL
- en: Application security and proper user management are not within the scope of
    this book. However, we're going to create a dummy user service that will help
    us simulate a logged-in user. This service will be used by the commenting system,
    and we'll refactor our existing component to make use of it too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction of a new project component and additional container components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two new RxJS operators called `switchMap` and `take`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a tabbed interface component for project detail navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using content projection to create a navigation UI component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `contenteditable` to create an in-place editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `@HostBinding` and `@HostListener` to bind component members to host element
    properties and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining view elements using the `@ViewChild` decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing DOM operations by using the `ElementRef` DOM abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a commenting system that allows us to gather user comments in different
    areas of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing a simple pipe to format relative time intervals using the third-party
    library Moment.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an editor that enables users to edit text fields in-place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving into projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this topic, we're going to implement the changes needed to move our simple
    task list into a structure that is organized by projects. For this purpose, we
    need to modify the main layout of our components as well as introduce a new component
    that represents our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Project service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's update our application model to include project data. For this,
    we're going to create a new model for a project as well as update the model of
    our tasks to add a project ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `src/app/model.ts` file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each task is now including a reference to a project. The project entities are
    consisting of an ID, individual title, and description property. Let''s also update
    our in-memory web API database. Open the `src/app/database.ts` file and apply
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've added two projects to our database as well as updated all the tasks to
    include a reference to the first of the two projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to need a service to access our projects, and we should also
    update our task service to include a method that allows us to query for tasks
    that belong to a specific project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s apply the changes to the existing task service. Open up the `src/app/tasks/task.service.ts`
    file and implement the following changes. Effective changes are marked in bold,
    and the ellipsis character is indicating more code that is irrelevant for the
    changes to be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The added `getProjectTasks` method is providing a mapped observable that takes
    our source tasks subject and maps each tasks array to produce a filtered tasks
    array that only includes tasks of a specific project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, now we need to create a new service that allows us to obtain information
    about the projects from our in-memory web API database. Let''s use the Angular
    CLI to create a new service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Angular CLI should have created our service on the path `src/app/project/project.service.ts`.
    Let''s open that file and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the preceding code changes briefly. Our project service contains
    three members:'
  prefs: []
  type: TYPE_NORMAL
- en: '**projects: BehaviourSubject<Project[]>**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `projects` member behaviour subject is emitting our whole project list once
    loaded from our database. This subject is the basis for all operations within
    our service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**selectedProjectId: BehaviourSubject<number>**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we will need to know which of the projects is currently selected within
    our application, we need to store this information in our service. We're using
    a behaviour subject for emitting the currently selected project ID. This allows
    us to simply emit a project ID through `selectedProjectId` if we wish to select
    a given project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**selectedProject: Observable<Project>**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `selectedProject` observable will always emit the currently selected project.
    We'll make use of `combineLatest` to make sure if either `projects` or `selectedProjectId`
    emits a change. We will re-emit the updated, selected project through the `selectedProject`
    observable stream.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within the constructor of our service, we're first calling the `loadProjects`
    method to do the HTTP call to our in-memory web API database to obtain the list
    of projects. Within the `loadProjects` method, we're sticking to the same pattern
    from our task service. We're subscribing to the HTTP service observable and emitting
    the resulting items through our internal `projects` subject.
  prefs: []
  type: TYPE_NORMAL
- en: After executing the `loadProjects` method within our constructor, we will create
    the `selectedProject` observable. We will use `combineLatest`, which we've discussed
    already in the previous chapter, to combine the `projects` and the `selectedProjectId`
    subjects into a single observable stream. Whenever one of those two input observables
    emits an event, `combineLatest` will combine the latest result of both input observables
    into a single item that is emitted through the output observable stream. We're
    using the map operator to extract the selected project from the list of projects
    and returning it as an item into the observable output stream.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `selectProject` method is merely emitting the new project ID through
    the `selectedProjectId` subject. Since we're using this subject within the `selectedProject`
    observable created with `combineLatest`, this change will cause the `selectedProject`
    observable to re-emit the currently selected project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step, we need to add our new service to the app module providers.
    Let''s open the `src/app/app.module.ts` file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, that's it for our project service for the moment. We've created our service
    in a highly reactive way, where we store all state within RxJS behavior subjects
    and react to change, transform streams, and emit where updates need to be communicated.
  prefs: []
  type: TYPE_NORMAL
- en: Project component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already implemented all necessary changes to deal with the model, data,
    and state for our projects. Now, it's time to move on to the components that are
    required to display our projects and the tasks that belong to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the project component using the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s change the component class file located in `src/app/project/project/project.component.ts`
    by replacing its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special here. We''ve created a simple project component that accepts
    a project object as input. Let''s move on the template of our new component and
    change the content of the file in `src/app/project/project.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Within our template, we first render the project header, which consists of the
    title and the description of our project. After the project header, we want to
    render all project tasks. We can just include the task list container component
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the task list container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That''s it for our project component. However, our task list container is still
    implemented in such a way that it deals with all available tasks and does not
    know anything about projects. Let''s change that by modifying our component class
    located in `src/app/container/task-list-container.component.ts`. Changes are highlighted
    in bold while irrelevant parts are hidden under an ellipsis character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we're introducing a new member called `selectedProject`, which
    is an observable stream that we obtain from our project service. Within the constructor
    of our component, we're injecting the project service and receiving the observable
    by calling the `getSelectedProject` method on our service. If you remember from
    the previous topic, this observable will always emit the currently selected project
    within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Within the constructor, we also need to change the way we obtain our task list.
    Going forward, the task list that we're going to use within our container is always
    dependent on the selected project. To make this happen, we're going to look at
    a new RxJS operator called `switchMap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me first try to explain how `switchMap` works in one sentence. It takes
    an observable stream and for every item emitted, it connects a different observable
    stream to the output. This might sound confusing, so for you to get a better grasp
    on that new concept, let''s look at a simplified example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example uses `switchMap` to connect an observable **(o2)** to
    a new output observable, every time the source observable **(o1)** is emitting
    an item. We''re using the `interval` helper to create an observable that is emitting
    an item every second. For the second observable **(o2)**, we''re using the `from`
    helper to generate an observable sequence that is emitting the strings **a** and
    **b** as separate items. After that, we''re using the `switchMap` operator, which
    will create a new output observable that connects our **(o2)** observable to the
    output, whenever there''s a new item emitted by the source observable **(o1)**.
    The preceding example will, therefore, log the strings **a** and **b** to the
    console each second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49510bc3-69e8-4dd4-b21b-b92fe9d941cc.png)'
  prefs: []
  type: TYPE_IMG
- en: A stream diagram showing the behaviour of the switchMap operator
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re used to Promises, then you can also think of the `switchMap` operator
    as building an asynchronous Promise chain by returning new Promises within the
    `then` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By chaining Promises, we can perform four different asynchronous operations
    in sequence. The `switchMap` operator behaves almost the same, but instead, we
    could chain four different observables after each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we have learned about the `switchMap` operator and how we can use it
    to chain multiple asynchronous operations in sequence. Now, let''s go back to
    our task list container component and see how we can apply this concept to obtain
    project tasks. The following core excerpt is only showing the relevant part of
    the changes we have used already in our task list container component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we're using the `switchMap` operator to take the `selectedProject`
    observable as input and switch to the observable we're obtaining by the `getProjectTasks`
    call. This technique allows us to chain the two asynchronous operations, obtaining
    the selected project and receiving tasks, together in sequence. Within the callback
    of the `switchMap` operator, we are receiving the selected project object, and
    we use the ID of the project to obtain the observable of project tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Now, every time the `selectedProject` observable is emitting a new value, our
    tasks observable will also emit the latest tasks of the selected project. Nice
    and reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Alright! There's only one change left to discuss. Let's focus on the changes
    within the `addTask` method. Since our task model is now also including a `projectId`
    property, we need to make sure we're adding the correct project ID every time
    we create a task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make use of another unknown RxJS operator, `take`, within the code changes
    for the `addTask` method. Don''t worry. The `take` operator works much more straightforward
    than the `switchMap` operator. Again, let''s start with a simplification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in the preceding example will print the number one to the console.
    The numbers two and three will not be emitted by the output stream after the transformation
    using the `take` operator. The `take` operator will create a new observable stream
    that will only emit the number of items specified with the parameter passed to
    it. After the amount of items specified are emitted, the stream will close itself,
    even calling for unsubscription to all parent streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/657f7f96-f032-41a3-9b98-d42617176005.png)'
  prefs: []
  type: TYPE_IMG
- en: Input observable with three emissions is transformed to an output observable
    with one emission using the take operator
  prefs: []
  type: TYPE_NORMAL
- en: The `take` operator is especially impressive on our behaviour subjects, where
    you'd like to do some one-off actions on emitted items. Since behaviour subjects
    are always issuing the most recent item at a new subscription, we can use the
    take operator to immediately extract the latest value of the behaviour subject
    and do something with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code of our updated `addTask` method again to see how and
    why we''re making use of the `take` operator there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need to understand at which point in time the `addTask` method
    is getting called. This call happens whenever the user clicks on the add task
    button within the user interface. All we want to do now really is get the latest
    value of our `selectedProject` observable so that we can use the project ID to
    create our task associated with this project. However, if we'd subscribed to the
    `selectedProject` observable in a usual way, we'd keep those subscriptions within
    the `addTask` method active forever. This behaviour would mean that going forward
    when we call this method, let's say, ten times, on every change of the selected
    project, those ten subscriptions would fire again and create some unwanted duplicate
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `take` operator, we can prevent this behaviour. It allows us to create
    an observable stream that will be automatically unsubscribed once the desired
    amount of items have passed through. When we pass the number one as an item count
    parameter to the `take` operator, we can just take one item from the source stream
    and create a subscription that is only valid for this one item.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the changes within the task list container component. Till now,
    we have created a new project service, updated our existing task service, created
    a project component, and updated our task list container component to deal with
    the currently selected project. The last thing that is left to do is integrate
    our project component into the overall application as a top level component.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the project component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this topic, we're going to integrate the changes we've applied so far
    to our application. Currently, our root component is rendering a task list container
    component directly, which we will need to change to render our projects.
  prefs: []
  type: TYPE_NORMAL
- en: We could go ahead and render the project UI component directly within our application
    root component, however, we've learned that we should never include a top-level
    component without a container component to separate our state concerns from our
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this and use the Angular CLI to create a project container component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After the component stub has been generated, open up the `src/app/container/project-container/project-container.component.ts`
    file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing fancy here. We''re using the project service to obtain the observable
    that is emitting the currently selected project. We''re going to use this observable
    to render our project UI component. Let''s open up the view template of our new
    container component located in `src/app/container/project-container/project-container.component.html`
    and replace the stub template with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Also, the view template is ridiculously simple. However, we should not fall
    into the temptation of skipping a data container component just because things
    look too simple to be worth a wrapper. You should always bring up the discipline
    to stick to the rule that every top-level component needs a container component
    to handle the data and state concerns. It will save you a lot of time in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to include the project container component in the view of our
    root component. At the same time, we'll also change the layout of our application
    slightly, and go one step further toward our final application look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up the view template of our root component located in `src/app/app.component.html`
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We're adding two layout elements as well as our newly created project container
    component. That's it for our changes to integrate the project component into our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You've successfully implemented the first version of the project
    feature into our application. We've created a whole bunch of things in this topic.
    Besides building the model and database, services, and components, we have also
    integrated our feature successfully by creating and including a new project container
    component. Go ahead and preview our changes within your browser. I hope you're
    happy with the results and are looking forward to further enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize what we did within this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: Created and updated our model to include projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented a new project service to obtain project data and updated the existing
    task service to deal with project tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've created a new project component as well as a project container component
    to separate our UI from state and data concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We updated the task list container component to use the active project information
    to display only relevant project tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about the `switchMap` and `take` operators from RxJS and how to use
    them within our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated our root component view to include our project container component instead
    of the task list container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a tabbed interface component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s introduce a new UI component to the project that will provide us with
    a tabbed interface that we can use for navigation purposes inside of the project
    component. We''d like to divide the project view into different areas that can
    be accessed through this tabbed interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a4cb7ea-70f1-429e-8e59-664c3771e8a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the tabbed interface we're going to create
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we create a new component to render tabs, we will update our model to
    declare an interface that we''re using to represent an individual tab. Open the
    `src/app/model.ts` file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tabs will always consist of a title and an ID, which will be useful later
    when we need to distinguish between individual tabs. Next, we''re going to create
    our tabs component. Using the Angular CLI, we can create the stub of our new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open up the component class located in `src/app/ui/tabs/tabs.component.ts`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re following the concept of simple and "pure" components and only using
    input to determine how we should render our tabs. Also, when a tab gets activated,
    we''ll call the `activateTab` method that will then emit using the `outActivateTab`
    output. By now, you should be quite familiar with what you see in this component
    class and the concepts behind it. The `tabs` input is expected to be a list of
    tab objects, for which we''ve just created an interface within our model. Let''s
    open the component view template located in `src/app/ui/tabs/tabs.component.html`
    and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We're repeating over our list of tabs and rendering a button as the effective
    tab element. On the tab button, we set a class based on the condition if the current
    tab from the repetition is the same tab that got passed into our component as
    an active tab. This will make our active tab look different from the rest. When
    the user clicks one of the tabs, we're calling the `activateTab` method and passing
    the clicked tab object as a parameter. Going back to the component code, you can
    see that we're then emitting this tab through the `outActivateTab` output.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, that was already everything we need for our tabs component. Let's make
    use of our tabs in the project component and provide a tabbed interface to access
    the project's details.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s open the project component class in `src/app/project/project/project.component.ts`
    and update our code with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We're going to use the tabs component in our project component, and therefore
    we need to provide the necessary input and handle the output of the tabs component.
    For this reason, our project component will now also contain the inputs `tabs`
    and `activeTab`.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned from the previous chapter, [Chapter 3](0ae44400-ec3a-4fb6-816b-b5e808196718.xhtml),
    *Dealing with Data and State*, that our UI components should always delegate output
    until they reach a container component. Following this concept will ensure we're
    separating our state and data manipulation from our UI components, which will
    significantly enhance the overall maintainability of our code. Since our tabs
    component will notify us of a change in the active tab, we will respond to this
    by delegating and merely re-emitting the `outActivateTab` output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s open up the project view template located in `src/app/project/project/project.comonent.html`
    and edit it with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We're rendering our tabs component, passing down the tabs objects and the currently
    active tab we've received as input to the project component. We'll also listen
    for a tab activation output on the tabs component and call the `activateTab` method
    within the project component.
  prefs: []
  type: TYPE_NORMAL
- en: We're also using the information of the active tab to decide if we should render
    the task list container component or not. Only if the ID of the currently active
    tab equals to "tasks" will we render the task list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now we need to make sure we''re passing the data required for the tabs
    down to the project component. We also need to ensure that when a tab is activated,
    we''re performing the necessary changes to our application state. The project
    container component renders the project component, so let''s open up the component
    class located in `src/app/container/project-container/project-container.component.ts`
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since we're now in a container component, it's okay to store state and perform
    actions on that state. We're adding a list of tab objects where we are already
    thinking a bit ahead. The Comments tab will be used to switch to our commenting
    system that we'll be building later in this chapter. The Activities tab will be
    used in a later chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We're also storing the currently active tab using the `activeTab` member and
    initializing it with the first tab within our tabs list.
  prefs: []
  type: TYPE_NORMAL
- en: The code within the `activateTab` method looks almost too simple to be right.
    All we're doing is accepting a tab object as a parameter and updating our `activeTab`
    member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all that''s left to do for making use of our tabs component is updating
    the bindings within the project container component. Let''s open the component
    view template located in `src/app/container/project-container/project-container.component.html`
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That was easy, right? This last change was already everything required to provide
    a friendly tabbed interface to our project component. We'll make use of the `activeTab`
    property to activate more detail views of our project going forward. At the moment,
    the Tasks tab is the only tab enabling something within our user interface, but
    as continue adding features, we'll use the other two tabs for navigation too.
  prefs: []
  type: TYPE_NORMAL
- en: Building the main navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve already added a project feature to our application.
    We''ve also added a tabbed interface to navigate the details of a project. However,
    there''s still no way to navigate between projects. That''s what we''re going
    to change now. In this section, we will create components to build our main navigation.
    We will then integrate it and use it to navigate between all existing projects
    within the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fc4767a-93d9-4bb5-afb2-6b863d790263.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the main navigation we're going to build in this section of the
    book
  prefs: []
  type: TYPE_NORMAL
- en: We are designing our navigation components in such a way that we can quickly
    make use of them in any situation. For achieving this goal, we're going to look
    at a new concept within Angular, which is called content projection. With the
    use of content projection, we can achieve a new level of component composition.
  prefs: []
  type: TYPE_NORMAL
- en: Composition using content projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content projection allows you to insert a view portion from a parent component
    into its child component. This concept is a potent tool when it comes to composition.
    With so-called content slots, we can mark a position within our child component
    where we'd like to give our parent components the opportunity to pass in a view
    portion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple content projection example that helps us understand
    what this is good for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is showing a straightforward UI component called the reveal
    content component. It's showing a title that we can click on to show or hide content.
    This behaviour is advantageous in a lot of situations and is similar to the concept
    of an accordion or collapsible component.
  prefs: []
  type: TYPE_NORMAL
- en: There are two things in this example that are unique and should look unfamiliar
    to you. I've also highlighted those two lines of code for you so that you can
    see them popping out right away.
  prefs: []
  type: TYPE_NORMAL
- en: Within our reveal content component, we're using the `<ng-content>` element
    to mark the position for content to be projected from a parent component. This
    element is also called a content projection slot, and you can have multiples of
    those slots within your component view.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing, which is something we've never done so far, is within the
    app component of the preceding example. We put some template code between the
    reveal content component open and close tags. Usually, a component will eliminate
    any template code that is put into its host element. However, before it does so,
    it first checks if the child component contains content projection slots. If there
    are content projection slots within the child component, it will project any view
    portion found in the host element into the child component at the designated position.
    This is the position we've marked using the `<ng-content>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Content projection and projection slots are concepts borrowed from the web components
    Shadow DOM specification. Angular does not yet use Shadow DOM by default, and
    therefore the behaviour is emulated. However, the concept is the same. If you're
    familiar with Angular.js, the first version of Angular, content projection is
    very similar to the idea of transclusion from Angular.js.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we can use a select attribute on the `<ng-content>` element to
    set a CSS-like selector. This selector will be used to selectively choose that
    elements should be projected into the specific content slot. In this way, you
    can have multiple content slots that cover different requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Elements from the component host element can only be projected once, and this
    content projection works by going through all the `<ng-content>` elements in sequential
    order by projecting any matching elements. If you have multiple competing content
    projection slots in your template, the first one will win and receive the elements
    that get projected into your component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example that illustrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how we can use selective content projection using
    the `select` attribute on a `<ng-content>` element. The `h1` title element is
    projected into the first content projection slot since we're using a CSS selector
    that matches all `h1` elements. The second content slot does not contain a `select`
    attribute and therefore accepts all other elements that are projected into the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating navigation components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build our navigation from three separate components. Let''s look at
    their purpose real quick:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The navigation item component**: Represents one navigation item within our
    navigation. Its responsibility is to render the title of a navigation item as
    well as its behavior when an item is activated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The navigation section component**: This is used to visually separate navigation
    items that belong together. We can use this component to group navigation items
    under a title. This grouping makes it easier for our users to find the navigation
    items they are looking for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The navigation component**: This holds the full navigation together. It''s
    just a container that contains our navigation section components together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using selective content projection, we can provide an excellent content-based
    API, which makes it easy to use our navigation components in any situation. The
    benefit of building content-based APIs is that we can compose our components together,
    only by including them in a view template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the lowest of the three components, the navigation
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open up the view templated located in `src/app/ui/navigation-item/navigation-item.component.html`
    and change its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, I know, it looks too simple to be true. But that''s all we need within
    the view of our navigation item component. Let''s move on to the component class
    of the navigation item located in `src/app/ui/navigation-item/navigation-item.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Besides a `title` input, the component also takes an input, `navId`, to be used
    later during activation. This ID will help us in our parent component when detecting
    which of the navigation items was activated.
  prefs: []
  type: TYPE_NORMAL
- en: We are using a new decorator within our component that we haven't used before.
    The `@HostListener` decorator is a handy addition to our Angular toolset. With
    the help of host listeners, you can create event bindings on the component host
    element, but handle them within your component. Usually, the host element is not
    in direct control of our component. The host element always resides within the
    parent component where our component is placed. However, sometimes it's required
    to bind to properties or events of that element. Just like in our case, where
    we'd like to bind to the click event on the host element of our component. You
    can use the `@HostListener` decorator on a method to bind that method to a specific
    event on the host element. Pass the event name you'd like to bind to as a parameter
    to the decorator. In our case, we're binding to the click event on the navigation
    item host element. Each time the click event is fired, our `activateNavigationItem`
    method will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `activateNavigationItem` method, after a navigation item is clicked,
    we're emitting the ID of the specific navigation item through the `outActivateNavigationItem`
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, that''s it for our navigation items. Let''s move one level higher
    within our navigation component tree and create the navigation section component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The navigation section component is responsible for grouping navigation items
    together. Let''s open the view template located in `src/app/ui/navigation-section/navigation-section.component.html`
    first and apply the necessary changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Each navigation section consists of a title as well as a list of navigation
    items. Now, we're making use of content projection, which we looked at in the
    previous section. We're marking a place within our view template where view portions
    from the parent component can be projected into the navigation section component.
    Since we know that we only want the navigation item component to be projected
    into our navigation section, we are using a `select` attribute on the `<ng-content>`
    element. By setting the `select` attribute to a value of `mac-navigation-item`,
    Angular will only project navigation item components into this content slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also apply the changes to our navigation section component class located
    in `src/app/ui/navigation-section/navigation-section.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This component class is elementary. The only thing we do here is to provide
    a title input that is rendered within our navigation section view. The rest of
    our component logic is handled using content projection, which is providing us
    with a beautiful content-based API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we could already go ahead and use those two components in conjunction
    and arrange them in any view template within our application. As an example, we
    could write a navigation for accessing cute dog pictures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That's the big strength of content-based APIs. Using content projection, we
    provide the ability to compose complex component trees and configure behaviour
    using only view templates. This comes with a significant ease of use. Not surprisingly,
    a lot of Angular UI libraries are using content projection to create their APIs,
    simply because it's just so much easier to configure everything you need declaratively
    using Angular templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now, let''s create the last component of our threeâ€”the navigation component.
    The navigation component is putting a frame on our navigation and is grouping
    navigation sections together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s open the view template of the navigation component located in
    `src/app/ui/navgiation/navigation.component.html` and change its content to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using content projection again to project elements into our navigation
    view. This time, we''re selecting only navigation section components. Let''s also
    change our component class in `src/app/ui/navigation/navigation.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Okay, this is as simple as a component class could be. The class is empty, and
    we're not providing any particular component configuration. You might wonder why
    we even need this component. Well, to decide about the right to exist for our
    components, we need to look at all parts that are defining the component. The
    component class might not contain any behavioral content. However, the styles
    and the component view could provide material that makes the component worth existing.
    If you're using content projection, you often end up with very little code within
    your classes, and that's fine. As long as the content projection or even only
    encapsulated styles provide us developers with a more convenient API, we should
    feel right about the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to the overall navigation component tree, things might start to
    get a bit confusing, which is normal when multiple levels are involved. Just to
    recap quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: The navigation item is rendering a title and dealing with the behaviour when
    an item is getting activated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The navigation sections render a section title and project navigation items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The navigation solely projects navigation sections and acts as a container around
    our navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we're ready to use our navigation components and put them into action within
    our application!
  prefs: []
  type: TYPE_NORMAL
- en: Providing a project navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within this section, we''re going to use the navigation components we''ve just
    created to provide a project navigation. For this, we''re first going to introduce
    the necessary changes in the app component class located in `src/main/app/app.component.ts`.
    This is the first time we are dealing with the app or root component class. Since
    this is our root component, we''re treating it like a container component, and
    it gets the privileges to deal with state and data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We're storing two observables within our app component. Using the project service,
    we're obtaining an observable that emits the list of available projects. We're
    also storing the observable that emits the currently selected project.
  prefs: []
  type: TYPE_NORMAL
- en: The `selectProject` method is accepting a project ID as a parameter and delegates
    the call to our project service. This will then cause all observers who subscribed
    to the selected project observable to receive the newly selected project. If you
    remember, we're already using this observable within our task list container component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the view template of our app component located in `src/app/app.component.html`
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We're using our navigation components to create a project navigation in the
    space that is reserved for our main navigation. At the moment, we're rendering
    just one navigation section that belongs to our projects. By using the `NgFor`
    directive, we're repeating a navigation item component for each project within
    the list of available projects. We're binding the project ID to the `navId` input
    as well as the project title to the `title` input of our navigation item. Additionally,
    we're setting an active class on the navigation item component if the specific
    project is currently selected.
  prefs: []
  type: TYPE_NORMAL
- en: If one of the navigation items is activated, we call the `selectProject` method
    of our app component and pass the ID that is emitted by the `outActivgateNavigationItem`
    as `$event`.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! You have successfully built a project navigation. It's a good time
    to preview your changes in the browser now. You should already be able to navigate
    between the two projects that were added into our database. Since our task list
    container is already making use of the selected project observable, the logic
    of switching between projects should already be seamless. You can try to navigate
    to the second project, which does not contain any tasks. Try adding tasks and
    switching between the two projects.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within this section, we''ve created our navigation components and used them
    to create our project navigation. You have learned about the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Using content projection to build a content-based API for your components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of content projection slots and the use of `<ng-content>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `select` attribute on content slots to selectively project content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `@HostListener` decorator to bind host element events to component
    methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One editor to rule them all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be processing a lot of user input within our application. Therefore,
    it''s crucial to provide a pleasant authoring experience to our users. Users need
    to be able to edit project titles, descriptions, and task titles. Within the commenting
    system, which we are creating later in this chapter, users also need to be able
    to edit their comments. We could use regular text area input and work with dialogue
    boxes to edit those fields, but this seems too old-fashioned for a modern user
    interface. Native input fields are fantastic, but sometimes they don''t provide
    an outstanding user experience. What we''re looking for is a way to edit stuff
    in-place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e38df5e-85ee-408c-92a8-55d8cd60fb35.png)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of our in-place editor in action, showing the save and cancel buttons
  prefs: []
  type: TYPE_NORMAL
- en: To build our in-place editor, we're going to use the contenteditable API that
    will enable a user to modify the content within HTML elements directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how we can use the `contenteditable` attribute
    to make HTML elements editable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Run the preceding example on a blank HTML page and click on the `h1` text. You
    will see that the element has become editable and you can type to modify its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting notified about changes within editable elements is relatively easy.
    There''s an input event emitted on every DOM element that is editable, and this
    will allow us to react to change easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With this example, we have already created a naive implementation of an in-place
    editor where we're able to monitor changes applied by the user. Within this topic,
    we'll use this standard technology to build a reusable component that we can use
    wherever we want to make things editable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an editor component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a new stub component for our editor using the Angular
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After the files have been generated, so let''s open up the component class
    located in `src/ui/editor/editor.component.ts` and apply the following code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that's quite a lot of new code. Let's dissect the different parts of the
    editor component and go through each part step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our editor component, we''ll need to interact with the native DOM element,
    which we make editable using the contenteditable API. The easiest and also the
    safest method to do this is to use the `@ViewChild` decorator to retrieve a DOM
    element by using local view references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `@ViewChild` decorator can be used to search our component view for a specific
    DOM element or a component instance. When we'd like to search our view for a particular
    component instance, we can just pass the component class as a parameter to the
    decorator. When searching for a DOM element, we need to pass a string that should
    match a local view reference on one of the elements within our component view.
    Angular returns a type called `ElementRef` when we're searching our view for DOM
    elements. This object is just a wrapper around native DOM elements, which you
    can then use to access the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to search the component subtree for one single DOM element or component
    instance, we can use the `@ViewChild` decorator. We can also search for a list
    of DOM elements or component instances using the `@ViewChildren` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Query decorator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `@ViewChildren` (selector) | Will query the current component''s view for
    either directives or components and return an object of the type `QueryList`.
    If the view is dynamically updated, the list will be updated as well.When the
    selector parameter is a directive or component type, the query decorator will
    search our component view for matching directives or components and return a list
    of directive or component instances.The selector parameter can also be a string
    that is then used as a local view reference name to find DOM elements containing
    this local view reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ViewChild` (selector) | Will query for only the first matching component
    or directive instance or a DOM element containing the specific local view reference.
    |'
  prefs: []
  type: TYPE_TB
- en: If you need to communicate with view child components directly, you can use
    the `@ViewChild` and `@ViewChildren` decorators to get hold of those components.
    Sometimes, this is required, but this technique should be used carefully. Direct
    component communication only makes sense when you have requirements that can not
    be fulfilled by using component input and output.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you need to run some initialization code on view children after your
    component is initialized. In such cases, you can use the `AfterViewInit` life
    cycle hook. While the view child properties of your component class will still
    be undefined within the constructor of your component, they will be populated
    and initialized after the `AfterViewInit` life cycle callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move back to our editor component code. The next thing we''re going
    to look at is another property in our editor component called `editMode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Our editor is functioning in two modes. The `editMode` property is used inside
    of our component to determine if the editor is in edit mode or display mode. The
    default mode of the editor component is the display mode. A user can then switch
    an editor to edit mode, where he/she will be able to edit the content within the
    editor. After he/she's done editing, he/she can save or discharge the changes.
    This action will also switch the component back into display mode (where `editorMode`
    is false again).
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `@HostBinding` decorator to set the CSS class `edit-mode` on
    the component host element conditionally. This state class will help us to style
    our component differently, depending on the editor mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the input properties of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `content` input property can be used to set the content of our editor from
    the parent components. This input is required to set the initial content that
    appears when our editor is in display mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second input property, `showControls`, controls whether the editor should
    show the control functions. When this input is annoying to false, the editor does
    not show any controls and therefore acts in read-only mode. Three UI controls
    will be shown in our editor when this property is set to true:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Edit button**: If the editor is in display mode, the edit button is the only
    visible control on the editor. When a user clicks this button, the editor component
    will switch into edit mode by setting `editMode` to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Save button**: This control will only be shown if the component is in edit
    mode. It''s there to save any changes performed by the user and switch the component
    back to display mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel button**: This control is shown along with the save button when the
    component is in edit mode. If activated, the component will switch back to display
    mode, reverting any changes that were typed into the editor by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides our input properties, we also need some output properties to notify
    the outer world about the changes within our editor. Let''s quickly discuss the
    two output properties we''re exposing on our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `outSaveEdit` output is emitting the updated content once the user applies
    any changes to the editor content and has clicked the save button.
  prefs: []
  type: TYPE_NORMAL
- en: Our editor component works in a simple way. If the component is in edit mode,
    it shows an element that can be edited using the contenteditable API. However,
    once the editor switches back to display mode, we see a different element that
    cannot be edited. CSS controls the visibility within the modifier class, which
    is set by the host element property binding to the `editMode` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular has no control over the content within our editable element. We control
    this content manually by using native DOM operations. Let''s look at how we do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: These two private methods can be used inside of our editor component to obtain
    the content of our editable DOM element or to set its content, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We've already discussed the `editableContentElement` property of our editor
    component and how we obtain a reference to the editable element within our component
    view using the `@ViewChild` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Angular does not directly provide us with a DOM element reference but a wrapper
    object of the type `ElementRef`. It's a wrapper around the native DOM element,
    which holds additional information that is relevant to Angular. Using the `nativeElement`
    property, we can obtain a reference to the underlying native DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementRef` wrapper plays an integral part in Angular's platform-agnostic
    architecture. It allows you to run Angular in different environments (for example,
    on a server, native mobile, web workers, or others). It's part of an abstraction
    layer between the components and their views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we set editable content within our component view using the
    `setEditableContent` method. First, we want to make sure that when our view is
    ready, we are initializing the editable content with the text present in our `content`
    component input. For this, we can use the `AfterViewInit` life cycle hook. We
    also needed a way to react to changes to the `content` input property, and update
    the editable content element based on that. We can use the life cycle hook `OnChanges`
    for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Within the `ngOnChanges` callback, once a change in the content input property
    is detected, we can reflect the changed content onto our editable element. It's
    important to check whether the `editableContentElement` input is already set before
    we call `setEditableContent`. Since the `OnChanges` life cycle hook is called
    before the `AfterViewInit` life cycle, the `editableContentElement` obtained by
    our `@ViewChild` query will not be available yet. Because of that, we also need
    to use the `ngAfterViewInit` callback to set the initial content of our editable
    element once our component view has initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so far, we''ve looked at how we can reflect the content input of our
    component into the editable element within the view of the editor component. Now,
    let''s take a look at the implementation of the three user actions within the
    editor. These are the three actions for the edit, save, and cancel buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When our editor is in display mode, a user can only activate edit mode. We are
    taking care of that using the `beginEdit` method. If a user clicks the edit button
    on our editor component, the only thing we need to do is switch our editor into
    edit mode. We can do that by merely setting the `editMode` property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever we''ve discussed thus far concerning the code is good enough for us
    to set up a fully functional component. However, the last part of the code, which
    we haven''t discussed yet, relates to ensuring better accessibility of our editor.
    Since our editor component is a bit larger than the editable element, we also
    want to make sure that a click anywhere inside the editor component will cause
    the editable element to be focused. The following code makes this happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Using the `@HostListener` decorator, we are registering an event binding on
    our component host element that calls the `focusEditableContent` method. Inside
    this method, we are using the reference to the editable DOM element and triggering
    a focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was the last missing piece of code to discuss within our component class.
    Let''s look at the template of our component, which is located within the `src/app/ui/editor/editor.component.html`
    file, to see how the code we''ve just created in our component class is related
    to the component view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The logic within the editor component template is quite straightforward. If
    you've been following the component code, you'll now be able to identify the different
    elements that compose this component's view.
  prefs: []
  type: TYPE_NORMAL
- en: The first element within the CSS class, `editable-content`, is our editable
    element that has the `contenteditable` attribute. The user will be able to type
    into this element when the editor is in edit mode. It's important to note that
    we've annotated it with a local view reference, `#editableContentElement`, which
    we're using in our view child queries.
  prefs: []
  type: TYPE_NORMAL
- en: The second element within the CSS class, `output`, is only to display the editor
    content and is only visible when the editor is in display mode. The visibility
    of both the elements is controlled using CSS, based on the `edit-mode` modifier
    class, which, if you recall from the component class code, is set through host
    property binding based on the `editMode` property.
  prefs: []
  type: TYPE_NORMAL
- en: The three control buttons are shown conditionally using the `NgIf` directive.
    The `showControls` input property needs to be `true`, and depending on the `editMode`
    flag, the view will either show the edit button or the save and the cancel buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the editor component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to incorporate the editor component we''ve just created within
    our current project. We will use the editor component to make three areas in our
    application editable in-place:'
  prefs: []
  type: TYPE_NORMAL
- en: The titles of tasks within our task list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The title of projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The description of projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by integrating our in-place editor component into our task list
    component and making the titles of our tasks editable. Open up the file located
    in `src/app/tasks/task/task.component.html` and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Instead of just rendering the task title directly, we will now use our editor
    component to render the task title. We're binding the task title onto the `content`
    input property of our editor and calling a new method called `updateTitle` when
    the editor is emitting a `outSaveEdit` output. The `showControls` input property
    needs to be set to `true`, otherwise the editor will always stay in read-only
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the new `updateTitle` method in the task component class located
    in `src/app/tasks/task/task.component.ts`. The following code excerpt shows the
    added method in bold; unchanged code parts are hidden using the ellipsis character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `updateTitle` method is very similar to the already present `updateTask`
    method. The difference is that we're emitting an updated task model which contains
    the updated title from out editor component. The `updateTask` method is emitting
    an updated task model where the done flag was updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that we can re-use the `outUpdateTask` output makes our change to
    integrate the editor component very simple. To help you recall the data flow that
    is now happening within our component tree, let''s look at all the different pieces
    involved once again:'
  prefs: []
  type: TYPE_NORMAL
- en: A user clicks the edit button within the editor component inside a task component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After editing and clicking the save button, an `outSaveEdit` output with the
    updated title is emitted from the editor and our `updateTitle` method is called
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `updateTitle` method is emitting a new task object containing the updated
    title using the `outUpdateTask` output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task list component is delegating the `outUpdateTask` output to its parent
    using an output with the same name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task list container component is catching the updated task and calls the
    `updateTask` method on our task list service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the service has updated the data in our in-memory web API database, the
    updated task list will be passed down the component tree again until the task
    we've just updated arrives at the specific task component again, where it will
    also update the `content` input of our editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, our reactive and unidirectional data flow pays off when it comes
    to state architecture. With minimal changes, we've added a new feature to make
    our task titles editable in-place. Also, the way our data flows has not increased
    in complexity by implementing this change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply similar changes to make our project title and description editable.
    Let''s start by implementing changes to the template of our project component
    located in `src/app/project/project/project.component.html`. Again, changes are
    in bold and unchanged parts are hidden using the ellipsis character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we''re using two editors, one for our project title and one for
    the description. The rest of the changes are very similar to the changes we''ve
    applied to our task component. We''re using two new methods called `updateTitle`
    and `updateDescription`, which we now need to add in the project component class
    located in `src/app/project/project/project.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Since we did not have anything to update in our project component as of yet,
    we first need to add a new output called `outUpdateProject` to notify our parent
    component about an updated project. The two methods `updateTitle` and `updateDescription`
    are both emitting an updated version of the project data using the updated information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update our project container component to handle the newly
    introduced project updates. Let''s start by changing the view template located
    in `src/app/container/project-container/project-container.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re handing the new `outUpdateProject` output of our project component and
    calling a new method called `updateProject`. Let''s look at the implementation
    of this method in the project container component class located in `src/app/container/project-container/project-container.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Within the newly added method, we're calling the `updateProject` method on the
    project service and passing the project object that was initially emitted by the
    project UI component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s implement the `updateProject` method within our project service
    to update project data using the Angular HTTP service. Let''s open the `src/app/project/project.service.ts`
    file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Nothing new here. We're using the Angular HTTP service to execute a post request
    to the in-memory web API. After a successful call, we're calling the `loadProjects`
    method on our service, which will emit an updated project list using the `projects`
    behavior subject. This will cause all of our reactive subscriptions to receive
    the updated list of projects and update accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've successfully created and integrated our editor component
    to make project titles, descriptions, and task titles editable. Now is a great
    time to preview your changes in the browser and play around with the editing capabilities
    we've added using the editor component. Using an in-place editor, we've simplified
    the authoring process within our application for our users. Also, by using a reactive
    data architecture, the editing feels very responsive and intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this building block, we have created an in-place editor component, which
    we can use to make things editable for any content within our application. It
    allows us to provide the user with contextual editing capabilities, which will
    result in a fantastic overall user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also learned about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `contenteditable` HTML5 attribute to enable in-place editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `@ViewChild` and `@ViewChildren` to query view child elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ElementRef` dependency to perform native DOM operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the logic, using the `OnChange` as well as the `AfterViewInit`
    life cycle hooks, to reflect data between Angular and content that is not in immediate
    control of Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going forward, we'll start dealing with user-generated content within our application
    and therefore require a minimal setup that allows us to deal with users correctly.
    We're creating a model to represent users as well as a simple user service that
    will tell us about the currently logged in user. Our service will just act as
    a mock user service and concerns like registration, login, and authentication
    are not within the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s stick to the practice we''ve established within this book and start
    by introducing the model for our users. Let''s open the `src/app/model.ts` file
    and add the following interface at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s keep this as minimal as possible. Our users will consist of only an
    ID, name, and a URL to a profile picture. As a next step, let''s add a new users
    resource to our in-memory web API database. Open up the `src/app/database.ts`
    file and apply the following changes. Updated content is marked in bold while
    the ellipsis character indicates unchanged, hidden parts of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We've used our newly created user model to add a new users resource to the in-memory
    database. Currently, we'll only store one user within the users resource.
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the `pictureUrl` inside of the added user object that we're
    referencing a path called `/assets/user.svg`. You can download this resource from
    this book's online resource repository. Please find the exact download link in
    the Download section of Chapter 13, *Task Management Application Source Code*.
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose your personal profile picture instead of the generic profile
    picture that is available in the book resources. Either way, after preparing the
    image, you need to store it on the path `src/assets/` and set the filename to
    match what is specified in our user object within the in-memory database.
  prefs: []
  type: TYPE_NORMAL
- en: User service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright, we''ve prepared our model and database for handling users within our
    application. Now, we can create a new service that we are using in our container
    components to obtain the currently logged in user. Let''s create a user service
    using the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open the stub service generated on the `src/app/user/user.service.ts`
    path and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We're keeping things simple here. The only method we're providing from our service
    is the `getCurrentUser` method, which will execute a call to our in-memory web
    API and return the first user in the users resource.
  prefs: []
  type: TYPE_NORMAL
- en: That's already everything for our user service. Next up, we're going to create
    two simple UI components to display the logged in user within our application.
  prefs: []
  type: TYPE_NORMAL
- en: User area component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already created the data structures required to represent users within
    our application. We''ll now make use of this to create a user area that shows
    the user profile of the currently logged in user. The user area will be placed
    above the main navigation within the left-hand side area in our application layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e786b6fe-c402-4b8b-8f96-94c0fcdfa639.png)'
  prefs: []
  type: TYPE_IMG
- en: The user area component will be positioned above our main navigation
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will be creating a reusable component to render user profile
    pictures. Let''s use the Angular CLI to generate the stub of our profile picture
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, let''s open the component class file located in `src/app/user/profile-picture/profile-picture.component.ts`
    and change its content to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Our profile picture component has one straightforward responsibility: to render
    the profile picture of a user. It accepts an input `user` of our model type `User`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Angular framework is concerned about security, and when we are rendering
    security relevant HTML, we need to tell Angular that this specific operation should
    be considered as trusted. In our case, we will render the image source attribute
    to display user profile pictures dynamically using Angular. Image source attributes
    are considered vulnerable because they execute get requests, can contain user-generated
    content, and therefore could also contain some attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: When we're using plain string URLs within HTML resource elements, like image,
    script, or link elements, Angular will raise an error. If we want to render an
    expression to an image source attribute within an Angular template, we need to
    use Angular's DOM sanitizer to create a trusted URL first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the different use cases for using the Angular `DomSanitizer`
    to mark vulnerable resources as trusted:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Use-case** | **Component class** | **Template usage** |'
  prefs: []
  type: TYPE_TB
- en: '| Render HTML |'
  prefs: []
  type: TYPE_TB
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Render Styles |'
  prefs: []
  type: TYPE_TB
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Render links |'
  prefs: []
  type: TYPE_TB
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Resources |'
  prefs: []
  type: TYPE_TB
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Note that bypassing security is not always a good solution. If you're rendering
    user-generated content that could contain attack vectors, you should consider
    sanitizing this content. The `DomSanitizer` of Angular provides a `sanitize` method
    that allows you to sanitize content for different contexts. It will strip out
    and escape security relevant parts of the content and return a sanitized version
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of our profile picture component class, we are using the DOM sanitizer
    to create a trusted resource URL that we can then use within our template. We're
    sanitizing the user profile picture URL inside of the `OnChanges` life cycle hook.
    This way, if we're changing the user input, the trusted resource URL will also
    be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the template of our profile picture component located in `src/app/user/profile-picture/profile-picture.component.html`
    and replace the content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need in our profile picture component template. We can now use
    the trusted picture URL inside the `src` attribute, binding on an image element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s move on to the main component we''d like to create for our
    user area within the left-hand side area of our application layout. We''re using
    Angular CLI again to create the stub of our user area component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s jump right into the component class file located in `src/app/user/user-area/user-area.component.ts`
    and replace the content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special here. The user area component accepts a `user` input to render
    the profile information of a specific user. Also, we're adding an `openTasksCount`
    input to the component. This will be used to show a message about how many open
    tasks currently exist overall in the projects within the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the user area component template located in `src/app/user/user-area/user-area.component.html`
    and replace the content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: First, we're rendering the users' profile picture by using our newly created
    profile picture component. We're just forwarding the user object that we provided
    as an input to our user area component down to the profile picture component.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of the information container DIV element, we're rendering a welcome message
    for our user as well as a message to show the number of open tasks.
  prefs: []
  type: TYPE_NORMAL
- en: That wasn't too complicated. We've just created two UI components for our user
    feature. The user area UI component is rendering a section within the side area
    of our primary layout to show some profile information about the currently logged
    in user. We've also built a reusable profile picture component, which is rendering
    a user's profile image based on a user object.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the user area component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to incorporate our user component into our main layout. For this,
    we're going to modify our root application component, which is acting as our outermost
    container component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the component class of our app component located in `src/app/app.component.ts`
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We've introduced two new observables within our app component.
  prefs: []
  type: TYPE_NORMAL
- en: The `openTasksCount` observable is based on the task list observable we obtain
    by calling `getTasks` on our task list service. The task list observable is emitting
    the most recent list of all tasks within our application. Based on that, we're
    using the RxJS map operator to map the list of tasks as input to the count of
    open tasks as output. This results in an observable stream that always emits the
    most recent number of open tasks within our application.
  prefs: []
  type: TYPE_NORMAL
- en: The second observable, `user`, is obtained merely by calling the `getCurrentUser`
    method on our recently created user service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the changes within our app component template. Open the
    `src/app/app.component.html` file and apply the following changes. Effective changes
    are highlighted in bold while some unchanged code parts are hidden using the ellipsis
    character. Make sure that you only update the highlighted parts of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We're rendering a user area component and passing the required inputs by subscribing
    to our observables directly in the view using the `async` pipe. Now, as soon as
    the logged in user or the amount of open tasks changes, our user area component
    will receive the updated values as input.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You've successfully created a user area component that you can now
    preview in your browser. Try to mark tasks as done and watch the user that is
    being updated based on the overall amount of open tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Our main layout of the application is now complete, and all further enhancements
    will build on that basic layout.
  prefs: []
  type: TYPE_NORMAL
- en: Building a commenting system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve created our main project components, a reusable editor
    component, and within the previous topic, we''ve created and integrated a user
    area component. Within this topic, we''re going to create a commenting system
    that enables users to write comments on projects. The commenting system will use
    our editor component to make existing comments editable. We''re also using our
    user feature and the profile picture component to visualize user comments. Based
    on the authoring user of comments, we will decide if existing comments are editable
    for the logged in user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e4d56bd-64f9-43b4-9b44-54a57d54411c.png)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of the component subtree of our commenting system
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates the architecture of the component tree within
    the commenting system that we are about to create.
  prefs: []
  type: TYPE_NORMAL
- en: The comments component will be responsible for listing all the existing comments,
    as well as creating new comments. A comment component represents each comment
    itself. Comment components use an editor that enables users to edit comments once
    they are created.
  prefs: []
  type: TYPE_NORMAL
- en: The editor component emits an output called `outSaveEdit` once editable content
    is saved using the control buttons of the editor. In the comment component, we
    will capture the output and propagate a new output upwards to our comments component.
    From there, we will delegate the output further to a new project comments container
    component that we're creating in this topic. The project comments container will
    be responsible for storing and retrieving comments using the project service.
  prefs: []
  type: TYPE_NORMAL
- en: The comments component will also be responsible for providing the necessary
    UI logic to create new comments. The creation of further comments will also be
    communicated to the project comments container using component output. There,
    we will use the project service to add the newly created comment.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a model for comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on to creating more components within our application, let's
    first define the model and data we're using to represent comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up our model file located in `src/app/model.ts` and apply the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We've added two new interfaces to represent our comments. The `Comment` interface
    consists of a `time` property that holds a number timestamp of the time the comment
    was created. We also store the user who commented and of course the comment itself
    using a property named `content`.
  prefs: []
  type: TYPE_NORMAL
- en: The `CommentUpdate` interface is used for communicating comment updates across
    components and services.
  prefs: []
  type: TYPE_NORMAL
- en: We've also updated the model of our projects to include an additional field
    called `comments`. That's where all project comments will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re changing the `Project` interface to include a new property called
    `comments`, we also need to make sure our database is updated with this change.
    Let''s open our database located in the `src/app/database.ts` file and apply the
    following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The only difference in this file is that we've added the new `comments` property
    on our project objects. For both projects, we're just adding an empty array with
    no pre-existing comments.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, that's all the changes required in our data and model for now. Let's
    move on to the creation of our commenting system.
  prefs: []
  type: TYPE_NORMAL
- en: Building the comment component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start making our commenting system by fleshing out the comment component
    first. In addition to the comment itself, we'd like to display the user's profile,
    who commented, and the time of the comment.
  prefs: []
  type: TYPE_NORMAL
- en: To display the time, we will make use of relative time formatting, as this will
    give our users a better feel of time. Relative time formatting presents timestamps
    in the format "5 minutes ago" or "1 month ago", in contrast to absolute timestamps,
    such
  prefs: []
  type: TYPE_NORMAL
- en: as "25.12.2015 18:00". Using a famous third-party library called Moment.js,
    we'll create a view pipe that we can use within component templates to convert
    timestamps and dates into a relative time format.
  prefs: []
  type: TYPE_NORMAL
- en: View pipes are a great way to enrich the template language of Angular. They
    allow you to create helper functions that you can then use within the view inside
    of your component templates. So far, we've only used one view pipe, the `AsyncPipe`,
    which was used to subscribe to observable streams directly inside of the component
    view. Within this section, we'll create our view pipe, which can be used to format
    dates using the Moment.js library.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to install Moment.js as a production dependency to our
    project. Open up a terminal within the root folder of your project and execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'After Moment.js is installed, we can go ahead and create our first view pipe.
    We can also use the Angular CLI to generate the stub code of our pipe for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, the Angular CLI should have created a new view pipe for us with the
    name `fromNow`. Let''s open the view pipe code located in the `src/app/pipes/from-now.pipe.ts`
    file and change its content to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: All view pipes need to be decorated using Angular's `@Pipe` decorator. Inside
    of the configuration object, we can pass this to the decorator factory, and specify
    the name of the pipe. This name is how we address the view pipe within our component
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'View pipe classes should always implement an interface called `PipeTransform`.
    This interface will ensure that the mandatory method, `transform`, is implemented
    within our pipe class. The transform method is the central piece of every view
    pipe. This function will be called when a pipe is used within the view template
    of a component. Let''s look at a basic example of how a view pipe is used inside
    of a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In this essential case, we''re using a view pipe with the name `toUpperCase`.
    Angular will take the value on the left-hand side of the expression and pass it
    to the `transform` method of the `toUpperCase` pipe as the first parameter. The
    value that is returned from the `transform` method is then evaluated and rendered
    into the view. We can also compose multiple view pipes by chaining them after
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the name will be passed to the `transform` method of the `reverse`
    pipe. The returned value of the `reverse` pipe's `transform` method will then
    be passed as the first parameter to the `transform` method of the `toUpperCase`
    pipe. Like this, you can chain an indefinite amount of pipes onto each other to
    transform component properties directly in your component view template.
  prefs: []
  type: TYPE_NORMAL
- en: View pipes are treated as stateless by default. Angular uses this assumption
    to perform some optimizations in the background. If pipes and their `transform`
    methods can be considered stateless and pure, Angular can cache the results of
    pipe transformations and re-use the cached values later on. This behaviour is
    okay in most cases, and we don't want to miss out on that performance optimization.
    However, sometimes it's required to rely on some services or other sources of
    state to determine the result of a pipe transformation. In such a case, the `transform`
    method of a pipe is not pure, and therefore cannot be cached. To tell Angular
    that our pipe is not pure, you can use an additional configuration property on
    pipes called `pure`. If you set this property to false, your pipe transformations
    will not be cached, and Angular will execute your `transform` method every time
    your view is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use our newly created `fromNow` pipe to format the timestamp of comments
    within our comment component. We''re using the Angular CLI again to create the
    structure for the comment component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open the component template file located in `src/app/comments/comment/comment.component.html`
    and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We're reusing our profile picture component to render the comment author user.
    To display the time of the comment in a relative format, we'll use the `fromNow`
    pipe that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will make use of the in-place editor component to display the content
    of the comment and make it editable at the same time. We will bind the comment
    content property to the `content` input property of the editor. At the same time,
    we will listen for the `outSaveEdit` output of the editor and call the `updateComment`
    method on our comment component class.
  prefs: []
  type: TYPE_NORMAL
- en: We're also deciding if the currently logged in user passed into our component
    as `user` input is the authoring user of the given comment and then use this information
    to either enable or disable the controls on our editor using the `showControls`
    input property. This way, the current user is only allowed to edit a comment if
    he/she's also the author of that comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also create our component class and open the `src/app/comments/comment/comment.component.ts`
    file to replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The component code is pretty straightforward. As input, we expect a user object
    that is passed along to the `user` input property. This property represents the
    currently logged in user and is used within our template to determine if a user
    should be able to edit the comment. The `comment` input property is expected to
    be an object of type `Comment`. From there, we gather the comment content, the
    time of creation, and the comment author user.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the view template of our comment component, we can observe that
    the `outSaveEdit` output on the editor component will call the `updateComment`
    method in our comment component. Inside of the `updateComment` method, we're creating
    a copy of our comment object and updating its content with the editor output.
    This copy is then emitted using the `outUpdateComment` output of the comment component.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need for our comment component. Next up, we're going to create
    the comments component, which represents a list of comments and embraces the necessary
    UI element to create new comments.
  prefs: []
  type: TYPE_NORMAL
- en: Building the comments component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last missing piece of the puzzle for our commenting system is the comments
    component, which will list all the comments and provide the UI to create new comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7960e916-5e1f-4b48-b681-8743f531e4d2.png)'
  prefs: []
  type: TYPE_IMG
- en: The comments component allows users to add comments to projects
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the Angular CLI to create the structure for our comments component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s edit the template of our comments component located in `src/app/comments/comments/comments.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: To allow users to create new comments, we're making use of the contenteditable
    API by adding a DIV element that contains the `contenteditable` attribute. We're
    using a local view reference called `#commentContentEditable` on that element
    so that we can quickly reference it from within our component class.
  prefs: []
  type: TYPE_NORMAL
- en: To add a new comment, we will use a button with a click event binding that calls
    the `createComment` method on our component class.
  prefs: []
  type: TYPE_NORMAL
- en: Below the section where users can add new comments, we will create another section
    that will list all the existing comments. If no comments exist, we just don't
    render the section.
  prefs: []
  type: TYPE_NORMAL
- en: We're using a particular view element called `<ng-container>` to group our All
    comments title together with the list of comments. This container element is handy
    in situations where you're using template elements, like with the use of `NgIf`,
    but you don't want to create an artificial HTML element for that purpose. Using
    an `<ng-container>` element in conjunction with `NgIf` allows you to show or hide
    a list of elements conditionally, but without the need to have a common parent
    HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of the `NgFor` directive, we are repeating over all existing comments
    and rendering a comment component for each repetition. We are binding the comment
    object to our comment component and also adding an output binding to handle updated
    comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the class of our comments component by changing the content of
    the `src/app/comments/comments/comments.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Our component class has two inputs. The `user` input is expected to be set to
    the currently logged in user. The comments input is a list of comments that is
    used in our component view to iterate over and render comment components.
  prefs: []
  type: TYPE_NORMAL
- en: We also have two outputs in our component. The fist one, `outUpdateComment`,
    is used to tell our parent that one of the comments has been updated. The output
    value is of type `CommentUpdate`, which holds the index of the comment that got
    updated and the comment object itself. Inside of the `updateComment` method, which
    is called from the binding on comment components in our view, we're constructing
    a comment update object and emitting it through the `outUpdateComment` output.
  prefs: []
  type: TYPE_NORMAL
- en: The `outCreateComment` output is used to tell our parent that a new comment
    should be created. The `createComment` method is used to create a new comment
    object and emit it through that output. Additionally, we're using a view query
    to get hold of the editable DOM element within our component view and store it
    into the member property `commentContentEditable`. When a new comment is created
    using the `createComment` method, after we've emitted the newly created comment
    object, we're using the reference to the editable item to reset its text content.
    This way, after creating a new comment, the editable content element will be blank
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the commenting system into projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've created our comments model and updated our in-memory web API database.
    We've created the comment and comments components along with a new view pipe called
    `fromNow` to format relative times in our comment view template. The only missing
    part is to integrate our comments component in our project. For this, we are making
    use of the second tab on our project component, which we've already prepared for
    for our commenting system. To keep our data flow tight, we're introducing a final
    component to fill the gap between our projects and the comments component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use Angular CLI to create the project comments container component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'After the component files have been generated, let''s open the class file located
    in `src/app/container/project-comments-container/project-comments-container.component.ts`
    and replace its content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Within our project comments container, we're storing three different observables.
    Let's take a look at each of them and their purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The `user` observable emits the currently logged in user. Within the constructor
    of our container component, we're calling the `getCurrentUser` method on the user
    service to obtain the observable.
  prefs: []
  type: TYPE_NORMAL
- en: The `selectedProject` observable is obtained by calling `getSelectedProject`
    on our project service. This observable will always emit the currently selected
    project. If we're choosing a different project in our main navigation, the newly
    selected project is emitted through this observable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `projectComments` observable is a transformed observable with the
    `selectedProject` observable as a source. We would like to access the project
    comments directly so we can use them as input to our commenting system. By using
    the `map` operator inside a pipe transformation, we can select the `comments`
    field of the selected project and create a new output observable that is always
    emitting the comments list of the selected project.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we're providing two methods, `createComment` and `updateComment`, to
    create or update comments using the project service. We're obtaining the latest
    value of the `selectedProject` observable by utilizing the `take` operator and
    updating an existing or adding a new comment using the project service, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the code of our component class. You should be reasonably familiar
    with the logic inside of our container component. The patterns we're using are
    very similar to those from our existing task list container, or the ones present
    in our app component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the view template of our project comments container component located
    in `src/app/container/project-comments-container/project-comments-container.component.html`
    and change its content to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing we wouldn't expect from a regular container component template.
    We're merely rendering a comments UI component and binding all inputs and outputs
    of the component to the logic and data within our container component class. Again,
    we're making our comments UI component highly reusable by separating the state
    and data concerns with the use of a container component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, we''re almost finished integrating our commenting system. The last
    missing bit is to include our project comments container component within our
    project component. Let''s open the view template of the project component located
    in `src/app/project/project/project.component.html` and apply the necessary changes
    to render our commenting system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We're just reusing the same logic we've already used to render our task list
    container. We ensure that our tabbed interface within the project component activates
    the project comments container component by placing an `NgIf` with the respective
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: There you go! That wasn't too complicated, was it? We've finally created and
    integrated a commenting system on our projects. Due to the way we've built our
    commenting system, we can integrate comments in any other location we want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Preview your changes in the browser and play around with the commenting functionality
    a bit to get familiar with what you''ve just built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09c1e366-895d-482f-ae50-97f2acc364a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the commenting system that is integrated within our project component
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this topic, we have successfully created a fully-fledged commenting system
    that can be placed in various areas of our application to enable commenting. Users
    can interact with in-place editors to edit the content in comments, which gives
    them a great user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'While writing the code for our commenting system, we learned about the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a re-usable commenting system that can be used to add commenting functionality
    in every area of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple pipe using the `@Pipe` decorator and the Moment.js library
    to provide relative time formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `<ng-container>` element to group elements for use within a template
    directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-using the editor component as an in-place editor within the comment component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main topic of this chapter was the introduction of projects. We've created
    the necessary model and data layer to deal with projects to group individual tasks.
    We've also created UI components to display project information and a tabbed user
    interface component that we can reuse wherever we need it. We learned about the
    concept of content projection, which allows us to build beautiful content-based
    APIs for our components.
  prefs: []
  type: TYPE_NORMAL
- en: We've further structured our main layout and introduced some navigation components
    that we're currently using to provide a project navigation.
  prefs: []
  type: TYPE_NORMAL
- en: We created a simple in-place editor that provides an excellent authoring experience
    within our application. Going forward, we can use the editor component wherever
    we want to make content editable for our users. They will not have to jump into
    disturbing dialogues or separate configuration pages, and will be able to edit
    directly within their current context. This is an excellent tool for enhancing
    the experience of our users.
  prefs: []
  type: TYPE_NORMAL
- en: Besides our shiny new editor component, we created a whole commenting system
    that can be easily included in areas of our application where we'd like to provide
    commenting capabilities. We have added the commenting system within our project
    and users can now comment on projects by navigating to the Comments tab on the
    project details.
  prefs: []
  type: TYPE_NORMAL
- en: The project navigation and the tabbed interface we've built are both great.
    However, it would be nice to think that the concern of navigation could be separated
    from our regular application composition. We also want to leverage the browser's
    location URL and the native functionality of the browser history. Within the next
    chapter, we're going to address this and learn everything required to integrate
    the Angular router into our application.
  prefs: []
  type: TYPE_NORMAL
