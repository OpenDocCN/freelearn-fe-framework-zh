- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular and the Angular CDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular has an amazing ecosystem of tools and libraries, including Angular Material,
    the **Angular command-line interface** (**Angular CLI**), and the beloved **Angular
    Component Dev Kit** (**Angular CDK**). I call it “beloved” because if you are
    to implement your own custom interactions and behaviors in Angular apps without
    having to rely on an entire set of libraries, the Angular CDK is going to be your
    best friend. In this chapter, you’ll learn what an amazing combination of Angular
    and the Angular CDK is. You’ll learn about some neat components built into the
    CDK and will also use some CDK **APIs** to create amazing and optimized content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the recipes we’re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using virtual scroll for huge lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard navigation for lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointy little popovers with the Overlay API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input coercion utilities from the Angular CDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the CDK drag and drop API to move items from one list to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi-step game with the CDK stepper API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessible Listbox interactions using CDK listbox directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with nested menus using the Angular CDK menu API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter09](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Using virtual scroll for huge lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There might be certain scenarios in your application where you might have to
    show a huge set of items. This could be from either your backend API or the browser’s
    local storage. In either case, rendering a lot of items at once causes performance
    issues because the **Document Object Model** (**DOM**) struggles, and also because
    of the fact that the JS thread gets blocked, and the page becomes unresponsive.
    In this recipe, we’ll render a list of 270,000 users and use the `virtual scroll`
    functionality from the Angular CDK to improve the rendering performance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-virtual-scroll`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab. When you click the **Get Data**
    button, you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.1: The ng-cdk-virtual-scroll app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a pretty simple Angular app, but with a lot of data. Right now, it
    shows a loader (button) for about a couple of seconds and then is supposed to
    show the data. However, you’ll notice that right after the **Tap me** button disappears,
    the loader keeps showing, the button is unresponsive, and we see a blank screen,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: App stuck with a blank screen while rendering list items'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, our entire application becomes unresponsive. If you scroll through—or
    even hover over—the items, you’ll see that the hover animation on the list items
    is not smooth and is a bit laggy. Let’s see the steps to use the Angular CDK virtual
    scroll to improve the rendering performance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the Angular CDK installed in the workspace. However, if you
    needed to install it, you would run the following command from the project’s root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may have to restart your Angular server if you reinstall the package, so
    rerun the `npm run serve ng-cdk-virtual-scroll` command again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ScrollingModule` class from the `@angular/cdk` package into the `users-list.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now must implement the virtual scroll, modify the `users-list-item.component.html`
    file to use the `*cdkVirtualFor` directive instead of the `*ngFor directive`,
    and wrap the `<li>` element inside a `<cdk-virtual-scroll-viewport>` element,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we have moved the CSS classes `"``list list-group p-2"` from the
    `<ul>` element to the `<cdk-virtual-scroll-viewport>` element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Boom! Within a few steps, and by using the Angular CDK virtual scroll, we were
    able to fix a huge performance rendering issue within our Angular app. See the
    next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular CDK provides the Scrolling APIs, which include the `*cdkVirtualFor`
    directive and the `<cdk-virtual-scroll-viewport>` element. It is necessary to
    have `<cdk-virtual-scroll-viewport>` wrapping the element that has the `*cdkVirtualFor`
    directive being applied to it. Notice that we have an attribute on the `cdk-virtual-scroll-viewport`
    element named `[itemSize]`, having its value set to `"``120"`. The reason for
    this is that each list item has a height of approximately 120 pixels, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Each list item has a height of approximately 120 pixels'
  prefs: []
  type: TYPE_NORMAL
- en: But how does it improve the rendering performance? Glad you asked! In the original
    code for this recipe, when we loaded the 270,000 users, it would create a separate
    `<li>` element with the `class="list__item list-group-item"` attribute for each
    user, thus creating 270,000 DOM elements all being rendered at once. With the
    virtual scroll in place, the CDK only creates a few `<li>` elements, renders them,
    and just replaces the content of those few `<li>` elements as we scroll through
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, it creates 6 `<li>` elements, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Showing only a few <div> elements rendered on DOM due to virtual
    scroll'
  prefs: []
  type: TYPE_NORMAL
- en: Since we only have a few elements rendered on the DOM, we don’t have performance
    issues anymore, and the hover animation also seems super-smooth now.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing virtual scroll in your own applications, make sure that you
    set a specific height to the `<cdk-virtual-scroll viewport>` element, and also
    set the `[itemSize]` attribute equal to the expected list-item height in pixels,
    otherwise the list won’t show.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular CDK scrolling examples: [https://material.angular.io/cdk/scrolling/examples](https://material.angular.io/cdk/scrolling/examples)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard navigation for lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessibility is one of the most important aspects of building apps with a great
    user experience. The apps should not only be fast and performant but also accessible.
    While there are a lot of things to consider when it comes to accessibility, in
    this recipe, we’re going to make lists and list items more accessible by providing
    keyboard navigation for the items. With the Angular CDK, it is super simple. We’re
    going to use the `ListKeyManager` service from the Angular CDK to implement keyboard
    navigation for the users list in our target application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-lkm`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.5: The ng-cdk-lkm app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that already has some of the goodness of the Angular CDK—that
    is, it has virtual scroll implemented from the previous recipe. We’ll now start
    making changes to the app to implement keyboard navigation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll implement the `FocusableOption` interface and some accessibility
    factors to our `UsersListItemComponent` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to implement what happens in the `focus` method. We’ll use the
    `ElementRef` service to get the `nativeElement` and will set focus on the `nativeElement`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add some accessibility to the list itself. Update the file `users-list.component.ts`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to implement the `FocusKeyManager` class in our `UsersListComponent`
    class. We’ll have to query our list items in the component to create an instance
    of the `FocusKeyManager` class. Update the `users-list.component.ts` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now initiate the `FocusKeyManager` instance in the `AfterViewInit` hook
    in the same file. Update the `users-list.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to listen to the keyboard events. For this, you could either
    use a `keydown` event or a `window:keydown` event. For simplicity of the recipe,
    we’ll go with the `window:keydown` event as pressing any key will bubble up the
    event to the `window` object. Update the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you go to the app, and press the down arrow key, you should see the first
    item being focused on the list and you can navigate to next and previous items
    and focusing them using the arrow keys.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add a bit more fun to the recipe, let’s also implement an event listener
    for when the user presses the *Enter* key on a particular item. We will just show
    an alert with the item’s details. Let’s use a `HostListener` decorator in the
    `users-list-item.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the above change, you should be able to see the selected item as shown
    in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.6: Selected item JSON being shown in an alert'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Awesomesauce! You have just learned how to implement keyboard navigation using
    the Angular CDK. See the next section to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular CDK provides the `ListKeyManager` class, which allows you to implement
    keyboard navigation. There are a bunch of techniques we can use with the `ListKeyManager`
    class, and for this recipe, we chose the `FocusKeyManager` class. To make it work
    for a list of items, we needed to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: We made sure that we had a component for each item in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used `ViewChildren` with `QueryList` in the list component to query all the
    list item components. `ViewChildren` is a property decorator that retrieves all
    the `UsersListItemComponent` elements from the DOM using `QueryList`, which gets
    updated automatically if an item is added, removed, or updated in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then created an instance of the `FocusKeyManager` class in the list component
    so we can initiate the list item component elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Added a keyboard listener to the list component and passed the event to the
    instance of the `FocusKeyManager` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we defined the `listKeyManager` property in the `UsersListComponent` class,
    we also defined its type as well by specifying it as `FocusKeyManager<UsersListItemComponent>`.
    This made it easier to understand that our `FocusKeyManager` class is supposed
    to work with an array of `UsersListItemComponent` elements. Therefore, in the
    `ngAfterViewInit` method, we specified `this.listKeyManager = new FocusKeyManager(this.listItemsElements);`,
    which provided a queried list of `UsersListItemComponent` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we listened to the `window:keydown` event, we took the `keydown`
    event received in the handler and provided it to the instance of our `FocusKeyManager`
    class as `this.listKeyManager.onKeydown(event);`. This told our `FocusKeyManager`
    instance which key was pressed and what it must do.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `UsersListItemComponent` class implements the `FocusableOption`
    interface, and it also has the `focus` method, which the `FocusKeyManager` class
    uses behind the scenes when we press the keyboard arrow-down or arrow-up keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also used two properties with the `HostBinding` decorator. Let’s
    analyze them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `HostBinding` decorator is used here to bind a class property (`tabIndex`)
    to a host element’s attribute `(tabIndex).` This effectively sets the `tabIndex`
    of the component’s host element to `-1`, making it programmatically focusable
    but not reachable via sequential keyboard navigation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the above binds the role property of the class to the role attribute
    of the component’s host element. It assigns the ARIA role list item to the host
    element, providing a hint to assistive technologies about how they should interpret
    this element.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how the recipe works, see the next section for some relevant
    links.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular CDK accessibility documentation: [https://material.angular.io/cdk/a11y/overview](https://material.angular.io/cdk/a11y/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewChildren` official documentation: [https://angular.io/api/core/ViewChildren](https://angular.io/api/core/ViewChildren
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointy little popovers with the Overlay API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the advanced recipes in this book, especially for those of you
    who have already been working with Angular for a while. In this recipe, we’ll
    not only create some **popovers** using the **CDK Overlay API**, but we’ll also
    make them pointy, just like tooltips, and that’s where the fun lies.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-popover`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.7: The ng-cdk-popover app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our app has a list of users that we can scroll through on the page. We’ll add
    a popover menu to each item so that a drop-down menu is shown with some actions.
    We already have the `@angular/cdk` package installed, so we don’t need to worry
    about that. Let’s start with the recipe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first add the Overlay’s default styles so that when the overlay is displayed,
    it is positioned correctly. Open the `src/styles.scss` file and update it as per
    the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://ng-cookbook.com/s/cdk-pane-styles](https://ng-cookbook.com/s/cdk-pane-styles
    )'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll create variables to hold the overlay origin (for the origin of the
    positions of the opened overlay) and the actual relative position’s settings.
    Open the `users-list.component.ts` file and update it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `users-list.component.html` file and add the `cdkOverlayOrigin`
    directive to the `<app-users-list-item>` selector so that we can have each list
    item as an origin for the pop-up menu, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to somehow pass the `#menuTrigger` variable from the template to assign
    its value to the `popoverMenuOrigin` property in the `UsersListComponent` class.
    To do so, create a method named `openMenu` in the `users-list.component.ts` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need a property to show/hide the popover menu. Let’s create it and
    set it to `true` in the `openMenu` method as well. Update the `users-list.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now create an actual overlay. To do so, we’ll create an `<ng-template>`
    element with the `cdkConnectedOverlay` directive. At the bottom of the `users-list.component.html`
    file, add the code `(<ng-template>` `element)` from the following link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://ng-cookbook.com/s/ng-popover-overlay](https://ng-cookbook.com/s/ng-popover-overlay
    )'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to pass the `#menuTrigger` variable that we have on each list item
    to the `openMenu` method on a click of the list item. Update the file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you refresh the app now and click on any of the list items, you should see
    a drop-down menu, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.8: Working drop-down menu for each list item'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now have to implement the part where we show a pointy little arrow with
    the drop-down menu so that we can correlate the drop-down menu with the list item.
    First, add the following styles to the `menu-popover` class in the `src/styles.scss`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now be able to see a pointy arrow on the top right of the drop-down
    menu, but if you try clicking the last item on the screen, you’ll see that the
    drop-down menu opens upward but still shows the pointer at the top, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_09.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.9: Drop-down arrow pointing at the wrong list item'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To point to the actual origin of the popover/drop-down menu, we need to implement
    a custom directive that applies a custom class to the popover. Let’s start by
    creating a directive, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the code in the `popover-positional-class.directive.ts` generated file
    as per the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://ng-cookbook.com/s/popover-pc-directive](https://ng-cookbook.com/s/popover-pc-directive)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s import the `PopoverPositionalClassDirective` class in the file `users-list.component.ts`
    so we can use it in the template later. Update the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `users-list.component.html` file to apply our directive to the
    `<ng-template>` element. Update the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to create a `popoverMenuPosition` property and a `popoverPositionChanged`
    method in our `users-list.component.ts` file to track which list item is for opening
    the menu (for positioning) and which is for when the position of the menu changes
    due to resizing of the window or a change in content. Update the file further
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And voilà! If you now refresh the page and tap each of the list items, you’ll
    see the arrows point in the correct direction. See the following screenshot to
    view the popover arrow pointing downward for the last item, due to the popover
    being shown above the item:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_10.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.10: Drop-down arrow pointing at the correct list item (pointing downward)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! You now know how to use the Angular CDK to work with overlays to create
    custom pop-up/drop-down menus. Moreover, you now know how to quickly implement
    the pointy arrows on the menu using a custom directive. See the next section to
    understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing an overlay using the Angular CDK Overlay API includes a couple
    of pieces to work with. We first have to import the `OverlayModule` class in our
    `UserListComponent` class’s imports. We do this because the `OverlayModule` contains
    the directives we are using in the application: for example, the `CdkConnectedOverlay`
    directive and the `CdkOverlayOrigin` directive. After importing the module for
    creating an overlay, we need to have both an overlay (the menu in our case) and
    an overlay origin (which opens/shows the menu). In this recipe, since we’re using
    the overlay to create a popover menu for each list item, we use the `cdkOverlayOrigin`
    directive on the `<app-users-list-item>` elements. Notice that the `<app-users-list-item>`
    elements are being rendered through the `*ngFor` directive.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in order to know which item was clicked or precisely which item we
    need to show the popover for, we create a `#menuTrigger` template variable on
    each list item element, and you’ll notice that we also bind the `(click)` event
    on the list items to call the `openMenu` method, passing this `menuTrigger` template
    variable into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you have noticed the `openMenu` method in the `users-list.component.ts`
    file, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we assign the `itemTrigger` property to our class’s `popoverMenuOrigin`
    property. This is because this `popoverMenuOrigin` property is being bound with
    the actual overlay in our template. You can also see that we set the `menuShown`
    property to `true`, and this is because it will decide whether the overlay should
    be shown or hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see the code for the actual overlay, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss each of the `cdkConnectedOverlay` directive’s attributes, one
    by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cdkConnectedOverlay` attribute: This is the actual overlay directive that
    makes the `<ng-template>` element an Angular CDK overlay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayOrigin]` attribute: This tells the Overlay API what
    the origin of this overlay is. This is to help the CDK decide where to position
    the overlay when opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayOpen]` attribute: This decides whether the overlay
    should be shown or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayHasBackdrop]` attribute: This decides whether the
    overlay should have a backdrop or not—that is, if it has a backdrop, the user
    shouldn’t be able to click anything else apart from the overlay when it is open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `(backdropClick)` attribute: This is the event handler for when we click
    the backdrop. In this case, we’re setting the `menuShown` property to `false`,
    which hides/closes the overlay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayPositions]` attribute: This provides the positioning
    configuration to the Overlay API. It is an array of preferred positions that defines
    whether the overlay should be shown below the origin, on top of the origin, on
    the left, on the right, how far from the origin, and so on using properties such
    as `originX`, `originY`, `overlayX`, and `overlayY`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayPanelClass]` attribute: A **CSS** class to be applied
    to the generated overlay. This is used for styling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of the attributes set correctly, we are able to see the overlay working
    when tapping the list items. *“But what about the pointy arrows, Ahsan?”* Well,
    hold on! We’ll discuss them too.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the Angular CDK Overlay API already has a lot of things covered, including
    where to position the overlay based on the available space, and since we want
    to show the pointy arrows, we’ll have to analyze whether the overlay is being
    shown above the item or below the item. By default, we have the following styles
    set in the `src/styles.scss` file to show the pointy arrow below the popover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we have the `--up` modifier class, as follows, to show the overlay
    *above* the popover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s talk about how and when this `--up` modifier class is applied. We
    have created a custom directive named `appPopoverPositionalClass`. This directive
    is also applied to the `<ng-template>` element we have for the overlay—that is,
    this directive is applied with the `cdkConnectedOverlay` directive and expects
    the following input attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `appPopoverPositionalClass` attribute: The actual directive selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `targetSelector` attribute: The query selector for the element that is
    generated by the Angular CDK Overlay API. Ideally, this should be the same as
    what we use in `cdkConnectedOverlayPanelClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `inverseClass` attribute: The class to be applied when the vertical position
    (`originY`) of the overlay is changed—that is, from `"top"` to `"bottom"`, and
    vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `originY` attribute: The `originY` position of the overlay at the moment.
    The value is either `"top"` or `"bottom"`, based on the overlay position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a `(positionChange)` listener on the CDK Overlay `<ng-template>` element
    that triggers the `popoverPositionChanged` method as soon as the overlay position
    changes. Notice that inside the `popoverPositionChanged` method, upon getting
    a new position, we update the `popover.originY` property that is updating `menuPopoverOrigin.originY`,
    and then we’re also passing `menuPopoverOrigin.originY` as the `[originY]` attribute
    to our `appPopoverPositionalClass` directive. Since we’re passing it to the directive,
    the directive knows if the overlay position is `"top"` or `"bottom"` at any particular
    time. How? Because we’re using the `ngOnChanges` life cycle hook in the directive
    to listen to the `originY` attribute/input, and as soon as we get a different
    value for `originY`, we either add the value of `inverseClass` as a CSS class
    to the `Overlay` element or remove it based on the value of the `originY` attribute.
    Also, based on the applied CSS classes, the direction of the popover arrow is
    decided for the overlay.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular CDK Overlay API: [https://material.angular.io/cdk/overlay/overview](https://material.angular.io/cdk/overlay/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CdkOverlayOrigin` directive documentation: [https://material.angular.io/cdk/overlay/api#CdkOverlayOrigin](https://material.angular.io/cdk/overlay/api#CdkOverlayOrigin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input coercion utilities from the Angular CDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of those cool things that you see and think, “Oh, that could’ve
    been handy if I knew about this before.” I absolutely thought that about these
    coercion utilities from the Angular CDK. There have been many times when you have
    a number value as an input in an Angular component and you are forced to use the
    square bracket notation `([myNumberInput]="numberValue")` because if you use `"``myNumberInput="numberValue"`,
    it is interpreted as a literal string `"numberValue"` instead of a variable. The
    coercion utilities from the Angular CDK are exactly what we need here.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-coercion`inside
    the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_11.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.11: using-cdk-coercion running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a rating component that takes a few inputs, including “value” and “disabled.”
    However, we can’t really use them like usual attributes and have to use square
    brackets notation for the Angular attribute bindings for both of them. We’ll fix
    that in the recipe. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s say we want to add a new feature to the ratings component—that
    is, having a max number for the rating. Right now, it defaults to `5`. So we’ll
    create a new input in the `rating.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll provide the max input to the rating component from the home component.
    We’ll set its value to `8`. But we’ll use the usual HTML notation to supply the
    value. Update the usage of the `<app-rating-component>` in the `home.component.html`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ll notice immediately that the IDE throws an error as we can’t assign a
    string value to a number input.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll now use the coercion utilities from the Angular CDK to solve this issue.
    Update the `rating.component.ts` file to use the `NumberInput` type and the `coerceNumberProperty`
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you check the `home.component.html` file again, you’ll see that the error
    is gone and the app compiles without any issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s make the `disabled` property coerced as well. We’ll try to use the double-curly-braces
    `{{}}` notation for this input. Update the usage of the `<app-rating>` element
    in the `home.component.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll see an error in both the IDE and the compilation: `Type ''string'' is
    not assignable to type ''boolean''`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the issue, let’s use the `BooleanInput` and `coerceBooleanProperty`
    method in the `rating.component.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And voilà! Your code should be compiled without errors, and you should be able
    to provide values without the forced square-bracket attribute binding notation.
    What’s great is that even if you just add the `disabled` attribute to the `<app-rating>`
    element, it will disable the component, which is what happens when we apply the
    `disabled` attribute to a regular `input` element or `textarea`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we used two different methods from the Angular CDK’s coercion
    utilities. The `coerceNumberProperty` method and the `coerceBooleanProperty` method.
    Let’s first have a look at the `coerceNumberProperty` method along with the `NumberInput`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The `NumberInput`type resolves to being `string | number | null | undefined`,
    which makes it possible for us to provide the values as any of those types. And
    when we don’t use the square-bracket notation for attribute binding, the value
    is considered as a **string**. This seems to be covered by the `NumberInput` type.
    The `coerceNumberProperty` method takes any value and converts it into a number.
    The function also takes a second optional argument as the fallback value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usages of the `BooleanInput` type and the `coerceBooleanProperty` method
    are very similar to the `NumberInput` type and `coerceNumberProperty` respectively.
    The difference, however, is that the `coerceBooleanProperty` method takes any
    value and converts it into a boolean. The logic behind this method is a bit different
    as it looks for the following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Which means if the attribute is provided without a value, it is going to be
    an empty string. And even though empty string is a falsy value, with the coerceBooleanProperty,
    an attribute without a value (empty string) will resolve as a truthy value.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CDK coercion documentation: [https://material.angular.io/cdk/coercion/overview](https://material.angular.io/cdk/coercion/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the CDK Drag and Drop API to move items from one list to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever used the Trello board app, or maybe other apps that also allow
    you to drag and drop list items from one list to another? Well, you can do this
    easily using the Angular CDK, and in this recipe, you’ll learn about using the
    **Angular CDK Drag and Drop API** to move items from one list to another. You’ll
    also learn how to reorder lists.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-drag-drop`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_12.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.12: The ng-cdk-drag-drop app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have an interesting app that has some folders and files.
    We’re going to implement the drag-and-drop functionality for the files to be dragged
    to other folders, which should update the folder’s file count instantly, and we
    should be able to see the file in the new folder as well. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to import `DragDropModule` because we use the `CdkDrag`
    and the `CdkDropList` directives in our app which belong to it. We will import
    the module into the `imports` array of our `FoldersListComponent` class. Modify
    the `folders-list.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll apply the `cdkDrag` directive to each of our files and will apply
    the `cdkDropList` directive to each of the folders. Update the `folders-list.component.html`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also enable reordering of the files within a folder by adding the `cdkDropList`
    directive to the container elements for the files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now define the origin of the drag-and-drop interaction by specifying
    the `[cdkDragData]` attribute on each `<app-file>` element and the `[cdkDropListData]`
    attribute on each `<app-folder>` element, and on the files container as well.
    Update the template again, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to implement what happens when the file is dropped. To do so, we’ll
    use the `(cdkDropListDropped)` event handler. Update the template, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to implement the `onFileDrop` method. Update the `folders-list.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `moveItemInArray` method and the `transferArrayItem` method are built-in
    from the Angular CDK. This makes our implementation a breeze.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to implement drag-and-drop previews, we need to enclose the droplists
    and the draggable items into an element with the `cdkDropListGroup` directive.
    Update the `folders-list.component.html` file and apply the directive to the element
    with the `folders` class (i.e., at the top level), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To apply a custom drag preview, we use a custom element with the `*cdkDragPreview`
    directive applied to it. Update the `folders-list.component.html` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `fa-icon` component to work, we also need to import the `FontAwesomeModule`
    in the `FoldersListComponent` class. Update the file below as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need some styles for the drag-and-drop previews. Update the `folders-list.component.scss`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also add some styles to make sure the other list items move smoothly
    when reordering the items within a folder. Since we need to style the elements
    from the Angular CDK, and they have styles encapsulation, we need to add the styles
    in our global `scss` file. Update the `folders-list.component.scss` file further,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create a drop preview (a placeholder that appears until we
    release the dragged file) template as well. For this, we use the `*cdkDragPlaceholder`
    directive on the `preview` element. Update the `folders-list.component.html` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s create an `upArrow` property using the `faArrowAltCircleUp`
    icon from the `@fortawesome` package. Update the `folders-list.component.ts` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And boom! We now have a seamless **User Experience** (**UX**) for the entire
    drag-and-drop flow. Like it? Make sure that you share a snapshot on your X (Twitter)
    and tag me at **@codewith_ahsan**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finished the recipe, let’s see in the next section how it all
    works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There were a couple of interesting directives in this recipe, and we’ll go through
    them all one by one. First of all, as good Angular developers, we import the `DragDropModule`
    class into the `imports` array of our `standalone component`named `FoldersListComponent`,
    just to make sure we don’t end up with errors. Then, we start making the files
    draggable. We do this by adding the `cdkDrag` directive to each file element by
    applying the `*ngFor` directive to it. This tells the Angular CDK that this element
    will be dragged and, therefore, the Angular CDK binds different handlers to each
    element to be dragged.
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular components by default are not block elements. Therefore, when applying
    the `cdkDrag` directive to an Angular component such as the `<app-file>` component,
    it might restrict the animations from the CDK being applied when we’re dragging
    the elements. In order to fix this, we need to set a `display: block;` for our
    component elements. Notice that we’re applying the required styles in the `folders-list.component.scss`
    file (line 25) for the `.folders__selected-folder-files__file` class.'
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the drag elements, we use the `cdkDropList` directive for
    each container DOM element where we’re supposed to drop the file. In our recipe,
    that is each folder that we see on the screen, and we can also reorder the files
    within a folder. Therefore, we apply the `cdkDropList` directive to the wrapper
    element of the currently displayed files, as well as to each `<app-folder>` item
    with the `*ngFor` looping over the `folders` array.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we specify the **data** that we’re dragging by specifying `[cdkDragData]="file"`
    for each draggable file. This helps us identify it in the later process when we
    drop it either within the current folder or within other folders. We also specify
    in which array this dragged item will be added when dropped upon the particular
    list, and we do this by specifying `[cdkDropListData]="ARRAY"` statements for
    the elements that we’ve applied the `cdkDropList` directive to. When the Angular
    CDK combines the information from the `cdkDragData` and the `cdkDropListData`
    attributes, it can easily identify if the item was dragged and then dropped within
    the same list or in another list.
  prefs: []
  type: TYPE_NORMAL
- en: To handle what happens when we drop the dragged file, we use the `(cdkDropListDropped)`
    method from the Angular CDK on the element with the `cdkDropList` directive. We
    take the `$event` emitted from the CDK and pass it to our `onFileDrop` method.
    What’s great is that within the `onFileDrop` method, we use the `moveItemInArray`
    and `transferArrayItem` helper methods from the Angular CDK, with a really simple
    bit of logic to compare the containers. That is, the Angular CDK provides us with
    enough information that we can get away with the whole functionality really easily.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the recipe, we customize how our drag preview should look
    when we are dragging a file using a custom template, by using the `*cdkDragPreview`
    directive on it. This tells the Angular CDK to not render it right away but to
    show it with the mouse when we start dragging a file. For our recipe, we only
    show the icon of the file as the drag preview. And finally, we also customize
    the drop preview (or drag placeholder) usingthe `*cdkDragPlaceholder` directive,
    which shows a transparent rectangle with an upward-arrow icon to reflect where
    the item is going to be added when dropped. Of course, we had to add some custom
    styles for both the drag preview and the drop preview.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular CDK Drag and Drop documentation: [https://material.angular.io/cdk/drag-drop/overview](https://material.angular.io/cdk/drag-drop/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi-step game with the CDK Stepper API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you try finding examples of the CDK Stepper API over the internet, you’ll
    find a bunch of articles revolving around creating multi-step forms using the
    CDK Stepper API, but since it is a stepper at its base, it can be used for various
    use cases. In this recipe, we’re going to build a guessing game using the Angular
    CDK Stepper API, in which the user will guess what the output of a rolled dice
    will be.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-stepper`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_13.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.13: The ng-cdk-stepper app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let’s look at how to create a multi-step game with the CDK Stepper API
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a really simple yet interesting application at hand that has a couple
    of components built already, including the `dice component`, the `value-guess
    component`, and the `leaderboard component`. We’ll create this game as a multi-step
    game using the **Stepper API**. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `CdkStepperModule` class from the `@angular/cdk` package
    in the `game.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create our stepper component now. Run the following command in the workspace
    root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choose the `@nx/angular:component` schematic when asked and select the “As provided”
    option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To make our component a `CdkStepper`, we need to provide it using the `CdkStepper`
    token and have to extend our component class from `CdkStepper` as well. We can
    remove the `constructor`, the `OnInit` implementation, and the `ngOnInit` method.
    Modify the `game-stepper.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `CDKStepper` provides us helpful methods like `next`, `previous`, and `reset`
    to navigate between the steps, and the `selectedIndexChange`event emitter to identify
    when a step is changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add the template for our `<game-stepper>` component. We’ll start by adding
    the header that will show the step label. Update your `game-stepper.component.html`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll add the template to show our main content for the selected step—this
    is pretty simple to do. We need to add a `div` with the `[ngTemplateOutlet]` attribute,
    where we’ll show the content. Update the `game-stepper.component.html` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we’ll add a footer element that’ll contain the navigation buttons
    for our stepper— that is, we should be able to jump to the next and the previous
    step using those navigation buttons. Update the `game-stepper.component.html`
    file further, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add some styles to our `game-stepper` component. Modify the `game-stepper.component.scss`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we want to use the `game stepper` component inside the `game` component.
    To do this, first import it in the `GameComponent` class’s `imports` array as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now wrap our entire template in the `game.component.html` file with the
    `<app-game-stepper>` component. Update the file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now modify our `game.component.html` file to break down the inner template
    into steps. For that, we’ll use the `<cdk-step>` element to wrap around the content
    for each step. Update the file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll add a label for each step. We need to add an `<ng-template>` element
    inside each `<cdk-step>` element. Update the `game.component.html` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you refresh the app, you should see the first step as the visible step,
    as well as the bottom navigation button, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_14.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.14: The first step and the navigation button using CDKStepper'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to make sure that we can only move forward to the second step
    once we have entered a name in the first step. Make the following changes to the
    `game.component.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to disable the next button on the first step until we have entered
    a value for the player’s name. To do so, update the `game-stepper.component.html`
    file—specifically, the element with the `cdkStepperNext` attribute—as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To handle the case when the user provides the name and hits the *Enter* key,
    resulting in the form submission, we can move to the next step using a `@ViewChild()`
    in the `GameComponent` class. Modify the `game.component.ts` file as follows,
    and try entering the name and then pressing the *Enter* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s write the flow for guessing the number. Update the `game.component.ts`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the functions in place, let’s update the template to listen
    to the event listeners from the `<app-value-guesser>` and `<app-dice>` components
    and act accordingly. We’ll also add elements with class alerts to show messages
    in case of a successful or wrong guess. Update the `game.component.html` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to populate the leaderboards. Update the `game.component.ts`
    file to use the `LeaderboardService` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `game.component.html` file to pass the scores as an attribute
    to the `<app-leader-board>` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you refresh the app now and play the game, you should be able to see the
    leaderboard, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_15.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.15: Displaying results in the leaderboard at Step 3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Phew! That was a *long* recipe! Well, perfection requires time and dedication.
    Feel free to use this game yourself or even with your friends, and if you improve
    it, do let me know on my socials.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve finished the recipe, see the next section on how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of moving parts in this recipe, but they’re super easy. First,
    we import the `CdkStepperModule` class into the `imports` array of our `GameComponent`
    class. Then, we create a component that extends the `CdkStepper` class. The reason
    for extending the `CdkStepper` class is to be able to create this `GameStepperComponent`
    component so that we can create a reusable template with some styles, and even
    some custom functionality.
  prefs: []
  type: TYPE_NORMAL
- en: To start using the `GameStepperComponent` component, we wrap the entire template
    within the `<app-game-stepper>` element in the `game.component.html` file. Since
    the component extends the `CdkStepper` API, we can use all the functionality of
    the `CdkStepper` component here. For each step, we use the `<cdk-step>` element
    from the CDK and wrap the template of the step inside it. Notice that in the `game-stepper.component.html`
    file, we use the `[ngTemplateOutlet]` attribute for both the step’s label and
    the step’s actual content. This is a reflection of how amazing the CDK Stepper
    API is. Since our `GameStepperComponent` class extends the `CDKStepper` class,
    it automatically generates a `label` property and the `content` property for each
    step based on the values/template we provide for each `<cdk-step>` element in
    the `game.component.html` file. Since we provide an `<ng-template cdkStepLabel>`
    inside each `<cdk-step>` element in the `game.component.html` file, the CDK generates
    a `step.stepLabel.template` automatically for each step, which we then use inside
    the `game-stepper.component.html` file, to show the label of each `<cdk-step>`
    element respectively. If we didn’t provide the `<ng-template cdkStepLabel>` for
    a step and rather just used `<cdk-step label="someValue">`, it would then use
    the `step.label` property as per our code written in the `game-stepper.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: For the bottom navigation buttons, you notice that we use `<button>` elements
    with the `cdkStepperPrevious` and `cdkStepperNext` directives for going to the
    previous step and the next step respectively. We also show/hide the next and previous
    buttons based on the conditions to check if there is a step to go to. To prevent
    the navigation button from being rendered in the DOM when the provided condition
    is false, we utilize the `*ngIf` binding to dynamically hide or show it.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting thing about the CDK Stepper API is that we can tell whether
    the user should be able to go to the next steps and backward, regardless of the
    state of the current step, or whether the user should first do something in the
    current step to go to the next one. The way we do it is by using the `[linear]`
    attribute on our `<app-game-stepper>` element, setting its value to `true`. This
    tells the CDK Stepper API to not move to the next step using the `cdkStepperNext`
    button, until the current step’s `completed` property is `true`. While just providing
    `[linear]="true"` is enough to handle the functionality, we improve the UX by
    disabling the **Next** button—in this case, by using `[disabled]="!selected!.completed"`
    on the `cdkStepperNext` button, as it makes more sense to just disable the button
    if it isn’t going to do anything on click.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we needed to decide when a step is considered complete. For the first
    step, it is obvious that we should have a name entered in the input to consider
    the step completed—or, in other words, the `FormControl` for the `'name'` property
    in the `nameForm` Form Group should have a value. For the second step, it is bound
    to the condition `isCorrectGuess !== null`. This ensures that the user has guessed
    a number; regardless of whether the guess is correct or not, we mark the step
    as completed and let the user go to the next step (the leaderboard) if the user
    wants to. And that’s pretty much about it. You could go beyond the recipe to add
    an option of restarting the game from the leaderboard (last) step.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular CDK Stepper examples: [https://material.angular.io/cdk/stepper/examples](https://material.angular.io/cdk/stepper/examples)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessible listbox interactions using CDK Listbox directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessibility is one of the key aspects to focus on when you’re thinking about
    your end users using your applications. One of the major use cases for the users
    is to make a selection in apps, whether that’s selecting the color or size of
    a product or selecting multiple labels for a post. It makes it such a good experience
    if the experience is accessible. In this recipe, we’re going to replace a color
    selection feature for products with an accessible alternative using the **Angular
    CDK Listbox APIs**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-listbox`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_16.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.16: The ng-cdk-listbox app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Figure 9.16*, you will notice that we have options for selecting the product
    color—and if you click one of them, you can see the selected color on the right
    side. Even though they are somewhat accessible, they do not completely follow
    any of the WAI ARIA patterns. Let’s use the CDK Listbox module by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to import the `CdkListboxModule` class into the `imports` array
    of our `ProductCardComponent` class so we can use the `cdkListbox` and `cdkOptions`
    directives. Modify the `product-card.component.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll replace the HTML template to use the `cdkListbox` and `cdkOption`
    directives. We will be using an unordered list (`ul`) and list items (`li` elements)
    to render a similar color list. Update the `product-card.component.html` file
    between the mentioned HTML comments as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ll notice that the options still look the same (because of the CSS classes);
    however, the functionality is gone now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s also add some styles to highlight the selected color. Update the `color-options.scss`
    file inside the `src/styles` folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since Angular CDK Listbox works with both template-driven and reactive forms,
    let’s add the `formControlName` attribute to bind it with the `color` form control
    from the `productForm` form group. Update the template further as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! With this change, when you refresh the page and pick a color, you should
    be able to see the desired result as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Angular CDK implements WAI ARIA and, therefore, it is also possible to use
    the `typeahead` feature in the listbox. Let’s modify the template further to make
    it work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you select any color and focus on the list box, you can type the name of
    the color here to jump directly to the option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Awesome!! You’ve finished the recipe. Now you can see the next section to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we’ve used the CDK Listbox API. And it is super cool that it
    completely implements the WAI ARIA pattern for the listbox. Kudos to the Angular
    team. To start, we import the `CdkListboxModule` in our standalone component (`ProductCardComponent`
    class) in its `imports` array. Then we use an unordered list, `<ul>`, in the template
    along with the `cdkListbox` directive. This applies the CDK Listbox features to
    the `<ul>` element. You’ll notice that we’re using the `aria-labelledby` attribute
    on the `<ul>` according to the WAI ARIA pattern for the listbox. Finally, we have
    the `cdkListboxOrientation` attribute set to `"horizontal"`, which tells the CDK
    Listbox API to allow horizontal navigation for this listbox; i.e., we can navigate
    with the left and right arrow keys. I would encourage you to read the Listbox
    specification at [https://www.w3.org/WAI/ARIA/apg/patterns/listbox/](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)
    to see the cool accessibility features it proposes. And what’s amazing is that
    the Angular CDK Listbox APIs follow all of them.
  prefs: []
  type: TYPE_NORMAL
- en: On top of following the WAI ARIA pattern for listboxes, the listbox itself works
    seamlessly with Angular forms (both template-driven and reactive). And since we
    were already using a reactive form in the template of the `product-card` component,
    we could easily use the `formControlName` binding with the `<ul>` element. Notice
    that each list item `(<li>)` element has the `cdkOption` binding, which tells
    the CDK Listbox module about the value of each option. At the end of the recipe,
    we also introduced the `cdkOptionTypeaheadLabel`, which helps the CDK Listbox
    API follow the `typeahead` feature of the WAI ARIA pattern recommendation. If
    we don’t use this attribute, the CDK Listbox module uses the list item’s text
    content as the default `typeahead`.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that we also added another CSS selector in the `color-options.scss`
    file, i.e., `&[aria-selected=true]`, to highlight the selected color. That’s because
    the CDK Listbox API automatically sets that attribute to `true` or `false` based
    on which item is selected. And this too, is a part of the WAI ARIA pattern for
    listbox.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CDK Listbox documentation: [https://material.angular.io/cdk/listbox/overview](https://material.angular.io/cdk/listbox/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WAI ARIA pattern for listboxes: [https://www.w3.org/WAI/ARIA/apg/patterns/listbox/](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with nested menus using the Angular CDK Menu API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Menus are vital for so many applications we use today. The pattern of having
    a menu itself allows us to have experiences that don’t take up space in the DOM
    all the time and can be shown relative to their triggers **on demand**. In this
    recipe, you’ll learn how to create nested menus using the Angular CDK APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-menu`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_17.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.17: The ng-cdk-menu app running on http://localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an application that has a product card that needs an actions menu so
    we can perform some actions. We’ll start using the Angular CDK Menu APIs to implement
    a nested menu. Let’s take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the styles from [https://ng-cookbook.com/s/cdk-pane-styles](https://ng-cookbook.com/s/cdk-pane-styles)
    into the `styles.scss` file in the project. Make sure to keep the existing styles
    in your file and just add the ones you copied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the components from the Angular CDK Menu APIs in the `product-card.component.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s use some directives in the template to create a menu. We’ll be using
    an `<ng-template>` element for our menu and will assign it to a template variable.
    Update the `product-card.component.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you click the More button (three vertical dots icon) on the product card
    now, you should be able to see the menu as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_18.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.18: Menu implementation using Angular CDK Menu APIs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You’ll notice that the menu starts from the bottom-left position of the trigger.
    This is the default menu position set by the Angular CDK Menu API. We can override
    it using connected positions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s use some preferred connected positions so the menu is shown on the left
    side of the trigger by default. Update the `product-card.component.ts` file as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s use the `menuPositions` variable in the template to use the preferred
    positions. Update the `product-card.component.html` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now refresh the app and click the More button (three vertical dots icon)
    on the product card, you should see the menu appearing on the left side of the
    button as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_19.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.19: Menu with preferred positions'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s implement the nested menu now. We’ll create the `<ng-template>` element
    for the nested menu and connect it with the `"Manage"` menu item. Update the `product-card.component.html`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this change, you should be able to see the nested menu as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_09_20.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.20: Nested menu implementation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Kaboom! We were able to implement a nested menu in this application within a
    few steps by using the Angular CDK. Trust me, if we had to do this on our own,
    this would’ve taken hours, or maybe days.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular CDK provides the CDK Menu APIs, which include the `cdkMenuTriggerFor`
    directive. This directive ideally points to a template variable for an `<ng-template>`
    element. And then behind the scenes, the Angular CDK connects that menu with the
    trigger. Even though the menu item itself is appended to the `<body>` element
    inside an overlay, the position of the overlay is calculated accurately for the
    menu and is correct across screen resizes as well. However, the Angular CDK Menu
    API **does not** contain the CSS styles for the overlay. Therefore, in this recipe,
    we have a link to the relevant styles for both the overlay and the menu itself.
    You’ll also notice that we use the directives `cdkMenu` on the menu list `(<ul>)`
    items, and we use the `cdkMenuItem`on the menu `(<li>)` items. Since we use these
    three directives and nothing else from the Angular CDK Menu package, you’ll notice
    that we don’t import `CdkMenuModule` from `'@angular/cdk/menu'`. That’s because
    all these directives are `standalone` directives. So they can be imported without
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we also modified the default positioning for the menu. By default,
    the overlay starts from the *bottom-left* point of the trigger, toward the right
    side. We used a `ConnectionPosition` array with the `[cdkMenuPosition]` binding
    to the **More** button (the trigger element) to use our preferred position. The
    first (preferred) position is that the overlay’s **top-right** corner aligns with
    the trigger element’s **bottom-right** corner. That is, the overlay shows below
    the **More** button and expands toward the left side, as per the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The second position is that the overlay shows above More button (three vertical
    dots icon) and still expands toward the left side based on the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we implemented the nested menu. This was pretty simple. We created
    another menu with the same technique as the first one, creating an `<ng-template>`
    with a template variable, a `cdkMenu` inside it, and `cdkMenuItems` inside the
    menu. Then we set the trigger of this nested menu to the `Manage` menu item in
    the primary menu. The Angular CDK is smart enough to understand if the trigger
    is a `cdkMenuItem`. If it is, it opens the nested menu automatically on the mouse-over
    event on the trigger menu item. And when the mouse-leave event triggers from the
    nested menu, it hides. I must give kudos to the Angular CDK team for making things
    this easy.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular CDK Menu: [https://material.angular.io/cdk/menu/overview](https://material.angular.io/cdk/menu/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularCookbook2e](Chapter_9.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1388317275422265.png)'
  prefs: []
  type: TYPE_IMG
