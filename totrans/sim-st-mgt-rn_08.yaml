- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Integrating Jotai in a React Native App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React Native应用中集成Jotai
- en: 'In the previous chapter, we ventured into the mathematical world of **XState**.
    We will continue our journey by exploring another young state management library
    called **Jotai**. **Jotai** is inspired by an experimental state management library
    created at **Facebook** called Recoil. In this chapter, we will take a brief look
    at **Recoil**, an experimental state management library created by Facebook. Once
    we’re comfortable with the main ideas of this library, namely a new concept called
    an “atomic state”, we will take a deep dive into **Jotai**. We will configure
    Jotai in our app, and we’ll continue to work on data fetching and managing liked
    images with the help of **Jotai**. Here’s what we will go over in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探索了**XState**的数学世界。我们将继续我们的旅程，通过探索另一个名为**Jotai**的年轻状态管理库来继续前进。**Jotai**受到了在**Facebook**创建的一个实验性状态管理库Recoil的启发。在本章中，我们将简要了解**Recoil**，这是Facebook创建的一个实验性状态管理库。一旦我们熟悉了这个库的主要思想，即一个名为“原子状态”的新概念，我们将深入探讨**Jotai**。我们将在我们的应用中配置Jotai，并借助**Jotai**继续进行数据获取和管理点赞图片的工作。以下是本章我们将涉及的内容：
- en: What is **Recoil** and an atomic state?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Recoil**和原子状态是什么？'
- en: What is **Jotai**?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是**Jotai**？
- en: Configuring **Jotai** in the Funbook app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Funbook应用中配置**Jotai**
- en: Using `FavoritedImages`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FavoritedImages`
- en: By the end of this chapter, you will have a new way of looking at global state
    management – by dividing it into small items, called **atoms**. You will also
    know how to set up **Jotai** in a new project, and how to use it for data fetching
    and data management.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将有一种新的看待全局状态管理的方法——通过将其划分为称为**原子**的小项目。你还将了解如何在新的项目中设置**Jotai**，以及如何使用它进行数据获取和数据管理。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow along with this chapter, you will need some knowledge of
    **JavaScript** and **ReactJS**. If you have followed at least *Chapters 1 to 4*
    of this book, you should be able to proceed without any issues.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上本章的内容，你需要了解一些**JavaScript**和**ReactJS**的知识。如果你至少跟随着本书的*第1章到第4章*，你应该能够没有问题地继续学习。
- en: Feel free to use an IDE of your choice, as **React** **Native** does not need
    any specific functionality. Currently, the most popular IDEs for frontend developers
    are Microsoft’s VSCode, Atom, Sublime Text, and WebStorm.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用你选择的IDE，因为**React Native**不需要任何特定功能。目前，前端开发者中最受欢迎的IDE是微软的VSCode、Atom、Sublime
    Text和WebStorm。
- en: The code snippets provided in this chapter are here to illustrate what we should
    be doing with the code. They do not provide the whole picture. To code along easier,
    please open the GitHub repo in your IDE and look at the files in there. You can
    either start with the file in the folder named `example-app-full` or `chapter-8`.
    If you start with `example-app-full`, you will be responsible for implementing
    the solutions described in this chapter. If you choose to look at `chapter-8`,
    you will see the entire solution implemented by me.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码片段旨在说明我们应该如何使用代码。它们并不提供完整的画面。为了更容易地编码，请在你选择的IDE中打开GitHub仓库，查看其中的文件。你可以从名为`example-app-full`或`chapter-8`的文件夹中的文件开始。如果你从`example-app-full`开始，你将负责实现本章描述的解决方案。如果你选择查看`chapter-8`，你将看到我实现的整个解决方案。
- en: 'If you get stuck or lost, you can check the code in the GitHub repo: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-8](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-8).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到困难或迷失方向，可以查看GitHub仓库中的代码：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-8](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-8)。
- en: What is Recoil and an atomic state?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**Recoil**和原子状态是什么？'
- en: If you’ve been following this book chapter by chapter, you may be feeling as
    though the list of different types of state management libraries is never-ending.
    You would be right, to some extent. New state management libraries pop up every
    few weeks; they are sometimes purely open source, and sometimes company-backed.
    However, they rarely propose groundbreaking solutions. More often than not, they
    are newer implementations of known concepts. Those implementations are greatly
    appreciated, as every developer likes working comfortably – and what are those
    known concepts, you may ask?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直按章节顺序阅读这本书，你可能觉得不同类型的状态管理库列表永远没有尽头。在某种程度上，这是正确的。每隔几周就会出现新的状态管理库；它们有时是纯开源的，有时是公司支持的。然而，它们很少提出突破性的解决方案。更常见的是，它们是已知概念的较新实现。这些实现受到了极大的欢迎，因为每个开发者都喜欢舒适地工作——那么，那些已知的概念是什么呢，你可能想知道？
- en: 'There’s a consensus in the **ReactJS** world that state management libraries
    can be divided into three types:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在**ReactJS**世界中，有一个共识，即状态管理库可以分为三种类型：
- en: Flux type – these are state management libraries that hold the state outside
    of components and use a unidirectional data flow. They are inspired by **Facebook’s
    Flux**, the most famous example being **Redux**. There are modern implementations
    of this flow, such as **Redux Toolkit** or **Zustand**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flux类型 - 这些是持有状态在组件之外的状态管理库，并使用单向数据流。它们受到了**Facebook的Flux**的启发，最著名的例子是**Redux**。这种流有现代的实现，如**Redux
    Toolkit**或**Zustand**。
- en: Proxy type – these libraries “wrap” the state, conceptually similar to what
    a proxy does. When using this type of state management, the developer can subscribe
    to, and read, wrapped values like any other values in the component. The best
    examples of proxy-type state management are **React’s Context**, **MobX**, or
    **Valtio**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理类型 - 这些库“包装”状态，概念上类似于代理所做的那样。当使用这种类型的状态管理时，开发者可以像读取组件中的任何其他值一样订阅和读取包装值。代理类型状态管理的最佳例子是**React的Context**、**MobX**或**Valtio**。
- en: Atomic type – this is the state set at the lowest level, managed naturally by
    `setState` in class components and the `useState` hook in function components.
    Values set in this way can be passed around the app and used in a bigger context.
    **Facebook** created an experimental library to promote this type of state management,
    called **Recoil**. **Jotai** soon followed suit.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原子类型 - 这是最低级别的状态集合，由类组件中的`setState`和函数组件中的`useState`钩子自然管理。以这种方式设置的价值可以在应用程序中传递并用于更大的上下文中。**Facebook**创建了一个实验性库来推广这种类型的状态管理，称为**Recoil**。**Jotai**很快也效仿。
- en: '**Recoil** was created around mid-2020 and quickly garnered lots of attention.
    It was published by Facebook itself, the creators of React, so everyone was expecting
    a great new solution. The idea of using the smallest possible denomination of
    pieces of state, peppered and accessible throughout **React** apps, was enticing.
    Unfortunately, after the first gasp of excitement, a big part of the React community
    lost interest in **Recoil** and went about their days continuing to work mostly
    with Redux. Two years later, **Recoil’s** documentation still states that it’s
    experimental and few people are talking about it.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**回弹**（Recoil）是在2020年中期创建的，并迅速获得了大量关注。它是由Facebook自己发布的，Facebook也是React的创造者，因此每个人都期待着一个全新的解决方案。使用尽可能小的状态片段，并在**React**应用中分散和可访问的想法非常吸引人。不幸的是，在最初的兴奋之后，React社区中很大一部分人对**Recoil**失去了兴趣，继续使用Redux进行日常工作。两年后，**Recoil**的文档仍然声明它是实验性的，而且很少有人谈论它。'
- en: A small community of developers was paying more attention than the rest of us
    though. *Poimandres*, an open source developer collective, went to work and created
    their implementation of an atomic state. They called it **Jotai**. If you visit
    their GitHub page, you will see they also developed **Valtio**, a proxy-type state
    management library, and **Zustand**, a lightweight flux-type state management
    library. **Valtio** and **Zustand** are so far in the shadow of their more famous
    alternatives, but **Jotai** has dominated the stage for atomic state management.
    This library is production-ready; it’s being actively developed through **GitHub**,
    and its developers provide constant support on an open Discord server. This is
    why we will talk about **Jotai**, and not **Recoil**, in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有一小群开发者比我们其他人更加关注。*Poimandres*，一个开源开发者集体，开始工作并创建了他们自己的原子状态实现。他们称之为**Jotai**。如果你访问他们的GitHub页面，你会看到他们也开发了**Valtio**，一个代理类型的状态管理库，以及**Zustand**，一个轻量级的flux类型状态管理库。**Valtio**和**Zustand**到目前为止在更著名的替代品阴影之下，但**Jotai**在原子状态管理舞台上占据了主导地位。这个库是生产就绪的；它正在通过**GitHub**积极开发，并且其开发者在一个开放的Discord服务器上提供持续的支持。这就是为什么我们将讨论**Jotai**，而不是**Recoil**，在本章中。
- en: What is Jotai?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Jotai？
- en: 'As mentioned in the previous section, `useState`) or externally. Daishi is
    continually working on new things; you can observe all his work in the *Jotai
    Labs* **GitHub** repo: [https://github.com/jotai-labs](https://github.com/jotai-labs).
    He’s also interested in developing features for fetching and **React’s Suspense**.
    You can find more links to his projects in the *Further* *reading* section.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`useState`)或外部。Daishi一直在努力开发新事物；你可以在*Jotai Labs* **GitHub**仓库[https://github.com/jotai-labs](https://github.com/jotai-labs)中观察他的所有工作。他对开发用于获取和**React的Suspense**的功能也很感兴趣。你可以在*进一步*
    *阅读*部分找到更多关于他的项目的链接。
- en: We now have a good understanding of why Jotai was created. It aims to solve
    state management problems from a new perspective, following React’s best practices
    and concepts proposed by the experimental Recoil library. It’s time we try this
    “atomic” state approach in our app. Let’s get to coding!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对为什么创建Jotai有了很好的理解。它旨在从新的视角解决状态管理问题，遵循React的最佳实践和实验性Recoil库提出的概念。是时候在我们应用中尝试这种“原子”状态方法了。让我们开始编码吧！
- en: Configuring Jotai in the Funbook app
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Funbook应用中配置Jotai
- en: 'If you’re a fan of simplicity, my dear reader, you may just fall in love with
    this state management library. Configuring it in our app only requires running
    the `install` command in the terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个简单性的粉丝，我亲爱的读者，你可能会爱上这个状态管理库。在我们的应用中配置它只需要在终端运行`install`命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, see the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，查看以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There’s one hidden gem of configuration to be added: Suspense. I specifically
    used the word gem because this configuration requirement of **Jotai** will make
    your app crash less. Suspense is a new ReactJS functionality, created to only
    be able to render components that are ready to be rendered. As with any new functionality,
    the users need to get used to it, and sometimes need to be forced to try it. **Jotai**
    is doing exactly this: forcing the users to use Suspense, for their own good!
    Let’s go ahead and add it at the root of our app:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的一个隐藏的配置宝石是Suspense。我特意用了宝石这个词，因为**Jotai**的这项配置要求将使你的应用崩溃更少。Suspense是ReactJS的新功能，旨在只能渲染准备好渲染的组件。就像任何新功能一样，用户需要习惯它，有时甚至需要被迫尝试它。**Jotai**正是这样做的：强迫用户使用Suspense，这对他们自己是有好处的！让我们继续在我们的应用根目录中添加它：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, our app can use `ListOfFavoritedImages`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用可以使用`ListOfFavoritedImages`。
- en: Using Jotai for ListOfFavoritedImages
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jotai进行ListOfFavoritedImages
- en: 'You may have noticed that we didn’t give much of a theoretical introduction
    to **Jotai**. This is because this library is minimal. There is no boilerplate,
    no complex concepts. All we need to do is create an atom and use it thanks to
    a custom hook in the app. Let’s start by creating an atom with some mock data
    for the liked images:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们没有对**Jotai**进行太多的理论介绍。这是因为这个库非常简洁。没有样板代码，没有复杂的概念。我们只需要创建一个原子并使用它，多亏了应用中的自定义钩子。让我们先创建一个带有一些模拟数据的喜欢图片原子的例子：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have the mocked images array ready; all we need to do now is use it. Given
    our previous experiences with other state management libraries, you are probably
    expecting to see some sort of setup, wrapper, subscription, or something similar.
    I’m sorry to disappoint, but all we need to do to use the `ListOfFavoritedImages`
    component as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了模拟的图像数组；我们现在需要做的就是使用它。鉴于我们之前与其他状态管理库的经验，你可能期望看到某种设置、包装器、订阅或其他类似的东西。很抱歉让你失望，但我们现在需要做的只是如下使用`ListOfFavoritedImages`组件：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we imported the `useAtom` and the atom we created in
    our `imagesAtom` file. And what is the result? Let’s run the app in the simulator
    and find out!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了`useAtom`以及我们在`imagesAtom`文件中创建的原子。那么结果如何呢？让我们在模拟器中运行应用并找出答案！
- en: '![Figure 8.1 – App displaying images based on Jotai atoms ](img/Figure_8.01_B18396.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 基于Jotai原子的应用显示图像](img/Figure_8.01_B18396.jpg)'
- en: Figure 8.1 – App displaying images based on Jotai atoms
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 基于Jotai原子的应用显示图像
- en: Everything works! I must admit, this feels almost magical. Surely, fetching
    will be more complicated?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都正常！我必须承认，这感觉几乎像魔法。当然，获取数据会更复杂吗？
- en: Fetching data with Jotai
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jotai获取数据
- en: 'We successfully set up mocked image data in our app, but we would like to fetch
    real data from the server. Going back to the **Jotai** docs, we will find a guide
    on asynchronous atoms (you can find a link to this part of the documentation in
    the *Further reading* section). Here’s what our async atom for fetching images
    will look like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的应用中成功设置了模拟的图像数据，但我们希望从服务器获取真实数据。回到**Jotai**文档，我们将找到一个关于异步原子的指南（你可以在*进一步阅读*部分找到该文档的链接）。以下是我们的用于获取图像的异步原子的样子：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We add a `requestBase` import to use URLs more comfortably. Then, we proceed
    to create a basic atom with the specific URL. The last function is the async atom.
    We know it’s async because it uses the `async` keyword. The body of the async
    atom function is a `fetch` function and data return. The atom is ready, but it’s
    not connected to anything just yet. We will need to call it in the app and make
    it fill `imageListAtom`. Let’s start by invoking the fetching. A good place to
    do so will be at the root of the app once the user is logged in. This means we
    will not be fetching in the `App.js` root component, but rather in the `Home`
    component:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`requestBase`导入以更舒适地使用URL。然后，我们继续创建一个具有特定URL的基本原子。最后一个函数是异步原子。我们知道它是异步的，因为它使用了`async`关键字。异步原子函数的主体是一个`fetch`函数和数据返回。原子已经准备好了，但还没有连接到任何东西。我们需要在应用中调用它，并让它填充`imageListAtom`。让我们从调用获取操作开始。这样做的好地方是在用户登录后应用根目录。这意味着我们不会在`App.js`根组件中获取数据，而是在`Home`组件中：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We start by importing the necessary pieces: a custom hook from `console.log`
    to the component and seeing whether the value of `json` is the same as expected.
    By the way, there is no rule for naming the returns of atoms. You may as well
    write this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入必要的部分：从`console.log`到组件的自定义钩子，并查看`json`的值是否与预期相同。顺便说一句，原子返回的命名没有规则。你也可以这样写：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you’re using linter plugins (such as `json` value being declared but not
    used. What good does it do to fetch images if we’re not doing anything with them?
    And what should we do with them? We should make the newly fetched array of images
    fill `imageListAtom`. The way to accomplish this is to change our read-only `imageListAtom`
    to a read-write atom.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用linter插件（例如`json`值被声明但未使用。如果我们不对它们做任何事情，获取图像有什么好处？我们应该如何处理它们？我们应该让新获取的图像数组填充`imageListAtom`。完成这个任务的方法是将我们的只读`imageListAtom`改为读写原子。
- en: Reading and writing atoms
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入原子
- en: 'Ah! Finally, some theory! I’m sure you’ve been craving this, my dear reader!
    (Since it’s difficult to convey irony in a technical text, let me take this opportunity
    to explain: the previous sentence is sarcastic).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！终于有一些理论了！我敢肯定，亲爱的读者，你一定渴望这些！（由于在技术文本中传达讽刺很难，让我抓住这个机会解释一下：上一句话是讽刺的）。
- en: 'There are three types of atoms: read-only, write-only, and read-write atoms.
    The read-only atoms are the simplest: all you do is create them and set the value
    they need to hold on to, for example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 原子有三种类型：只读、只写和读写原子。只读原子是最简单的：你所做的就是创建它们，并设置它们需要保留的值，例如：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Read-only atoms can hold more than simple values or strings. If you need more
    complex logic in your atom, you should use the following syntax:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 只读原子可以保存比简单的值或字符串更多的内容。如果你需要在原子中实现更复杂的逻辑，你应该使用以下语法：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding short snippet, you can observe that atoms have access to a
    `getter` function, which, in turn, can access other atoms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个简短的代码片段中，你可以观察到原子可以访问一个`getter`函数，而这个函数反过来又可以访问其他原子。
- en: 'If we wanted to add a write functionality to our atom, we can add a `setter`
    function as the second argument to the atom:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要给我们的原子添加写功能，我们可以在原子的第二个参数中添加一个`setter`函数：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We’ve added a new function, which will accept a new text and pass it to the
    `onlyReadMe` atom. If you were to use it in a component, it would look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新函数，它将接受一个新的文本并将其传递给`onlyReadMe`原子。如果你要在组件中使用它，它看起来会是这样：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the example component in the preceding screenshot, you can observe how a
    read-write atom can be implemented. We start by importing the atom, but we declare
    two values: the value and the setter, very similar to what we would use in a regular
    `useState` hook. Lower in the component, we use `{fancyText}` to display the text
    from the atom, and the `setFancyText` function to set a new text through a button
    press.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个截图中的示例组件中，你可以观察到如何实现读写原子。我们首先导入原子，但声明了两个值：值和设置器，这与我们在常规`useState`钩子中使用的方法非常相似。在组件的较低部分，我们使用`{fancyText}`来显示原子中的文本，并使用`setFancyText`函数通过按钮点击来设置新的文本。
- en: 'The last type of atom we can talk about is the write-only atom. The only difference
    between this atom and a read-write atom is that we declare the read argument as
    `null`. Here’s an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以讨论的最后一种原子是只写原子。这种原子与读写原子的唯一区别在于我们声明读取参数为`null`。以下是一个示例：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When using this type of atom, you always need to make sure to accommodate the
    hook with the non-existing default value. Here’s how this write-only hook would
    be used in the preceding example component:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种类型的原子时，你总是需要确保为非存在的默认值适配钩子。以下是如何在前面的示例组件中使用这个只写钩子的方法：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the comma in the array with values derived from the `useAtom` hook. It
    indicates there is a null value on the first index, but we choose to not use it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到数组中有来自`useAtom`钩子的值，其中的逗号表示第一个索引处有一个空值，但我们选择不使用它。
- en: Adding read-write functionality to the imageListAtom
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向imageListAtom添加读写功能
- en: 'So far, we have a read-only `imageListAtom` and an async `fetchImagesAtom`.
    Let’s add a write functionality to `imageListAtom` so that it can accept values
    from `fetchImagesAtom`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个只读的`imageListAtom`和一个异步的`fetchImagesAtom`。让我们给`imageListAtom`添加写功能，以便它可以接受来自`fetchImagesAtom`的值：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The atom is ready to receive values, so let’s give it some. We have to go back
    to the `Home` component where we kicked off data fetching, and add a `useEffect`,
    which will update `imageListAtom`. Here’s what the code should look like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 原子已经准备好接收值了，所以让我们给它一些值。我们必须回到启动数据获取的`Home`组件，并添加一个`useEffect`，它将更新`imageListAtom`。以下是代码应该看起来像什么：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a good moment to check again whether everything works fine in the app
    since we just implemented data fetching. If everything is, in fact, working as
    expected, we’ll move on to implementing functionality for the `console.log` to
    check that the atoms hold and return the values you are expecting them to have.
    If you continue to have issues, you can join the *Poimandres* Discord server (link
    in the *Further reading* section), where you’ll find a **Jotai**-dedicated channel.
    *Daishi Kato*, the author of **Jotai**, answers all sorts of questions on this
    channel himself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个检查应用是否一切正常的好时机，因为我们刚刚实现了数据获取。如果一切确实按预期工作，我们将继续实现`console.log`的功能，以检查原子是否持有并返回你期望它们拥有的值。如果你继续遇到问题，可以加入*Poimandres*
    Discord服务器（在*进一步阅读*部分有链接），在那里你可以找到一个**Jotai**专属频道。**Jotai**的作者**Daishi Kato**会亲自回答这个频道上的各种问题。
- en: Once you are sure that everything is good, we’ll move on to implementing the
    `ImageDetailsModal`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定一切正常，我们将继续实现`ImageDetailsModal`。
- en: Implementing the Like button
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现喜欢按钮
- en: 'The full functionality of the `ImageDetailsModal` consists of two parts: the
    heart icon being full or not – indicating whether the image has been liked, and
    the actual action of liking an image – which means adding the new image to the
    array of images on the Favorited surface.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageDetailsModal`的完整功能由两部分组成：心形图标是否完整——表示图片是否已被喜欢，以及实际喜欢图片的动作——这意味着将新图片添加到收藏表面的图片数组中。'
- en: 'Let’s start by creating the necessary atom for the heart icon. We need to know
    whether a given image has been liked or not. We can establish whether it has been
    liked by filtering the array of images and checking whether a given image is present
    in the array. Here’s what the resulting atom will look like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建心形图标所需的原子。我们需要知道一个给定的图像是否已被点赞。我们可以通过过滤图像数组并检查给定的图像是否存在于数组中来确定它是否已被点赞。下面是生成的原子将看起来像什么：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As per the atom syntax, we start by establishing the default value as `false`.
    We then add a setter function, which will receive the new image object. Inside
    the setter function, we use `get` function to get `imageListAtom` and check our
    current image object against it. Finally, we set `isImageLikedAtom` to the correct
    value. Once the atom is created, we need to use it in the component:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 根据原子语法，我们首先将默认值设置为`false`。然后添加一个设置函数，该函数将接收新的图像对象。在设置函数内部，我们使用`get`函数获取`imageListAtom`并检查当前的图像对象是否与之匹配。最后，我们将`isImageLikedAtom`设置为正确的值。一旦原子创建完成，我们就需要在组件中使用它：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You may wonder why we are calling the `setIsLiked` function so crudely – why
    not add `useEffect`? The fact of the matter is that we need this function to be
    called when the component is rendered and only then. We could add a `useEffect`
    hook with an empty dependency array, but it would achieve the same result while
    looking more complicated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们如此粗糙地调用`setIsLiked`函数——为什么不使用`useEffect`？事实上，我们需要这个函数在组件渲染时被调用，并且仅在此之后。我们可以添加一个带有空依赖数组的`useEffect`钩子，但这会使结果看起来更复杂。
- en: When does it run?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它何时运行？
- en: There are some subtleties to the React component life cycle. They are more obvious
    with class components, where we would use `componentDidMount`, `componentWillUnmount`,
    and so on. Functional components have the same life cycle, without being as obvious
    about it. And it so happens that the `useEffect` hook only runs after a given
    component has finished rendering, while functions called directly do not wait
    for the render to finish.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的生命周期有一些微妙之处。在类组件中，这些微妙之处更为明显，我们会使用`componentDidMount`、`componentWillUnmount`等。函数组件有相同的生命周期，但没有那么明显。而且，`useEffect`钩子仅在给定组件完成渲染后运行，而直接调用的函数则不需要等待渲染完成。
- en: As far as our example goes, we do not need to make sure the rendering is complete
    before calling the `setIsLiked` function. However, big applications often ask
    a lot of their developers, and you may face a case where you need to closely control
    when a given atom setter function (or any other function for that matter) is run.
    You can read more on this topic in *Difference between ‘useEffect’ and calling
    function directly inside a component*, linked in the *Further* *reading* section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的示例而言，我们不需要在调用`setIsLiked`函数之前确保渲染完成。然而，大型应用程序往往对开发者要求很高，你可能会遇到需要密切控制给定原子设置函数（或任何其他函数）何时运行的情况。你可以在“*Further
    reading*”部分的链接中了解更多关于这个主题的信息：“*Difference between ‘useEffect’ and calling function
    directly inside a component*”。
- en: 'Circling back to our use case: we have a very nice `isImageLiked` atom in place.
    You can test that it works correctly by opening image modals on the **Feed** surface
    – where the heart icon should be empty – and on the **Favorites** surface – where
    the heart icon should be full.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的用例：我们有一个非常好的`isImageLiked`原子。你可以通过在**Feed**表面打开图像模态来测试它是否正确工作——那里的心形图标应该是空的——以及在**收藏**表面——那里的心形图标应该是满的。
- en: 'Now, on to the liking action! We will not need to do anything too fancy here.
    We must take `imageListAtom` and add a new image to it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到点赞操作！我们在这里不需要做任何太花哨的事情。我们必须获取`imageListAtom`并向其中添加一个新图像：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As with the example write-only atom, we start by declaring a null for the default
    atom value. In the setter function, we get `imageListAtom` and we add the new
    image using the `unshift` function, which adds items to the beginning of the original
    array. We finish by setting the newly created array as `imageListAtom` and by
    triggering the setter in `isImageLikedAtom`. Let’s add this to the modal component:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像示例中的只写原子一样，我们首先声明一个空值作为默认原子值。在设置函数中，我们获取`imageListAtom`并使用`unshift`函数添加新图像，该函数将项目添加到原始数组的开头。我们通过将新创建的数组设置为`imageListAtom`并在`isImageLikedAtom`中触发设置器来完成。让我们将此添加到模态组件中：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We must import the `addImageToArray` atom into our component and then call it
    in the right place upon the button being tapped. Let’s test our app! Chances are
    everything is working perfectly fine. You can tap the heart icon when it’s empty
    and it becomes full, and when you close the modal and go to the `FlatList`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将`addImageToArray`原子导入到我们的组件中，然后在按钮被点击的正确位置调用它。让我们测试我们的应用！很可能会一切正常。你可以点击空的心形图标，它会变成满的，然后关闭模态框并转到`FlatList`。
- en: 'React Native’s `FlatList` is a pure component, which means it does not re-render
    unless specifically instructed to do so. We have encountered this same problem
    already when using `FlatList`. `extraData` prop from `FlatList` – we can pass
    atom values to `useState` and let the natural state re-render the component. We
    can also take advantage of the utilities provided by the React Navigation library.
    This is my favorite approach, and it is the one I chose to use. There’s a `useIsFocused`
    custom hook in `Favorites` surface:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的`FlatList`是一个纯组件，这意味着除非明确指示，否则它不会重新渲染。我们已经在使用`FlatList`时遇到过这个问题。`FlatList`的`extraData`属性——我们可以将原子值传递给`useState`，让自然状态重新渲染组件。我们还可以利用React
    Navigation库提供的工具。这是我最喜欢的方法，也是我选择使用的方法。在`Favorites`界面中有一个`useIsFocused`自定义钩子：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using this hook, the `Favorites` surface will re-render every time this tab
    is focused. Of course, this is a hook to be used with great caution. Too many
    re-renders cause apps to crash unexpectedly. If you do decide to use it, make
    sure the re-render is necessary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个钩子，每次这个标签页获得焦点时，`Favorites`界面都会重新渲染。当然，这是一个需要谨慎使用的钩子。过多的重新渲染会导致应用意外崩溃。如果你决定使用它，请确保重新渲染是必要的。
- en: Time to visit the Funbook app again! In this section, we started by using a
    basic hook with a mock array of images. We then implemented data fetching using
    `ImageDetailsModal` and check whether your images on the **Favorites** surface
    are updated correctly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候再次访问Funbook应用了！在本节中，我们首先使用了一个基本的钩子和一个模拟的图片数组。然后我们实现了使用`ImageDetailsModal`的数据获取，并检查你的**收藏**界面上的图片是否正确更新。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered **Jotai**, a new kid on the block of state management
    libraries. Inspired by a new, atomic approach to state management proposed by
    Facebook through their library named **Recoil**, **Jotai** has become more and
    more popular within the React community. It offers a bottom-up approach, as opposed
    to top-down libraries, such as **Redux** or **MobX**. It’s honestly stupidly easy
    to configure and use. It doesn’t offer many utilities, but the documentation is
    very clear and easy to use. In this chapter, we managed to use it to fetch and
    store data, and we also used it to implement actions on that data, such as adding
    items to an array. **Jotai** marks the end of our journey with classic state management
    libraries.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了**Jotai**，这是状态管理库中的新成员。受Facebook通过其名为**Recoil**的库提出的新原子状态管理方法的启发，**Jotai**在React社区中越来越受欢迎。它提供了一种自下而上的方法，与自上而下的库（如**Redux**或**MobX**）相反。它确实非常容易配置和使用。它不提供很多工具，但文档非常清晰且易于使用。在本章中，我们成功地使用它来获取和存储数据，我们还用它来实现对数据的操作，例如向数组中添加项目。**Jotai**标志着我们与经典状态管理库的旅程的结束。
- en: In the next chapter, we’ll talk about **React Query**, which is not a state
    management library, but a data-fetching library. It does have its place in this
    book, however. More on that in the next chapter! See you there!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论**React Query**，它不是一个状态管理库，而是一个数据获取库。然而，它在这本书中也有其位置。更多内容将在下一章中介绍！那里见！
- en: Further reading
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://marmelab.com/blog/2022/06/23/proxy-state-with-valtio.html](https://marmelab.com/blog/2022/06/23/proxy-state-with-valtio.html):
    A State Management Tour: Proxy State with Valtio.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://marmelab.com/blog/2022/06/23/proxy-state-with-valtio.html](https://marmelab.com/blog/2022/06/23/proxy-state-with-valtio.html):
    状态管理之旅：使用Valtio进行代理状态。'
- en: '[https://github.com/facebookexperimental/Recoil/tree/main](https://github.com/facebookexperimental/Recoil/tree/main):
    *Recoil* GitHub page.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/facebookexperimental/Recoil/tree/main](https://github.com/facebookexperimental/Recoil/tree/main):
    *Recoil* GitHub页面。'
- en: '[https://opencollective.com/pmndrs](https://opencollective.com/pmndrs): Poimandres
    website.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opencollective.com/pmndrs](https://opencollective.com/pmndrs): Poimandres网站。'
- en: '[https://github.com/dai-shi/react-suspense-fetch](https://github.com/dai-shi/react-suspense-fetch):
    `react-suspense-fetch`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dai-shi/react-suspense-fetch](https://github.com/dai-shi/react-suspense-fetch):
    `react-suspense-fetch`.'
- en: '[https://github.com/dai-shi/react-hooks-fetch](https://github.com/dai-shi/react-hooks-fetch):
    `react-hooks-fetch`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dai-shi/react-hooks-fetch](https://github.com/dai-shi/react-hooks-fetch):
    `react-hooks-fetch`。'
- en: '[https://github.com/dai-shi/react-hooks-worker](https://github.com/dai-shi/react-hooks-worker):
    `react-hooks-worker`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dai-shi/react-hooks-worker](https://github.com/dai-shi/react-hooks-worker):
    `react-hooks-worker`。'
- en: '[https://jotai.org/docs/guides/async](https://jotai.org/docs/guides/async):
    *Jotai –* *Async*.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jotai.org/docs/guides/async](https://jotai.org/docs/guides/async):
    *Jotai –* *异步*。'
- en: '[https://discord.com/invite/poimandres](https://discord.com/invite/poimandres):
    Poimandres Discord server.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/poimandres](https://discord.com/invite/poimandres):
    Poimandres Discord 服务器。'
- en: '[https://www.geekyhub.in/post/difference-between-useeffect-and-direct-function-call/](https://www.geekyhub.in/post/difference-between-useeffect-and-direct-function-call/):
    *Difference between ‘useEffect’ and calling function directly inside* *a component*.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.geekyhub.in/post/difference-between-useeffect-and-direct-function-call/](https://www.geekyhub.in/post/difference-between-useeffect-and-direct-function-call/):
    *“useEffect”与在组件内部直接调用函数之间的区别*。'
- en: '[https://reactnavigation.org/docs/function-after-focusing-screen/#re-rendering-screen-with-the-useisfocused-hook](https://reactnavigation.org/docs/function-after-focusing-screen/#re-rendering-screen-with-the-useisfocused-hook):
    React Navigation `useIsFocused` hook.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reactnavigation.org/docs/function-after-focusing-screen/#re-rendering-screen-with-the-useisfocused-hook](https://reactnavigation.org/docs/function-after-focusing-screen/#re-rendering-screen-with-the-useisfocused-hook):
    React Navigation `useIsFocused` 钩子。'
