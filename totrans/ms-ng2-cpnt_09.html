<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Spaceship Dashboard"><div class="titlepage" id="aid-1O8H62"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Spaceship Dashboard</h1></div></div></div><p>When I was a child, I loved to play spaceship pilot. I piled up old carton boxes and decorated the interior to look like a spaceship cockpit. With a marker, I drew a spaceship dashboard on the inside of the boxes, and I remember playing in there for hours.</p><p>The thing that's special about the design of cockpits and spaceship dashboards is that they need to provide an overview and control over the whole spaceship on very limited space. I think the same also applies to application dashboards. A dashboard should provide the user with an overview and a sense for the overall status of what's going on.</p><p>In this chapter, we will create such a dashboard for our task management application. We will make use of the open source charting library Chartist to create good looking responsive charts and provide an overview over open tasks and project status:</p><div class="mediaobject"><img src="../Images/image00340.jpeg" alt="Spaceship Dashboard"/><div class="caption"><p>A preview of the tasks chart that we will build during the course of this chapter</p></div></div><p style="clear:both; height: 1em;"> </p><p>On a higher level, we will create the following components in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Project summary</strong></span>: This is the project summary that will provide a quick insight into the overall project status. By aggregating all efforts of containing tasks, we can provide a nice overall efforts status, for which we have created the components in the previous chapter.</li><li class="listitem"><span class="strong"><strong>Project activity chart</strong></span>: Without any labels or scales, this bar chart will just give a quick sense for the activity on projects in the last 24 hours.</li><li class="listitem"><span class="strong"><strong>Project tasks chart</strong></span>: This chart provides an overview of the task progress on projects. Using a line chart, we will display the count of open tasks over a certain time period. Using our Toggle component that we created in <a class="link" title="Chapter 2. Ready, Set, Go!" href="part0020.xhtml#aid-J2B81">Chapter 2</a>, <span class="emphasis"><em>Ready, Set, Go!</em></span>, of this book, we'll provide an easy way for the user to switch the displayed timeframe on the chart.</li></ul></div><div class="section" title="Introduction to Chartist"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Introduction to Chartist</h1></div></div></div><p>We will create <a id="id424" class="indexterm"/>some components in this chapter that will render charts, and we should look for some help in rendering them. Of course, we can follow a similar approach as we did in <a class="link" title="Chapter 6. Keeping Up with Activities" href="part0044.xhtml#aid-19UOO1">Chapter 6</a>, <span class="emphasis"><em>Keeping Up with Activities</em></span>, when we drew our activity timeline. However, when it comes to more complex data visualization, it's better to rely on a library to do the heavy lifting.</p><p>It shouldn't be a surprise that we'll use Chartist to fill this gap because I've spent almost two years writing it. As the author of Chartist, I feel very lucky that we've found a perfect spot in this book to make use of it.</p><p>I'd like to take the opportunity to introduce you to Chartist briefly before we dive into the implementation of the components for our dashboard.</p><p>The claim of Chartist is simple responsive charts, and this is luckily still the case after three years of existence. I can tell you that probably the hardest job of maintaining this library was to protect it from feature bloating. There are so many great movements, technologies, and ideas in the open source community and to resist and always stay focused on the initial claim wasn't easy.</p><p>Let me show you a very basic example of how you can create a simple line chart once you've included the Chartist scripts on your website:</p><div class="informalexample"><pre class="programlisting">const chart = new Chartist.Line('#chart', {
labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
series: [
    [10, 7, 2, 8, 5]
  ]
});</pre></div><p>The corresponding HTML markup that is required for this example looks as simple as the following:</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
&lt;div id="chart" class="ct-golden-section"&gt;&lt;/div&gt;
&lt;/body&gt;</pre></div><p>The following figure <a id="id425" class="indexterm"/>shows you the resulting chart that is rendered by Chartist:</p><div class="mediaobject"><img src="../Images/image00341.jpeg" alt="Introduction to Chartist"/><div class="caption"><p>A simple line chart rendered with Chartist</p></div></div><p style="clear:both; height: 1em;"> </p><p>I believe that by saying that we've been sticking to our claim to stay simple, we've not promised too much.</p><p>Let's look at the second core concern of Chartist, which is to be perfectly responsive. Well, let's start with one of my most appreciated principles in web development, which is the separation of concerns in the frontend. Chartist tries to stick to this separation wherever possible, which means that it uses CSS for its appearance, SVG for the basic graphical structure, and JavaScript for any behavior. Simply by following this principle, we've already enabled a lot of responsiveness. We can use CSS media queries to apply different styles to our charts on different media.</p><p>While CSS is great for visual styles, there are plenty of elements in the process of rendering charts, which can't be controlled simply by styling. After all, this is the reason why we use a JavaScript library to render charts.</p><p>So, how can we control how Chartist renders our charts on different media if we haven't got control over this in CSS? Well, Chartist provides something called responsive configuration overrides. Using the browsers <code class="literal">matchMedia</code> API, Chartist is able to provide a configuration mechanism that allows you to specify options that you want overridden on certain media.</p><p>Let's look into a simple <a id="id426" class="indexterm"/>example of how we can easily implement responsive behavior using a mobile-first approach:</p><div class="informalexample"><pre class="programlisting">const chart = new Chartist.Line('#chart', {
labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
series: [
    [10, 7, 2, 8, 5]
  ]
}, {
showPoint: true,
showLine: true
}, <span class="strong"><strong>[</strong></span>
<span class="strong"><strong>  ['screen and (min-width: 400px)', {</strong></span>
<span class="strong"><strong>showPoint: false</strong></span>
<span class="strong"><strong>  }],</strong></span>
<span class="strong"><strong>  ['screen and (min-width: 800px)', {</strong></span>
<span class="strong"><strong>lineSmooth: false</strong></span>
<span class="strong"><strong>  }]</strong></span>
<span class="strong"><strong>]</strong></span>);</pre></div><p>Here, the second parameter to the <code class="literal">Chartist.Line</code> constructor sets the initial options; we can provide overriding options annotated with media queries in an array as the third parameter of the constructor. In this example, we'll override the <code class="literal">showPoint</code> option for any media larger than 400 px in width. Media larger than 800 px in width will receive both the <code class="literal">showPoint</code> override as well as the <code class="literal">lineSmooth</code> override.</p><p>Not only can we specify real media queries to trigger setting changes, but we can also use an overriding mechanism that is very similar to CSS. This way, we can implement various approaches, such as ranged or exclusive media queries, mobile-first, or desktop-first. This responsive options mechanism can be used for all options available in Chartist.</p><div class="mediaobject"><img src="../Images/image00342.jpeg" alt="Introduction to Chartist"/><div class="caption"><p>Displaying the previous chart on three different media left to right, starting from a media with less than 400 px (A), less than 800 px (B), and more than 800 px (C).</p></div></div><p style="clear:both; height: 1em;"> </p><p>As you can see, implementing complex responsive behavior is a breeze with Chartist. Although our task management application was never meant to be a responsive web application, we can still benefit from this feature in order to optimize our content.</p><p>If I've tickled your fantasy <a id="id427" class="indexterm"/>with Chartist, I recommend that you check out the project's website at <a class="ulink" href="http://gionkunz.github.io/chartist-js">http://gionkunz.github.io/chartist-js</a>. On the website, you can also visit the live example page at <a class="ulink" href="http://gionkunz.github.io/chartist-js/examples.html">http://gionkunz.github.io/chartist-js/examples.html</a>, where you can hack some charts directly in the browser.</p></div></div>
<div class="section" title="Projects dashboard"><div class="titlepage" id="aid-1P71O2"><div><div><h1 class="title"><a id="ch09lvl1sec54"/>Projects dashboard</h1></div></div></div><p>In this chapter, we'll <a id="id428" class="indexterm"/>create a projects dashboard, which will consist of the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Tasks chart</strong></span>: This is <a id="id429" class="indexterm"/>where we'll provide a visual overview on open tasks over time. All projects will be represented in a line chart that displays the progress of open tasks. We'll also provide some user interaction <a id="id430" class="indexterm"/>so that the user can choose between different timeframes.</li><li class="listitem"><span class="strong"><strong>Activity chart</strong></span>: This <a id="id431" class="indexterm"/>component visualizes activities in a bar chart over a timeframe of 24 hours. This will help our users quickly identify overall and peak project activities.</li><li class="listitem"><span class="strong"><strong>Project summary</strong></span>: This is <a id="id432" class="indexterm"/>where we'll display a summary of each project where we outline the most important facts. Our project summary component will also include an activity chart component that visualizes project activity.</li><li class="listitem"><span class="strong"><strong>Projects dashboard</strong></span>: This <a id="id433" class="indexterm"/>component is just a composition of the previous two components. This is our main component in the dashboard. It represents our dashboard page and is directly exposed to the router.</li></ul></div><div class="section" title="Creating the projects dashboard component"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec66"/>Creating the projects dashboard component</h2></div></div></div><p>First, we'll create <a id="id434" class="indexterm"/>our main dashboard component. The <code class="literal">ProjectsDashboard</code> component has only two responsibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtaining project data, which is used to create the dashboard</li><li class="listitem">Composing the main dashboard layout by including our dashboard subcomponents</li></ul></div><p>Let's jump right in and create a new component class on the path, <code class="literal">lib/projects-dashboard/projects-dashboard.js</code>:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewEncapsulation, Inject} from '@angular/core';
import template from './projects-dashboard.html!text';
import {ProjectService} from '../project/project-service/project-service';

@Component({
selector: 'ngc-projects-dashboard',
host: {class: 'projects-dashboard'},
template,
encapsulation: ViewEncapsulation.None
})
export class ProjectsDashboard {
constructor(@Inject(ProjectService) projectService) {
this.projects = projectService.change;
  }
}</pre></div><p>In our <code class="literal">dashboard</code> component, we'll use the change observable of <code class="literal">ProjectService</code> directly. This is different to the usual way that we deal with observables. Usually, we'd subscribe to the observable in our component and then update our component whenever data streams through. However, in our projects dashboard, we're directly storing the change observable of <code class="literal">ProjectService</code> on our component.</p><p>Now, we can use one of Angular's async core pipes in order to subscribe to the observable directly in our view.</p><p>Exposing observables <a id="id435" class="indexterm"/>directly into the view and using the <code class="literal">async</code> pipe to subscribe to the observable comes with a main advantage.</p><p>We don't need to deal with subscribing and unsubscribing in our component, as the <code class="literal">async</code> pipe will do that for us directly in the view.</p><p>When a new value is emitted within the observable, the <code class="literal">async</code> pipe will cause the underlying binding to be updated. Also, if the view gets destroyed because of any reason, the <code class="literal">async</code> pipe will automatically unsubscribe from the observable.</p><div class="note" title="Note"><h3 class="title"><a id="tip16"/>Tip</h3><p>By chaining RxJS operators together, we can bring an observable stream into the required shape without performing any subscription. Using the <code class="literal">async</code> pipe, we can then leave it up to the view to subscribe and unsubscribe from the transformed observable stream. This encourages us to write pure and stateless components, and when used correctly, this is a great practice.</p></div><p>Let's take a look at the view of our component created in the <code class="literal">projects-dashboard.html</code> file in the same directory as the <code class="literal">Component</code> class:</p><div class="informalexample"><pre class="programlisting">&lt;div class="projects-dashboard__l-header"&gt;
&lt;h2 class="projects-dashboard__title"&gt;Dashboard&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="projects-dashboard__l-main"&gt;
&lt;h3 class="projects-dashboard__sub-title"&gt;Projects&lt;/h3&gt;
&lt;ul class="projects-dashboard__list"&gt;
<span class="strong"><strong>&lt;li *ngFor="let project of projects | async"&gt;</strong></span>
<span class="strong"><strong>&lt;div&gt;{{project.title}}&lt;/div&gt;</strong></span>
<span class="strong"><strong>&lt;div&gt;{{project.description}}&lt;/div&gt;</strong></span>
<span class="strong"><strong>&lt;/li&gt;</strong></span>
&lt;/ul&gt;
&lt;/div&gt;</pre></div><p>You can see from the template that we use the <code class="literal">async</code> pipe to subscribe to the projects observable of our <code class="literal">Component</code> class. The <code class="literal">async</code> pipe will initially return <code class="literal">null</code>, but on any change in the observable, this will return the resolved value from the subscription. This means that we don't need to worry about subscribing to our project list observable. We can simply make use of the <code class="literal">async</code> pipe to subscribe and resolve directly in our view.</p><p>For the moment, we only displayed the project title and description, but in the next section, we will create a new project summary component that will deal with some more complex rendering.</p></div><div class="section" title="Project summary component"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec67"/>Project summary component</h2></div></div></div><p>In this section, we'll <a id="id436" class="indexterm"/>create a <code class="literal">project-summary</code> component that will provide some overview information for projects. Besides the title and description, this will also include an overview over the total efforts on the project tasks.</p><p>Let's first build the component and make the necessary preparations so that we can display the total effort of the underlying tasks of the project.</p><p>We'll start with the Component class on the <code class="literal">lib/projects-dashboard/project-summary/project-summary.js</code> path:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import{FormatEffortsPipe} from '../../pipes/format-efforts';</strong></span>
<span class="strong"><strong>import{EffortsTimeline} from '../../efforts/efforts-timeline/efforts-timeline';</strong></span>
import template from './project-summary.html!text';

@Component({
selector: 'ngc-project-summary',
host: { class: 'project-summary' },
template,
<span class="strong"><strong>directives: [EffortsTimeline],</strong></span>
<span class="strong"><strong>pipes: [FormatEffortsPipe],</strong></span>
encapsulation: ViewEncapsulation.None
})
export class ProjectSummary {
@Input() project;

ngOnChanges(changes) {
if (this.project) {
<span class="strong"><strong>this.totalEfforts = this.project.tasks.reduce(</strong></span>
<span class="strong"><strong>        (totalEfforts, task) =&gt; {</strong></span>
<span class="strong"><strong>if (task.efforts) {</strong></span>
<span class="strong"><strong>totalEfforts.estimated += task.efforts.estimated || 0;</strong></span>
<span class="strong"><strong>totalEfforts.effective += task.efforts.effective || 0;</strong></span>
<span class="strong"><strong>          }</strong></span>

<span class="strong"><strong>returntotalEfforts;</strong></span>
<span class="strong"><strong>        }, {</strong></span>
<span class="strong"><strong>estimated: 0,</strong></span>
<span class="strong"><strong>effective: 0</strong></span>
<span class="strong"><strong>        });</strong></span>
       }
  }
}</pre></div><p>As you've probably already guessed, we reused the <code class="literal">EffortsTimeline</code> component that we created in the previous chapter. As our project summary will also include an efforts timeline, based on the same semantics as our total effort, there's no need to create a new component for this.</p><p>What we need to do, though, is to accumulate all task efforts into an overall effort. Using the <code class="literal">Array.prototype.reduce</code> function, we can accumulate all task efforts relatively easy.</p><p>The resulting object <a id="id437" class="indexterm"/>from the reduce call needs to keep up with the format that is expected of an <code class="literal">efforts</code> object. As an initial value, we'll provide an <code class="literal">efforts</code> object with an estimated and effective time of zero. Then, the reduce callback will add any task effort values that are found in the project.</p><p>Let's look into the template to see how we're going to use this total efforts data to display our <code class="literal">EffortsTimeline</code> component:</p><div class="informalexample"><pre class="programlisting">&lt;div class="project-summary__title"&gt;<span class="strong"><strong>{{project?.title}}</strong></span>&lt;/div&gt;
&lt;div class="project-summary__description"&gt;
<span class="strong"><strong>{{project?.description}}</strong></span>
&lt;/div&gt;
&lt;div class="project-summary__label"&gt;Total Efforts&lt;/div&gt;
<span class="strong"><strong>&lt;ngc-efforts-timeline [estimated]="totalEfforts?.estimated"</strong></span>
<span class="strong"><strong>                      [effective]="totalEfforts?.effective"</strong></span>
<span class="strong"><strong>height="10"&gt;&lt;/ngc-efforts-timeline&gt;</strong></span>
<span class="strong"><strong>&lt;p&gt;{{totalEfforts | formatEfforts}}&lt;/p&gt;</strong></span>
</pre></div><p>After displaying the title and description of the project, we included the <code class="literal">EffortsTimeline</code> component, which we bind to the <code class="literal">totalEfforts</code> member that we just constructed. This timeline will now display the total aggregated amount of efforts logged on the tasks.</p><p>In addition to the timeline, we also rendered a formatted efforts text, such as the one that we already rendered in the <code class="literal">Efforts</code> component of the previous chapter. For this, we used the <code class="literal">FormatEffortsPipe</code> pipe.</p><p>Now, what's still left to do is to integrate our <code class="literal">ProjectSummary</code> component into the <code class="literal">ProjectsDashboard</code> component.</p><p>Let's look at the template modification in the <code class="literal">projects-dashboard.html</code> component template:</p><div class="informalexample"><pre class="programlisting">...
&lt;li *ngFor="let project of projects | async"&gt;
<span class="strong"><strong>&lt;ngc-project-summary </strong></span>
<span class="strong"><strong>    [project]="project"</strong></span>
<span class="strong"><strong>    [routerLink]="['/projects', project._id]"&gt;</strong></span>
<span class="strong"><strong>&lt;/ngc-project-summary&gt;</strong></span>
&lt;/li&gt;
...</pre></div><p>You can see that we bind the <code class="literal">project</code> local view variable, which was created by the <code class="literal">NgFor</code> directive in <a id="id438" class="indexterm"/>conjunction with the <code class="literal">async</code> pipe, to the <code class="literal">project</code> input property of our <code class="literal">ProjectSummary</code> component.</p><p>We also used the <code class="literal">RouterLink</code> directive to establish the navigation onto the <code class="literal">ProjectDetails</code> view if the user clicks on one of the summary tiles.</p><p>The modifications in the <code class="literal">ProjectsDashboard</code> component class are negligible:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {ROUTER_DIRECTIVES} from '@angular/router';</strong></span>
<span class="strong"><strong>import{ProjectSummary} from './project-summary/project-summary';</strong></span>
...
@Component({
selector: 'ngc-projects-dashboard',
<span class="strong"><strong>directives: [ProjectSummary, ROUTER_DIRECTIVES],</strong></span>
  ...
})
export class ProjectsDashboard {
  ...
}</pre></div><p>The only modification that we applied to the <code class="literal">Component</code> class was to add the <code class="literal">ProjectSummary</code> component and the <code class="literal">ROUTER_DIRECTIVES</code> constant to the directives list of the component. The <code class="literal">ROUTER_DIRECTIVES</code> constant includes the <code class="literal">RouterOutlet</code> and <code class="literal">RouterLink</code> directives, and we use the latter in our template.</p><div class="mediaobject"><img src="../Images/image00343.jpeg" alt="Project summary component"/><div class="caption"><p>A projects dashboard displaying two project summary components with the aggregated total effort</p></div></div><p style="clear:both; height: 1em;"> </p><p>Okay, so far so good. We created two new components and reused our <code class="literal">EffortsTimeline</code> <a id="id439" class="indexterm"/>component to create an aggregated view on the tasks efforts. In the next section, we will enrich our <code class="literal">ProjectSummary</code> component with a nice Chartist chart.</p></div></div>
<div class="section" title="Creating your first chart"><div class="titlepage" id="aid-1Q5IA2"><div><div><h1 class="title"><a id="ch09lvl1sec55"/>Creating your first chart</h1></div></div></div><p>In this section, we will <a id="id440" class="indexterm"/>create our first chart using Chartist to provide a project activity overview over the past 24 hours. This bar chart will only provide some visual clues about the project activity, and our goal is not to make it provide detailed information. For this reason, we will configure it to hide any labels, scales, and grid lines. The only visible part should be the bars of the bar chart.</p><p>Before we start creating the activity chart itself, we need to look at how we need to transform and prepare our data for the charts.</p><p>Let's look at what data we already have in our system. As far as the activities go, they all have a timestamp on them stored in the <code class="literal">time</code> field. However, for our chart, we want something else displayed. What we're looking for is a chart that displays one bar for each hour of the past 24 hours. Each bar should represent the count of activities in that timeframe.</p><p>The following illustration shows our source data, which is basically a time stream of activity events. On the lower arrow, we see the data that we need to end up with for our chart:</p><div class="mediaobject"><img src="../Images/image00344.jpeg" alt="Creating your first chart"/><div class="caption"><p>An illustration displaying activities as a time stream where the dots represent activities. The lower arrow is showing a rasterized count by hour for the last 24 hours.</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's implement a function that does the transformation outlined in this image. We'll add this function to our <a id="id441" class="indexterm"/>
<code class="literal">time-utilities</code> module on the <code class="literal">lib/utilities/time-utilities.js</code> path:</p><div class="informalexample"><pre class="programlisting">function rasterize(timeData, timeFrame, quantity, now, fill = 0) {
  // Floor to a given time frame
now = Math.floor(now / timeFrame) * timeFrame;
returntimeData.reduce((out, timeData) =&gt; {
    // Calculating the designated index in the rasterized output
<span class="strong"><strong>const index = Math.ceil((now - timeData.time) / timeFrame);</strong></span>
    // If the index is larger or equal to the designed rasterized 
    // array length, we can skip the value
<span class="strong"><strong>if (index &lt; quantity) {</strong></span>
<span class="strong"><strong>out[index] = (out[index] || 0) + timeData.weight;</strong></span>
<span class="strong"><strong>    }</strong></span>
return out;
  }, Array.from({length: quantity}).fill(fill)).reverse();
}</pre></div><p>Let's look at the input parameters of our newly-created function:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">timeData</code>: This parameter is expected to be an array of objects that contains a <code class="literal">time</code> property that is set to the timestamp of the event that should be counted. The objects should also contain a <code class="literal">weight</code> property, which is used to count. Using this property, we can count one event as two or even count minus values to decrease the count in a raster.</li><li class="listitem"><code class="literal">timeFrame</code>: This parameter specifies the time span of each raster in milliseconds. If we want to have 24 rasterized frames, each consisting of one hour this parameter needs to be set to 3,600,000 (1 h = 60 min = 3,600 s = 3,600,000 ms).</li><li class="listitem"><code class="literal">quantity</code>: This parameter sets the amount of rasterized frames that should be present in the output array. In the case of 24 frames of one hour, this parameter should be set to 24.</li><li class="listitem"><code class="literal">now</code>: This is when our function is rasterizing time, starting at a given point in time backwards. The <code class="literal">now</code> parameter sets this point in time.</li><li class="listitem"><code class="literal">fill</code>: This is how we can specify how we'd like our rasterized output array to be initialized. In the case of our activity counts, we want this to be set to <code class="literal">0</code>.</li></ul></div><p>The function that we just created is necessary to create the activity chart. The transformation helps us prepare project activities for the input data of the chart.</p><p>It's time to create our first chart component! Let's start with a new template created on the <code class="literal">lib/projects-dashboard/project-summary/activity-chart/activity-chart.html</code> path:</p><div class="informalexample"><pre class="programlisting">&lt;div #chartContainer&gt;&lt;/div&gt;</pre></div><p>As we leave all the rendering up to Chartist, this is actually already all that we need. Chartist needs an <a id="id442" class="indexterm"/>element as a container to create the chart in. We set a <code class="literal">chartContainer</code> local view reference so that we can reference it from our component, and then pass it to Chartist.</p><p>Let's move on with the chart creation, and flesh out the activity chart component by creating the <code class="literal">Component</code> class in <code class="literal">activity-chart.js</code> in the same directory as the template:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import Chartist from 'chartist';</strong></span>
<span class="strong"><strong>import {rasterize, UNITS} from '../../../utilities/time-utilities';</strong></span>

@Component({
selector: 'ngc-activity-chart',
  ...
})
export class ActivityChart {
<span class="strong"><strong>@Input() activities;</strong></span>
<span class="strong"><strong>@ViewChild('chartContainer') chartContainer;</strong></span>

ngOnChanges() {
<span class="strong"><strong>this.createOrUpdateChart();</strong></span>
  }

ngAfterViewInit() {
<span class="strong"><strong>this.createOrUpdateChart();</strong></span>
  }
  ...
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="note11"/>Note</h3><p>Chartist is available for almost all package managers, and it also comes bundled in the <span class="strong"><strong>UMD</strong></span> module format (<span class="strong"><strong>Universal Module Format</strong></span>), which, in fact, is a wrapper to enable <span class="strong"><strong>AMD</strong></span> (<span class="strong"><strong>Asynchronous Module Definition</strong></span>), CommonJS module format, and global export.</p></div><p>Using JSPM, we can simply install Chartist by executing the following command on the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jspm install chartist</strong></span>
</pre></div><p>After installing Chartist, we can directly import it using ES6 module syntax.</p><p>We also import the rasterize function that we created so that we can use it later to convert our activities into the expected input format for our chart.</p><p>As we rely on a view <a id="id443" class="indexterm"/>child as a container element to create our chart, we need to wait for the <code class="literal">AfterViewInit</code> lifecycle hook in order to construct the chart. At the same time, we need to rerender the chart if the input <code class="literal">activities</code> change. Using the <code class="literal">OnChanges</code> lifecycle hook, we can react on input changes and update our chart.</p><p>Let's now look at the <code class="literal">createOrUpdateChart</code> function, which does exactly what its name already implies:</p><div class="informalexample"><pre class="programlisting">createOrUpdateChart() {
<span class="strong"><strong>if (!this.activities || !this.chartContainer) {</strong></span>
<span class="strong"><strong>return;</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>consttimeData = this.activities.map((activity) =&gt; {</strong></span>
<span class="strong"><strong>return {</strong></span>
<span class="strong"><strong>time: activity.time,</strong></span>
<span class="strong"><strong>weight: 1</strong></span>
<span class="strong"><strong>    };</strong></span>
<span class="strong"><strong>  });</strong></span>

<span class="strong"><strong>const series = [</strong></span>
<span class="strong"><strong>rasterize(</strong></span>
<span class="strong"><strong>timeData,</strong></span>
<span class="strong"><strong>UNITS.find((unit) =&gt; unit.short === 'h').milliseconds,</strong></span>
<span class="strong"><strong>      24, </strong></span>
<span class="strong"><strong>      +new Date())</strong></span>
<span class="strong"><strong>  ];</strong></span>

if (this.chart) {
this.chart.update({ series });
  } else {
<span class="strong"><strong>this.chart = new Chartist.Bar(this.chartContainer.nativeElement, {</strong></span>
<span class="strong"><strong>series</strong></span>
<span class="strong"><strong>    }, {</strong></span>
<span class="strong"><strong>width: '100%',</strong></span>
<span class="strong"><strong>height: 60,</strong></span>
<span class="strong"><strong>axisY: {</strong></span>
<span class="strong"><strong>onlyInteger: true,</strong></span>
<span class="strong"><strong>showGrid: false,</strong></span>
<span class="strong"><strong>showLabel: false,</strong></span>
<span class="strong"><strong>offset: 0</strong></span>
<span class="strong"><strong>      },</strong></span>
<span class="strong"><strong>axisX: {</strong></span>
<span class="strong"><strong>showGrid: false,</strong></span>
<span class="strong"><strong>showLabel: false,</strong></span>
<span class="strong"><strong>offset: 0</strong></span>
<span class="strong"><strong>      },</strong></span>
<span class="strong"><strong>chartPadding: 0</strong></span>
<span class="strong"><strong>    });</strong></span>
  }
}</pre></div><p>Let's look into the code in more detail and walk through it step by step:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">As we get called both from the <code class="literal">AfterViewInit</code> and <code class="literal">OnChanges</code> lifecycle, we need to make sure that both the <code class="literal">chartContainer</code> and <code class="literal">activities</code> inputs are ready before we continue.</li><li class="listitem">Now, it's time to convert the activity data that we receive as input into the rasterized form that is required for the chart that we'd like to create. We use <code class="literal">Array.prototype.map</code> to transform our activities into the <code class="literal">timeData</code> objects that are required by the <code class="literal">rasterize</code> function. We also pass the necessary parameters so that the function will rasterize into 24 frames, each consisting of one hour.</li><li class="listitem">If the <code class="literal">chart</code> member is already set to a chart that was previously created, we can use the <code class="literal">update</code> function on the Chartist chart object to only update with the new data.</li><li class="listitem">If there's no <a id="id444" class="indexterm"/>chart object already, we need to create a new chart. As a first parameter to the <code class="literal">Chartist.Bar</code> constructor, we'll pass the DOM element reference of our container view child. Chartist will create our chart in this container element. The second argument is our data, which we fill with the series that was just generated. In the chart options, we'll set everything to achieve a very plain-looking chart without any detailed information.</li></ul></div><p>This is great! We created our first chart component using Chartist! Now, we can go back to our <code class="literal">ProjectSummary</code> component and integrate the activity chart there to provide an activity overview:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {ActivityService} from '../../activities/activity-service/activity-service';</strong></span>
<span class="strong"><strong>import {ActivityChart} from './activity-chart/activity-chart';</strong></span>

@Component({
selector: 'ngc-project-summary',
  ...
directives: [EffortsTimeline, <span class="strong"><strong>ActivityChart</strong></span>],
  ...
})
export class ProjectSummary {
  ...
<span class="strong"><strong>constructor(@Inject(ActivityService) activityService) {</strong></span>
<span class="strong"><strong>this.activityService = activityService;</strong></span>
<span class="strong"><strong>  }</strong></span>

ngOnChanges() {
if (this.project) {
      ...

<span class="strong"><strong>this.activities = this.activityService.change</strong></span>
<span class="strong"><strong>        .map((activities) =&gt; activities.filter((activity) =&gt; activity.subject === this.project._id));</strong></span>
    }
  }
}</pre></div><p>The first change here is to <a id="id445" class="indexterm"/>include the <code class="literal">ActivityService</code> so that we can extract the required project activities to pass them to the <code class="literal">ActivityChart</code> component. We also need to import the <code class="literal">ActivityChart</code> component and declare it as a directive on the component.</p><p>As our component relies on the project to be provided as input, which is subject to change, we need to implement the logic to extract activities in the <code class="literal">OnChanges</code> lifecycle hook of the component.</p><p>Before we pass on the observable activities stream, we need to filter the activities that come through the stream so that we only get activities that are relevant to the current project. Again, we will use the <code class="literal">async</code> pipe in order to subscribe to the activities so that there's no need to use a subscribe form within the component. The <code class="literal">activities</code> property will be directly set to a filtered <code class="literal">Observable</code>.</p><p>Let's look at the changes in the view of the <code class="literal">ProjectSummary</code> component in order to enable our chart:</p><div class="informalexample"><pre class="programlisting">...
&lt;div class="project-summary__label"&gt;Activity last 24 hours&lt;/div&gt;
<span class="strong"><strong>&lt;ngc-activity-chart [activities]="activities | async"&gt;</strong></span>
<span class="strong"><strong>&lt;/ngc-activity-chart&gt;</strong></span>
</pre></div><p>We add our <code class="literal">ActivityChart</code> component at the bottom of the already existing template. We also create the necessary binding to pass our activities into the component. Using the <code class="literal">async</code> pipe, we can resolve the observable stream and pass the filtered activities list into the <code class="literal">chart</code> component.</p><p>Finally, our <a id="id446" class="indexterm"/>
<code class="literal">ProjectSummary</code> component looks great and immediately provides a project insight by displaying the aggregated efforts timeline and a nice activity chart. In the next section, we'll dive a bit deeper into the charting capabilities of Chartist, and we will also provide some interactivity using Angular.</p></div>
<div class="section" title="Visualizing open tasks"><div class="titlepage" id="aid-1R42S2"><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Visualizing open tasks</h1></div></div></div><p>In this section, we will <a id="id447" class="indexterm"/>create a chart component using Chartist, which will display the open task progress of projects over time. To do this, we'll use a line chart with a specific interpolation that provides quantized steps rather than lines with directly connected points.</p><p>We are also providing some interactivity in that the user will be able to switch the displayed time frame using a toggle button. This allows us to reuse the <code class="literal">Toggle</code> component that we created in <a class="link" title="Chapter 2. Ready, Set, Go!" href="part0020.xhtml#aid-J2B81">Chapter 2</a>,<span class="emphasis"><em> Ready, Set, Go!,</em></span> of this book.</p><p>Let's first look at the data that we have in our system and how we can transform it into the data needed by Chartist.</p><p>We can rely on two data attributes of our tasks in order to draw them onto a timeline. The <code class="literal">created</code> attribute is set to the timestamp at the moment when the task was created. If a task is marked as done, the <code class="literal">done</code> attribute is set to the timestamp at that time.</p><p>As we're only interested in the amount of open tasks at any given time, we can safely presume a model where we put all tasks onto a single timeline and where we are only concerned about the <code class="literal">created</code> and <code class="literal">done</code> timestamps as events. Let's look at the following illustration to get a better understanding of the problem:</p><div class="mediaobject"><img src="../Images/image00345.jpeg" alt="Visualizing open tasks"/><div class="caption"><p>An illustration that shows how we can represent all task timelines on a single timeline using the created and done events. The created events count as a +1, while the done events count as -1.</p></div></div><p style="clear:both; height: 1em;"> </p><p>The lower arrow is a representation of all tasks of the <code class="literal">created</code> and <code class="literal">done</code> events on a timeline. We can now use <a id="id448" class="indexterm"/>this information as input to our <code class="literal">rasterize</code> function in order to get the data that we need for our chart. As the <code class="literal">timeData</code> objects that are used as input for the rasterization also support a <code class="literal">weight</code> property, we can use this to represent the <code class="literal">created (+1)</code> or <code class="literal">done (-1)</code> events.</p><p>We need to make a slight modification to our rasterize function. So far, the rasterize function only counts events together in frames. However, for the open task counts, we look into an accumulation over time. If the task count changes, we need to keep the value until it changes again. In transformation of activities in the previous topic, we didn't use this same logic. There, we only counted events inside frames, but there was no accumulation.</p><p>Let's look at the following illustration to see the difference as compared to the rasterization that we applied while processing activities:</p><div class="mediaobject"><img src="../Images/image00346.jpeg" alt="Visualizing open tasks"/><div class="caption"><p>An illustration that shows how we can accumulate the open tasks count over time</p></div></div><p style="clear:both; height: 1em;"> </p><p>We can count each <code class="literal">weight</code> property of the <code class="literal">timeData</code> objects (events) together over time. Only if there's a change of the accumulated value, we will write the current accumulated value into the rasterized output array.</p><p>Let's open our <code class="literal">time-utilities</code> module and apply the changes to the <code class="literal">rasterize</code> function:</p><div class="informalexample"><pre class="programlisting">export function rasterize(timeData, timeFrame, quantity, 
now = +new Date(), fill = 0, 
<span class="strong"><strong>accumulate = false</strong></span>) {
  // Floor to a given time frame
now = Math.floor(now / timeFrame) * timeFrame;
<span class="strong"><strong>  // Accumulation value used for accumulation mode to keep track </strong></span>
<span class="strong"><strong>  // of current value</strong></span>
<span class="strong"><strong>let accumulatedValue = 0;</strong></span>

<span class="strong"><strong>  // In accumulation mode we need to be sure that the time data </strong></span>
<span class="strong"><strong>  // is ordered</strong></span>
<span class="strong"><strong>if (accumulate) {</strong></span>
<span class="strong"><strong>timeData = timeData.slice().sort(</strong></span>
<span class="strong"><strong>      (a, b) =&gt; a.time &lt; b.time ? -1 : a.time &gt; b.time ? 1 : 0);</strong></span>
<span class="strong"><strong>  }</strong></span>

return timeData.reduce((rasterized, timeData) =&gt; {
<span class="strong"><strong>    // Increase the accumulated value, in case we need it</strong></span>
<span class="strong"><strong>accumulatedValue += timeData.weight;</strong></span>
    // Calculating the designated index in the rasterized output 
    // array
const index = Math.ceil((now - timeData.time) / timeFrame);
    // If the index is larger or equal to the designed rasterized 
    // array length, we can skip the value
if (index &lt; quantity) {
<span class="strong"><strong>rasterized[index] = accumulate ? </strong></span>
<span class="strong"><strong>accumulatedValue :</strong></span>
<span class="strong"><strong>        (rasterized[index] || 0) + timeData.weight;</strong></span>
    }
return rasterized;
  }, Array.from({length: quantity}).fill(fill)).reverse();
}</pre></div><p>Let's walk through the changes that we applied to the <code class="literal">rasterize</code> function to allow accumulation of frames:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">First of all, we added a new parameter to our function with the name <code class="literal">accumulate</code>. We used <a id="id449" class="indexterm"/>the ES6 default parameters to set the parameter to <code class="literal">false</code> if no value was passed into the function when called.</li><li class="listitem">We now define a new <code class="literal">accumulatedValue</code> variable, which we initialize with <code class="literal">0</code>. This variable will be used to keep track of the sum of all <code class="literal">weight</code> values over time.</li><li class="listitem">The next bit of code is very important. If we want to accumulate the sum of all <code class="literal">weight</code> values over time, we need to make sure that these values come in sequence. In order to ensure this, we sort the <code class="literal">timeData</code> list by its items <code class="literal">time</code> attribute.</li><li class="listitem">In the <code class="literal">reduce</code> callback, we increase the <code class="literal">accumulatedValue</code> variable by the <code class="literal">weight</code> value of the current <code class="literal">timeData</code> object.</li><li class="listitem">If the <code class="literal">timeData</code> object falls into a rasterized frame, we do not increase this frame's count like we did before. In accumulation mode, we set the frames count to the current value in <code class="literal">accumulatedValue</code>. This will result in all changed accumulated <a id="id450" class="indexterm"/>values being reflected in the rasterized output array.</li></ul></div><p>This is all the preparation that we need to process the date in order to render our open tasks chart. Let's move on and create the <code class="literal">Component</code> class of our new <code class="literal">chart</code> component.</p><div class="section" title="Creating an open tasks chart"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec68"/>Creating an open tasks chart</h2></div></div></div><p>In the following component, we <a id="id451" class="indexterm"/>will utilize the refactored <code class="literal">rasterize</code> function of the previous topic. Using the new accumulate function, we can now track open task counts over time.</p><p>Let's start with the <code class="literal">Component</code> class in a new <code class="literal">lib/projects-dashboard/tasks-chart/tasks-chart.js</code> file to implement our <code class="literal">Component</code> class:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import Chartist from 'chartist';</strong></span>
<span class="strong"><strong>import Moment from 'moment';</strong></span>

<span class="strong"><strong>import {rasterize} from '../../utilities/time-utilities';</strong></span>

@Component({
selector: 'ngc-tasks-chart',
  ...
})
export class TasksChart {
<span class="strong"><strong>@Input() projects;</strong></span>
<span class="strong"><strong>@ViewChild('chartContainer') chartContainer;</strong></span>

ngOnChanges() {
<span class="strong"><strong>this.createOrUpdateChart();</strong></span>
  }

ngAfterViewInit() {
<span class="strong"><strong>this.createOrUpdateChart();</strong></span>
  }
     ...
}</pre></div><p>So far, this looks exactly like our first <code class="literal">chart</code> component where we visualized project activities. We also imported Chartist as we will use it to render our chart in the <code class="literal">createOrUpdateChart</code> function that we'll create shortly. The chart that we will create will contain much more detailed information. We will render both axis labels and some scales. In order to format our labels that basically contain timestamps, we use the Moment.js library once again.</p><p>We also use the <a id="id452" class="indexterm"/>
<code class="literal">projects</code> input data and transform it with the amended <code class="literal">rasterize</code> utility function in order to prepare all the data for our line chart.</p><p>Let's move on and flesh out the <code class="literal">createOrUpdateChart</code> method of our component:</p><div class="informalexample"><pre class="programlisting">createOrUpdateChart() {
if (!this.projects || !this.chartContainer) {
return;
  }

  // Create a series array that contains one data series for each 
  // project
<span class="strong"><strong>const series = this.projects.map((project) =&gt; {</strong></span>
<span class="strong"><strong>    // First we need to reduces all tasks into one timeData list</strong></span>
<span class="strong"><strong>const timeData = project.tasks.reduce((timeData, task) =&gt; {</strong></span>
<span class="strong"><strong>      // The created time of the task generates a timeData with </strong></span>
<span class="strong"><strong>      // weight 1</strong></span>
<span class="strong"><strong>timeData.push({</strong></span>
<span class="strong"><strong>time: task.created,</strong></span>
<span class="strong"><strong>weight: 1</strong></span>
<span class="strong"><strong>      });</strong></span>
<span class="strong"><strong>      // If this task is done, we're also generating a timeData</strong></span>
<span class="strong"><strong>      // object with weight -1</strong></span>
<span class="strong"><strong>if (task.done) {</strong></span>
<span class="strong"><strong>timeData.push({</strong></span>
<span class="strong"><strong>time: task.done,</strong></span>
<span class="strong"><strong>weight: -1</strong></span>
<span class="strong"><strong>        });</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>return timeData;</strong></span>
<span class="strong"><strong>    }, []);</strong></span>

    // Using the rasterize function in accumulation mode, we can 
    // create the required data array that represents our series 
    // data
<span class="strong"><strong>return rasterize(timeData, 600000, 144, +new Date(), </strong></span>
<span class="strong"><strong>null, true);</strong></span>
<span class="strong"><strong>  });</strong></span>

const now = +new Date();
<span class="strong"><strong>  // Creating labels for all the timeframes we're displaying</strong></span>
<span class="strong"><strong>const labels = Array.from({</strong></span>
<span class="strong"><strong>length: 144</strong></span>
<span class="strong"><strong>  }).map((e, index) =&gt; now - index * 600000).reverse();</strong></span>

if (this.chart) {
    // If we already have a valid chart object, we can simply 
    // update the series data and labels
this.chart.update({
series,
labels
    });
  } else {
    // Creating a new line chart using the chartContainer element 
    // as container
this.chart = new Chartist.Line(this.chartContainer.nativeElement, {
series,
      labels
    }, {
      width: '100%',
height: 300,
      // Using step interpolation, we can cause the chart to 
      // render in steps instead of directly connected points
<span class="strong"><strong>lineSmooth: Chartist.Interpolation.step({</strong></span>
<span class="strong"><strong>        // The fill holes setting on the interpolation will cause </strong></span>
<span class="strong"><strong>        // null values to be skipped and makes our line to </strong></span>
<span class="strong"><strong>        // connect to the next valid value</strong></span>
<span class="strong"><strong>fillHoles: true</strong></span>
<span class="strong"><strong>      }),</strong></span>
axisY: {
onlyInteger: true,
low: 0,
offset: 70,
        // We're using the label interpolation function for 
        // formatting our open tasks count
labelInterpolationFnc: (value) =&gt; `${value} tasks`
      },
axisX: {
<span class="strong"><strong>        // We're only displaying two x-axis labels and grid lines</strong></span>
<span class="strong"><strong>labelInterpolationFnc: (value, index, array) =&gt; index % (144 / 4) === 0 ? Moment(value).calendar() : null</strong></span>
      }
    });
  }
}</pre></div><p>Okay, that's quite a bit of code here. Let's walk through it step by step to gain a better understanding of what's going on:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we need to create our transformed series data by mapping the projects list. The series array should include one data array for each project. Each data array will contain the open project tasks over time.</li><li class="listitem">As the <code class="literal">rasterize</code> function expects a list of <code class="literal">timeData</code> objects, we first need to transform the projects task list into this format. By reducing the task list, we create a single list of the <code class="literal">timeData</code> objects. The <code class="literal">reduce</code> function callback will <a id="id453" class="indexterm"/>generate one <code class="literal">timeData</code> object with a <code class="literal">weight</code> of 1 for each task. Additionally, it will generate a <code class="literal">timeData</code> object for each task marked as one with the <code class="literal">weight</code> value -1. This will result in the desired <code class="literal">rimeData</code> array, which we can use to accumulate and rasterize.</li><li class="listitem">After preparing the <code class="literal">timeData</code> list, we can call the <code class="literal">rasterize</code> function in order to create a list of open tasks over a certain amount of timeframes. We use a 10 minute timeframe (600000ms) and rasterize this with 144 frames. This makes a total of 24 hours.</li><li class="listitem">Besides the series data, we will also need labels for our chart. We create a new array and initialize this with 144 timestamps, all of which are set to the start of the 144 rasterized frames that we display on the chart.</li><li class="listitem">Now, we have the series data and the labels ready, and all that's left to do is to render our chart.</li><li class="listitem">Using the <code class="literal">lineSmooth</code> configuration, we can specify a special kind of interpolation for our line chart. The step interpolation will not connect each point in our line chart directly, but rather it will move in discrete steps to move from point to point. This is exactly what we're looking for to render the open task counts over time.</li><li class="listitem">Setting the <code class="literal">fillHoles</code> option to <code class="literal">true</code> in the step interpolation is very important. Using this setting, we can actually tell Chartist that it should close any gaps within the data (actually null values) and connect the line to the next valid value. Without this setting, we'd see gaps on the chart between the task count changes in our data arrays.</li><li class="listitem">One last important thing in our code is the <code class="literal">labelInterpolationFnc</code> option that we set on the <span class="emphasis"><em>x</em></span> axis configuration. This function can not only be used to format a label or interpolate any expression that may come along with the label, but it also allows us to return null instead. Returning null from this function will cause Chartist to skip the given label and the corresponding grid line. This is very useful if we'd like to skip certain labels by their value or by the index of the label. In our code, we ensure that we only render four labels of all 144 generated labels.</li></ol><div style="height:10px; width: 1px"/></div><p>Let's take a look at the rather simple template of our component in the <code class="literal">tasks-chart.html</code> file in the same folder as our <code class="literal">Component</code> class file:</p><div class="informalexample"><pre class="programlisting">&lt;div #chartContainer class="tasks-chart__container"&gt;&lt;/div&gt;</pre></div><p>The same as with the <code class="literal">ActivityChart</code> component, we only create a simple chart container element, which we already reference in our <code class="literal">Component</code> class.</p><p>This is basically all that we <a id="id454" class="indexterm"/>needed to do in order to create an open tasks chart using Chartist. However, there's still some room for improvement here:</p><div class="mediaobject"><img src="../Images/image00347.jpeg" alt="Creating an open tasks chart"/><div class="caption"><p>Open tasks visualized with our tasks chart component using Chartist's step interpolation</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Creating a chart legend"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec69"/>Creating a chart legend</h2></div></div></div><p>Currently, there's no <a id="id455" class="indexterm"/>way to tell exactly which of the lines represents what project. We <a id="id456" class="indexterm"/>see one colored line for each project, but we can't associate these colors. What we need is a simple legend that helps our users to associate line chart colors to projects.</p><p>Let's look at the required code changes to implement legends on our chart. In the <code class="literal">Component</code> class of our <code class="literal">TasksChart</code> component, we need to perform the following modifications:</p><div class="informalexample"><pre class="programlisting">...
export class TasksChart {
  ...
ngOnChanges() {
<span class="strong"><strong>if (this.projects) {</strong></span>
<span class="strong"><strong>      // On changes of the projects input, we need to update the </strong></span>
<span class="strong"><strong>      // legend</strong></span>
<span class="strong"><strong>this.legend = this.projects.map((project, index) =&gt; {</strong></span>
<span class="strong"><strong>return {</strong></span>
<span class="strong"><strong>name: project.title,</strong></span>
<span class="strong"><strong>class: `tasks-chart__series--series-${index + 1}`</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>      });</strong></span>
<span class="strong"><strong>    }</strong></span>

this.createOrUpdateChart();
  }
  ...
}</pre></div><p>In the <code class="literal">OnChanges</code> lifecycle hook, we map the projects input to a list of objects that contain a <code class="literal">name</code> and <code class="literal">class</code> <a id="id457" class="indexterm"/>property, which will support us in rendering a simple legend. The <a id="id458" class="indexterm"/>template <code class="literal">`tasks-chart__series--series-${index + 1}`</code> string will generate the necessary class name to render the right color into our legend.</p><p>Using this legend information, we can now go ahead and implement the necessary template changes to render the legend in our <code class="literal">chart</code> component:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="tasks-chart__series-list"&gt;
<span class="strong"><strong>&lt;li *ngFor="let series of legend"</strong></span>
<span class="strong"><strong>class="tasks-chart__series {{series.class}}"&gt;</strong></span>
<span class="strong"><strong>    {{series.name}}</strong></span>
<span class="strong"><strong>&lt;/li&gt;</strong></span>
&lt;/ul&gt;
&lt;div #chartContainer class="tasks-chart__container"&gt;&lt;/div&gt;</pre></div><p>Well, that was a piece of cake, right? However, the result speaks for itself. We created a nice legend for the chart in just a couple of minutes:</p><div class="mediaobject"><img src="../Images/image00348.jpeg" alt="Creating a chart legend"/><div class="caption"><p>Open tasks chart with our added legend</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Making tasks chart interactive"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec70"/>Making tasks chart interactive</h2></div></div></div><p>Currently, we <a id="id459" class="indexterm"/>hardcoded the timeframe of our open task chart to be 144 frames, each of 10 minutes, making a total of 24 hours displayed to the user. However, maybe our users would want to change this view.</p><p>In this topic, we will create a simple input control using our <code class="literal">Toggle</code> component, which allows our users to change the timeframe settings of the chart.</p><p>We will provide the following views as options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Day:</strong></span> This view will rasterize 144 frames, each consisting of 10 minutes, which makes a total of 24 hours</li><li class="listitem"><span class="strong"><strong>Week:</strong></span> This view will rasterize 168 frames, each consisting of one hour, which makes a total of seven days</li><li class="listitem"><span class="strong"><strong>Year:</strong></span> This view will rasterize 360 frames, each representing a full day</li></ul></div><p>Let's start with the implementation of our timeframe switch by modifying the <code class="literal">Component</code> class code of the <code class="literal">TasksChart</code> component:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {Toggle} from '../../ui/toggle/toggle';</strong></span>

@Component({
  ...
<span class="strong"><strong>directives: [Toggle]</strong></span>
})
export class TasksChart {
  ...
constructor() {
    // Define the available time frames within the chart provided 
    // to the user for selection
<span class="strong"><strong>this.timeFrames = [{</strong></span>
<span class="strong"><strong>name: 'day',</strong></span>
<span class="strong"><strong>timeFrame: 600000,</strong></span>
<span class="strong"><strong>amount: 144</strong></span>
<span class="strong"><strong>    }, {</strong></span>
<span class="strong"><strong>name: 'week',</strong></span>
<span class="strong"><strong>timeFrame: 3600000,</strong></span>
<span class="strong"><strong>amount: 168</strong></span>
<span class="strong"><strong>    }, {</strong></span>
<span class="strong"><strong>name: 'year',</strong></span>
<span class="strong"><strong>timeFrame: 86400000,</strong></span>
<span class="strong"><strong>amount: 360</strong></span>
<span class="strong"><strong>    }];</strong></span>
    // From the available time frames, we're generating a list of 
    // names for later use within the Toggle component
<span class="strong"><strong>this.timeFrameNames</strong></span>
<span class="strong"><strong>      = this.timeFrames.map((timeFrame) =&gt; timeFrame.name);</strong></span>
    // The currently selected timeframe is set to the first 
    // available one
<span class="strong"><strong>this.selectedTimeFrame = this.timeFrames[0];</strong></span>
  }
  ...
createOrUpdateChart() {
    ...
const series = this.projects.map((project) =&gt; {
      ...
return rasterize(timeData, 
<span class="strong"><strong>this.selectedTimeFrame.timeFrame, </strong></span>
<span class="strong"><strong>this.selectedTimeFrame.amount, </strong></span>
                       +new Date(), null, true);
    });

const now = +new Date();
const labels = Array.from({
length: <span class="strong"><strong>this.selectedTimeFrame.amount</strong></span>
    }).map((e, index) =&gt; now - index * <span class="strong"><strong>this.selectedTimeFrame.timeFrame</strong></span>).reverse();
  ...
  }
  ...
  // Called from the Toggle component if a new timeframe was 
  // selected
<span class="strong"><strong>onSelectedTimeFrameChange(timeFrameName) {</strong></span>
    // Set the selected time frame to the available timeframe with 
    // the name selected in the Toggle component
<span class="strong"><strong>this.selectedTimeFrame = </strong></span>
<span class="strong"><strong>this.timeFrames.find((timeFrame) =&gt;</strong></span>
<span class="strong"><strong>timeFrame.name === timeFrameName);</strong></span>
this.createOrUpdateChart();
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Let's go through <a id="id460" class="indexterm"/>these changes briefly:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we added a constructor to our <code class="literal">Component</code> class in which we initialized three new members. The <code class="literal">timeFrames</code> member is set to an array of timeframe description objects. They contain the <code class="literal">name</code>, <code class="literal">timeFrame</code>, and <code class="literal">amount</code> properties, which are later used for the calculations. The <code class="literal">timeFrameNames</code> member contains a list of timeframe names, which is directly derived from the <code class="literal">timeFrames</code> list. Finally, we have a <code class="literal">selectedTimeFrame</code> member, which simply points to the first available timeframe object.</li><li class="listitem">In the <code class="literal">createOrUpdateChart</code> function, we no longer rely on hardcoded values for the task count rasterization, but we refer to the data in the <code class="literal">selectedTimeFrame</code> object. By changing this object reference and calling the <code class="literal">createOrUpdateChart</code> function again, we can now switch the view on the underlying data dynamically.</li><li class="listitem">Finally, we added a new <code class="literal">onSelectedTimeFrameChange</code> method, which acts as a binding to the <code class="literal">Toggle</code> component, and this will be called whenever the user selects a different timeframe.</li></ol><div style="height:10px; width: 1px"/></div><p>Let's look at the necessary template changes to enable switching of timeframes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;ngc-toggle </strong></span>
<span class="strong"><strong>      [buttonList]="timeFrameNames"</strong></span>
<span class="strong"><strong>      [selectedButton]="selectedTimeFrame.name"</strong></span>
<span class="strong"><strong>      (selectedButtonChange)="onSelectedTimeFrameChange($event)"&gt;</strong></span>
<span class="strong"><strong>&lt;/ngc-toggle&gt;</strong></span>
...
&lt;div #chartContainer class="tasks-chart__container"&gt;&lt;/div&gt;</pre></div><p>From the bindings to the <code class="literal">Toggle</code> component, you can already tell that we rely on the <code class="literal">timeFrameNames</code> member on our component to represent all selectable timeframes. We also bind to the <code class="literal">selectedButton</code> input property of the <code class="literal">Toggle</code> component using the <code class="literal">selectedTimeFrame.name</code> property. On changes of the selected button in the <code class="literal">Toggle</code> component, we call the <code class="literal">onSelectedTimeFrameChange</code> function, where the timeframe is switched and the chart is updated.</p><p>This is all that we need to enable switching the timeframe on our chart. The user can now choose between the year, week, and day views.</p><p>Our <code class="literal">TasksChart</code> component is now ready to be integrated into our dashboard. We can achieve this with some <a id="id461" class="indexterm"/>small changes to the template of our <code class="literal">ProjectsDashboard</code> component:</p><div class="informalexample"><pre class="programlisting">...
&lt;div class="projects-dashboard__l-main"&gt;
<span class="strong"><strong>&lt;h3 class="projects-dashboard__sub-title"&gt;Tasks Overview&lt;/h3&gt;</strong></span>
<span class="strong"><strong>&lt;div class="projects-dashboard__tasks"&gt;</strong></span>
<span class="strong"><strong>&lt;ngc-tasks-chart [projects]="projects | async"&gt;</strong></span>
<span class="strong"><strong>&lt;/ngc-tasks-chart&gt;</strong></span>
<span class="strong"><strong>&lt;/div&gt;</strong></span>
  ...
&lt;/div&gt;</pre></div><p>This is basically all that we need to make, and after this change, our dashboard contains our nice chart displaying open task counts over time.</p><p>In the binding of the <code class="literal">TasksChart</code> projects input property, we use the <code class="literal">async</code> pipe once again to resolve the observable stream of projects directly in the view.</p></div></div>
<div class="section" title="Summary" id="aid-1S2JE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we learned about Chartist and how to use it in conjunction with Angular to create good looking and functional charts. We can leverage the power of both worlds, and create reusable chart components that are nicely encapsulated.</p><p>Just like in most real cases, we always have a lot of data, but the one that we need in a particular case. We learned how we can transform existing data into a form that is optimized for visual representation.</p><p>In the next chapter, we will look at building a plugin system in our application. This will allow us to develop portable functionality that is packaged into plugins. Our plugin system will load new plugins dynamically, and we will use it to develop a simple agile estimation plugin.</p></div></body></html>