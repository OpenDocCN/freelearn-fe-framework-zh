<html><head></head><body>
<div id="_idContainer023">
<h1 class="chapter-number" id="_idParaDest-81"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-82"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.2.1">Fetching and Mutating Data</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Handling dynamic data is crucial in today's web development landscape. </span><span class="koboSpan" id="kobo.3.2">Most modern apps interact with data from various sources. </span><span class="koboSpan" id="kobo.3.3">The way an app manages loading states, errors, and data updates plays a big role in user experience. </span><span class="koboSpan" id="kobo.3.4">Fortunately, Remix offers a comprehensive solution for both retrieving and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">updating data.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Fetching data</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Mutating data</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will implement data reads and writes in BeeRich. </span><span class="koboSpan" id="kobo.9.2">First, we will practice data loading. </span><span class="koboSpan" id="kobo.9.3">Then, we will learn about data mutations in Remix and implement an expense </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">creation form.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">By the end of this chapter, you will know how to fetch and mutate data in Remix. </span><span class="koboSpan" id="kobo.11.2">You will also understand how Remix executes </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">loader</span></strong><span class="koboSpan" id="kobo.13.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">action</span></strong><span class="koboSpan" id="kobo.15.1"> functions and how Remix revalidates loader data after mutations. </span><span class="koboSpan" id="kobo.15.2">Finally, you will have practiced building applications with progressive enhancement in mind, which we will build upon in </span><a href="B17399_06.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.17.1">, </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Progressively Enhancing the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.19.1">User Experience</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">You can find the setup instructions for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">here: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Note that the code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">start</span></strong><span class="koboSpan" id="kobo.28.1"> folder of this chapter is different from our final solution from </span><a href="B17399_04.xhtml#_idTextAnchor057"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.29.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.30.1">, </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Routing in Remix</span></em><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">Read the instructions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">README.md</span></strong><span class="koboSpan" id="kobo.34.1"> file of this chapter’s folder on GitHub before </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">you continue.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.36.1">Fetching data</span></h1>
<p><span class="koboSpan" id="kobo.37.1">Before diving into this chapter, make sure you've followed the steps in the technical requirements section. </span><span class="koboSpan" id="kobo.37.2">Once </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.38.1">you've completed the setup guide, let's briefly revisit the key steps to prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">any issues:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.40.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">npm i</span></strong><span class="koboSpan" id="kobo.42.1"> to install </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">all dependencies.</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">If you are missing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">.env</span></strong><span class="koboSpan" id="kobo.46.1"> file in your project’s root, create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">.env</span></strong><span class="koboSpan" id="kobo.48.1"> file and add the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">to it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.50.1">
DATABASE_URL="file:./dev.db"</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.51.1">Prisma – our database toolkit of choice – uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">DATABASE_URL</span></strong><span class="koboSpan" id="kobo.53.1"> environment variable to connect to </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">our database.</span></span></p></li> <li><span class="koboSpan" id="kobo.55.1">Next, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">npm run build</span></strong><span class="koboSpan" id="kobo.57.1"> to generate the Prisma client for our data schema. </span><span class="koboSpan" id="kobo.57.2">Prisma reads our Prisma schema from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">prisma/schema.prisma</span></strong><span class="koboSpan" id="kobo.59.1"> file and generates types and functions for us to </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">work with.</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">npm run update:db</span></strong><span class="koboSpan" id="kobo.63.1"> to create or update the SQLite database. </span><span class="koboSpan" id="kobo.63.2">We use SQLite with Prisma to persist our </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">development data.</span></span></li>
<li><span class="koboSpan" id="kobo.65.1">Finally, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">npm run seed</span></strong><span class="koboSpan" id="kobo.67.1"> to seed our local database with mock data. </span><span class="koboSpan" id="kobo.67.2">You can find the mock script </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">prisma/seed.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.71.1">Our datatabase is set up, and we can now use Prisma to query the database. </span><span class="koboSpan" id="kobo.71.2">Next, let's add the code to fetch data from the database </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">to BeeRich.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.73.1">Fetching data at the route level</span></h2>
<p><span class="koboSpan" id="kobo.74.1">Let’s use Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">loader</span></strong><span class="koboSpan" id="kobo.76.1"> functions </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.77.1">and route-level data </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.78.1">fetching to query the database for </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">expense data:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.80.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">app/routes/dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.82.1"> file in </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.84.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">loader</span></strong><span class="koboSpan" id="kobo.86.1"> function to the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">route module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.88.1">
export async function loader() {  return {};}</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">loader</span></strong><span class="koboSpan" id="kobo.90.1"> functions are Remix’s HTTP </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">GET</span></strong><span class="koboSpan" id="kobo.92.1"> request handlers and work with request and response objects that follow the Fetch API’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">Request</span></strong><span class="koboSpan" id="kobo.94.1">–</span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">Response</span></strong><span class="koboSpan" id="kobo.96.1"> interface. </span><span class="koboSpan" id="kobo.96.2">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">loader</span></strong><span class="koboSpan" id="kobo.98.1"> functions are executed only on the server and must return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Response</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.100.1">object (</span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><span class="No-Break"><span class="koboSpan" id="kobo.101.1">https://developer.mozilla.org/en-US/docs/Web/API/Response</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.102.1">).</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.103.1">For now, we </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.104.1">return an empty JavaScript object. </span><span class="koboSpan" id="kobo.104.2">Remix </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.105.1">serializes the object for us (</span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">JSON.stringify</span></strong><span class="koboSpan" id="kobo.107.1">) and creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">Response</span></strong><span class="koboSpan" id="kobo.109.1"> object with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Content-Type</span></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">application/json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.113.1">Next, import our new </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">database client:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.115.1">
import { db } from '~/modules/db.server';</span></pre></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.116.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.117.1">You can find more information about our Prisma client setup in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">README.md</span></strong><span class="koboSpan" id="kobo.119.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">here: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md"><span class="No-Break"><span class="koboSpan" id="kobo.121.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.122.1">.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.123.1">Use the database client to query for all expenses and return the results array from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.126.1">
import { db } from '~/modules/db.server';export async function loader() {</span><strong class="bold"><span class="koboSpan" id="kobo.127.1">  const expenses = await db.expense.findMany({});</span></strong><strong class="bold"><span class="koboSpan" id="kobo.128.1">  return expenses;</span></strong><span class="koboSpan" id="kobo.129.1">}</span></pre></li> <li><span class="koboSpan" id="kobo.130.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">json</span></strong><span class="koboSpan" id="kobo.132.1"> helper function from Remix and pass the expenses array </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">to it:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.134.1">import { json } from '@remix-run/node';</span></strong><span class="koboSpan" id="kobo.135.1">import { db } from '~/modules/db.server';export async function loader() {  const expenses = await db.expense.findMany({});  return </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">json(expenses);</span></strong><span class="koboSpan" id="kobo.137.1">}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.138.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">json</span></strong><span class="koboSpan" id="kobo.140.1"> helper function </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.141.1">returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">Response</span></strong><span class="koboSpan" id="kobo.143.1"> object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Content-Type</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.145.1">application/json</span></strong><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">Using the helper function allows us to provide an </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">init</span></strong><span class="koboSpan" id="kobo.148.1"> object as the second argument to add HTTP headers, a status text, and a status code to </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">the response.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.150.1">This step is </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.151.1">optional as we don’t return any HTTP headers or cookies with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">Response</span></strong><span class="koboSpan" id="kobo.153.1"> object just yet. </span><span class="koboSpan" id="kobo.153.2">We’ll cover this in more detail later in </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">this book.</span></span></p></li> <li><span class="koboSpan" id="kobo.155.1">Update the database query to order the data </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">by date:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.157.1">
const expenses = await db.expense.findMany({</span><strong class="bold"><span class="koboSpan" id="kobo.158.1">  orderBy: {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.159.1">    createdAt: 'desc',</span></strong><strong class="bold"><span class="koboSpan" id="kobo.160.1">  },</span></strong><span class="koboSpan" id="kobo.161.1">});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.162.1">Note that we have complete control over what to query based on our frontend needs. </span><span class="koboSpan" id="kobo.162.2">Rather than sorting the expenses array on the client side, we can modify the database query in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">loader</span></strong><span class="koboSpan" id="kobo.164.1"> function. </span><span class="koboSpan" id="kobo.164.2">Performing as much logic as we can on the server minimizes the need for client-side state management. </span><span class="koboSpan" id="kobo.164.3">This is a best practice we should keep </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">in mind.</span></span></p></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.166.1">Move as much logic as possible to the server</span></p>
<p class="callout"><span class="koboSpan" id="kobo.167.1">We should try to move as much code as possible to the server-side </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">action</span></strong><span class="koboSpan" id="kobo.169.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> functions.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.172.1">Moving code to the server ensures that less code is shipped to the client. </span><span class="koboSpan" id="kobo.172.2">It also increases the amount of logic that works before JavaScript has fully loaded on the client. </span><span class="koboSpan" id="kobo.172.3">Finally, we make sure we decrease the complexity of our client-side application by moving the code to our fast and powerful server and </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">database runtimes.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.174.1">Thereafter, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">console.log</span></strong><span class="koboSpan" id="kobo.176.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">loader</span></strong><span class="koboSpan" id="kobo.178.1"> function so that we can track its execution on </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">the terminal.</span></span></li>
<li><span class="koboSpan" id="kobo.180.1">Run</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.181.1"> the app (</span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">npm run dev</span></strong><span class="koboSpan" id="kobo.183.1">) and open BeeRich in a </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">browser window.</span></span></li>
<li><span class="koboSpan" id="kobo.185.1">Finally, navigate </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.186.1">between different pages and check the server terminal for your </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">console.log</span></strong><span class="koboSpan" id="kobo.188.1"> message. </span><span class="koboSpan" id="kobo.188.2">Take note when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">loader</span></strong><span class="koboSpan" id="kobo.190.1"> function is executed. </span><span class="koboSpan" id="kobo.190.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">loader</span></strong><span class="koboSpan" id="kobo.192.1"> functions only run on the server, you will find the log statements in the terminal and not the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">browser console.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.194.1">Great! </span><span class="koboSpan" id="kobo.194.2">Whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">dashboard/expenses</span></strong><span class="koboSpan" id="kobo.196.1"> path is added to the URL, Remix calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.198.1"> route module’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.200.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Next, we need to figure out how to access the data in React. </span><span class="koboSpan" id="kobo.201.2">Luckily, this is as easy as it gets in Remix. </span></p>
<ol>
<li><span class="koboSpan" id="kobo.202.1">Again, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.204.1"> route module in </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.206.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.208.1"> hook </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">@remix-run/react</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.212.1">Next, call the hook in the route </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">module component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.214.1">
const expenses = useLoaderData();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.215.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.217.1"> hook to access the loader data </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">of the same route module</span></strong><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">It’s as easy as that; no prop drilling or other shenanigans </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">are required.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.221.1">Remix </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.222.1">executes </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">loader</span></strong><span class="koboSpan" id="kobo.224.1"> functions first and then </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.225.1">renders the React application on the server. </span><span class="koboSpan" id="kobo.225.2">In our React component, we access the fetched data without having to manage loading states. </span><span class="koboSpan" id="kobo.225.3">This allows us to eliminate a big chunk of boilerplate code that many React apps </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">suffer from.</span></span></p></li> <li><span class="koboSpan" id="kobo.227.1">So far, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">expenses</span></strong><span class="koboSpan" id="kobo.229.1"> variable in our route component is typed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">any</span></strong><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">This isn’t ideal. </span><span class="koboSpan" id="kobo.231.3">Luckily, we are using TypeScript for both our frontend and backend code. </span><span class="koboSpan" id="kobo.231.4">We are further co-locating client and server code in the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">app</span></strong><span class="koboSpan" id="kobo.233.1"> folder. </span><span class="koboSpan" id="kobo.233.2">This allows us to do powerful things, such as inferring the type of the loader data when </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">useLoaderData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.237.1">Pass the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">loader</span></strong><span class="koboSpan" id="kobo.239.1"> function to the generic slot </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">useLoaderData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.243.1">
const expenses = useLoaderData&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.244.1">typeof loader</span></strong><span class="koboSpan" id="kobo.245.1">&gt;();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.246.1">Now, inspect the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">expenses</span></strong><span class="koboSpan" id="kobo.248.1"> (that is, by hovering over the variable name in your editor). </span><span class="koboSpan" id="kobo.248.2">The variable is now typed as an expense object array that is wrapped </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">JsonifyObject&lt;{…}&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.252.1">Remix co-locates your client and server code in the same file. </span><span class="koboSpan" id="kobo.252.2">This allows us to infer the types of fetched data across the network (from server to client). </span><span class="koboSpan" id="kobo.252.3">However, since we work with </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Response</span></strong><span class="koboSpan" id="kobo.254.1"> objects in </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">loader</span></strong><span class="koboSpan" id="kobo.256.1"> functions, the returned data is serialized as JSON. </span><span class="koboSpan" id="kobo.256.2">This changes the shape of the data. </span><span class="koboSpan" id="kobo.256.3">For instance, JSON cannot manage </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">Date</span></strong><span class="koboSpan" id="kobo.258.1"> objects but serializes them </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">.</span></span></p><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">JsonifyObject</span></strong><span class="koboSpan" id="kobo.263.1"> is a helper type from Remix that ensures that the expense object is correctly typed after being serialized to JSON. </span><span class="koboSpan" id="kobo.263.2">We will return to that later; for now, we are happy that we can easily access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">loader</span></strong><span class="koboSpan" id="kobo.265.1"> data and have it </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">fully typed.</span></span></p></li> <li><span class="koboSpan" id="kobo.267.1">Let’s use the expense array to replace the hardcoded expense list. </span><span class="koboSpan" id="kobo.267.2">Loop over the expense </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.268.1">data to render the list </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">of expenses:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.270.1">
&lt;ul className="flex flex-col"&gt;  {</span><strong class="bold"><span class="koboSpan" id="kobo.271.1">expenses.map((expense) =&gt;</span></strong><span class="koboSpan" id="kobo.272.1"> (    &lt;ListLinkItem key={expense.id} to={</span><strong class="bold"><span class="koboSpan" id="kobo.273.1">`/dashboard/expenses/${expense.id}`</span></strong><span class="koboSpan" id="kobo.274.1">}&gt;      &lt;p&gt;        &lt;i&gt;{new Date(</span><strong class="bold"><span class="koboSpan" id="kobo.275.1">expense.createdAt</span></strong><span class="koboSpan" id="kobo.276.1">).toLocaleDateString('en-US')}&lt;/i&gt;      &lt;/p&gt;      &lt;p className="text-xl font-semibold"&gt;{</span><strong class="bold"><span class="koboSpan" id="kobo.277.1">expense.title</span></strong><span class="koboSpan" id="kobo.278.1">}&lt;/p&gt;      &lt;p&gt;        &lt;b&gt;          {Intl.NumberFormat('en-US', { style: 'currency', currency: </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">expense.currencyCode</span></strong><span class="koboSpan" id="kobo.280.1"> }).format(            </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">expense.amount</span></strong><span class="koboSpan" id="kobo.282.1">,          )}        &lt;/b&gt;      &lt;/p&gt;    &lt;/ListLinkItem&gt;  ))}&lt;/ul&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.283.1">Notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">createdAt</span></strong><span class="koboSpan" id="kobo.285.1"> property is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">string</span></strong><span class="koboSpan" id="kobo.287.1"> type. </span><span class="koboSpan" id="kobo.287.2">We turn it into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">Date</span></strong><span class="koboSpan" id="kobo.289.1"> object </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.290.1">by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">new Date(expense.createdAt)</span></strong><span class="koboSpan" id="kobo.292.1">. </span><span class="koboSpan" id="kobo.292.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">loader</span></strong><span class="koboSpan" id="kobo.294.1"> function, the expenses array carries </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">createdAt</span></strong><span class="koboSpan" id="kobo.296.1"> properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Date</span></strong><span class="koboSpan" id="kobo.298.1"> type. </span><span class="koboSpan" id="kobo.298.2">On the client, we need to deserialize the data as it was parsed </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">to JSON.</span></span></p></li> <li><span class="koboSpan" id="kobo.300.1">Finally, run the application and visit the expense overview page. </span><span class="koboSpan" id="kobo.300.2">You should be able to view a list of expenses from the </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">seed data.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.302.1">Amazing! </span><span class="koboSpan" id="kobo.302.2">We utilize a server-side </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">loader</span></strong><span class="koboSpan" id="kobo.304.1"> function to fetch data, and then we access the data in React to render our page. </span><span class="koboSpan" id="kobo.304.2">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">loader</span></strong><span class="koboSpan" id="kobo.306.1"> function allows us to co-locate server-side data loading and data rendering in the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">same file.</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.308.1">Note that </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.309.1">data fetching in Remix happens in </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">loader</span></strong><span class="koboSpan" id="kobo.311.1"> functions</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.312.1"> at the route level. </span><span class="koboSpan" id="kobo.312.2">Route-level data fetching offers many advantages by giving up some of the flexibility of fetching </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">from components.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Component-based data loading is susceptible to blocking requests, which may lead to fetch waterfalls. </span><span class="koboSpan" id="kobo.314.2">A component that fetches data often defers rendering its child components until the data is loaded. </span><span class="koboSpan" id="kobo.314.3">This blocks the children from kicking off their own fetch requests, effectively creating a waterfall of </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">fetch requests.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">Imagine a component that renders the layout of the page. </span><span class="koboSpan" id="kobo.316.2">First, it fetches the user object and displays a big loading spinner until the user data has been fetched. </span><span class="koboSpan" id="kobo.316.3">After the user data has been fetched, the page is rendered. </span><span class="koboSpan" id="kobo.316.4">Nested components now fetch their own data. </span><span class="koboSpan" id="kobo.316.5">The user fetch request blocked these requests. </span><span class="koboSpan" id="kobo.316.6">This behavior may repeat itself several times in nested subtrees of </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">an app.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.318.1">Remix promotes route-level data fetching</span></p>
<p class="callout"><span class="koboSpan" id="kobo.319.1">In Remix, we aim to fetch data in route modules instead of components. </span><span class="koboSpan" id="kobo.319.2">By avoiding granular data fetching at the component level, we aim to optimize data loading and prevent fetch waterfalls. </span><span class="koboSpan" id="kobo.319.3">We should remember this as a </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">best practice.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">Note that route-level data fetching does not imply that you can only access the data at the route level. </span><span class="koboSpan" id="kobo.321.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.323.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">useRouteLoaderData</span></strong><span class="koboSpan" id="kobo.325.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">useMatches</span></strong><span class="koboSpan" id="kobo.327.1"> hooks in any custom hook or component of your application to access </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">loader data.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">useRouteLoaderData</span></strong><span class="koboSpan" id="kobo.331.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">useMatches</span></strong><span class="koboSpan" id="kobo.333.1"> hooks are used to access data from any currently active route – compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.335.1">, which returns the data of the </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.336.1">route module that the hook is called in. </span><span class="koboSpan" id="kobo.336.2">Refer to the Remix documentation for more </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">information: </span></span><a href="https://remix.run/docs/en/2/hooks/use-route-loader-data"><span class="No-Break"><span class="koboSpan" id="kobo.338.1">https://remix.run/docs/en/2/hooks/use-route-loader-data</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.339.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">As always, make </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.341.1">sure to implement the same functionality for the income routes. </span><span class="koboSpan" id="kobo.341.2">This ensures you revisit the concepts introduced in this section before </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">moving on.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">Next, let’s have a look at how we can fetch data based on dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">route parameters.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.345.1">Fetching dynamic data in parameterized routes</span></h2>
<p><span class="koboSpan" id="kobo.346.1">Now that </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.347.1">we’ve updated the expenses overview page, you might have noticed that this broke our hardcoded expense details route. </span><span class="koboSpan" id="kobo.347.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">fix that.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">You may remember from </span><a href="B17399_04.xhtml#_idTextAnchor057"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.350.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.351.1">, </span><em class="italic"><span class="koboSpan" id="kobo.352.1">Routing in Remix</span></em><span class="koboSpan" id="kobo.353.1">, that we designed the expense details page as a nested route that renders within the expenses overview page. </span><span class="koboSpan" id="kobo.353.2">It is also a parameterized route that uses a dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">route parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Let’s update the code so that it queries the requested expense from the database based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">route parameter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.357.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">/app/routes/dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.359.1"> file in your editor. </span><span class="koboSpan" id="kobo.359.2">We’re already using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">loader</span></strong><span class="koboSpan" id="kobo.361.1"> function to render our </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">mock data.</span></span></li>
<li><span class="koboSpan" id="kobo.363.1">Delete the mock data array from </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the file.</span></span></li>
<li><span class="koboSpan" id="kobo.365.1">Next, update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">loader</span></strong><span class="koboSpan" id="kobo.367.1"> function to query the database and find a unique expense object with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">id</span></strong><span class="koboSpan" id="kobo.369.1"> parameter that we access from </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">the URL:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.371.1">import { db } from '~/modules/db.server';</span></strong><span class="koboSpan" id="kobo.372.1">export </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">async</span></strong><span class="koboSpan" id="kobo.374.1"> function loader({ params }: LoaderFunctionArgs) {  const { id } = params;  const expense = </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">await db.expense.findUnique({ where: { id } });</span></strong><span class="koboSpan" id="kobo.376.1">  if (!expense) throw new Response('Not found', { status: 404 });  return json(expense);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.377.1">We now call our database to dynamically query for the </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">correct expense.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.379.1">Note that we still throw a </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">404 Response</span></strong><span class="koboSpan" id="kobo.381.1"> if we cannot find an expense that matches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">id</span></strong><span class="koboSpan" id="kobo.383.1"> parameter. </span><span class="koboSpan" id="kobo.383.2">This is a great way to stop further executions and show the user that something </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">went wrong.</span></span></p></li> <li><span class="koboSpan" id="kobo.385.1">Run BeeRich by executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">npm run dev</span></strong><span class="koboSpan" id="kobo.387.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">a terminal.</span></span></li>
<li><span class="koboSpan" id="kobo.389.1">Open a browser window and navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">to </span></span><a href="http://localhost:3000/dashboard/expenses/"><span class="No-Break"><span class="koboSpan" id="kobo.391.1">http://localhost:3000/dashboard/expenses/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.392.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.393.1">Click on one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">listed expenses.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.395.1">Notice that the URL changes to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">id</span></strong><span class="koboSpan" id="kobo.397.1"> parameter of the expense. </span><span class="koboSpan" id="kobo.397.2">Remix executes a client-side navigation (when JS is available) to update </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the URL.</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.399.1">Remix </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.400.1">executes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">loader</span></strong><span class="koboSpan" id="kobo.402.1"> function when we navigate to the associated route segment. </span><span class="koboSpan" id="kobo.402.2">On every page navigation, Remix fetches the loader data of each new route module that matches the newly requested page. </span><span class="koboSpan" id="kobo.402.3">If we navigate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">/login</span></strong><span class="koboSpan" id="kobo.404.1">, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">loader</span></strong><span class="koboSpan" id="kobo.406.1"> functions of all </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">newly matching routes</span></strong><span class="koboSpan" id="kobo.408.1"> are executed. </span><span class="koboSpan" id="kobo.408.2">This may include the following route modules (from root </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">to leaf):</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">root.tsx</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">routes/_layout.tsx</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">routes/_layout.login.tsx</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.413.1">If we further navigate from </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">/login</span></strong><span class="koboSpan" id="kobo.415.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">/signup</span></strong><span class="koboSpan" id="kobo.417.1">, then only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">_layout.signup.tsx</span></strong><span class="koboSpan" id="kobo.419.1"> route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">loader</span></strong><span class="koboSpan" id="kobo.421.1"> function is executed as it’s the only route segment that wasn’t already </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">active before.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">Let’s visualize what’s going on by reviewing the </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">Network</span></strong><span class="koboSpan" id="kobo.425.1"> tab in the developer tools of the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">browser window:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.427.1">Open the developer tools in the browser window that runs </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">your app.</span></span></li>
<li><span class="koboSpan" id="kobo.429.1">Open the </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">Network</span></strong><span class="koboSpan" id="kobo.431.1"> tab of the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">developer tools.</span></span></li>
<li><span class="koboSpan" id="kobo.433.1">Filter by </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">Fetch/XHR</span></strong><span class="koboSpan" id="kobo.435.1"> network requests. </span><span class="koboSpan" id="kobo.435.2">This is optional but helps you find all fetch requests made to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> functions.</span></span></li>
<li><span class="koboSpan" id="kobo.438.1">Now, change the URL in the URL bar to </span><a href="http://localhost:3000/dashboard/expenses/"><span class="koboSpan" id="kobo.439.1">http://localhost:3000/dashboard/expenses/</span></a><span class="koboSpan" id="kobo.440.1"> and reload the </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">browser window.</span></span></li>
<li><span class="koboSpan" id="kobo.442.1">You should see no fetch requests in the </span><strong class="bold"><span class="koboSpan" id="kobo.443.1">Network</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.444.1">tab yet.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.445.1">This is because Remix initially server renders your application. </span><span class="koboSpan" id="kobo.445.2">Your </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.447.1"> route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">loader</span></strong><span class="koboSpan" id="kobo.449.1"> function is executed, and the data is used to render the HTML on </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">the server.</span></span></p></li>
<li><span class="koboSpan" id="kobo.451.1">Next, click on any of the expenses in the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">expenses list.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.453.1">Remix </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.454.1">is now running client-side. </span><span class="koboSpan" id="kobo.454.2">After hydration, the client-side Remix app takes over the routing of our application. </span><span class="koboSpan" id="kobo.454.3">This allows us to avoid full-page requests, which would require more network bandwidth and increase </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">response times.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.456.1">Since we are using Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Link</span></strong><span class="koboSpan" id="kobo.458.1"> component, Remix can intercept page transitions. </span><span class="koboSpan" id="kobo.458.2">Remix prevents the browser’s default behavior (full-page reload) if JavaScript is loaded. </span><span class="koboSpan" id="kobo.458.3">Instead, it emulates the behavior by making fetch requests to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">loader</span></strong><span class="koboSpan" id="kobo.460.1"> functions to fetch the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">required data.</span></span></p></li>
<li><span class="koboSpan" id="kobo.462.1">Inspect the request in the </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">Network</span></strong><span class="koboSpan" id="kobo.464.1"> tab. </span><span class="koboSpan" id="kobo.464.2">The navigation to </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">/dashboard/expenses/$id</span></strong><span class="koboSpan" id="kobo.466.1"> invokes a fetch request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.468.1"> route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">loader</span></strong><span class="koboSpan" id="kobo.470.1"> function, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.471.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.472.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">:</span></span></li>
</ol>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.474.1"><img alt="Figure 5.1 – Screenshot of the fetched loader data after a route transition" src="image/Figure_5.01_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.475.1">Figure 5.1 – Screenshot of the fetched loader data after a route transition</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.476.1">As visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.477.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.478.1">.1</span></em><span class="koboSpan" id="kobo.479.1">, Remix executes a fetch request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">loader</span></strong><span class="koboSpan" id="kobo.481.1"> function, which then returns the expense object </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">as JSON.</span></span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.483.1">Click on </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.484.1">another expense. </span><span class="koboSpan" id="kobo.484.2">Notice that Remix repeats the behavior for each navigation to an expense details route. </span><span class="koboSpan" id="kobo.484.3">Every time we click on a new expense, the URL changes, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">loader</span></strong><span class="koboSpan" id="kobo.486.1"> function of the details page is called again with the next </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">$id</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.488.1">route parameter.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.489.1">Notice that Remix never re-fetches the expenses array for the overview page. </span><span class="koboSpan" id="kobo.489.2">That is because we remain on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.491.1"> route segment. </span><strong class="bold"><span class="koboSpan" id="kobo.492.1">Remix only loads data for newly matching </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.493.1">route segments.</span></strong></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.494.1">Great! </span><span class="koboSpan" id="kobo.494.2">We </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.495.1">are now able to fetch dynamic data with parameterized routes. </span><span class="koboSpan" id="kobo.495.2">Note that Remix only fetches data for newly matching route segments. </span><span class="koboSpan" id="kobo.495.3">This avoids unnecessary requests. </span><span class="koboSpan" id="kobo.495.4">We also learned that Remix fetches from </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">loader</span></strong><span class="koboSpan" id="kobo.497.1"> functions during server-side rendering and client-side navigations. </span><span class="koboSpan" id="kobo.497.2">Remix handles data loading on a per-route level on both sides of </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">the network.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.499.1">Remix is both a frontend and a backend framework</span></p>
<p class="callout"><span class="koboSpan" id="kobo.500.1">Remix calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">loader</span></strong><span class="koboSpan" id="kobo.502.1"> functions on the initial request on the server before rendering React server-side. </span><span class="koboSpan" id="kobo.502.2">On the client, Remix fetches loader data on client-side navigations with AJAX requests (</span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">fetch requests).</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">Revisit the concepts introduced in this section by updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">dashboard.income.$id.tsx</span></strong><span class="koboSpan" id="kobo.506.1"> route module so that it matches </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">Make sure you test your implementation before moving on. </span><span class="koboSpan" id="kobo.508.3">Inspect which </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">loader</span></strong><span class="koboSpan" id="kobo.510.1"> functions are executed when switching between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">/income</span></strong><span class="koboSpan" id="kobo.512.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">/expenses</span></strong><span class="koboSpan" id="kobo.514.1"> routes by using the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.515.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.516.1"> tab.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">Next, let’s see how </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">loader</span></strong><span class="koboSpan" id="kobo.519.1"> functions are called in parallel. </span><span class="koboSpan" id="kobo.519.2">For this, we need to adapt our application logic </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">a bit.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.521.1">Loading data in parallel</span></h2>
<p><span class="koboSpan" id="kobo.522.1">As </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.523.1">visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.524.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.525.1">.2</span></em><span class="koboSpan" id="kobo.526.1">, the expense overview page has two sections – the list of all expenses (</span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.528.1">) and the details view of the currently selected expense (</span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.530.1">). </span><span class="koboSpan" id="kobo.530.2">The details view is empty when navigating to </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">/dashboard/expenses</span></strong><span class="koboSpan" id="kobo.532.1"> since the nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">$id</span></strong><span class="koboSpan" id="kobo.534.1"> route module does not appear on </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">the screen:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.536.1"><img alt="Figure 5.2 – Screenshot of the expenses route with a nested $id route module" src="image/Figure_5.02_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.537.1">Figure 5.2 – Screenshot of the expenses route with a nested $id route module</span></p>
<p><span class="koboSpan" id="kobo.538.1">Let’s update</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.539.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">Expenses</span></strong><span class="koboSpan" id="kobo.541.1"> navigation link on the dashboard’s navigation bar (highlighted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.542.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.543.1">.2</span></em><span class="koboSpan" id="kobo.544.1">). </span><span class="koboSpan" id="kobo.544.2">Currently, the </span><strong class="bold"><span class="koboSpan" id="kobo.545.1">Expenses</span></strong><span class="koboSpan" id="kobo.546.1"> link points to </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">/dashboard/expenses</span></strong><span class="koboSpan" id="kobo.548.1">. </span><span class="koboSpan" id="kobo.548.2">We will update this link so that it points to the most recently created </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">expense instead:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.550.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">dashboard.tsx</span></strong><span class="koboSpan" id="kobo.552.1"> route module in </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.554.1">Add the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">loader</span></strong><span class="koboSpan" id="kobo.556.1"> function to the </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">route module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.558.1">
import { json } from '@remix-run/node';import { db } from '~/modules/db.server';export async function loader() {  const firstExpense = await db.expense.findFirst({    orderBy: { createdAt: 'desc' },  });  return json({ firstExpense });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.559.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">loader</span></strong><span class="koboSpan" id="kobo.561.1"> function queries the database for the most recently created expense. </span><span class="koboSpan" id="kobo.561.2">It then returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">queried </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">firstExpense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.565.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">firstExpense</span></strong><span class="koboSpan" id="kobo.567.1"> can also be </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">null</span></strong><span class="koboSpan" id="kobo.569.1"> if the database has no </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">expense entries.</span></span></p></li> <li><span class="koboSpan" id="kobo.571.1">Next, access </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.572.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">firstExpense</span></strong><span class="koboSpan" id="kobo.574.1"> object using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">useLoaderData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.576.1"> hook:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.577.1">
const { firstExpense } = useLoaderData&lt;typeof loader&gt;();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.578.1">We type the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.580.1"> hook with the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">loader</span></strong><span class="koboSpan" id="kobo.582.1"> function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">firstExpense</span></strong><span class="koboSpan" id="kobo.584.1"> is now correctly typed as the serialized version of an expense object </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.588.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">firstExpense</span></strong><span class="koboSpan" id="kobo.590.1"> to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">to</span></strong><span class="koboSpan" id="kobo.592.1"> property of the </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">Expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.594.1">NavLink</span></strong><span class="koboSpan" id="kobo.595.1">. </span><span class="koboSpan" id="kobo.595.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">firstExpense</span></strong><span class="koboSpan" id="kobo.597.1"> can be </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">null</span></strong><span class="koboSpan" id="kobo.599.1">, we must ensure we make this </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">change conditionally:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
&lt;li className="mr-auto"&gt;  &lt;NavLink    to=</span><strong class="bold"><span class="koboSpan" id="kobo.602.1">{firstExpense ? </span><span class="koboSpan" id="kobo.602.2">`/dashboard/expenses/${firstExpense.id}` : '/dashboard/expenses'}</span></strong><span class="koboSpan" id="kobo.603.1">  &gt;    Expenses  &lt;/NavLink&gt;&lt;/li&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.604.1">Great! </span><span class="koboSpan" id="kobo.604.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">Expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.606.1">NavLink</span></strong><span class="koboSpan" id="kobo.607.1"> component now navigates the user to the most recently </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">created expense.</span></span></p></li> <li><span class="koboSpan" id="kobo.609.1">Run BeeRich by executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">npm run dev</span></strong><span class="koboSpan" id="kobo.611.1"> and open the expenses overview page in a browser </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">window: </span></span><a href="http://localhost:3000/dashboard/expenses"><span class="No-Break"><span class="koboSpan" id="kobo.613.1">http://localhost:3000/dashboard/expenses</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.614.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.615.1">Notice that the </span><strong class="bold"><span class="koboSpan" id="kobo.616.1">Expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.617.1">NavLink</span></strong><span class="koboSpan" id="kobo.618.1"> component lost its active styling. </span><span class="koboSpan" id="kobo.618.2">This is because the link now points to a nested route, which does not trigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">isActive</span></strong><span class="koboSpan" id="kobo.620.1"> condition on Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">NavLink</span></strong><span class="koboSpan" id="kobo.622.1"> component. </span><span class="koboSpan" id="kobo.622.2">Luckily, our custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">NavLink</span></strong><span class="koboSpan" id="kobo.624.1"> component offers a </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">styleAsActive</span></strong><span class="koboSpan" id="kobo.626.1"> prop, which can be used to apply the </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.627.1">active styling whenever </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">we want.</span></span></p></li>
<li><span class="koboSpan" id="kobo.629.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">useLocation</span></strong><span class="koboSpan" id="kobo.631.1"> hook </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">@remix-run/react</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.635.1">Next, call the hook in the route </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">module component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.637.1">
const location = useLocation();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.638.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">useLocation</span></strong><span class="koboSpan" id="kobo.640.1"> hook lets us access a global location object with information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">current URL.</span></span></p></li> <li><span class="koboSpan" id="kobo.642.1">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">styleAsActive</span></strong><span class="koboSpan" id="kobo.644.1"> prop to the </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">Expenses</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.646.1">NavLink</span></strong><span class="koboSpan" id="kobo.647.1">. </span><span class="koboSpan" id="kobo.647.2">Set the property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">true</span></strong><span class="koboSpan" id="kobo.649.1"> whenever the user is on an </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.652.1"> route:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.653.1">
&lt;NavLink  to={firstExpense ? </span><span class="koboSpan" id="kobo.653.2">`/dashboard/expenses/${firstExpense.id}` : '/dashboard/expenses'}  </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">styleAsActive={location.pathname.startsWith('/dashboard/expenses')}</span></strong><span class="koboSpan" id="kobo.655.1">&gt;  Expenses&lt;/NavLink&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.656.1">With that, we’ve restored the active styling on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">dashboard/expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1"> route.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.660.1">With these changes in place, let’s learn about parallel </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">data fetching.</span></span></p></li> <li><span class="koboSpan" id="kobo.662.1">Visit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">/dashboard/income</span></strong><span class="koboSpan" id="kobo.664.1"> page in a browser window and clear the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.665.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.666.1"> tab.</span></span></li>
<li><span class="koboSpan" id="kobo.667.1">Now, navigate </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.668.1">to the details page of the most recently created expense by clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">Expenses</span></strong><span class="koboSpan" id="kobo.670.1"> navigation </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">menu link.</span></span></li>
<li><span class="koboSpan" id="kobo.672.1">As visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.673.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.674.1">.3</span></em><span class="koboSpan" id="kobo.675.1">, you should now see two fetch requests in the </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">Network</span></strong><span class="koboSpan" id="kobo.677.1"> tab. </span><span class="koboSpan" id="kobo.677.2">The requests are made to the two </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.679.1"> functions:</span></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">dashboard.expenses.tsx</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">dashboard.expenses.$id.tsx</span></strong></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.682.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">loader</span></strong><span class="koboSpan" id="kobo.684.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">dashboard.tsx</span></strong><span class="koboSpan" id="kobo.686.1"> is not executed as the route module was already active on the page before </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">the navigation:</span></span></p></li>
</ol>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.688.1"><img alt="Figure 5.3 – Inspecting the fetch request waterfall" src="image/Figure_5.03_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.689.1">Figure 5.3 – Inspecting the fetch request waterfall</span></p>
<p><span class="koboSpan" id="kobo.690.1">As visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.691.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.692.1">.3</span></em><span class="koboSpan" id="kobo.693.1">, we </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.694.1">can inspect the waterfall of the fetch requests in the </span><strong class="bold"><span class="koboSpan" id="kobo.695.1">Network</span></strong><span class="koboSpan" id="kobo.696.1"> tab. </span><span class="koboSpan" id="kobo.696.2">The green bar indicates the server execution time for the request. </span><span class="koboSpan" id="kobo.696.3">Note that both fetch requests are executed in parallel. </span><span class="koboSpan" id="kobo.696.4">This flattens the request waterfall and improves the </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">response time.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">You might have noticed that we query the database again in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">loader</span></strong><span class="koboSpan" id="kobo.700.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.702.1">. </span><span class="koboSpan" id="kobo.702.2">You might have asked yourself why we are not reusing the loader data from </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.704.1"> as we already fetch all expenses from the database. </span><span class="koboSpan" id="kobo.704.2">This is a trade-off for the parallel execution of </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">loader</span></strong><span class="koboSpan" id="kobo.706.1"> functions. </span><span class="koboSpan" id="kobo.706.2">Several </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.707.1">loaders cannot depend on each other’s data as they are all executed </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">in parallel.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">Let’s summarize </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">our observations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.711.1">On initial request, Remix renders our app on </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">the server.</span></span></li>
<li><span class="koboSpan" id="kobo.713.1">All active </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">loader</span></strong><span class="koboSpan" id="kobo.715.1"> functions are executed in parallel and passed to the React app during </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">server-side rendering.</span></span></li>
<li><span class="koboSpan" id="kobo.717.1">With loaders, we fetch application data on a </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">per-route level.</span></span></li>
<li><span class="koboSpan" id="kobo.719.1">Remix emulates the browser’s default behavior with JavaScript. </span><span class="koboSpan" id="kobo.719.2">All subsequent page navigations execute client-side if JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">has loaded.</span></span></li>
<li><span class="koboSpan" id="kobo.721.1">Remix uses fetch requests to load all required loader data </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">on navigation.</span></span></li>
<li><span class="koboSpan" id="kobo.723.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">loader</span></strong><span class="koboSpan" id="kobo.725.1"> functions of all newly matching route segments are executed </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">in parallel.</span></span></li>
<li><span class="koboSpan" id="kobo.727.1">Already active </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">loader</span></strong><span class="koboSpan" id="kobo.729.1"> functions are not </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">executed again.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.731.1">Practice what you’ve learned in this section by implementing the same functionality on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">/income</span></strong><span class="koboSpan" id="kobo.733.1"> routes. </span><span class="koboSpan" id="kobo.733.2">Query for the most recently created invoice in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">dashboard.tsx</span></strong><span class="koboSpan" id="kobo.735.1"> route module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">loader</span></strong><span class="koboSpan" id="kobo.737.1"> function. </span><span class="koboSpan" id="kobo.737.2">Then, update the </span><strong class="bold"><span class="koboSpan" id="kobo.738.1">Income</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.739.1">NavLink</span></strong><span class="koboSpan" id="kobo.740.1"> component. </span><span class="koboSpan" id="kobo.740.2">Finally, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">useLocation</span></strong><span class="koboSpan" id="kobo.742.1"> hook to add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">styleAsActive</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.744.1"> prop.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">Next, let’s see whether we can optimize the code </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">a bit:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.747.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">app/routes/dashboard.tsx</span></strong><span class="koboSpan" id="kobo.749.1"> file in </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">your editor.</span></span></li>
<li><span class="koboSpan" id="kobo.751.1">After adding the invoice query to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">loader</span></strong><span class="koboSpan" id="kobo.753.1"> function, the function may look </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.755.1">
export async function loader() {  const firstExpense = await db.expense.findFirst({    orderBy: { createdAt: 'desc' },  });</span><strong class="bold"><span class="koboSpan" id="kobo.756.1">  const firstInvoice = await db.invoice.findFirst({</span></strong><strong class="bold"><span class="koboSpan" id="kobo.757.1">    orderBy: { createdAt: 'desc' },</span></strong><strong class="bold"><span class="koboSpan" id="kobo.758.1">  });</span></strong><span class="koboSpan" id="kobo.759.1">  return json({ firstExpense, </span><strong class="bold"><span class="koboSpan" id="kobo.760.1">firstInvoice</span></strong><span class="koboSpan" id="kobo.761.1"> });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.762.1">This naïve implementation awaits the invoice query after executing the expense query. </span><span class="koboSpan" id="kobo.762.2">Whenever </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.763.1">independent queries are executed in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">loader</span></strong><span class="koboSpan" id="kobo.765.1"> function, we have the opportunity to execute the queries in parallel to reduce the </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">response time.</span></span></p></li> <li><span class="koboSpan" id="kobo.767.1">Refactor the code so that it executes the two queries </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">in parallel:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.769.1">
export async function loader() {  const </span><strong class="bold"><span class="koboSpan" id="kobo.770.1">expenseQuery</span></strong><span class="koboSpan" id="kobo.771.1"> = db.expense.findFirst({    orderBy: { createdAt: 'desc' },  });  const </span><strong class="bold"><span class="koboSpan" id="kobo.772.1">invoiceQuery</span></strong><span class="koboSpan" id="kobo.773.1"> = db.invoice.findFirst({    orderBy: { createdAt: 'desc' },  });  </span><strong class="bold"><span class="koboSpan" id="kobo.774.1">const [firstExpense, firstInvoice] = await Promise.all([expenseQuery, invoiceQuery]);</span></strong><span class="koboSpan" id="kobo.775.1">  return json({ firstExpense, firstInvoice });}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.776.1">Instead of awaiting both queries after each other, we can pass both query promises to </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">Promise.all</span></strong><span class="koboSpan" id="kobo.778.1"> to execute them </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">in parallel.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.780.1">In this section, we went over data fetching in Remix. </span><span class="koboSpan" id="kobo.780.2">You learned how to use and type the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.782.1"> hook and how to query data based on dynamic route parameters. </span><span class="koboSpan" id="kobo.782.2">You now know that Remix promotes data fetching at the route module level. </span><span class="koboSpan" id="kobo.782.3">This allows us to execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">loader</span></strong><span class="koboSpan" id="kobo.784.1"> functions in parallel and avoid request waterfalls. </span><span class="koboSpan" id="kobo.784.2">You </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.785.1">further understand the importance of moving as much logic as possible to the server to reduce the size and complexity of the client bundle. </span><span class="koboSpan" id="kobo.785.2">Finally, you practiced optimizing </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">loader</span></strong><span class="koboSpan" id="kobo.787.1"> functions to make independent requests in parallel. </span><span class="koboSpan" id="kobo.787.2">Next, we’ll learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">data mutations.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.789.1">Mutating data</span></h1>
<p><span class="koboSpan" id="kobo.790.1">Creating and </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.791.1">updating data is just as important as fetching data. </span><span class="koboSpan" id="kobo.791.2">In this section, we will add an expense creation form and learn how to mutate data </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">in Remix.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.793.1">Mutating data without JavaScript</span></h2>
<p><span class="koboSpan" id="kobo.794.1">Remember</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.795.1"> the three-step process for building web UIs from Ryan Florence that we discussed in </span><a href="B17399_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.796.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.797.1">? </span><span class="koboSpan" id="kobo.797.2">The first step is to make the user experience work without JavaScript. </span><span class="koboSpan" id="kobo.797.3">After that, we add JavaScript to enhance the experience but ensure that the baseline implementation </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.798.1">still works. </span><span class="koboSpan" id="kobo.798.2">This process is called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.799.1">progressive enhancement</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.801.1">In this section, we use Remix's </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">action</span></strong><span class="koboSpan" id="kobo.803.1"> function to handle incoming form submissions on the server. </span><span class="koboSpan" id="kobo.803.2">In the `action` function, we will validate the user data and write the new expense object to the database. </span><span class="koboSpan" id="kobo.803.3">Let's see how we can use the native form element to submit user data, without the need for </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">client-side JavaScript:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.805.1">First, create a new route module for the expense creation </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">form: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">app/routes/dashboard.expenses._index.tsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.809.1">We add the expense creation form to the index route of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">/dashboard/expenses/</span></strong><span class="koboSpan" id="kobo.811.1"> path. </span><span class="koboSpan" id="kobo.811.2">This leads to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">route hierarchy:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">/dashboard/expenses/</span></strong><span class="koboSpan" id="kobo.814.1">: Shows the expenses list and the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">creation form</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">/dashboard/expenses/$id</span></strong><span class="koboSpan" id="kobo.817.1">: Shows the expenses list and the expense details for the expense with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.819.1"> identifier</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.820.1">Add a route component to </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">dashboard.expenses._index.tsx</span></strong><span class="koboSpan" id="kobo.822.1"> that contains an HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">form element:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.824.1">
export default function Component() {  return (    &lt;form </span><strong class="bold"><span class="koboSpan" id="kobo.825.1">method="POST"</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.826.1">action="/dashboard/expenses/?index"</span></strong><span class="koboSpan" id="kobo.827.1">&gt;    &lt;/form&gt;  );}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.828.1">The HTML </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.829.1">form element allows us to set </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">method</span></strong><span class="koboSpan" id="kobo.831.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">action</span></strong><span class="koboSpan" id="kobo.833.1"> attributes. </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">method</span></strong><span class="koboSpan" id="kobo.835.1"> defines the submission method (</span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">POST</span></strong><span class="koboSpan" id="kobo.837.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">GET</span></strong><span class="koboSpan" id="kobo.839.1">), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">action</span></strong><span class="koboSpan" id="kobo.841.1"> sets the path name for </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">the submission.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.843.1">We set the method to </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">POST</span></strong><span class="koboSpan" id="kobo.845.1"> as we are </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">mutating data.</span></span></p></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.847.1">POST to mutate, GET to load</span></p>
<p class="callout"><span class="koboSpan" id="kobo.848.1">HTML forms use the HTTP verbs </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">POST</span></strong><span class="koboSpan" id="kobo.850.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">GET</span></strong><span class="koboSpan" id="kobo.852.1"> for submissions. </span><span class="koboSpan" id="kobo.852.2">It’s best to use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">POST</span></strong><span class="koboSpan" id="kobo.854.1"> request for mutations and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">GET</span></strong><span class="koboSpan" id="kobo.856.1"> request to read data from </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">the server.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.858.1">We want to submit the data to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">dashboard.expenses._index.tsx</span></strong><span class="koboSpan" id="kobo.860.1"> route module (the route module of the form element). </span><span class="koboSpan" id="kobo.860.2">Note that this is the default behavior, so we could also omit the attribute declaration. </span><span class="koboSpan" id="kobo.860.3">However, for educational purposes, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">action</span></strong><span class="koboSpan" id="kobo.862.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">/dashboard/expenses?index</span></strong><span class="koboSpan" id="kobo.864.1"> as the pathname for </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">the action.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.866.1">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">?index</span></strong><span class="koboSpan" id="kobo.868.1"> search parameter that is added to the action’s pathname. </span><span class="koboSpan" id="kobo.868.2">Index route modules and their parent route modules both match the same URL. </span><span class="koboSpan" id="kobo.868.3">When defining an </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">action</span></strong><span class="koboSpan" id="kobo.870.1"> function, that action can live in either </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">dashboard.expenses.tsx</span></strong><span class="koboSpan" id="kobo.872.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">dashboard.expenses._index.tsx</span></strong><span class="koboSpan" id="kobo.874.1">. </span><span class="koboSpan" id="kobo.874.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">?index</span></strong><span class="koboSpan" id="kobo.876.1"> search parameter tells Remix to submit to the index route module, not the </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">parent module.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.878.1">Next, let’s add </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.879.1">input fields for the </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">expense data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.881.1">
export default function Component() {  return (    &lt;form method="post" action="/dashboard/expenses/?index"&gt;      &lt;label className="w-full lg:max-w-md"&gt;        Title:        &lt;input type="text" </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">name="title"</span></strong><span class="koboSpan" id="kobo.883.1"> placeholder="Dinner for           Two" required /&gt;      &lt;/label&gt;      &lt;label className="w-full lg:max-w-md"&gt;        Description:        &lt;textarea </span><strong class="bold"><span class="koboSpan" id="kobo.884.1">name="description"</span></strong><span class="koboSpan" id="kobo.885.1"> /&gt;      &lt;/label&gt;      &lt;label className="w-full lg:max-w-md"&gt;        Amount (in USD):        &lt;input type="number" defaultValue={0} </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">name="amount"</span></strong><span class="koboSpan" id="kobo.887.1">           required /&gt;      &lt;/label&gt;      &lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.888.1">type="submit"</span></strong><span class="koboSpan" id="kobo.889.1">&gt;Create&lt;/button&gt;    &lt;/form&gt;  );}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.890.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">route</span></strong><span class="koboSpan" id="kobo.892.1"> module component now renders a simple HTML form with fields for the expense data. </span><span class="koboSpan" id="kobo.892.2">It doesn’t look pretty without CSS. </span><span class="koboSpan" id="kobo.892.3">We will solve this in the next step. </span><span class="koboSpan" id="kobo.892.4">For now, let’s focus on the content of </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">the form.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.894.1">We add </span><a id="_idIndexMarker228"/><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">name</span></strong><span class="koboSpan" id="kobo.896.1"> attributes to the input and textarea elements. </span><span class="koboSpan" id="kobo.896.2">On form submission, the form data includes key-value pairs for every named input field. </span><span class="koboSpan" id="kobo.896.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">name</span></strong><span class="koboSpan" id="kobo.898.1"> attributes are used as the keys of the form data. </span><span class="koboSpan" id="kobo.898.2">Finally, a button of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">submit</span></strong><span class="koboSpan" id="kobo.900.1"> type is used to submit the form data </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">on click.</span></span></p></li> <li><span class="koboSpan" id="kobo.902.1">Next, add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">action</span></strong><span class="koboSpan" id="kobo.904.1"> function to the </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">route module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.906.1">
import type { </span><strong class="bold"><span class="koboSpan" id="kobo.907.1">ActionFunctionArgs</span></strong><span class="koboSpan" id="kobo.908.1"> } from '@remix-run/node';export async function action({ request }: </span><strong class="bold"><span class="koboSpan" id="kobo.909.1">ActionFunctionArgs</span></strong><span class="koboSpan" id="kobo.910.1">) {  // TODO}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.911.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">loader</span></strong><span class="koboSpan" id="kobo.913.1"> functions to handle HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">GET</span></strong><span class="koboSpan" id="kobo.915.1"> requests. </span><span class="koboSpan" id="kobo.915.2">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">action</span></strong><span class="koboSpan" id="kobo.917.1"> function is called for all other HTTP requests to the route, including </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.919.1"> requests.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.920.1">Both functions receive a couple of parameters. </span><span class="koboSpan" id="kobo.920.2">You already know about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">params</span></strong><span class="koboSpan" id="kobo.922.1"> parameter, which lets us access dynamic route segments. </span><span class="koboSpan" id="kobo.922.2">Now, we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">request</span></strong><span class="koboSpan" id="kobo.924.1"> parameter, which gives us access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">Request</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.926.1">object (</span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><span class="No-Break"><span class="koboSpan" id="kobo.927.1">https://developer.mozilla.org/en-US/docs/Web/API/Request</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.928.1">).</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.929.1">We type </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">loader</span></strong><span class="koboSpan" id="kobo.931.1"> function parameters with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">LoaderFunctionArgs</span></strong><span class="koboSpan" id="kobo.933.1"> type and </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">action</span></strong><span class="koboSpan" id="kobo.935.1"> function parameters with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">ActionFunctionArgs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.937.1"> type.</span></span></p></li> <li><span class="koboSpan" id="kobo.938.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">request</span></strong><span class="koboSpan" id="kobo.940.1"> parameter to parse the request body into </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">form data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.942.1">
export async function action({ request }: ActionFunctionArgs) {  </span><strong class="bold"><span class="koboSpan" id="kobo.943.1">const formData = await request.formData();</span></strong><span class="koboSpan" id="kobo.944.1">  const title = formData.get('title');  const description = formData.get('description');  const amount = formData.get('amount');}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.945.1">Remix follows </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.946.1">the Fetch API specification. </span><span class="koboSpan" id="kobo.946.2">On incoming HTTP requests, we have access to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">Request</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.948.1"> object.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.949.1">By calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">formData</span></strong><span class="koboSpan" id="kobo.951.1"> function, we parse the request body into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">FormData</span></strong><span class="koboSpan" id="kobo.953.1"> object that provides us with access to the key-value pairs of the form input data. </span><span class="koboSpan" id="kobo.953.2">You can find more information about form data in the MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><span class="No-Break"><span class="koboSpan" id="kobo.955.1">https://developer.mozilla.org/en-US/docs/Web/API/FormData</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.956.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.957.1">Import our database client and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">redirect</span></strong><span class="koboSpan" id="kobo.959.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">from Remix:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.961.1">
import { redirect } from '@remix-run/node';import { db } from '~/modules/db.server';</span></pre></li> <li><span class="koboSpan" id="kobo.962.1">Validate the form data before using it to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">new expense:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.964.1">
export async function action({ request }: ActionFunctionArgs) {  const formData = await request.formData();  const title = formData.get('title');  const description = formData.get('description');  const amount = formData.get('amount');</span><strong class="bold"><span class="koboSpan" id="kobo.965.1">  if (typeof title !== 'string' || typeof description !== 'string' || typeof amount !== 'string') {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.966.1">    throw Error('something went wrong');</span></strong><strong class="bold"><span class="koboSpan" id="kobo.967.1">  }</span></strong><span class="koboSpan" id="kobo.968.1">  const amountNumber = Number.parseFloat(amount);</span><strong class="bold"><span class="koboSpan" id="kobo.969.1">  if (Number.isNaN(amountNumber)) {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.970.1">    throw Error('something went wrong');</span></strong><strong class="bold"><span class="koboSpan" id="kobo.971.1">  }</span></strong><span class="koboSpan" id="kobo.972.1">  const expense = await db.expense.create({    data: {      title,      description,      amount: amountNumber,      currencyCode: 'USD',    },  });  return redirect(`/dashboard/expenses/${expense.id}`);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.973.1">This is quite a </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.974.1">bit of boilerplate code. </span><span class="koboSpan" id="kobo.974.2">However, remember that we implemented a full-stack data mutation, including basic </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">input validation.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.976.1">It’s a must to validate user input data on the server. </span><span class="koboSpan" id="kobo.976.2">Later in this book, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">zod</span></strong><span class="koboSpan" id="kobo.978.1"> library to help validate user input. </span><span class="koboSpan" id="kobo.978.2">For now, we keep it simple and manually validate the data using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.980.1"> stamtents.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.981.1">Note that, once again, we co-locate the server-side HTTP handler and the associated client-side UI together in </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">one file.</span></span></p></li> <li><span class="koboSpan" id="kobo.983.1">Review the return statement of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">action</span></strong><span class="koboSpan" id="kobo.985.1"> function. </span><span class="koboSpan" id="kobo.985.2">We redirect to the expense details page of the created expense to </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">communicate success:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.987.1">
redirect(`/dashboard/expenses/${expense.id}`);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.988.1">Like </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">loader</span></strong><span class="koboSpan" id="kobo.990.1"> functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">action</span></strong><span class="koboSpan" id="kobo.992.1"> functions must return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">Response</span></strong><span class="koboSpan" id="kobo.994.1"> object or plain JSON (which Remix wraps in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">Response</span></strong><span class="koboSpan" id="kobo.996.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">for us).</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.998.1">We utilize </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.999.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">redirect</span></strong><span class="koboSpan" id="kobo.1001.1"> helper function to create a redirect </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">response object.</span></span></p></li> <li><span class="koboSpan" id="kobo.1003.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">/dashboard.expenses.$id.tsx</span></strong><span class="koboSpan" id="kobo.1005.1"> route module in your editor and add a quick link to the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">creation page:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1007.1">import { FloatingActionLink } from '~/components/links';</span></strong><span class="koboSpan" id="kobo.1008.1">export default function Component() {  const expense = useLoaderData&lt;typeof loader&gt;();  return (    &lt;&gt;      &lt;div className="w-full h-full p-8"&gt;        &lt;H2&gt;{expense.title}&lt;/H2&gt;        &lt;p&gt;${expense.amount}&lt;/p&gt;      &lt;/div&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.1009.1">      &lt;FloatingActionLink to="/dashboard/expenses/"&gt;Add expense&lt;/FloatingActionLink&gt;</span></strong><span class="koboSpan" id="kobo.1010.1">    &lt;/&gt;  );}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1011.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">FloatingActionLink</span></strong><span class="koboSpan" id="kobo.1013.1"> component wraps Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">Link</span></strong><span class="koboSpan" id="kobo.1015.1"> component. </span><span class="koboSpan" id="kobo.1015.2">The quick link </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.1016.1">from the expense details page to the creation form allows for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">convenient workflow:</span></span></p><ul><li><span class="koboSpan" id="kobo.1018.1">Expense creation redirects to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">created expense.</span></span></li><li><span class="koboSpan" id="kobo.1020.1">The expense details page offers a quick link back to </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">expense creation.</span></span></li></ul></li> <li><span class="koboSpan" id="kobo.1022.1">Execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">npm run dev</span></strong><span class="koboSpan" id="kobo.1024.1"> to start the </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">dev server.</span></span></li>
<li><span class="koboSpan" id="kobo.1026.1">Navigate to the expenses overview page (</span><a href="http://localhost:3000/dashboard/expenses/"><span class="koboSpan" id="kobo.1027.1">http://localhost:3000/dashboard/expenses/</span></a><span class="koboSpan" id="kobo.1028.1">) and test the implementation. </span><span class="koboSpan" id="kobo.1028.2">Create your </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">first expense!</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1030.1">What do you notice? </span><span class="koboSpan" id="kobo.1030.2">When submitting the native HTML form element, the browser executes a full-page reload. </span><span class="koboSpan" id="kobo.1030.3">This is the browser’s default behavior on form submissions. </span><span class="koboSpan" id="kobo.1030.4">Furthermore, you might notice that the created expense appears in the expense list after completing </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">the submission.</span></span></p>
<p><span class="koboSpan" id="kobo.1032.1">A full-page reload triggers a refresh of the full page. </span><span class="koboSpan" id="kobo.1032.2">Remix renders the HTML on the server and triggers all active loader functions. </span><span class="koboSpan" id="kobo.1032.3">The expense overview is reloaded </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">on submission.</span></span></p>
<p><span class="koboSpan" id="kobo.1034.1">The form element </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.1035.1">provides a </span><strong class="bold"><span class="koboSpan" id="kobo.1036.1">declarative way</span></strong><span class="koboSpan" id="kobo.1037.1"> of describing a fetch request. </span><span class="koboSpan" id="kobo.1037.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">FormData</span></strong><span class="koboSpan" id="kobo.1039.1"> API and use named input fields to declare what fields should be sent to the server. </span><span class="koboSpan" id="kobo.1039.2">Form submissions trigger </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">POST</span></strong><span class="koboSpan" id="kobo.1041.1"> requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">action</span></strong><span class="koboSpan" id="kobo.1043.1"> function. </span><span class="koboSpan" id="kobo.1043.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">Request</span></strong><span class="koboSpan" id="kobo.1045.1"> object to parse the submitted form data. </span><span class="koboSpan" id="kobo.1045.2">This happens on the server. </span><span class="koboSpan" id="kobo.1045.3">So far, our implementation uses no </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">client-side JavaScript.</span></span></p>
<p><span class="koboSpan" id="kobo.1047.1">In a React SPA, we often call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">event.preventDefault</span></strong><span class="koboSpan" id="kobo.1049.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">onSubmit</span></strong><span class="koboSpan" id="kobo.1051.1"> handlers to prevent the browser’s default behavior. </span><span class="koboSpan" id="kobo.1051.2">Here, we initiate a client-side fetch request. </span><span class="koboSpan" id="kobo.1051.3">This may look something </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
function CreateExpenseForm() {  const [title, setTitle] = React.useState('');
  const [description, setDescription] = React.useState('');
  const [amount, setAmount] = React.useState(0);
  const [isSubmitting, setIsSubmitting] = React.useState(false);
  const handleSubmit = async (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {
    </span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">event.preventDefault();</span></strong><span class="koboSpan" id="kobo.1055.1">
    setIsSubmitting(true);
    await fetch('/dashboard/expenses/?index', {
      method: 'POST',
      body: JSON.stringify({ title, description, amount }),
    });
    setIsSubmitting(false);
  };
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;Input
        label="Title:"
        placeholder="Dinner for Two"
        required
        value={title}
        onChange={(event) =&gt; setTitle(event.target.value)}
      /&gt;
      &lt;Textarea label="Description:" value={description}         onChange={(event) =&gt; setDescription(event.target.value)} /&gt;
      &lt;Input
        label="Amount (in USD):"
        type="number"
        required
        value={amount}
        onChange={(e) =&gt; setAmount(e.target.valueAsNumber)}
      /&gt;
      &lt;Button type="submit" isPrimary disabled={isSubmitting}&gt;
        Create
      &lt;/Button&gt;
    &lt;/form&gt;
  );
}</span></pre>
<p><span class="koboSpan" id="kobo.1056.1">By doing so, we </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.1057.1">avoid full-page reloads and gain control over what pieces of the React state should be updated by the mutation. </span><span class="koboSpan" id="kobo.1057.2">However, without supporting native form submissions, we lose the ability to fall back to the browser’s default behavior. </span><span class="koboSpan" id="kobo.1057.3">Worse, implementing this ourselves forces us to develop custom solutions for pending states, error handling, and state revalidation </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">after mutation.</span></span></p>
<p><span class="koboSpan" id="kobo.1059.1">Making it work without JavaScript enables us to support user interactions before JavaScript has loaded or in case it fails to load. </span><span class="koboSpan" id="kobo.1059.2">This is a powerful feature we get when using Remix’s primitives and conventions. </span><span class="koboSpan" id="kobo.1059.3">However, Remix also scales upward. </span><span class="koboSpan" id="kobo.1059.4">Let’s add JavaScript to enhance </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">the experience.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.1061.1">Mutating data with JavaScript</span></h2>
<p><span class="koboSpan" id="kobo.1062.1">Remix </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.1063.1">provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">Form</span></strong><span class="koboSpan" id="kobo.1065.1"> component that progressively enhances the experience. </span><span class="koboSpan" id="kobo.1065.2">All we need to do is replace the native HTML form element through Remix’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">Form</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1"> component:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1068.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">Form</span></strong><span class="koboSpan" id="kobo.1070.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">from Remix:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1072.1">
import { Form } from '@remix-run/react';</span></pre></li> <li><span class="koboSpan" id="kobo.1073.1">Use it to </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.1074.1">replace the native HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">form element:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
export default function Component() {  return (</span><strong class="bold"><span class="koboSpan" id="kobo.1077.1">    &lt;Form method="post" action="/dashboard/expenses/?index"&gt;</span></strong><span class="koboSpan" id="kobo.1078.1">      …</span><strong class="bold"><span class="koboSpan" id="kobo.1079.1">    &lt;/Form&gt;</span></strong><span class="koboSpan" id="kobo.1080.1">  );}</span></pre></li> <li><span class="koboSpan" id="kobo.1081.1">Now, test the implementation again and create some </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">more expenses.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.1083.1">What changed? </span><span class="koboSpan" id="kobo.1083.2">You may be able to notice a </span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">few things:</span></span></p><ul><li><span class="koboSpan" id="kobo.1085.1">When using Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">Form</span></strong><span class="koboSpan" id="kobo.1087.1"> component, Remix prevents the browser’s default behavior and executes a client-side fetch request to submit the form, avoiding the full-page reload. </span><span class="koboSpan" id="kobo.1087.2">This works out of the box without us adding an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">onSubmit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1"> handler.</span></span></li><li><span class="koboSpan" id="kobo.1090.1">Our custom page loading indicator is triggered, indicating that form submissions also affect Remix’s global </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">navigation object.</span></span></li><li><span class="koboSpan" id="kobo.1092.1">After submission, the app still executes a redirect and transitions the user to the expense </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">details page.</span></span></li><li><span class="koboSpan" id="kobo.1094.1">After submission, the new expense appears in the expense overview list as part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">/dashboard/expenses/</span></strong><span class="koboSpan" id="kobo.1096.1"> route’s loader data. </span><span class="koboSpan" id="kobo.1096.2">Remix emulates the browser’s default behavior of refreshing all content on </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">the page.</span></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.1098.1">Remember how Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">NavLink</span></strong><span class="koboSpan" id="kobo.1100.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">Link</span></strong><span class="koboSpan" id="kobo.1102.1"> components enhance anchor tag navigations? </span><span class="koboSpan" id="kobo.1102.2">By replacing the native form element with Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">Form</span></strong><span class="koboSpan" id="kobo.1104.1"> component, we get client-side data fetching, progressive enhancement, and client-side state revalidation out of </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">the box.</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">We now take </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.1107.1">advantage of JavaScript on the client, but that JavaScript is provided through Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">Form</span></strong><span class="koboSpan" id="kobo.1109.1"> component, and no custom boilerplate code is required. </span><span class="koboSpan" id="kobo.1109.2">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">Form</span></strong><span class="koboSpan" id="kobo.1111.1"> component sets the global navigation object’s state to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">submitting</span></strong><span class="koboSpan" id="kobo.1113.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">loading</span></strong><span class="koboSpan" id="kobo.1115.1"> for managing pending UIs. </span><span class="koboSpan" id="kobo.1115.2">Using Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">Form</span></strong><span class="koboSpan" id="kobo.1117.1"> component further ensures the refetching of all active </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">loader</span></strong><span class="koboSpan" id="kobo.1119.1"> functions </span><span class="No-Break"><span class="koboSpan" id="kobo.1120.1">after mutation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1121.1">Remix revalidates loader data after every action</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1122.1">Remix refreshes all loader data by re-fetching from all active </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">loader</span></strong><span class="koboSpan" id="kobo.1124.1"> functions after executing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">action</span></strong><span class="koboSpan" id="kobo.1126.1"> function, just like a full-page reload would do on a HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">form submission.</span></span></p>
<p><span class="koboSpan" id="kobo.1128.1">Data revalidation is a powerful feature that lets us avoid stale data on the client or having to develop custom logic to synchronize client and </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">server states.</span></span></p>
<p><span class="koboSpan" id="kobo.1130.1">Nice! </span><span class="koboSpan" id="kobo.1130.2">In this section, we implemented an expense creation form and associated </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">action</span></strong><span class="koboSpan" id="kobo.1132.1"> function. </span><span class="koboSpan" id="kobo.1132.2">You learned how Remix removes boilerplate code by providing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">Form</span></strong><span class="koboSpan" id="kobo.1134.1"> component, which does the heavy lifting under the hood. </span><span class="koboSpan" id="kobo.1134.2">You practiced declaring a fetch request using named input fields and Remix’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">Form</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.1137.1">Before moving on, let’s style our form by bringing in some of the prepared </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">UI components:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1139.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">Textarea</span></strong><span class="koboSpan" id="kobo.1141.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">Input</span></strong><span class="koboSpan" id="kobo.1143.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">Form</span></strong><span class="koboSpan" id="kobo.1145.1"> components from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">components</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1"> folder:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1148.1">
import { Form, Input, Textarea } from '~/components/forms';</span></pre></li> <li><span class="koboSpan" id="kobo.1149.1">Remove the import of Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">Form</span></strong><span class="koboSpan" id="kobo.1151.1"> component since we will be using our custom wrapper </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">component instead.</span></span></li>
<li><span class="koboSpan" id="kobo.1153.1">Replace the native label, input, and textarea elements with our </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">styled counterparts:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1155.1">
export default function CreateExpensePage() {  return (    &lt;Form method="post" action="/dashboard/expenses/?index"&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.1156.1">      &lt;Input label="Title:" type="text" name="title"         placeholder="Dinner for Two" required /&gt;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1157.1">      &lt;Textarea label="Description:" name="description" /&gt;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1158.1">      &lt;Input label="Amount (in USD):" type="number"         defaultValue={0} name="amount" required /&gt;</span></strong><span class="koboSpan" id="kobo.1159.1">      &lt;button type="submit"&gt;Create&lt;/button&gt;    &lt;/Form&gt;  );}</span></pre></li> <li><span class="koboSpan" id="kobo.1160.1">Also, import </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.1161.1">the styled </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">Button</span></strong><span class="koboSpan" id="kobo.1163.1"> component from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">components</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1"> folder:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1166.1">
import { Button } from '~/components/buttons';</span></pre></li> <li><span class="koboSpan" id="kobo.1167.1">Replace the native button element with our wrapper component and add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">isPrimary</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1"> property:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1170.1">
&lt;Button type="submit" isPrimary&gt;  Create&lt;/Button&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.1171.1">Run BeeRich locally. </span><span class="koboSpan" id="kobo.1171.2">The form should look much </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">nicer now.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1173.1">Make sure you implement the invoice creation form and replicate what we did for the expense routes. </span><span class="koboSpan" id="kobo.1173.2">Start by implementing the functionality without JavaScript. </span><span class="koboSpan" id="kobo.1173.3">Then, enhance the experience with Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">Form</span></strong><span class="koboSpan" id="kobo.1175.1"> component. </span><span class="koboSpan" id="kobo.1175.2">I encourage you to keep the </span><strong class="bold"><span class="koboSpan" id="kobo.1176.1">Network</span></strong><span class="koboSpan" id="kobo.1177.1"> tab open while running BeeRich locally. </span><span class="koboSpan" id="kobo.1177.2">Filter by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">Fetch/XHR</span></strong><span class="koboSpan" id="kobo.1179.1"> network requests and inspect </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.1180.1">how Remix revalidates all loader data after each form submission. </span><span class="koboSpan" id="kobo.1180.2">If you get stuck working on the income routes, you can find the final solution for this chapter on </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/05-fetching-and-mutating-data/bee-rich/solution"><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/05-fetching-and-mutating-data/bee-rich/solution</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.1184.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1185.1">Reading and writing data are important aspects of modern web application development. </span><span class="koboSpan" id="kobo.1185.2">Remix provides primitives, conventions, and levers </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">for both.</span></span></p>
<p><span class="koboSpan" id="kobo.1187.1">This chapter introduced you to Remix’s server-side </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">loader</span></strong><span class="koboSpan" id="kobo.1189.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">action</span></strong><span class="koboSpan" id="kobo.1191.1"> functions. </span><span class="koboSpan" id="kobo.1191.2">You learned that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">loader</span></strong><span class="koboSpan" id="kobo.1193.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">action</span></strong><span class="koboSpan" id="kobo.1195.1"> functions are route-level HTTP request handlers that get and mutate data. </span><span class="koboSpan" id="kobo.1195.2">Loaders handle HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">GET</span></strong><span class="koboSpan" id="kobo.1197.1"> requests, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">action</span></strong><span class="koboSpan" id="kobo.1199.1"> functions receive all other incoming </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">HTTP requests.</span></span></p>
<p><span class="koboSpan" id="kobo.1201.1">Initially, Remix renders our app on the server. </span><span class="koboSpan" id="kobo.1201.2">All further page transitions happen on the client. </span><span class="koboSpan" id="kobo.1201.3">On the initial request, loader data is used during server-side rendering. </span><span class="koboSpan" id="kobo.1201.4">On all subsequent navigations, Remix fetches loader data via fetch requests and only re-renders the changing parts of the route hierarchy on </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">Next, you learned that route-level data fetching allows us – among other things – to flatten request waterfalls that may occur with component-level fetching. </span><span class="koboSpan" id="kobo.1203.2">Remix also executes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">loader</span></strong><span class="koboSpan" id="kobo.1205.1"> functions in parallel to reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">response times.</span></span></p>
<p><span class="koboSpan" id="kobo.1207.1">By completing this chapter, you should now understand how Remix uses the HTML form element to work with mutations declaratively. </span><span class="koboSpan" id="kobo.1207.2">Remix provides progressive enhancement out of the box. </span><span class="koboSpan" id="kobo.1207.3">By default, Remix executes client-side fetch requests to perform data mutations. </span><span class="koboSpan" id="kobo.1207.4">However, if JavaScript isn’t available (hasn’t loaded yet, failed to load, or is disabled), then Remix can fall back to the browser’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">default behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.1209.1">In this chapter, we added an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">action</span></strong><span class="koboSpan" id="kobo.1211.1"> function to validate request data and create a new expense object. </span><span class="koboSpan" id="kobo.1211.2">Remix automatically refetches all loader data after every mutation. </span><span class="koboSpan" id="kobo.1211.3">With Remix, we get data revalidation out of </span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">the box.</span></span></p>
<p><span class="koboSpan" id="kobo.1213.1">Remix’s data loading and mutations work with and without JavaScript. </span><span class="koboSpan" id="kobo.1213.2">This allows us to enhance the experience progressively and make our application accessible to more users. </span><span class="koboSpan" id="kobo.1213.3">In the next chapter, we will learn more about progressively enhancing the experience. </span><span class="koboSpan" id="kobo.1213.4">We will formalize what we learned in this chapter and learn about more tools to enhance the experience in our </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">Remix apps.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.1215.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1216.1">The Remix documentation outlines the full stack data flow in Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">here: </span></span><a href="https://remix.run/docs/en/2/discussion/data-flow"><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">https://remix.run/docs/en/2/discussion/data-flow</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1220.1">You can find Remix’s documentation about data loading </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">here: </span></span><a href="https://remix.run/docs/en/2/guides/data-loading"><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">https://remix.run/docs/en/2/guides/data-loading</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1224.1">You can find Remix’s documentation about mutations </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">here: </span></span><a href="https://remix.run/docs/en/2/guides/data-writes"><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">https://remix.run/docs/en/2/guides/data-writes</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1228.1">The Remix team has created an amazing video series called Remix Singles that goes in depth into how to work with data in Remix. </span><span class="koboSpan" id="kobo.1228.2">The series starts with a video about data loading, which you can find </span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">here: </span></span><a href="https://www.youtube.com/watch?v=NXqEP_PsPNc"><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">https://www.youtube.com/watch?v=NXqEP_PsPNc</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1232.1">MDN Web Docs is a great place to learn more about the HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">protocol: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP"><span class="No-Break"><span class="koboSpan" id="kobo.1234.1">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1235.1">.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer024">
</div>
</div>
</body></html>