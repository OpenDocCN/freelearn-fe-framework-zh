- en: Chapter 5. Component Life cycle and Newer ECMAScript in React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：组件生命周期和 React 中的新 ECMAScript
- en: So far, we have explored React component properties and how we need to initialize,
    update, and change the component's state(s) for interactive applications. Let's
    now explore the lifecycle of such a React component in this chapter. We will also
    dig into future ECMAScript syntax and a few changes that the React community also
    used from version 0.13.0\. For this, we will review some ES6 and ES7 features
    within the React library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 React 组件属性以及我们需要如何初始化、更新和更改组件的状态（s）以实现交互式应用程序。现在让我们在本章中探索此类 React
    组件的生命周期。我们还将深入研究未来的 ECMAScript 语法以及 React 社区从 0.13.0 版本开始使用的一些更改。为此，我们将回顾 React
    库中的一些 ES6 和 ES7 功能。
- en: While creating any React component by calling `React.createClass()`, we need
    to always have a render method. This render method returns a description of the
    DOM. React has a performance edge in our applications because React maintains
    a fast in-memory representation of the DOM and never directly interacts with the
    actual DOM. Thus, when the render method returns the description of the DOM, React
    can compare the difference between the actual DOM and the in-memory representation,
    and, based on the difference(s), re-renders the view accordingly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过调用 `React.createClass()` 创建任何 React 组件时，我们始终需要有一个渲染方法。此渲染方法返回 DOM 的描述。React
    在我们的应用程序中具有性能优势，因为 React 维护一个快速的内存表示形式的 DOM，并且从不直接与实际的 DOM 交互。因此，当渲染方法返回 DOM 的描述时，React
    可以比较实际 DOM 和内存表示之间的差异，并根据差异重新渲染视图。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: React component lifecycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 组件生命周期
- en: Using React with ECMAScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ECMAScript 中使用 React
- en: React component lifecycle
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 组件生命周期
- en: 'As per Facebook''s React documentation from [http://facebook.github.io/react/docs/working-with-the-browser.html](http://facebook.github.io/react/docs/working-with-the-browser.html),
    the React component lifecycle can be broadly classified into three categories
    as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Facebook 的 React 文档 [http://facebook.github.io/react/docs/working-with-the-browser.html](http://facebook.github.io/react/docs/working-with-the-browser.html)，React
    组件生命周期可以大致分为以下三个类别：
- en: '*"**Mounting****:** A component is being inserted into the DOM.*'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"**挂载**：组件正在被插入到 DOM 中。*"'
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***Updating****:** A component is being re-rendered to determine if the DOM
    should be updated.*'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**更新**：组件正在重新渲染以确定是否应该更新 DOM。*'
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***Unmounting:** A component is being removed from the DOM.**"***'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**卸载**：组件正在从 DOM 中移除。**"***"'
- en: React provides lifecycle methods that you can specify to hook into this process.
    We provide `will` methods, which are called right before something happens, and
    `did` methods which are called right after something happens.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了生命周期方法，您可以在其中指定以挂钩到这个过程。我们提供了 `will` 方法，这些方法在某个事件发生之前被调用，以及 `did` 方法，这些方法在某个事件发生后被调用。
- en: Mounting category
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载类别
- en: '**Mounting** is the process of publishing the virtual representation of a component
    into the final UI representation (for example, DOM or native components). In a
    browser, it would mean publishing a React element into an actual DOM element in
    the DOM tree.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂载** 是将组件的虚拟表示发布到最终 UI 表示（例如，DOM 或原生组件）的过程。在浏览器中，这意味着将 React 元素发布到 DOM 树中的实际
    DOM 元素。'
- en: '| Method Name | Method Function |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 方法名称 | 方法功能 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getInitialState()` | This method is invoked before the component is mounted.In
    the case of stateful components, this method returns the initial state data. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `getInitialState()` | 此方法在组件挂载之前被调用。对于有状态组件，此方法返回初始状态数据。|'
- en: '| `componentWillMount()` | This method is called just before React mounts the
    component in the DOM. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `componentWillMount()` | 此方法在 React 将组件挂载到 DOM 之前被调用。|'
- en: '| `componentDidMount()` | This method is called immediately after mounting
    occurs. The initialization process that DOM nodes requires should go within this
    method. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `componentDidMount()` | 此方法在组件挂载后立即调用。DOM 节点所需的初始化过程应在此方法中进行。|'
- en: Like in the previous chapters, most of the code in the `index.html` is the same.
    We will only be replacing the contents of the JavaScript file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，`index.html` 中的大部分代码都是相同的。我们只需替换 JavaScript 文件的全部内容。
- en: 'The code of `index.html` will become as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 的代码将变为以下内容：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initially, we can see the value of `myButton` set to **11**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们可以看到 `myButton` 的值设置为 **11**：
- en: '![Mounting category](img/00023.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![挂载类别](img/00023.jpeg)'
- en: The value of `myButton` increases by two when the `onClick(addOnClick)` event
    occurs. Thus, the value of state changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当`onClick(addOnClick)`事件发生时，`myButton`的值增加两个。因此，状态的值发生了变化。
- en: '![Mounting category](img/00024.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![挂载类别](img/00024.jpeg)'
- en: Value of `myButton` increases by two when the `onClick` event occurs
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当`onClick`事件发生时，`myButton`的值增加两个
- en: If we add the `componentWillMount` method to the preceding code, we will be
    able to see that the React component is only mounted in the DOM once, but is rendered
    each time we click on the button.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`componentWillMount`方法添加到前面的代码中，我们将能够看到React组件在DOM中只挂载一次，但每次我们点击按钮时都会进行渲染。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The screenshot of the app component mounting on the DOM shows in the console,
    **MyButton component is mounting**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中显示的应用组件挂载到DOM的截图，**MyButton组件正在挂载**。
- en: '![Mounting category](img/00025.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![挂载类别](img/00025.jpeg)'
- en: Screenshot of app component mounting on the DOM
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用组件挂载到DOM的截图
- en: 'Let''s implement the last mounting method, `componentDidMount`, which is called
    after the component is mounted. As you can see in the next screenshot, the console
    shows the component has been mounted once but the component is rendered the number
    of times we click on the button, four times in this case: `11 + (2*4) =19`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现最后一个挂载方法，`componentDidMount`，它在组件挂载后被调用。正如您在下一张截图中所见，控制台显示组件已挂载一次，但组件被渲染的次数与我们点击按钮的次数相同：`11
    + (2*4) =19`。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The screenshot shows methods where mounting and mounted on the DOM is called
    once, though rendering happens. Thus, after the `componentDidMount` method is
    executed, in the console we can see the output **MyButton component is mounted**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该截图显示挂载和挂载到DOM只调用一次的方法，尽管发生了渲染。因此，在`componentDidMount`方法执行后，在控制台中我们可以看到输出**MyButton组件已挂载**。
- en: '![Mounting category](img/00026.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![挂载类别](img/00026.jpeg)'
- en: Screenshot of methods where mounting and mounted on the DOM is called once,
    though rendering happens
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的截图显示挂载和挂载到DOM只调用一次，尽管发生了渲染
- en: Updating category
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新类别
- en: 'The React component lifecycle allows updating components at runtime. This can
    be done using the following methods:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的生命周期允许在运行时更新组件。这可以通过以下方法完成：
- en: '| Method Name | Method Function |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 方法名称 | 方法功能 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `componentWillReceiveProps(object nextProps)` | This method is invoked when
    a mounted React component receives new properties (props). This means you can
    use it to compare between `this.props`, the current set of properties, and `nextProps`,
    the new property values. There is no similar method like `componentWillReceiveState`.
    Thus, an incoming property transition may cause a state change, but an incoming
    state may not cause a property change. If we want to perform some operation in
    response to a state change, we would need to use the method `componentWillUpdate`.Thus,
    the component''s property changes will be rendered in the updated view without
    re-rendering the view. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `componentWillReceiveProps(object nextProps)` | 当挂载的React组件接收到新属性（props）时，此方法会被调用。这意味着您可以使用它来比较`this.props`，当前属性集，和`nextProps`，新的属性值。没有类似`componentWillReceiveState`的方法。因此，传入的属性转换可能会引起状态变化，但传入的状态可能不会引起属性变化。如果我们想对状态变化执行某些操作，我们需要使用`componentWillUpdate`方法。因此，组件的属性变化将在更新的视图中渲染，而无需重新渲染视图。
    |'
- en: '| `shouldComponentUpdate(object nextProps, object nextState)` | This method
    is invoked when a component requires an update in the DOM.The return type is boolean
    (`true`/`false`).It returns `false` when there is no change in the props and/or
    state, which will prevent `componentWillUpdate` and `componentDidUpdate` from
    being called. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `shouldComponentUpdate(object nextProps, object nextState)` | 当组件需要在DOM中更新时，此方法会被调用。返回类型是布尔值（`true`/`false`）。如果没有props和/或状态的变化，它将返回`false`，这将阻止`componentWillUpdate`和`componentDidUpdate`被调用。
    |'
- en: '| `componentWillUpdate(object nextProps, object nextState)` | As the name suggests,
    this method is invoked immediately before updating occurs, but not in the first
    render call.`this.setState()` cannot be called within this lifecycle method. To
    update a state in response to a property change, use `componentWillReceiveProps`
    instead. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `componentWillUpdate(object nextProps, object nextState)` | 如其名所示，此方法在更新发生之前立即被调用，但不在第一次渲染调用中。在此生命周期方法中不能调用`this.setState()`。要响应属性变化更新状态，请使用`componentWillReceiveProps`代替。
    |'
- en: '| `componentDidUpdate(object prevProps, object prevState)` | This is invoked
    immediately after updating occurs in the DOM and not during the initial `render()`
    call. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `componentDidUpdate(object prevProps, object prevState)` | 这是在 DOM 更新后立即调用的，而不是在初始
    `render()` 调用期间。|'
- en: 'Let''s add the preceding methods in our code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中添加前面的方法：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Execute the preceding code to see the following output. We can see the various
    lifecycle events of the React component and the corresponding output they give
    in the console.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码以查看以下输出。我们可以看到 React 组件的各种生命周期事件以及它们在控制台输出的对应内容。
- en: '![Updating category](img/00027.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![更新分类](img/00027.jpeg)'
- en: Screenshot of component being updated
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 组件更新的截图
- en: Unmounting category
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载分类
- en: '`componentWillUnmount()` is invoked immediately before a component is unmounted
    and destroyed. You should perform any necessary cleanup here.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件卸载和销毁之前立即调用 `componentWillUnmount()`。你应该在这里执行任何必要的清理工作。
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here's the complete example encompassing all the lifecycle methods of a React
    component. The `index.html` is the same as the preceding.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含 React 组件所有生命周期方法的完整示例。`index.html` 与前面相同。
- en: 'The code of `index.html`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 的代码：'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the corresponding `index.js` code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的 `index.js` 代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Observe the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: After executing the preceding code, we will be able to see two buttons as **Mount**
    and **Unmount**
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行上述代码后，我们将能够看到两个按钮，分别是 **挂载** 和 **卸载**
- en: The initial value of the component is set to **11**
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的初始值设置为 **11**
- en: '`onClick` on the React component; its value is increased by a value of two'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 组件上的 `onClick`；其值增加两个
- en: While clicking on the **Mount**, the lifecycle methods of the React component
    is called
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击 **挂载** 时，React 组件的生命周期方法被调用
- en: For each of these lifecycle methods, we can see an output in the console![Unmounting
    category](img/00028.jpeg)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这些生命周期方法中的每一个，我们都可以在控制台中看到输出![卸载分类](img/00028.jpeg)
- en: Screenshot of unmouting the component from the DOM
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 DOM 中卸载组件的截图
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: Mounted composite components support the method `component.forceUpdate()`.
    This method can be invoked on any mounted component, in case of some changes in
    the deeper aspect of the component, without using `this.setState()`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：已挂载的复合组件支持 `component.forceUpdate()` 方法。如果组件的深层方面发生某些更改，可以在不使用 `this.setState()`
    的情况下调用此方法。
- en: 'Our React component''s lifecycles are shown next. The lifecycles are highlighted
    in the right portion of the developer tool:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面展示我们的 React 组件的生命周期。生命周期在开发工具的右侧部分被突出显示：
- en: '![Unmounting category](img/00029.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![卸载分类](img/00029.jpeg)'
- en: Screenshot showing the React component's lifecycle, as highlighted in the right
    portion of the developer tool
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 展示 React 组件生命周期的截图，如图形开发工具右侧所示
- en: Other ES (ECMAScript) versions in React
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 中的其他 ES (ECMAScript) 版本
- en: 'In the second half of this chapter, we will explore how React supports newer
    versions of ECMAScript. Until now, we have explored the different lifecycle methods
    in a React component. In this section of the chapter, we will dig into something
    different: how changes in the new version of ECMAScript have been adopted by React.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们将探讨 React 如何支持 ECMAScript 的新版本。到目前为止，我们已经探讨了 React 组件中的不同生命周期方法。在本章的这一部分，我们将深入了解不同内容：ECMAScript
    新版本中的变化是如何被 React 采纳的。
- en: ES6
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES6
- en: '**ES6** is the current version of the ECMAScript Language Specification Standard.
    Further details about the changes and the new things incorporated can be found
    on the Mozilla Development Network site: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**ES6** 是 ECMAScript 语言规范标准的当前版本。关于更改和新增内容的更多详细信息，可以在 Mozilla 开发者网络网站上找到：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla)'
- en: Complete documentation for ES6 is beyond the scope of this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围超出了 ES6 的完整文档。
- en: 'According to the Facebook documentation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Facebook 文档：
- en: 'Starting with React 0.13.0 a transpiler allows us to use ES6 classes. JavaScript
    originally didn''t have a built-in class system. The developer team wanted class
    creation using the idiomatic JavaScript style. Therefore instead of `React.createClass`
    the developer team has introduced a component. You can use the transpiler they
    ship with `react-tools` by making use of the harmony option and setting it to
    `true` as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从 React 0.13.0 版本开始，一个转换器允许我们使用 ES6 类。JavaScript 最初没有内置的类系统。开发团队希望使用惯用的 JavaScript
    风格创建类。因此，开发团队引入了组件，而不是 `React.createClass`。您可以通过使用 `react-tools` 中的转换器并利用和谐选项将其设置为
    `true` 来使用他们提供的转换器，如下所示：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By looking through [https://www.npmjs.com/package/react-tools](https://www.npmjs.com/package/react-tools),
    you can find details of the different options you can pass with the JSX Transformer.
    `--harmony` turns on JS transformations such as ES6 classes and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 [https://www.npmjs.com/package/react-tools](https://www.npmjs.com/package/react-tools)，您可以找到有关可以传递给
    JSX 转换器的不同选项的详细信息。`--harmony` 启用诸如 ES6 类等 JS 转换。
- en: Thus, ES6 syntax will be transformed into ES5 compatible syntaxes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ES6 语法将被转换为与 ES5 兼容的语法。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Transpiling** is a method for taking source code written in one language
    and transforming it into another language that has a similar level of abstraction.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换** 是一种将一种语言编写的源代码转换为具有相似抽象级别的另一种语言的方法。'
- en: When TypeScript is compiled and is transformed by the compiler into JavaScript,
    it has very similar levels of abstraction. Hence, it is called transpiling.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TypeScript 编译并由编译器转换为 JavaScript 时，它具有非常相似的抽象级别。因此，它被称为转换。
- en: Here, React classes are defined as a plain JavaScript class. Let's go through
    the following code from their documentation with some modifications and explanations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，React 类被定义为普通的 JavaScript 类。让我们通过以下代码（经过一些修改和解释）来了解他们的文档。
- en: 'Code within `index.html`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 中的代码：'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The highlighted line with the argument as `harmony=true` ensures that the jsx
    syntax with ES6 code should be transpiled into JavaScript using ES5 syntax.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `harmony=true` 参数的突出显示行确保 JSX 语法与 ES6 代码一起使用时应使用 ES5 语法进行转换。
- en: 'Code within `index.js`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js` 中的代码：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Explanation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：
- en: 'Line 1: Declaring the React component `ES6Component`, which extends from `React.Component`
    instead of `React.createClass`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 1 行：声明 React 组件 `ES6Component`，它扩展自 `React.Component` 而不是 `React.createClass`
- en: 'Line 2: The render function call syntax is different. Before, it was'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 2 行：渲染函数调用语法不同。之前是
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is a screenshot demonstrating it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示截图：
- en: '![ES6](img/00030.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![ES6](img/00030.jpeg)'
- en: Screenshot of the React component using ES6
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 的 React 组件截图
- en: Instead of `getInitialState` in `React.createClass`, using ES6 the new constructor
    has the new own state property in `React.Component`, which is exported.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `React.createClass` 中不再使用 `getInitialState`，使用 ES6 的新构造函数在 `React.Component`
    中具有新的自有状态属性，该属性被导出。
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![ES6](img/00031.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![ES6](img/00031.jpeg)'
- en: Screenshot of the React component using ES6
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 的 React 组件截图
- en: Another feature of React using ES6 is No Autobinding.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用 ES6 的另一个特性是自动绑定。
- en: As with ES6 classes, which do not automatically bind to the instance, we need
    to use bind.(this) **OR** use the arrow sign (`=>`) explicitly in ES6.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ES6 类一样，由于它们不会自动绑定到实例，我们需要使用 `bind.(this)` **或者** 在 ES6 中显式使用箭头符号 (`=>`)。
- en: Following these ES6 syntaxes, we can rewrite our sample app from Chapter XX,
    which lists the user's likes in Facebook. Just as before, if the user clicks on
    the liked-page name, the string **I Liked it** will be updated on the page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些 ES6 语法，我们可以重写第 XX 章的示例应用，该应用列出用户的 Facebook 喜欢的内容。就像之前一样，如果用户点击喜欢的页面名称，页面上的字符串
    **我喜欢它** 将被更新。
- en: 'The changes as per the new ES6 syntaxes are highlighted next:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据新的 ES6 语法所做的更改将在下面突出显示：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`let` is used instead of `var` to declare a variable in a local scope.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let` 而不是 `var` 在局部作用域中声明变量。
- en: 'The output remains the same, as per the next screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与下一个截图相同：
- en: '![ES6](img/00032.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![ES6](img/00032.jpeg)'
- en: Screenshot of the React app, fetching the user's liked pages, using ES6 syntaxes
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 语法获取用户喜欢的页面的 React 应用截图
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: ES6 does not support mixins. Mixins will be covered later in this book
    in [Chapter 7](part0044_split_000.html#page "Chapter 7. Making Your Component
    Reusable"), *Making your Component Reusable*, in more detail. Mixins are used
    to write reusable codes in React applications.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：ES6 不支持混入。混入将在本书的 [第 7 章](part0044_split_000.html#page "第 7 章。使组件可重用") 中更详细地介绍，*使组件可重用*。混入用于在
    React 应用程序中编写可重用代码。
- en: ES7
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES7
- en: 'ECMAScript7 is one step beyond ES6\. Even before ES6 was finalized, new features
    started to be proposed. Please view the experimental and stabilized feature list
    at the following URL:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript7是ES6的下一步。甚至在ES6最终确定之前，新的功能已经开始被提出。请查看以下URL的实验性和稳定特性列表：
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_7_support_in_Mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_7_support_in_Mozilla)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_7_support_in_Mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_7_support_in_Mozilla)'
- en: 'Keeping ES7 in mind, the React developer community presented us with some syntactic
    sugar to the existing React class code. In the future version of JavaScript (ES7),
    there can be more declarative syntax for property initialization, as this would
    be a more idiomatic way of expressing. Here''s a quick example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到ES7，React开发者社区为我们提供了一些现有的React类代码的语法糖。在JavaScript的未来版本（ES7）中，可能会有更多用于属性初始化的声明式语法，因为这会是一种更符合习惯的表达方式。以下是一个快速示例：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone through the lifecycle of a typical React component,
    the various phases it undergoes, and how React renders the view based on the diff-ing
    algorithm (that is, calculating the deltas between the virtual DOM and the actual
    DOM).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了典型React组件的生命周期，它经历的各个阶段，以及React如何根据diff算法（即计算虚拟DOM和实际DOM之间的差异）来渲染视图。
- en: In the second part of the chapter, we explored the future of ECMAScript and
    how React.js already supports it. For this, we have used sample code examples
    from Facebook's documentation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们探讨了ECMAScript的未来以及React.js如何支持它。为此，我们使用了Facebook文档中的示例代码。
- en: In the next chapter, we will discuss React's reusable components known as mixins.
    We will also explore how we can add validations in a React-based application.
    Validations are required for apps that accept user input. User inputs should be
    validated before being sent to the server, to prevent malicious or invalid content
    from being sent.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论React的可重用组件，即mixins。我们还将探讨如何在基于React的应用程序中添加验证。对于接受用户输入的应用程序，验证是必需的。在将用户输入发送到服务器之前，应该对其进行验证，以防止恶意或无效内容被发送。
