<html><head></head><body>
<div id="_idContainer329">
<p><a id="_idTextAnchor443"/></p>
<h1 class="chapter-number" id="_idParaDest-236"><a id="_idTextAnchor444"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-237"><a id="_idTextAnchor445"/><span class="koboSpan" id="kobo.2.1">Unit Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In previous chapters, we saw how to build reasonably complex Vue.js applications. </span><span class="koboSpan" id="kobo.3.2">This chapter is about testing them to maintain code quality and prevent defects. </span><span class="koboSpan" id="kobo.3.3">We will look at approaches to unit testing Vue.js applications in order to improve the quality and speed of delivery of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">our applications.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will </span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.6.1">also look at using tests to drive development using </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.9.1">TDD</span></strong><span class="koboSpan" id="kobo.10.1">). </span><span class="koboSpan" id="kobo.10.2">As we proceed, we will gain an understanding of why code needs to be tested and what kinds of testing can be employed on different parts of a </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Vue.js application.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Understanding testing and the need to </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">test code</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Building your </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">first test</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Testing components</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Testing methods</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Testing routing</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Testing state management </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">with Pinia</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Snapshot testing</span></span><a id="_idTextAnchor446"/></li>
</ul>
<h1 id="_idParaDest-238"><a id="_idTextAnchor447"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">There are no technical requirements for this chapter outside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">git</span></strong><span class="koboSpan" id="kobo.27.1"> CLI, which you will have already used by now. </span><span class="koboSpan" id="kobo.27.2">You can find this chapter’s source code </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">here: </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11</span></span></a></p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor448"/><span class="koboSpan" id="kobo.30.1">Understanding testing and the need to test code</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.31.1">Testing</span></strong><span class="koboSpan" id="kobo.32.1"> is a crucial </span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.33.1">process for ensuring that the code does what it’s meant to do. </span><span class="koboSpan" id="kobo.33.2">Quality production software is empirically correct. </span><span class="koboSpan" id="kobo.33.3">That means that for the enumerated cases that developers and testers have found, the application behaves </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">This lies in </span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.36.1">contrast with software that has been proven to be correct, which is a very time-consuming endeavor and is usually part of academic research projects. </span><span class="koboSpan" id="kobo.36.2">We are still at the point where correct software (proven) is still being built to show what kinds of systems are possible to build with this constraint </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">of correctness.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Testing prevents the introduction of defects such as bugs and regressions (that is, when a feature stops working as expected). </span><span class="koboSpan" id="kobo.38.2">In the next section, we will learn about the various types </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">of testing.</span></span></p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor449"/><span class="koboSpan" id="kobo.40.1">Different types of testing</span></h2>
<p><span class="koboSpan" id="kobo.41.1">The testing </span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.42.1">spectrum spans from </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">end-to-end testing</span></strong><span class="koboSpan" id="kobo.44.1"> (by manipulating the user interface) to </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">integration tests</span></strong><span class="koboSpan" id="kobo.46.1">, and finally to </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">unit tests</span></strong><span class="koboSpan" id="kobo.48.1">. </span></p>
<h3><span class="koboSpan" id="kobo.49.1">End-to-end testing</span></h3>
<p><span class="koboSpan" id="kobo.50.1">End-to-end tests test everything, including the user interface, the underlying HTTP services, and even database interactions; nothing is mocked. </span><span class="koboSpan" id="kobo.50.2">If you’ve </span><a id="_idIndexMarker1197"/><span class="koboSpan" id="kobo.51.1">got an e-commerce application, an end-to-end </span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.52.1">test might actually place a real order with a real credit card, or it might place a test order with a test </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">credit card.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">End-to-end tests are costly to run and maintain. </span><span class="koboSpan" id="kobo.54.2">They require the use of full-blown browsers controlled through programmatic drivers such as Selenium, WebdriverIO, or Cypress. </span><span class="koboSpan" id="kobo.54.3">This type of test platform is costly to run, and small changes in the application code can cause end-to-end tests to </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">start failing.</span></span></p>
<h3><span class="koboSpan" id="kobo.56.1">Integration tests</span></h3>
<p><span class="koboSpan" id="kobo.57.1">Integration </span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.58.1">or system-level tests ensure that a set of systems </span><a id="_idIndexMarker1200"/><span class="koboSpan" id="kobo.59.1">is working as expected. </span><span class="koboSpan" id="kobo.59.2">This will usually involve deciding on a limit as to where the system under test lies and allowing it to run, usually against mocked or stubbed upstream services and systems (which are therefore not </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">under test).</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Since external </span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.62.1">data access is stubbed, a whole host of issues, such as </span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.63.1">timeouts and flakes, can be reduced (when compared to end-to-end tests). </span><span class="koboSpan" id="kobo.63.2">Integration test suites are usually fast enough to run as a continuous integration step, but the full test suite tends not to be run locally </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">by engineers.</span></span></p>
<h3><span class="koboSpan" id="kobo.65.1">Unit tests</span></h3>
<p><span class="koboSpan" id="kobo.66.1">Unit tests </span><a id="_idIndexMarker1203"/><span class="koboSpan" id="kobo.67.1">are great at providing fast feedback during development. </span><span class="koboSpan" id="kobo.67.2">Unit testing paired with TDD is part of extreme programming practice. </span><span class="koboSpan" id="kobo.67.3">Unit tests </span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.68.1">are great at testing complicated logic or building a system from its expected output. </span><span class="koboSpan" id="kobo.68.2">Unit tests are usually fast enough to run a developer’s code against before sending their code for review and continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">The following diagram is an interpretation of the pyramid of testing. </span><span class="koboSpan" id="kobo.70.2">It can be interpreted to mean that you should have a high number of cheap and fast unit tests, a reasonable number of system tests, and just a few end-to-end </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">UI tests:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer304">
<span class="koboSpan" id="kobo.72.1"><img alt="Figure 11.1 – Pyramid of testing diagram" src="image/Figure_11.01_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.73.1">Figure 11.1 – Pyramid of testing diagram</span></p>
<p><span class="koboSpan" id="kobo.74.1">Now that we’ve looked at why we should be testing applications, let’s start writing </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">some tests.</span></span></p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor450"/><span class="koboSpan" id="kobo.76.1">Building your first test</span></h1>
<p><span class="koboSpan" id="kobo.77.1">To illustrate how quick and easy it is to get started with automated tests in a Vue 3 project, we will </span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.78.1">start by creating a simple test using Vitest (</span><a href="https://vitest.dev/"><span class="koboSpan" id="kobo.79.1">https://vitest.dev/</span></a><span class="koboSpan" id="kobo.80.1">), the officially </span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.81.1">recommended testing framework for Vue 3 and the simplest to begin with as the installation steps of a new application let you select it </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">right away.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">In the following figure, you can see the prompt for </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">installing Vitest:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer305">
<span class="koboSpan" id="kobo.85.1"><img alt="Figure 11.2 – Creating an application and selecting Yes to using Vitest" src="image/Figure_11.02_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.86.1">Figure 11.2 – Creating an application and selecting Yes to using Vitest</span></p>
<p><span class="koboSpan" id="kobo.87.1">After the application is scaffolded, you will find it created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">__tests__</span></strong><span class="koboSpan" id="kobo.89.1"> folder under </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">components</span></strong><span class="koboSpan" id="kobo.91.1"> and created a test already. </span><span class="koboSpan" id="kobo.91.2">For now though, delete the file (but not the folder) and create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">__tests__</span></strong><span class="koboSpan" id="kobo.93.1"> folder directly under the root of you project. </span><span class="koboSpan" id="kobo.93.2">Next, create an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">App.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.95.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">shallowMount</span></strong><span class="koboSpan" id="kobo.98.1"> to render the application and test whether it displays </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">The Vue.js Workshop Blog</span></strong><span class="koboSpan" id="kobo.100.1">. </span><span class="koboSpan" id="kobo.100.2">For the purposes of this example, we’ll use the text </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">The Vue.js Workshop Blog</span></strong><span class="koboSpan" id="kobo.102.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">shallowMount</span></strong><span class="koboSpan" id="kobo.104.1"> does a </span><em class="italic"><span class="koboSpan" id="kobo.105.1">shallow render</span></em><span class="koboSpan" id="kobo.106.1">, which means that only the top level of a component is rendered; all the child components </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">are stubbed.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">This is useful for testing a component in isolation since the child components’ implementations are </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">not run:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
import { describe, it, expect } from 'vitest'
import { shallowMount } from '@vue/test-utils'
import App from '../src/App.vue'
describe('App', () =&gt; {
  it('App renders blog title correctly', () =&gt; {
    const wrapper = shallowMount(App)
    expect(wrapper.text()).toContain('The Vue.js Workshop
                                      Blog')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.111.1">Save this file, and at the Terminal (ensure you’ve already run </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">npm install</span></strong><span class="koboSpan" id="kobo.113.1"> to finish creating a new application), run </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">run test:unit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">When you </span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.118.1">indicated in the installation prompt that you wanted to include Vitest, it added the following script to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">package.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
    "test:unit": "vitest --environment jsdom"</span></pre>
<p><span class="koboSpan" id="kobo.122.1">You will get a report on the test run and its </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">immediate failure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer306">
<span class="koboSpan" id="kobo.124.1"><img alt="Figure 11.3 – The unit test running and failing" src="image/Figure_11.03_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.125.1">Figure 11.3 – The unit test running and failing</span></p>
<p><span class="koboSpan" id="kobo.126.1">To make the test pass, we can edit our </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">App.vue</span></strong><span class="koboSpan" id="kobo.128.1"> file to include the header we want (note that we also removed much of the code created </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">by default):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
&lt;script setup&gt;
&lt;/script&gt;
&lt;template&gt;
  &lt;header&gt;
  &lt;h1&gt;The Vue.js Workshop Blog&lt;/h1&gt;
  &lt;/header&gt;
&lt;/template&gt;
&lt;style&gt;
&lt;/style&gt;</span></pre>
<p><span class="koboSpan" id="kobo.131.1">Save the </span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.132.1">file and you’ll immediately see </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">the result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer307">
<span class="koboSpan" id="kobo.134.1"><img alt="Figure 11.4 – The test passing!" src="image/Figure_11.04_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.135.1">Figure 11.4 – The test passing!</span></p>
<p><span class="koboSpan" id="kobo.136.1">You have just completed your first piece of TDD. </span><span class="koboSpan" id="kobo.136.2">This process started by writing a test that failed. </span><span class="koboSpan" id="kobo.136.3">This failure was followed by an update to the code under test (in this case the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">App.vue</span></strong><span class="koboSpan" id="kobo.138.1"> component), which made the failing </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">test pass.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">The TDD process </span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.141.1">gives us confidence that our features have been tested properly since we can see that tests fail before they pass when we update the code that drives </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">our feature.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">In the next section, we’ll show how to take what we’ve learned and apply it to </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">Vue components.</span></span></p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor451"/><span class="koboSpan" id="kobo.145.1">Testing components</span></h1>
<p><span class="koboSpan" id="kobo.146.1">Components are at the core Vue.js applications. </span><span class="koboSpan" id="kobo.146.2">Writing unit tests for them is straightforward </span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.147.1">with Vitest. </span><span class="koboSpan" id="kobo.147.2">Having tests that exercise the majority of your components gives you confidence that they behave as designed. </span><span class="koboSpan" id="kobo.147.3">Ideal unit tests for components run quickly and </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">are simple.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">We’ll carry on building the blog application example. </span><span class="koboSpan" id="kobo.149.2">We have now built the heading, but a blog usually also needs a list of posts </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">to display.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">We’ll create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">PostList</span></strong><span class="koboSpan" id="kobo.153.1"> component. </span><span class="koboSpan" id="kobo.153.2">For now, it will just render a </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">div</span></strong><span class="koboSpan" id="kobo.155.1"> wrapper and support a </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">posts </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">Array</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.158.1"> prop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
&lt;script setup&gt;
defineProps({
  posts: {
    type: Array,
      default: () =&gt; []
  }
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.160.1">We can </span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.161.1">add some data in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">App</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
&lt;script&gt;
export default {
  data() {
    return {
      posts: [
        {
          title: 'Vue.js for React developers',
            description: 'React has massive popularity here
              are the key benefits of Vue.js over it.',
                tags: ['vue', 'react'],
        },
        {
          title: 'Migrating an AngularJS app to Vue.js',
            description: 'With many breaking changes,
              AngularJS developers have found it easier to
                retrain to Vue.js than Angular 2',
                  tags: ['vue', 'angularjs']
        }
      ]
    }
  }
}
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.165.1">Now that </span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.166.1">we have some posts, we can pass them as a bound prop to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">PostList</span></strong><span class="koboSpan" id="kobo.168.1"> component from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">App</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
&lt;script setup&gt;
import PostList from './components/PostList.vue'
&lt;/script&gt;
&lt;template&gt;
  &lt;header&gt;
  &lt;h1&gt;The Vue.js Workshop Blog&lt;/h1&gt;
  &lt;/header&gt;
  &lt;PostList :posts="posts" /&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.172.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">PostList</span></strong><span class="koboSpan" id="kobo.174.1"> component will render out each post in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">PostListItem</span></strong><span class="koboSpan" id="kobo.176.1"> component, which we’ll create </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">as follows.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">PostListItem</span></strong><span class="koboSpan" id="kobo.179.1"> takes two props: </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">title</span></strong><span class="koboSpan" id="kobo.181.1"> (which is a string) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">description</span></strong><span class="koboSpan" id="kobo.183.1"> (also a string). </span><span class="koboSpan" id="kobo.183.2">It renders them in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">h3</span></strong><span class="koboSpan" id="kobo.185.1"> tag and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">p</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.187.1">tag, respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
&lt;script setup&gt;
defineProps({
  title: {
    type: String
  },
  description: {
    type: String
  }
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
  &lt;h3&gt;{{ title }}&lt;/h3&gt;
  &lt;p&gt;{{ description }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.189.1">We now </span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.190.1">need to loop through the posts and render out a </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">PostListItem</span></strong><span class="koboSpan" id="kobo.192.1"> component with relevant props bound in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">PostList.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.195.1">
&lt;script setup&gt;
import PostListItem from './PostListItem.vue';
defineProps({
  posts: {
    type: Array,
      default: () =&gt; []
  }
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;PostListItem v-for="post in posts"
    :key="post.slug"
    :title="post.title"
    :description="post.description"/&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.196.1">To test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">PostListItem</span></strong><span class="koboSpan" id="kobo.198.1"> component, we can do a shallow render with some arbitrary </span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.199.1">title and description props set, and check that they get rendered. </span><span class="koboSpan" id="kobo.199.2">Add a new file to </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">src/__tests__</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.201.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">PostListItem.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
import { describe, it, expect } from 'vitest'
import { shallowMount } from '@vue/test-utils';
import PostListItem from '../components/PostListItem.vue';
describe('PostListItem', () =&gt; {
  it('PostListItem renders title and description
  correctly', () =&gt; {
    const wrapper = shallowMount(PostListItem, {
      propsData: {
        title: "Blog post title",
        description: "Blog post description"
      }
    })
    expect(wrapper.text()).toMatch("Blog post title")
    expect(wrapper.text()).toMatch("Blog post description")
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.205.1">This test </span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.206.1">can be run individually at the command line by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">npm run test:unit __tests__/PostListItem.test.js</span></strong><span class="koboSpan" id="kobo.208.1"> command (as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.209.1">Figure 11</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.210.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer308">
<span class="koboSpan" id="kobo.212.1"><img alt="Figure 11.5 – PostListItem test output" src="image/Figure_11.05_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.213.1">Figure 11.5 – PostListItem test output</span></p>
<p><span class="koboSpan" id="kobo.214.1">Next, we’ll see one of the pitfalls of shallow rendering. </span><span class="koboSpan" id="kobo.214.2">When testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">PostList</span></strong><span class="koboSpan" id="kobo.216.1"> component, all we can do is test the number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">PostListItem</span></strong><span class="koboSpan" id="kobo.218.1"> components </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">it’s rendering.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">Save </span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.221.1">this test </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">__tests__/PostList.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.225.1">
import { describe, it, expect } from 'vitest'
import { shallowMount } from '@vue/test-utils';
import PostList from '../src/components/PostList.vue';
import PostListItem from '../src/components/PostListItem.vue';
describe('PostList', () =&gt; {
  it('PostList renders the right number of PostListItem',
  () =&gt; {
    const wrapper = shallowMount(PostList, {
      propsData: {
        posts:  [
          {
            title: "Blog post title",
            description: "Blog post description"
          }
        ]
      }
    })
    expect(wrapper.findAllComponents(PostListItem))
      .toHaveLength(1);
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.226.1">This passes, but we </span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.227.1">are testing something that the user will not directly interact with, the number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">PostListItem</span></strong><span class="koboSpan" id="kobo.229.1"> instances rendered in </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">PostList</span></strong><span class="koboSpan" id="kobo.231.1">, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer309">
<span class="koboSpan" id="kobo.233.1"><img alt="Figure 11.6 – PostList test output" src="image/Figure_11.06_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.234.1">Figure 11.6 – PostList test output</span></p>
<p><span class="koboSpan" id="kobo.235.1">A better solution is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">mount</span></strong><span class="koboSpan" id="kobo.237.1"> function, which renders the full component tree, whereas the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">shallowMount</span></strong><span class="koboSpan" id="kobo.239.1"> function would only render out the children of the component being rendered. </span><span class="koboSpan" id="kobo.239.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">mount</span></strong><span class="koboSpan" id="kobo.241.1">, we can assert that the titles and descriptions are rendered to </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">the page.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">The drawback of this approach is that we’re testing both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">PostList</span></strong><span class="koboSpan" id="kobo.245.1"> component and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">PostListItem</span></strong><span class="koboSpan" id="kobo.247.1"> component since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">PostList</span></strong><span class="koboSpan" id="kobo.249.1"> component doesn’t render the title or description; it renders a set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">PostListItem</span></strong><span class="koboSpan" id="kobo.251.1"> components that in turn render the relevant title </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">and description.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
import { describe, it, expect } from 'vitest'
import { shallowMount, mount } from '@vue/test-utils';
import PostList from '../src/components/PostList.vue';
import PostListItem from '../src/components/PostListItem.vue';
describe('PostList', () =&gt; {
  // Previous test…
  it('PostList renders passed title and description for
  each passed post', () =&gt; {
    const wrapper = mount(PostList, {
      propsData: {
        posts:  [
          {
            title: "Title 1",
            description: "Description 1"
          },
          {
            title: "Title 2",
            description: "Description 2"
          }
        ]
      }
    })
    const outputText = wrapper.text()
    expect(outputText).toContain('Title 1')
    expect(outputText).toContain('Description 1')
    expect(outputText).toContain('Title 2')
    expect(outputText).toContain('Description 2')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.256.1">The new </span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.257.1">tests pass as indicated by the following output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">npm run test:unit </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">__tests__/PostList.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer310">
<span class="koboSpan" id="kobo.261.1"><img alt="Figure 11.7 – Test run for PostList with both shallow and mounted tests" src="image/Figure_11.07_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.262.1">Figure 11.7 – Test run for PostList with both shallow and mounted tests</span></p>
<p><span class="koboSpan" id="kobo.263.1">We have now seen how to write unit tests for Vue.js with Vitest and </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">vue-test-utils</span></strong><span class="koboSpan" id="kobo.265.1">. </span><span class="koboSpan" id="kobo.265.2">These tests can be run often and the test runs complete within seconds, which gives us near-immediate feedback while working on new or </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">existing components.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor452"/><span class="koboSpan" id="kobo.267.1">Exercise 11.01: Building and unit testing a tag list component</span></h2>
<p><span class="koboSpan" id="kobo.268.1">When </span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.269.1">creating the fixture for </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">posts</span></strong><span class="koboSpan" id="kobo.271.1">, we populated </span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.272.1">a tags field with </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">vue</span></strong><span class="koboSpan" id="kobo.274.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">angularjs</span></strong><span class="koboSpan" id="kobo.276.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">react</span></strong><span class="koboSpan" id="kobo.278.1"> but did not </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">display them.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">The complete code for this exercise can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.01"><span class="No-Break"><span class="koboSpan" id="kobo.282.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.01</span></span></a></p>
<p><span class="koboSpan" id="kobo.283.1">To make </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.284.1">tags useful, we will display the tags in the </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">post list:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.286.1">We can </span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.287.1">start by writing a unit test that will explain what we expect a </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">PostListItem</span></strong><span class="koboSpan" id="kobo.289.1"> component to do when passed a set of tags as props. </span><span class="koboSpan" id="kobo.289.2">It expects that each tag will be rendered with a hashtag prepended </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">to it.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.291.1">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">react</span></strong><span class="koboSpan" id="kobo.293.1"> tag will be shown as </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">#react</span></strong><span class="koboSpan" id="kobo.295.1">. </span><span class="koboSpan" id="kobo.295.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">__tests__/PostListItem.test.js</span></strong><span class="koboSpan" id="kobo.297.1"> file, we can add a </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">new test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
// rest of test and imports
it('PostListItem renders tags with a # prepended to them', () =&gt; {
  const wrapper = shallowMount(PostListItem, {
    propsData: {
      tags: ['react', 'vue']
    }
  })
  expect(wrapper.text()).toMatch('#react')
  expect(wrapper.text()).toMatch('#vue')
})</span></pre>
<p><span class="koboSpan" id="kobo.300.1">This test fails when run with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">npm run test:unit __tests__/PostListItem.test.js</span></strong><span class="koboSpan" id="kobo.302.1"> command, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.303.1">Figure 11</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.304.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer311">
<span class="koboSpan" id="kobo.306.1"><img alt="Figure 11.8 – Tag test for PostListItem failing" src="image/Figure_11.08_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1">Figure 11.8 – Tag test for PostListItem failing</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.308.1">Next, we </span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.309.1">should implement the tag list rendering </span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.310.1">in </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">src/components/PostListItem.vue</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">We’ll add tags as props of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Array</span></strong><span class="koboSpan" id="kobo.314.1"> type and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">v-for</span></strong><span class="koboSpan" id="kobo.316.1"> to render out </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the tags:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.318.1">
&lt;script setup&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.319.1">
defineProps({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.320.1">
  title: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.321.1">
    type: String</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.322.1">
  },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.323.1">
  description: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.324.1">
    type: String</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.325.1">
  },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.326.1">
  tags: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.327.1">
    type: Array,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.328.1">
    default: () =&gt; []</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.329.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.330.1">
})</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.331.1">
&lt;/script&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.332.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.333.1">
  &lt;div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.334.1">
  &lt;h3&gt;{{ title }}&lt;/h3&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.335.1">
  &lt;p&gt;{{ description }}&lt;/p&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.336.1">
  &lt;ul&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.337.1">
    &lt;li</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.338.1">
    v-for="tag in tags"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.339.1">
    :key="tag"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.340.1">
    #{{ tag }}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.341.1">
    &lt;/li&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.342.1">
  &lt;/ul&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.343.1">
  &lt;/div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.344.1">
&lt;/template&gt;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.345.1">With </span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.346.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">PostListItem</span></strong><span class="koboSpan" id="kobo.348.1"> component implemented, the </span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.349.1">unit test should </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">now pass:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer312">
<span class="koboSpan" id="kobo.351.1"><img alt="Figure 11.9 – PostListItem unit test passing" src="image/Figure_11.09_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.352.1">Figure 11.9 – PostListItem unit test passing</span></p>
<p><span class="koboSpan" id="kobo.353.1">However, the </span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.354.1">tags are not displayed in </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">the </span></span><span class="No-Break"><a id="_idIndexMarker1228"/></span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer313">
<span class="koboSpan" id="kobo.357.1"><img alt="Figure 11.10 – PostList displaying without tags despite the correct PostListItem implementation" src="image/Figure_11.10_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.358.1">Figure 11.10 – PostList displaying without tags despite the correct PostListItem implementation</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.359.1">We can write a unit test for </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">PostList</span></strong><span class="koboSpan" id="kobo.361.1"> that would show this behavior. </span><span class="koboSpan" id="kobo.361.2">In essence, we’ll be passing some tags in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">posts</span></strong><span class="koboSpan" id="kobo.363.1"> list and running the same assertions as are already present in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">PostListItem.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.365.1"> file.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.366.1">We’ll do this </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">__tests__/PostList.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
it('PostList renders tags for each post', () =&gt; {
  const wrapper = mount(PostList, {
    propsData: {
      posts:  [
              {
                tags: ['react', 'vue']
              },
              {
                tags: ['html', 'angularjs']
              }
              ]
    }
  })
  const outputText = wrapper.text()
  expect(outputText).toContain('#react')
  expect(outputText).toContain('#vue')
  expect(outputText).toContain('#html')
  expect(outputText).toContain('#angularjs')
})</span></pre>
<p><span class="koboSpan" id="kobo.371.1">As per </span><a id="_idIndexMarker1229"/><span class="koboSpan" id="kobo.372.1">our application output shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.373.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.374.1">.11</span></em><span class="koboSpan" id="kobo.375.1">, the test </span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.376.1">is failing when run with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">npm run test:unit </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">__tests__/PostList.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer314">
<span class="koboSpan" id="kobo.380.1"><img alt="Figure 11.11 – PostList tags test failing" src="image/Figure_11.11_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.381.1">Figure 11.11 – PostList tags test failing</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.382.1">In order </span><a id="_idIndexMarker1231"/><span class="koboSpan" id="kobo.383.1">to fix this test, we can find the issue </span><a id="_idIndexMarker1232"/><span class="koboSpan" id="kobo.384.1">in </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">src/components/PostList.vue</span></strong><span class="koboSpan" id="kobo.386.1">, where the tags prop for </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">PostListItem</span></strong><span class="koboSpan" id="kobo.388.1"> is not bound. </span><span class="koboSpan" id="kobo.388.2">By updating </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">src/components/PostList.vue</span></strong><span class="koboSpan" id="kobo.390.1"> to bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">tags</span></strong><span class="koboSpan" id="kobo.392.1"> prop, we can fix the </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">unit test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.394.1">
&lt;!-- rest of template --&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.395.1">
&lt;PostListItem v-for="post in posts"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.396.1">
  :key="post.slug"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.397.1">
  :title="post.title"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.398.1">
  :description="post.description"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
  :tags="post.tags"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.400.1">
/&gt;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.401.1">The failing unit test now passes, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">following screenshot.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer315">
<span class="koboSpan" id="kobo.403.1"><img alt="Figure 11.12 – PostList tags test passing" src="image/Figure_11.12_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.404.1">Figure 11.12 – PostList tags test passing</span></p>
<p><span class="koboSpan" id="kobo.405.1">We have </span><a id="_idIndexMarker1233"/><span class="koboSpan" id="kobo.406.1">now seen how we can test rendered component </span><a id="_idIndexMarker1234"/><span class="koboSpan" id="kobo.407.1">output with both the shallow rendering and mounting of components. </span><span class="koboSpan" id="kobo.407.2">Let’s briefly understand what each of these </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">terms means:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.409.1">Shallow rendering</span></strong><span class="koboSpan" id="kobo.410.1">: This </span><a id="_idIndexMarker1235"/><span class="koboSpan" id="kobo.411.1">renders at a depth of </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">1</span></strong><span class="koboSpan" id="kobo.413.1">, meaning that if children are components, they will just be rendered as the component tag; their template will not </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">be run</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.415.1">Mounting</span></strong><span class="koboSpan" id="kobo.416.1">: This </span><a id="_idIndexMarker1236"/><span class="koboSpan" id="kobo.417.1">renders the full component tree in a similar fashion as would be rendered in </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">the browser</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.419.1">Next, we’ll look at how to test </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">component methods.</span></span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor453"/><span class="koboSpan" id="kobo.421.1">Testing component methods</span></h1>
<p><span class="koboSpan" id="kobo.422.1">In the previous version of Vue, the recommendation would have been to do testing on filters </span><a id="_idIndexMarker1237"/><span class="koboSpan" id="kobo.423.1">and mixins, but typically avoid writing tests for methods as they aren’t directly called </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">by users.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">In Vue 3, both filters and mixins are deprecated and replaced with </span><em class="italic"><span class="koboSpan" id="kobo.426.1">regular</span></em><span class="koboSpan" id="kobo.427.1"> methods and computed properties. </span><span class="koboSpan" id="kobo.427.2">That being said, finding the methods appropriate for tests may require </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">some thought.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">Consider a </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">computed</span></strong><span class="koboSpan" id="kobo.431.1"> property </span><a id="_idIndexMarker1238"/><span class="koboSpan" id="kobo.432.1">that truncates its input to </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">eight characters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
// rest of file…
import { computed } from 'vue';
const props = defineProps({
  title: {
    type: String
  },
  description: {
    type: String
  },
  tags: {
    type: Array,
    default: () =&gt; []
  }
})
const truncated = computed(() =&gt; {
  return props.description &amp;&amp; props.description.slice(0,8)
})
defineExpose({ truncated })</span></pre>
<p><span class="koboSpan" id="kobo.435.1">In the preceding code sample, </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">truncated</span></strong><span class="koboSpan" id="kobo.437.1"> is defined as a computed property based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">description</span></strong><span class="koboSpan" id="kobo.439.1"> value passed as a property. </span><span class="koboSpan" id="kobo.439.2">At the end, </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">defineExpose</span></strong><span class="koboSpan" id="kobo.441.1"> is used to make the property available for testing. </span><span class="koboSpan" id="kobo.441.2">Items that are specified within </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">script setup</span></strong><span class="koboSpan" id="kobo.443.1"> are considered </span><em class="italic"><span class="koboSpan" id="kobo.444.1">closed</span></em><span class="koboSpan" id="kobo.445.1"> and are not available outside the component itself. </span><span class="koboSpan" id="kobo.445.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">defineExpose</span></strong><span class="koboSpan" id="kobo.447.1">, we can then write a test </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">against </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">truncated</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">We can test the logic of the computed property in two ways. </span><span class="koboSpan" id="kobo.451.2">First, longer strings should be truncated. </span><span class="koboSpan" id="kobo.451.3">Secondly, shorter strings should be returned </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">as is.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">Here are </span><a id="_idIndexMarker1239"/><span class="koboSpan" id="kobo.454.1">the additional tests added </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">PostListItem.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
it('truncated properly returns only the first 8 characters', () =&gt; {
  const wrapper = shallowMount(PostListItem, {
    propsData: {
      title: "Blog post title",
      description: "Blog post description"
    }
  })
  expect(wrapper.vm.truncated).toMatch('Blog pos')
})
it('truncated properly doesnt change shorter values', () =&gt; {
  const wrapper = shallowMount(PostListItem, {
    propsData: {
      title: "Blog post title",
      description: "Test"
    }
  })
  expect(wrapper.vm.truncated).toMatch('Test')
})</span></pre>
<p><span class="koboSpan" id="kobo.459.1">The first new test passes a long value for description and confirms that the truncated version is shorter. </span><span class="koboSpan" id="kobo.459.2">Note the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">vm</span></strong><span class="koboSpan" id="kobo.461.1"> to access the Vue instance of the component and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">truncated</span></strong><span class="koboSpan" id="kobo.463.1"> computed property. </span><span class="koboSpan" id="kobo.463.2">The next test confirms that if a shorter value is used, truncated will not </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">shorten it.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Remember </span><a id="_idIndexMarker1240"/><span class="koboSpan" id="kobo.466.1">that a user would not actually call </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">truncated</span></strong><span class="koboSpan" id="kobo.468.1"> directly. </span><span class="koboSpan" id="kobo.468.2">As an alternative to directly testing the computed property, we could confirm that any template usage works properly as well. </span><span class="koboSpan" id="kobo.468.3">In that case, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">wrapper.text()</span></strong><span class="koboSpan" id="kobo.470.1"> would make sense to return the </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">rendered result.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor454"/><span class="koboSpan" id="kobo.472.1">Exercise 11.02: Building and testing an ellipsis method</span></h2>
<p><span class="koboSpan" id="kobo.473.1">We have </span><a id="_idIndexMarker1241"/><span class="koboSpan" id="kobo.474.1">seen how to test an arbitrary </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">truncated</span></strong><span class="koboSpan" id="kobo.476.1"> computed </span><a id="_idIndexMarker1242"/><span class="koboSpan" id="kobo.477.1">method; we will now implement an </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">ellipsis</span></strong><span class="koboSpan" id="kobo.479.1"> computed method and </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">test it.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">The complete code for this exercise can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.02"><span class="No-Break"><span class="koboSpan" id="kobo.483.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.02</span></span></a></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.484.1">We can start by writing a set of tests for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">ellipsis</span></strong><span class="koboSpan" id="kobo.486.1"> computed method (which will live in </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">src/components/PostListItem.vue</span></strong><span class="koboSpan" id="kobo.488.1">). </span><span class="koboSpan" id="kobo.488.2">One test should check that the filter does nothing if the passed value is less than 50 characters; another should check whether the passed value is more than 50 characters and if so, truncate the value to 50 and </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">appends </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">…</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.492.1">We will do this in a</span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">__tests__/ellipsis.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
// rest of script
describe('ellipsis', () =&gt; {
  it('ellipsis should do nothing if value is less
  than 50 characters', () =&gt; {
     const wrapper = shallowMount(PostListItem, {
       propsData: {
         title: "Blog post title",
         description: "Test"
       }
     })
     expect(wrapper.vm.truncated).toMatch('Test')
  })
  it('ellipsis should truncate to 50 and append "..."
</span><span class="koboSpan" id="kobo.495.2">  when longer than 50 characters', () =&gt; {
     const wrapper = shallowMount(PostListItem, {
       propsData: {
         title: "Blog post title",
         description: "Should be more than
         the 50 allowed characters by a small amount"
       }
     })
     expect(wrapper.vm.truncated).toMatch('Should be
       more than the 50 allowed characters by a...')
  })
})</span></pre>
<ol>
<li value="2"><span class="koboSpan" id="kobo.496.1">We can </span><a id="_idIndexMarker1243"/><span class="koboSpan" id="kobo.497.1">now implement the logic for </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">ellipsis</span></strong><span class="koboSpan" id="kobo.499.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">src/components/PostListItem.vue</span></strong><span class="koboSpan" id="kobo.501.1">. </span><span class="koboSpan" id="kobo.501.2">We will add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">computed</span></strong><span class="koboSpan" id="kobo.503.1"> object </span><a id="_idIndexMarker1244"/><span class="koboSpan" id="kobo.504.1">with </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">ellipsis</span></strong><span class="koboSpan" id="kobo.506.1">, which will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">String#slice</span></strong><span class="koboSpan" id="kobo.508.1"> if the passed value is longer than 50 characters and do </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">nothing otherwise:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.510.1">
&lt;script setup&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.511.1">
// rest of script</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.512.1">
const ellipsis = computed(() =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.513.1">
  return props.description &amp;&amp; props.description.length</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.514.1">
    &gt; 50 ? </span><span class="koboSpan" id="kobo.514.2">`${props.description.slice(0,50)}...` :</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.515.1">
      props.description;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.516.1">
})</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.517.1">
defineExpose({ truncated, ellipsis })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.518.1">
&lt;/script&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.519.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.520.1">
  &lt;div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.521.1">
  &lt;h3&gt;{{ title }}&lt;/h3&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.522.1">
  &lt;p&gt;{{ ellipsis }}&lt;/p&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.523.1">
  &lt;ul&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.524.1">
    &lt;li v-for="tag in tags" :key="tag"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.525.1">
    #{{ tag }}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.526.1">
    &lt;/li&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.527.1">
  &lt;/ul&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.528.1">
  &lt;/div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.529.1">
&lt;/template&gt;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.530.1">As you </span><a id="_idIndexMarker1245"/><span class="koboSpan" id="kobo.531.1">can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">ellipsis</span></strong><span class="koboSpan" id="kobo.533.1"> computed method </span><a id="_idIndexMarker1246"/><span class="koboSpan" id="kobo.534.1">works on the description prop and handles trimming values longer than 50 characters. </span><span class="koboSpan" id="kobo.534.2">The tests now pass as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.535.1">Figure 11</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.536.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer316">
<span class="koboSpan" id="kobo.538.1"><img alt="Figure 11.13 – Ellipsis tests now passing" src="image/Figure_11.13_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.539.1">Figure 11.13 – Ellipsis tests now passing</span></p>
<p><span class="koboSpan" id="kobo.540.1">We have now seen how to test methods and computed properties of a </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">Vue.js component.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">Next, we will see how to deal with an application that uses </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">Vue.js routing.</span></span></p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor455"/><span class="koboSpan" id="kobo.544.1">Testing Vue routing</span></h1>
<p><span class="koboSpan" id="kobo.545.1">We have currently got an application that renders our blog home page or </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">feed view.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Next, we should </span><a id="_idIndexMarker1247"/><span class="koboSpan" id="kobo.548.1">have post pages. </span><span class="koboSpan" id="kobo.548.2">To do this, we will use Vue Router, as covered in previous chapters, and ensure that our routing works as designed with </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">Vue Router is installed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">npm</span></strong><span class="koboSpan" id="kobo.552.1">, specifically, </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">npm install vue-router@4</span></strong><span class="koboSpan" id="kobo.554.1">, and then wiring it up in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">main.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
import { createApp } from 'vue'
import App from './App.vue'
import router from './router';
createApp(App).use(router).mount('#app')</span></pre>
<p><span class="koboSpan" id="kobo.558.1">Next, we can create a file to define our routes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">src/router/index.js</span></strong><span class="koboSpan" id="kobo.560.1">. </span><span class="koboSpan" id="kobo.560.2">This will instantiate the router and define our initial paths. </span><span class="koboSpan" id="kobo.560.3">We will begin with a root path (</span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">/</span></strong><span class="koboSpan" id="kobo.562.1">) to display the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">PostList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.564.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
import { createRouter, createWebHistory } from
'vue-router';
import PostList from '@/components/PostList.vue';
const routes = [
  {
    path: '/',
    component: PostList
  }
];
const router = createRouter({
  history: createWebHistory(),
  routes
});
export default router;</span></pre>
<p><span class="koboSpan" id="kobo.566.1">Now that we’ve got our initial route, we should update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">App.vue</span></strong><span class="koboSpan" id="kobo.568.1"> file to leverage the component </span><a id="_idIndexMarker1248"/><span class="koboSpan" id="kobo.569.1">being rendered by the router. </span><span class="koboSpan" id="kobo.569.2">We’ll render </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">render-view</span></strong><span class="koboSpan" id="kobo.571.1"> instead of directly using </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">PostList</span></strong><span class="koboSpan" id="kobo.573.1">. </span><span class="koboSpan" id="kobo.573.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">posts</span></strong><span class="koboSpan" id="kobo.575.1"> binding, however, stays </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">the same:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.577.1">
&lt;!—rest of file… --&gt;
&lt;template&gt;
  &lt;header&gt;
  &lt;h1&gt;The Vue.js Workshop Blog&lt;/h1&gt;
  &lt;/header&gt;
  &lt;router-view :posts="posts"&gt;&lt;/router-view&gt;
&lt;/template&gt;—-- rest of file... </span><span class="koboSpan" id="kobo.577.2">--&gt;</span></pre>
<p><span class="koboSpan" id="kobo.578.1">Now, our posts in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">App.vue</span></strong><span class="koboSpan" id="kobo.580.1"> file are missing a bit of core data to render a </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">SinglePost</span></strong><span class="koboSpan" id="kobo.582.1"> component. </span><span class="koboSpan" id="kobo.582.2">We need to make sure to have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">slug</span></strong><span class="koboSpan" id="kobo.584.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">content</span></strong><span class="koboSpan" id="kobo.586.1"> properties to render something useful on our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">SinglePost</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.588.1"> page:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
&lt;script&gt;
export default {
  data() {
    return {
      posts: [
        {
          slug: 'vue-react',
          title: 'Vue.js for React developers',
          description: 'React has massive popularity here
                        are the key benefits of Vue.js over
                        it.',
          content: 'This is the content of the Vue.js for
                    React developers post.',
          tags' ['vue', 'react'],
        },
        {
          slug: 'vue-angularjs',
          title: 'Migrating an AngularJS app to Vue'js',
          description: 'With many breaking changes,
                        AngularJS developers have found it
                        easier to retrain to Vue.js than
                        Angular 2',
          content: 'This is the content of the Vue.js for
                    AngularJS developers post.',
          tags' ['vue', 'angularjs']
        }
      ]
    }
  }
}
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.590.1">We can now </span><a id="_idIndexMarker1249"/><span class="koboSpan" id="kobo.591.1">start working on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">SinglePost</span></strong><span class="koboSpan" id="kobo.593.1"> component. </span><span class="koboSpan" id="kobo.593.2">For now, we'll just have some placeholders in the template. </span><span class="koboSpan" id="kobo.593.3">Also, </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">SinglePost</span></strong><span class="koboSpan" id="kobo.595.1"> will receive posts as a prop, so we can fill that in </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.597.1">
&lt;script setup&gt;
defineProps({
  posts: {
    type: Array,
      default: () =&gt; []
  }
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
  &lt;h2&gt;Post: RENDER ME&lt;/h2&gt;
  &lt;p&gt;Placeholder for post.content.&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.598.1">Next, we will </span><a id="_idIndexMarker1250"/><span class="koboSpan" id="kobo.599.1">register </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">SinglePost</span></strong><span class="koboSpan" id="kobo.601.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">router/index.js</span></strong><span class="koboSpan" id="kobo.603.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">/:postId</span></strong><span class="koboSpan" id="kobo.605.1"> path (which will be available to the component </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">under </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">this.$route.params.postId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.609.1">
import { createRouter, createWebHistory } from
'vue-router';
import PostList from '@/components/PostList.vue';
import SinglePost from '@/components/SinglePost.vue';
const routes = [
  {
    path: '/',
    component: PostList
  },
  {
    path: '/:postId',
    component: SinglePost
  }
];
const router = createRouter({
  history: createWebHistory(),
  routes
});
export default router;</span></pre>
<p><span class="koboSpan" id="kobo.610.1">If we switch back to implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">SinglePost</span></strong><span class="koboSpan" id="kobo.612.1"> component, we’ve got access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">postId</span></strong><span class="koboSpan" id="kobo.614.1">, which will map to the slug in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">posts</span></strong><span class="koboSpan" id="kobo.616.1"> array, and we’ve also got access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">posts</span></strong><span class="koboSpan" id="kobo.618.1"> since it’s being bound onto </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">render-view</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.620.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">App</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">Now we can </span><a id="_idIndexMarker1251"/><span class="koboSpan" id="kobo.624.1">create a computed property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">post</span></strong><span class="koboSpan" id="kobo.626.1">, which finds posts based </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">postId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
// other imports
import { useRoute } from 'vue-router';
// props code
const route = useRoute();
const post = computed(() =&gt; {
  const { postId } = route.params;
  return props.posts.find(p =&gt; p.slug === postId);
})</span></pre>
<p><span class="koboSpan" id="kobo.631.1">From this computed </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">post</span></strong><span class="koboSpan" id="kobo.633.1"> property, we can extract </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">title</span></strong><span class="koboSpan" id="kobo.635.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">content</span></strong><span class="koboSpan" id="kobo.637.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">post</span></strong><span class="koboSpan" id="kobo.639.1"> exists (we have to watch out for posts that don’t exist). </span><span class="koboSpan" id="kobo.639.2">So, still in </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">SinglePost</span></strong><span class="koboSpan" id="kobo.641.1">, we can add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">computed properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
const title = computed(() =&gt; {
  return post &amp;&amp; post.value.title;
})
const content = computed(() =&gt; {
  return post &amp;&amp; post.value.content;
})</span></pre>
<p><span class="koboSpan" id="kobo.644.1">We can then replace the placeholders in the template with the value of the computed properties. </span><span class="koboSpan" id="kobo.644.2">So, our template ends up </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
&lt;template&gt;
  &lt;div&gt;
  &lt;h2&gt;Post: {{ title }}&lt;/h2&gt;
  &lt;p&gt;{{ content }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.647.1">Now let’s update </span><a id="_idIndexMarker1252"/><span class="koboSpan" id="kobo.648.1">the application so that we can link to individual posts. </span><span class="koboSpan" id="kobo.648.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">PostList.vue</span></strong><span class="koboSpan" id="kobo.650.1">, pass the slug in as a </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">new property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.652.1">
&lt;!-- rest of template --&gt;
&lt;PostListItem v-for="post in posts"
:key="post.slug"
:title="post.title"
:description="post.description"
:tags="post.tags"
:slug="post.slug"
/&gt;
&lt;!-- rest of template --&gt;</span></pre>
<p><span class="koboSpan" id="kobo.653.1">Next, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">PostListItem</span></strong><span class="koboSpan" id="kobo.655.1">, we will first add a new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">slug</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.657.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
// rest of the props...
</span><span class="koboSpan" id="kobo.658.2">slug: {
  type: String
}</span></pre>
<p><span class="koboSpan" id="kobo.659.1">Then we edit </span><a id="_idIndexMarker1253"/><span class="koboSpan" id="kobo.660.1">the template to link with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">slug</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.662.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
&lt;template&gt;
  &lt;div&gt;
  &lt;router-link :to="`/${slug}`"&gt;
  &lt;h3&gt;{{ title }}&lt;/h3&gt;
  &lt;/router-link&gt;
  &lt;p&gt;{{ ellipsis }}&lt;/p&gt;
  &lt;ul&gt;
    &lt;li v-for="tag in tags" :key="tag"&gt;
    #{{ tag }}
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">router-link</span></strong><span class="koboSpan" id="kobo.665.1"> is a Vue Router-specific link, which means that on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">PostList</span></strong><span class="koboSpan" id="kobo.667.1"> page, upon clicking on a post list item, we are taken to the correct post’s URL, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer317">
<span class="koboSpan" id="kobo.669.1"><img alt="Figure 11.14 – Post list view displayed in the browser" src="image/Figure_11.14_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.670.1">Figure 11.14 – Post list view displayed in the browser</span></p>
<p><span class="koboSpan" id="kobo.671.1">After </span><a id="_idIndexMarker1254"/><span class="koboSpan" id="kobo.672.1">clicking on a title, the right post </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">is displayed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer318">
<span class="koboSpan" id="kobo.674.1"><img alt="Figure 11.15 – Single post view displaying in the browser" src="image/Figure_11.15_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.675.1">Figure 11.15 – Single post view displaying in the browser</span></p>
<p><span class="koboSpan" id="kobo.676.1">To test </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">vue-router</span></strong><span class="koboSpan" id="kobo.678.1">, we will need to build our tests to handle the asynchronous nature of the router. </span><span class="koboSpan" id="kobo.678.2">We’ll begin by testing that clicking on a post properly loads just the information for a single post. </span><span class="koboSpan" id="kobo.678.3">We can do this by looking for all the blog posts on the initial page, and only one particular post when a route </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">is clicked:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.680.1">
import { describe, it, expect } from 'vitest';
import { mount, flushPromises } from '@vue/test-utils'
import App from '../src/App.vue';
import router from "@/router";
describe('SinglePost', () =&gt; {
  it('Router renders single post page when clicking a post
  title', async () =&gt; {
    router.push('/');
    await router.isReady();
    const wrapper = mount(App, {
      global: {
        plugins: [router]
      }
  })
    expect(wrapper.text()).toMatch("Vue.js for React
                                    developers");
    expect(wrapper.text()).toMatch("Migrating an AngularJS
                                    app to Vue.js");
    await wrapper.find('a').trigger('click');
    await flushPromises();
    expect(wrapper.text()).toMatch("Vue.js for React
                                    developers");
    expect(wrapper.text()).not.toMatch("Migrating an
                                        AngularJS app to
                                        Vue.js2");
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.681.1">On top, we import both </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">mount</span></strong><span class="koboSpan" id="kobo.683.1"> and a new utility, </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">flushPromises</span></strong><span class="koboSpan" id="kobo.685.1">, that we’ll use later. </span><span class="koboSpan" id="kobo.685.2">We also import our router. </span><span class="koboSpan" id="kobo.685.3">In the test, we begin by navigating to the root path and as stated earlier, due to the asynchronous nature of the router, we wait for it </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">to finish.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">We then check </span><a id="_idIndexMarker1255"/><span class="koboSpan" id="kobo.688.1">for both blog posts. </span><span class="koboSpan" id="kobo.688.2">After that, we trigger a click event on the first post, wait for it to finish with </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">flushPromises</span></strong><span class="koboSpan" id="kobo.690.1">, and then check to see that only our first post </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">is rendered.</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">We should check that navigating directly to a valid post URL will yield the correct result. </span><span class="koboSpan" id="kobo.692.2">In order to this we’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">router.replace('/')</span></strong><span class="koboSpan" id="kobo.694.1"> to clear any state that’s set and then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">router.push()</span></strong><span class="koboSpan" id="kobo.696.1"> with a post slug. </span><span class="koboSpan" id="kobo.696.2">We will then use similar assertions to ensure we’re rendering just </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">one post:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
  It('Router renders single post page when a slug is set',
  async () =&gt; {
    await router.replace('/');
    await router.push('/vue-react');
    const wrapper = mount(App, {
      global: {
        plugins: [router]
      }
  })
    expect(wrapper.text()).toMatch("Vue.js for React
                                    developers");
    expect(wrapper.text()).not.toMatch("Migrating an
                                        AngularJS app to
                                        Vue.js");
  })</span></pre>
<p><span class="koboSpan" id="kobo.699.1">Those two </span><a id="_idIndexMarker1256"/><span class="koboSpan" id="kobo.700.1">tests work as expected when run with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">npm run test:unit __tests__/SinglePost.test.js</span></strong><span class="koboSpan" id="kobo.702.1"> command. </span><span class="koboSpan" id="kobo.702.2">The following screenshot displays the </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">desired output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer319">
<span class="koboSpan" id="kobo.704.1"><img alt="Figure 11.16 – Routing tests passing for SinglePost" src="image/Figure_11.16_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.705.1">Figure 11.16 – Routing tests passing for SinglePost</span></p>
<p><span class="koboSpan" id="kobo.706.1">Now that you’ve seen how to test your routes, let’s practice it with </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">an example.</span></span></p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor456"/><span class="koboSpan" id="kobo.708.1">Exercise 11.03: Building a tag page and testing its routing</span></h2>
<p><span class="koboSpan" id="kobo.709.1">Much like </span><a id="_idIndexMarker1257"/><span class="koboSpan" id="kobo.710.1">we built a single-post page, we’ll now build a tag page, which </span><a id="_idIndexMarker1258"/><span class="koboSpan" id="kobo.711.1">is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">PostList</span></strong><span class="koboSpan" id="kobo.713.1"> component except only posts with a certain tag are displayed and each post is a link to a relevant </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">single-post view.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">You can find the complete code </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.03"><span class="No-Break"><span class="koboSpan" id="kobo.717.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.03</span></span></a></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.718.1">We can </span><a id="_idIndexMarker1259"/><span class="koboSpan" id="kobo.719.1">start by creating a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">TagPage</span></strong><span class="koboSpan" id="kobo.721.1"> component in </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">src/components/TagPage.vue</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">We know it will receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">posts</span></strong><span class="koboSpan" id="kobo.725.1"> as a prop </span><a id="_idIndexMarker1260"/><span class="koboSpan" id="kobo.726.1">and that we want to render a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">PostList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.728.1"> component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.729.1">
&lt;script setup&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.730.1">
import PostList from './PostList.vue';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.731.1">
defineProps({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.732.1">
  posts: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.733.1">
    type: Array,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.734.1">
      default: () =&gt; []</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.735.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.736.1">
})</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.737.1">
&lt;/script&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.738.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.739.1">
  &lt;h3&gt;#INSERT_TAG_NAME&lt;/h3&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.740.1">
&lt;/template&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.741.1">Next, we want to wire the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">TagPage</span></strong><span class="koboSpan" id="kobo.743.1"> component to the router in </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">src/router.js</span></strong><span class="koboSpan" id="kobo.745.1">. </span><span class="koboSpan" id="kobo.745.2">We’ll import it and add it as part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">routes</span></strong><span class="koboSpan" id="kobo.747.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">tags/:tagName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1"> path:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.751.1">
// other imports</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.752.1">
import TagPage from '@/components/TagPage.vue';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.753.1">
const routes = [</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.754.1">
  // other routes</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.755.1">
  {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.756.1">
    path:'/tags/:tagName',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.757.1">
    component: TagPage</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.758.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.759.1">
];</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.760.1">
// router instantiation and export</span></pre></li>
<li><span class="koboSpan" id="kobo.761.1">Back in </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">TagPage.vue</span></strong><span class="koboSpan" id="kobo.763.1">, we can </span><a id="_idIndexMarker1261"/><span class="koboSpan" id="kobo.764.1">now use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">tagName</span></strong><span class="koboSpan" id="kobo.766.1"> param </span><a id="_idIndexMarker1262"/><span class="koboSpan" id="kobo.767.1">and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">tagName</span></strong><span class="koboSpan" id="kobo.769.1"> computed property as well as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">tagPosts</span></strong><span class="koboSpan" id="kobo.771.1"> computed property that filters based on </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">the tag.</span></span><pre class="source-code"><span class="koboSpan" id="kobo.773.1">
import { computed } from 'vue';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.774.1">
import { useRoute } from 'vue-router';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.775.1">
const props = defineProps({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.776.1">
  posts: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.777.1">
    type: Array,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.778.1">
      default: () =&gt; []</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.779.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.780.1">
})</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.781.1">
const route = useRoute();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.782.1">
const tagName = computed(() =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.783.1">
  return route.params.tagName;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.784.1">
})</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.785.1">
const tagPosts = computed(() =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.786.1">
  return props.posts.filter(p =&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.787.1">
    p.tags.includes(route.params.tagName));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.788.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.789.1">Now that </span><a id="_idIndexMarker1263"/><span class="koboSpan" id="kobo.790.1">we have access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">tagPosts</span></strong><span class="koboSpan" id="kobo.792.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">tagName</span></strong><span class="koboSpan" id="kobo.794.1">, we can </span><a id="_idIndexMarker1264"/><span class="koboSpan" id="kobo.795.1">replace the placeholders in the template. </span><span class="koboSpan" id="kobo.795.2">We will render </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">#{{ tagName }}</span></strong><span class="koboSpan" id="kobo.797.1"> and bind </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">tagPosts</span></strong><span class="koboSpan" id="kobo.799.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">posts</span></strong><span class="koboSpan" id="kobo.801.1"> prop </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">PostList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.805.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.806.1">
  &lt;h3&gt;# {{ tagName }}&lt;/h3&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.807.1">
  &lt;PostLists :posts="tagPosts" /&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.808.1">
&lt;/template&gt;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.809.1">Now, the page displays something like the following if we navigate, for example, </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">/tags/angularjs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer320">
<span class="koboSpan" id="kobo.813.1"><img alt="Figure 11.17 – Tag page for angularjs" src="image/Figure_11.17_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.814.1">Figure 11.17 – Tag page for angularjs</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.815.1">The next step is to convert the tag anchors (</span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">a</span></strong><span class="koboSpan" id="kobo.817.1">) in </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">PostListItem</span></strong><span class="koboSpan" id="kobo.819.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">router-link</span></strong><span class="koboSpan" id="kobo.821.1"> that points to </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">/tags/${tagName}</span></strong><span class="koboSpan" id="kobo.823.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">src/components/PostListItem.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.827.1">
  &lt;router-link :to="`/tags/${tag}`"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
  v-for="tag in tags" :key="tags"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.829.1">
  #{{ tag }}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.830.1">
  &lt;/router-link&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.831.1">Now it is </span><a id="_idIndexMarker1265"/><span class="koboSpan" id="kobo.832.1">time to write some tests. </span><span class="koboSpan" id="kobo.832.2">We will first check that </span><a id="_idIndexMarker1266"/><span class="koboSpan" id="kobo.833.1">being on the home page and clicking on </span><strong class="bold"><span class="koboSpan" id="kobo.834.1">#angularjs</span></strong><span class="koboSpan" id="kobo.835.1"> puts us on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">angularjs</span></strong><span class="koboSpan" id="kobo.837.1"> tag page. </span><span class="koboSpan" id="kobo.837.2">We’ll write it as follows </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">__tests__/TagPage.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.841.1">
// rest of test...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.842.1">
describe('TagPage', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.843.1">
  it('Router renders tag page when clicking a tag in</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.844.1">
  the post list item', async () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.845.1">
    router.push('/');</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.846.1">
    await router.isReady();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.847.1">
    const wrapper = mount(App, {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.848.1">
      global: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.849.1">
      plugins: [router]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.850.1">
      }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.851.1">
    })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.852.1">
    expect(wrapper.text()).toMatch("Vue.js for React</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.853.1">
                                    developers");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.854.1">
    expect(wrapper.text()).toMatch("Migrating an</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.855.1">
                                    AngularJS app to</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.856.1">
                                    Vue.js");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.857.1">
    await wrapper.find('a[href="/tags/angularjs"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.858.1">
      .trigger('click');</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.859.1">
    await flushPromises();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.860.1">
    expect(wrapper.text()).toMatch("Migrating an</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.861.1">
                                    AngularJS app to</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.862.1">
                                    Vue.js");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.863.1">
    expect(wrapper.text()).not.toMatch("Vue.js for</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.864.1">
                                        React</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.865.1">
                                        developers");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.866.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.867.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.868.1">We should </span><a id="_idIndexMarker1267"/><span class="koboSpan" id="kobo.869.1">also test that going directly to the tag URL works </span><a id="_idIndexMarker1268"/><span class="koboSpan" id="kobo.870.1">as expected; that is, we do not see </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">irrelevant content:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.872.1">
// rest of test...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.873.1">
  it('Router renders tag page when a URL is set',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.874.1">
  async () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.875.1">
    await router.replace('/');</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.876.1">
    await router.push('/tags/angularjs');</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.877.1">
    const wrapper = mount(App, {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.878.1">
      global: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.879.1">
      plugins: [router]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.880.1">
      }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.881.1">
    })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.882.1">
    expect(wrapper.text()).toMatch("Migrating an</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.883.1">
                                    AngularJS app to</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.884.1">
                                    Vue.js");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.885.1">
    expect(wrapper.text()).not.toMatch("Vue.js for</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.886.1">
                                        React</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.887.1">
                                        developers");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.888.1">
  })</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.889.1">The tests </span><a id="_idIndexMarker1269"/><span class="koboSpan" id="kobo.890.1">pass since the application is working as expected. </span><span class="koboSpan" id="kobo.890.2">Therefore, the </span><a id="_idIndexMarker1270"/><span class="koboSpan" id="kobo.891.1">output will be </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer321">
<span class="koboSpan" id="kobo.893.1"><img alt="Figure 11.18 – TagPage routing tests passing on the command line" src="image/Figure_11.18_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.894.1">Figure 11.18 – TagPage routing tests passing on the command line</span></p>
<p><span class="koboSpan" id="kobo.895.1">Before </span><a id="_idIndexMarker1271"/><span class="koboSpan" id="kobo.896.1">going on, however, let’s run </span><em class="italic"><span class="koboSpan" id="kobo.897.1">all</span></em><span class="koboSpan" id="kobo.898.1"> our unit tests. </span><span class="koboSpan" id="kobo.898.2">You’ll </span><a id="_idIndexMarker1272"/><span class="koboSpan" id="kobo.899.1">notice that while our tests pass, there are now </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">various warnings:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer322">
<span class="koboSpan" id="kobo.901.1"><img alt="Figure 11.19 – Warnings about router-link and router-view" src="image/Figure_11.19_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.902.1">Figure 11.19 – Warnings about router-link and router-view</span></p>
<p><span class="koboSpan" id="kobo.903.1">As these warnings don’t fail our tests, we should remove them. </span><span class="koboSpan" id="kobo.903.2">We’ve got a few options for how to </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">One way is to simply stub out, or </span><em class="italic"><span class="koboSpan" id="kobo.906.1">fake</span></em><span class="koboSpan" id="kobo.907.1">, the components we don’t need. </span><span class="koboSpan" id="kobo.907.2">In this case, we want our tests to ignore the router components that we aren’t testing at the time. </span><span class="koboSpan" id="kobo.907.3">We can address this by using an option supported by both </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">mount</span></strong><span class="koboSpan" id="kobo.909.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">shallowMount</span></strong><span class="koboSpan" id="kobo.911.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">stubs</span></strong><span class="koboSpan" id="kobo.913.1">. </span><span class="koboSpan" id="kobo.913.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">stubs</span></strong><span class="koboSpan" id="kobo.915.1"> option, we tell Vue’s test utilities to </span><em class="italic"><span class="koboSpan" id="kobo.916.1">stub</span></em><span class="koboSpan" id="kobo.917.1">, or create an empty component of, a set </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">of tags.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">We add </span><a id="_idIndexMarker1273"/><span class="koboSpan" id="kobo.920.1">this option in a new global argument to either </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">mount</span></strong><span class="koboSpan" id="kobo.922.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">shallowMount</span></strong><span class="koboSpan" id="kobo.924.1">. </span><span class="koboSpan" id="kobo.924.2">Here’s </span><a id="_idIndexMarker1274"/><span class="koboSpan" id="kobo.925.1">an example </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">ellipsis.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.929.1">
const wrapper = shallowMount(PostListItem, {
  propsData: {
    title: "Blog post title",
    description: "Test"
  },
  global: {
    stubs:['router-link'],
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.930.1">Once added to both tests in </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">ellipsis.test.js</span></strong><span class="koboSpan" id="kobo.932.1">, those warnings go away. </span><span class="koboSpan" id="kobo.932.2">Next, we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">fix </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">App.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.936.1">
describe('App', () =&gt; {
  it('App renders blog title correctly', () =&gt; {
    const wrapper = shallowMount(App, {
      global: {
        stubs:['router-link','router-view'],
      }
    })
    expect(wrapper.text()).toContain('The Vue.js Workshop
                                      Blog')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.937.1">Notice we stub </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">router-view</span></strong><span class="koboSpan" id="kobo.939.1"> as well. </span><span class="koboSpan" id="kobo.939.2">Next, we’ll fix </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">PostList.test.js</span></strong><span class="koboSpan" id="kobo.941.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">PostListItem.test.js</span></strong><span class="koboSpan" id="kobo.943.1">. </span><span class="koboSpan" id="kobo.943.2">Both of these actually use </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">router-link</span></strong><span class="koboSpan" id="kobo.945.1"> so we can’t stub them, but we can provide them as plugins to </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">mount</span></strong><span class="koboSpan" id="kobo.947.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">shallowMount</span></strong><span class="koboSpan" id="kobo.949.1">. </span><span class="koboSpan" id="kobo.949.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">PostList.test.js</span></strong><span class="koboSpan" id="kobo.951.1">, we first import </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">our router:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.953.1">
import router from '@/router';</span></pre>
<p><span class="koboSpan" id="kobo.954.1">Then in </span><a id="_idIndexMarker1275"/><span class="koboSpan" id="kobo.955.1">each of the three tests, pass the router as a plugin </span><a id="_idIndexMarker1276"/><span class="koboSpan" id="kobo.956.1">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">global</span></strong><span class="koboSpan" id="kobo.958.1"> object, </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.960.1">
const wrapper = mount(PostList, {
  propsData: {
    posts:  [
    {
      tags: ['react', 'vue']
    },
    {
      tags: ['html', 'angularjs']
    }
    ]
  },
  global: {
    plugins: [ router ]
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.961.1">Next, we can update </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">PostListItem.test.js</span></strong><span class="koboSpan" id="kobo.963.1">, but we need to make another change here. </span><span class="koboSpan" id="kobo.963.2">Previously the test made use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">shallowMount</span></strong><span class="koboSpan" id="kobo.965.1">, but we need to switch to </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">mount</span></strong><span class="koboSpan" id="kobo.967.1"> so </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">router-link</span></strong><span class="koboSpan" id="kobo.969.1"> properly renders its output. </span><span class="koboSpan" id="kobo.969.2">Here’s the entire test with both </span><a id="_idIndexMarker1277"/><span class="koboSpan" id="kobo.970.1">the plugin </span><a id="_idIndexMarker1278"/><span class="koboSpan" id="kobo.971.1">change and the switch </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">mount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.975.1">
// rest of test...
</span><span class="koboSpan" id="kobo.975.2">describe('PostListItem', () =&gt; {
  it('PostListItem renders title and description
  correctly', () =&gt; {
    const wrapper = mount(PostListItem, {
      propsData: {
        title: "Blog post title",
        description: "Blog post description"
      },
      global: {
        plugins: [ router ]
      }
    })
    expect(wrapper.text()).toMatch("Blog post title")
    expect(wrapper.text()).toMatch("Blog post description")
  })
  it('PostListItem renders tags with a # prepended to
  them', () =&gt; {
    const wrapper = mount(PostListItem, {
      propsData: {
        tags: ['react', 'vue']
      },
      global: {
        plugins: [ router ]
      }
    })
    expect(wrapper.text()).toMatch('#react')
    expect(wrapper.text()).toMatch('#vue')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.976.1">At this </span><a id="_idIndexMarker1279"/><span class="koboSpan" id="kobo.977.1">point, our warnings have been resolved. </span><span class="koboSpan" id="kobo.977.2">We’ve now </span><a id="_idIndexMarker1280"/><span class="koboSpan" id="kobo.978.1">seen how to implement and test an application that includes </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">vue-router</span></strong><span class="koboSpan" id="kobo.980.1">. </span><span class="koboSpan" id="kobo.980.2">In the next section, we will learn about testing Pinia </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">in detail.</span></span></p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor457"/><span class="koboSpan" id="kobo.982.1">Testing state management with Pinia</span></h1>
<p><span class="koboSpan" id="kobo.983.1">To show </span><a id="_idIndexMarker1281"/><span class="koboSpan" id="kobo.984.1">how to test a component that relies </span><a id="_idIndexMarker1282"/><span class="koboSpan" id="kobo.985.1">on Pinia (Vue’s official global state management solution), we’ll implement and test a newsletter </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">subscription banner.</span></span></p>
<p><span class="koboSpan" id="kobo.987.1">To start with, we should create the banner template. </span><span class="koboSpan" id="kobo.987.2">The banner will contain a </span><strong class="bold"><span class="koboSpan" id="kobo.988.1">Subscribe to the newsletter</span></strong><span class="koboSpan" id="kobo.989.1"> call to action and a </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">close button.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.991.1">
&lt;script setup&gt;
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;
  &lt;strong&gt;Subscribe to the newsletter&lt;/strong&gt;
  &lt;button&gt;Close&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style scoped&gt;
div {
  background-color: #c0c0c0;
  size: 100%;
  padding: 10px;
}
div button {
  float: right;
}
&lt;/style&gt;</span></pre>
<p><span class="koboSpan" id="kobo.992.1">We can </span><a id="_idIndexMarker1283"/><span class="koboSpan" id="kobo.993.1">display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">NewsletterBanner</span></strong><span class="koboSpan" id="kobo.995.1"> component </span><a id="_idIndexMarker1284"/><span class="koboSpan" id="kobo.996.1">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">App.vue</span></strong><span class="koboSpan" id="kobo.998.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1000.1">
&lt;script setup&gt;
import NewsletterBanner from './components/NewsletterBanner.vue';
&lt;/script&gt;
&lt;template&gt;
  &lt;NewsletterBanner /&gt;
  &lt;header&gt;
  &lt;h1&gt;The Vue.js Workshop Blog&lt;/h1&gt;
  &lt;/header&gt;
  &lt;router-view :posts="posts"&gt;&lt;/router-view&gt;
&lt;/template&gt;
&lt;!-- rest of template --&gt;</span></pre>
<p><span class="koboSpan" id="kobo.1001.1">We’ll </span><a id="_idIndexMarker1285"/><span class="koboSpan" id="kobo.1002.1">then install Pinia with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">npm install –save pinia</span></strong><span class="koboSpan" id="kobo.1004.1"> command. </span><span class="koboSpan" id="kobo.1004.2">Once </span><a id="_idIndexMarker1286"/><span class="koboSpan" id="kobo.1005.1">Pinia is installed, we can initialize our store in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">store.js</span></strong><span class="koboSpan" id="kobo.1007.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1009.1">
import { defineStore } from 'pinia'
export const userPreferencesStore = defineStore({
  id: 'userPreferences',
  state: () =&gt; ({
  }),
  getters: {
  },
  actions: {
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.1010.1">Our Pinia store is also registered in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">main.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router';
const app = createApp(App);
app.use(router);
app.use(createPinia());
app.mount('#app');</span></pre>
<p><span class="koboSpan" id="kobo.1014.1">In order </span><a id="_idIndexMarker1287"/><span class="koboSpan" id="kobo.1015.1">to decide whether the newsletter banner </span><a id="_idIndexMarker1288"/><span class="koboSpan" id="kobo.1016.1">should be displayed or not, we need to add an initial state to </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">our store:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1018.1">
  state: () =&gt; ({
    dismissedSubscriberBanner: false
  }),</span></pre>
<p><span class="koboSpan" id="kobo.1019.1">To close the banner, we need an action that will set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">dismissedSubscribeBanner</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1021.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1024.1">
  actions: {
    dismissSubscriberBanner() {
      this.dismissedSubscriberBanner = true;
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1025.1">We can now use the store state and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">dismissSubscribeBanner</span></strong><span class="koboSpan" id="kobo.1027.1"> action to decide whether to show the banner (using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">v-if</span></strong><span class="koboSpan" id="kobo.1029.1">) and whether to close it (binding to a click on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">close button):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1031.1">
&lt;script setup&gt;
import { computed } from 'vue';
import { userPreferencesStore } from '@/store.js';
const store = userPreferencesStore();
const showBanner = computed(() =&gt; {
  return !store.dismissedSubscriberBanner;
})
&lt;/script&gt;
&lt;template&gt;
  &lt;div v-if="showBanner"&gt;
  &lt;strong&gt;Subscribe to the newsletter&lt;/strong&gt;
  &lt;button @click="store.dismissSubscriberBanner()"&gt;
    Close&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;!-- rest of template --&gt;</span></pre>
<p><span class="koboSpan" id="kobo.1032.1"> At this </span><a id="_idIndexMarker1289"/><span class="koboSpan" id="kobo.1033.1">point, the </span><a id="_idIndexMarker1290"/><span class="koboSpan" id="kobo.1034.1">banner looks like this in </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">a browser:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer323">
<span class="koboSpan" id="kobo.1036.1"><img alt="Figure 11.20 – Newsletter banner displayed in a browser" src="image/Figure_11.20_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1037.1">Figure 11.20 – Newsletter banner displayed in a browser</span></p>
<p><span class="koboSpan" id="kobo.1038.1">Before we </span><a id="_idIndexMarker1291"/><span class="koboSpan" id="kobo.1039.1">write our unit test, it may be a good </span><a id="_idIndexMarker1292"/><span class="koboSpan" id="kobo.1040.1">idea to see if our </span><em class="italic"><span class="koboSpan" id="kobo.1041.1">existing</span></em><span class="koboSpan" id="kobo.1042.1"> tests work. </span><span class="koboSpan" id="kobo.1042.2">(And as you can probably guess, this is leading to something.) If you go ahead and run all the tests, you’ll see a whole new set </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">of issues.</span></span></p>
<p><span class="koboSpan" id="kobo.1044.1">In the first following figure, note </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">the warnings:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer324">
<span class="koboSpan" id="kobo.1046.1"><img alt="Figure 11.21 – Test failures related to Pinia" src="image/Figure_11.21_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1047.1">Figure 11.21 – Test failures related to Pinia</span></p>
<p><span class="koboSpan" id="kobo.1048.1">As you can see, we now have two tests failing due to Pinia. </span><span class="koboSpan" id="kobo.1048.2">As with the issues we saw with Vue Router, we need to do some work to ensure our tests don’t throw an error just because we added in Pinia. </span><span class="koboSpan" id="kobo.1048.3">To begin, we’re going to install some Pinia-specific testing utilities </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">via </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">npm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1052.1">
npm install --save @pinia/testing</span></pre>
<p><span class="koboSpan" id="kobo.1053.1">This gives us the ability to then import a utility to help test Pinia stores, as well as helping with the new errors being thrown. </span><span class="koboSpan" id="kobo.1053.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">SinglePost.test.js</span></strong><span class="koboSpan" id="kobo.1055.1">, import Pinia’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">testing utility:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1057.1">
import { createTestingPinia } from '@pinia/testing'</span></pre>
<p><span class="koboSpan" id="kobo.1058.1">Then, much </span><a id="_idIndexMarker1293"/><span class="koboSpan" id="kobo.1059.1">like how we passed Vue Router </span><a id="_idIndexMarker1294"/><span class="koboSpan" id="kobo.1060.1">as a plugin, we’ll also pass a test-specific version </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">of Pinia:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1062.1">
const wrapper = mount(App, {
  global: {
    plugins: [router,
      createTestingPinia({createSpy:vi.fn})]
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.1063.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">createSpy</span></strong><span class="koboSpan" id="kobo.1065.1"> parameter is used to stub action calls and uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">vi.fn</span></strong><span class="koboSpan" id="kobo.1067.1">. </span><span class="koboSpan" id="kobo.1067.2">In our first line in the unit test, we can modify the imports from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">vitest</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1069.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1070.1">
import { describe, it, expect, vi } from 'vitest';</span></pre>
<p><span class="koboSpan" id="kobo.1071.1">Update the plugins attribute for all the wrappers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">SinglePost.test.js</span></strong><span class="koboSpan" id="kobo.1073.1"> and repeat the same fixes </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">TagPage.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1077.1">The next check should be that if the store has </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">dismissedSubscriberBanner: true</span></strong><span class="koboSpan" id="kobo.1079.1">, the banner should not be displayed. </span><span class="koboSpan" id="kobo.1079.2">This is done by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">initialState</span></strong><span class="koboSpan" id="kobo.1081.1"> feature of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">createTestingPinia</span></strong><span class="koboSpan" id="kobo.1083.1">. </span><span class="koboSpan" id="kobo.1083.2">It lets you define initial state values based on the ID value of </span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">our store.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1085.1">
it('Newsletter Banner should not display if store is initialised with it dismissed', () =&gt; {
  const wrapper = shallowMount(NewsletterBanner, {
    global: {
      plugins: [createTestingPinia({
        initialState: {
          userPreferences: {
            dismissedSubscriberBanner: true
          }
        },
        createSpy:vi.fn
      })]
    }
  })
  expect(wrapper.text()).not.toMatch("Subscribe to the
                                      newsletter");
})</span></pre>
<p><span class="koboSpan" id="kobo.1086.1">The final </span><a id="_idIndexMarker1295"/><span class="koboSpan" id="kobo.1087.1">test we’ll write is to make sure that </span><a id="_idIndexMarker1296"/><span class="koboSpan" id="kobo.1088.1">clicking the banner’s </span><strong class="bold"><span class="koboSpan" id="kobo.1089.1">Close</span></strong><span class="koboSpan" id="kobo.1090.1"> button fires an action to the store. </span><span class="koboSpan" id="kobo.1090.2">We can do this by checking that it is called when clicking the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1091.1">Close</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1"> button:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1093.1">
  it('Newsletter Banner should hide on "close" button
  click', async () =&gt; {
    const wrapper = shallowMount(NewsletterBanner, {
      global: {
        plugins: [createTestingPinia(
          { createSpy:vi.fn })]
      }
    })
    const store = userPreferencesStore();
    await wrapper.find('button').trigger('click');
    expect(store.dismissSubscriberBanner)
      .toHaveBeenCalledTimes(1);
  })</span></pre>
<p><span class="koboSpan" id="kobo.1094.1">The </span><a id="_idIndexMarker1297"/><span class="koboSpan" id="kobo.1095.1">tests will </span><a id="_idIndexMarker1298"/><span class="koboSpan" id="kobo.1096.1">now pass when run with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">npm run test:unit __tests__/NewsletterBanner.test.js</span></strong><span class="koboSpan" id="kobo.1098.1"> command, </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer325">
<span class="koboSpan" id="kobo.1100.1"><img alt="Figure 11.22 – Unit tests for NewsLetterBanner passing on the command line" src="image/Figure_11.22_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1101.1">Figure 11.22 – Unit tests for NewsLetterBanner passing on the command line</span></p>
<p><span class="koboSpan" id="kobo.1102.1">You’ve now had a chance to work with Pinia state management and testing, let’s now work on an exercise to demonstrate what </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">you’ve learned.</span></span></p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor458"/><span class="koboSpan" id="kobo.1104.1">Exercise 11.04: Building and testing a cookie disclaimer banner</span></h2>
<p><span class="koboSpan" id="kobo.1105.1">We’ll now look at how to implement a cookie disclaimer banner using Pinia and how to test it. </span><span class="koboSpan" id="kobo.1105.2">We will </span><a id="_idIndexMarker1299"/><span class="koboSpan" id="kobo.1106.1">store whether the cookie banner is being </span><a id="_idIndexMarker1300"/><span class="koboSpan" id="kobo.1107.1">shown in Pinia (the default is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">true</span></strong><span class="koboSpan" id="kobo.1109.1">); when the banner is closed, it will update </span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1113.1">You can find the complete code </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.04"><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.04</span></span></a></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1116.1">Create a green cookie banner with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">Cookies Disclaimer</span></strong><span class="koboSpan" id="kobo.1118.1"> title in bold, the disclaimer, and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">I agree</span></strong><span class="koboSpan" id="kobo.1120.1"> button. </span><span class="koboSpan" id="kobo.1120.2">We will create this </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">src/components/CookieBanner.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1124.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1125.1">
  &lt;div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1126.1">
  &lt;strong&gt;Cookies Disclaimer&lt;/strong&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1127.1">
    We use cookies to improve our experience.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1128.1">
  &lt;button&gt;I agree&lt;/button&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1129.1">
  &lt;/div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1130.1">
&lt;/template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1131.1">
&lt;style scoped&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1132.1">
div {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1133.1">
  background-color: green;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1134.1">
  size: 100%;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1135.1">
  padding: 10px;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1136.1">
  margin-top: 50px;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1137.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1138.1">
div button {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1139.1">
  float: right;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1140.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1141.1">
&lt;/style&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.1142.1">Next, we will </span><a id="_idIndexMarker1301"/><span class="koboSpan" id="kobo.1143.1">need to </span><a id="_idIndexMarker1302"/><span class="koboSpan" id="kobo.1144.1">import and render </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">CookieBanner</span></strong><span class="koboSpan" id="kobo.1146.1"> below </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">router-view</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1148.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">src/App.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1151.1">
&lt;script setup&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1152.1">
import NewsletterBanner from './components/NewsletterBanner.vue';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1153.1">
import CookieBanner from './components/CookieBanner.vue';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1154.1">
&lt;/script&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1155.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1156.1">
  &lt;NewsletterBanner /&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1157.1">
  &lt;header&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1158.1">
  &lt;h1&gt;The Vue.js Workshop Blog&lt;/h1&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1159.1">
  &lt;/header&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1160.1">
  &lt;router-view :posts="posts"&gt;&lt;/router-view&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1161.1">
  &lt;CookieBanner /&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1162.1">
&lt;/template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1163.1">
&lt;!-- rest of template --&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.1164.1">Add a state value to control whether to display the cookie banner. </span><span class="koboSpan" id="kobo.1164.2">In our Pinia store, we will initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">acceptedCookie</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1166.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1169.1">
// rest of Pinia store...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1170.1">
state: () =&gt; ({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1171.1">
  dismissedSubscriberBanner: false,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1172.1">
  acceptedCookie: false</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1173.1">
}),</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1174.1">
// rest of Pinia store...</span></pre></li>
<li><span class="koboSpan" id="kobo.1175.1">We will </span><a id="_idIndexMarker1303"/><span class="koboSpan" id="kobo.1176.1">also need an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">acceptCookie</span></strong><span class="koboSpan" id="kobo.1178.1"> action </span><a id="_idIndexMarker1304"/><span class="koboSpan" id="kobo.1179.1">to close </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">the banner:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1181.1">
// rest of Pinia store...</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1182.1">
actions: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1183.1">
  dismissSubscriberBanner() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1184.1">
    this.dismissedSubscriberBanner = true;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1185.1">
  },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1186.1">
  acceptCookie() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1187.1">
    this.acceptedCookie = true;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1188.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1189.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1190.1">
// rest of Pinia store...</span></pre></li>
<li><span class="koboSpan" id="kobo.1191.1">Next, we will expose the store state as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">accept</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">edCookie</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1194.1">computed property:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1195.1">
&lt;script setup&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1196.1">
import { computed } from 'vue';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1197.1">
import { userPreferencesStore } from '@/store.js';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1198.1">
const store = userPreferencesStore();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1199.1">
const acceptedCookie = computed(() =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1200.1">
  return store.acceptedCookie;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1201.1">
})</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1202.1">
&lt;/script&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.1203.1">We will </span><a id="_idIndexMarker1305"/><span class="koboSpan" id="kobo.1204.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">v-if</span></strong><span class="koboSpan" id="kobo.1206.1"> to show the banner when </span><a id="_idIndexMarker1306"/><span class="koboSpan" id="kobo.1207.1">cookies have not been accepted yet. </span><span class="koboSpan" id="kobo.1207.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.1208.1">I agree</span></strong><span class="koboSpan" id="kobo.1209.1"> button will close the banner when it’s clicked by calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">store action:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1211.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1212.1">
  &lt;div v-if="!acceptedCookie"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1213.1">
  &lt;strong&gt;Cookies Disclaimer&lt;/strong&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1214.1">
    We use cookies to improve our experience.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1215.1">
  &lt;button @click="store.acceptCookie"&gt;I agree&lt;/button&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1216.1">
  &lt;/div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1217.1">
&lt;/template&gt;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1218.1">We now have a cookie banner that is displayed until </span><strong class="bold"><span class="koboSpan" id="kobo.1219.1">I agree</span></strong><span class="koboSpan" id="kobo.1220.1"> is clicked, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer326">
<span class="koboSpan" id="kobo.1222.1"><img alt="Figure 11.23 – Cookie banner displayed in the browser" src="image/Figure_11.23_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1223.1">Figure 11.23 – Cookie banner displayed in the browser</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.1224.1">We will </span><a id="_idIndexMarker1307"/><span class="koboSpan" id="kobo.1225.1">now write a test that checks that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">CookieBanner</span></strong><span class="koboSpan" id="kobo.1227.1"> is displayed </span><a id="_idIndexMarker1308"/><span class="No-Break"><span class="koboSpan" id="kobo.1228.1">by default:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1229.1">
import { describe, it, expect, vi } from 'vitest'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1230.1">
import { shallowMount } from '@vue/test-utils';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1231.1">
import CookieBanner from '../src/components/CookieBanner.vue';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1232.1">
import { createTestingPinia } from '@pinia/testing'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1233.1">
import { userPreferencesStore } from '@/store.js';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1234.1">
describe('CookieBanner', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1235.1">
  it('Cookie Banner should display if store is</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1236.1">
  initialized with it not dismissed', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1237.1">
    const wrapper = shallowMount(CookieBanner, {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1238.1">
      global: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1239.1">
        plugins:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1240.1">
          [createTestingPinia({createSpy:vi.fn})]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1241.1">
      }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1242.1">
    })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1243.1">
    expect(wrapper.text()).toMatch("Cookies</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1244.1">
                                    Disclaimer");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1245.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1246.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.1247.1">We will </span><a id="_idIndexMarker1309"/><span class="koboSpan" id="kobo.1248.1">also write a test to check whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">acceptedCookie</span></strong><span class="koboSpan" id="kobo.1250.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">true</span></strong><span class="koboSpan" id="kobo.1252.1"> in the </span><a id="_idIndexMarker1310"/><span class="koboSpan" id="kobo.1253.1">store, and if so, the cookie banner won’t </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">be displayed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1255.1">
it('Cookie Banner should not display if store is initialised with it dismissed', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1256.1">
  const wrapper = shallowMount(CookieBanner, {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1257.1">
    global: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1258.1">
      plugins: [createTestingPinia({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1259.1">
        initialState: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1260.1">
          userPreferences: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1261.1">
            acceptedCookie: true</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1262.1">
          }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1263.1">
        },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1264.1">
        createSpy:vi.fn</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1265.1">
      })]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1266.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1267.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1268.1">
  expect(wrapper.text()).not.toMatch("Cookies</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1269.1">
                                      Disclaimer");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1270.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.1271.1">Finally, we </span><a id="_idIndexMarker1311"/><span class="koboSpan" id="kobo.1272.1">want to check that when the </span><strong class="bold"><span class="koboSpan" id="kobo.1273.1">I agree</span></strong><span class="koboSpan" id="kobo.1274.1"> button </span><a id="_idIndexMarker1312"/><span class="koboSpan" id="kobo.1275.1">is clicked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">acceptCookie</span></strong><span class="koboSpan" id="kobo.1277.1"> action </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">is triggered:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1279.1">
it('Cookie Banner should hide on "I agree" button click', async () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1280.1">
  const wrapper = shallowMount(CookieBanner, {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1281.1">
    global: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1282.1">
      plugins:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1283.1">
        [createTestingPinia({ createSpy:vi.fn })]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1284.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1285.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1286.1">
    const store = userPreferencesStore();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1287.1">
    await wrapper.find('button').trigger('click');</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1288.1">
    expect(store.acceptCookie)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1289.1">
      .toHaveBeenCalledTimes(1);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1290.1">
})</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1291.1">The three </span><a id="_idIndexMarker1313"/><span class="koboSpan" id="kobo.1292.1">tests we wrote pass when run </span><a id="_idIndexMarker1314"/><span class="koboSpan" id="kobo.1293.1">with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">npm run test:unit __tests__/CookieBanner.test.js</span></strong><span class="koboSpan" id="kobo.1295.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1296.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer327">
<span class="koboSpan" id="kobo.1297.1"><img alt="Figure 11.24 – Tests for the cookie banner passing" src="image/Figure_11.24_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1298.1">Figure 11.24 – Tests for the cookie banner passing</span></p>
<p><span class="koboSpan" id="kobo.1299.1">We’ve now seen how to test components that rely on Pinia for state and updates. </span><span class="koboSpan" id="kobo.1299.2">Next, we’ll look at snapshot testing to see how it simplifies the testing of </span><span class="No-Break"><span class="koboSpan" id="kobo.1300.1">render output.</span></span></p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor459"/><span class="koboSpan" id="kobo.1301.1">Snapshot testing</span></h1>
<p><span class="koboSpan" id="kobo.1302.1">Snapshot tests </span><a id="_idIndexMarker1315"/><span class="koboSpan" id="kobo.1303.1">provide a way to write tests for fast-changing pieces of code without keeping the assertion data inline with the test. </span><span class="koboSpan" id="kobo.1303.2">Changes to a snapshot reflect changes to the output, which is quite useful for </span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">code reviews.</span></span></p>
<p><span class="koboSpan" id="kobo.1305.1">For example, we can </span><a id="_idIndexMarker1316"/><span class="koboSpan" id="kobo.1306.1">add a snapshot test to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">PostList.test.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1308.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1309.1">
  it('PostList renders correctly', () =&gt; {
    const wrapper = mount(PostList, {
      propsData: {
        posts: [
               {
                 title: "Title 1",
                 description: "Description 1"
               },
               {
                 title: "Title 2",
                 description: "Description 2"
               }
        ]
      },
      global: {
        plugins: [ router ]
      }
    })
    expect(wrapper.text()).toMatchSnapshot();
  });</span></pre>
<p><span class="koboSpan" id="kobo.1310.1">The first time this test is run, a snapshot file will be written </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">__tests__/__snapshots__</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1313.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1314.1">
// Vitest Snapshot v1
exports[`PostList &gt; PostList renders tags for each post 2 1`] = `"Title 1Description 1Title 2Description 2"`;</span></pre>
<p><span class="koboSpan" id="kobo.1315.1">This makes it </span><a id="_idIndexMarker1317"/><span class="koboSpan" id="kobo.1316.1">easy to quickly see what the changes mean in terms of </span><span class="No-Break"><span class="koboSpan" id="kobo.1317.1">concrete output.</span></span></p>
<p><span class="koboSpan" id="kobo.1318.1">We’ve now seen how to use snapshot tests. </span><span class="koboSpan" id="kobo.1318.2">Next, we’ll put all the tools we've learned about in this chapter together to add a </span><span class="No-Break"><span class="koboSpan" id="kobo.1319.1">new page.</span></span></p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor460"/><span class="koboSpan" id="kobo.1320.1">Activity 11.01: Adding a simple search-by-title page with tests</span></h2>
<p><span class="koboSpan" id="kobo.1321.1">We have already built a post list page, a single-post view page, and a posts-by-tag page. </span><span class="koboSpan" id="kobo.1321.2">A great </span><a id="_idIndexMarker1318"/><span class="koboSpan" id="kobo.1322.1">way to resurface old content on a blog is by implementing good search functionality. </span><span class="koboSpan" id="kobo.1322.2">We will add search functionality to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">PostList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1324.1"> page:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1325.1">Create the search form with an input and a button in a new file </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">src/components/SearchForm.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1328.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1329.1">We’ll now get the form to display by importing and rendering it </span><span class="No-Break"><span class="koboSpan" id="kobo.1330.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">src/App.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1332.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1333.1">We are now able to search the search form in the application, </span><span class="No-Break"><span class="koboSpan" id="kobo.1334.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer328">
<span class="koboSpan" id="kobo.1335.1"><img alt="Figure 11.25 – The post view with a search form" src="image/Figure_11.25_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1336.1">Figure 11.25 – The post view with a search form</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1337.1">We’re </span><a id="_idIndexMarker1319"/><span class="koboSpan" id="kobo.1338.1">now ready to add a snapshot test for the search form. </span><span class="koboSpan" id="kobo.1338.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">__tests__/SearchForm.test.js</span></strong><span class="koboSpan" id="kobo.1340.1">, we should add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">SearchForm should match </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">expected HTML</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1344.1">We want to track the contents of the search form input using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">v-model</span></strong><span class="koboSpan" id="kobo.1346.1"> to two-way bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">searchTerm</span></strong><span class="koboSpan" id="kobo.1348.1"> instance variable and the contents of </span><span class="No-Break"><span class="koboSpan" id="kobo.1349.1">the input.</span></span></li>
<li><span class="koboSpan" id="kobo.1350.1">When the search form is submitted, we’ll need to update the URL with the right parameter. </span><span class="koboSpan" id="kobo.1350.2">This can be done with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">this.$router.push()</span></strong><span class="koboSpan" id="kobo.1352.1">. </span><span class="koboSpan" id="kobo.1352.2">We will store the search in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">q</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1354.1">query parameter.</span></span></li>
<li><span class="koboSpan" id="kobo.1355.1">We will want to reflect the state of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">q</span></strong><span class="koboSpan" id="kobo.1357.1"> query parameter in the search form input. </span><span class="koboSpan" id="kobo.1357.2">We can do this by reading </span><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">q</span></strong><span class="koboSpan" id="kobo.1359.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">this.$route.query</span></strong><span class="koboSpan" id="kobo.1361.1"> and setting it as the initial value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">searchTerm</span></strong><span class="koboSpan" id="kobo.1363.1"> data field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">SearchForm</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1365.1">component state.</span></span></li>
<li><span class="koboSpan" id="kobo.1366.1">Next, we’ll want to filter the posts passed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">PostList</span></strong><span class="koboSpan" id="kobo.1368.1"> on the home page. </span><span class="koboSpan" id="kobo.1368.2">We’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">route.query.q</span></strong><span class="koboSpan" id="kobo.1370.1"> in a computed property that filters posts by their title. </span><span class="koboSpan" id="kobo.1370.2">This new computed property will then be used instead of posts </span><span class="No-Break"><span class="koboSpan" id="kobo.1371.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">src/App.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1373.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1374.1">Next, we should add a test that changes the search query parameter and check that the app shows the right result. </span><span class="koboSpan" id="kobo.1374.2">To do this, we can import </span><strong class="source-inline"><span class="koboSpan" id="kobo.1375.1">src/App.vue</span></strong><span class="koboSpan" id="kobo.1376.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">@/router.js</span></strong><span class="koboSpan" id="kobo.1378.1">, and render the app with the store and the router. </span><span class="koboSpan" id="kobo.1378.2">We can then update the search field contents. </span><span class="koboSpan" id="kobo.1378.3">Finally, we can submit the form by clicking </span><a id="_idIndexMarker1320"/><span class="koboSpan" id="kobo.1379.1">the element where test ID is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">Search</span></strong><span class="koboSpan" id="kobo.1381.1"> (which is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1382.1">search button).</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.1383.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1384.1">The solution for this activity can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Activity11.01"><span class="No-Break"><span class="koboSpan" id="kobo.1386.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Activity11.01</span></span></a></p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor461"/><span class="koboSpan" id="kobo.1387.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1388.1">Throughout this chapter, we’ve looked at different approaches to testing different types of </span><span class="No-Break"><span class="koboSpan" id="kobo.1389.1">Vue.js applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1390.1">Testing in general is useful for empirically showing that the system is working. </span><span class="koboSpan" id="kobo.1390.2">Unit tests are the cheapest to build and maintain and should be the base of testing functionality. </span><span class="koboSpan" id="kobo.1390.3">System tests are the next level up in the testing pyramid and allow you to gain confidence that the majority of features are working as expected. </span><span class="koboSpan" id="kobo.1390.4">End-to-end tests show that the main flows of the full </span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">system work.</span></span></p>
<p><span class="koboSpan" id="kobo.1392.1">We’ve seen how to unit test components and methods, as well as testing through layers, and testing component output in a black-box fashion instead of inspecting component internals to test functionality. </span><span class="koboSpan" id="kobo.1392.2">Using the Vitest testing library, we tested advanced functionality, such as routing and applications, that </span><span class="No-Break"><span class="koboSpan" id="kobo.1393.1">leverage Pinia.</span></span></p>
<p><span class="koboSpan" id="kobo.1394.1">Finally, we looked at snapshot testing and saw how it can be an effective way to write tests for template-heavy chunks </span><span class="No-Break"><span class="koboSpan" id="kobo.1395.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.1396.1">In the next chapter, we will look at end-to-end testing techniques that can be applied to </span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">Vue.js applications.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer330">
</div>
</div>
</body></html>