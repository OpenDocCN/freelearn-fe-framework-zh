- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a WYSIWYG Editor for the Desktop Using Electron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications are traditionally built with HTML, CSS, and JavaScript. Their
    use has also widely spread to server development using **Node.js**. Various tools
    and frameworks have emerged in recent years that use HTML, CSS, and JavaScript
    to create applications for desktop and mobile. In this chapter, we will investigate
    how to create desktop applications using Angular and **Electron**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Electron is a JavaScript framework used to build native desktop applications
    with web technologies. Combining it with the Angular framework allows us to create
    fast and highly performant web applications. In this chapter, we will build a
    desktop **WYSIWYG** editor and cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a WYSIWYG editor library for Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Electron in the workspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating between Angular and Electron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging a desktop application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential background theory and context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Electron is a cross-platform framework used to build Windows, Linux, and Mac
    desktop applications. Many popular applications, such as Visual Studio Code, Skype,
    and Slack, are made with Electron. The Electron framework is built on top of Node.js
    and Chromium. Web developers can leverage their existing HTML, CSS, and JavaScript
    skills to create desktop applications without learning a new language like C++
    or C#.
  prefs: []
  type: TYPE_NORMAL
- en: Electron applications have many similarities with PWA applications. Consider
    building an Electron application for scenarios such as advanced filesystem manipulation
    or when you need a more native look and feel for your application. Another use
    case is when you build a complementary tool for your primary desktop product and
    want to ship them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Electron application consists of two processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main**: This interacts with the native local resources using the Node.js
    API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Renderer**: This is responsible for managing the user interface of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Electron application can have only one main process that communicates with
    one or more renderer processes. Each renderer process operates in complete isolation
    from the others.
  prefs: []
  type: TYPE_NORMAL
- en: The Electron framework provides the **ipcMain** and **ipcRenderer** interfaces,
    which we can use to interact with these processes. The interaction is accomplished
    using **Inter-Process Communication (IPC)**, a mechanism that exchanges messages
    securely and asynchronously over a common channel via a Promise-based API.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we will build a desktop WYSIWYG editor that keeps its content
    local to the filesystem. Initially, we will build it as an Angular application
    using **ngx-wig**, a popular WYSIWYG Angular library. We will then convert it
    to a desktop application using Electron and learn how to synchronize content between
    Angular and Electron. We will also see how to persist the content of the editor
    into the filesystem. Finally, we will package our application as a single executable
    file that can be run in a desktop environment. The following diagram describes
    an architectural overview of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει διάγραμμα  Περιγραφή που δημιουργήθηκε αυτόματα](img/B18465_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Project architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Build time: 1 hour.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software tools are required to complete this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular CLI**: A command-line interface for Angular that you can find at
    [https://angular.io/cli](https://angular.io/cli).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: A code editor that you can download from [https://code.visualstudio.com](https://code.visualstudio.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub material**: The code for this chapter can be found in the `Chapter05`
    folder at [https://github.com/PacktPublishing/Angular-Projects-Third-Edition](https://github.com/PacktPublishing/Angular-Projects-Third-Edition).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a WYSIWYG editor library for Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will kick off our project by creating a WYSIWYG editor as a Angular application.
    Use the Angular CLI to create a new Angular application from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the following options to the `ng new` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my-editor`: Defines the name of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--defaults`: Defines CSS as the preferred stylesheet format of the application
    and disables routing because our application will consist of a single component
    that will host the editor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A WYSIWYG editor is a rich text editor, such as Microsoft Word. We could create
    one from scratch using the Angular framework, but it would be time-consuming,
    and we would only reinvent the wheel. The Angular ecosystem contains a wide variety
    of libraries for this purpose. One of them is the ngx-wig library, which has no
    external dependencies, just Angular! Let’s add the library to our application
    and learn how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `npm` client to install `ngx-wig` from the npm package registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.module.ts` file and add `NgxWigModule` to the `imports` array
    of the `@NgModule` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`NgxWigModule` is the main module of the ngx-wig library.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new Angular component that will host our WYSIWYG editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the template file of the newly generated component, `editor.component.html`,
    and replace its content with the following HTML snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`NgxWigModule` exposes a set of Angular services and components we can use
    in our application. The main component of the module is the `<ngx-wig>` component,
    which displays the actual WYSIWYG editor. It exposes a collection of input properties
    that we can set, such as the placeholder of the editor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `app.component.html` file and replace its content with the `<app-editor>`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `styles.css` file, which contains global styles for the Angular application,
    and add the following styles to make the editor dockable and take up the full
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the main HTML file of the Angular application, `index.html`, and remove
    the `<base>` tag from the `<head>` element. The browser uses the `<base>` tag
    to reference scripts and CSS files with a relative URL. Leaving it as is will
    make our desktop application fail because it will load all necessary assets directly
    from the local filesystem. We will learn more in the *Integrating Angular with
    Electron* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see what we have achieved so far. Run `ng serve` and navigate to `http://localhost:4200`
    to preview the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Application output](img/B18465_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Application output
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A toolbar with buttons that allows us to apply different styles to the content
    of the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text area that is used as the main container to add content to the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have now created a web application using Angular with a fully operational
    WYSIWYG editor. In the following section, we will learn how to convert it into
    a desktop one using Electron.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Electron in the workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Electron framework is an npm package that we can install using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will install the latest version of the `electron` npm package
    in the Angular CLI workspace. It will also add a respective entry into the `devDependencies`
    section of the `package.json` file of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Electron is added to the `devDependencies` section of the `package.json` file
    because it is a development dependency of our application. It is used only to
    prepare and build our application as a desktop one and not during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Electron applications run on the Node.js runtime and use the Chromium browser
    to render. A Node.js application has at least a JavaScript file, usually called
    `index.js` or `main.js`, which is the main entry point of the application. Since
    we are using Angular and TypeScript as our development stack, we will start by
    creating a separate TypeScript file that will be finally compiled in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `electron` inside the `src` folder of the Angular CLI
    workspace. The `electron` folder will contain any source code that is related
    to Electron.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can think of our application as two different platforms. The web platform
    is the Angular application, which resides in the `src\app` folder. The desktop
    platform is the Electron application, which resides in the `src\electron` folder.
    This approach has many benefits, including that it enforces the separation of
    concerns in our application and allows each one to develop independently from
    the other. From now on, we will refer to them as the Angular and Electron applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `main.ts` file inside the `electron` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we first import the `BrowserWindow` and `app` artifacts
    from the `electron` npm package. The `BrowserWindow` class is used to create a
    desktop window for our application. We define the window dimensions, passing an
    `options` object in its constructor that sets the `width` and `height` values
    of the window. We then call the `loadFile` method, passing the HTML file we want
    to load inside the window as a parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `index.html` file that we pass in the `loadFile` method is the main HTML
    file of the Angular application. It is loaded using the **file** protocol, which
    is why we removed the `<base>` tag in the *Adding a WYSIWYG editor library for
    Angular* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `app` object is the global object of our desktop application, just like
    the `window` object on a web page. It exposes a `whenReady` Promise that, when
    resolved, allows us to run any initialization logic for our application, including
    creating the window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `tsconfig.json` file inside the `electron` folder and add the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `main.ts` file must be compiled into JavaScript because browsers do not
    understand TypeScript. The compilation process is called **transpilation** and
    requires a TypeScript configuration file. The configuration file contains options
    that drive the TypeScript **transpiler**, which is responsible for the transpilation
    process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding TypeScript configuration file defines the path of the Electron
    source code files, using the `include` property, and sets the `importHelpers`
    property to `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we enable the `importHelpers` flag, it will include helpers from the **tslib**
    library in our application, resulting in a larger bundle size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to install the **Webpack CLI**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Webpack CLI invokes **webpack**, a popular module bundler, from the command
    line. We will use webpack to build and bundle our Electron application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install the `ts-loader` npm package using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **ts-loader** library is a webpack plugin that can load TypeScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created all the pieces needed to convert our Angular application into
    a desktop one using Electron. We only need to put them together to build and run
    our desktop application. The main piece that orchestrates the Electron application
    is the webpack configuration file that we need to create in the root folder of
    our Angular CLI workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding file configures webpack in our application using the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`: Indicates that we are currently running in a `development` environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devtool`: Enables source map file generation for debugging purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry`: Indicates the main entry point of the Electron application, which
    is the `main.ts` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: Defines the path and the filename of the Electron bundle that will
    be generated from webpack. The `path` property points to the same folder used
    by the Angular CLI to create the bundle of the Angular application. The `filename`
    property is set to `shell.js` because the default one generated from webpack is
    `main.js`, and it will cause a conflict with the `main.js` file generated from
    the Angular application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: Instructs webpack to load the `ts-loader` plugin to handle TypeScript
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`: Indicates that we are currently running in the main process of Electron.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The webpack module bundler now contains all the information needed to build
    and bundle the Electron application. On the other hand, the Angular CLI takes
    care of building the Angular application. Let’s see how we can combine them and
    run our desktop application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the `concurrently` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **concurrently** library enables us to execute multiple processes together.
    In our case, it will allow us to run the Angular and Electron applications in
    parallel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `package.json` file and add a new entry in the `scripts` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `start:desktop` script builds the Angular application, using the `ng build`
    command of the Angular CLI, and the Electron application, using the `webpack`
    command. Both applications run in watch mode using the `--watch` option, so every
    time we change the code, the application will rebuild to reflect the change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Angular CLI will delete the `dist` folder by default whenever we modify
    the Angular application. We can prevent this behavior using the `--delete-output-path=false`
    option because the Electron application is also built in the same folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We did not pass the webpack configuration file to the `webpack` command because
    it assumes the `webpack.config.js` filename by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the **Run** menu that exists in the sidebar of Visual Studio Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Run menu](img/B18465_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Run menu
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **RUN AND DEBUG** pane that appears, select the **Add Configuration…**
    option from the drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18465_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – RUN AND DEBUG pane
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code will open a drop-down menu that allows us to select the
    environment to run our application. Select the **{} Node.js: Electron Main** configuration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `launch.json` file that opens, set the value of the `program` property
    to `${workspaceFolder}/dist/my-editor/shell.js`. The `program` property points
    to the absolute path of the Electron bundle file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are now ready to run our desktop application and preview it. Run the following
    command to build the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will first build the Electron application and then the
    Angular one. Wait for the Angular build to finish, select the **Electron Main**
    option from the drop-down menu of the **RUN AND DEBUG** pane, and click the *Play*
    button to preview the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Application window](img/B18465_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Application window
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see that our Angular application with the
    WYSIWYG editor is hosted inside a native desktop window. It contains the following
    characteristics that we usually find in desktop applications:'
  prefs: []
  type: TYPE_NORMAL
- en: The header with an icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimize, maximize, and close buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Angular application is rendered inside the Chromium browser. To verify that,
    click the **View** menu item and select the **Toggle Developer Tools** option.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have successfully managed to create your own desktop WYSIWYG
    editor. In the following section, we will learn how to interact between Angular
    and Electron.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating between Angular and Electron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the specifications of the project, the content of the WYSIWYG editor
    needs to be persisted in the local filesystem. Additionally, the content will
    be loaded from the filesystem upon application startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular application handles any interaction between the WYSIWYG editor
    and its data using the renderer process, whereas the Electron application manages
    the filesystem with the main process. Thus, we need to establish an IPC mechanism
    to communicate between the two Electron processes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Angular CLI workspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by setting up the Angular CLI project to support the desired communication
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Angular CLI workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to modify several files to configure the workspace of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `main.ts` file that exists in the `src\electron` folder and set the
    `webPreferences` property in the `BrowserWindow` constructor accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding flags will enable Node.js in the renderer process and expose the
    `ipcRenderer` interface, which we will need to communicate with the main process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to install the `ngx-electronyzer` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **ngx-electronyzer** library allows us to integrate the Electron API into
    an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular and Electron applications are now ready to interact with each other
    using the IPC mechanism. Let’s start implementing the necessary logic in the Angular
    application first.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular application is responsible for managing the WYSIWYG editor. The
    content of the editor is kept in sync with the filesystem using the renderer process
    of Electron. Let’s find out how to use the renderer process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Angular service using the following command of the Angular CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `editor.service.ts` file and inject the `ElectronService` class from
    the `ngx-electronyzer` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ElectronService` class exposes part of the Electron API, including the
    `ipcRenderer` interface we are currently interested in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a method that will be called to get the content of the editor from the
    filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `invoke` method of the `ipcRenderer` property, passing the name of
    the communication channel as a parameter. The result of the `getContent` method
    is a `Promise` object of the `string` type, since the content of the editor is
    raw text data. The `invoke` method initiates a connection with the main process
    through the `getContent` channel. In the *Interacting with the filesystem* section,
    we will see how to set up the main process to respond to the `invoke` method call
    in that channel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a method that will be called to save the content of the editor to the
    filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `setContent` method calls the `invoke` method of the `ipcRenderer` object
    again but with a different channel name. It also uses the second parameter of
    the `invoke` method to pass data to the main process. In this case, the `content`
    parameter will contain the content of the editor. We will see how to configure
    the main process to handle data in the *Interacting with the filesystem* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `editor.component.ts` file and create a `myContent` property to hold
    editor data. Also, inject `EditorService` in the `constructor` of the `EditorComponent`
    class, and add the `OnInit` interface from the `@angular/core` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a method that calls the `getContent` method of the `editorService` variable
    and executes it inside the `ngOnInit` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `async`/`await` syntax, which allows the synchronous execution of
    our code in Promise-based method calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a method that calls the `setContent` method of the `editorService` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s bind those methods that we have created with the template of the component.
    Open the `editor.component.html` file and add the following bindings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `ngModel` directive to bind the model of the editor to the `myContent`
    component property, which will be used to display the content initially. We also
    use the `contentChange` event binding to save the content of the editor whenever
    it changes, that is, while the user types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `ngModel` directive is part of the `@angular/forms` npm package. Import
    `FormsModule` into the `app.module.ts` file to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have implemented all the logic for our Angular application to communicate
    with the main process. It is time to implement the other end of the communication
    mechanism, the Electron application, and its main process.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main process interacts with the filesystem using the **fs** library, which
    is built into the Electron framework. Let’s see how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `main.ts` file that exists in the `src\electron` folder and import
    the following artifacts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `fs` library is responsible for interacting with the filesystem. The `path`
    library provides utilities for working with file and folder paths. The `ipcMain`
    object allows us to work with the main process of Electron.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a variable that holds the path of the file containing the content of
    the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The file that keeps the content of the editor is the `content.html` file that
    exists inside the reserved `userData` folder. The `userData` folder is an alias
    for a special purpose system folder, different for each OS, and it is used to
    store application-specific files such as configuration. You can find more details
    about the `userData` folder and other system folders at [https://www.electronjs.org/docs/api/app#appgetpathname](https://www.electronjs.org/docs/api/app#appgetpathname).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `getPath` method of the `app` object works cross-platform and is used to
    get the path of special folders, such as the home directory of a user or the application
    data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `handle` method of the `ipcMain` object to start listening for requests
    in the `getContent` channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the main process receives a request in this channel, it uses the `existsSync`
    method of the `fs` library to check whether the file with the content of the editor
    exists already. If it exists, it reads it using the `readFileSync` method and
    returns its content to the renderer process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `handle` method again, but this time for the `setContent` channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have connected the Angular and the Electron application, it is
    time to preview our WYSIWYG desktop application:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the `start:desktop` npm script, and press *F5* to run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the editor and its toolbar to enter some content, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Editor content](img/B18465_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Editor content
  prefs: []
  type: TYPE_NORMAL
- en: Close the application window and rerun the application. If everything worked
    correctly, you should see the content you entered inside the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have enriched your WYSIWYG editor by adding persistence
    capabilities to it. In the following section, we will take the last step toward
    creating our desktop application and learn how to package and distribute it.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging a desktop application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web applications are usually bundled and deployed to a hosting web server.
    On the other hand, desktop applications are bundled and packaged as a single executable
    file that can be easily distributed. Packaging our WYSIWYG application requires
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring webpack for production mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an Electron bundler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at them in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring webpack for production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already created a webpack configuration file for the development environment.
    We now need to create a new one for production. Both configuration files will
    share some functionality, so let’s start by creating a common one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `webpack.dev.config.js` file in the root folder of the Angular CLI
    workspace with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `mode`, `devtool`, and `output` properties from the `webpack.config.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `package.json` file and pass the new webpack development configuration
    file at the `start:desktop` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `webpack.prod.config.js` file in the root folder of the Angular CLI
    workspace with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The main difference with the webpack configuration file for the development
    environment is that we changed the `filename` of the `output` bundle to `main.js`.
    The Angular CLI adds a hashed number in the `main.js` file of the Angular application
    in production, so there will be no conflicts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new entry in the `scripts` property of the `package.json` file to build
    our application in production mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `build:electron` script builds the Angular and Electron application in production
    mode simultaneously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have completed all the configurations needed to package our desktop application.
    In the following section, we will learn how to convert it into a single bundle
    specific to each OS.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Electron bundler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Electron framework has various tools created and maintained by the open-source
    community. One of these tools is the **electron-packager** library, which we can
    use to package our desktop application as a single executable file for each OS
    (Windows, Linux, and macOS). Let’s see how we can integrate it into our development
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install `electron-packager` as a development dependency
    for our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new entry in the `scripts` property of the `package.json` file to package
    our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding script, `electron-packager` will read all files in the `dist/my-editor`
    folder, package them, and output the final bundle in the `dist` folder. The `--asar`
    option instructs the packager to archive all files in the **ASAR** format, similar
    to a ZIP or TAR file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `package.json` file in the `src\electron` folder and add the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `electron-packager` library requires a `package.json` file to be present
    in the output folder, which points to the main entry file of the Electron application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `webpack.prod.config.js` file and add the `CopyWebpackPlugin` in the
    `plugins` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `CopyWebpackPlugin` to copy the `package.json` file from the `src\electron`
    folder into the `dist\my-editor` folder while building the application in production
    mode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to build the application in production mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the following `npm` command to package it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command will package the application for the OS you currently
    run on, which is the default behavior of the `electron-packager` library. You
    can alter this behavior by passing additional options, which you will find in
    the GitHub repository of the library, listed in the *Further reading* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to the `dist` folder of the Angular CLI workspace. You will find a
    folder called `my-editor-{OS}`, where `{OS}` is your current OS and its architecture.
    For example, in Windows, it will be `my-editor-win32-x64`. Open the folder, and
    you will get the following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Application package (Windows)](img/B18465_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Application package (Windows)
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the `my-editor.exe` file is the executable file
    of our desktop application. Our application code is not included in this file
    but in the `app.asar` file, which exists in the `resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Run the executable file, and the desktop application should open normally. You
    can take the whole folder and upload it to a server, or distribute it by any other
    means. Your WYSIWYG editor can now reach many more users, such as those that are
    offline most of the time. Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a WYSIWYG editor for the desktop using Angular and
    Electron. Initially, we created an Angular application and added `ngx-wig`, a
    popular Angular WYSIWYG library. Then, we learned how to build an Electron application
    and implemented a communication mechanism to exchange data between the Angular
    and Electron applications. Finally, we learned how to bundle our application for
    packaging and get it ready for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to build a mobile photo geotagging application
    with Angular and Ionic.
  prefs: []
  type: TYPE_NORMAL
- en: Practice questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which class is responsible for creating a desktop window in Electron?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we communicate between the main and renderer processes in Electron?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which flags enable the use of Node.js in the renderer process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we load Electron in an Angular application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which interface do we use to interact with Electron in an Angular application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we pass data to the main Electron process from an Angular application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which package do we use for filesystem manipulation in Electron?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which library do we use to package an Electron application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some links to build upon what we learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Electron: [https://www.electronjs.org](https://www.electronjs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Electron quick start: [https://www.electronjs.org/docs/tutorial/quick-start](https://www.electronjs.org/docs/tutorial/quick-start)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngx-wig`: [https://www.npmjs.com/package/ngx-wig](https://www.npmjs.com/package/ngx-wig)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Webpack configuration: [https://webpack.js.org/configuration](https://webpack.js.org/configuration)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts-loader`: [https://webpack.js.org/guides/typescript](https://webpack.js.org/guides/typescript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngx-electronyzer`: [https://www.npmjs.com/package/ngx-electronyzer](https://www.npmjs.com/package/ngx-electronyzer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filesystem API: [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`electron-packager`: [https://www.npmjs.com/package/electron-packager](https://www.npmjs.com/package/electron-packager)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concurrently`: [https://www.npmjs.com/package/concurrently](https://www.npmjs.com/package/concurrently)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
