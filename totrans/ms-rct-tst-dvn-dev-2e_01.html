<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer008">
<h1 class="chapter-number" id="_idParaDest-19"><a id="_idTextAnchor017"/>1</h1>
<h1 id="_idParaDest-20"><a id="_idTextAnchor018"/>First Steps with Test-Driven Development</h1>
<p>This book is a walk-through of building React applications using a test-driven approach. We’ll touch on many different parts of the React experience, including building forms, composing interfaces, and animating elements. Perhaps more importantly, we’ll do that all while learning a whole range of testing techniques.</p>
<p>You might have already used a React testing library such as React Testing Library or Enzyme, but this book doesn’t use them. Instead, we’ll be working from <em class="italic">first principles</em>: building up our own set of test functions based directly on our needs. That way, we can focus on the key ingredients that make up all great test suites. These ingredients—ideas such as super-small tests, test doubles, and factory methods—are decades old and apply across all modern programming languages and runtime environments. That’s why this book doesn’t use a testing library; there’s really no need. What you’ll learn will be useful to you no matter which testing<a id="_idIndexMarker000"/> libraries you use.</p>
<p>On the other hand, <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) is an effective technique for learning new frameworks and libraries. That makes this a very well-suited book for React and its ecosystem. This book will allow you to explore React in a way that you may not have experienced before as well as to make use of React Router and Redux and build out a GraphQL interface.</p>
<p>If you’re new to the TDD process, you might find it a bit heavy-handed. It is a meticulous and disciplined style of developing software. You’ll wonder why we’re going to such Herculean efforts to build an application. For those that master it, there is tremendous value to be gained in specifying our software in this way, as follows:</p>
<ul>
<li>By being crystal clear about our product specifications, we gain the ability to adapt our code without fear of change.</li>
<li>We gain automated regression testing by default.</li>
<li>Our tests act as comments for our code, and those comments are verifiable when we run them.</li>
<li>We gain a method of communicating our decision-making process with our colleagues.</li>
</ul>
<p>You’ll soon start recognizing the higher level of trust and confidence you have in the code you’re working on. If you’re anything like us, you’ll get hooked on that feeling and find it hard to work without it.</p>
<p><em class="italic">Parts 1</em> and <em class="italic">2</em> of this book involve building an appointment system for a hair salon – nothing too revolutionary, but as sample applications go, it offers plenty of scope. We’ll get started with that in this chapter. <em class="italic">Parts 3</em> and <em class="italic">4</em> use an entirely different application: a logo interpreter. Building that offers a fun way to explore more of the React landscape.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Creating a new React project from scratch</li>
<li>Displaying data with your first test</li>
<li>Refactoring your work</li>
<li>Writing great tests</li>
</ul>
<p>By the end of the chapter, you’ll have a good idea of what the TDD process looks like when building out a simple React component. You’ll see how to write a test, how to make it pass, and how to refactor your work.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor019"/>Technical requirements</h1>
<p>Later in this chapter, you’ll be required to install <strong class="bold">Node Package Manager</strong> (<strong class="bold">npm</strong>) together with a whole host of packages. You’ll want to ensure you have a machine capable of running the Node.js environment.</p>
<p>You’ll also need access to a terminal.</p>
<p>In addition, you should choose a good editor or <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) to work with your code.</p>
<p>The code files for this chapter can be found at the following link: <a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter01">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter01</a>.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor020"/>Creating a new React project from scratch</h1>
<p>In this section, we’ll assemble all <a id="_idIndexMarker001"/>of the necessary pieces that you’ll need to write a React application with TDD.</p>
<p>You may have come<a id="_idIndexMarker002"/> across the <strong class="source-inline">create-react-app</strong> package, which many people use to create an initial React project, but we won’t be using that. The very first TDD principle you’re going to<a id="_idIndexMarker003"/> learn is <strong class="bold">You Ain’t Gonna Need It</strong> (<strong class="bold">YAGNI</strong>). The <strong class="source-inline">create-react-app</strong> package adds a whole bunch of boilerplate that isn’t relevant to what we’re doing here—things such as a <strong class="source-inline">favicon.ico</strong> file, a sample logo, and CSS files. While these are undoubtedly useful, the basic idea behind YAGNI is that if it doesn’t meet a needed specification, then it doesn’t go in.</p>
<p>The thinking behind YAGNI is that anything <a id="_idIndexMarker004"/>unnecessary is simply <em class="italic">technical debt</em> – it’s stuff that’s just sitting there, unused, getting in your way.</p>
<p>Once you see how easy it is to start a React project from scratch, you won’t ever use <strong class="source-inline">create-react-app</strong> again!</p>
<p>In the following subsections, we’ll install NPM, Jest, React, and Babel.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor021"/>Installing npm</h2>
<p>Following the TDD process <a id="_idIndexMarker005"/>means running tests frequently—<em class="italic">very</em> frequently. Tests are run on the command line using the <strong class="source-inline">npm test</strong> command. So, let’s start by getting npm installed.</p>
<p>You can find out if you already have it installed on your machine by opening a terminal window (or Command Prompt if you’re on Windows) and typing the following command:</p>
<p class="source-code">npm -v</p>
<p>If the command isn’t found, head on over to the Node.js website at <a href="https://nodejs.org">https://nodejs.org</a> for installation<a id="_idIndexMarker006"/> instructions.</p>
<p>If you’ve already got npm installed, we recommend you ensure you’re on the latest version. You can do this on<a id="_idIndexMarker007"/> the command line by typing the following command:</p>
<p class="source-code">npm install npm@latest -g</p>
<p>Now you’re all set. You can<a id="_idIndexMarker008"/> use the <strong class="source-inline">npm</strong> command to create your project.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor022"/>Creating a new Jest project</h2>
<p>Now that With npm installed, we can create our<a id="_idIndexMarker009"/> project by performing the following<a id="_idIndexMarker010"/> steps:</p>
<ol>
<li>If you’re following along with the book’s Git repository, open a terminal and navigate to the repository directory that you’ve cloned. Otherwise, simply navigate to where you normally store your work projects.</li>
<li>Create a new directory<a id="_idIndexMarker011"/> using <strong class="source-inline">mkdir appointments</strong> and then set it as your current directory, using <strong class="source-inline">cd appointments</strong>.</li>
<li>Enter the <strong class="source-inline">npm init</strong> command. This initializes<a id="_idIndexMarker012"/> a new npm project by generating a template <strong class="source-inline">package.json</strong> file. You’ll be prompted to enter some information about your project, but you can just accept all of the defaults <em class="italic">except</em> for the <strong class="source-inline">test command</strong> question, for which you should type in <strong class="source-inline">jest</strong>. This will enable you to run tests by using the <strong class="source-inline">npm test</strong> shortcut command.</li>
</ol>
<p class="callout-heading">Editing the package.json file by hand</p>
<p class="callout">Don’t worry if you miss the prompt for the test command while you work through the instructions; you can set it afterwards by adding <strong class="source-inline">"test": "jest"</strong> to the <strong class="source-inline">scripts</strong> section of the generated <strong class="source-inline">package.json</strong> file.</p>
<ol>
<li value="4">Now go ahead <a id="_idIndexMarker013"/>and install Jest <a id="_idIndexMarker014"/>using <strong class="source-inline">npm install --save-dev jest</strong>. NPM will then download and install everything. Once completed, you should see a message like the<a id="_idIndexMarker015"/> following:<p class="source-code"><strong class="bold">added 325 packages, and audited 326 packages in 24s</strong></p></li>
</ol>
<p class="callout-heading">Alternatives to Jest</p>
<p class="callout">The TDD practices you’ll study in<a id="_idIndexMarker016"/> this book will work for a wide variety of test runners, not just Jest. An <a id="_idIndexMarker017"/>example is the Mocha test runner. If you’re interested in using Mocha with this book, take a look at the guidance at <a href="https://reacttdd.com/migrating-from-jest-to-mocha">https://reacttdd.com/migrating-from-jest-to-mocha</a>.</p>
<h3>Commit early and often</h3>
<p>Although we’ve just started, it’s time to<a id="_idIndexMarker018"/> commit what you’ve done. The TDD process offers natural stopping points to<a id="_idIndexMarker019"/> commit – each time you see a new test pass, you can commit. This way, your repository will fill up with lots of tiny commits. You might not be used to that—you may be more of a “one commit per day” person. This is a great opportunity to try something new!</p>
<p>Committing <em class="italic">early and often</em> simplifies commit messages. If you have just one test in a commit, then you can use the test description as your commit message. No thinking is required. Plus, having a detailed commit history helps you backtrack if you change your mind about a particular implementation. </p>
<p>So, get used to typing <strong class="source-inline">git commit</strong> when you’ve got a passing test.</p>
<p>As you approach the end of a feature’s development, you can use <strong class="source-inline">git rebase</strong> to squash your commits so that your Git history is kept tidy.</p>
<p>Assuming you’re using Git to keep track of your work, go ahead and enter the following commands to <strong class="source-inline">commit</strong> what you’ve done so far:</p>
<p class="source-code">git init</p>
<p class="source-code">echo "node_modules" &gt; .gitignore</p>
<p class="source-code">git add .</p>
<p class="source-code">git commit -m "Blank project with Jest dependency"</p>
<p>You’ve now “banked” that change<a id="_idIndexMarker020"/> and you can safely put it out of your mind and move on to the following two dependencies, which are React and Babel. </p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor023"/>Bringing in React and Babel</h2>
<p>Let’s install React. That’s two<a id="_idIndexMarker021"/> packages that can be installed with this next command:</p>
<p class="source-code">npm install --save react react-dom</p>
<p>Next, we need Babel, which transpiles a few <a id="_idIndexMarker022"/>different things for us: React’s <strong class="bold">JavaScript Syntax Extension (JSX)</strong> templating<a id="_idIndexMarker023"/> syntax, module mocks (which we’ll meet in <a href="B18423_07.xhtml#_idTextAnchor125"><em class="italic">Chapter 7</em></a>, <em class="italic">Testing useEffect and Mocking Components</em>), and various draft ECMAScript constructs that we’ll use.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The following information is accurate for Babel 7. If you’re using a later version, you may need to adjust the installation instructions<a id="_idIndexMarker024"/> accordingly.</p>
<p>Now, Jest already includes Babel—for the aforementioned module mocks—so we just need to install presets and plugins as follows:</p>
<p class="source-code">npm install --save-dev @babel/preset-env @babel/preset-react</p>
<p class="source-code">npm install --save-dev @babel/plugin-transform-runtime</p>
<p class="source-code">npm install --save @babel/runtime</p>
<p>A Babel preset is a set of <a id="_idIndexMarker025"/>plugins. Each plugin enables a specific feature of the ECMAScript standards or a preprocessor such as JSX.</p>
<p class="callout-heading">Configuring Babel</p>
<p class="callout">The <strong class="source-inline">env</strong> preset should <a id="_idIndexMarker026"/>usually be configured with target execution environments. It’s not necessary for the purposes of this book. See the <em class="italic">Further reading</em> section at the end of this chapter for more information.</p>
<p>We need to enable the packages we’ve just installed. Create <a id="_idIndexMarker027"/>a new file, <strong class="source-inline">.babelrc</strong>, and add the following code:</p>
<pre class="source-code">
{
  "presets": ["@babel/env", "@babel/react"],
  "plugins": ["@babel/transform-runtime"]
}</pre>
<p>Both Babel and React are<a id="_idIndexMarker028"/> now ready for use.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You may wish to commit your source code to Git at this point.</p>
<p>In this section, you’ve installed<a id="_idIndexMarker029"/> NPM, primed your new Git repository, and you’ve installed the package dependencies you’ll need to build your React app with TDD. You’re all set to write some tests.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor024"/>Displaying data with your first test</h1>
<p>Now we’ll use the<em class="italic"> </em><strong class="bold">TDD cycle</strong><em class="italic"> </em>for the first time, which<a id="_idIndexMarker030"/> you’ll learn about as we go through each step of the cycle.</p>
<p>We’ll start our application by building out an appointment view, which shows the details of an appointment. It’s a<a id="_idIndexMarker031"/> React component called <strong class="source-inline">Appointment</strong> that will be passed in a data structure that represents an appointment at the hair salon. We can imagine it looks a little something like the following example:</p>
<pre class="source-code">
{
  customer: {
    firstName: "Ashley",
    lastName: "Jones",
    phoneNumber: "(123) 555-0123"
  },
  stylist: "Jay Speares",
  startsAt: "2019-02-02 09:30",
  service: "Cut",
  notes: ""
}</pre>
<p>We won’t manage to get all of this information displayed by the time we complete the chapter; in fact, we’ll only display the customer’s <strong class="source-inline">firstName</strong>, and we’ll make use of the <strong class="source-inline">startsAt</strong> timestamp to order a list of today’s appointments.</p>
<p>In the following few subsections, you’ll <a id="_idIndexMarker032"/>write your first Jest test and go through all of the necessary steps to make it pass.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor025"/>Writing a failing test</h2>
<p>What exactly <em class="italic">is</em> a test? To answer that, let’s <a id="_idIndexMarker033"/>write one. Perform the following steps:</p>
<ol>
<li value="1">In your project directory, type<a id="_idIndexMarker034"/> the following commands:<p class="source-code"><strong class="bold">mkdir test</strong></p><p class="source-code"><strong class="bold">touch test/Appointment.test.js</strong></p></li>
<li>Open the <strong class="source-inline">test/Appointment.test.js</strong> file in your favorite editor or IDE and enter the following code:<p class="source-code">describe("Appointment", () =&gt; {</p><p class="source-code">});</p></li>
</ol>
<p>The <strong class="source-inline">describe</strong> function <a id="_idIndexMarker035"/>defines a <em class="italic">test suite</em>, which is <a id="_idIndexMarker036"/>simply a set of tests with a given name. The first argument is the name of the unit you are testing. It could be a React component, a function, or a module. The<a id="_idIndexMarker037"/> second argument is a function inside of which you define your tests. The purpose<a id="_idIndexMarker038"/> of the <strong class="source-inline">describe</strong> function is to describe how this named “thing” works—whatever the thing is.</p>
<p class="callout-heading">Global Jest functions</p>
<p class="callout">All of the Jest functions (such as <strong class="source-inline">describe</strong>) are already<a id="_idIndexMarker039"/> required and available in the global namespace when you run the <strong class="source-inline">npm test</strong> command. You don’t need to import anything.</p>
<p>For React components, it’s good practice to give <strong class="source-inline">describe</strong> blocks the same name as the component itself.</p>
<p class="callout-heading">Where should you place your tests?</p>
<p class="callout">If you do try out the <strong class="source-inline">create-react-app</strong> template, you’ll <a id="_idIndexMarker040"/>notice that it contains a single unit test file, <strong class="source-inline">App.test.js</strong>, which exists in the same directory as the source file, <strong class="source-inline">App.js</strong>.</p>
<p class="callout">We prefer to keep our test files <a id="_idIndexMarker041"/>separate from our application source files. Test files go in a directory named <strong class="source-inline">test</strong> and source files go in a directory named <strong class="source-inline">src</strong>. There is no real objective advantage to either approach. However, do note that it’s likely that you won’t have a one-to-one mapping between production and test files. You may choose to organize your test files differently from the way you organize your source files.</p>
<p>Let’s go ahead and run <a id="_idIndexMarker042"/>this with Jest. You might think that running tests now is <a id="_idIndexMarker043"/>pointless, since we haven’t even written a test yet, but doing so gives us valuable information about what to do next. With TDD, it’s normal to run your test runner at every opportunity.</p>
<p>On the command line, run the npm test command again. You will see this output:</p>
<p class="source-code">No tests found, exiting with code 1</p>
<p class="source-code">Run with `--passWithNoTests` to exit with code 0</p>
<p>That makes sense—we haven’t written any tests yet, just a <strong class="source-inline">describe</strong> block to hold them. At least we don’t have any syntax errors!</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you instead saw the following:</p>
<p class="callout"><strong class="source-inline">&gt; echo "Error: no test specified" &amp;&amp; exit 1</strong></p>
<p class="callout">You need to set Jest as the value for the test command in <a id="_idIndexMarker044"/>your <strong class="source-inline">package.json</strong> file. See <em class="italic">Step 3</em> in <em class="italic">Creating a new Jest project</em> above.</p>
<h3>Writing your first expectation</h3>
<p>Change <a id="_idIndexMarker045"/>your <strong class="source-inline">describe</strong> call as follows:</p>
<pre class="source-code">
describe("Appointment", () =&gt; {
<strong class="bold">  it("renders the customer first name", () =&gt; {</strong>
<strong class="bold">  });</strong>
});</pre>
<p>The <strong class="source-inline">it</strong> function defines <a id="_idIndexMarker046"/>a single test. The first argument is the description of the test and always starts with a present-tense verb so that it reads in plain English. The <strong class="source-inline">it</strong> in the function name refers to the noun you used to name your test suite (in this case, <strong class="source-inline">Appointment</strong>). In fact, if you run tests now, with <strong class="source-inline">npm test</strong>, the ouput (as shown below) will make good sense:</p>
<p class="source-code">PASS test/Appointment.test.js</p>
<p class="source-code">  Appointment</p>
<p class="source-code">    ✓ renders the customer first name (1ms)</p>
<p>You can read the <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> descriptions together as one sentence: <em class="italic">Appointment renders the customer first name</em>. You should aim for all of your tests to be readable in this way.</p>
<p>As we add more tests, Jest will show us a little checklist of passing tests.</p>
<p class="callout-heading">Jest’s test function</p>
<p class="callout">You may have used the <strong class="source-inline">test</strong> function<a id="_idIndexMarker047"/> for Jest, which is equivalent to <strong class="source-inline">it</strong>. We prefer <strong class="source-inline">it</strong> because it reads better and serves as a helpful guide for how to succinctly describe our test.</p>
<p class="callout">You may have also seen people start <a id="_idIndexMarker048"/>their test descriptions with “<em class="italic">should…</em>”. I don’t really see the point in this, it’s just an additional word we have to type. Better to just use a well-chosen verb to follow the “it.”</p>
<p>Empty tests, such<a id="_idIndexMarker049"/> as the one we just <a id="_idIndexMarker050"/>wrote, always pass. Let’s change <a id="_idIndexMarker051"/>that now. Add an <em class="italic">expectation</em> to our test as follows:</p>
<pre class="source-code">
it("renders the customer first name", () =&gt; {
<strong class="bold">  expect(document.body.textContent).toContain("Ashley");</strong>
});</pre>
<p>This <strong class="source-inline">expect</strong> call is an example of a fluent API. Like the test description, it reads like plain English. You can read it like this:</p>
<p><em class="italic">I expect</em> <strong class="source-inline">document.body.textContent</strong> <strong class="source-inline">toContain</strong> <em class="italic">the string</em> <strong class="source-inline">Ashley</strong>.</p>
<p>Each expectation <a id="_idIndexMarker052"/>has an <strong class="bold">expected value</strong> that is compared against a <strong class="bold">received value</strong>. In this example, the<a id="_idIndexMarker053"/> expected value is <strong class="source-inline">Ashley</strong> and the received value is whatever is stored in <strong class="source-inline">document.body.textContent</strong>. In other words, the expectation passes if <strong class="source-inline">document.body.textContent</strong> has the word <strong class="source-inline">Ashley</strong> anywhere within it.</p>
<p>The <strong class="source-inline">toContain</strong> function is called a <strong class="source-inline">matcher</strong> and there <a id="_idIndexMarker054"/>are a whole lot of different matchers that work<a id="_idIndexMarker055"/> in different ways. You can (and should) write your own matchers. You’ll discover how to do that in <a href="B18423_03.xhtml#_idTextAnchor053"><em class="italic">Chapter 3</em></a>, <em class="italic">Refactoring the Test Suite</em>. Building matchers that are specific to your own project is an essential part of writing clear, concise tests.</p>
<p>Before we run this test, spend a minute thinking about the code. You might have guessed that the test will fail. The question is, <a id="_idIndexMarker056"/>how will it fail?</p>
<p>Run the <strong class="source-inline">npm test</strong> command and find out:</p>
<p class="source-code">FAIL  test/Appointment.test.js</p>
<p class="source-code">  Appointment</p>
<p class="source-code">    ✕ renders the customer first name (1 ms)</p>
<p class="source-code">  ● Appointment › renders the customer first name</p>
<p class="source-code">    The error below may be caused by using the wrong test environment, see https://jestjs.io/docs/configuration#testenvironment-string.</p>
<p class="source-code">    Consider using the "jsdom" test environment.</p>
<p class="source-code">    ReferenceError: document is not defined</p>
<p class="source-code">      1 | describe("Appointment", () =&gt; {</p>
<p class="source-code">      2 |   it("renders the customer first name", () =&gt; {</p>
<p class="source-code">    &gt; 3 |     expect(document.body.textContent).toContain("Ashley");</p>
<p class="source-code">        |            ^</p>
<p class="source-code">      4 |   });</p>
<p class="source-code">      5 | })</p>
<p class="source-code">      6 |</p>
<p class="source-code">      at Object.&lt;anonymous&gt; (test/Appointment.test.js:3:12)</p>
<p>We have our first failure!</p>
<p>It’s probably not the failure <a id="_idIndexMarker057"/>you were expecting. Turns out, we still have some setup to take care of. Jest helpfully tells us what it thinks we need, and it’s correct; we need <a id="_idIndexMarker058"/>to specify a test environment of <strong class="source-inline">jsdom</strong>.</p>
<p>A <strong class="bold">test environment</strong> is a piece of <a id="_idIndexMarker059"/>code that runs before and after your test suite to perform setup and teardown. For the <strong class="source-inline">jsdom</strong> test environment, it instantiates a new <strong class="source-inline">JSDOM</strong> object and sets global and document objects, turning Node.js into a browser-like environment. </p>
<p><strong class="bold">jsdom</strong> is a package that contains a headless<a id="_idIndexMarker060"/> implementation of the <strong class="bold">Document Object Model (DOM)</strong> that runs on <a id="_idIndexMarker061"/>Node.js. In effect, it turns Node.js into a browser-like environment that responds to the usual DOM APIs, such as the document API we’re trying to access in this test.</p>
<p>Jest provides a<a id="_idIndexMarker062"/> pre-packaged <strong class="source-inline">jsdom</strong> test environment that will ensure our tests run with these DOM <a id="_idIndexMarker063"/>APIs ready to go. We just need to install it and instruct Jest to use it.</p>
<p>Run the following command at your command prompt:</p>
<p class="source-code">npm install --save-dev jest-environment-jsdom</p>
<p>Now we need to<a id="_idIndexMarker064"/> open <strong class="source-inline">package.json</strong> and add the following section at the bottom:</p>
<pre class="source-code">
{
  ...,
  "jest": {
    "testEnvironment": "jsdom"
  }
}</pre>
<p>Then<a id="_idIndexMarker065"/> we run <a id="_idIndexMarker066"/><strong class="source-inline">npm test</strong> <a id="_idIndexMarker067"/>again, <a id="_idIndexMarker068"/>giving the following output:</p>
<p class="source-code">FAIL test/Appointment.test.js</p>
<p class="source-code">  Appointment</p>
<p class="source-code">    ✕ renders the customer first name (10ms)</p>
<p class="source-code">  ● Appointment › renders the customer first name</p>
<p class="source-code">    expect(received).toContain(expected)</p>
<p class="source-code">    Expected substring: "Ashley"</p>
<p class="source-code">    Received string:    ""</p>
<p class="source-code">      1 | describe("Appointment", () =&gt; {</p>
<p class="source-code">      2 |   it("renders the customer first name", () =&gt; {</p>
<p class="source-code">    &gt; 3 |     expect(document.body.textContent).toContain("Ashley");</p>
<p class="source-code">        |                                       ^</p>
<p class="source-code">      4 |   });</p>
<p class="source-code">      5 | });</p>
<p class="source-code">      6 |</p>
<p class="source-code">      at Object.toContain (test/Appointment.test.js:3:39)</p>
<p>There are four parts to <a id="_idIndexMarker069"/>the test output that are relevant to us:</p>
<ul>
<li>The name of the failing test</li>
<li>The expected answer</li>
<li>The actual answer</li>
<li>The location in the source where the error occurred</li>
</ul>
<p>All of these help us to pinpoint why <a id="_idIndexMarker070"/>our tests failed: <strong class="source-inline">document.body.textContent</strong> is empty. That’s<a id="_idIndexMarker071"/> not surprising given we haven’t written any React code yet.</p>
<h3>Rendering React components from within a test</h3>
<p>In order to make this test<a id="_idIndexMarker072"/> pass, we’ll have<a id="_idIndexMarker073"/> to write some code above the expectation that will call into our production code.</p>
<p>Let’s work backward from that expectation. We know we want to build a React component to render this text (that’s the <strong class="source-inline">Appointment</strong> component we specified earlier). If we imagine we already have that component defined, how would we get React to render it from within our test?</p>
<p>We simply do the same thing we’d do at the entry point of our own app. We render our root component like this:</p>
<pre class="source-code">
ReactDOM.createRoot(container).render(component);</pre>
<p>The preceding function replaces the DOM <strong class="source-inline">container</strong> element with a new element that is constructed by React by rendering our React <strong class="source-inline">component</strong>, which in our case will be called <strong class="source-inline">Appointment</strong>.</p>
<p class="callout-heading">The createRoot function</p>
<p class="callout">The <strong class="source-inline">createRoot</strong> function is <a id="_idIndexMarker074"/>new in <a id="_idIndexMarker075"/>React 18. Chaining it with the call to <strong class="source-inline">render</strong> will suffice for most of our tests, but in <a href="B18423_07.xhtml#_idTextAnchor125"><em class="italic">Chapter 7</em></a><em class="italic">, Testing useEffect and Mocking Components</em>, you’ll adjust this a little to support re-rendering in a single test.</p>
<p>In order to call this in <a id="_idIndexMarker076"/>our test, we’ll need to <a id="_idIndexMarker077"/>define both <strong class="source-inline">component</strong> and <strong class="source-inline">container</strong>. The test will then have the following<a id="_idIndexMarker078"/> shape:</p>
<pre class="source-code">
it("renders the customer first name", () =&gt; {
  const component = ???
  const container = ???
  ReactDOM.createRoot(container).render(component);
  expect(document.body.textContent).toContain("Ashley");
});</pre>
<p>The value<a id="_idIndexMarker079"/> of <strong class="source-inline">component</strong> is easy; it will <a id="_idIndexMarker080"/>be an instance of <strong class="source-inline">Appointment</strong>, the component under test. We specified that as taking a customer as a prop, so let’s write out what that might look like now. Here’s a JSX fragment that takes <strong class="source-inline">customer</strong> as a prop:</p>
<pre class="source-code">
 const customer = { firstName: "Ashley" };
 const component = &lt;Appointment customer={customer} /&gt;;</pre>
<p>If you’ve never done any TDD before, this might seem a little strange. Why are we writing test code for a component we haven’t yet built? Well, that’s partly the point of TDD – we let the test drive our design. At the beginning of this section, we formulated a verbal specification of what our <strong class="source-inline">Appointment</strong> component was going to do. Now, we have a concrete, written specification that can be automatically verified by running the test.</p>
<p class="callout-heading">Simplifying test data</p>
<p class="callout">Back when we were considering<a id="_idIndexMarker081"/> our design, we came up with a whole object format for our appointments. You might think the definition of a customer here is very sparse, as it only contains a first name, but we don’t need anything else for a test about customer names.</p>
<p>We’ve figured out <strong class="source-inline">component</strong>. Now, what about <strong class="source-inline">container</strong>? We can use the DOM to create a <strong class="source-inline">container</strong> element, like this:</p>
<pre class="source-code">
const container = document.createElement("div");</pre>
<p>The call to <strong class="source-inline">document.createElement</strong> gives us a new HTML element that we’ll use as our rendering root. However, we<a id="_idIndexMarker082"/> also need to attach it to the current document body. That’s because certain DOM events will only register if our elements are part of the document tree. So, we also need to use the following line of <a id="_idIndexMarker083"/>code: </p>
<pre class="source-code">
document.body.appendChild(container);</pre>
<p>Now our expectation should pick up whatever we render because it’s rendered as part of <strong class="source-inline">document.body</strong>.</p>
<p class="callout-heading">Warning</p>
<p class="callout">We won’t be using <strong class="source-inline">appendChild</strong> for long; later in the chapter, we’ll be switching it out for something more appropriate. We would not recommend using <strong class="source-inline">appendChild</strong> in your own test suites for reasons that will become clear!</p>
<p>Let’s put it<a id="_idIndexMarker084"/> all <a id="_idIndexMarker085"/>together:</p>
<ol>
<li value="1">Change your test in <strong class="source-inline">test/Appointments.test.js</strong> as follows:<p class="source-code">it("renders the customer first name", () =&gt; {</p><p class="source-code"><strong class="bold">  const customer = { firstName: "Ashley" };</strong></p><p class="source-code"><strong class="bold">  const component = (</strong></p><p class="source-code"><strong class="bold">    &lt;Appointment customer={customer} /&gt;</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">  const container = document.createElement("div");</strong></p><p class="source-code"><strong class="bold">  document.body.appendChild(container);</strong></p><p class="source-code"><strong class="bold">  ReactDOM.createRoot(container).render(component);</strong></p><p class="source-code">  expect(document.body.textContent).toContain(</p><p class="source-code">    "Ashley"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>As we’re <a id="_idIndexMarker086"/>using both the <strong class="source-inline">ReactDOM</strong> namespace and JSX, we’ll need to include the two standard React imports at the top of our test file for this to work, as shown below:<p class="source-code">import React from "react";</p><p class="source-code">import ReactDOM from "react-dom/client";</p></li>
<li>Go ahead and run the test; it’ll fail. Within the output, you’ll see the following code:<p class="source-code"><strong class="bold">ReferenceError: Appointment is not defined</strong></p><p class="source-code"><strong class="bold">    5 |   it("renders the customer first name", () =&gt; {</strong></p><p class="source-code"><strong class="bold">    6 |     const customer = { firstName: "Ashley" };</strong></p><p class="source-code"><strong class="bold"> &gt;  7 |     const component = (</strong></p><p class="source-code"><strong class="bold">    8 |       &lt;Appointment customer={customer} /&gt;               </strong></p><p class="source-code"><strong class="bold">      |        ^</strong></p><p class="source-code"><strong class="bold">    9 |     );</strong></p></li>
</ol>
<p>This is subtly different from<a id="_idIndexMarker087"/> the test failure we saw earlier. This is a runtime exception, not an expectation failure. Thankfully, though, the exception is telling us exactly what we need to do, just as a test expectation would. It’s finally time to build <strong class="source-inline">Appointment</strong>.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor026"/>Make it pass</h2>
<p>We’re now ready to make the<a id="_idIndexMarker088"/> failing test pass. Perform the following steps:</p>
<ol>
<li value="1">Add a new <strong class="source-inline">import</strong> statement to <strong class="source-inline">test/Appointment.test.js</strong>, below the two React imports, as follows:<p class="source-code"><strong class="bold">import { Appointment } from "../src/Appointment";</strong></p></li>
<li>Run tests with <strong class="source-inline">npm test</strong>. You’ll get a different error this time, with the key message being this:<p class="source-code">Cannot find module '../src/Appointment' from 'Appointment.test.js'</p></li>
</ol>
<p class="callout-heading">Default exports</p>
<p class="callout">Although <strong class="source-inline">Appointment</strong> was defined as an <a id="_idIndexMarker089"/>export, it wasn’t defined as a <em class="italic">default</em> export. That means we have to import it using the curly brace form of import (<strong class="source-inline">import { ... }</strong>). We tend to avoid using default exports as doing so keeps the name of our component and its usage in sync. If we change the name of a component, then every place where it’s imported will break until we change those, too. This isn’t the case with default exports. Once your names are out of sync, it’s harder to track where components are used—you can’t simply use text search to find them.</p>
<ol>
<li value="3">Let’s create that module. Type the following <a id="_idIndexMarker090"/>code in your command prompt:<p class="source-code"><strong class="bold">mkdir src</strong></p><p class="source-code"><strong class="bold">touch src/Appointment.js</strong></p></li>
<li>In your editor, add the following content to <strong class="source-inline">src/Appointment.js</strong>:<p class="source-code">export const Appointment = () =&gt; {};</p></li>
</ol>
<p>Why have we created a shell of <strong class="source-inline">Appointment</strong> without actually creating an implementation? This might seem pointless, but another core principle of TDD is <em class="italic">always do the simplest thing to pass the test</em>. We could rephrase this as <em class="italic">always do the simplest thing to fix the error you’re working on</em>.</p>
<p>Remember when<a id="_idIndexMarker091"/> we mentioned that we listen carefully to what the test runner tells us? In this case, the test runner said <strong class="source-inline">Cannot</strong> <strong class="source-inline">find module Appointment</strong>, so what was needed was to create that module, which we’ve done, and then immediately stopped. Before we do anything else, we need to run our tests to learn what’s the next thing to do.</p>
<p>Running <strong class="source-inline">npm test</strong> again, you <a id="_idIndexMarker092"/>should get this test failure:</p>
<p class="source-code">● Appointment › renders the customer first name</p>
<p class="source-code">   expect(received).toContain(expected)</p>
<p class="source-code">   Expected substring: "Ashley"</p>
<p class="source-code">   Received string:    ""</p>
<p class="source-code">     12 |     ReactDOM.createRoot(...).render(component);</p>
<p class="source-code">     13 |</p>
<p class="source-code">   &gt; 14 |     expect(document.body.textContent).toContain(</p>
<p class="source-code">        |                                       ^</p>
<p class="source-code">     15 |       "Ashley"</p>
<p class="source-code">     16 |     );</p>
<p class="source-code">     17 |   });</p>
<p class="source-code">     at Object.&lt;anonymous&gt; (test/Appointment.test.js:14:39)</p>
<p>To fix the test, let’s change the <strong class="source-inline">Appointment</strong> definition as follows:</p>
<pre class="source-code">
export const Appointment = () =&gt; "Ashley";</pre>
<p>You might be thinking, <em class="italic">“That’s not a component! There’s no JSX.”</em> Correct. <em class="italic">“And it doesn’t even use the customer prop!”</em> Also correct. But React will render it anyway, and theoretically, it <a id="_idIndexMarker093"/>should make the test pass; so, in practice, it’s a good enough implementation, at least for now.</p>
<p>We always write the minimum amount of code that makes a test pass.</p>
<p>But does it pass? <a id="_idIndexMarker094"/>Run <strong class="source-inline">npm test</strong> again and take a look at the output:</p>
<p class="source-code">● Appointment › renders the customer first name</p>
<p class="source-code">    expect(received).toContain(expected)</p>
<p class="source-code">    Expected substring: "Ashley"</p>
<p class="source-code">    Received string:    ""</p>
<p class="source-code">      12 |     ReactDOM.createRoot(...).render(component);</p>
<p class="source-code">      13 |</p>
<p class="source-code">    &gt; 14 |     expect(document.body.textContent).toContain(</p>
<p class="source-code">      15 |                                       ^</p>
<p class="source-code">      16 |       "Ashley"</p>
<p class="source-code">      17 |     );</p>
<p class="source-code">         |   });</p>
<p>No, it does not pass. This is a<a id="_idIndexMarker095"/> bit of a headscratcher. We <em class="italic">did </em>define a valid React component. And we did tell React to render it in our container. What’s going on?</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor027"/>Making use of the act test helper</h2>
<p>In a React testing situation like this, often<a id="_idIndexMarker096"/> the answer has something to do with the <a id="_idIndexMarker097"/>async nature of the runtime environment. Starting in React 18, the render function is <strong class="bold">asynchronous</strong>: the function <a id="_idIndexMarker098"/>call will return before React has modified the DOM. Therefore, the expectation will run <em class="italic">before</em> the DOM is modified.</p>
<p>React provides a helper function for our tests that pauses until asynchronous rendering has completed. It’s called <strong class="source-inline">act</strong> and you simply need to wrap it around any React API calls. To use <strong class="source-inline">act</strong>, perform the following steps:</p>
<ol>
<li value="1">Go to the top of <strong class="source-inline">test/Appointment.test.js</strong> and add the following line of code:<p class="source-code">import { act } from "react-dom/test-utils";</p></li>
<li>Then, change the line with the <strong class="source-inline">render</strong> call to read as follows:<p class="source-code"><strong class="bold">act(() =&gt; </strong></p><p class="source-code"><strong class="bold">  </strong>ReactDOM.createRoot(container).render(component)</p><p class="source-code"><strong class="bold">)</strong>;</p></li>
<li>Now rerun your test and you should see a passing test, but with an odd warning printed above it, like this:<p class="source-code"><strong class="bold">&gt; jest</strong></p><p class="source-code"><strong class="bold">  console.error</strong></p><p class="source-code"><strong class="bold">    Warning: The current testing environment is not configured to support act(...)</strong></p><p class="source-code"><strong class="bold">      at printWarning (node_modules/react-dom/cjs/react-dom.development.js:86:30)</strong></p></li>
</ol>
<p>React would like us to be explicit in our use of <strong class="source-inline">act</strong>. That’s because there are use cases where <strong class="source-inline">act</strong> does not<a id="_idIndexMarker099"/> make sense—but for unit testing, we almost certainly want to use it.</p>
<p class="callout-heading">Understanding the act function</p>
<p class="callout">Although we’re using it here, the <strong class="source-inline">act</strong> function is not <a id="_idIndexMarker100"/>required for testing <a id="_idIndexMarker101"/>React. For a detailed discussion on this function and how it can be used, head to <a href="https://reacttdd.com/understanding-act">https://reacttdd.com/understanding-act</a>.</p>
<ol>
<li value="4">Let’s go ahead and <a id="_idIndexMarker102"/>enable the <strong class="source-inline">act</strong> function. Open <strong class="source-inline">package.json</strong> and modify your <strong class="source-inline">jest</strong> property to read as follows:<p class="source-code">{</p><p class="source-code">  ...,</p><p class="source-code">  "jest": {</p><p class="source-code">    "testEnvironment": "jsdom",</p><p class="source-code">    <strong class="bold">"globals": {</strong></p><p class="source-code"><strong class="bold">      "IS_REACT_ACT_ENVIRONMENT": true</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Now run your test again with <strong class="source-inline">npm test</strong>, giving the output shown:<p class="source-code"><strong class="bold">&gt; jest</strong></p><p class="source-code"><strong class="bold"> PASS  test/Appointment.test.js</strong></p><p class="source-code"><strong class="bold">  Appointment</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders the customer first name (13 ms)</strong></p><p class="source-code"><strong class="bold">Test Suites: 1 passed, 1 total</strong></p><p class="source-code"><strong class="bold">Tests:       1 passed, 1 total</strong></p><p class="source-code"><strong class="bold">Snapshots:   0 total</strong></p><p class="source-code"><strong class="bold">Time:        1.355 s</strong></p><p class="source-code"><strong class="bold">Ran all test suites.</strong></p></li>
</ol>
<p><em class="italic">Finally</em>, you have a passing test, with no warnings!</p>
<p>In the following section, you will <a id="_idIndexMarker103"/>discover how to remove the hardcoded string value that you’ve introduced by adding a second test.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor028"/>Triangulating to remove hardcoding</h2>
<p>Now that we’ve got past that<a id="_idIndexMarker104"/> little hurdle, let’s think again about the problems with our test. We did a bunch of strange acrobatics just to get this test passing. One odd thing was the use of a hardcoded value of <strong class="source-inline">Ashley</strong> in the React component, even though we’d gone to the trouble of defining a customer prop in our test and passing it in.</p>
<p>We did that because we want to stick to our rule of only doing the simplest thing that will make a test pass. In order to get to the real implementation, we need to add more tests.</p>
<p>This process is called <strong class="bold">triangulation</strong>. We add more <a id="_idIndexMarker105"/>tests to build more of a <em class="italic">real</em> implementation. The more specific our tests get, the more general our production code needs to get.</p>
<p class="callout-heading">Ping pong programming</p>
<p class="callout">This is one reason<a id="_idIndexMarker106"/> why pair programming using TDD can be so enjoyable. Pairs can play <em class="italic">ping pong</em>. Sometimes, your <a id="_idIndexMarker107"/>pair will write a test that you can solve trivially, perhaps by hardcoding, and then you force them to do the hard work of both tests by triangulating. They need to remove the hardcoding and add the generalization.</p>
<p>Let’s triangulate by performing the following steps:</p>
<ol>
<li value="1">Make a copy of your first<a id="_idIndexMarker108"/> test, pasting it just under the first test, and change the test description and the name of <strong class="source-inline">Ashley</strong> to <strong class="source-inline">Jordan</strong>, as follows:<p class="source-code">it("renders another customer first name", () =&gt; {</p><p class="source-code">  const customer = { firstName: "Jordan" };</p><p class="source-code">  const component = (</p><p class="source-code">    &lt;Appointment customer={customer} /&gt;</p><p class="source-code">  );</p><p class="source-code">  const container = document.createElement("div");</p><p class="source-code">  document.body.appendChild(container);</p><p class="source-code">  act(() =&gt; </p><p class="source-code">    ReactDOM.createRoot(container).render(component)</p><p class="source-code">  );</p><p class="source-code">  expect(document.body.textContent).toContain(</p><p class="source-code">    "Jordan"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Run tests<a id="_idIndexMarker109"/> with <strong class="source-inline">npm test</strong>. We expect this<a id="_idIndexMarker110"/> test to fail, and it does. But examine the code carefully. Is this what you expected to see? Take a look at the value of <strong class="source-inline">Received string</strong> in the following code:<p class="source-code"><strong class="bold">FAIL test/Appointment.test.js</strong></p><p class="source-code"><strong class="bold">  Appointment</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders the customer first name (18ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✕</strong><strong class="bold"> renders another customer first name (8ms)</strong></p><p class="source-code"><strong class="bold">  </strong><strong class="bold">●</strong><strong class="bold"> Appointment › renders another customer first name</strong></p><p class="source-code"><strong class="bold">    expect(received).toContain(expected)</strong></p><p class="source-code"><strong class="bold">    Expected substring: "Jordan"</strong></p><p class="source-code"><strong class="bold">    Received string:    "AshleyAshley"</strong></p></li>
</ol>
<p>The document body has the text <strong class="source-inline">AshleyAshley</strong>. This kind of repeated text is an indicator that our tests are not <em class="italic">independent</em> of one another. The component has been rendered twice, once for each test. That’s correct, but the document isn’t being cleared between each test run. </p>
<p>This is a problem. When it<a id="_idIndexMarker111"/> comes to unit testing, we want all tests to be independent of one other. If they aren’t, the output of one test could affect the functionality of a subsequent test. A test might pass because of the actions of a previous rest, resulting in <a id="_idIndexMarker112"/>a false positive. And even if the test did fail, having an unknown initial state means you’ll spend time figuring out if it was the initial state of the test that caused the issue, rather than the test scenario itself.</p>
<p>We need to change course and fix this before we get ourselves into trouble.</p>
<p class="callout-heading">Test independence</p>
<p class="callout">Unit tests should be independent of one another. The simplest way to achieve this is to not have any shared state between tests. Each test should only use variables that it has created itself.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor029"/>Backtracking on ourselves</h2>
<p>We know that the <strong class="bold">shared state</strong> is the problem. Shared state is<a id="_idIndexMarker113"/> a fancy way of saying “shared variables.” In this case, it’s <strong class="source-inline">document</strong>. This is the single global <strong class="source-inline">document</strong> object that is given to us by the <strong class="source-inline">jsdom</strong> environment, which is consistent with how a normal web browser operates: there’s a single <strong class="source-inline">document</strong> object. But unfortunately, our two tests <a id="_idIndexMarker114"/>use <strong class="source-inline">appendChild</strong> to add into that single document that’s shared between them. They don’t each get their own separate instance.</p>
<p>A simple<a id="_idIndexMarker115"/> solution is to replace <strong class="source-inline">appendChild</strong> with <strong class="source-inline">replaceChildren</strong>, like this:</p>
<pre class="source-code">
document.body.replaceChildren(container);</pre>
<p>This will clear out everything from <strong class="source-inline">document.body</strong> before doing the append.</p>
<p>But there’s a problem. We’re in the middle of a <em class="italic">red</em> test. We should never refactor, rework, or otherwise change course while we’re red.</p>
<p>Admittedly, this is all highly <a id="_idIndexMarker116"/>contrived—we could <a id="_idIndexMarker117"/>have used <strong class="source-inline">replaceChildren</strong> right from the start. But not only are we proving the need for <strong class="source-inline">replaceChildren</strong>, we are also about to discover an important technique for dealing with just this kind of scenario.</p>
<p>What we’ll have to do is <em class="italic">skip</em> this test we’re working on, fix the previous test, then re-enable the skipped test. Let’s do that now by performing the following steps:</p>
<ol>
<li value="1">In the first test you’ve just written, change <strong class="source-inline">it</strong> to <strong class="source-inline">it.skip</strong>. Do<a id="_idIndexMarker118"/> that now for the<a id="_idIndexMarker119"/> second test as follows:<p class="source-code">it<strong class="bold">.skip</strong>("renders another customer first name", () =&gt; {</p><p class="source-code">  ...</p><p class="source-code">});</p></li>
<li>Run tests. You’ll see that Jest ignores the second test and the first one still passes, as follows:<p class="source-code"><strong class="bold">PASS test/Appointment.test.js</strong></p><p class="source-code"><strong class="bold">  Appointment</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders the customer first name (19ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">○</strong><strong class="bold"> skipped 1 test</strong></p><p class="source-code"><strong class="bold">Test Suites: 1 passed, 1 total</strong></p><p class="source-code"><strong class="bold">Tests: 1 skipped, 1 passed, 2 total</strong></p></li>
<li>In the <a id="_idIndexMarker120"/>first test, change <strong class="source-inline">appendChild</strong> to <strong class="source-inline">replaceChildren</strong> as<a id="_idIndexMarker121"/> follows:<p class="source-code">it("renders the customer first name", () =&gt; {</p><p class="source-code">  const customer = { firstName: "Ashley" };</p><p class="source-code">  const component = (</p><p class="source-code">    &lt;Appointment customer={customer} /&gt;</p><p class="source-code">  );</p><p class="source-code">  const container = document.createElement("div");</p><p class="source-code">  document.body.<strong class="bold">replaceChildren</strong>(container);</p><p class="source-code">  ReactDOM.createRoot(container).render(component);</p><p class="source-code">  expect(document.body.textContent).toContain(</p><p class="source-code">    "Ashley"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Rerun the tests with <strong class="source-inline">npm test</strong>. It should still be passing.</li>
</ol>
<p>It’s time to bring the skipped test back in by<a id="_idIndexMarker122"/> removing <strong class="source-inline">.skip</strong> from the function name.</p>
<ol>
<li value="5">Perform<a id="_idIndexMarker123"/> the same update in <a id="_idIndexMarker124"/>this test as in <a id="_idIndexMarker125"/>the first: change <strong class="source-inline">appendChild</strong> to <strong class="source-inline">replaceChildren</strong>, like this:<p class="source-code">it("renders another customer first name", () =&gt; {</p><p class="source-code">  const customer = { firstName: "Jordan" };</p><p class="source-code">  const component = (</p><p class="source-code">    &lt;Appointment customer={customer} /&gt;</p><p class="source-code">  );</p><p class="source-code">  const container = document.createElement("div");</p><p class="source-code">  document.body.<strong class="bold">replaceChildren</strong>(container);</p><p class="source-code">  act(() =&gt; </p><p class="source-code">    ReactDOM.createRoot(container).render(component)</p><p class="source-code">  );</p><p class="source-code">  expect(document.body.textContent).toContain(</p><p class="source-code">    "Jordan"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Running tests now should <a id="_idIndexMarker126"/>give us the error that we were originally expecting. No more repeated text content, as you can see:<p class="source-code"><strong class="bold">FAIL test/Appointment.test.js</strong></p><p class="source-code"><strong class="bold">  Appointment</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders the customer first name (18ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✕</strong><strong class="bold"> renders another customer first name (8ms)</strong></p><p class="source-code"><strong class="bold">  </strong><strong class="bold">●</strong><strong class="bold"> Appointment › renders another customer first name</strong></p><p class="source-code"><strong class="bold">    expect(received).toContain(expected)</strong></p><p class="source-code"><strong class="bold">    Expected substring: "Jordan"</strong></p><p class="source-code"><strong class="bold">    Received string:    "Ashley"</strong></p></li>
<li>To make the test pass, we<a id="_idIndexMarker127"/> need to introduce the prop and use it within our component. Change the definition of <strong class="source-inline">Appointment</strong> to look as follows, destructuring the function arguments to pull out the customer prop:<p class="source-code">export const Appointment = (<strong class="bold">{ customer }</strong>) =&gt; (</p><p class="source-code">  &lt;div&gt;<strong class="bold">{customer.firstName}</strong>&lt;/div&gt;</p><p class="source-code">);</p></li>
<li>Run tests. We expect this test to now pass:<p class="source-code"><strong class="bold">PASS test/Appointment.test.js</strong></p><p class="source-code"><strong class="bold"> Appointment</strong></p><p class="source-code"><strong class="bold"> </strong><strong class="bold">✓</strong><strong class="bold"> renders the customer first name (21ms)</strong></p><p class="source-code"><strong class="bold"> </strong><strong class="bold">✓</strong><strong class="bold"> renders another customer first name (2ms)</strong></p></li>
</ol>
<p>Great work! We’re done with our passing test, and we’ve successfully triangulated to remove hardcoding.</p>
<p>In this section, you’ve written two tests and, in the process of doing so, you’ve discovered and overcome some of the challenges we face when writing automated tests for React components.</p>
<p>Now that we’ve got our tests working, we can take a closer look at the code we’ve written. </p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor030"/>Refactoring your work</h1>
<p>Now that you’ve got a green test, it’s time to<a id="_idIndexMarker128"/> refactor your work. Refactoring is the process of adjusting your code’s structure without changing its functionality. It’s crucial for keeping a code base in a fit, maintainable state.</p>
<p>Sadly, the refactoring step is the step that always gets forgotten. The impulse is to rush straight into the next feature. We can’t stress how important it is to take time to simply stop and <em class="italic">stare</em> at your code and think about ways to improve it. Practicing your refactoring skills is a sure-fire way to level up as a developer.</p>
<p>The adage “more haste; less speed” applies to coding just as it does in life. If you make a habit of skipping the refactoring phase, your code quality will likely deteriorate over time, making it harder to work with and therefore slower to build new features.</p>
<p>The TDD cycle helps you build good personal discipline and habits, such as consistently refactoring. It might take more effort upfront, but you will reap the rewards of a code base that remains maintainable as it ages.</p>
<p class="callout-heading">Don’t Repeat Yourself</p>
<p class="callout">Test code needs as much care and <a id="_idIndexMarker129"/>attention as production code. The number one principle you’ll be relying on when refactoring your tests is <strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>). <em class="italic">Drying up tests</em> is a phrase all TDDers repeat often.</p>
<p class="callout">The key point is that you want your tests to be as concise as possible. When you see repeated code that exists in multiple tests, it’s a great indication that you can pull that repeated code out. There are a few different ways to do that, and we’ll cover just a couple in this chapter.</p>
<p class="callout">You will see further techniques for drying up tests in <a href="B18423_03.xhtml#_idTextAnchor053"><em class="italic">Chapter 3</em></a><em class="italic">, Refactoring the Test Suite</em>.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor031"/>Sharing setup code between tests</h2>
<p>When tests contain identical setup<a id="_idIndexMarker130"/> instructions, we can promote those instructions into a shared <strong class="source-inline">beforeEach</strong> block. The code in this block is executed before each test.</p>
<p>Both of our tests use the same two variables: <strong class="source-inline">container</strong> and <strong class="source-inline">customer</strong>. The first one of these, <strong class="source-inline">container</strong>, is initialized identically in each test. That makes it a good candidate for a <strong class="source-inline">beforeEach</strong> block.</p>
<p>Perform the following steps to introduce your first <strong class="source-inline">beforeEach</strong> block:</p>
<ol>
<li value="1">Since <strong class="source-inline">container</strong> needs to be accessed in the <strong class="source-inline">beforeEach</strong> block and each of the tests, we must declare it in the outer <strong class="source-inline">describe</strong> scope. And since we’ll be setting its value in the <strong class="source-inline">beforeEach</strong> block, that also means we’ll need to use <strong class="source-inline">let</strong> instead of <strong class="source-inline">const</strong>. Just above the first test, add the following line of code:<p class="source-code">let container;</p></li>
<li>Below that declaration, add the following code:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  container = document.createElement("div");</p><p class="source-code">  document.body.replaceChildren(container);</p><p class="source-code">});</p></li>
<li>Delete the corresponding two <a id="_idIndexMarker131"/>lines from each of your two tests. Note that since we defined <strong class="source-inline">container</strong> in the scope of the <strong class="source-inline">describe</strong> block, the value set in the <strong class="source-inline">beforeEach</strong> block will be available to your test when it executes.</li>
</ol>
<p class="callout-heading">Use of let instead of const</p>
<p class="callout">Be careful when you<a id="_idIndexMarker132"/> use <strong class="source-inline">let</strong> definitions within the <strong class="source-inline">describe</strong> scope. These variables are not cleared by default between each<a id="_idIndexMarker133"/> test execution, and that shared state will affect the outcome of each test. A good rule of thumb is that any variable you declare in the <strong class="source-inline">describe</strong> scope should be assigned to a new value in a corresponding <strong class="source-inline">beforeEach</strong> block, or in the first part of each test, just as we’ve done here.</p>
<p class="callout">For a more detailed look at the use of <strong class="source-inline">let</strong> in test<a id="_idIndexMarker134"/> suites, head to <a href="https://reacttdd.com/use-of-let">https://reacttdd.com/use-of-let</a>.</p>
<p>In <a href="B18423_03.xhtml#_idTextAnchor053"><em class="italic">Chapter 3</em></a><em class="italic">, Refactoring the Test Suite</em>, we’ll look <a id="_idIndexMarker135"/>at a method for sharing this setup code between multiple test suites.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor032"/>Extracting methods</h2>
<p>The call to <strong class="source-inline">render</strong> is the same in both tests. It’s also <a id="_idIndexMarker136"/>quite lengthy given that it’s wrapped in a call to <strong class="source-inline">act</strong>. It makes sense to extract this entire operation and give it a more meaningful name.</p>
<p>Rather than pull it out as is, we can create a new function that takes the <strong class="source-inline">Appointment</strong> component as its parameter. The explanation for why this is useful will come after, but now let’s perform the following steps:</p>
<ol>
<li value="1">Above the first test, write the following definition. Note that it still needs to be within the <strong class="source-inline">describe</strong> block because it uses the <strong class="source-inline">container</strong> variable:<p class="source-code">const render = component =&gt;</p><p class="source-code">  act(() =&gt; </p><p class="source-code">    ReactDOM.createRoot(container).render(component)</p><p class="source-code">  );</p></li>
<li>Now, replace the call to <strong class="source-inline">render</strong> in each test with the following line of code:<p class="source-code">render(&lt;Appointment customer={customer} /&gt;);</p></li>
<li>In the preceding step, we <em class="italic">inlined</em> the JSX, passing it directly into <strong class="source-inline">render</strong>. That means you can now delete the line starting with <strong class="source-inline">const component</strong>. For example, your first test should end up looking as follows:<p class="source-code">it("renders the customer first name", () =&gt; {</p><p class="source-code">  const customer = { firstName: "Ashley" };</p><p class="source-code">  render(&lt;Appointment customer={customer} /&gt;);</p><p class="source-code">  expect(document.body.textContent).toContain(</p><p class="source-code">    "Ashley"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Rerun <a id="_idIndexMarker137"/>your tests and <a id="_idIndexMarker138"/>verify that they are still passing.</li>
</ol>
<p class="callout-heading">Highlighting differences within your tests</p>
<p class="callout">The parts of a test that you want to highlight are the parts that differ between tests. Usually, some code remains the same (such as <strong class="source-inline">container</strong> and the steps needed to render a component) and some code differs (<strong class="source-inline">customer</strong> in this example). Do your best to hide away whatever is the same and highlight what differs. That way, it makes it obvious what a test is specifically testing.</p>
<p>This section has covered a couple of simple ways of refactoring your code. As the book progresses, we’ll look at many different ways that both production source code and test code can be refactored.</p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor033"/>Writing great tests</h1>
<p>Now that you’ve written a<a id="_idIndexMarker139"/> couple of tests, let’s step away from the keyboard and <a id="_idIndexMarker140"/>discuss what you’ve seen so far.</p>
<p>Your first test looks like the following example:</p>
<pre class="source-code">
it("renders the customer first name", () =&gt; {
  const customer = { firstName: "Ashley" };
  render(&lt;Appointment customer={customer} /&gt;);
  expect(document.body.textContent).toContain("Ashley");
});</pre>
<p>This is concise and clearly readable.</p>
<p>A <em class="italic">good</em> test has the following three distinct sections:</p>
<ul>
<li><strong class="bold">Arrange</strong>: Sets up test dependencies</li>
<li><strong class="bold">Act</strong>: Executes production code under test</li>
<li><strong class="bold">Assert</strong>: Checks that expectations are met</li>
</ul>
<p>This is so well understood that it<a id="_idIndexMarker141"/> is called the <strong class="bold">Arrange, Act, Assert (AAA)</strong> pattern, and all of the tests in this book <a id="_idIndexMarker142"/>follow this <a id="_idIndexMarker143"/>pattern.</p>
<p>A <em class="italic">great</em> test is not just good but is also the following:</p>
<ul>
<li>Short</li>
<li>Descriptive</li>
<li>Independent of other tests</li>
<li>Has no side effects</li>
</ul>
<p>In the remainder of this section, we’ll discuss the TDD cycle, which you’ve already used, and also how to set up your development environment for easy TDD.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor034"/>Red, green, refactor</h2>
<p>TDD, at its heart, is the<a id="_idIndexMarker144"/> red, green, refactor cycle that we’ve just <a id="_idIndexMarker145"/>seen.</p>
<div>
<div class="IMG---Figure" id="_idContainer006">
<img alt="Figure 1.1 – The TDD cycle " height="383" src="image/Figure_1.01_B18423.jpg" width="472"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The TDD cycle</p>
<p>The steps of the TDD cycle are:</p>
<ol>
<li value="1"><strong class="bold">Write a failing test</strong>: Write a short<a id="_idIndexMarker146"/> test that describes some functionality you want. Execute your test and watch it fail. If it doesn’t fail, then it’s an unnecessary test; delete it and write another.</li>
<li><strong class="bold">Make it pass</strong>: Make the test <a id="_idIndexMarker147"/>green by writing the simplest production code that will work. Don’t worry about finding a neat code structure; you can tidy it up later.</li>
<li><strong class="bold">Refactor your code</strong>: Stop, slow <a id="_idIndexMarker148"/>down, and resist the urge to move on to the next feature. Work hard to make<a id="_idIndexMarker149"/> your code—both production and test code—as clean as it can be.</li>
</ol>
<p>That’s all there is to it. You’ve already seen this cycle in action in the preceding two sections, and we’ll continue to use it throughout the rest of the book. </p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor035"/>Streamlining your testing process</h2>
<p>Think about the effort you’ve<a id="_idIndexMarker150"/> put into this book so far. What actions have you been doing the most? They are the following: </p>
<ul>
<li>Switching between <strong class="source-inline">src/Appointment.js</strong> and <strong class="source-inline">test/Appointment.test.js</strong></li>
<li>Running <strong class="source-inline">npm test</strong> and analyzing the output</li>
</ul>
<p>Make sure you can perform these actions quickly.</p>
<p>For a start, you should use split-screen functionality in your editor. If you aren’t already, take this opportunity to learn how to do it. Load your production module on one side and the corresponding unit test file on the other.</p>
<p>Here’s a picture of our setup; we use <strong class="source-inline">nvim</strong> and <strong class="source-inline">tmux</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<img alt="Figure 1.2 – A typical TDD setup running tmux and vim in a terminal " height="856" src="image/Figure_1.02_B18423.jpg" width="1184"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – A typical TDD setup running tmux and vim in a terminal</p>
<p>You can see that we also <a id="_idIndexMarker151"/>have a little test window at the bottom for showing test output.</p>
<p>Jest can also watch your files<a id="_idIndexMarker152"/> and auto-run tests when they change. To enable this, change the <strong class="source-inline">test</strong> command<a id="_idIndexMarker153"/> in <strong class="source-inline">package.json</strong> to <strong class="source-inline">jest --watchAll</strong>. This reruns all of your tests when it detects any changes.</p>
<p class="callout-heading">Watching files for changes</p>
<p class="callout">Jest’s watch mode has an option to run only the tests in files that have changed, but since your React app will be composed of many different files, each of which are interconnected, it’s better to run everything as breakages can happen in many modules.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor036"/>Summary</h1>
<p>Tests act like a safety harness in our learning; we can build little blocks of understanding, building on top of each other, up and up to ever-greater heights, without fear of falling.</p>
<p>In this chapter, you’ve learned a <em class="italic">lot</em> about the TDD experience.</p>
<p>To begin with, you set up a React project from scratch, pulling in only the dependencies you need to get things running. You’ve written<a id="_idIndexMarker154"/> two tests using Jest’s <strong class="source-inline">describe</strong>, <strong class="source-inline">it</strong>, and <strong class="source-inline">beforeEach</strong> functions. You<a id="_idIndexMarker155"/> discovered the <strong class="source-inline">act</strong> helper, which<a id="_idIndexMarker156"/> ensures all React rendering has been completed before your test expectations execute.</p>
<p>You’ve also seen plenty of testing ideas. Most importantly, you’ve practiced TDD’s red-green-refactor cycle. You’ve also used triangulation and you learned about the <strong class="bold">Arrange, Act, Assert</strong> pattern.</p>
<p>And we threw in a couple of design principles for good measure: DRY and YAGNI.</p>
<p>While this is a great start, the journey has only just begun. In the following chapter, we’ll test drive a more complex component.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor037"/>Further reading</h1>
<p>Take a look at the Babel web page to discover how to correctly configure the Babel <strong class="source-inline">env</strong> preset. This is important for real-world applications, but we skipped over it in this chapter. You can find it at the following link: </p>
<p><a href="https://babeljs.io/docs/en/babel-preset-env">https://babeljs.io/docs/en/babel-preset-env</a>.</p>
<p>React’s <strong class="source-inline">act</strong> function was introduced in React 17 and has seen updates in React 18. It is deceptively complex. See this blog post for some more discussion on how this function is used at the following link: <a href="https://reacttdd.com/understanding-act">https://reacttdd.com/understanding-act</a>.</p>
<p>This book doesn’t make much use of Jest’s <strong class="source-inline">watch</strong> functionality. In recent versions of Jest, this has seen some interesting updates, such as the ability to choose which files to watch. If you find rerunning tests a struggle, you might want to try it out. You can find more information at the following link: <a href="https://jestjs.io/docs/en/cli#watch">https://jestjs.io/docs/en/cli#watch</a>.</p>
</div>
<div>
<div id="_idContainer009">
</div>
</div>
</div></body></html>