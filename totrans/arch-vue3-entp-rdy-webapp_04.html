<html><head></head><body>
<div id="_idContainer033">
<h1 class="chapter-number" id="_idParaDest-67"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-68"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.2.1">Architecture for Large-Scale Web Apps</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we explored building and scaling large-scale applications in Vue 3. </span><span class="koboSpan" id="kobo.3.2">We discussed why we need Vue.js performance optimization, the primary reasons behind poor Vue performance, how to check your Vue.js application’s bundle size, and optimizing the performance of an enterprise Vue application using different methods such as asynchronous/lazy component loading, WebP images, and image compression and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">code splitting.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will learn how to handle a sizable enterprise-ready project, from managing larger file structures to using the micro frontend architecture. </span><span class="koboSpan" id="kobo.5.2">We will also learn how to handle the internationalization and localization of our Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">3 project.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will cover the following key topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">File architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and structure</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Micro </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">frontend architecture</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Internationalization </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and localization</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">By the end of this chapter, you will know how to architect large-scale web apps with Vue 3, how to implement structures and file architecture using the law of predictability, and how to use community-recommended packages to inform predictability in your Vue.js 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">enterprise-ready application.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">You will also learn how to use micro frontend architecture to your advantage and how to implement an Atomic Design with Storybook to streamline your component directory and make your enterprise project less difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">And lastly, you will learn how to add and properly integrate internationalization in to your Vue application and about the benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">this brings.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">To get started with this chapter, I recommend you read through </span><a href="B17237_03.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.24.1">, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Scaling Performance in Vue.js 3</span></em><span class="koboSpan" id="kobo.26.1">, where we elucidate the building and scaling of large-scale applications in </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Vue 3.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">All the code files for this chapter can be found at  </span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-4"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-4</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.30.1">.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.31.1">Understanding file architecture and structure</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Structuring </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.33.1">your project depends solely on the preference of your organization and how easy it is to access files and folders when fixing bugs and adding </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">new features.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">In this section, we will explore different principles that will give you an idea of how you can structure your project to incorporate best practices, standards, and </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">easy-to-access files.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">What is the most effective way to structure your project to scale and keep it maintainable and extendable the more </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">it grows?</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">This is a common question in the software development industry but there is no one-size-fits-all method. </span><span class="koboSpan" id="kobo.39.2">It all depends on the principle of predictability, as discussed in this </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">article: </span></span><a href="https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application/"><span class="No-Break"><span class="koboSpan" id="kobo.41.1">https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.42.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">The principle of predictability is simply the ability to go from point A to point B in any code base to intuitively go from a feature request or bug report to the location in the code base where the said task can be addressed. </span><span class="koboSpan" id="kobo.43.2">Furthermore, it’s the ability to quickly or easily understand a particular code base based on the standard use of community or popular libraries </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">and tools.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">To elaborate, when a code base uses standard, community-agreed, and popular libraries or tools, it gives a great developer experience as developers are already familiar with </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">these tools.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">In the next section, we will delve deeper into discussing predictability and how we can achieve it in </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">Vue 3.</span></span><a id="_idTextAnchor116"/></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.49.1">Predictability in Vue 3</span></h2>
<p><span class="koboSpan" id="kobo.50.1">How to </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.51.1">achieve predictability in Vue 3 is very simple, as stated previously; it boils down to using Vue 3 standards and </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">style guides.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">For example, just</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.54.1"> imagine buying a new iPhone 13 ProMax in a different size; it will be awkward since you must have certainly predicted the size to stay the same from </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">your reviews.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">The approach applies to the mindsets of developers toward a new code base; we expect most libraries, component names, files, and folder structures to follow Vue 3 community standards and style guide with a little adjustment to suit the organization’s use case (</span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">if any).</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">So how can we achieve predictability in Vue 3? </span><span class="koboSpan" id="kobo.58.2">In the following subsections, we will look at a few ways to achieve standards in your enterprise Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">3 applicatio</span><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.60.1">n.</span></span></p>
<h3><span class="koboSpan" id="kobo.61.1">Community-wide standards for predictability</span></h3>
<p><span class="koboSpan" id="kobo.62.1">If you’re coming from Vue 2, you should already be familiar with the standards that exist within it. </span><span class="koboSpan" id="kobo.62.2">We </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.63.1">will discuss adding more Vue 3 specific standards </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">from there.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Vue has the following pages where you can look out for </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">community standards:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.67.1">Start by reviewing the official Vue.js style </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">guide (</span></span><a href="https://v3.vuejs.org/style-guide/#rule-categories"><span class="No-Break"><span class="koboSpan" id="kobo.69.1">https://v3.vuejs.org/style-guide/#rule-categories</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.70.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.71.1">Always use the scaffolding generated by the</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.72.1"> Vue </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">command-line interface</span></strong><span class="koboSpan" id="kobo.74.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.75.1">CLI</span></strong><span class="koboSpan" id="kobo.76.1">) or Vite in Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">3 (</span></span><a href="https://vuejs.org/guide/quick-start.html"><span class="No-Break"><span class="koboSpan" id="kobo.78.1">https://vuejs.org/guide/quick-start.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.79.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">The official Vue.js libraries are found under the </span><em class="italic"><span class="koboSpan" id="kobo.81.1">Community </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.82.1">Guide</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1"> (</span></span><a href="https://vuejs.org/about/community-guide.html"><span class="No-Break"><span class="koboSpan" id="kobo.84.1">https://vuejs.org/about/community-guide.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.85.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.86.1">Use one of the most popular component frameworks such as Vuetify (</span><a href="https://vuetifyjs.com/en/"><span class="koboSpan" id="kobo.87.1">https://vuetifyjs.com/en/</span></a><span class="koboSpan" id="kobo.88.1">) or </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">Quasar (</span></span><a href="https://quasar.dev/"><span class="No-Break"><span class="koboSpan" id="kobo.90.1">https://quasar.de</span><span id="_idTextAnchor119"/><span class="koboSpan" id="kobo.91.1">v/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.92.1">)</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.93.1">Official libraries and component libraries</span></h3>
<p><span class="koboSpan" id="kobo.94.1">Using official libraries </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.95.1">and component libraries not</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.96.1"> only brings functionality to your project but also enforces standards and allows you to build applications following standard and generally acceptable patterns according to the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">Vue community.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">For example, Vuex is a </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.99.1">state management system that prides itself on implementing a pattern and a library together because it enforces a standard to follow when building </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">Vue applications.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Another </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.102.1">great example is Vue Router, which enables developers to build routing systems in ways that are adaptable to </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">other projects.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">And the good thing about all of this is when a developer who has built with these libraries is added to a new code base, using these tools, it </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">becomes pred</span><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.106.1">ictable.</span></span></p>
<h3><span class="koboSpan" id="kobo.107.1">Standard file structure</span></h3>
<p><span class="koboSpan" id="kobo.108.1">Another </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.109.1">important aspect of project standards is the file structure. </span><span class="koboSpan" id="kobo.109.2">The file structure is an arguable aspect of project standards because different organizations and projects use different structures and Vue does not provide detailed documentation specifying </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">a structure.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">However, when you use the official Vue CLI, it provides a starting point for creating a standard folder and file structure that is widely used in the Vue.js world, and it’s most familiar for Vue developers around </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">the world.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">The following code block shows how to create a new Vue 3 project using the official Vue 3 standalone CLI </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">called Vite:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
npm create vite@latest
npm create vite@latest my-vue-app --template vue</span></pre>
<p><span class="koboSpan" id="kobo.116.1">The following screenshot shows the official project scaffolding using the Vue 3 official CLI </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">called Vite:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.118.1"><img alt="Figure 4.1 – Official Vue CLI file structure" src="image/Figure_4.01_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.119.1">Figure 4.1 – Official Vue CLI file structure</span></p>
<p><span class="koboSpan" id="kobo.120.1">The</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.121.1"> initial structure used in the preceding screenshot should already be familiar to many developers, therefore making it predictable. </span><span class="koboSpan" id="kobo.121.2">Always stick with Vue’s initial structure, build on it, and only change it for a </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">goo</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.123.1">d reason.</span></span></p>
<h3><span class="koboSpan" id="kobo.124.1">Recommended component rules</span></h3>
<p><span class="koboSpan" id="kobo.125.1">The Vue component directory</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.126.1"> is where the confusion begins because thousands of files and Vue components can be created, and it becomes very difficult to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">with time.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Adapting your code base to follow the official Vue 3 style guide is a starting point for a predictable code base and you can learn a lot about making your folder and file structure more predictable</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.129.1"> for developers from there. </span><span class="koboSpan" id="kobo.129.2">The style guide provides lots of community-wide standards and best practices for the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">Vue ecosystem.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Some of the most important points are </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">listed here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.133.1">First, we have</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.134.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Single-File Component</span></strong><span class="koboSpan" id="kobo.136.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.137.1">SFC</span></strong><span class="koboSpan" id="kobo.138.1">) style guide, which states a lot of points to follow, with the important one being that your components should be named </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">in PascalCase.</span></span></li>
<li><span class="koboSpan" id="kobo.140.1">Secondly, an SFC (</span><a href="https://vuejs.org/guide/scaling-up/sfc.html"><span class="koboSpan" id="kobo.141.1">https://vuejs.org/guide/scaling-up/sfc.html</span></a><span class="koboSpan" id="kobo.142.1">) should always order the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.144.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.146.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">&lt;style&gt;</span></strong><span class="koboSpan" id="kobo.148.1"> tags consistently, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">&lt;style&gt;</span></strong><span class="koboSpan" id="kobo.150.1"> at the end. </span><span class="koboSpan" id="kobo.150.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">script</span></strong><span class="koboSpan" id="kobo.152.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">template</span></strong><span class="koboSpan" id="kobo.154.1"> tags are always necessary while the style tag </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">is optional.</span></span></li>
<li><span class="koboSpan" id="kobo.156.1">It also states that, when possible, each component should be defined in its own dedicated file (SFC). </span><span class="koboSpan" id="kobo.156.2">This is where Storybook or Atomic Design, in general, comes in to play as we will see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">following sections.</span></span></li>
<li><span class="koboSpan" id="kobo.158.1">Additionally, component names should always be multi-worded to not conflict with any existing or future HTML elements. </span><span class="koboSpan" id="kobo.158.2">Don’t create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Table</span></strong><span class="koboSpan" id="kobo.160.1"> component or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">Button</span></strong><span class="koboSpan" id="kobo.162.1"> component since there are HTML tags with those names already; you can create a multi-word such as the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">DataTable</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.164.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">CustomButton</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.167.1">Most importantly, tightly coupled child components should be prefixed with their parent component’s name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">TodoListItem</span></strong><span class="koboSpan" id="kobo.169.1"> in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">TodoList</span></strong><span class="koboSpan" id="kobo.171.1"> component. </span><span class="koboSpan" id="kobo.171.2">The method also helps in debugging, as developers can easily spot components with names in </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">error messages.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.173.1">Vue.js has a full style guide at </span><a href="https://vuejs.org/style-guide/"><span class="koboSpan" id="kobo.174.1">https://vuejs.org/style-guide/</span></a><span class="koboSpan" id="kobo.175.1"> with a number of other standards that will help your project be more predictable for a community-wide audience </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">of</span><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.177.1"> developers.</span></span></p>
<h3><span class="koboSpan" id="kobo.178.1">Recommended community-wide standards for predictability</span></h3>
<p><span class="koboSpan" id="kobo.179.1">Over</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.180.1"> the years, the Vue community has developed and argued on numerous different standards that should be </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.181.1">used by Vue developers for a more predictive </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">In the following subsections, we will discuss a handful of these standards and how to implement them in your </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">enter</span><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.185.1">prise project.</span></span></p>
<h4><span class="koboSpan" id="kobo.186.1">A flat component directory</span></h4>
<p><span class="koboSpan" id="kobo.187.1">A flat component directory</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.188.1"> entails giving a specific naming convention to your Vue components and your team, sticking with that convention throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">application development.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">You can use a single or nested directory structure, but the naming convention should stay the same. </span><span class="koboSpan" id="kobo.190.2">The next two screenshots show different ways to implement the flat component directory. </span><span class="koboSpan" id="kobo.190.3">The following screenshot shows a single flat </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">component directory:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.192.1"><img alt="Figure 4.2 – Single flat component directory" src="image/Figure_4.02_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.193.1">Figure 4.2 – Single flat component directory</span></p>
<p><span class="koboSpan" id="kobo.194.1">The following</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.195.1"> screenshot shows a nested flat </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">component directory:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 4.3 – Nested flat compo﻿﻿nent directory" src="image/Figure_4.03_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 4.3 – Nested flat compo</span><a id="_idTextAnchor124"/><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.199.1">nent directory</span></p>
<h4><span class="koboSpan" id="kobo.200.1">Standardized route/page naming convention</span></h4>
<p><span class="koboSpan" id="kobo.201.1">Another</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.202.1"> important improvement to the principle of predictability is having proper and well-defined route/page naming conventions throughout your team </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">and project.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">For instance, using routes/page naming conventions used in Laravel or AdonisJS makes it easy for developers who have prior knowledge of these frameworks to quickly predict the code base. </span><span class="koboSpan" id="kobo.204.2">The same is applicable if you define your custom convention and stick with it through your team. </span><span class="koboSpan" id="kobo.204.3">It allows new members to easily predict and understand your </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">The following screenshot shows how you can structure your routes to be predictable based on routing standards from Laravel </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">and AdonisJS:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.208.1"><img alt="Figure 4.4 – Showing the pattern that can be adopted" src="image/Figure_4.04_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.209.1">Figure 4.4 – Showing the pattern that can be adopted</span></p>
<p><span class="koboSpan" id="kobo.210.1">You </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.211.1">should always reference your routes properly with their name when using them in router links and programmatically for more consistency </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">and flexibility.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">For example, see </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
&lt;router-link :to="{name: PhotosIndex}"&gt;Photos&lt;/router-link&gt;</span></pre>
<p><span class="koboSpan" id="kobo.216.1">Also, note that not all routes will fit this pattern exactly, as some routes will be cruddier than others. </span><span class="koboSpan" id="kobo.216.2">If this happens, a good recommendation is to continue using PascalCase for your route names </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">f</span><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.218.1">or consistency.</span></span></p>
<h4><span class="koboSpan" id="kobo.219.1">A more comprehensive file structure</span></h4>
<p><span class="koboSpan" id="kobo.220.1">Using the</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.221.1"> basic file structure from the Vue CLI is a great starting point for predictability and can be extended from there to include other files and directories in a way that standardizes our enterprise project for </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">better predictability.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">The following screenshot shows how to extend the file structure to include other necessary files </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">and directories:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.225.1"><img alt="Figure 4.5 – Extending the file structure from the default Vue CLI structure" src="image/Figure_4.05_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.226.1">Figure 4.5 – Extending the file structure from the default Vue CLI structure</span></p>
<p><span class="koboSpan" id="kobo.227.1">The additional files and folders will solely depend on your team, organization, or project, but the additional folders in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.228.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.229.1">.5</span></em><span class="koboSpan" id="kobo.230.1"> are the structure we have defined for the project we are building, and extending it from the default Vue CLI structure makes it </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">more predictable.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Also, providing</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.233.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">README.md</span></strong><span class="koboSpan" id="kobo.235.1"> file (</span><a href="https://changelog.md/"><span class="koboSpan" id="kobo.236.1">https://changelog.md/</span></a><span class="koboSpan" id="kobo.237.1">) in the root of a standard directory</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.238.1"> explaining the purpose of the directory and any rules for what should be included in it or how to use the directory files is very useful. </span><span class="koboSpan" id="kobo.238.2">This comes in handy, especially for those standards that aren’t </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">community-wide standards.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">While we tend to make our code base predictable enough for developers, no matter how well the project uses community-wide standards and Vue style guides, there are cases where we need to define specific files and folders that are generic to our project </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">or team.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">While creating a predictable code base is great for larger projects and teams using the steps and patterns discussed in the previous sections, there is still a lot to explore, and in the next section, we will explore different patterns, architectures, and structures that can be used to structure your larger-scale </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">enterprise projects.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.244.1">Different frontend architectural patterns</span></h1>
<p><span class="koboSpan" id="kobo.245.1">In this section, we will explore different architectural patterns we can use to structure our enterprise Vu</span><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.246.1">e </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">3 applications.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.248.1">Micro frontend architecture</span></h2>
<p><span class="koboSpan" id="kobo.249.1">Micro frontend </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.250.1">is the first </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.251.1">architecture that comes to mind when it comes to structuring enterprise frontend projects. </span><span class="koboSpan" id="kobo.251.2">As expressed in the official documentation, it extends the concept of microservices in the backend to the </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">frontend world.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">The concept of a micro frontend comes from the buzzword microservices (</span><a href="https://martinfowler.com/articles/microservices.html"><span class="koboSpan" id="kobo.254.1">https://martinfowler.com/articles/microservices.html</span></a><span class="koboSpan" id="kobo.255.1">) used in a backend web application to split gigantic blocks into a smaller, more manageable </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">This approach to software development makes it easier for teams to manage, maintain, and deploy larger and enterprise </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">applications faster.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">This </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.260.1">concept, which has changed the way backend applications have been developed over many years, is introduced into frontend projects in the form of </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">micro frontends.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">According to Martin Fowler (</span><a href="https://martinfowler.com/articles/micro-frontends.html"><span class="koboSpan" id="kobo.263.1">https://martinfowler.com/articles/micro-frontends.html</span></a><span class="koboSpan" id="kobo.264.1">), “</span><em class="italic"><span class="koboSpan" id="kobo.265.1">Micro Frontend is an architectural style where independently deliverable frontend applications are composed into a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.266.1">greater whole</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">.”</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">In recent years, since the initial adoption, there has been tremendous adoption of this concept in larger projects, thereby bringing the benefits of microservices into </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">frontend projects.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">The following are some</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.271.1"> key benefits that come with implementing the micro </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">frontend architecture:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.273.1">It comes with more scalable organizations with decoupled and </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">autonomous teams</span></span></li>
<li><span class="koboSpan" id="kobo.275.1">It brings smaller, more cohesive, and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">code bases</span></span></li>
<li><span class="koboSpan" id="kobo.277.1">The provides the ability to upgrade, update, or even rewrite parts of the frontend in a more </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">incremental fashion</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.279.1">As much as there are tremendous benefits to using this architecture in your enterprise project as outlined in the official documentation, the pattern requires a steep learning curve, a higher number of team expatriates, and a large number of </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">team members.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">The following diagram shows an end-to-end example of teams using a micro frontend for the Pinterest </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">demo application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.283.1"><img alt="Figure 4.6 – An end-to-end example of teams using a micro frontend" src="image/Figure_4.06_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.284.1">Figure 4.6 – An end-to-end example of teams using a micro frontend</span></p>
<p><span class="koboSpan" id="kobo.285.1">Here’s a </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.286.1">diagram of how structuring</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.287.1"> the Pinterest demo application will look using the micro </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">frontend architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.289.1"><img alt="Figure 4.7 – A screenshot of a micro frontend in action" src="image/Figure_4.07_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.290.1">Figure 4.7 – A screenshot of a micro frontend in action</span></p>
<p><span class="koboSpan" id="kobo.291.1">From the </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.292.1">screenshot, we can</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.293.1"> easily separate each of the features into a different service and have a dedicated team of frontend engineers to work </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Micro frontend is one of the best architectural patterns to use in enterprise applications because the core ideas behind a micro frontend are having isolated team code, it being technology-agnostic, </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.296.1">ownership, and so on. </span><span class="koboSpan" id="kobo.296.2">These features make developing enterprise applications a breeze. </span><span class="koboSpan" id="kobo.296.3">However, other patterns are also widely used, and we will explore </span><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.297.1">them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">next section.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.299.1">Atomic Design</span></h2>
<p><span class="koboSpan" id="kobo.300.1">Atomic Design (</span><a href="https://bradfrost.com/blog/post/atomic-web-design/"><span class="koboSpan" id="kobo.301.1">https://bradfrost.com/blog/post/atomic-web-design/</span></a><span class="koboSpan" id="kobo.302.1">) is a methodology </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.303.1">for </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.304.1">crafting </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.305.1">design systems. </span><span class="koboSpan" id="kobo.305.2">Brad Frost first introduced it for creating scalable design systems using ideas </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">from chemistry.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">From chemistry class, we know that matter comprises atoms that bond together to form molecules, which in turn combine to form more complex organisms and ultimately create all the matter in </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the universe.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">Similarly, we can break down our components into fundamental building blocks and work up from there. </span><span class="koboSpan" id="kobo.309.2">These building blocks can be divided into five components from the chemistry example, as </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">listed here:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.311.1">Atoms</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.312.1">Molecules</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.313.1">Organisms</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.314.1">Templates</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.315.1">Pages</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.316.1">This diagram from Rohan Kamath (</span><a href="https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53"><span class="koboSpan" id="kobo.317.1">https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53</span></a><span class="koboSpan" id="kobo.318.1">) gives a clear illustration of the Atomic </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">Design elements:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.320.1"><img alt="Figure 4.8 – Atomic Design elements explained (source: https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)" src="image/Figure_4.08_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.321.1">Figure 4.8 – Atomic Design elements explained (source: https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)</span></p>
<p><span class="koboSpan" id="kobo.322.1">Let’s explore</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.323.1"> each of these com</span><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.324.1">ponents</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.325.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">understand them.</span></span></p>
<h3><span class="koboSpan" id="kobo.327.1">Atoms</span></h3>
<p><span class="koboSpan" id="kobo.328.1">In science</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.329.1"> class, we learned that atoms are the basic building blocks of matter. </span><span class="koboSpan" id="kobo.329.2">But when applied to web interfaces, atoms are the HTML tags such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">input</span></strong><span class="koboSpan" id="kobo.331.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">label</span></strong><span class="koboSpan" id="kobo.333.1">, and so on. </span><span class="koboSpan" id="kobo.333.2">They can also be customized to include abstract elements such as color palettes, fonts, </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">or animations.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">Atoms are not very useful on their own except when combined with othe</span><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.336.1">r elements to </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">form molecules.</span></span></p>
<h3><span class="koboSpan" id="kobo.338.1">Molecules</span></h3>
<p><span class="koboSpan" id="kobo.339.1">When we start combining atoms, things start to get a little interesting </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">and tangible.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">The </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.342.1">smallest unit of a compound is called a molecule, and it comprises groups of atoms bonded together. </span><span class="koboSpan" id="kobo.342.2">In web interfaces, these molecules take on their own properties and serve as the backbone of any </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">design system.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">For instance, a form input, label, or button is not very useful as standalone functionality, but when combined as a form, they become very useful because they can actually do something. </span><span class="koboSpan" id="kobo.344.2">Furthermore, by combining atoms to form useful components, these components become reusable and can also </span><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.345.1">be combined to </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">form organisms.</span></span></p>
<h3><span class="koboSpan" id="kobo.347.1">Organisms</span></h3>
<p><span class="koboSpan" id="kobo.348.1">An</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.349.1"> organism is the combination of different molecules used to form a relatively complex and distinct section of </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">a component.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">An organism is designed to consist of different or similar molecule types. </span><span class="koboSpan" id="kobo.351.2">For instance, a molecule can consist of a primary navigation, a list of social media channels, a search form, and </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">a logo.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">The wonderful part of building an organism from molecules is that it encourages creating standalone, po</span><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.354.1">rtable, or </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">reusable components.</span></span></p>
<h3><span class="koboSpan" id="kobo.356.1">Templates</span></h3>
<p><span class="koboSpan" id="kobo.357.1">Templates </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.358.1">will already be familiar to the web development world; they are predefined groups of organisms stitched together to form a page. </span><span class="koboSpan" id="kobo.358.2">In templates, the designs start to come together, and the layout of the page becomes structured </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">and visible.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Each template contains all related abstract molecules, organisms, and atoms in some cases. </span><span class="koboSpan" id="kobo.360.2">Since templates are visible pages or part of a page, clients can start to see the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">final design.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">With templates, you can create different versions of your design, whether high fidelity, low fidelity, and so on. </span><span class="koboSpan" id="kobo.362.2">Templates are more HTML wireframes and can al</span><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.363.1">so become the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">final deliverable.</span></span></p>
<h3><span class="koboSpan" id="kobo.365.1">Pages</span></h3>
<p><span class="koboSpan" id="kobo.366.1">A page is a </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.367.1">specific instance of a template; in some cases, a complex page can contain more than one template combined to form a </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">bigger page.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">A page gives an accurate depiction of what the user will ultimately see, and they are the highest level of fidelity and most tangible. </span><span class="koboSpan" id="kobo.369.2">It is typically where most time is spent, and more reviews revolve </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">around it.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">In Vue.js, pages represent the different routes users access when navigating </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">Using Atomic Design principles gives us the ability to traverse from abstract pages or templates to concrete ones. </span><span class="koboSpan" id="kobo.373.2">Because of this, we can create systems that promote consistency and scalability while simultaneously showing things in their </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">final context.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">In this book, we will learn how to use the Atomic Design pattern to structure our enterprise project</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.376.1"> and use Storybook for the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">design system.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.378.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.379.1">A design system is a </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.380.1">set of interconnected patterns and standards to manage design at scale by reducing redundancy while creating a shared language and visual consistency a</span><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.381.1">cross different pages </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">and channels.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.383.1">Storybook</span></h2>
<p><span class="koboSpan" id="kobo.384.1">Storybook </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.385.1">can</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.386.1"> be implemented with any architectural pattern, such as Atomic Design, to build component-driven </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">user interfaces</span></strong><span class="koboSpan" id="kobo.388.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.389.1">UIs</span></strong><span class="koboSpan" id="kobo.390.1">) faster. </span><span class="koboSpan" id="kobo.390.2">According to the official website (</span><a href="https://storybook.js.org/"><span class="koboSpan" id="kobo.391.1">https://storybook.js.org/</span></a><span class="koboSpan" id="kobo.392.1">), Storybook</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.393.1"> is an open-source tool for building UI components and pages in isolation. </span><span class="koboSpan" id="kobo.393.2">It streamlines UI development, testing, </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">and documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">Storybook allows us, the developers, to create and test components </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">in isolation.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">In the next section, we will learn how to implement Storybook into our project and start using the Atomic Design principles to c</span><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.398.1">reate a maintainable Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">3 project.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.400.1">Implementing Storybook in Vue.js 3</span></h1>
<p><span class="koboSpan" id="kobo.401.1">Visit the official documentation for Vue implementation (</span><a href="https://storybook.js.org/docs/vue/get-started/introduction"><span class="koboSpan" id="kobo.402.1">https://storybook.js.org/docs/vue/get-started/introduction</span></a><span class="koboSpan" id="kobo.403.1">) to follow along with the implementation. </span><span class="koboSpan" id="kobo.403.2">In </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.404.1">Storybook, everything revolves around stories. </span><span class="koboSpan" id="kobo.404.2">A story describes the state of a rendered component and captures everything a</span><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.405.1"> component should/can do </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">when rendered.</span></span></p>
<h3><span class="koboSpan" id="kobo.407.1">Installing Storybook</span></h3>
<p><span class="koboSpan" id="kobo.408.1">You can</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.409.1"> use the Storybook CLI to install it in a single command by running it inside your existing Vue.js project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">root directory.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">Storybook will look into your project’s dependencies during installation and provide you with the best </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">configuration available.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">Next, depending on your framework, first, build your app and then check that everything works by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
npx sb init
npm run storybook</span></pre>
<p><span class="koboSpan" id="kobo.416.1">The preceding</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.417.1"> command will start a new development server and open a browser window showing you a </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">welcome screen:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.419.1"><img alt="Figure 4.9 – The welcome screen" src="image/Figure_4.09_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">Figure 4.9 – The welcome screen</span></p>
<p><span class="koboSpan" id="kobo.421.1">Creating a story is as easy as telling the computer what a particular component will do, the properties needed to carry out the task, and the different designs a particular component can have. </span><span class="koboSpan" id="kobo.421.2">In the next section, we will exp</span><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.422.1">lore how to create a story </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">in Storybook.</span></span></p>
<h3><span class="koboSpan" id="kobo.424.1">Creating a story</span></h3>
<p><span class="koboSpan" id="kobo.425.1">Before</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.426.1"> we delve into creating stories (components), let’s make sure we’re in sync with our folder structure for this project using Atomic Design </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">and Storybook.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The following screenshot shows the complete folder structure for implementing Atomic Design and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">stories</span></strong><span class="koboSpan" id="kobo.430.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">for Storybook:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.432.1"><img alt="Figure 4.10 – A screenshot showing the Vue 3 component and the Storybook structure" src="image/Figure_4.10_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.433.1">Figure 4.10 – A screenshot showing the Vue 3 component and the Storybook structure</span></p>
<p><span class="koboSpan" id="kobo.434.1">From the screenshot example, we have restructured our Vue.js project to use the Atomic Design principle and folder structures (the red indicator), and Storybook added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">stories</span></strong><span class="koboSpan" id="kobo.436.1"> folder (the yellow indicator) to help us understand how to write our own stories. </span><span class="koboSpan" id="kobo.436.2">We can delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">stories</span></strong><span class="koboSpan" id="kobo.438.1"> folder and follow the pattern in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.439.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.440.1">.10</span></em><span class="koboSpan" id="kobo.441.1"> to create our story inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.443.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">Now, we</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.445.1"> can start creating stories; remember, a story has to depict a particular action or group of </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">related actions.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">Here is a story we created for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">Button</span></strong><span class="koboSpan" id="kobo.449.1"> component we will use throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">the project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
import MyButton from "./Button.vue";
// More on default export:  https://storybook.js.org/docs/vue/writing-stories/introduction#default-export
export default {
  title: "/Button",
  component: MyButton,
  // More on argTypes:
  // https://storybook.js.org/docs/vue/api/argtypes
  argTypes: {
    backgroundColor: { control: "color" },
    onClick: {},
    size: {
      control: { type: "select" },
      options: ["small", "medium", "large"],
    },
  },
};
// More on component templates: https://storybook.js.org/docs/vue/writing-stories/introduction#using-args
const Template = (args) =&gt; ({
  // Components used in your story `template` are defined
   // in the `components` object
  components: { MyButton },
  // The story's `args` need to be mapped into the template
  // through the `setup()` method
  setup() {
    return { args };
  },
  // And then the `args` are bound to your component with
  // `v-bind="args"`
  template: '&lt;my-button v-bind="args" /&gt;',
});
export const Primary = Template.bind({});
// More on args: https://storybook.js.org/docs/vue/writing-
// stories/args
Primary.args = {
  primary: true,
  label: "Button",
};
export const Secondary = Template.bind({});
Secondary.args = {
  label: "Button",
};
export const Large = Template.bind({});
Large.args = {
  size: "large",
  label: "Button",
};
export const Small = Template.bind({});
Small.args = {
  size: "small",
  label: "Button",
};</span></pre>
<p><span class="koboSpan" id="kobo.452.1">For instance, a </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.453.1">button will be created in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">atoms</span></strong><span class="koboSpan" id="kobo.455.1"> directory because it is a single element, though it can have different properties and actions, such as being a blue button, white button, clickable button, disabled button, and so on. </span><span class="koboSpan" id="kobo.455.2">It’s still </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">a button.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">From the story, we can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">Button</span></strong><span class="koboSpan" id="kobo.459.1"> component will have two sizes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">small</span></strong><span class="koboSpan" id="kobo.461.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">large</span></strong><span class="koboSpan" id="kobo.463.1">), also, it will have two designs, which are </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">primary</span></strong><span class="koboSpan" id="kobo.465.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">secondary</span></strong><span class="koboSpan" id="kobo.467.1">, and additionally, it will accept two properties, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">primary</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.469.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">label</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">You can learn how to write a story to test the properties and actions of the button using the official </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">documentation (</span></span><a href="https://storybook.js.org/docs/vue/get-started/whats-a-story"><span class="No-Break"><span class="koboSpan" id="kobo.474.1">https://storybook.js.org/docs/vue/get-started/whats-a-story</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.475.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">Once you have</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.477.1"> created all your components and stories, you should have a directory like the one shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.479.1"><img alt="Figure 4.11 – A screenshot showing a complete directory including Storybook stories" src="image/Figure_4.11_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.480.1">Figure 4.11 – A screenshot showing a complete directory including Storybook stories</span></p>
<p><span class="koboSpan" id="kobo.481.1">Furthermore, with your project arranged like this, it becomes easy for developers to understand the structure and where to find components easily. </span><span class="koboSpan" id="kobo.481.2">Members of the team can easily</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.482.1"> test out components with different properties before even using them in the real project </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">using Storybook.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">In the next section, we will explore how to create an internationalized application in Vue.js 3, which allows your application to not be limited</span><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.485.1"> to a single language and </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">cultural setting.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.487.1">Implementing internationalization and localization</span></h1>
<p><span class="koboSpan" id="kobo.488.1">The essence of building an enterprise application is to support local markets around the world and to achieve this, that’s where internationalization comes </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">into place.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">The process of preparing software to support local languages and the cultural settings of other geographical locations is </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.491.1">called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.492.1">internationalization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.493.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.494.1">I18n</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">I18n is often misrepresented </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.497.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.498.1">localization</span></strong><span class="koboSpan" id="kobo.499.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.500.1">L10n</span></strong><span class="koboSpan" id="kobo.501.1">) and sometimes </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">even translation.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">While Il8n is a product development approach that is focused on making one code base capable of supporting worldwide languages and locale-specific formatting and behaviors, L10n makes a product specific to a target market or region(s), including translation of the interface and possible adaptation of terminology </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">In this section, we will first look into the benefits of internationalizing the software and further explore ho</span><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.506.1">w to implement I18n  in </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">Vue 3.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.508.1">Benefits of internationalizing software</span></h2>
<p><span class="koboSpan" id="kobo.509.1">The benefits of </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.510.1">creating internalized software are enormous and some of these are </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">listed here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.512.1">It creates higher-quality software that meets the technical and cultural needs of </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">multiple locales</span></span></li>
<li><span class="koboSpan" id="kobo.514.1">It provides greater in-country customer acceptance </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">and satisfaction</span></span></li>
<li><span class="koboSpan" id="kobo.516.1">It provides a single source code for all languages of </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">the product</span></span></li>
<li><span class="koboSpan" id="kobo.518.1">Internalized software reduces time, cost, and effort </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">for L10n</span></span></li>
<li><span class="koboSpan" id="kobo.520.1">Internalized software is simpler, and supports easier maintenance for future iterations of </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">the product</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.522.1">Market </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.523.1">acceptance is one of the major problems that arises when software is not fully internalized before or </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">after release.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">Therefore, we will look at how to implement I18n in our enterprise Vue </span><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.526.1">3 application right from the </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">development phase.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.528.1">Installing Vue I18n</span></h2>
<p><span class="koboSpan" id="kobo.529.1">In Vue 3, Vue-I18n is a </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.530.1">great compatible plugin that is used to implement I18n, and it easily integrates some localization features into your </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">Vue.js application.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">Follow these steps to</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.533.1"> internationalize </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">your app:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.535.1">There are </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.536.1">different ways to install the package according to the official documentation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">https://vue-i18n.intlify.dev/installation.html</span></strong><span class="koboSpan" id="kobo.538.1">), but we will install it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">npm</span></strong><span class="koboSpan" id="kobo.540.1"> command, as </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">shown here:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.542.1">npm install vue-i18n@9</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.543.1">After installation, inside the Vue 3 </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">main.js</span></strong><span class="koboSpan" id="kobo.545.1"> file, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">following script:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
import { createApp } from 'vue'
import { createI18n } from 'vue-i18n'
const i18n = createI18n({
  // something vue-i18n options here ...
</span><span class="koboSpan" id="kobo.547.2">})
const app = createApp(App)
app.use(i18n)
app.mount('#app')</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.548.1">With the preceding setup, you should have internalization added to your Vue project, but it will easily get bloated when developers start adding translations. </span><span class="koboSpan" id="kobo.548.2">So, we recommend creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">locales</span></strong><span class="koboSpan" id="kobo.550.1"> folder where every locale-related configuration will </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">be added.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.552.1">Let’s create </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.553.1">the folder and the files inside the root directory </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
mkdir src/locales
touch src/locales/index.js src/locales/en.json src/locales/fr.json src/locales/de.json</span></pre></li>
<li><span class="koboSpan" id="kobo.556.1">Next, inside each of the translation files, add the following codes and </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">other translations:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.558.1">
{
  "welcomeMsg": "Welcome to Your Vue.js App",
    ….
</span><span class="koboSpan" id="kobo.558.2">}</span></pre></li>
<li><span class="koboSpan" id="kobo.559.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">index.js</span></strong><span class="koboSpan" id="kobo.561.1"> file, add the following scripts to import </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">different locales:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.563.1">
import en from «./en.json»;
import fr from "./fr.json";
import de from «./de.json»;
const messages = {
 en,
 fr,
 de,
};
export default messages;</span></pre></li>
<li><span class="koboSpan" id="kobo.564.1">Lastly, add </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.565.1">the files to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">createI18n</span></strong><span class="koboSpan" id="kobo.567.1"> configuration in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">main.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.569.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.570.1">
import locales from "./locales/index.js";
const i18n = createI18n({
 locale: "en", // set locale
 fallbackLocale: "en", // set fallback locale
 messages: locales, // set locale messages
});</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.571.1">Arranging your files and folder in this structure allows for easy adoption and maintainability. </span><span class="koboSpan" id="kobo.571.2">Let’s look at the final structure of our project, including internationalization, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.573.1"><img alt="Figure ﻿4.12 – The final structure of the Vue 3 application" src="image/Figure_4.12_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.574.1">Figure </span><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.575.1">4.12 – The final structure of the Vue 3 application</span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.576.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.577.1">This chapter reviewed in more depth architecting large-scale web apps with Vue 3. </span><span class="koboSpan" id="kobo.577.2">We discussed the structure and file architecture by diving deeper into the law of predictability and how to use community-recommended packages to inform predictability in your Vue.js 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">enterprise-ready application.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">We also covered in detail how to use micro frontend architecture to your advantage. </span><span class="koboSpan" id="kobo.579.2">Also, we discussed how to implement an Atomic Design with Storybook to streamline your component directory and make your enterprise project less difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">Next, we discussed how to add I18n to your Vue application. </span><span class="koboSpan" id="kobo.581.2">We also discussed the benefits and how to properly integrate I18n into your Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">3 application.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">In the next chapter, we will explore GraphQL, GraphQL Apollo Server 2, queries, mutations, and how to integrate these technologies into your Vue.js 3 application. </span><span class="koboSpan" id="kobo.583.2">In addition, you will learn how to utilize GraphQL to deliver scalable and </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">high-performing applications.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer034">
</div>
</div>
</body></html>