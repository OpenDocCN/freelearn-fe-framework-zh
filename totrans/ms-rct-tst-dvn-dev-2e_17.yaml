- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Your First Cucumber Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-driven development is primarily a process for developers. Sometimes, customers
    and product owners want to see the results of automated tests too. Unfortunately,
    the humble unit test that is the foundation of TDD is simply too low-level to
    be helpful to non-developers. That’s where the idea of **Behavior Driven Development
    (BDD)** comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'BDD tests have a few characteristics that set them apart from the unit tests
    you’ve seen so far:'
  prefs: []
  type: TYPE_NORMAL
- en: They are **end-to-end tests** that operate across the entire system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are written in natural language rather than code, which is understandable
    by non-coders and coders alike.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They avoid making references to internal mechanics, instead focusing on the
    outward behavior of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test definition describes itself (with unit tests, you need to write a test
    description that matches the code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax is designed to ensure that your tests are written as examples, and
    as discrete specifications of behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BDD tools vs TDD vs unit tests
  prefs: []
  type: TYPE_NORMAL
- en: The style of TDD you’ve seen so far in this book treats (for the most part)
    its tests as examples that specify behavior. Also, our tests were always written
    in the **Arrange-Act-Assert (AAA)** pattern. However, notice that unit test tools
    such as Jest do not force you to write tests this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one reason why BDD tools exist: to force you to be very clear when
    you specify the behavior of your system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces two new software packages: Cucumber and Puppeteer.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Cucumber to build our BDD tests. Cucumber is a system that exists
    for many different programming environments, including Node.js. It consists of
    a test runner that runs tests contained within **feature files**. Features are
    written in a plain-English language known as **Gherkin**. When Cucumber runs your
    tests, it translates these feature files into function calls; these function calls
    are written in JavaScript **support scripts**.
  prefs: []
  type: TYPE_NORMAL
- en: Since Cucumber has its own test runner, it doesn’t use Jest. However, we will
    make use of Jest’s `expect` package in some of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber is not the only way to write system tests
  prefs: []
  type: TYPE_NORMAL
- en: Another popular testing library is Cypress, which may be a better choice for
    you and/or your team. Cypress puts the emphasis on the visual presentation of
    results. I tend to avoid it because its API is very different from industry-standard
    testing patterns, which increases the amount of knowledge developers need to have.
    Cucumber is cross-platform and tests look very similar to the standard unit tests
    you’ve seen throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Puppeteer** performs a similar function to the JSDOM library. However, while
    JSDOM implements a fake DOM API within the Node.js environment, Puppeteer uses
    a real web browser, Chromium. In this book, we’ll use it in *headless* mode, which
    means you won’t see the app running onscreen; but you can, if you wish, turn headless
    mode off. Puppeteer comes with all sorts of bolt-ons, such as the ability to take
    screenshots.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-browser testing
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to test cross-browser support for your application, you may be better
    off looking at an alternative such as Selenium, which isn’t covered in this book.
    However, the same testing principles apply when writing tests for Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Cucumber and Puppeteer into your code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first Cucumber test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data tables to perform setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have a good idea of how a Cucumber test is
    built and run.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter17)'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Cucumber and Puppeteer into your code base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s add the necessary packages to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the packages we’re after. As well as Cucumber and Puppeteer,
    we’ll also pull in `@babel/register`, which will enable us to use ES6 features
    within our support files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new file named `cucumber.json` with the following content. This
    has two settings; `publishQuiet` turns off a bunch of noise that would otherwise
    appear when you run tests, and `requireModule` hooks up `@babel/register` before
    tests are run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new folder called `features`. This should live at the same level as
    `src` and `test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another folder within that called `features/support`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now run tests with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Throughout this chapter and the following one, it may be helpful to narrow
    down the tests you’re running. You can run a single scenario by providing the
    test runner with the filename and starting line number of the scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to getting set up with Cucumber and Puppeteer—now it’s time
    to write a test.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Cucumber test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll build a Cucumber feature file for a part of the Spec
    Logo application that we’ve already built.
  prefs: []
  type: TYPE_NORMAL
- en: Warning on Gherkin code samples
  prefs: []
  type: TYPE_NORMAL
- en: If you’re reading an electronic version of this book, be careful when copying
    and pasting feature definitions. You may find extra line breaks are inserted into
    your code that Cucumber won’t recognise. Before running your tests, please look
    through your pasted code snippets and remove any line breaks that shouldn’t be
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Before running any Cucumber tests, it’s important to ensure that your build
    output is up to date by running `npm run build`. Your Cucumber specs are going
    to run against the code built in the `dist` directory, not your source in the
    `src` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use package.json scripts to your advantage
  prefs: []
  type: TYPE_NORMAL
- en: You could also modify your `package.json` scripts to invoke a build before Cucumber
    specs are run, or to run webpack in watch mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `features/sharing.feature` and enter the following
    text. A feature has a name and a short description, as well as a bunch of scenarios
    listed one after another. We’ll start with just one scenario for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Gherkin syntax
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**, **When**, and **Then** are analogous to the **Arrange**, **Act**,
    and **Assert** phases of your Jest tests: *given* all these things are true, *when*
    I perform this action, *then* I expect all these things to happen.'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you’d have a single **When** clause in each of your scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that I’ve written the **Given** clauses in past tense and the
    **When** clause in the present tense, and the **Then** clause has a “should” in
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run the feature by typing `npx cucumber-js` at the command line.
    You’ll see a warning printed, as shown in the following code block. Cucumber has
    stopped processing at the first `Given...` statement because it can’t find the
    JavaScript support function that maps to it. In the warning, Cucumber has helpfully
    given you a starting point for the definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s do exactly what it suggested. Create the `features/support/sharing.steps.js`
    file and add the following code. It defines a step definition that calls Puppeteer’s
    API to launch a new browser, then open a new page, and then navigate to the URL
    provided. The step definition description matches up with the **Given** clause
    in our test scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second parameter to `async` keyword. This is an addition to what Cucumber
    tells us in its suggested function definition. We need `async` because Puppeteer’s
    API calls all return promises that we’ll need to `await`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Anonymous functions, not lambda expressions
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we are defining anonymous functions (`async function
    (...) { ... }`) rather than lambda expressions (`async (...) => { ... }`). It
    allows us to take advantage of the implicit context binding that occurs with anonymous
    functions. If we used lambdas, we’d need to call `.bind(this)` on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your tests again. Cucumber now dictates the next clause that needs work.
    For this clause, `And the presenter clicked the button ''startSharing''`, we need
    to get access to the `page` object we just created in the previous step. The way
    to do this is by accessing what’s known as the `World` object, which is the context
    for all the clauses in the current scenario. We must build this now. Create the
    `features/support/world.js` file and add the following content. It defines two
    methods, `setPage` and `getPage`, which allow us to save multiple pages within
    the world. The ability to save multiple pages is important for this test, where
    we have at least two pages—the presenter page and the observer page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use the `setPage` and `getPage` functions from within our step definitions.
    Our approach will be to call `setPage` from the first step definition—the one
    we wrote in *step 3*—and then use `getPage` to retrieve it in subsequent steps.
    Modify the first step definition now to include the call to `setPage`, as shown
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moving on to the next step, `the presenter clicked the button ''startSharing''`,
    we’ll solve this by using the `Page.click` Puppeteer function to find a button
    with an ID of `startSharing`. As in the last test, we use a `buttonId` parameter
    so that this step definition can be used with other buttons in future scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step, `the observer navigates to the presenter''s sharing link`, is
    like the first step in that we want to open a new browser. The difference is that
    it’s for the observer, and we first need to look up the path to follow. The path
    is given to us through the URL that the presenter is shown once they start searching.
    We can look that up using the `Page.$eval` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Step definition duplication
  prefs: []
  type: TYPE_NORMAL
- en: There’s some duplication building up between our step definitions. Later on,
    we’ll extract this commonality into its own function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step definition uses the `Page.$eval` Puppeteer function again, this
    time to find an HTML node and then transform it into a plain JavaScript object.
    We then test that object using the `expect` function in the normal way. Make sure
    to place the listed `import` statement at the top of your file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run your tests with `npx cucumber-js`. The output from your test run will look
    as follows. While our step definitions are complete, something is amiss:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although our app has loaded, we still need to spin up the server to process
    our requests. To do that, add the following two functions to the `World` class
    in `features/support/world.js`, including the `import` statement for the app at
    the top of the file. The `startServer` function is equivalent to how we start
    the server in `server/src/server.js`. The `closeServer` function stops the server,
    but before it does this, it closes all Puppeteer browser instances. It’s important
    to do this before closing the server. That’s because the server does not kill
    any live websocket connections when the `close` method is called. We need to ensure
    they are closed first; otherwise, the server won’t stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting a server from within the same project
  prefs: []
  type: TYPE_NORMAL
- en: We are lucky that all our code lives within the same project, so it can be started
    within the same process. If your code base is split over multiple projects, you
    may find yourself dealing with multiple processes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Make use of these new functions with the `Before` and `After` hooks. Create
    a new file, `features/support/hooks.js`, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `npx cucumber-js` command and observe the output. Your scenario should
    now be passing (if it isn’t, double-check you’ve run `npm run build`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s go back and tidy up that repeated code. We’ll extract a function called
    `browseToPageFor` and place it within our `World` class. Open `features/support/world.js`
    and add the following method at the bottom of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, move the Puppeteer `import` statement across from `features/support/sharing.steps.js`
    into `features/support/world.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, rewrite the two navigation steps in terms of `browseToPageFor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observing within a browser and with console logging
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests we’ve written run Puppeteer in headless mode, meaning that an actual
    Chrome browser window doesn’t launch. If you’d like to see that happen, you can
    turn headless mode off by modifying the launch commands (remember there are two
    in the previous step definitions) to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const browser = await puppeteer.launch(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ headless: false }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using console logging to assist in your debugging, you’ll need to
    provide another parameter to dump console output to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const browser = await puppeteer.launch(`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ dumpio: true }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`);`'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now written a BDD test with Cucumber and Puppeteer. Next, let’s look
    at a more advanced Cucumber scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Using data tables to perform setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at a useful time-saving feature of Cucumber: data
    tables. We’ll write a second scenario that, as with the previous one, will already
    pass given the existing implementation of Spec Logo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new feature file called `features/drawing.feature` with the following
    content. It contains a set of instructions to draw a square using a Logo function.
    A small side length of `10` is used; that’s to make sure the animation finishes
    quickly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first phrase does the same thing as our previous step definition, except
    we’ve renamed `presenter` to `user`. Being more generic makes sense in this case
    as the role of the presenter is no longer relevant to this test. We can use the
    `World` function `browseToPageFor` for this first step. In the sharing feature,
    we used this function together with an `appPage` constant that contained the URL
    to navigate to. Let’s pull that constant into `World` now. In `features/support/world.js`,
    add the following constant at the top of the file, above the `World` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method to the `World` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `features/support/sharing.steps.js`, remove the definitions for `port` and
    `appPage` and update the first step definition, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s time to create a new step definition for a user page. Open the `features/support/drawing.steps.js`
    file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, what about the second line, with the data table? What should our step
    definition look like? Well, let’s ask Cucumber. Run the `npx cucumber-js` command
    and have a look at the output. It gives us the starting point of our definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go ahead and add the suggested code to `features/supports/drawing.steps.js`.
    If you run `npx cucumber-js` at this point, you’ll notice that Cucumber successfully
    notices that the step definition is pending:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `dataTable` variable is a `DataTable` object with a `raw()` function that
    returns an array of arrays. The outer array represents each row, and the inner
    arrays represent the columns of each row. In the next step definition, we want
    to take every single line and insert it into the edit prompt. Each line should
    be followed by a press of the *Enter* key. Create that now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step requires us to look for line elements with the right attribute
    values and compare them to the values in our second data table. The following
    code does exactly that. Copy it out now and run your tests to ensure that it works
    and that the test will pass. An explanation of all the detailed points will follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That last test contained some complexity that’s worth diving into:'
  prefs: []
  type: TYPE_NORMAL
- en: We used `Page.waitForTimeout` to wait for 2 seconds, which gives the system
    time to complete animations. Including a timeout like this is not a great practice,
    but it’ll work for now. We’ll look at a way of making this more specific in the
    next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Page.$$eval` function is like `Page.$eval` but returns an array under the
    hood, and calls `document.querySelector` rather than `document.querySelectorAll`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important that we do all of the attribute transformation logic—moving from
    HTML line elements and attributes to “plain” integer values of `x1`, `y1`, and
    so on—within the `transform` function of `Page.$$eval`. This is because Puppeteer
    will garbage collect any DOM node objects once the `$$eval` call is done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our line values need to be parsed with `parseFloat` because the `requestAnimationFrame`
    logic we coded doesn’t perfectly line up with the integer endpoints—they are out
    by very slight fractional amounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That also means we need to use the `toBeCloseTo` Jest matcher rather than `toBe`,
    which we need because of the fractional value difference described previously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use the `DataTable` `hashes()` function here to pull out an array
    of objects that has a key for each of the columns in the data table, based on
    the header row that we provided in the feature definition. So, for example, we
    can call `hashes()[0].x1` to pull out the value in the `x1` column for the first
    row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go ahead and run your tests again with `npx cucumber-js`. Everything should
    be passing.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now got a good understanding of using Cucumber data tables to make more
    compelling BDD tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber tests (and BDD tests in general) are similar to the unit tests we’ve
    been writing in the rest of the book. They are focused on specifying *examples*
    of behavior. They should make use of real data and numbers as means to test a
    general concept, like we’ve done in the two examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: BDD tests differ from unit tests in that they are system tests (having a much
    broader test surface area) and they are written in natural language.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with unit tests, it’s important to find ways to simplify the code when
    writing BDD tests. The number one rule is to try to write generic `World` class
    or some other module. We’ve seen an example of how to do that in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll use a BDD test to drive the implementation of a new
    feature in Spec Logo.
  prefs: []
  type: TYPE_NORMAL
