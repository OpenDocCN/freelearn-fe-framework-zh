- en: Chapter 7. Flip Flop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we should be confident about performing the initial implementation
    of an Angular application using TDD. Also, we should be familiar with using the test-first
    approach. The test-first approach is very good for the learning stage, but sometimes
    it's a time suck when we get a lot of errors. For simple and known behavior, it
    may not be good to go for the test-first approach.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen how the test-first approach works, so we can skip those
    steps by checking any feature without creating those components. Besides that,
    we can go one step further to make us more confident in writing our components
    faster. We can have our components ready and then write end-to-end test specs
    to test the expected behavior. If the e2e test fails, we can trigger an error
    in the Protractor debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will continue to expand our knowledge of applying TDD (but
    not the test-first approach) with Angular. We will not discuss the details of
    the basic Angular component ecosystem here; rather, we will go a step ahead and include more
    Angular features. We will take our knowledge further by looking at the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with route parameter data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "Protractor location references with CSS and \LHTML elements"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamentals of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will walk-through applying TDD to routes and navigation
    for a search application. Before getting into the walk-through, we need to be
    aware of some of the techniques, configurations, and functions that will be used
    throughout this chapter, which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Protractor locators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headless browser testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reviewing these concepts, we can move on to the walk-through.
  prefs: []
  type: TYPE_NORMAL
- en: Protractor locators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protractor locators are key components where everybody should spend some time
    to learn. In the previous Protractor chapters, we understood some commonly used
    locators with working examples. We will provide some examples of the Protractor
    `Locator` here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protractor locators allow us to find elements within an HTML page. In this
    chapter, we will see the CSS, HTML, and Angular-specific locators in action. Locators
    are passed to the `element` function. The `element` function will find and return
    the elements on a page. The generic locator syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `<LOCATOR>` is a placeholder. The following sections
    describe a couple of these locators.
  prefs: []
  type: TYPE_NORMAL
- en: CSS locators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSS is used to add layout, color, formatting, and style to an HTML page. From
    an end-to-end testing perspective, the look and style of an element may be part
    of a specification. As an example, consider the following HTML snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All these four selections will select the `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: Button and link locators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides being able to select and interpret the way something looks, it is also
    important to be able to find buttons and links within a page. This will allow
    a test to interact with the site easily. Here are a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buttonText` locator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`linkText` locator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: URL location references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When testing Angular routes, we need to be able to test the URL of our test.
    By adding tests around the URL and location, we have to ensure that the application
    works with specific routes. This is important because routes provide an interface
    to our application. Here is how to get the URL reference in a Protractor test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to use the different locators, it is time to put the
    knowledge to use.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing an Angular project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to get a process and method to set up your projects quickly.
    The less time you spend on thinking about the structure of the directory and the
    required tools, the more time you can spend developing!
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, in the previous chapters, we looked at how to get simple existing
    projects for Angular developed as `quickstart` projects ([https://github.com/angular/quickstart](https://github.com/angular/quickstart)).
  prefs: []
  type: TYPE_NORMAL
- en: However, some people use the `angular2-seed` ([https://github.com/mgechev/angular2-seed](https://github.com/angular/angular-seed))
    project, Yeoman, or create a custom template. Although these techniques are useful
    and have their merits, when starting out in Angular, it is essential to understand
    what it takes to build an application from the ground up. By building the directory
    structure and installing tools by ourselves, we will understand Angular better.
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to make layout decisions based on your specific application
    and needs, as opposed to fitting them into some other module. As you grow and
    become a better Angular developer, this step may not be needed and will become
    second nature to you.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the existing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off, we will clone the project from the Angular `quickstart` project
    at [https://github.com/angular/quickstart](https://github.com/angular/quickstart),
    rename it as `angular-flip-flop`, and our project folder structure will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading the existing project](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapters, we discussed how to set up the project, understood the
    different components involved, and walked through the entire process. We will
    skip these details and assume that you can recall how to perform the necessary
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `quickstart` project doesn''t included the base `href` in the project''s
    landing page (`index.html`). We will need that to proceed perfectly with routing,
    so let''s add a single line (`base href`) to the `<head>` section of `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, our bootstrapping component is in the application component and the HTML
    template is in the component itself. We should separate the template to a new
    file before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we will update our application component (`app/app.component.ts`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create our separate template file at `app/app.component.html`. And the
    code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s proceed with it and get ready to run using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To confirm the installation and run the project, the application will automatically
    run in the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the expected output after running the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the project](img/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Restructuring the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's change the project structure a bit, not much though. By default, it has
    included unit testing in the same location as the components file and separated
    the e2e testing file outside the `app/` folder in the `e2e/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will keep all the tests in the same location, that is, outside of
    `app`; we will keep all the tests as `spec/e2e` and `spec/unit`.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to separate the test specs from the component. This way, we can
    keep our unit tests file outside in the `spec/unit` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our current folder structure will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Restructuring the project](img/image_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As long as we have changed the path for both unit and e2e tests, we should have
    to change the path in the Karma configuration and Protractor configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up headless browser testing for Karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we were running Karma using the default configuration.
    The default Chrome configuration launches Chrome on every test. Testing against
    the actual code and browser that the application will run in is a powerful tool.
    However, when launching, a browser may not always know how you want it to behave.
    From a unit test perspective, you may not want the browser to be launched in a
    window. The reason could be that tests may take a long time to run or you may
    not always have a browser installed.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Karma comes equipped with the ability to easily configure PhantomJS,
    a headless browser. A headless browser runs in the background and will not display
    web pages in a UI. The PhantomJS headless browser is a really great tool to use
    for testing. It can even be set up to take screenshots of your tests! Read more
    about how this is done and about the WebKit used on the PhantomJS site at [http://phantomjs.org/](http://phantomjs.org/).
    The following setup configuration will show us how to set up PhantomJS with Karma
    for headless browser testing.
  prefs: []
  type: TYPE_NORMAL
- en: Preconfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Karma is installed, it automatically includes the PhantomJS browser plugin.
    For further reference, the plugin is located at [https://github.com/karma-runner/karma-phantomjs-launcher](https://github.com/karma-runner/karma-phantomjs-launcher).
    There shouldn't be any more installation or configuration required.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if your setup states that it is missing `karma-phantomjs-launcher`,
    you can easily install it using `npm`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PhantomJS is configured in the `browsers` section of the Karma configuration.
    Open the `karma.conf.js` file and update it with the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Do that in the `plugins` option as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that the project has been initialized and configured with headless browser
    testing, you can see it in action through the following walk-throughs.
  prefs: []
  type: TYPE_NORMAL
- en: Walk-through of Angular routes and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This walk-through will leverage Angular routes. Routes are an extremely useful
    feature of Angular, as they were in Angular 1.x before it, but more powerful.
    They allow us to control certain aspects of the application using different components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This walk-through will flip between components to show us how to use TDD to
    build routes. The following are the specifications. There will be a navigation
    menu, which has two menu items, **View1** and **View2**:'
  prefs: []
  type: TYPE_NORMAL
- en: In the navigation menu, click on label **View1**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content area (router outlet) will load/flip **View1** content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here''s the second part:'
  prefs: []
  type: TYPE_NORMAL
- en: In the navigation menu, click on label **View2**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content area (router outlet) will load/flip **View2** content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, this will be an application that does a flip/flop between two views.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Angular routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The router is an optional service in Angular, so it's not included in the Angular
    core. If we need to use the router, we will have to install the Angular `router`
    service in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as we have cloned our project from `quickstart`, we should be okay
    because it has recently added the Angular router to its dependencies, but we should check
    and confirm. If it doesn''t have `@angular/router` in its dependencies in `package.json`,
    we can install the Angular router using `npm`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Defining directions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A route specifies a location and expects a result. From an Angular perspective,
    the routes must first be specified and then associated with certain components.
  prefs: []
  type: TYPE_NORMAL
- en: To implement a router in our application, we will need to import the router
    module in the application module, where it will register the router in the application.
    After that, we will need to configure all the routes and pass that configuration
    to the application module.
  prefs: []
  type: TYPE_NORMAL
- en: The router module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement a router in the application, we will need to import the `RouterModule`
    in our application module, located at `app/app.module.ts`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will just make the `router` module available in the application system,
    but we will have to have a router configuration to define all the possible routers
    in the entire application and then import that configuration to the application
    ecosystem via the application module.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A router is useless until we configure it, and to do so, we first need to import
    the `router` component. Configuration will mainly contain a list of arrays, where
    route paths and related components live as key-value pairs. We can add the configuration
    array to the application module, or we can create a separate configuration file
    and include the app module in it. We will go for the second option so that route
    configuration will be separated from the app module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the router configuration file in the application root as `app/app.routes.ts`.
    There, at first, we will need to import the Angular `Routes` from the Angular
    service, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'From the router config file, we will need to export the configuration array,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Routers in the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've already imported the `router` module to our application module, located
    at `app/app.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will need to import the router configuration file (`rootRouterConfig`)
    to this application module file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the application module, we know `NgModule` imports the optional modules to
    the application ecosystem, and similarly, to include the router in the application,
    `RouterModule` has a function known as `RouterModule.forRoot(RouterConfig)`, which
    accepts the `routerConfiguration` to implement a router in the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application module (`app/app.module.ts`) will import that `RouterModule`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Routes in the config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's add some routes to our `Routes` configuration array, which is located
    at `app/app.routes.ts`. The route configuration array contains some objects as
    key-value pairs, with mostly two to three elements in every object.
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the array object contains the `path`, and the second one
    contains the relevant `component` to load for that `path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add two routes to our configuration array, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, two routes, `view1` and `view2`, are defined, and two components have
    been assigned to load for that route.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we may need to redirect from one route to another. For example,
    for the root path of the application (`''`), we may plan to redirect to the `view1`
    route. For that, we have to set the `redirectTo` element in the object and assign
    some route name as its value. We will also need to add one extra element as `pathMatch`
    and set its value to `full` so it will match the full path before redirecting
    to some other route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, yes, our initial route configuration is ready to go. Now, the full configuration
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I should mention here that we have to import the `view1` and `view2` components
    as we have used them in the router config.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more in detail about Angular routes, refer to [https://angular.io/docs/ts/latest/guide/router.html](https://angular.io/docs/ts/latest/guide/router.html).
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have installed and imported a router module, configured routes, and
    included things in the application ecosystem. We still need to do some related
    tasks, such as creating a router outlet, creating navigation, and creating the
    component defined in the route, to have hands-on experience with routes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the router outlet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As long as the route is configured in `appComponent`, we need a placeholder
    to load the route's navigated components, which Angular defines as the route outlet.
  prefs: []
  type: TYPE_NORMAL
- en: A `RouterOutlet` is a placeholder that Angular dynamically fills based on the
    application's route.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, we will place the `router-outlet` in the `appComponent`
    template, located at (`/app/app.component.html`), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Preparing the navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the route configuration, we have set two paths, `/view1` and `/view2`, for
    our application. Now, let's create the navigation menu with two route paths to
    make navigation easy. For that, we can create a separate simple component so that
    navigation can be isolated for the entire application component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component file for the `NavbarComponent` at `/app/nav/navbar.component.ts`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create a template for the navigation component at (`/app/nav/navbar.component.html`),
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't bother about the `members` link in in the navigation for now; I'll tell
    you what it is in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the basic CSS style for the navigation component for a better
    look at `/app/nav/navbar.component.css`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have a navigation component. Now we will have to bind that to our app component,
    which is our application landing page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we have to append the following to the `appComponent` template, located
    at `/app/app.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Preparing the components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each defined route, we will need to create an individual component as every
    route will be associated with a component.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have two defined routes, and we will need to create two individual
    components to work on the routes' navigation. We will create `View1Component`
    and `View2Component` as per our requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component file for the `View 1` component at `/app/view/view1.component.ts`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another component file for the `View 2` component (`/app/view/view2.component.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are ready with our routes and related components (`Navigation`, `View1`,
    and `View2`). Hopefully, everything's working as expected and we can see the application
    output in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Wait, before looking at the expected output in the browser, let's test the expected
    result with end-to-end testing. Now we know the expected behavior, and we will
    write out the e2e test specs based on our expectation. Once we're ready with the
    e2e test specs, we will see how it fulfills our expectation.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the flip/flop test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the first of the 3 As, *assemble*, these steps will show us how to
    assemble the test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the Protractor base template, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the root of the application using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `beforeEach` method needs to confirm that the correct component''s view
    is being displayed. This can be done using a CSS locator to look for the `div`
    tag of `view1`. The expectation will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add an expectation that `view2` is not visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add further confirmation by getting the entire text of the `view1` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Flipping to the next view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding test needs to confirm that when the `view2` link will be clicked
    in the navigation, the `view2` component''s content will load. In order to test
    this, we can use the `by.linkText` locator. Here is what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `beforeEach` function is now complete and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add the assertion.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting a flip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The assertion will again use Protractor''s CSS locator, as shown here, to find
    whether `view2` is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to confirm that `view1` is no longer available. Add the expectation
    that `view1` should not exist, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, to make sure, we can check whether the `view2` contents have been loaded,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have the test about to switch from the `view1` to `view2` component by
    clicking on the `view2` link in the navigation, let''s go back to the `view1`
    component by clicking on the `view1` link in the navigation, hoping things work
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The test has now been assembled.
  prefs: []
  type: TYPE_NORMAL
- en: Running the flip/flop test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our test spec is ready, and it's time to run it and see the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will have to keep our project running via the HTTP server, with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to run Protractor. Be sure about the port number of the running
    application and Protractor configuration file; just to be sure, update the running
    server port in the configuration. To run Protractor, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The results should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The Protractor tests have passed as per our expectations. Now we can have a
    look at the browser to check whether things are working the same way as the e2e
    test results.
  prefs: []
  type: TYPE_NORMAL
- en: Opening the app in a browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As long as we've run the `npm start` command for e2e testing, our application
    could run on a specific port, `3000`,  on the localhost. By default, it will open
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Opening the app in a browser](img/B05405_07_04-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Searching the TDD way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This walk-through will show us how to build a simple search application. It has
    two components: the first discusses a search query component, and the second uses
    routes to display search result details.'
  prefs: []
  type: TYPE_NORMAL
- en: Walk-through of the search query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application being built is a search application. The first step is to set
    up the search area with search results. Imagine that I am performing a search.
    In this case, the following actions will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: A search query is typed in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are displayed at the bottom of the search box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This piece of the application is very similar to the test, layout, and approach
    we have seen in [Chapter 6](ch06.html "Chapter 6. The First Step"), *The* *First
    Step*. The application will need to use an input, respond to a click, and confirm
    the resulting data. Since the tests and code use the same functionality as the
    previous example, it is not worth providing a complete walk-through of the search
    functionality. Instead, the following subsections will show the required code
    with a few explanations.
  prefs: []
  type: TYPE_NORMAL
- en: The search query test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code represents the test for the search query functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We should notice a parallel to the previous tests. The functionality is written
    to mirror the behavior of a user typing in the search box. The test finds the
    input field, types a value, and then selects the button that says **Search**.
    The assertion confirms that the result contains a single value.
  prefs: []
  type: TYPE_NORMAL
- en: The search application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To perform a search operation, we will need to create a search component that
    will contain an input field to accept the user input (search query) and a button
    to perform user action with a click event. Besides that, it may have a placeholder
    to contain the search result.
  prefs: []
  type: TYPE_NORMAL
- en: As long as our application already has the router included, we can place the
    search component for a specific route.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have called our search component as `MembersComponent`, since we
    worked with some member data in the search component. And routes will be configured
    based on that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our existing `app.routes.ts` file, we will add the following search
    routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The search component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The search component (`MembersComponent`) will be the main class for the search
    functionality here. It will perform a search and return the search result.
  prefs: []
  type: TYPE_NORMAL
- en: During the initial loading of the search component, it will not have any search
    query, so we have set the behavior to return all the data. Then, after the search
    trigger, it will return data based on a search query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search component will be placed in `app/members/members.compoennt.ts`.
    In the code, at first, we will have to import the required Angular services, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `Http` service for the AJAX call, and by default, in Angular,
    the `Http` service returns an observable object. However, it''s easier to handle
    a promise than an observable object. So, we will convert this observable object
    to a promise. Angular suggests using the `rxjs` module, which has the `toPromise`
    method, used to convert an observable object to a promise. So, we will import
    the `rxjs` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Angular introduced the `ngOnInit()` method to be executed while initializing
    the component, similar to the contractor method in any class, but it's helpful
    to run the test spec. For that, we have imported the `OnInit` interface from the
    Angular core, and the `Component` class will implement the `OnInit` interface
    to get the `ngOnInit` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides that, the `Component` class should inject the required module, such
    as `Http` and `Router`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed, we will use the `ngOnInit()` method, and from that, we will initialize
    the searching mechanism, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will apply the `search` feature on a member list, and for that, we
    have some dummy data at `app/data/people.json`. We will retrieve the data from
    here and perform a search operation on the data. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: The `getData()` method will retrieve the data from the API and will return a
    promise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `searchQuery()` method will resolve the returned promise and will make
    a data array based on the search query. If no search query is provided, it will
    return the complete dataset as an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `search()` method will prepare the dataset for the template to bind to
    in the frontend:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one more optional method here, which is used to navigate to the member
    details component. We''ve called that the `person` component. Here, the `viewDetails()`
    method will pass the member ID, and the `router.navigate()` method will navigate
    the application to the `person` component with the ID as a parameter, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code of `MembersComponent` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `search` component template contains the search form and the list of search
    results when there are results to show.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding Angular components are similar to what has already been shown
    in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We are using a dummy dataset from the `people.json` file, which contains information
    about people with addresses. We want to split the information in two parts, one
    as summary information and the other with address details. As we will work with
    this dataset, it will be easy to make an object model for this dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The summary dataset will be defined as a `Person` object, and address details
    will be defined as `Address`. Let's create a person object at `app/members/person/person.component.ts`
    and place both object models in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two object model classes for `Person` and `Address` look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Show me the search results!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the **Search** button is set with the required features, the result
    should contain the data only based on the search query, instead of everything.
    Let's look at the user specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a set of search results:'
  prefs: []
  type: TYPE_NORMAL
- en: We will have the member list based on the search query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will click on any member's name and navigate to the details component for
    details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the top-down approach, the first step will be the Protractor test,
    followed by the necessary steps to get the application fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the search results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the specification states, we will need to leverage the existing search results.
    Instead of creating a test from scratch, we can add to the existing search query
    test. Start with a base test embedded in the search query test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The next step is building the test.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the search result test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, the search results are already available from the search query
    test. We don't have to add any more setup steps for the test.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a search result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The object under testing is the result. The test is that the result is selected
    and the application must then do something. The steps to writing this in Protractor
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `resultItem`. As we will be representing the details using a route,
    we will create a link to the details page and click on the link. Here is how to
    create a link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the link within the `resultItem`. This uses the currently selected element
    and then finds any subelements that meet the criteria. The code for this is as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to select the link, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Confirming a search result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the search item has been selected, we will need to verify that the
    result details page is visible. The simplest solution at this point is to ensure
    that the details view is visible. This can be done using Protractor''s CSS locator
    to look for the search detail view. The following is the code to be added for
    confirming a search result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the complete test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now that the test is set up, we can continue to the next phase of the life cycle
    and run it.
  prefs: []
  type: TYPE_NORMAL
- en: The search result component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The search result component (the one we named `Person`) will route to accept
    the person ID from the `params` route and will search data based on that ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search result component will be placed in `app/members/person/person.component.ts`.
    In the code, at first, we will have to import the required Angular services, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already seen some of these Angular services in the `members` component.
    Here, we will mainly discuss the `ActivatedRoute`, as it''s new. This is an Angular
    router module, which is used to interact with the current/activated route: when
    we need to access the `params` in the current route, we''ll access them through this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed, we will need `ActivatedRoute` while initializing the component;
    therefore, we have called `ActivatedRoute` on the `ngOnInit()` method. It will
    provide the current route params for us, and we will have our expected ID, which
    will be used to retrieve that specific `Person` from the demo members dataset,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We have some dummy data at `app/data/people.json`. This is the same data used
    in the `members` component. We will retrieve the data based on the selected ID,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getData()` method will retrieve the data from the API and will return
    a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `getPerson()` method will resolve the returned promise and will return the
    `Person` object based on the selected ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code regarding `PersonComponent` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `search` component template contains the search form and the list of search
    results when there are some results to show.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Search results in the route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the search result/`Person` component, but we forgot to include that
    in the router configuration. Without that, we will have an exception as it will
    not be possible to navigate to the `Person` component from the `members` list
    without having it in the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our existing `app.routes.ts` file, we will add the following search
    routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Running the search wheel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is ready with the restructure, route configuration, e2e testing,
    and components with their child components. We will look at the current file structure
    and output of the project.
  prefs: []
  type: TYPE_NORMAL
- en: App structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have two major folders in our application, one is the `app` directory and
    the other is the `spec/test` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the current structure of our `app` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![App structure](img/B05405_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s the `test` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![App structure](img/B05405_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our search feature is ready to run. If we run `npm start`, our application will
    run in the browser on the port `3000` by default. Let's navigate to **Members**
    to get the output of the search feature. The search feature URL is `http://localhost:3000/members`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we land on the **Members** page, it will actually load all the data as
    the search input is empty, which means there is no search query. The output should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s run](img/image_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s check the **Members** page with a search query. If we type `Thomas`
    as the query and search, it will give us only one data row, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s run](img/image_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have one row in the data list. Now it''s time to see the details of the
    data. After clicking on **Thomas**, we will see detailed information about Thomas,
    with the address, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s run](img/image_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hurray! The complete application is running in the browser as expected.
  prefs: []
  type: TYPE_NORMAL
- en: How's e2e now!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project is running in the browser, and we've done e2e testing for every
    component. Let's see how the e2e test reacts when we run the whole application's
    e2e test together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `npm run e2e`; the output is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How''s e2e now!](img/B05405_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. Which custom placeholder is used to load the component after navigation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Q2\. Given the following Angular component, how would you select the `element`
    and simulate a click?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Q3\. When using routes with Angular, you need to install `@angular/router`.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed us how to use TDD to build an Angular application. The approach,
    up to this point, has focused on the specification from a user perspective and
    using TDD with a top-down approach. This technique helps us get usable and small
    components tested and completed for the users.
  prefs: []
  type: TYPE_NORMAL
- en: As applications grow, so does their complexity. In the next chapter, we will
    explore the bottom-up approach and see when to use that technique over the top-down
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter showed us how TDD can be used to develop a component-based application
    with navigation by routers. Routes allow us to get a nice separation of our components
    and views. We looked at the usage of several Protractor locators, from CSS to
    repeaters, link text, and inner locators. Besides using Protractor, we also learned
    how to configure Karma with a headless browser, and we got to see it in action.
  prefs: []
  type: TYPE_NORMAL
