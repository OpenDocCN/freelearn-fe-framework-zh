- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Logo Interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logo is a programming environment created in the 1960s. It was, for many decades,
    a popular way to teach children how to code—I have fond memories of writing Logo
    programs back in high school. At its core, it is a method for building graphics
    via imperative instructions.
  prefs: []
  type: TYPE_NORMAL
- en: In this part of the book, we’ll build an application called **Spec Logo**. The
    starting point is an already-functioning interpreter and a barebones UI. In the
    following chapters, we’ll bolt on additional features to this codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides a second opportunity to test-drive Redux. It covers the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Studying the **Spec Logo** user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undoing and redoing user actions in Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving to local storage via Redux middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing keyboard focus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have learned how to test-drive complex Redux
    reducers and middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter14)'
  prefs: []
  type: TYPE_NORMAL
- en: Studying the Spec Logo user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The interface has two panes: the left pane is the drawing pane, which is where
    the output from the Logo script appears. On the right side is a prompt where the
    user can edit instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: The Spec Logo interface ](img/Figure_14.01_B18423.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: The Spec Logo interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the screenshot. You can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **script name** in the top-left corner. This is a text field that the user
    can click on to change the name of the current script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **display**, which shows script output on the left-hand side of the page.
    You can see a shape has been drawn here, which is the result of the Logo statements
    entered at the prompt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **turtle**, shown in the middle of the screen. This is a little green triangle
    that marks where drawing commands originate. The turtle has an *x* and *y* position,
    starting at *0,0*, which is the middle of the screen. The viewable drawing is
    600x600 in size, and the turtle can move throughout this area. The turtle also
    has an angle, initially zero, which is pointing directly right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **prompt** in the bottom right-hand corner, marked with a **>** symbol.
    This is where you enter your statements, which can be multiline. Hitting *Enter*
    will send the current prompt text to the interpreter. If it makes a complete statement,
    it will be executed, and the prompt cleared ready for your next statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **statement history** above the prompt. It lists all the previously executed
    statements. Each is given a number so you can refer back to the statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **menu bar** in the top-right corner, containing **Undo**, **Redo**, and **Reset**
    buttons. It is this menu bar that we’ll be building out in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although we won’t be writing any Logo code in this chapter, it’s worth spending
    some time playing around and making your own drawings with the interpreter. Here’s
    a list of instructions that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18423_Table_14.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s also worth looking through the codebase. The `src/parser.js` file and the
    `src/language` directory contain the Logo interpreter. There are also corresponding
    test files in the test directory. We won’t be modifying these files, but you may
    be interested in seeing how this functionality has been tested.
  prefs: []
  type: TYPE_NORMAL
- en: There is a single Redux reducer in `src/reducers/script.js`. Its `defaultState`
    definition neatly encapsulates everything needed to represent the execution of
    a Logo program. Almost all the app’s React components use this state in some way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be adding two more reducers into this directory: one
    for undo/redo and one for prompt focus. We’ll be making modifications to three
    React components: `MenuButtons`, `Prompt`, and `ScriptName`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by building a new reducer, named `withUndoRedo`.
  prefs: []
  type: TYPE_NORMAL
- en: Undoing and redoing user actions in Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll add undo and redo buttons at the top of the page, which
    allow the user to undo and redo statements that they’ve previously run. They’ll
    work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, both buttons will be disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user executes a statement, the **Undo** button will become enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user clicks the **Undo** button, the last statement will be undone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At that point, the **Redo** button becomes available, and the user can choose
    to redo the last statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple actions can be undone and then redone, in sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user performs a new action while **Redo** is available, the redo sequence
    is cleared, and the **Redo** button becomes unavailable again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Aside from adding button elements, the work involved here is building a new
    reducer, `withUndoRedo`, which will *decorate* the script reducer. This reducer
    will return the same state as the script reducer, but with two additional properties:
    `canUndo` and `canRedo`. In addition, the reducer stores `past` and `future` arrays
    within it that record the past and future states. These will never be returned
    to the user, just stored, and will replace the current state should the user choose
    to undo or redo.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the reducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reducer will be a higher-order function that, when called with an existing
    reducer, returns a new reducer that returns the state we’re expecting. In our
    production code, we’ll replace this store code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll replace it with this decorated reducer, which takes exactly the same
    reducer and wraps it in the `withUndoRedo` reducer that we’ll build in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To test this, we’ll need to use a spy to act in place of the script reducer,
    which we’ll call `decoratedReducerSpy`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the initial state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s make a start by building the reducer itself, before adding buttons to
    exercise the new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `test/reducers/withUndoRedo.test.js` and add the following
    setup and test, which specifies what should happen when we pass an undefined state
    to the reducer. This is equivalent to how we began testing our other reducers,
    but in this case, we pass the call through to the decorated reducer. The test
    passes an `undefined` state to the reducer, which is the required mechanism for
    initializing a reducer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `src/reducers/withUndoRedo.js` file and make the test pass with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next test to the `describe` block, as shown. This uses the `toMatchObject`
    matcher, which we first encountered in [*Chapter 6*](B18423_06.xhtml#_idTextAnchor099),
    *Exploring Test Doubles*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by adding the `return` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initially, both `canUndo` and `canRedo` should be `false`, as there are no
    previous or future states that we can move to. Let’s add those two tests as a
    pair, still in the same `describe` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make these tests pass, we need to create a new object with those properties
    added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s move on to the meat of the reducer. After performing an action, we want
    to be able to perform an `present` and `future` constants to denote those states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass with the following code. Since we’re no longer dealing with
    an undefined state, this is the moment that we need to wrap our existing code
    in a conditional block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we make sure we call the reducer again since, for this new block, it
    won’t happen. Write the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, simply call the reducer before the `return` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next test shows that this object also needs to return the new state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by saving the reducer value in a variable named `newPresent`
    and returning it as part of the returned object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The script reducer holds a special value named `nextInstructionId`. We can
    use this to determine whether the script instruction was processed or whether
    an error occurred. When a statement is valid, it is executed and `nextInstructionId`
    is incremented. But when a statement can’t be processed, `nextInstructionId` remains
    the same. We can use that fact to avoid saving history if a statement contains
    an error. To do that, modify the `present` and `future` constants to include this
    parameter, and add the new test, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by wrapping our new `return` block in a conditional, and returning
    the old state if the condition doesn’t pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This covers all the functionality for performing any actions *other than* **Undo**
    and **Redo**. The next section covers **Undo**.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the undo action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll create a new Redux action, of type `UNDO`, which causes us to push the
    current state into a new array called `past`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this test, we can reuse the `present` and `innerAction` properties, so
    push those up into the outer `describe` block now. Also, define a new `undoAction`
    Redux action. We’ll use it within our first test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new nested `describe` block with the following test and setup. The `beforeEach`
    block sets up a scenario where we’ve already performed an action that will have
    stored a previous state. We’re then ready to undo it within the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Performing an action within a beforeEach block
  prefs: []
  type: TYPE_NORMAL
- en: Notice the call to the `reducer` function in the `beforeEach` setup. This function
    is the function under test, so it could be considered part of the `reducer` is
    part of the test setup, since all these tests rely on having performed at least
    one action that can then be undone. In this way, we can consider this `reducer`
    call to be part of the **Assert** phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make that pass by modifying the function as follows. We use a `past` variable
    to store the previous state. If we receive an `UNDO` action, we return that value.
    We also use a `switch` statement since we’ll be adding a case for `REDO` later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s adjust this so that we can undo any number of levels deep. Add
    the next test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this, we’ll need to upgrade `past` to an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There’s one final test we need to do. We need to check that after undoing,
    we can also redo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, return a new object comprised of `lastEntry` and the new
    `canRedo` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all there is to the `UNDO` action. Next, let’s add the `REDO` action.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the redo action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Redo is very similar to undo, just reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a new definition for the Redux action of type `REDO`, in the top-level
    `describe` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Underneath the undo `describe` block, add the following redo `describe` block
    with the first test. Be careful with the setup for the spy; the call is `mockReturnValueOnce`
    here, not `mockReturnValue`. The test needs to ensure it takes its value from
    the stored `redo` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, in your production code, declare a `future` variable, next
    to the declaration for `past`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set this within the `UNDO` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that it’s saved, we can handle the `REDO` action. Add the following `case`
    statement, between the `UNDO` clause and the `default` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next test is for multiple levels of redo. This is slightly more complicated
    than the same case in the `undo` block—we’ll have to modify the `beforeEach` block
    to take us back *twice*. First, pull out the `futureFuture` value from the undo
    test and bring it into the outer scope, next to the other values, just below `future`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update `beforeEach` to take two steps forward and then two back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, start by initializing the `future` variable to be an empty
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `UNDO` clause to push the current value to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `REDO` clause to pull out that value we just pushed. After this
    change, the test should be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There’s one final test we need to write for our barebones implementation, which
    checks that a redo followed by an undo brings us back to the original state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by setting the `past` property in the `REDO` case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This completes our reducer. However, our implementation has a memory leak! We
    never clear out the `future` array when we generate new states. If the user repeatedly
    hit `future` but become inaccessible, due to `canRedo` being `false` in the latest
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test for this scenario, you can simulate the sequence and check that you
    expect to return `undefined`. This test isn’t *great* in that we really shouldn’t
    be sending a `REDO` action when `canRedo` returns `false`, but that’s what our
    test ends up doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To make that pass, simply clear `future` when setting a new state, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now done with the reducer. To finish this off, hook it into our Redux
    store. Open `src/store.js` and make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your tests should all be passing and the app should still run.
  prefs: []
  type: TYPE_NORMAL
- en: However, the undo and redo functionality is still not accessible. For that,
    we need to add some buttons to the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: Building buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final piece to this puzzle is adding buttons to trigger the new behavior
    by adding **Undo** and **Redo** buttons to the menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `test/MenuButtons.test.js` and add the following `describe` block at the
    bottom of the file, nested inside the `MenuButtons` `describe` block. It uses
    a couple of helper functions that have already been defined with the `renderWithStore`
    file and button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by modifying the implementation for `MenuButtons` as shown,
    in the `src/MenuButtons.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next test, which checks that the button is initially disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by adding a hardcoded `disabled` attribute, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add in the code that will require us to connect with Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `MenuButtons` to pull out `canUndo` from the store. It already uses
    the `script` state for the **Reset** button behavior, so in this case, we just
    need to destructure it further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final test for the `UNDO` action when it is clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by adding the lines highlighted next. We add the new `undo`
    action helper and then use that to call `dispatch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat from *Step 2* to *Step 8* for the `canRedo` property from the script
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s the last change needed. The undo and redo functionality is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we’ll move from building a Redux reducer to building Redux middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Saving to local storage via Redux middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll update our app to save the current state to *local storage*,
    a persistent data store managed by the user’s web browser. We’ll do that by way
    of Redux middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Each time a statement is executed in the `LocalStorage` API. When the user next
    opens the app, the tokens will be read and replayed through the parser.
  prefs: []
  type: TYPE_NORMAL
- en: The parseTokens function
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the parser (in `src/parser.js`) has a `parseTokens` function.
    This is the function we’ll call from within our middleware, and in this section,
    we’ll build tests to assert that we’ve called this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write a new piece of Redux middleware for the task. The middleware will
    pull out two pieces of the script state: `name` and `parsedTokens`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, let’s review the browser `LocalStorage` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`window.localStorage.getItem(key)` returns the value of an item in local storage.
    The value stored is a string, so if it’s a serialized object, then we need to
    call `JSON.parse` to deserialize it. The function returns `null` if no value exists
    for the given key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.localStorage.setItem(key, value)` sets the value of an item. The value
    is serialized as a string, so we need to make sure to call `JSON.stringify` on
    any objects before we pass them in here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s test-drive our middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `src/middleware` and `test/middleware` directories, and then open
    the `test/middleware/localStorage.test.js` file. To make a start, define two spies,
    `getItemSpy` and `setItemSpy`, which will make up the new object. We have to use
    `Object.defineProperty` to set these spies because the `window.localStorage` property
    is write protected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s write our first test for the middleware. This test simply asserts that
    the middleware does what all middleware should, which is to call `next(action)`.
    Redux middleware functions have complicated semantics, being functions that return
    functions that return functions, but our tests will make short work of that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, create the `src/middleware/localStorage.js` file and add
    the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next test checks that we return that value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `save` function to return that value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, check that we add the stringified value to local storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, complete the implementation of the `save` middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s move on to the `load` function, which isn’t middleware but there’s no
    harm in placing it in the same file. Create a new `describe` block with the following
    test, ensuring `import` is updated as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by defining a new function in the production code, by adding
    `load`, just below the definition of `save`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now to send this data to the parser. For this, we’ll need a `parserSpy` spy
    function that we use to spy on the parser’s `parseTokens` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following production code to make that pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next test makes sure the data is returned in the right format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by returning an object with the parsed response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s add the name to that data structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, first, we need to save the name that’s returned from local
    storage, and then we need to insert it into the `present` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to deal with the case where no state has been saved yet. The
    `LocalStorage` API gives us `null` back in that case, but we’d like to return
    `undefined`, which will trigger Redux to use the default state. Add this test
    to the outer `describe` block, so that it won’t pick up the extra `getItemSpy`
    mock values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by wrapping the `return` statement in an `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `src/store.js` and modify it to include the new middleware. I’m defining
    a new function, `configureStoreWithLocalStorage`, so that our tests can continue
    using `configureStore` without interacting with local storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `src/index.js` and replace the call to `configureStore` with a call to
    `configureStoreWithLocalStorage`. You’ll also need to update `import` for this
    new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it. If you like, this is a great time to run the app for a manual test
    and try it. Open the browser window, type a few commands, and try it out!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re stuck for commands to run a manual test, you can use these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: These commands exercise most of the functionality within the interpreter and
    display. They’ll come in handy in [*Chapter 15*](B18423_15.xhtml#_idTextAnchor306),
    *Adding Animation*, when you’ll want to be manually testing as you make changes.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve learned how to test-drive Redux middleware. For the final part of the
    chapter, we will write another reducer, this time one that helps us manipulate
    the browser’s keyboard focus.
  prefs: []
  type: TYPE_NORMAL
- en: Changing keyboard focus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user of our application will, most of the time, be typing in the prompt
    at the bottom right of the screen. To help them out, we’ll move the keyboard focus
    to the prompt when the app is launched. We should also do this when another element—such
    as the name text field or the menu buttons—has been used but has finished its
    job. Then, the focus should revert back to the prompt, ready for another instruction.
  prefs: []
  type: TYPE_NORMAL
- en: React doesn’t support setting focus, so we need to use a **React ref** on our
    components and then drop it into the DOM API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll do this via a Redux reducer. It will have two actions: `PROMPT_FOCUS_REQUEST`
    and `PROMPT_HAS_FOCUSED`. Any of the React components in our application will
    be able to dispatch the first action. The `Prompt` component will listen for it
    and then dispatch the second, once it has focused.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the reducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start, as ever, with the reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `test/reducers/environment.test.js` and add the following
    `describe` block. This covers the basic case of the reducer needing to return
    the default state when `undefined` is passed to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the test pass with the following code, in a file named `src/reducers/environment.js`.
    Since we’ve built reducers before, we know where we’re going with this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next test, which checks that we set the `promptFocusRequest` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by adding in a `switch` statement, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the final test for this reducer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, make that pass by adding another `case` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we can use the new reducer in our tests, we’ll need to add it to the
    store. Open up `src/store.js` and modify it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That gives us a new reducer that’s hooked into the Redux store. Now, let’s make
    use of that.
  prefs: []
  type: TYPE_NORMAL
- en: Focusing the prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s move on to the most difficult part of this: focusing the actual prompt.
    For this, we’ll need to introduce a React ref:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `test/Prompt.test.js` and add the following `describe` block at the bottom,
    nested within the `Prompt` `describe` block. The test uses the `document.activeElement`
    property, which is the element that currently has focus. It’s also using the `renderInTableWithStore`
    function, which is the same as the `renderWithStore` helper you’ve seen already,
    except that the component is first wrapped in a table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s make that pass. We define a new ref using the `useRef` hook and add a
    `useEffect` hook to focus when the component mounts. Make sure to pull out the
    new constants from the React constant, which is at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next test, we’ll dispatch an action to the Redux store. Since this
    test suite hasn’t yet got a test that dispatches actions, we’ll need to add all
    the plumbing. Start by importing the `dispatchToStore` function into the test
    suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need a new helper function that will clear focus. Because focus will
    be set as soon as the component mounts, we need to unset it again so we can verify
    the behavior of our focus request. Once we have that helper, we can add the next
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, first, create a new call to `useSelector` to pull out the
    `promptFocusRequest` value from the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a new effect that will run when `promptFocusRequest` changes. This
    uses the ref to call the DOM’s `focus` method on the HTML element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next test, dispatch an action when the focus has occurred:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, start by adding a new action helper function that we can
    call within the `Prompt` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, call `promptHasFocused` within the `useEffect` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is a slight issue with this last code snippet. The dispatched `PROMPT_HAS_FOCUSED`
    action will set `promptFocusRequest` back to `false`. That then causes the `useEffect`
    hook to run a second time, with the component re-rendering. This is clearly not
    intended, nor is it necessary. However, since it has no discernable effect on
    the user, we can skip fixing it at this time.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the `Prompt` component, which now steals focus anytime the `promptFocusRequest`
    variable changes value.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting focus in other components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All that’s left is to call the request action when required. We’ll do this
    for `ScriptName`, but you could also do it for the buttons in the menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `test/ScriptName.test.js`, find the `describe` block named `when the user
    hits Enter`:, and add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/ScriptName.js`, modify the component to define an action helper named
    `promptFocusRequest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call that from within the edit completion handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it! If you build and run now, you’ll see how focus is automatically given
    to the `prompt` textbox, and if you edit the script name (by clicking on it, typing
    something, and then hitting *Enter*), you’ll see that focus returns to the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a good understanding of test-driving complex Redux reducers
    and middleware.
  prefs: []
  type: TYPE_NORMAL
- en: First, we added support undo/redo with a Redux decorator reducer. Then, we built
    Redux middleware to save and load existing states via the browser’s `LocalStorage`
    API. And finally, we looked at how to test-drive changing the browser’s focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll look at how to test-drive something much more intricate:
    animation.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wikipedia entry on the Logo programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Logo_(programming_language)](https://en.wikipedia.org/wiki/Logo_(programming_language))'
  prefs: []
  type: TYPE_NORMAL
