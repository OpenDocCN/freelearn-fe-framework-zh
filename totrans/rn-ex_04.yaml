- en: Advanced Functionality with the Expenses App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用支出应用的高级功能
- en: 'In the last chapter, we began working on an expense tracking app simply titled
    `Expenses`. After getting some basic functionality written for the app, our next
    goal is to continue working on the app and add new features to it that will make
    the app feature-complete. This chapter will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始着手开发一个简单命名为`Expenses`的支出跟踪应用。在为该应用编写了一些基本功能后，我们的下一个目标是继续开发该应用并添加新的功能，使其功能完善。本章将涵盖以下主题：
- en: Utilizing the `react-native-vector-icons` library to utilize icons in our app
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`react-native-vector-icons`库在我们的应用中使用图标
- en: Learning how to use the `Picker` component to render a dropdown, such as an
    interface that can accept any array of items for user selection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`Picker`组件来渲染下拉菜单，例如一个可以接受任何项目数组的用户选择界面
- en: Updating our list view to show the expense category icons and show the current
    amount spent with a progress bar
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新我们的列表视图以显示支出类别图标，并显示当前花费的进度条
- en: Creating a second view that renders the previous months' expenses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个第二个视图来渲染之前月份的支出
- en: Using the `Icon.TabBarIOS` component to toggle between the current month's and
    the previous month's view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Icon.TabBarIOS`组件在当前月份和之前月份的视图之间切换
- en: Allowing deletion of added expenses for both the current month and the previous
    ones
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许删除当前月份和之前月份添加的支出
- en: Due to the extensive features in this chapter, the section on making modifications
    for this app to run on an Android device has been moved to [Chapter 9](c9cb084b-5c75-4683-94c3-9b2124e8ecb0.xhtml),
    *Additional React Native Components*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章内容广泛，关于将此应用修改为在Android设备上运行的章节已移至[第9章](c9cb084b-5c75-4683-94c3-9b2124e8ecb0.xhtml)《额外的React
    Native组件》。
- en: Using vector icons
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用矢量图标
- en: 'In [Chapter 3](6ac206f7-d3d2-4b39-89ab-a6fdcf124e02.xhtml), *Our Second Project
    - The Budgeting App*, we mentioned that upon tapping that button, the user should
    be shown a modal that allows them to input details for their expenses: the name,
    amount, date the purchase was made on, and an icon to categorize the item. The
    modal should `allow` the user to either cancel or save the entry they make.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](6ac206f7-d3d2-4b39-89ab-a6fdcf124e02.xhtml)《我们的第二个项目 - 预算应用》中，我们提到在点击该按钮后，用户应看到一个模态窗口，允许他们输入他们的支出详情：支出的名称、金额、购买日期以及用于分类的图标。该模态窗口应允许用户取消或保存他们所做的条目。
- en: 'For our first exercise, we should do the following things:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个练习中，我们应该做以下几件事情：
- en: 'Begin by writing a utilities file for handling icons:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先编写一个处理图标的工具文件：
- en: This file should contain an object that contains the stringified names of categories
    and their icon names from our vector icon library.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此文件应包含一个对象，其中包含类别字符串化名称和我们的矢量图标库中的图标名称。
- en: This file should also contain a method that takes in the name, desired size,
    and color of an icon and returns that icon as a component. Treat this as a stateless
    functional component.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此文件还应包含一个方法，该方法接受图标的名称、所需大小和颜色，并返回该图标作为组件。将其视为无状态函数组件。
- en: Let's look at how we can utilize the vector icon library that we installed in
    the last chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何利用上一章中安装的矢量图标库。
- en: 'We can import `react-native-vector-icons` with the following statement:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语句导入`react-native-vector-icons`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This maps a reference of `Icon` to a component that uses the Font Awesome icon
    set.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`Icon`的引用映射到使用Font Awesome图标集的组件。
- en: 'To utilize it, you can render an `Icon` component like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，您可以像这样渲染`Icon`组件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `name` property tells the library which icon to pull from its collection.
    You can find a list of all the icons that Font Awesome contains at [http://fontawesome.io](http://fontawesome.io).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性告诉库从其集合中拉取哪个图标。您可以在[http://fontawesome.io](http://fontawesome.io)找到Font
    Awesome包含的所有图标列表。'
- en: 'Our app will contain the following 12 icons:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用将包含以下12个图标：
- en: '`home`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`家`'
- en: '`shopping-cart`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`购物车`'
- en: '`cutlery`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`餐具`'
- en: '`film`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电影`'
- en: '`car`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`汽车`'
- en: '`coffee`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`咖啡`'
- en: '`plane`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`飞机`'
- en: '`shopping-bag`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`购物袋`'
- en: '`book`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`书籍`'
- en: '`beer`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`啤酒`'
- en: '`gamepad`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`游戏手柄`'
- en: '`plug`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`插头`'
- en: 'The categories that these icons represent will be (in order) the following
    ones:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图标所代表的类别将按以下顺序排列：
- en: Home
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 家
- en: Grocery
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杂货
- en: Restaurant
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅
- en: Entertainment
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 娱乐
- en: Car
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车
- en: Coffee
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 咖啡
- en: Travel
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行
- en: Shopping
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物
- en: Books
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍
- en: Drinks
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饮料
- en: Hobby
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爱好
- en: Utilities
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公用事业
- en: With these in mind, we should create a helper file that will let us render an
    icon.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些，我们应该创建一个辅助文件，使我们能够渲染图标。
- en: Icon methods
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图标方法
- en: The `iconMethods` file will be a lot simpler than our previous helper methods.
    With `iconMethods`, our goal is to keep an object that maps category names and
    icons and then, export a function that will help us return the `react-native-vector-icon`
    components.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`iconMethods`文件将比我们之前的辅助方法简单得多。使用`iconMethods`，我们的目标是保持一个映射类别名称和图标的对象，然后导出一个函数，帮助我们返回`react-native-vector-icon`组件。'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `categories` object lets us quickly access both the category and icon name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`categories`对象让我们可以快速访问类别和图标名称：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have a stateless function, `getIconComponent`, that accepts the `name`
    of a category along with an optional `size` and `color`, then returns an `Icon`
    component for our app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个无状态函数`getIconComponent`，它接受一个类别的`name`以及可选的`size`和`color`，然后返回我们的应用中的`Icon`组件。
- en: Now that we have our `iconMethods` file built out, it's time to create a `Picker`
    component to select a category.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了`iconMethods`文件，是时候创建一个`Picker`组件来选择一个类别了。
- en: Picker
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Picker
- en: So far in this book, we have used `DatePickerIOS` and `DatePickerAndroid` for
    users to select dates. Each platform also has access to a native `Picker` component,
    where we can populate an array of choices and allow our users to interact with
    it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们使用了`DatePickerIOS`和`DatePickerAndroid`让用户选择日期。每个平台也可以访问本地的`Picker`组件，我们可以填充一个选择数组，并允许我们的用户与之交互。
- en: 'Building a `Picker` is easy. We start by writing a `Picker` in the `render`
    method of a component and populate it with `Picker.Item` children:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`Picker`很简单。我们首先在组件的`render`方法中编写一个`Picker`，并用`Picker.Item`子项填充它：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we can give the `Picker` some props. The following ones are used in this
    exercise:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以给`Picker`一些属性。以下是在这个练习中使用的一些属性：
- en: '`onValueChange`: This is a callback fired when an item has been selected. It
    passes two arguments: `itemValue` and `itemPosition`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onValueChange`：这是一个在项目被选中时触发的回调。它传递两个参数：`itemValue`和`itemPosition`'
- en: '`selectedValue`: This is a reference to the current value of the `Picker` list'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedValue`：这是对`Picker`列表当前值的引用'
- en: Selecting a category
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个类别
- en: 'We will modify our existing `AddExpensesModal` component to add the following
    functionality:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改现有的`AddExpensesModal`组件，以添加以下功能：
- en: Create a `Button` right below the `ExpandableCell`/`DatePickerIOS` component
    to select a category for our expense.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ExpandableCell`/`DatePickerIOS`组件下方创建一个`Button`，用于选择我们费用的类别。
- en: 'On press, that button should render a `Picker` component for the user to interact
    with. This `Picker` should have the following features:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按钮被按下时，应该渲染一个`Picker`组件供用户交互。这个`Picker`应该具有以下功能：
- en: Contain the list of twelve categories that we are using in our app as `Picker`
    items by mapping the array instead of hardcoding each of the twelve categories.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过映射数组而不是硬编码每一个十二个类别，我们使用`Picker`项在我们的应用中包含十二个类别的列表。
- en: 'Have a callback that sets the selected value as the selected category for our
    expense. Next:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个回调将选定的值设置为我们的费用选定的类别。接下来：
- en: Render this `Picker` as a child of an `ExpandableCell` component within `AddExpensesModal` so
    that it can be collapsed when not in use.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这个`Picker`作为`AddExpensesModal`组件内的`ExpandableCell`组件的子组件渲染，以便在不使用时可以折叠。
- en: Render the preceding `ExpandableCell` component between the date and save/cancel
    buttons within `AddExpensesModal`.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AddExpensesModal`中，在日期和保存/取消按钮之间渲染前一个`ExpandableCell`组件。
- en: Use the `getIconComponent` function from `iconMethods` to render the selected
    category's icon, if applicable, and style it so that it appears on the page in
    the same row as the `ExpandableCell` for our `Picker` component.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`iconMethods`中的`getIconComponent`函数渲染选定的类别图标（如果适用），并对其样式进行设置，使其在页面上与`Picker`组件的`ExpandableCell`在同一行显示。
- en: Modify `AddExpensesModal` so that its submit button is also disabled if a category
    has not been set by the user.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`AddExpensesModal`，使其提交按钮在没有用户设置类别时也禁用。
- en: The `AddExpensesModal` component and its styles underwent a significant number
    of changes since the last time we looked at them in the last chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在上一章中查看它们以来，`AddExpensesModal`组件及其样式经历了显著的变化。
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `expanded` key is replaced by two separate Booleans for each `ExpandableCell`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ExpandableCell`的`expanded`键被替换为两个单独的布尔值。
- en: 'The `expandableCellTitle` is replaced by one string for each `ExpandableCell`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`expandableCellTitle`被替换为每个`ExpandableCell`的一个字符串：'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The rendering of the original `ExpandableCell` has been modified to accommodate
    the changes in variable and function names to make it more specific to its child
    component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 `ExpandableCell` 的渲染已被修改以适应变量和函数名称的变化，使其更具体于其子组件：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the newly-added `ExpandableCell` component, rendering a `Picker` underneath
    it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新添加的 `ExpandableCell` 组件，在其下方渲染一个 `Picker`：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Button` component used to save an expense has been modified to check for
    the presence of a category to allow its saving:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用于保存费用的 `Button` 组件已被修改以检查类别的存在，以便允许其保存：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `_clearFieldsAndCloseModal` method has been updated for the new fields:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`_clearFieldsAndCloseModal` 方法已更新以适应新字段：'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `_onDatePickerExpand` method is just a renaming of the old `_onExpand`
    method, while `_onCategoryPickerExpand` is specific to the `Picker` category:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`_onDatePickerExpand` 方法只是将旧 `_onExpand` 方法的重命名，而 `_onCategoryPickerExpand`
    是特定于 `Picker` 类别的：'
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Render each `Picker.Item` by mapping the array of category names to a new element:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将类别名称数组映射到新元素来渲染每个 `Picker.Item`：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `_setItemCategory` function is fired in the `onValueChange` callback of
    our `Picker` category:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`_setItemCategory` 函数在 `Picker` 类别的 `onValueChange` 回调中触发：'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save the `category` property to storage as part of `_saveItemToBudget`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `_saveItemToBudget` 中的 `category` 属性保存到存储中：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how the new `Picker` component should look:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是新的 `Picker` 组件应有的样子：
- en: '![](img/image_04_001-1.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_001-1.png)'
- en: 'I added styling for `categoryIcon`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我为 `categoryIcon` 添加了样式：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code uses the `Dimensions` API to set `marginLeft` to the width of the
    screen minus `50` pixels.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用 `Dimensions` API 将 `marginLeft` 设置为屏幕宽度减去 `50` 像素。
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code has updated styling to contain a `flexDirection` of `row`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码已更新样式，包含 `flexDirection` 为 `row`。
- en: Updating CurrentMonthExpenses and ExpenseRow
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 CurrentMonthExpenses 和 ExpenseRow
- en: 'Up to this point, we have been rendering the `CurrentMonthExpenses` and `ExpenseRow`
    components without a category as one did not exist previously. Let''s update them
    with the following goals in mind:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在渲染没有类别的 `CurrentMonthExpenses` 和 `ExpenseRow` 组件，因为没有之前存在。让我们带着以下目标更新它们：
- en: '`CurrentMonthExpenses` should access each item''s category and pass it to `ExpenseRow`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentMonthExpenses` 应该访问每个项目的类别并将其传递给 `ExpenseRow`'
- en: '`ExpenseRow` should render the appropriate category''s assigned icon in the
    row of expenses so that our users can quickly visualize what it is that they spent
    part of their budget on'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExpenseRow` 应该在费用行中渲染适当的分配图标，以便我们的用户可以快速了解他们花预算的部分是什么'
- en: We should use the `resetAsyncStorage` method created in `StorageMethods` to
    clear any current list of expenses before modifying `ExpenseRow` so that the previous
    expenses without a category assigned will not cause any issues
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该使用在 `StorageMethods` 中创建的 `resetAsyncStorage` 方法在修改 `ExpenseRow` 之前清除任何当前的费用列表，以确保未分配类别的先前费用不会引起任何问题
- en: 'Once you have updated these components, check out my solution, which is as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更新这些组件后，查看我的解决方案，如下所示：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code used one time (and not saved in the file afterwards) to clear
    storage.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了一次（之后没有保存到文件中）来清除存储。
- en: 'Then, I updated the `CurrentMonthExpenses` component to pass in the `category`
    an expense was assigned as a prop to the `ExpenseRow` component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将 `CurrentMonthExpenses` 组件更新为将分配给费用的 `category` 作为属性传递给 `ExpenseRow` 组件：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After that, I created a new `View` to render the category icon:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我创建了一个新的 `View` 来渲染类别图标：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For styling, the following `icon` property was added:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于样式，添加了以下 `icon` 属性：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is how your app should look after icons have been added:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 添加图标后，您的应用应如下所示：
- en: '![](img/image_04_002-1.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_002-1.png)'
- en: Great job on the updates! In the next section, we should give the user a visualization
    of their remaining budget using a progress indicator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更新做得很好！在下一节中，我们应该使用进度指示器给用户展示他们剩余预算的视觉化。
- en: Updating App.js with ProgressViewIOS
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ProgressViewIOS 更新 App.js
- en: When planning this app in the last chapter, we wrote that this list should also
    prominently display the user's set budget for the month along with a progress
    indicator showing how close they are to hitting their budget.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章规划此应用时，我们写道这个列表还应突出显示用户为该月设定的预算以及一个进度指示器，显示他们离达到预算有多近。
- en: 'Using `ProgressViewIOS`, we can depict our user''s progress toward their monthly
    limit. The following props will be used in this project:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ProgressViewIOS`，我们可以描绘用户向月度限额的进展。以下属性将用于本项目：
- en: '`progress`: This is a number between `0` and `1` that tracks the value of the
    progress bar'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`progress`：这是一个介于`0`和`1`之间的数字，用于跟踪进度条的值'
- en: '`progressTintColor`: This is a string that sets the color of the progress bar'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`progressTintColor`：这是一个设置进度条颜色的字符串'
- en: 'You can render a `ProgressViewIOS` component like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以这样渲染一个`ProgressViewIOS`组件：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this section, we should update `Expenses` to do the following things:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们应该更新`Expenses`以执行以下操作：
- en: First, we should modify the `checkCurrentMonthBudget` function from `storageMethods`
    to also return the amount spent for the month
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们应该修改`storageMethods`中的`checkCurrentMonthBudget`函数，使其也返回该月的花费金额
- en: Then, `App.js` should have its `_updateBudget` function updated to account for
    the amount spent being returned by `checkCurrentMonthBudget`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`App.js`应该更新其`_updateBudget`函数，以考虑`checkCurrentMonthBudget`返回的花费金额
- en: 'Finally, add a `ProgressViewIOS` component to `CurrentMonthExpenses`:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将一个`ProgressViewIOS`组件添加到`CurrentMonthExpenses`：
- en: It should have a function to calculate its `progress` prop
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该有一个函数来计算其`progress`属性
- en: It should also show the dollar amount currently spent as a string
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还应该显示当前花费的金额作为字符串
- en: ProgressViewIOS example
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ProgressViewIOS示例
- en: 'To begin, we will need to make an addition to our `storageMethods` file to
    grab the current month''s spent amount so that we can calculate the `progress`
    prop for `ProgressViewIOS`. This can be done by modifying `checkCurrentMonthBudget`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向我们的`storageMethods`文件中添加一个条目，以获取当前月份的花费金额，以便我们可以计算`ProgressViewIOS`的`progress`属性。这可以通过修改`checkCurrentMonthBudget`来实现：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are returning an object containing both the `budget` and `spent` amounts
    as opposed to just the `budget`. This means that we will also need to modify how
    the `App` component's `_updateBudget` method receives our response data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回一个包含`budget`和`spent`金额的对象，而不是仅仅`budget`。这意味着我们还需要修改`App`组件的`_updateBudget`方法接收我们的响应数据的方式。
- en: 'The following addition to the `App` component just shows the `_updateBudget`
    asynchronous method since it is the only part modified to accommodate `storageMethods''`
    `checkCurrentMonthBudget` method''s changes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对`App`组件的添加仅显示了`_updateBudget`异步方法，因为它是我们唯一修改以适应`storageMethods`的`checkCurrentMonthBudget`方法更改的部分：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The text block that renders the budget as a string has been modified to display
    the current amount spent:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将预算作为字符串渲染的文本块已被修改，以显示当前花费的金额：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A `ProgressViewIOS` component is also mounted right after the preceding text
    block, pointing its `progress` prop to a function called `_getProgressViewAmount`,
    which calculates it for us:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ProgressViewIOS`组件也紧随前面的文本块之后挂载，将其`progress`属性指向一个名为`_getProgressViewAmount`的函数，该函数为我们计算它：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following code is a simple division to grab the percentage:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个简单的除法，用于获取百分比：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Set `margin` to `10` so that it does not reach the edge of the screen:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将`margin`设置为`10`，以便它不会达到屏幕边缘：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Reduce the `fontSize` of both the properties to `16` and set `alignSelf` to
    `center`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个属性的`fontSize`都减少到`16`，并将`alignSelf`设置为`center`：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As a result of these changes, your app should now have a progress indicator
    showing the user how close they are to hitting their budget for the month.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些变化，您的应用现在应该有一个进度指示器，显示用户距离达到本月预算还有多远。
- en: 'Thanks to the `_updateCurrentMonthExpenses` function in `App.js`, saving new
    expenses for the month will result in the amount spent and progress indicator
    being updated accordingly without any new logic having to be written:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`App.js`中的`_updateCurrentMonthExpenses`函数，保存新的月度花费将导致花费金额和进度指示器相应更新，而无需编写任何新的逻辑：
- en: '![](img/image_04_003-1.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_003-1.png)'
- en: This looks great! Our next step is to create a second view that will let us
    look at all the months' expenses, which in turn will have us using a TabBar to
    toggle between the two.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒！我们的下一步是创建一个第二个视图，让我们可以查看所有月份的花费，这反过来又让我们使用TabBar在两个视图之间切换。
- en: A view for prior months' expenses
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前几个月份花费的视图
- en: Our view for the previous months' expenses should be one that renders a list
    of the existing months in our budget. It should give us the month, the budget
    allocated for the month, and have the years separated by some sort of a header.
    Then, on tap, it should go to the summary for each month to show us our previous
    months' expenses that were input.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前几个月份花费视图应该是一个渲染我们预算中现有月份列表的视图。它应该给出月份、该月的预算分配，并且年份通过某种标题分隔。然后，在点击时，它应该转到每个月份的摘要，显示我们之前输入的月份花费。
- en: 'We should create some functions in a new utilities file, named `mockDataMethods`,
    to help us mock the data for the previous months and populate our app:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在名为 `mockDataMethods` 的新工具文件中创建一些函数，以帮助我们模拟前几个月的数据并填充我们的应用程序：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Above, arrays for years, months, and expenses are created and populated with
    data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，已创建并填充了年份、月份和支出数组的数组。
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I created a mocked object to be assigned to each month:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我为每个月创建了一个模拟对象：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function loops through the `years` array and creates an empty object within
    that year's property. It then does another loop within it to create a similar
    object for the `month` within that `year` and assigns the `mockObject` to it.
    Along the way, it also stops the function if we attempt to create any mocked expenses
    for months past January 2017.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数遍历 `years` 数组，并在该年份的属性中创建一个空对象。然后，它在其中进行另一个循环，为该 `year` 中的 `month` 创建一个类似的对象，并将
    `mockObject` 分配给它。在这个过程中，如果尝试为 2017 年 1 月之后月份创建任何模拟支出，它还会停止函数。
- en: 'Then, we use our `setAsyncStorage` function to assign our mocked expenses object
    to be the source of truth for our application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用我们的 `setAsyncStorage` 函数将我们的模拟支出对象分配为应用程序的真实来源：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Within the `componentWillMount` life cycle of `App.js`, we can call on the `mockPreviousMonthExpenses`
    function we created in `mockDataMethods` to populate our local storage with this
    mocked data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.js` 的 `componentWillMount` 生命周期中，我们可以调用在 `mockDataMethods` 中创建的 `mockPreviousMonthExpenses`
    函数，以用此模拟数据填充我们的本地存储。
- en: Additionally, we use the `logAsyncStorage` method from `storageMethods` in order
    to log the information to the console so that we can see that our mocked data
    has been saved to storage for later use.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用 `storageMethods` 中的 `logAsyncStorage` 方法将信息记录到控制台，以便我们可以看到我们的模拟数据已被保存到存储中以便以后使用。
- en: 'Once this step is completed, you should remove the `mockPreviousMonthExpenses`
    function from `App.js` since it does not need to be continuously called. Here
    is how our mocked expenses will look. You can view your own results by calling
    `console.table` on the object and opening up Chrome developer tools:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，你应该从 `App.js` 中删除 `mockPreviousMonthExpenses` 函数，因为它不需要持续调用。以下是我们的模拟支出将看起来如何。你可以通过在对象上调用
    `console.table` 并打开 Chrome 开发者工具来查看你的结果。
- en: '![](img/image_04_004.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_004.png)'
- en: After this step has been completed, we should create a new component that will
    show these details. Since we want a list that contains some sort of headers to
    separate the years, we will be rendering a `ListView` and using the `renderSectionHeader`
    prop to create sections in our app.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们应该创建一个新的组件来显示这些详细信息。由于我们想要一个包含某种标题以分隔年份的列表，我们将渲染一个 `ListView` 并使用 `renderSectionHeader`
    属性在我们的应用程序中创建分区。
- en: ListView with section headers
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有分区标题的 `ListView`
- en: To set up our `ListView` to accommodate section headers, we need to make some
    modifications to the way we've been creating `ListViews`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置 `ListView` 以适应分区标题，我们需要对我们创建 `ListViews` 的方式做一些修改。
- en: 'First, when we instantiate a new `ListView DataSource`, we''ll be passing it
    a second callback, `sectionHeaderHasChanged`. Like `rowHasChanged`, this one checks
    to see whether a section header has changed. In your code, it looks something
    like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当我们实例化一个新的 `ListView DataSource` 时，我们将传递第二个回调 `sectionHeaderHasChanged`。像
    `rowHasChanged` 一样，这个回调检查分区标题是否已更改。在你的代码中，它看起来像这样：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, instead of calling `cloneWithRows`, we call the similarly named `cloneWithRowsAndSections`
    function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们不再调用 `cloneWithRows`，而是调用同名的 `cloneWithRowsAndSections` 函数：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, your `ListView` component should now accept a function as its `renderSectionHeader`
    prop, which will render the section header for your application:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你的 `ListView` 组件现在应该接受一个函数作为其 `renderSectionHeader` 属性，该函数将渲染应用程序的分区标题：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that you have an overview of how to apply a section header to your `ListView`
    component, it''s time to apply that knowledge. Let''s create a new component,
    `PreviousMonthsList`. This component should do the following things:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何将分区标题应用到你的 `ListView` 组件上，现在是时候应用这些知识了。让我们创建一个新的组件，`PreviousMonthsList`。此组件应该执行以下操作：
- en: For the time being, replace the rendering of `CurrentMonthExpenses` in `App.js`
    with your `PreviousMonthsList` component so that you can view your progress while
    writing the component.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，将 `App.js` 中 `CurrentMonthExpenses` 的渲染替换为你的 `PreviousMonthsList` 组件，这样你可以在编写组件时查看你的进度。
- en: Grab the list of expenses from `AsyncStorage` and save it to the component state
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `AsyncStorage` 获取支出列表并将其保存到组件状态
- en: Render a `ListView` with section headers, which displays the name of the month
    as a string along with that month's numerical budget and a section header for
    each year that our `mocked` expenses provided
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染一个带有部分标题的`ListView`，显示月份名称作为字符串以及该月的预算数字以及我们`mocked`支出提供的每年部分标题。
- en: Style the rows and section headers to have a different look from each other
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为行和部分标题设置不同的样式，以便彼此区分。
- en: 'Once you have built your version of this component, check for the one that
    I built:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了你的组件版本，检查我构建的那个：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first thing I did was import `PreviousMonthsList` into `App.js` and replace
    where `CurrentMonthExpenses` was being mounted in its `render` method with `PreviousMonthsList`
    instead. This made it simpler for me to work on the component, knowing that any
    changes I made would be immediately noticeable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先将`PreviousMonthsList`导入到`App.js`中，并用`PreviousMonthsList`替换了`render`方法中`CurrentMonthExpenses`被挂载的位置。这样，我就可以更简单地工作在这个组件上，知道我做的任何更改都会立即显现。
- en: 'After this component was completed, I reverted `App.js` back to its original
    state (before the `PreviousMonthsList` component was created):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此组件后，我将`App.js`恢复到其原始状态（在创建`PreviousMonthsList`组件之前）：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `DataSource` instance saved into component state has the new `sectionHeaderHasChanged`
    function passed into it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的`sectionHeaderHasChanged`函数传递给保存在组件状态中的`DataSource`实例。
- en: 'During the `componentWillMount` life cycle event, I am asynchronously calling
    the `getAsyncStorage` function from `storageMethods` and saving its result into
    the `listOfExpenses` property in the component state:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`componentWillMount`生命周期事件中，我异步调用`storageMethods`中的`getAsyncStorage`函数，并将结果保存到组件状态的`listOfExpenses`属性中：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `dataSource` constant is being assigned with the `cloneWithRowsAndSections`
    method of the `ListView.DataSource` instance saved in the component state so that
    the section header for our list of expenses is available in the app:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将`dataSource`常量分配给保存在组件状态中的`ListView.DataSource`实例的`cloneWithRowsAndSections`方法，以便在应用中提供我们支出列表的部分标题：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is nothing special in the three stateless functions that handle the rendering
    of our row data, section header, and separator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 处理渲染行数据、部分标题和分隔符的三个无状态函数中没有什么特别之处。
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `rowDataContainer` style is given a `flexDirection` property set to `row`
    so that the two strings being rendered within it are on the same line:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowDataContainer`样式被赋予一个`flexDirection`属性，设置为`row`，以便在它内部渲染的两个字符串位于同一行：'
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `sectionHeader` gets its own styling so that a specified `height` and `backgroundColor`
    can be set to visually distinguish it from the rows of data in the `PreviousMonthsList`
    component:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`sectionHeader`有自己的样式，以便可以设置特定的`height`和`backgroundColor`，从而在视觉上将其与`PreviousMonthsList`组件中的数据行区分开来：'
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, by temporarily rendering `PreviousMonthsList` to where `CurrentMonthExpenses`
    previously belonged, we have a view that looks like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，通过临时将`PreviousMonthsList`渲染到`CurrentMonthExpenses`之前的位置，我们得到了一个看起来像这样的视图：
- en: '![](img/image_04_005-1.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_005-1.png)'
- en: The previous month's expenses
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上个月的支出
- en: The next step that we want to carry out is to create a view that shows us the
    expenses for each month and then allows the user to enter that view by tapping
    on one of these months. This view should be navigated to when the user long presses
    on a month in the `PreviousMonthsList` component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要执行的下一步是创建一个视图，显示每个月的支出，然后允许用户通过点击这些月份之一进入该视图。当用户在`PreviousMonthsList`组件中长按月份时，应导航到该视图。
- en: Thankfully, we already have a component that can handle this for us. In the
    last chapter, we built the `CurrentMonthExpenses` component that renders the expenses
    for a given month.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经有了一个可以为我们处理这个的组件。在上一个章节中，我们构建了`CurrentMonthExpenses`组件，用于渲染给定月份的支出。
- en: So far in our app, `CurrentMonthExpenses` is being rendered in just one place--`App.js`.
    The container that it renders within has a top margin offset to accommodate the
    navigation bar.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的应用中，`CurrentMonthExpenses`仅在`App.js`中渲染。它渲染的容器有一个顶部边距偏移，以适应导航栏。
- en: If we want to reuse the `CurrentMonthExpenses` component to render any month's
    expenses, we should build some logic to selectively include a top margin offset
    equal to the navigation bar's height if the component is being navigated to by
    `PreviousMonthsList`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要重用`CurrentMonthExpenses`组件来渲染任何月份的支出，我们应该构建一些逻辑，以便在通过`PreviousMonthsList`导航到组件时，选择性地包含等于导航栏高度的顶部边距偏移。
- en: 'This can be achieved by having `CurrentMonthExpenses` accept an optional Boolean
    as a prop to then append its `currentMonthExpensesContainer` style with its top
    margin being set to the navigation bar''s height:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过让`CurrentMonthExpenses`接受一个可选的布尔值作为属性，然后将其`currentMonthExpensesContainer`样式中的顶部边距设置为导航栏的高度来实现：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `Navigator` is being imported so that we have access to its navigation bar
    height. The `CurrentMonthExpenses` component's `propTypes` have been updated to
    expect an optional Boolean titled `isPreviousMonth`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`Navigator`以便我们能够访问其导航栏的高度。`CurrentMonthExpenses`组件的`propTypes`已更新，以期望一个可选的布尔值，标题为`isPreviousMonth`。
- en: Then, the `render` method of `CurrentMonthExpenses` checks to see whether the
    `isPreviousMonth` Boolean has been passed to the component. If it has, it adds
    the `marginTop` property to the `currentMonthExpensesContainer` style equal to
    the height of the navigation bar.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`CurrentMonthExpenses`的`render`方法检查是否已将`isPreviousMonth`布尔值传递给组件。如果是，它将`marginTop`属性添加到`currentMonthExpensesContainer`样式，其值等于导航栏的高度。
- en: 'Now it is time to link each row from `PreviousMonthsList` to navigate to the
    `CurrentMonthExpenses` component. Modify your `PreviousMonthsList` component so
    that it does the following things:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将`PreviousMonthsList`中的每一行链接到导航到`CurrentMonthExpenses`组件。修改您的`PreviousMonthsList`组件，使其执行以下操作：
- en: Importing and wrapping a `TouchableHighlight` component over each row being
    rendered.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入并包装每个正在渲染的行上的`TouchableHighlight`组件。
- en: When one of the rows is pressed, your app should navigate to `CurrentMonthExpenses`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按下其中一行时，您的应用应导航到`CurrentMonthExpenses`。
- en: As part of this navigation to `CurrentMonthExpenses`, your app's navigator should
    pass it all the props that it expects (as specified in the `propTypes` object
    of `CurrentMonthExpenses`), along with the optional `isPreviousMonth` prop set
    to `true`.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为导航到`CurrentMonthExpenses`的一部分，您的应用导航器应传递给它所有它期望的属性（如`CurrentMonthExpenses`的`propTypes`对象中指定的），以及可选的`isPreviousMonth`属性设置为`true`。
- en: 'When you complete this step, check out the solution that I came up with:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成此步骤后，查看我提出的解决方案：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I modified the `_renderRowData` method of `PreviousMonthsList` to wrap a `TouchableHighlight`
    component around the row of text. Since `TouchableHighlight` can only accept one
    immediate child component, I wrapped the two text elements around a `View`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我修改了`PreviousMonthsList`的`_renderRowData`方法，将其包装在一个`TouchableHighlight`组件周围。由于`TouchableHighlight`只能接受一个直接子组件，我将两个文本元素包装在一个`View`中。
- en: 'The `_renderSelectedMonth` method pushes `CurrentMonthExpenses` to the navigator
    and passes it all the expected props for that component. I used the `Number.toString`
    prototype method to convert the `rowData.budget` number to a string as `CurrentMonthExpenses`
    expects a string as its `budget` prop:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`_renderSelectedMonth`方法将`CurrentMonthExpenses`推送到导航器，并传递给它该组件所有预期的属性。我使用了`Number.toString`原型方法将`rowData.budget`数字转换为字符串，因为`CurrentMonthExpenses`期望其`budget`属性为字符串：'
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'I gave the `rowDataTouchableContainer` style a `height` of `30` pixels and
    set the `flexDirection` property of `textRow` to `row` so that the two `Text`
    components within it will render properly:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`rowDataTouchableContainer`样式的`height`设置为`30`像素，并将`textRow`的`flexDirection`属性设置为`row`，这样其中的两个`Text`组件就能正确渲染：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When the user presses on the name of a previous month, they will now see the
    following view:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下前一个月的名称时，他们将现在看到以下视图：
- en: '![](img/image_04_006-1.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_006-1.png)'
- en: 'Now, we have two different paths for our users to take in the app: they can
    view add expenses to the current month''s list in `App.js`, or they can view the
    archives of all of their previous months'' expenses. In the next section, we will
    learn how to implement a tab bar to show these two views.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用户在应用中有两条不同的路径可以选择：他们可以在`App.js`中查看添加当前月份的费用列表，或者他们可以查看他们之前所有月份的费用存档。在下一节中，我们将学习如何实现标签栏来显示这两个视图。
- en: Implementing TabBarIOS
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`TabBarIOS`
- en: '`TabBarIOS` renders a tabbed navigation bar at the bottom of the screen. The
    bar can contain multiple icons, each responsible for a different view.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabBarIOS`在屏幕底部渲染一个标签导航栏。该栏可以包含多个图标，每个图标负责不同的视图。'
- en: The different tabs that `TabBarIOS` renders are considered items of the tab
    bar. They are declared as `TabBarIOS.Item` components and are nested as children
    within `TabBarIOS`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabBarIOS`渲染的不同标签被认为是标签栏的项目。它们被声明为`TabBarIOS.Item`组件，并且作为`TabBarIOS`的子组件嵌套。'
- en: However, with the `react-native-vector-icons` library we imported, we would
    like to use Font Awesome icons for our navigation. Instead of rendering the `TabBarIOS.Item`
    components as children for our `TabBarIOS` component, we will substitute them
    for `Icon.TabBarItemIOS`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用我们导入的 `react-native-vector-icons` 库，我们希望使用 Font Awesome 图标进行导航。我们不会将 `TabBarIOS.Item`
    组件作为 `TabBarIOS` 组件的子组件渲染，而是用 `Icon.TabBarItemIOS` 替换它们。
- en: '`Icon.TabBarItemIOS` is a component that behaves in the exact same way that
    `TabBarIOS.Item` does, but with a couple of extra props that are specific to it.
    We will be using the following props for our implementation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Icon.TabBarItemIOS` 是一个组件，其行为方式与 `TabBarIOS.Item` 完全相同，但它有一些特定的额外属性。在我们的实现中，我们将使用以下属性：'
- en: '`onPress`: This is a callback that fires when the tab is tapped on by the user.
    This should always at least set the selected component to a Boolean in your state.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPress`：这是一个当用户点击标签时触发的回调。这应该至少在您的状态中将选定的组件设置为布尔值。'
- en: '`selected`: This is a Boolean that determines whether a specific tab is in
    the forefront of the application or not.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected`：这是一个布尔值，用于确定特定的标签是否在应用的前台。'
- en: '`title`: This is a string that shows the text that appears underneath your
    icon.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是一个显示在图标下方的文本的字符串。'
- en: '`iconName`: This is a string that maps to the icon you wish to display.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iconName`：这是一个映射到你希望显示的图标的字符串。'
- en: '`iconSize`: This is a number that dictates the size of the icon.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iconSize`：这是一个指定图标大小的数字。'
- en: The `iconColor` and `selectedIconColor` will need to have `renderAsOriginal`
    set to `true` so that these child-level settings override the parent `TabBarIOS`
    component's `tintColor` and `unselectedTintColor` props.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`iconColor` 和 `selectedIconColor` 需要将 `renderAsOriginal` 设置为 `true`，以便这些子级设置覆盖父
    `TabBarIOS` 组件的 `tintColor` 和 `unselectedTintColor` 属性。'
- en: 'Here''s how a sample `TabBarIOS` component can look:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例 `TabBarIOS` 组件可能的样子：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, `TabBarIOS` wraps around the `Icon.TabBarItemIOS` child components.
    Each of these child components handle their own icon type, size, and title. They
    also wrap around a function that renders their respective views.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`TabBarIOS` 包围了 `Icon.TabBarItemIOS` 子组件。这些子组件各自处理自己的图标类型、大小和标题。它们还围绕一个渲染各自视图的函数。
- en: 'Now, it''s time for you to give it a try. Let''s build a `TabBarIOS` component
    into our app by doing the following things:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是你尝试的时候了。让我们通过以下步骤将 `TabBarIOS` 组件构建到我们的应用中：
- en: Separate the app into c*urrent month* and *previous month's* expenses using
    `TabBarIOS`. Choose a suitable icon for each one!
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TabBarIOS` 将应用分成 *当前月份* 和 *上个月份* 的支出。为每个选择一个合适的图标！
- en: Adjust styling as you see fit to adjust any dimensions needed to accommodate
    `TabBarIOS`.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要调整样式，以适应 `TabBarIOS` 的任何尺寸。
- en: Give each `PreviousMonthsList` its own `NavigatorIOS` component so that the
    `TabBarIOS` component does not disappear when `PreviousMonthsList` navigates to
    a previous month's list of expenses.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个 `PreviousMonthsList` 提供自己的 `NavigatorIOS` 组件，这样当 `PreviousMonthsList` 导航到上个月份的支出列表时，`TabBarIOS`
    组件不会消失。
- en: Remove the navigation bar from the root-level `NavigatorIOS` component found
    in `index.ios.js` so that the navigation components for `PreviousMonthsList` do
    not render a second navigation bar.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `index.ios.js` 中的根级 `NavigatorIOS` 组件中移除导航栏，以便 `PreviousMonthsList` 的导航组件不会渲染第二个导航栏。
- en: 'Once you have built tabbed navigation for the app, come back and check out
    the version I wrote:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为应用构建了标签导航，请返回并查看我写的版本：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The only change made to the `index.ios.js` root file is the addition of the
    `navigationBarHidden` prop for our root `NavigatorIOS` component, set to `true`
    so that the navigation bar does not appear.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `index.ios.js` 根文件所做的唯一更改是添加了 `navigationBarHidden` 属性，将其设置为 `true` 以确保导航栏不会显示。
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `App.js` component, I am now explicitly setting items in state to default
    values so that components that are dependent on that prop don''t throw an error
    when the prop is not defined. Additionally, the `expenses` key has been modified
    to be an object--this will be the full object returned by the `getAsyncStorage`
    method in `StorageMethods`, not just for the current month:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.js` 组件中，我现在正在显式地将项目设置为默认值，以便依赖于该属性的组件在属性未定义时不会抛出错误。此外，`expenses` 键已被修改为对象——这将是
    `StorageMethods` 中的 `getAsyncStorage` 方法返回的完整对象，而不仅仅是当前月份的：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The entire `expenses` object will be passed into `PreviousMonthsList`, allowing
    it to render all expense data and update whenever a new item is added to a previous
    month through the `AddExpenses` component.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 `expenses` 对象将被传递到 `PreviousMonthsList` 中，允许它渲染所有支出数据，并在通过 `AddExpenses`
    组件向前一个月添加新项目时更新。
- en: The old `expenses` array, which references just the current month, is now explicitly
    labeled as `currentMonthExpenses`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的 `expenses` 数组，它仅引用当前月份，现在被明确标记为 `currentMonthExpenses`。
- en: There is also a new item in the component's state--`selectedTab`. This defaults
    to `currentMonth`, which is the leftmost tab that we intend on rendering.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的状态中还有一个新项目--`selectedTab`。它默认为 `currentMonth`，这是我们打算渲染的最左侧标签。
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The render method for `App.js` has been completely overhauled. It now returns
    a `TabBarIOS` component and two `Icon.TabBarItemIOS` children components that
    render a different view each:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js` 的渲染方法已经完全重写。现在它返回一个 `TabBarIOS` 组件和两个 `Icon.TabBarItemIOS` 子组件，每个组件渲染不同的视图：'
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `_renderCurrentMonthExpenses` method contains the old `render` method for
    this component:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`_renderCurrentMonthExpenses` 方法包含此组件的旧 `render` 方法：'
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `_renderPreviousMonthsList` method returns a `NavigatorIOS` component whose
    initial route is `PreviousMonthsList`. The `expenses` key in `App.js''` state
    is passed in to `PreviousMonthsList` via `passProps`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`_renderPreviousMonthsList` 方法返回一个初始路由为 `PreviousMonthsList` 的 `NavigatorIOS`
    组件。`App.js` 状态中的 `expenses` 键通过 `passProps` 传递给 `PreviousMonthsList`：'
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `_setSelectedTab` function changes the `selectedTab` property in the `App.js''`
    component state to the argument passed to it. This is the callback fired by the
    `onPress` props of the `Icon.TabBarItemIOS`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`_setSelectedTab` 函数将 `App.js` 组件状态中的 `selectedTab` 属性更改为传递给它的参数。这是由 `Icon.TabBarItemIOS`
    的 `onPress` 属性触发的回调：'
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The last change is that `_updateCurrentMonthExpenses` now calls `getAsyncStorge`
    from `storageMethods.js` instead of `getMonthObject` and has been renamed as `_updateExpenses`
    to reflect its new functionality:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是 `_updateCurrentMonthExpenses` 现在调用 `storageMethods.js` 中的 `getAsyncStorge`
    而不是 `getMonthObject`，并且已重命名为 `_updateExpenses` 以反映其新功能：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `previousMonthsContainer` style is applied to the `NavigatorIOS` instance
    that renders `PreviousMonthsList`. It does not contain a top margin equal to the
    navigation bar''s height since this will cause the navigation bar itself to have
    a top margin equal to its own height:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`previousMonthsContainer` 样式应用于渲染 `PreviousMonthsList` 的 `NavigatorIOS` 实例。它不包含等于导航栏高度的顶部边距，因为这会导致导航栏本身具有等于其自身高度的顶部边距：'
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Minor changes to `PreviousMonthsList` are that I'm now checking for the `expenses`
    object to be passed to it and the `cloneWithRowsAndSections` call in the `render`
    method is now updated to reflect this.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `PreviousMonthsList` 的微小更改是我现在正在检查传递给它的 `expenses` 对象，并且在 `render` 方法中的 `cloneWithRowsAndSections`
    调用现在已更新以反映这一点。
- en: Additionally, the `componentWillMount` life cycle has been entirely removed
    since we are now getting all our data as a prop.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`componentWillMount` 生命周期方法已被完全移除，因为我们现在作为属性获取所有数据。
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `marginTop` property for `previousMonthsListContainer` in this component
    has been set to the navigation bar height:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件中，`previousMonthsListContainer` 的 `marginTop` 属性已设置为导航栏高度：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, the `AddExpenses` component has been tweaked to reflect changing the
    `_updateCurrentExpenses` function name to `_updateExpenses`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`AddExpenses` 组件已经调整，以反映将 `_updateCurrentExpenses` 函数名称更改为 `_updateExpenses`：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here is how your app should look with `TabBarIOS` implemented:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现 `TabBarIOS` 后你的应用应该看起来的样子：
- en: '![](img/image_04_007-1.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_007-1.png)'
- en: There is one last thing we should do with the app, and it is to let users delete
    expenses.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该对应用做最后一件事，那就是让用户能够删除支出。
- en: Deleting expenses
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除支出
- en: 'For users to delete expenses from any month, we need to do the following things:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够从任何月份删除支出，我们需要做以下几件事：
- en: Add a method to `storageMethods` to update an `expenses` object. It should accept
    the month, year, and array of expenses. Then, it should override the array of
    expenses for that specific month and year combination in `AsyncStorage` with this
    new array, and recalculate the amount spent.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `storageMethods` 中添加一个方法来更新 `expenses` 对象。它应该接受月份、年份和支出数组。然后，它应该用这个新数组覆盖 `AsyncStorage`
    中特定月份和年份组合的支出数组，并重新计算支出金额。
- en: Wrap a `TouchabbleHighlight` component around each row that, when long pressed,
    opens an alert that asks the user whether they wish to delete the item.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `TouchabbleHighlight` 组件包裹在每一行周围，当长按时，会弹出一个提示框询问用户是否希望删除该项目。
- en: If the user confirms that they would like to delete the item, then we should
    delete it. A new array of expenses for the current month should be created without
    the deleted item, and it should be saved using the `storageMethods` function we
    made.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户确认他们想要删除该项目，那么我们应该删除它。应该创建一个新的当前月份支出数组，不包含已删除的项目，并使用我们制作的 `storageMethods`
    函数保存。
- en: When an expense is deleted, we should update the current view to reflect the
    item being deleted and the updated spent amount.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当删除一项支出时，我们应该更新当前视图以反映被删除的项目和更新的支出金额。
- en: If the user cancels, the alert should close and no changes should be made.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户取消，则警报应关闭且不应进行任何更改。
- en: Take some time to build this feature; when you're finished, check out the code
    I wrote for this part.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间构建这个功能；当你完成时，查看我为这部分编写的代码。
- en: 'First, I modified the `StorageMethods` file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我修改了 `StorageMethods` 文件：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first thing I did was write the `updateMonthExpensesArray` method. As I
    was writing it, I noticed that much of the code was similar to what `saveItemToBudget`
    was executing, so I refactored `saveItemToBudget` to call the new `updateMonthExpensesArray`
    method. This allows me to reuse some code in my file instead of writing it twice.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先编写了 `updateMonthExpensesArray` 方法。当我编写它时，我发现代码的大部分与 `saveItemToBudget` 执行的代码相似，所以我重构了
    `saveItemToBudget` 以调用新的 `updateMonthExpensesArray` 方法。这允许我在文件中重用一些代码，而不是写两次。
- en: 'When the `CurrentMonthExpenses` component deletes an item, `App.js` `_updateExpenses`
    method should be executed so that `AsyncStorage` is updated with a new array for
    the month and year that does not contain the deleted expense:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `CurrentMonthExpenses` 组件删除一个项目时，应执行 `App.js` 中的 `_updateExpenses` 方法，以便 `AsyncStorage`
    使用不包含已删除支出的新数组更新月份和年份：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `_updateExpenses` method is also passed into the `PreviousMonthsList` component
    so that it can propagate it down to its own rendering of `CurrentMonthExpenses`
    for the previous months:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`_updateExpenses` 方法也被传递到 `PreviousMonthsList` 组件中，以便它可以将其传播到其自己的 `CurrentMonthExpenses`
    的渲染，用于前几个月：'
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `PreviousMonthsList` gets a minor tweak to support the addition of the
    `updateExpenses` function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreviousMonthsList` 进行了一些小的调整以支持添加 `updateExpenses` 函数：'
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `render` method has been changed to set the `dataSource` constant of `ListView`
    to accept the expenses value of the `CurrentMonthExpenses` state in case it is
    present--this will be used to visually update the component to exclude a deleted
    item once a deletion occurs.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 方法已更改，将 `ListView` 的 `dataSource` 常量设置为接受 `CurrentMonthExpenses` 状态中的支出值（如果存在）--这将被用于在发生删除后视觉上更新组件，以排除已删除的项目。'
- en: 'This is necessary because `PreviousMonthsList` is the initial route of its
    own `NavigatorIOS` instance and therefore does not receive updated props from
    `App.js`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `PreviousMonthsList` 是其自己的 `NavigatorIOS` 实例的初始路由，因此不会从 `App.js` 接收更新的属性：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `_cancelAlert` method closes the `Alert` dialogue that appears:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`_cancelAlert` 方法关闭出现的 `Alert` 对话框：'
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following conditional blocks deal with the possibility that a user may
    want to delete more than one item from a list:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下条件块处理了用户可能想要从列表中删除多个项目的可能性：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `_deleteItem` method takes in the ID of the row being deleted, clones the
    expenses array, uses the `splice` method of the `Array` prototype to remove that
    specific index from it, and then removes it from `AsyncStorage` with the `updateMonthExpensesArray`
    method I created in the `StorageMethods` file.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`_deleteItem` 方法接收被删除行的 ID，克隆支出数组，使用 `Array` 原型的 `splice` 方法从其中删除该特定索引，然后使用我在
    `StorageMethods` 文件中创建的 `updateMonthExpensesArray` 方法从 `AsyncStorage` 中删除它。'
- en: 'Then, I set an `expenses` value in the local state to equal the new expenses
    array and call the `updateExpenses` method from `App.js` to update the data in
    the app:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我在本地状态中设置了一个 `expenses` 值，使其等于新的支出数组，并从 `App.js` 调用 `updateExpenses` 方法以更新应用中的数据：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Each `ExpenseRow` component will be passed in this `_onLongPress` method, which
    takes in its `rowID` and creates an alert prompt for the user. Based on the selected
    option, it either cancels the alert or deletes the row selected:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `ExpenseRow` 组件都会传递这个 `_onLongPress` 方法，该方法接收其 `rowID` 并为用户创建一个警报提示。根据所选选项，它要么取消警报，要么删除所选行：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `_renderRowData` method has been changed to pass in the `onLongPress` prop
    to `ExpenseRow`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`_renderRowData` 方法已更改，以将 `onLongPress` 属性传递给 `ExpenseRow`：'
- en: '[PRE70]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `TouchableHighlight` component of `ExpenseRow` has been updated to add
    an `onLongPress` callback that executes the `onLongPress` method passed into it
    as a prop from `CurrentMonthExpenses`. This is how the alert is triggered, giving
    the user the option to delete an added expense:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExpenseRow`的`TouchableHighlight`组件已被更新，以添加一个`onLongPress`回调，该回调执行从`CurrentMonthExpenses`作为属性传入的`onLongPress`方法。这就是触发警报的方式，给用户提供了删除添加的费用的选项：'
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This concludes our work on the iOS version of this app! Since this was a large
    app to build, I don't wish to drag you through the Android modifications in this
    chapter. Instead, the modifications I will make to this app to build it on an
    Android device can be found at the end of [Chapter 9](c9cb084b-5c75-4683-94c3-9b2124e8ecb0.xhtml),
    *Additional React Native Components*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对这个应用iOS版本的修改工作！由于这是一个构建起来很大的应用，我不希望在这个章节中带你们详细了解Android的修改。相反，我将在这个应用上进行的修改，以便在Android设备上构建，可以在[第9章](c9cb084b-5c75-4683-94c3-9b2124e8ecb0.xhtml)的末尾找到，*额外的React
    Native组件*。
- en: In the next chapter, we will begin working on an entirely new project.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始一个全新的项目。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we finished building our expense tracking app by utilizing
    the vector icon library we installed earlier to visually display the user's expenses.
    We also built a second view to look at the previous months' expenses and wrote
    a function to mock the data needed to visually verify that our app worked as intended.
    Then, we separated these two views using tabbed navigation and allowed users to
    delete expenses from the app.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过利用我们之前安装的矢量图标库来直观地显示用户的费用，完成了我们的费用跟踪应用的构建。我们还构建了一个第二个视图来查看前几个月的费用，并编写了一个函数来模拟所需的数据，以直观地验证我们的应用是否按预期工作。然后，我们使用标签导航将这两个视图分开，并允许用户从应用中删除费用。
