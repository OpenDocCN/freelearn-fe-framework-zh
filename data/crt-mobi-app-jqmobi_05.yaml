- en: Chapter 5. Client-side Templating, JSON APIs, and HTML5 Web Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。客户端模板化、JSON API和HTML5 Web 存储
- en: We've come a long way already and we've got some pretty hefty default templates
    and boilerplates for business. In this chapter, we're going to simplify and focus
    on some other things. We are going to create an aggregating news site based off
    social media. Until now, we've paid close attention to progressive enhancement.
    For this chapter, we leave that behind. This will require JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了很长一段路，为业务准备了一些相当庞大的默认模板和样板。在这一章中，我们将简化并专注于其他事项。我们将创建一个基于社交媒体的新闻聚合网站。到目前为止，我们一直非常重视渐进式增强。在本章中，我们将放弃这一点。这将需要JavaScript。
- en: 'In this chapter you will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将学到以下内容：
- en: Client-side templating options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端模板化选项
- en: JsRender
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JsRender
- en: Patching into JSON API (Twitter)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联接到 JSON API（Twitter）
- en: Programmatically changing pages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式更改页面
- en: Generated pages and DOM weight management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的页面和DOM权重管理
- en: Leveraging RSS feeds (natively)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 RSS 订阅（本地化）
- en: HTML5 Web Storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5 Web 存储
- en: Leveraging the Google Feeds API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Google Feeds API
- en: Client-side templating
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端模板化
- en: (In a grumpy old man's voice) Back in my day, we rendered all the pages on the
    server, and we liked it! LOL! Times are changing and we are seeing a massive ground
    swell in client-side templating frameworks. At their heart, they're pretty much
    all the same in that they take JSON data and apply an HTML-based template contained
    within a script tag.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: （以一个脾气暴躁的老人的声音）在我那个年代，我们在服务器上渲染所有页面，我们喜欢这样！哈哈！时代正在变化，我们看到客户端模板化框架的巨大潮流。它们的核心都差不多，即它们接收JSON数据并应用在一个包含在script标签中的基于HTML的模板上。
- en: If you know what **JSON** is, skip this paragraph. I spent a little time last
    chapter discussing this, but just in case you skipped ahead and don't know, JSON
    is JavaScript written in such a way that it can be used as a data exchange format.
    It's more efficient than XML and is instantly interpretable by the browser in
    an object-oriented fashion. JSON can request data even across domains using JSONP.
    For more on JSON, read [http://en.wikipedia.org/wiki/JSON](http://en.wikipedia.org/wiki/JSON).
    For more on JSONP, read [http://en.wikipedia.org/wiki/JSONP](http://en.wikipedia.org/wiki/JSONP).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道**JSON**是什么，跳过这一段。上一章我花了一点时间讨论了这个问题，但是万一你跳过了并且不知道，JSON是用JavaScript编写的，以便可以用作数据交换格式。它比XML更高效，并且以面向对象的方式立即被浏览器解释。JSON甚至可以使用JSONP跨域请求数据。有关JSON的更多信息，请阅读[http://en.wikipedia.org/wiki/JSON](http://en.wikipedia.org/wiki/JSON)。有关JSONP的更多信息，请阅读[http://en.wikipedia.org/wiki/JSONP](http://en.wikipedia.org/wiki/JSONP)。
- en: All these client-side libraries have some sort of notation in them to show where
    the data goes and gives ways to implement looping and conditionals. Some are "logic-less"
    and operate on the philosophy that there should be as little logic as possible.
    If you subscribe to this wonderfully academic approach, good for you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些客户端库都有一些标记，显示数据的去向，并提供实现循环和条件语句的方法。有些是“无逻辑”的，并且根据尽可能少的逻辑的理念运行。如果你赞同这种美妙的学术方法，那太棒了。
- en: Honestly, from a purely pragmatic perspective, I believe that the template is
    the perfect place for code. The more flexible, the better. JSON holds the data
    and the templates are used to transform it. To draw a parallel, XML is the data
    format and XSL templates are used to transform. Nobody whines about logic in XSL;
    so, I don't see why it should be a problem in JS templates. But, all of this discussion
    is purely academic. In the end, they'll pretty much all do what you're looking
    for. If you're more of a designer than a coder, you may want to look more at the
    logic-less templates.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，从纯粹实用的角度来看，我认为模板是代码的完美容器。越灵活越好。JSON保存数据，而模板用于转换数据。打个比方，XML是数据格式，XSL模板用于转换数据。没有人在XSL中抱怨逻辑；所以，我不明白为什么在JS模板中会成为问题。但是，所有这些讨论都是纯学术性的。最终，它们几乎都能做你想做的事情。如果你更多的是设计师而不是编码者，你可能会更多地关注无逻辑的模板。
- en: Following is a fairly exhaustive list of client-side templating frameworks.
    I'll probably miss a few and there will inevitably be more by the time this book
    gets published, but it's a start.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个相当详尽的客户端模板化框架列表。我可能会漏掉一些，而且到这本书出版时可能会有更多，但这是一个开始。
- en: doT
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: doT
- en: dust.js
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dust.js
- en: Eco
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eco
- en: EJS
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJS
- en: Google Closure Templates
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Closure Templates
- en: handlebars
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: handlebars
- en: haml-js
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: haml-js
- en: kite
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kite
- en: Jade
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jade
- en: jQote2
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQote2
- en: jQuery templates (discontinued)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery 模板（已停止）
- en: jsRender / jsView
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jsRender / jsView
- en: Parrot
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parrot
- en: node-asyncEJS
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: node-asyncEJS
- en: Nun
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nun
- en: Mu
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mu
- en: mustache
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mustache
- en: montage
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: montage
- en: Stencil
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stencil
- en: underscore.js
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: underscore.js
- en: Now, call me a fanboy, but, if it's officially jQuery, I love it. So, the first
    thing I tried was **jQuery Templates** . Sadly, shortly after learning to love
    it, the jQuery team abandoned the project and pointed people to **JsRender** as
    the continuation of the project. Whether that will be the continued direction
    in the future is another question, but, in the mean time, the features and power
    of JsRender make it a compelling offering and the basis for template work for
    the rest of this chapter. Not to mention, it's only 14k minified and fast as lightning.
    You can download the latest edition from [https://github.com/BorisMoore/jsrender](https://github.com/BorisMoore/jsrender).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然我是一个粉丝，但是，如果它是官方的 jQuery，我喜欢它。因此，我尝试的第一件事是 **jQuery Templates**。遗憾的是，在我刚学会喜欢它不久之后，jQuery
    团队放弃了这个项目，并指向 **JsRender** 作为项目的延续。未来是否会持续沿着这个方向是另一个问题，但是，目前，JsRender 的功能和强大性使其成为一个引人注目的选择，并且是本章其余部分模板工作的基础。更不用说，它只有经过精简的
    14k 并且速度快如闪电。您可以从 [https://github.com/BorisMoore/jsrender](https://github.com/BorisMoore/jsrender)
    下载最新版本。
- en: 'If you''re looking for help to make the decision on the right template framework
    for you, Andy Matthews was kind enough to offer the following link during the
    review process for this chapter: [http://garann.github.com/template-chooser/](http://garann.github.com/template-chooser/).
    It discusses the merits of several frameworks to help you make an informed choice.
    Thanks, Andy!'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找帮助以决定适合您的正确模板框架，那么在本章节审阅过程中，Andy Matthews很友好地提供了以下链接：[http://garann.github.com/template-chooser/](http://garann.github.com/template-chooser/)。它讨论了几个框架的优点，帮助您做出明智的选择。谢谢，Andy！
- en: Patching into JSON APIs (Twitter)
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接至 JSON API（Twitter）
- en: It's always fun to watch the trending topics on Twitter. It, like so many other
    popular online destinations, has a JSON API. Let's have some fun. Here's what
    we're going to build. You can see the listview on the left-side and the search
    view on the right-side.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 观看 Twitter 上的热门话题总是很有趣。就像许多其他受欢迎的在线目的地一样，它具有 JSON API。让我们来玩一下。这是我们要构建的内容。您可以在左侧看到列表视图，在右侧看到搜索视图。
- en: '![Patching into JSON APIs (Twitter)](img/0069_05_00.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![连接到 JSON API（Twitter）](img/0069_05_00.jpg)'
- en: 'At this point, I''m going to dispense with the academically correct practice
    of separating the CSS and JS from the HTML. Aside from the libraries, all page-specific
    code (HTML, CSS, and JS) will be located within the single page. The following
    code is our starting base page. It is `twitter.html` in the code bundle for the
    chapter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我将放弃从 HTML 中分离出 CSS 和 JS 的学术正确做法。除了库之外，所有特定于页面的代码（HTML、CSS 和 JS）将位于单个页面内。以下代码是我们起始的基本页面。在本章的代码包中，它是`twitter.html`：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This next bit of styling will help our Twitter results look more Twitter-ish:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的样式将帮助我们的 Twitter 结果看起来更像 Twitter：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This page is pretty much just a placeholder that will be filled in once we
    get back results from hitting the Twitter API:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面基本上只是一个占位符，一旦从 Twitter API 获取到结果，它将被填充：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following script is the processing core of the page.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的脚本是页面的处理核心。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Following are the two JsRender templates:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个 JsRender 模板：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: OK, that was a lot of code to throw at you all at once, but most of it should
    look pretty familiar at this point. Let's start with explaining some of the newest
    stuff.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，一次把那么多代码给你可能有点多，但大部分代码在这一点上看起来应该相当熟悉。让我们开始解释一些最新的东西。
- en: Normally, to pull data into a web page, you are subject to the same-domain policy
    even when you're pulling JSON. However, if it's coming from another domain, you'll
    need to bypass the same-domain policy. To bypass the some-domain policy, you could
    use some sort of server-side proxy such as PHP's **cURL** ([http://php.net/manual/en/book.curl.php](http://php.net/manual/en/book.curl.php))
    or the Apache **HTTP Core** **Components** ([http://hc.apache.org/](http://hc.apache.org/))
    in the Java world.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要将数据加载到网页中，即使您正在获取 JSON 格式的数据，也会受到同源策略的限制。然而，如果数据来自另一个域，您将需要绕过同源策略。为了绕过同源策略，您可以使用某种服务器端代理，例如
    PHP 的 **cURL**（[http://php.net/manual/en/book.curl.php](http://php.net/manual/en/book.curl.php)）或
    Java 世界中的 Apache **HTTP Core** **Components**（[http://hc.apache.org/](http://hc.apache.org/)）。
- en: 'Let''s just keep things simple and use **JSONP** (also known as **JSON with
    Padding**). JSONP does not use a normal Ajax request to pull information. Despite
    the fact that the configuration options are for the `$.ajax` command, behind the
    scenes, it will execute the call for the data as a standalone script tag as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持简单，使用**JSONP**（也称为**JSON with Padding**）。JSONP不使用常规的Ajax请求来获取信息。尽管配置选项是为`$.ajax`命令，但在幕后，它将以独立的脚本标签执行数据调用，如下所示：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is worth noting that JSONP is called using a GET request. That means that
    you can't use it to pass sensitive data, because it would be instantly viewable
    through network traffic scanning or simply looking at a browser's request history.
    So, no logging in over JSONP or passing anything sensitive. Got it?!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，通过JSONP使用GET请求。这意味着你不能用它传递敏感数据，因为它会通过网络流量扫描或简单查看浏览器的请求历史立即可见。所以，请不要通过JSONP登录或传递任何敏感信息。明白了吗？
- en: 'Before the actual request is made, jQuery will create a semi-random function
    name that will be executed once the response is received from the server. By appending
    that function name as the callback within the URL, we are telling Twitter to wrap
    their response to us with this function call. So, instead of receiving JSON script
    like `{"trends": …},` we have a script written to our page that starts as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '在实际请求发出之前，jQuery会创建一个半随机的函数名称，一旦从服务器收到响应，该函数将被执行。通过在URL中附加该函数名称作为回调，我们告诉Twitter用这个函数调用包裹他们发给我们的响应。因此，我们不会收到类似
    `{"trends": …},` 这样的JSON脚本，而是在我们页面上编写的脚本如下所示：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The reason this works is because the same-domain policy does not exist for scripts.
    Handy, yes? After the script is loaded and the callback has processed, we will
    have the data in JSON format. In the end, the execution under the sheets is vastly
    different, but the results are the same as you would get with regular `getJSON`
    requests from your own domain.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这能够运行的原因是同域策略对于脚本并不存在。方便，对吧？在脚本加载完并且回调处理完成之后，我们将以JSON格式获得数据。最终，在底层执行上有着截然不同，但结果与你通过自己域上的常规`getJSON`请求获得的结果是一样的。
- en: 'Here is a slice of the response back from Twitter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Twitter返回的响应片段：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we whittle down the response to only the part we want (the very latest
    set of trending topics) and pass that array into JsRender for … well… rendering.
    It may seem more simple to just loop through the JSON and use string concatenation
    to build your output but take a look at the following template and tell me that''s
    not going to be a lot cleaner to read and maintain:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将响应精简到我们想要的部分（最新一组热门话题），并将该数组传递给JsRender进行渲染。也许直接循环遍历JSON并使用字符串连接来构建输出可能更简单，但看看下面的模板，告诉我这不会更清晰易维护：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `text/x-jsrender` type on the script will ensure that the page does not
    try to parse the inner contents as JavaScript. Since we passed in an array to
    JsRender, the template will be written for every object in the array. Now that
    is simple! Granted, we're only pulling the name out of the data object, but you
    get the idea of how this works.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本上的`text/x-jsrender`类型将确保页面不会尝试解析内部内容为JavaScript。由于我们向JsRender传入了一个数组，模板将为数组中的每个对象编写。这样就简单了！尽管我们只从数据对象中提取了名称，但你明白这是如何工作的。
- en: 'Let''s look at the next significant block of JavaScript:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下一个重要的JavaScript代码块：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we pull the search term from the attribute on the link itself. The search
    term itself is somewhat inappropriate as an `id` attribute for dynamically rendered
    pages; so, we''ll strip out any spaces and non-alphanumeric content. We then append
    the `pageId` and `searchTerm` attribute to the JSON object we received back from
    Twitter. Following is a sample of returned data from this call:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从链接本身的属性中提取搜索词。搜索词本身作为用于动态渲染页面的`id`属性有些不合适，因此，我们将去除任何空格和非字母数字内容。然后，我们将`pageId`和`searchTerm`属性附加到我们从Twitter那里收到的JSON对象上。以下是从这个调用返回的数据样本：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, we''ll take this response and pass it into the renderer to be transformed
    against `twitterSearchPageTemplate`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将获取到的响应传递给渲染器，以便根据`twitterSearchPageTemplate`进行转换：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These are simple implementations. The examples on GitHub show many more options
    that are worth exploring. Check out [http://borismoore.github.com/jsrender/demos/](http://borismoore.github.com/jsrender/demos/)
    for details on creating more complex templates. This is a rapidly changing library
    (most client-side templating libraries are). So don't be surprised if, by the
    time you read this, there are a lot more options and slightly changed syntax.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是简单的实现。 GitHub 上的示例展示了许多值得探索的选项。查看[http://borismoore.github.com/jsrender/demos/](http://borismoore.github.com/jsrender/demos/)以获取有关创建更复杂模板的详细信息。这是一个变化迅速的库（大多数客户端模板库都是如此）。因此，如果你在阅读本文时，发现有更多选项和略有变化的语法，不要感到惊讶。
- en: Once we have the results of the transformation, we'll be ready to append the
    new page's source to the document's body and then programmatically change to this
    new page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了转换的结果，我们就可以将新页面的源附加到文档的主体，然后以编程方式切换到这个新页面。
- en: Programmatically changing pages
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以编程方式更改页面
- en: 'There are two ways to programmatically change pages in jQuery Mobile, and the
    differences are subtle:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以在 jQuery Mobile 中以编程方式更改页面，它们之间的区别很微妙：
- en: 'Call `$.mobile.changePage` and pass in a selector to the ID of the page you
    want to go to. This works the same way with URLs. Either way will yield the same
    results as if the user had clicked on a link. The page is inserted into the browser''s
    history as one might expect. Following is the example code:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`$.mobile.changePage`并传递一个选择器到你想要跳转到的页面的 ID。这与 URL 的工作方式相同。无论哪种方式都会产生与用户点击链接相同的结果。该页面将被插入浏览器的历史记录中，正如人们所期望的那样。以下是示例代码：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a jQuery object by selecting the page you want to change to first. Then,
    pass that jQuery object into the `$.mobile.changePage` function. The result is
    that the page is shown but the URL never updates, and, thus, it does not exist
    in the browser''s history. This might be useful in situations where, if the user
    refreshes the page, you would want them to start the process over at the first
    screen. It prevents deep linking through bookmarks into other pages in a multipage
    layout. Following is an example:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先通过选择要更改的页面来创建一个 jQuery 对象。然后，将该 jQuery 对象传递到`$.mobile.changePage`函数中。结果是页面被显示，但
    URL 永远不会更新，因此它不会存在于浏览器的历史记录中。这在用户刷新页面时重新开始第一个屏幕的过程时可能会有用。它防止了通过书签进行深度链接到多页布局中的其他页面。以下是一个示例：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Generated pages and DOM weight management
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成的页面和 DOM 负载管理
- en: In the normal course of events while surfing traditional mobile sites, jQuery
    Mobile will mark each page as `external-page`, which will cause the page to be
    removed from the DOM once the user navigates away from that page. The idea behind
    this is that it will manage DOM weight because "budget" (crappy) devices may not
    have as much memory to dedicate to their browsers. External pages will likely
    still be in the device cache for quick recall. So reloading them should be lightning
    fast. If you want to learn more about how jQuery Mobile handles this behavior,
    check out [http://jquerymobile.com/demos/1.3.0/docs/pages/page-cache.html](http://jquerymobile.com/demos/1.3.0/docs/pages/page-cache.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，当在传统移动站点上浏览时，jQuery Mobile 将每个页面标记为`external-page`，这将导致用户导航离开该页面后从 DOM
    中移除该页面。这样做的理念是，它将管理 DOM 的负载，因为“预算”（糟糕的）设备可能没有足够的内存来专用于其浏览器。外部页面很可能仍然在设备缓存中以便快速召回。因此，重新加载它们应该是极快的。如果你想了解
    jQuery Mobile 如何处理此行为，请查看[http://jquerymobile.com/demos/1.3.0/docs/pages/page-cache.html](http://jquerymobile.com/demos/1.3.0/docs/pages/page-cache.html)。
- en: jQuery Mobile has done a great job at managing DOM weight through normal means.
    However, when we dynamically create pages, they are not automatically deleted
    from the DOM on exit. This can become especially overwhelming if there are a lot
    of them. We could easily overwhelm the miserable browsers on dumb phones and even
    some of the early-model or budget smartphones. If a dynamically-created page is
    likely to be viewed again within a session, then it may well be worth leaving
    in the DOM. However, since we're generating it in the browser to begin with, it's
    probably safer and faster to just re-render the page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery Mobile 通过正常手段很好地管理 DOM 的负载。然而，当我们动态创建页面时，它们不会在退出时自动从 DOM 中删除。如果有很多这样的页面，这可能会变得非常压倒性。我们很容易就会压垮愚蠢手机上的可怜浏览器，甚至一些早期型号或预算智能手机也是如此。如果动态创建的页面可能在会话中再次查看，则将其留在
    DOM 中可能是值得的。然而，由于我们开始时是在浏览器中生成它，所以将页面重新呈现可能更安全更快速。
- en: 'You can mark a page for deletion using this line of code *after* the page has
    been rendered but *before* the page is initialized:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面呈现完成但在页面初始化之前，你可以使用这行代码标记一页删除：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**WARNING**: This line of code comes almost verbatim from the library code
    itself. This is how they do it behind the scenes. Please note that `$.mobile._bindPageRemove`
    begins with an underscore. We are not dealing with a public method here.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：这行代码基本上是直接从库代码中来的。这就是它们在幕后是如何做的。请注意，`$.mobile._bindPageRemove`以一个下划线开头。这里我们没有处理一个公共方法。'
- en: This particular code is an undocumented and unofficial part of the API, which
    means that it could be changed on any given release. As central as this is to
    the framework, I doubt they'll change it; however, anytime you start introducing
    code that relies on continued presence of non-public APIs, you run the risk of
    an upgrade breaking your code without any warning in the release notes. Use freely,
    but thoroughly test each library upgrade.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是API的一个未记录和非官方部分，这意味着它可能在任何发布的版本中被更改。这对于框架的核心部分来说，我怀疑它们会更改；但是，任何时候当你开始引入依赖于非公开API的代码时，你都面临着升级可能在发布说明中没有任何警告的情况下破坏你的代码的风险。可以自由使用，但是务必对每个库的升级进行彻底测试。
- en: Leveraging RSS feeds
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用RSS源
- en: What can I say? My editors made me do it. I hadn't initially planned on building
    anything around RSS. I'm glad they did because after looking around, there's a
    lot more information out there being fed by RSS than by JSON feeds. I figured
    the digital world had advanced a little more than it really had. So, Usha, thank
    you for making me include this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我能说什么呢？正是我的编辑让我这么做的。最初我并没有计划围绕RSS构建任何东西。我很高兴他们这样做，因为经过调查，发现被RSS提供的信息要比JSON信息源要多得多。我觉得数字世界比它实际上发展得更多。所以，Usha，谢谢你让我包括这个。
- en: First things first, if we don't use a server-side proxy, we will crash right
    into the unforgiving wall of the same-original policy. Examples include cURL in
    PHP systems, Apache HTTP Core Components in Java, or something like HttpWebRequest
    on .Net.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们不使用服务器端代理，我们将立即遇到同一源策略的严苛限制。示例包括PHP系统中的cURL，Java中的Apache HTTP Core组件，或者是.NET平台上的HttpWebRequest等。
- en: Following is the page I created in PHP to leverage cURL to grab the Ars Technica
    feed. The source for this file is in `ars.php` in the chapter code bundle.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我在PHP中创建的页面，利用cURL抓取Ars Technica的信息流。这个文件的源代码在本章的代码包中的`ars.php`中。
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**WARNING**: cURL and other server-side proxy libraries are very powerful and,
    thus, very dangerous tools. Do *not* parameterize the URL that you intend to hit
    with this page. Hard code the URL. If you must take a parameter from the calling
    URL to build your destination, then *you must escape all parameters*. If you do
    not, you can rest assured that someday a hacker is going to have a lot of fun
    with your site with cross-site scripting ([https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS))).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：cURL和其他服务器端代理库非常强大，因此也非常危险。*不要*把你想要访问本页的URL参数化。硬编码URL。如果你必须从调用URL获取参数来构建你的目标地址，那么*你必须转义所有的参数*。如果不这样做，可以肯定的是总有一天，黑客会利用你的网站进行跨站脚本(XSS)攻击([https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)))。'
- en: 'Next, let''s add some buttons to the top. One for our Twitter feed, and one
    for Ars Technica. The final source for this next part will be in the file `index.html`
    in the code bundle for the chapter:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在顶部添加一些按钮。一个是我们的Twitter源，一个是Ars Technica的。下一部分的最终来源将在本章的代码包中的`index.html`文件中：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s add to our scripts to load the feed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加脚本来加载信息流：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here's what our new feed reader looks like!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的新的RSS阅读器的样子！
- en: '![Leveraging RSS feeds](img/0069_05_01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![利用RSS源](img/0069_05_01.jpg)'
- en: Forcing responsive images
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制响应式图片
- en: When you're importing from a page where you have no control over the images
    embedded in the content, you may have to tweak them to get it to look right in
    mobile. As in the previous example, I've found it's best to remove the explicit
    width and heights on the image itself and use CSS to make it fill 100 percent
    of its current container. Then, use a CSS `max-width` property to ensure the image
    is never scaled beyond it's original intended sizes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个页面导入内容，而你无法控制内容中嵌入的图片时，你可能需要调整它们以在移动设备上显示正确。就像上一个例子一样，我发现最好是移除图片本身的显式宽度和高度，并使用CSS使其填充当前容器的100%。然后，使用CSS的`max-width`属性来确保图像不会被放大超出其原始意图的尺寸。
- en: While not truly being responsive in terms of loading a different size of the
    image that is appropriate for the resolution based on media queries, we've accomplished
    the same visible effect with the limited resources at our disposal for cases like
    this.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在加载适合分辨率的不同尺寸的图像方面并没有真正性能响应，但我们已经使用我们有限的资源达到了相同的可见效果，对于这样的情况。
- en: HTML5 Web Storage
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5 Web 存储
- en: 'HTML5 Web Storage is ridiculously simple if you haven''t messed with it already.
    If you have, skip to the next paragraph. There are really only two forms of web
    storage: `localStorage`, and `sessionStorage`. `localStorage` will keep the information
    indefinitely. `sessionStorage` will store only for the length of a single session.
    It''s a simple key/value paired system. Everything is string-based. So you''ll
    need to convert the values to other formats as needed, once you''ve extracted
    them back out of storage. Check out [http://www.w3schools.com/html5/html5_webstorage.asp](http://www.w3schools.com/html5/html5_webstorage.asp)
    for more information.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有尝试过 HTML5 Web 存储，它其实可以相当简单。如果已经尝试过了，可以跳到下一段。实际上只有两种 web 存储形式：`localStorage`，和
    `sessionStorage`。`localStorage` 将永久地保存信息。`sessionStorage` 只在单个会话的周期内保存。这是一个简单的键值配对系统。所有东西都是基于字符串的。因此，一旦你从存储中提取出来，你需要根据需要将这些值转换为其他格式。查看
    [http://www.w3schools.com/html5/html5_webstorage.asp](http://www.w3schools.com/html5/html5_webstorage.asp)
    获取更多详细信息。
- en: Now, this gets interesting with the definition of session. *Do not confuse*
    the session on your server with the browser session. The user session on your
    server might be set to expire within 20 minutes or so. However, just because your
    server session has expired, doesn't mean that your browser knows anything about
    that. *HTML5 session storage will persist until the browser is actually closed.*
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，关于会话的定义就变得有趣了。*不要混淆*你服务器上的会话和浏览器会话。你服务器上的用户会话可能在大概20分钟内就会过期。然而，只是因为你服务器上的会话已经过期，并不意味着你的浏览器知道这一点。*HTML5
    会话存储会一直持续到浏览器实际关闭。* '
- en: This gets especially tricky on mobile browsers. In both Android and iOS, when
    you switch tasks or press the home button, the browser doesn't actually close.
    In both cases, you have to actually use the task killer functions to completely
    close the browsers. This is something that the end user might not actually do
    on their own.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这在移动浏览器上就特别棘手了。在安卓和iOS系统中，当你切换任务或按下主屏幕按钮时，浏览器并不会真正关闭。在这两种情况下，你必须使用任务关闭功能来完全关闭浏览器。这是最终用户可能并不会自己去做的事情。
- en: But what's the big deal about web storage? Why not just use cookies to store
    information on the client? After all, it will work with everyone, right? Yes,
    cookies will work for everyone. However, they were never meant to store massive
    amounts of data like we're using in this example, and there is a soft limit to
    the number of cookies you can even store per domain (anywhere from 20-50 depending
    on the browser). The worst part about trying to use cookies for client-side storage
    is that they are sent back to the server as part of the request *for every single
    asset served from that domain*. That means that every CSS, JS, image, and page/Ajax
    request will carry every cookie with its payload. You can see how this could quickly
    start to degrade your performance. Adding one cookie could result in that data's
    transmission many times just to render a single page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，关于 web 存储有何不同之处呢？为什么不只是用 cookie 在客户端上存储信息呢？毕竟，这会适用于每个人，对吧？是的，cookie 会适用于每个人。然而，它们从来就不是用来存储大量数据的，就像我们在这个例子中使用的那样，并且每个域名可以存储的
    cookie 数量也有软上限（根据浏览器的不同，从 20 到 50 不等）。试图使用 cookie 在客户端存储的最糟糕的一面是，它们随着每个资源的请求一起发送回服务器。这意味着每个
    CSS、JS、图像以及页面/Ajax 请求都会携带着所有 cookie 以其有效荷载。你可以看到这样会很快降低你的性能。添加一个 cookie 可能导致数据被传输多次，仅用来渲染一个页面。
- en: Browser-based databases (a work in progress)
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于浏览器的数据库（进展中）
- en: Browser-based databases are in a state of extreme flux right now. There are
    actually two different standards available at the moment. The first is **Web**
    **SQL Database** ([http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/)).
    You could use it, but, according to the W3C, this spec is no longer active. Many
    browsers have implemented Web SQL Database, but how long will it be around?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于浏览器的数据库目前处于极端波动状态。实际上，目前有两种不同的标准。第一种是 **Web SQL Database** ([http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/))。你可以使用它，但根据
    W3C 的说法，这个规范已经不再活跃。许多浏览器已经实现了 Web SQL Database，但它能够存活多久呢？
- en: The W3C has, instead, stated that the direction for database on the browser
    will be **Indexed Database** ([http://www.w3.org/TR/IndexedDB/](http://www.w3.org/TR/IndexedDB/)).
    The working draft has editors from Microsoft, Google, and Mozilla; so, we can
    expect broad support in the future. The problem here is that the working draft
    was published May 24, 2012\. As of the time of writing this chapter, only Firefox,
    Chrome, and Internet Explorer 10 are supporting IndexedDB ([http://en.wikipedia.org/wiki/Indexed_Database_API](http://en.wikipedia.org/wiki/Indexed_Database_API)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: W3C已经声明，浏览器上数据库的方向将是**Indexed Database**（[http://www.w3.org/TR/IndexedDB/](http://www.w3.org/TR/IndexedDB/)）。工作草案的编辑来自微软、谷歌和Mozilla；因此，我们可以期待未来有广泛的支持。问题是，工作草案于2012年5月24日发布。截至我写这一章时，只有Firefox、Chrome和Internet
    Explorer 10支持IndexedDB（[http://en.wikipedia.org/wiki/Indexed_Database_API](http://en.wikipedia.org/wiki/Indexed_Database_API)）。
- en: JSON to the rescue
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON拯救了我们
- en: For now, we find ourselves in a terrible position of either using a doomed database
    or waiting for everyone to catch up with the new spec. Web Storage looks like
    the only safe bet in the near future. So, how can we best leverage that? With
    JSON, of course! All major browsers support JSON natively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们发现自己处于一个极其糟糕的境地，要么使用一个丑恶的数据库，要么等待所有人都跟上新规范。在不久的将来，Web存储看起来是唯一的安全选择。那么，我们如何最好地利用它呢？当然是用JSON！所有主要浏览器都原生支持JSON。
- en: Think about the way we've always had to deal with relational databases in the
    past. As object-oriented programmers, we've always done our query and then taken
    the results data and turned it into an object in memory. We can do almost the
    exact same thing by simply storing JSON directly to a key in Web Storage by using
    the `JSON.stringify` method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我们过去一直处理关系数据库的方式。作为面向对象的程序员，我们总是进行查询，然后将结果数据转换成内存中的对象。我们几乎可以通过使用`JSON.stringify`方法将JSON直接存储到Web存储中，以几乎相同的方式来做完全相同的事情。
- en: 'Here is an example to test if your system natively supports JSON. The source
    is `jsonTest.html` in the chapter code bundle:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，用来测试你的系统是否原生支持JSON。源文件在本章的代码包中的`jsonTest.html`。
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If all is well, you'll see an alert containing a timestamp.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你将看到一个包含时间戳的警报。
- en: If, for some reason, you find yourself in the unlucky position of having to
    support some massively out-of-date system (Windows Phone 7 and BlackBerry 5 or
    6, I'm looking at you), go get `json2.js` from [https://github.com/douglascrockford/JSON-js](https://github.com/douglascrockford/JSON-js)
    and include it with your other scripts. Then, you'll be able to stringify and
    parse JSON.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，你发现自己不幸地必须支持一些过时的系统（Windows Phone 7和BlackBerry 5或6，我正在看着你），请从[https://github.com/douglascrockford/JSON-js](https://github.com/douglascrockford/JSON-js)获取`json2.js`并将其包含在其他脚本中。然后，你将能够stringify和parse
    JSON。
- en: Leveraging the Google Feeds API
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Google Feeds API
- en: So, we've seen how to natively pull in a normal RSS feed, parse, and build out
    the pages using normal, tedious string concatenation. Now, let's consider an alternative
    that I had no idea even existed when I first started writing this chapter. Thanks
    go to Raymond Camden and Andy Matthews for pointing this out in their book, *jQuery
    Mobile Web Development Essentials*. You need to follow those two on Twitter at
    `@cfjedimaster` and `@commadelimited`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经看到了如何原生地拉取一个普通的RSS订阅，解析，并使用正常而乏味的字符串拼接构建页面。现在，让我们考虑一种替代方案，我在开始写这一章时甚至不知道它的存在。感谢雷蒙德·卡姆登和安迪·马修斯在他们的书《jQuery移动Web开发要点》中指出这一点。你需要在Twitter上关注他们两个，`@cfjedimaster`和`@commadelimited`。
- en: The Google Feeds API can be fed several options, but at its core, it's a way
    to specify an RSS or ATOM feed and get back a JSON representation. Naturally,
    this opens up a few more interesting doors in this chapter. If we can now pull
    in multiple feeds of different types without having to have any kind of server-side
    proxy, we can greatly simplify our lives. Client-side templates are back in the
    picture! No more string concatenation! Since they're all in a unified format (including
    the publish date), we can pull them all together into one master view with all
    feed stories sorted by date.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Google Feeds API可以提供多种选择，但它的核心是指定RSS或ATOM订阅并返回JSON表示。当然，这在这一章节中开启了更多有趣的可能性。如果我们现在可以获取不同类型的多个订阅，而无需任何服务器端代理，我们可以极大地简化我们的生活。客户端模板再次出现！不再需要字符串拼接！因为它们都是统一格式（包括发布日期），我们可以把它们全部整合到一个主视图中，所有订阅故事按日期排序。
- en: 'Sorting objects by their properties is actually pretty simple. You just have
    to pass a function to do the comparison. The following code is what we''ll use
    for the date:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 按其属性对对象进行排序实际上相当简单。你只需要传递一个比较函数。以下代码是我们将用于日期的：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s specify a JSON object to store the feeds we want to use:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们指定一个 JSON 对象来存储我们想要使用的 feeds：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next we''ll use our processor function to handle the stories as they come in:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们的处理函数来处理传入的故事：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s our JsRender template:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 JsRender 模板：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And finally, here is the function that will kick off the whole thing:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是将启动整个过程的函数：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I've included this as part of my functional example in the `challenge.html`
    file, but the source goes much deeper than that. The source of `challenge.html`
    has several hidden gems for you to find as well. I tossed in Reddit, Flickr, and
    a local search of Twitter while I was at it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将此包含在我的 `challenge.html` 文件的功能示例中，但源代码要比这深得多。`challenge.html` 的源代码还有几个隐藏的宝藏供你发现。我还添加了
    Reddit、Flickr 和本地搜索 Twitter。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You have been presented with a very wide array of choices for client-side templating.
    At this point, you now know how to leverage JSON and JSONP and combine them effectively
    to create pages on the fly. RSS should present no real challenge to you at this
    point either, since you can do it either natively or using Google Feeds.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经被呈现了一个非常广泛的客户端模板选择。在这一点上，你现在知道如何利用 JSON 和 JSONP 并有效地将它们结合起来动态创建页面。RSS 对你来说也不会是真正的挑战，因为你可以本地或使用
    Google Feeds 来处理。
- en: In the next chapter, we'll combine some of these techniques as we continue to
    build our technical tool chest and turn our eyes to HTML5 Audio.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将结合一些这些技术，继续构建我们的技术工具箱，并将目光转向 HTML5 音频。
