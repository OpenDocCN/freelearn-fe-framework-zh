- en: Chapter 7. Making Your Component Reusable
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：使你的组件可重用
- en: Until now, we have dug into React's components' lifecycle, properties, state,
    and ECMAScript with respect to React 0.1.13 and future versions. In this chapter,
    we will also see how we can write reusable components/code in React applications.
    Such reusable components in React are named Mixins. Furthermore, we will explore
    how the React component's properties can be validated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经深入探讨了React组件的生命周期、属性、状态以及与React 0.1.13和未来版本相关的ECMAScript。在本章中，我们还将看到如何在React应用程序中编写可重用的组件/代码。React中的这些可重用组件被称为混合。此外，我们将探讨如何验证React组件的属性。
- en: 'The following topics to be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding mixins
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解混合
- en: A higher order component in ECMA6 (as Mixin is not supported in ECMA6)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMA6中的高阶组件（因为混合在ECMA6中不受支持）
- en: Different types of validations in a React application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React应用程序中的不同类型的验证
- en: The structure of a React component and application's architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件和应用程序架构的结构
- en: Understanding Mixins
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解混合
- en: The Mixins (reusable components) are typically those React components that are
    used in multiple places and thus can be reused. Typically, the design elements,
    such as buttons, layout components, form fields, or any code logic/computation,
    that are used more than once are extracted in code named Mixin. Thus, Mixins help
    us incorporate some additional functionalities to existing React components by
    acting as helpers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 混合（可重用组件）通常是那些在多个地方使用的React组件，因此可以重用。通常，设计元素，如按钮、布局组件、表单字段或任何使用超过一次的代码逻辑/计算，都被提取到名为混合的代码中。因此，混合通过作为助手来帮助我们向现有的React组件中添加一些额外的功能。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like in the previous chapters , the index.html content remains the same. Only
    the contents of the corresponding js (having the React components) changes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，index.html的内容保持不变。只有相应的js（包含React组件）的内容发生变化。
- en: Exploring Mixins by example
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过示例探索混合
- en: 'In this example we are setting the interval of the window global objects for
    every 100 ms:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们为window全局对象设置了每100毫秒的间隔：
- en: 'Content of index.html:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: index.html的内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Content of index.js:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: index.js的内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Run the httpserver from the application''s root dir:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序的根目录运行httpserver：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the output for this code on opening `localhost:3333`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开`localhost:3333`时，以下是对此代码的输出：
- en: '![Exploring Mixins by example](img/00039.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![通过示例探索混合](img/00039.jpeg)'
- en: The app screenshot using Mixin with a lifecycle method
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生命周期方法的混合的应用程序截图
- en: 'The explanation of the executed code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码的解释：
- en: A mixin is nothing but a JavaScript object, which can be reused within the React
    component later. We begin with defining the Mixin.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 混合（Mixin）不过是一个可以被React组件后来重用的JavaScript对象。我们首先定义混合（Mixin）。
- en: The `componentWillMount` is a lifecycle method, which is added as a part of
    the Mixin. Later, when the Mixin is called from the react component, the log from
    `console.log` can be seen in the bottom part of the developer tool portion of
    the webpage to present **Component Will Mount**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillMount`是一个生命周期方法，它作为混合的一部分被添加。稍后，当混合从React组件中调用时，可以在网页的开发者工具部分底部看到`console.log`的日志，以展示**Component
    Will Mount**。'
- en: We add a typical react component (`<App />`), which calls the `<Label />` component.
    It's a render function, which displays the text presented on the label. The App
    component can have multiple react components, which will internally call different
    react components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个典型的React组件（`<App />`），它调用了`<Label />`组件。它是一个渲染函数，用于显示标签上呈现的文本。App组件可以有多个React组件，这些组件将内部调用不同的React组件。
- en: In the next example, we will see such an example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将看到这样的例子。
- en: React component `(<Label />`) is called from the `<App />` component. It's using
    the React Mixin (ReactMixin).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: React组件`(<Label />)`是从`<App />`组件中调用的。它使用了React混合（ReactMixin）。
- en: In line mixins:[ReactMixin], Mixins in React, are called using the keyword Mixin,
    followed by the Mixin name (ReactMixin in this case), within an array. We can
    define multiple Mixins, as JavaScript objects. All these separate Mixins can then
    be called from a single React component (each Mixin representing a separate element
    in an array).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 行内混合：[ReactMixin]，React中的混合（Mixins）是通过关键字Mixin后跟混合名称（在本例中为ReactMixin），在数组内调用。我们可以定义多个混合，作为JavaScript对象。所有这些独立的混合都可以从单个React组件（每个混合代表数组中的一个单独元素）中调用。
- en: We will explore such an example, with multiple Mixins, later in the chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面探索这样一个例子，其中包含多个混合。
- en: We then add the `setInterval()` function
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加`setInterval()`函数
- en: '`The setInterval`() method is a window function in JavaScript.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setInterval()`方法是JavaScript中的window函数。'
- en: It's declared as `window.setInterval(function, milliseconds)`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被声明为`window.setInterval(function, milliseconds)`。
- en: Although it's a method based on window object, but it's not necessary to call
    the `setInterval()` method on the window object, such as in the previously mentioned
    code. It can be called without the window prefix.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这是一个基于window对象的方法，但不需要在window对象上调用`setInterval()`方法，例如在之前提到的代码中。它可以不带window前缀调用。
- en: The first parameter is the function that gets executed (`this.increaseCountBy10`).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是执行的功能（`this.increaseCountBy10`）。
- en: The second parameter is the interval of time between executions of each of the
    function, `this.increaseCountBy10`. The interval is set to `100ms` in this case.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是每个函数执行之间的时间间隔，`this.increaseCountBy10`。在这种情况下，间隔设置为`100ms`。
- en: The lifecycle method (`componentWillMount`) is then called for the second time
    in the previously mentioned code. For the first time, it is called within the
    Mixin body, which logs the `Component Will Mount` on the log.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的代码中，生命周期方法（`componentWillMount`）被第二次调用。第一次调用是在Mixins体内，它记录了日志中的`Component
    Will Mount`。
- en: For the second time, it is called within the React component (`<Label />`).
    Due to the second call, the `setInterval()` method is incrementing the value from
    `0` (count set to `0` initially) to `10`, in each `100` ms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用是在React组件（`<Label />`）内部。由于第二次调用，`setInterval()`方法将值从`0`（最初将计数设置为`0`）增加到`10`，每次增加间隔为`100`毫秒。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Take a look at the Facebook documentation [https://facebook.github.io/react/docs/reusable-components.html](https://facebook.github.io/react/docs/reusable-components.html):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Facebook文档[https://facebook.github.io/react/docs/reusable-components.html](https://facebook.github.io/react/docs/reusable-components.html)：
- en: '"A nice feature of Mixins is that if a component is using multiple Mixins and
    several Mixins define the same lifecycle method (i.e. several Mixins want to do
    some clean up when the component is destroyed), all of the lifecycle methods are
    guaranteed to be called. Methods defined on Mixins run in the order Mixins were
    listed, followed by a method call on the component."'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '"Mixins的一个优点是，如果一个组件正在使用多个Mixins，并且几个Mixins定义了相同的生命周期方法（即几个Mixins想在组件销毁时进行一些清理），所有生命周期方法都将得到保证被调用。Mixins上定义的方法按照Mixins列出的顺序运行，然后是组件上的方法调用。"'
- en: 'We will see another example of Mixins in the next section:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到Mixins的另一个示例：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We shall now see another example where multiple Mixin will be called from a
    single React component. The following code is declared:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到另一个示例，其中多个Mixins将从单个React组件中调用。以下代码被声明：
- en: 'First, we shall declare two react Mixins:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明两个react Mixins：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the Second part of the code, we will call both the React Mixins, from the
    react component `<App />`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第二部分，我们将从react组件`<App />`中调用两个React Mixins：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Execute the command httpster from application root directly like before to
    see the output from two Mixins:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从应用程序根目录执行httpster命令，就像之前一样，以查看两个Mixins的输出：
- en: '![Exploring Mixins by example](img/00040.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![通过示例探索Mixins](img/00040.jpeg)'
- en: The app screenshot using multiple Mixins
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个Mixins的应用程序截图
- en: 'Note the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The same property name in both the Mixins, for example, **text**, in this case,
    will throw an error
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mixins中相同的属性名，例如，**text**，在这种情况下，将引发错误
- en: The same method name within the different Mixins will throw an error
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同Mixins中的相同方法名将引发错误
- en: The same lifecycle methods can be called both within Mixin and within a React
    component. The order of execution of these lifecycle methods is Mixin, followed
    by a React component.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的生命周期方法可以在Mixins和React组件内部调用。这些生命周期方法的执行顺序是Mixins，然后是React组件。
- en: In case the same lifecycle method is called within different Mixins, then the
    order of execution is in the order in which the Mixins are called within the array
    [lower to higher index].
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在多个Mixins中调用相同生命周期方法，则执行顺序是Mixins在数组中调用的顺序（从低到高索引）。
- en: Higher-order components in Mixins
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mixins中的高阶组件
- en: In ReactJS using ES6, Mixins are no longer supported. Instead of this, they
    have introduced higher order components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReactJS中使用ES6，Mixins不再被支持。取而代之的是，他们引入了高阶组件。
- en: These higher order components are widely used in the Relay framework, which
    is a complete React-based framework released by Facebook. The higher order component
    wraps up child UI components. Thus, these components when called will first execute
    its queries and thereby render the child UI component(s). When the query is passed,
    data is passed from the child component to the higher order component in as props.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高阶组件在 Relay 框架中被广泛使用，Relay 是由 Facebook 发布的一个完整的基于 React 的框架。高阶组件封装了子 UI 组件。因此，当这些组件被调用时，它们会首先执行其查询，从而渲染子
    UI 组件。当查询传递时，数据会从子组件以 props 的形式传递给高阶组件。
- en: Validations
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: '**Validations** are an integral part of any application dealing with user input.
    In ReactJS, there are some validations provided by the library that enables the
    developer to validate the data received.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证** 是任何处理用户输入的应用程序的一个基本组成部分。在 ReactJS 中，库提供了一些验证，使得开发者能够验证接收到的数据。'
- en: Data are received mostly as properties (props) in react application. The various
    validators are exported from `React.PropTypes`. Any validation error, if occurs,
    will appear in the JavaScript console. Any such error occurring due to validation
    check will only occur in the development mode due to performance reasons.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用程序中，数据大多以属性（props）的形式接收。各种验证器从 `React.PropTypes` 中导出。如果发生验证错误，它将出现在
    JavaScript 控制台中。由于性能原因，只有开发模式下才会因为验证检查而发生此类错误。
- en: 'Take a look at the Facebook ReactJS development team documentation [https://facebook.github.io/react/docs/reusable-components.html#prop-validation](https://facebook.github.io/react/docs/reusable-components.html#prop-validation).
    The following is an example of the various validators:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Facebook ReactJS 开发团队文档 [https://facebook.github.io/react/docs/reusable-components.html#prop-validation](https://facebook.github.io/react/docs/reusable-components.html#prop-validation)。以下是一些验证器的示例：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An example using the isRequired validator
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 isRequired 验证器的示例
- en: 'The `index.html` page. Use different JS pages in order to check the different
    versions of the validations used:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 页面。使用不同的 JS 页面来检查使用的不同版本的验证：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As the name of the validation suggests, the `isRequired` validator ensures
    that the property of the React component remains present. Otherwise, it will throw
    an error in the JS console. The `React.PropTypes.{foo}` properties are the JavaScript
    functions, which internally check whether a prop is valid or not. When the prop
    is valid, it will return `null`, but when the prop is invalid, then it returns
    an error. In [Chapter 4](part0029_split_000.html#page "Chapter 4. Stateful Components
    and Events"), *Stateful Components and Events* we dug into ES6\. In the next example,
    we will be using the ES6 syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如验证器名称所示，`isRequired` 验证器确保 React 组件的属性始终存在。否则，它将在 JS 控制台中抛出错误。`React.PropTypes.{foo}`
    属性是 JavaScript 函数，它们内部检查一个 prop 是否有效。当 prop 有效时，它将返回 `null`，但当 prop 无效时，它将返回一个错误。在
    [第 4 章](part0029_split_000.html#page "第 4 章。有状态组件和事件") 中，我们深入探讨了 ES6。在下一个示例中，我们将使用
    ES6 语法：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Run the httpster from your app's root dir in order to see the output in your
    browser's `localhost:3333`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用根目录下运行 httpster，以便在浏览器中的 `localhost:3333` 看到输出。
- en: 'The output will be as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![An example using the isRequired validator](img/00041.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用 isRequired 验证器的示例](img/00041.jpeg)'
- en: The app screenshot—the isRequired validation in the React component prop
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序截图——React 组件 prop 中的 isRequired 验证
- en: 'A few points from the ES6 point of view with respect to the previously mentioned
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ES6 视角来看，关于之前提到的代码的一些要点：
- en: '`use strict` has been used opt in to a restricted variant of JavaScript. This
    is used as we are using let instead of var. `use strict` allows to place a component
    in a `strict` operating context and prevents certain actions from being taken
    and throws more exceptions.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`use strict` 已经被用来选择性地启用 JavaScript 的一个受限版本。我们使用它是因为我们用 let 代替了 var。`use strict`
    允许将组件置于一个 `strict` 运行环境中，并阻止某些操作被执行，同时抛出更多的异常。'
- en: let declares variables that are limited in scope to the block, statement, or
    expression on which it is used.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: let 声明变量，其作用域限制在使用的块、语句或表达式中。
- en: See the details at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息请查看 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/)。
- en: An example using custom validator
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义验证器的示例
- en: 'The following is the template, generally used while using custom validation
    in the code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用自定义验证时通常使用的模板：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s go through an example of our own with custom error messages and use
    a few of these validations and see how it validates in the JavaScript console:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个自己的例子来演示，使用自定义错误消息，并使用这些验证之一，看看它在JavaScript控制台中的验证情况：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Run the httpster from your app's root dir in order to see the output in your
    browser's `localhost:3333`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的应用程序根目录运行httpster，以便在你的浏览器中的 `localhost:3333` 看到输出
- en: 'The output of this code is shown in this screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出显示在本截图：
- en: '![An example using custom validator](img/00042.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义验证器的示例](img/00042.jpeg)'
- en: The app screenshot—custom validation in the React component prop
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序截图——React组件属性中的自定义验证
- en: 'We can add more validations in the property (name) as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在属性（名称）中添加更多的验证，如下所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Run the httpster from your app's root dir in order to see the output in your
    browser's `localhost:3333`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的应用程序根目录运行httpster，以便在你的浏览器中的 `localhost:3333` 看到输出
- en: 'The output of the following code is shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出如下所示：
- en: '![An example using custom validator](img/00043.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义验证器的示例](img/00043.jpeg)'
- en: The app screenshot—validation in React component prop
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序截图——React组件属性中的验证
- en: Thus, if we pass the name property with more than seven chars, there would be
    no error in the JS console, as expected.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们传递的名称属性超过七个字符，那么在预期的JS控制台中将不会有错误。
- en: The structure of component
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件的结构
- en: Now that we have explored quite a lot regarding ReactJS, there might be queries
    in your mind about how to architecture a react component or more broadly a react
    application as a whole. There are no ground rules that have been set, which is
    ideal while writing an application based on ReactJS. However, if we dig into the
    tutorials by the Facebook documentation team, hyperlink [https://facebook.github.io/react/docs/tutorial.html](https://facebook.github.io/react/docs/tutorial.html),
    we will be able to understand the underlying way they have used while writing
    such an app.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对ReactJS进行了相当多的探索，你心中可能会有关于如何架构一个React组件或更广泛地说是一个React应用程序的问题。还没有设定任何基本规则，这在基于ReactJS编写应用程序时是理想的。然而，如果我们深入研究Facebook文档团队提供的教程，超链接
    [https://facebook.github.io/react/docs/tutorial.html](https://facebook.github.io/react/docs/tutorial.html)，我们将能够理解他们在编写这样的应用程序时所使用的底层方式。
- en: 'Let''s explore first how a component is structured mostly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探索一下组件通常是如何结构的：
- en: The component `declaredData` is fetched from the server [if required].
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件 `declaredData` 是在需要时从服务器获取的 [如果需要]。
- en: The `propTypes` of the component are declared [used for validations].
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件的 `propTypes` 已声明 [用于验证]。
- en: Component lifecycle methods [`componentWillMount`, `componentDidMount`, `componentDidUpdate`,`componentWillUnmount`,
    and so on] are defined.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件生命周期方法 [`componentWillMount`、`componentDidMount`、`componentDidUpdate`、`componentWillUnmount`
    等等] 已定义。
- en: Within each of these lifecycle methods, the functions of these methods are either
    declared or called internally from another JS functions, defined explicitly for
    a particular task. It's to be remembered that the previously mentioned lifecycle
    methods are not necessary to use all at the same time/any in an application.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个生命周期方法中，这些方法的功能要么是声明的，要么是从另一个为特定任务明确定义的JS函数内部调用的。需要记住的是，之前提到的生命周期方法不是在应用程序中同时或任何情况下都必须使用。
- en: The render method, which has to be present within any react component. Thus,
    the way to structure any react-based application varies application-wise. Although
    there is no best way, but like any other application, it's advisable to compartmentalize
    the code in order to follow separation of concerns. We should separate the react
    views, components and data. One component directory can call other child component(s)
    as and when required, which thereby increases readability and testability of the
    code.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须存在于任何React组件中的渲染方法。因此，任何基于React的应用程序的结构方式因应用而异。尽管没有最佳方式，但像任何其他应用程序一样，建议将代码分块以遵循关注点分离。我们应该将React视图、组件和数据分开。一个组件目录可以根据需要调用其他子组件，从而提高代码的可读性和可测试性。
- en: React being an open source JavaScript library, there are various open source
    sites and developers who are working on this library each day in order to enhance
    and tweak the library, as required.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React是一个开源的JavaScript库，因此有各种开源网站和开发者每天都在为此库工作，以增强和调整库，以满足需求。
- en: For an application, using the ReactJS library, typically the views (React views)
    are separated as per their function (for example, home page, admin page, and product
    catalog). With each of the subfolder within the view, you can add the test.js
    file or you can keep all the test-related files under the same tests folder. In
    case you need some react views, which should be shared across other components,
    you can keep all those related files under the shared/lib folder.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个使用ReactJS库的应用程序，通常根据其功能将视图（React视图）分开（例如，主页、管理页面和产品目录）。在每个视图的子文件夹中，你可以添加test.js文件，或者你可以将所有与测试相关的文件放在同一个tests文件夹下。如果你需要一些应该跨其他组件共享的react视图，你可以将这些相关文件放在shared/lib文件夹下。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how we can develop reusable components in ReactJS
    (Mixins, before ES6 implementation). We also came to know about the higher order
    components, which are used later in the latter versions of ReactJS (from 0.13),
    which support ES6 and doesn't support Mixins. Validations are an integral part
    of any application, especially those using user input (that is, form inputs).
    We explored how ReactJS deals with validations and how we can use our custom validations
    as well. We got an overview how the react components are structured. In the following
    chapter, we will be dealing with the testing, in a React application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在ReactJS中开发可重用组件（在ES6实现之前，使用Mixins）。我们还了解了高阶组件，这些组件在ReactJS的后续版本（从0.13版开始）中被使用，支持ES6但不支持Mixins。验证是任何应用程序的一个基本组成部分，尤其是那些使用用户输入（即表单输入）的应用程序。我们探讨了ReactJS如何处理验证，以及我们如何使用自定义验证。我们还概述了react组件的结构。在下一章中，我们将处理React应用程序的测试。
