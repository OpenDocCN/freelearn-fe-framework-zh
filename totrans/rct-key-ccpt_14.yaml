- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Data with React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use React Router to fetch or send data without using `useEffect()` or `useState()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share data between different routes without using React’s context feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the UI based on the current data submission status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create page and action routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the user experience by deferring the loading of non-critical data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, you learned how to use React Router to load different
    components for different URL paths. This is an important feature as it allows
    you to build multipage websites while still using React.
  prefs: []
  type: TYPE_NORMAL
- en: Routing is a crucial feature for many web applications, and React Router is
    therefore a very important package. But just as most websites need routing, almost
    all websites need to fetch and manipulate data. For example, HTTP requests in
    most websites are sent to load data (such as a list of products or blog posts)
    or to mutate data (for example, to create a product or a blog post).
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 8* , *Handling Side Effects* , you learned that you can use the
    `useEffect()` Hook and various other React features to send HTTP requests from
    inside a React application. But if you’re using React Router, you get some new,
    even more powerful tools for working with data.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore which new features are made available by React Router
    and how they may be used to simplify the process of fetching or sending data.
  prefs: []
  type: TYPE_NORMAL
- en: Data Fetching and Routing Are Tightly Coupled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, most websites do need to fetch (or send) data, and
    most websites do need more than one page. But it’s important to realize that these
    two concepts are typically closely related.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a user visits a new page (such as `/posts` ), it’s likely that some
    data will need to be fetched. In the case of a `/posts` page, the required data
    is probably a list of blog posts that is retrieved from a backend server. The
    rendered React component (such as `Posts` ) must therefore send an HTTP request
    to the backend server, wait for the response, handle the response (as well as
    potential errors), and, ultimately, display the fetched data.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, not all pages need to fetch data. Landing pages, “About Us” pages,
    and “Terms & Use” pages probably don’t need to fetch data when a user visits them.
    Instead, data on those pages is likely to be static. It might even be included
    in the source code as it doesn’t change frequently.
  prefs: []
  type: TYPE_NORMAL
- en: But many pages do need to get data from a backend every time they’re loaded—for
    instance, “Products,” “News,” “Events,” or other infrequently updated pages like
    the “User Profile.”
  prefs: []
  type: TYPE_NORMAL
- en: And data fetching isn’t everything. Most websites also contain features that
    require data submission—be it a blog post that can be created or updated, product
    data that’s administered, or a user comment that can be added. Hence, sending
    data to a backend is also a very common use case.
  prefs: []
  type: TYPE_NORMAL
- en: And beyond requests, components might also need to interact with other browser
    APIs, such as `localStorage` . For example, user settings might need to be fetched
    from storage as a certain page loads.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, all these interactions happen on pages. But it might not be immediately
    obvious how tightly data fetching and submission are coupled to routing.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, data is fetched when a route becomes active, i.e., when a
    component (the page component) is rendered for the first time. Sure, users might
    also be able to click a button to refresh the data, but while this is optional,
    data fetching upon initial page load is almost always required.
  prefs: []
  type: TYPE_NORMAL
- en: And when it comes to sending data, there is also a close connection to routing.
    At first sight, it’s not clear how it’s related because, while it makes sense
    to fetch data upon page load, it’s less likely that you will need to send some
    data immediately (except perhaps tracking or analytics data).
  prefs: []
  type: TYPE_NORMAL
- en: But it’s very likely that *after* sending data, you will want to navigate to
    a different page, meaning that it’s actually the other way around, and instead
    of initiating data fetching as a page loads, you want to load a different page
    after sending some data. For example, after an administrator enters some product
    data and submits the form, they should typically be redirected to a different
    page (for example, from `/products/new` to the `/products` page).
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection between data fetching, submission, and routing can therefore
    be summarized by the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data fetching** often should be initiated when a route becomes active (if
    that page needs data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After **submitting data** , the user should often be redirected to another route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because these concepts are tightly coupled, React Router provides extra features
    that vastly simplify the process of working with data.
  prefs: []
  type: TYPE_NORMAL
- en: Sending HTTP Requests without React Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with data is not just about sending HTTP requests. As mentioned in the
    previous section, you may also need to store or retrieve data via `localStorage`
    or perform some other operation as a page gets loaded. But sending HTTP requests
    is an especially common scenario and will therefore be the main use case considered
    for the majority of this chapter. Nonetheless, it’s vital to keep in mind that
    what you learn in this chapter is not limited to sending HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see, React Router provides various features that help with sending
    HTTP requests (or using other data fetching and manipulation APIs), but you can
    also send HTTP requests (or interact with `localStorage` or other APIs) without
    these features. Indeed, *Chapter 8* , *Handling Side Effects* , already taught
    you how HTTP requests can be sent from inside React components with the help of
    `useEffect()` .
  prefs: []
  type: TYPE_NORMAL
- en: When using React Router’s data fetching capabilities, you can get rid of `useEffect()`
    and manual state management.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides jumping back in this book, you can also revisit how data fetching with
    `useEffect()` works via this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/01-data-fetching-classic](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/01-data-fetching-classic)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Loading Data with React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With React Router, fetching data can be simplified down to this, shorter, code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Believe it or not, it really *is* that much less code than in the examples shown
    in *Chapter 8* . Back then, when using `useEffect()` , separate state slices had
    to be managed to handle loading and error states as well as the received data.
    Though, to be fair, the content that should be displayed in case of an error is
    missing here. It’s in a separate file (which will be shown later), but it would
    only add three extra lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, you see a couple of new features that haven’t
    been covered yet in the book. The `loader()` function and the `useLoaderData()`
    Hook are added by React Router. These features, along with many others that will
    be explored throughout this chapter, are made available by the React Router package.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that library installed, you can set an extra `loader` prop on your route
    definitions. This prop accepts a function that will be executed by React Router
    whenever this route (or one of its child routes, if defined) is activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function can be used to perform any data fetching or other tasks required
    to successfully display the page component. The logic for getting that required
    data can therefore be extracted from the component and moved into a separate function.
  prefs: []
  type: TYPE_NORMAL
- en: Since many websites have dozens or even hundreds of routes, adding these loader
    functions inline in the route definition objects quickly leads to complex and
    confusing route definitions. For this reason, you will typically add (and export)
    the `loader()` function in the same file that contains the component that needs
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When setting up the route definitions, you can then import the component and
    its `loader` function and use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Assigning an alias ( `postsLoader` , in this example) to the imported `loader`
    function is optional but recommended since you most likely have multiple `loader`
    functions from different components, which would otherwise lead to name clashes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you don’t need to name your functions `loader` . You could use
    any name and assign them as values for the `loader` property in the route definition.
  prefs: []
  type: TYPE_NORMAL
- en: But using `loader` as a function name does not just follow the convention; it
    also has the advantage that React Router’s built-in lazy loading support (covered
    in the previous chapter) lazy-loads the `loader` function when needed. It fails
    to do that if you pick any other name.
  prefs: []
  type: TYPE_NORMAL
- en: With this `loader` defined, React Router will execute the `loader()` function
    whenever a route is activated. To be precise, the `loader()` function is called
    before the component function is executed (that is, before the component is rendered).
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: The Posts component is rendered after the loader is executed'
  prefs: []
  type: TYPE_NORMAL
- en: This also explains why the `Posts` component example at the beginning of this
    section contained no code that handled any loading state. There simply *is* no
    loading state since a component function is only executed after its loader has
    finished (and the data is available). React Router won’t finish the page transition
    until the `loader()` function has finished its job (though, as you will learn
    toward the end of this chapter, there is a way of changing this behavior).
  prefs: []
  type: TYPE_NORMAL
- en: The `loader()` function can perform any operation of your choice (such as sending
    an HTTP request, or reaching out to browser storage via the `localStorage` API).
    Inside that function, you should return the data that should be exposed to the
    component function. It’s also worth noting that the `loader()` function can return
    any kind of data. It may also return a `Promise` object that then resolves to
    any kind of data. In that case, React Router will automatically wait for the `Promise`
    to be fulfilled before executing the related route component function. The `loader()`
    function can thus perform both asynchronous and synchronous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that the `loader()` function, like all the other
    code that makes up your React app, executes on the client side (that is, in the
    browser of a website visitor). Therefore, you may perform any action that could
    be performed anywhere else (for example, inside `useEffect()` ) in your React
    app as well.
  prefs: []
  type: TYPE_NORMAL
- en: You must not try to run code that belongs to the server side. Directly reaching
    out to a database, writing to the file system, or performing any other server-side
    tasks will fail or introduce security risks, meaning that you might accidentally
    expose database credentials on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Access to Loaded Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, the component that belongs to a `loader` (that is, the component
    that’s part of the same route definition) needs the data returned by the `loader`
    . This is why React Router offers a new Hook for accessing that data: the `useLoaderData()`
    Hook.'
  prefs: []
  type: TYPE_NORMAL
- en: When called inside a component function, this Hook yields the data returned
    by the `loader` that belongs to the active route. If that returned data is a `Promise`
    , React Router (as mentioned earlier) will automatically wait for that `Promise`
    to resolve and provide the resolved data when `useLoaderData()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `loader()` function may also return an HTTP response object (or a `Promise`
    resolving to a `Response` ) object. This is the case in the preceding example
    because the `fetch()` function yields a `Promise` that resolves to an object of
    type `Response` . In that instance, React Router automatically extracts the response
    body and provides direct access to the data that was attached to the response
    (via `useLoaderData()` ).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a response should be returned, the returned object must adhere to the standard
    `Response` interface, as defined here: [https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Returning responses might be strange at first. After all, the `loader()` code
    is still executed inside the browser (not on a server). Therefore, technically,
    no request was sent, and no response should be required (since the entire code
    is executed in the same environment, that is, the browser).
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, you can but don’t have to return a response; you may return
    any kind of value. React Router just also supports responses as one possible return
    value type.
  prefs: []
  type: TYPE_NORMAL
- en: '`useLoaderData()` can be called in any component rendered by the currently
    active route component. That may be the route component itself ( `Posts` , in
    the preceding example), but it may also be any nested component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `useLoaderData()` can also be used in a `PostsList` component
    that’s included in the `Posts` component (which has a `loader` added to its route
    definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, the `Posts` component file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This means that `useLoaderData()` can be used in exactly the place where you
    need the data. The `loader()` function can also be defined wherever you want but
    it must be added to the route where the data is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the React Router version being used, you might get a warning related
    to “No HydrateFallback” element being provided. You can ignore this warning as
    it only matters when using server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also explore this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/02-data-fetching-react-router)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Loading Data for Dynamic Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most websites, it’s unlikely that static, pre-defined routes alone will
    be sufficient to meet your needs. For instance, if you created a blogging site
    with exclusively static routes, you would be limited to a simple list of blog
    posts on `/posts` . To add more details about a selected blog post on routes such
    as `/posts/1` or `/posts/2` (for posts with different `id` values) you would need
    to include dynamic routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, React Router also supports data fetching with the help of the `loader()`
    function for dynamic routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PostDetails` component and its `loader` function can be implemented like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If it looks very similar to the `Posts` component in the *Loading Data with
    React Router* section, that’s no coincidence. Because the `loader()` function
    works in exactly the same way, there is just one extra feature being used to get
    hold of the dynamic path segment value: a `params` object that’s made available
    by React Router.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also explore this code example on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/03-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/examples/03-dynamic-routes)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: When adding a `loader()` function to a route definition, React Router calls
    that function whenever the route becomes active, right before the component is
    rendered. When executing that function, React Router passes an object that contains
    extra information as an argument to `loader()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This object passed to `loader()` includes two main properties:'
  prefs: []
  type: TYPE_NORMAL
- en: A `request` property that contains an object with more details about the request
    that led to the route activation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `params` property that yields an object containing a key-value map of all
    dynamic route parameters for the active route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `request` object doesn’t matter for this example and will be discussed in
    the next section. But the `params` object contains an `id` property that carries
    the `id` value of the post for which the route is loaded. The property is named
    `id` because, in the route definition, `/posts/:id` was chosen as a path. If a
    different placeholder name had been chosen, a property with that name would have
    been available on `params` (for example, for `/posts/:postId` , this would be
    `params.postId` ). This behavior is similar to the `params` object yielded by
    `useParams()` , as explained in *Chapter 13* , *Multipage Apps with React Router*
    .
  prefs: []
  type: TYPE_NORMAL
- en: With the help of the `params` object and the post `id` , the appropriate post
    `id` can be included in the outgoing request URL (for the `fetch()` request),
    and hence the correct post data can be loaded from the backend API. Once the data
    arrives, React Router will render the `PostDetails` component and expose the loaded
    post via the `useLoaderData()` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders, Requests, and Client-Side Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding section, you learned about a `request` object being provided
    to the `loader()` function. Getting such a `request` object might be confusing
    because React Router is a client-side library—all the code executes in the browser,
    not on a server. Therefore, no request should reach the React app (as HTTP requests
    are sent from the client to the server, not between JavaScript functions on the
    client side).
  prefs: []
  type: TYPE_NORMAL
- en: And, indeed, there is no request being sent via HTTP. Instead, React Router
    creates a request object via the browser’s built-in `Request` interface to use
    it as a “data vehicle.” This request is not sent via HTTP, but it’s used as a
    value for the `request` property on the data object that is passed to your `loader()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the built-in `Request` interface, visit [https://developer.mozilla.org/en-US/docs/Web/API/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)
    .
  prefs: []
  type: TYPE_NORMAL
- en: This `request` object will be unnecessary in many `loader` functions, but there
    are occasional scenarios in which you can extract useful information from that
    object—information that might be needed in the `loader` to fetch the right data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use the `request` object and its `url` property to get
    access to any search parameters (query parameters) that may be included in the
    currently active page’s URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, the `request` value is used to get hold of a query parameter
    value that’s used in the React app URL. That value is then used in an outgoing
    request.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is vital that you keep in mind that the code inside your `loader()`
    function, just like all your other React code, always executes on the client side.
    If, instead, you want to execute code on a server (and, for example, fetch data
    on the server side), you need to use **server-side rendering** ( **SSR** ) or
    some React framework that implements SSR, like Next.js. SSR and Next.js will be
    covered in the next chapter, *Chapter 15* , *Server-side Rendering & Building
    Fullstack Apps with Next.js* , and the chapters thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts Revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router supports the concept of layout routes. These are routes that contain
    other routes and render those other routes as nested children. As you may recall,
    this concept was introduced in *Chapter 13* , *Multipage Apps with React Router*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Conveniently, layout routes can also be used for sharing data across nested
    routes. Consider this example website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: A website with a header, a sidebar, and some main content'
  prefs: []
  type: TYPE_NORMAL
- en: This website has a header with a navigation bar, a sidebar showing a list of
    available posts, and a main area that displays the currently selected blog post.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example includes two layout routes that are nested into each other:'
  prefs: []
  type: TYPE_NORMAL
- en: The root layout route, which includes the top navigation bar that is shared
    across all pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A posts layout route, which includes the sidebar and the main content of its
    child routes (for example, the details for a selected post)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The route definitions code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this setup, both the `<Posts />` and the `<PostDetails />` components are
    rendered next to the sidebar (since the sidebar is part of the `<PostsLayout />`
    element).
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part is that the `/posts` route (i.e., the layout route) loads
    the post data, as it has the `postsLoader` assigned to it, and so the `PostsLayout`
    component file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since layout routes are also regular routes, you can add `loader()` functions
    and use `useLoaderData()` just as you could in any other route. However, because
    layout routes are activated for multiple child routes, their data is also displayed
    for different routes. In the preceding example, the list of blog posts is always
    displayed on the left side of the screen, no matter if a user visits `/posts`
    or `/posts/10` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: The same layout and data are used for different child routes'
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, the layout and data used do not change as different child
    routes are activated. React Router also avoids unnecessary data re-fetching (for
    the blog posts list data) as you switch between child routes. It’s smart enough
    to realize that the surrounding layout hasn’t changed.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing Data across Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layout routes do not just help you share components and markup. They also allow
    you to load and share data across a layout route and its child routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `PostDetails` component (that is, the component that’s rendered
    for the `/posts/:id` route) needs the data for a single post, and that data can
    be retrieved via a `loader` attached to the `/posts/:id` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This example was discussed earlier in this chapter in the *Loading Data for
    Dynamic Routes* section. This approach is fine, but in some situations, this extra
    HTTP request can be avoided. For example, the following route configuration can
    be simplified, and the extra `postDetailsLoader` on the child route can be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `PostsLayout` route already fetches a list of all posts.
    That layout component is also active for the `PostDetails` route. In such a scenario,
    fetching a single post is unnecessary, since all the data has already been fetched
    for the list of posts. Of course, a specific `postDetailsLoader` loader for the
    `PostDetails` child route would be required if the request for the list of posts
    (by `postsLoader` on the `PostsLayout` route) didn’t yield all the data required
    by `PostDetails` .
  prefs: []
  type: TYPE_NORMAL
- en: But if all the data is available, React Router allows you to tap into the loader
    data of a parent route component via the `useRouteLoaderData()` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Hook can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`useRouteLoaderData()` requires a route identifier as an argument. It requires
    an identifier assigned to the ancestor route that contains the data that should
    be reused. You can assign such an identifier via the `id` property to your routes
    as part of the route definitions code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `useRouteLoaderData()` Hook then returns the same data `useLoaderData()`
    yields in that route to which you added the `id` . In this example, it would provide
    a list of blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PostDetails` , this Hook can therefore be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `useParams()` Hook is used to get access to the dynamic route parameter
    value, and the `find()` method is used on the list of posts to identify a single
    post with a fitting `id` property. In this example, you would thus avoid sending
    an unnecessary HTTP request by reusing data that’s already available.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the `postDetailsLoader` that was part of the `/posts/:id` route definition
    can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first example at the very beginning of this chapter (where the HTTP request
    was sent with the help of `useEffect()` ), the code did not just handle the success
    case but also possible errors. In all the React Router-based examples since then,
    error handling has been omitted. Error handling was not discussed up to this point
    because, while React Router plays an important role in error handling, it’s vital
    to first gain a solid understanding of how React Router works in general and how
    it helps with data fetching. But, of course, errors can’t always be avoided and
    definitely should not be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, handling errors is also very straightforward and easy when using
    React Router’s data capabilities. You can set an `errorElement` property on your
    route definitions and define the element that should be rendered when an error
    occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This `errorElement` property can be set on any route definition of your choice,
    or even multiple route definitions simultaneously. React Router will render the
    `errorElement` of the route closest to the place where the error was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding snippet, no matter which route produced an error, it would
    always be the root route’s `errorElement` that was displayed (since that’s the
    only route definition with an `errorElement` ). But if you also added an `errorElement`
    to the `/posts` route, and the `:id` route produced an error, it would be the
    `errorElement` of the `/posts` route that was shown on the screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This allows you, the developer, to set up fine-grained error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the component used as a value for the `errorElement` , you can get access
    to the error that was thrown via the `useRouteError()` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With this simple yet effective error-handling solution, React Router allows
    you to avoid managing error states yourself. Instead, you simply define a standard
    React element (via the `element` prop) that should be displayed when things go
    right and an `errorElement` to be displayed if things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Onward to Data Submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, you’ve learned a lot about data fetching. But as mentioned earlier
    in this chapter, React Router also helps with data submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This component renders a `<form>` element that allows users to enter the details
    for a new post. Due to the following route configuration, the component is displayed
    whenever the `/posts/new` route becomes active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Without React Router’s data-related features, you might handle form submission
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Just as before when fetching data, this requires quite a bit of code and logic
    to be added to the component function. You must manually extract the submitted
    data, send the HTTP request, and navigate to a different page after receiving
    an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you might also need to manage loading state and potential errors
    (excluded in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: Again, React Router offers some help. Where a `loader()` function can be added
    to handle data loading, an `action()` function can be defined to handle data submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the new `action()` function, the preceding example component looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code might be similar in length but it has the advantage of moving all
    the data submission logic out of the component function into a special `action()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the addition of the `action()` function, the example code snippet includes
    the following important changes and features:'
  prefs: []
  type: TYPE_NORMAL
- en: A `<Form>` component that’s used instead of `<form>` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `method` prop is set on the `<Form>` (to `"post"` ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The submitted data is extracted as `FormData` by calling `request.formData()`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user is redirected via a newly added `redirect()` function (instead of `useNavigate()`
    and `navigate()` ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what are these elements about?
  prefs: []
  type: TYPE_NORMAL
- en: Working with action() and Form Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like `loader()` , `action()` is a special function that can be added to
    route definitions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the `action` prop set on a route definition, the assigned function is automatically
    called whenever a `<Form>` (not `<form>` !) targeting this route is submitted.
    `Form` is a component provided by React Router that should be used instead of
    the default `<form>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `Form` uses the default `<form>` element but prevents the browser
    default of creating and sending an HTTP request upon form submission. Instead,
    React Router creates a `FormData` object and calls the `action()` function defined
    for the route that’s targeted by the `<Form>` , passing a request object, based
    on the built-in `Request` interface, to it. The passed request object contains
    the form data generated by React Router. Later in this chapter, in the *Controlling
    Which <Form> Triggers Which Action* section, you’ll learn how to control which
    `action()` function of which route will be executed by React Router.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Handling form submissions with the help of “actions” might sound familiar— *Chapter
    9* , *Handling User Input & Forms with Form Actions* , discussed a similar concept.
  prefs: []
  type: TYPE_NORMAL
- en: But whereas *Chapter 9* discussed a feature built into React (which was not
    related or dependent on routing), this chapter explores a core concept of React
    Router.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, you can use either approach for handling form submissions. Or you
    could use none of the two and instead handle the `submit` event manually via `onSubmit`
    .
  prefs: []
  type: TYPE_NORMAL
- en: But when using routing with React Router, you’ll often end up with cleaner,
    more concise code that integrates smoothly with other routing features like redirects
    when using React Router’s `<Form>` component and `action()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The form data object that is created by calling `request.formData()` includes
    all form input values entered into the submitted form. To be registered, an input
    element such as `<input>` , `<select>` , or `<textarea>` must have the `name`
    attribute assigned to it. The values set for those `name` attributes can later
    be used to extract the entered data.
  prefs: []
  type: TYPE_NORMAL
- en: The `request` object (that contains the form data) received by the `action()`
    function is created by React Router when the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: The `Form` component defines the HTTP method of the request object. By setting
    the `Form` 's `method` prop to either `"get"` (the default) or `"post"` , you
    control what happens when the form is submitted. When setting `method="get"` (or
    when not setting `method` at all), a regular URL navigation will occur—just as
    if a link to a certain path were clicked. Any entered form values will be encoded
    as URL search parameters in that case. To trigger an `action()` function, `<Form>`
    's `method` must be set to `"post"` instead.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important to understand that the request is not sent via HTTP
    since `action()` , just like `loader()` or the component function, still executes
    in the browser rather than on a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `action()` function then receives an object with a `request` property that
    contains the created request object with the included form data. This `request`
    object can be used to extract the values entered into the form input fields like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The built-in `formData()` method yields a `Promise` that resolves to a `FormData`
    object that offers a `get()` method that can be used to get an entered value by
    its identifier (that is, by the `name` attribute value set on the input element).
    For example, the value entered into `<input name="title">` could be retrieved
    via `formData.get('title')` .
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can follow the approach chosen in the preceding code snippet
    and convert the `formData` object to a simple key-value object via `Object.fromEntries(formData)`
    . This object ( `postData` , in the preceding example) contains the names set
    on the form input elements as properties and the entered values as values for
    those properties (meaning that `postData.title` would yield the value entered
    in `<input name="title">` ).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: React Router also supports the other main HTTP verbs ( `"patch"` , `"put"` ,
    and `"delete"` ), and setting `method` to one of these verbs will indeed also
    trigger the `action()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful when working with multiple forms that should trigger the
    same `action()` . By using different methods, you can use one single action to
    run different code based on the value extracted from `request.method` inside the
    `action()` function.
  prefs: []
  type: TYPE_NORMAL
- en: But it’s worth noting that using methods other than `'get'` and `'post'` is
    not in line with the HTML standard. Therefore, React Router could remove support
    for these methods in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, when working with multiple forms that trigger the same `action()` , a
    more stable solution can be to include a hidden input field with a unique identifier
    (e.g., `<input type="hidden" name="_method" value="DELETE">` ). This value can
    then be extracted and used (e.g., in an `if` statement) in the `action()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extracted data can then be used for any operations of your choice. That
    could be an extra validation step or an HTTP request sent to some backend API,
    where the data may get stored in a database or file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, once all intended steps are performed, the `action()` function must
    return a value—any value of any type, but at least `null` . Not returning anything
    (i.e., omitting the `return` statement) is not allowed. Though, as with the `loader()`
    function, you may also return a response, for example, a redirect response like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, for actions, it’s highly likely that you will want to navigate to a
    different page once the action has been performed (e.g., once an HTTP request
    to an API has been sent). This may be required to navigate the user away from
    the data input page to a page that displays all available data entries (for example,
    from `/posts/new` to `/posts` ).
  prefs: []
  type: TYPE_NORMAL
- en: To simplify this common pattern, React Router provides a `redirect()` function
    that yields a response object that causes React Router to switch to a different
    route. You can therefore return the result of calling `redirect()` in your `action()`
    function to ensure that the user is navigated to a different page. It’s the equivalent
    of calling `navigate()` (via `useNavigate()` ) when manually handling form submissions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, React Router’s `redirect()` function is used instead of manually
    constructing a `Response` object.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Data Instead of Redirecting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, your `action()` functions may return anything. You don’t have
    to return a response object. While it is quite common to return a redirect response,
    you may occasionally want to return some raw data instead.
  prefs: []
  type: TYPE_NORMAL
- en: One scenario in which you might *not* want to redirect the user is after validating
    the user’s input. Inside the `action()` function, before sending the entered data
    to some API, you may wish to validate the provided values first. If an invalid
    value (such as an empty title) is detected, a great user experience is typically
    achieved by keeping the user on the route with the `<Form>` . The values entered
    by the user shouldn’t be cleared and lost; instead, the form should be updated
    to present useful validation error information to the user. This information can
    be passed from the `action()` to the component function so that it can be displayed
    there (for example, next to the form input fields).
  prefs: []
  type: TYPE_NORMAL
- en: 'In situations like this, you can return a “normal” value (that is, not a redirect
    response) from your `action()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a `validationErrors` array is returned if the entered `title`
    or `text` values are empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data returned by an `action()` function can be used in the route component
    (or any other nested component) via the `useActionData()` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`useActionData()` works a lot like `useLoaderData()` , but unlike `useLoaderData()`
    , it’s not guaranteed to yield any data. This is because while `loader()` functions
    always get called before the route component is rendered, the `action()` function
    only gets called once the `<Form>` is submitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `useActionData()` is used to get access to the `validationErrors`
    returned by `action()` . If `validationErrors` is truthy (that is, is not `undefined`
    ), the array will be mapped to a list of error items that are displayed to the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Validation errors are output below the input fields'
  prefs: []
  type: TYPE_NORMAL
- en: The `action()` function is therefore quite versatile in that you can use it
    to perform an action and redirect away as well as to conduct more than one operation
    and return different values for different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Which <Form> Triggers Which Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, in the section *Working with action() and Form Data*
    , you learned that when `<Form>` is used instead of `<form>` , React Router will
    execute the targeted `action()` function. But which `action()` function is targeted
    by `<Form>` ?
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, it’s the `action()` function assigned to the route that also renders
    the form (either directly or via some descendent component). Consider this route
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this definition, the `newPostAction()` function would be triggered whenever
    any `<Form>` inside of the `NewPost` component (or any nested component) is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, this default behavior is exactly what you want. But you can
    also target `action()` functions defined on other routes by setting the `action`
    prop on `<Form>` to the path of the route that contains the `action()` that should
    be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This form would cause React Router to execute the `action` belonging to the
    `/save-data` route—even though the `<Form>` component may be rendered as part
    of a component that belongs to a different route (e.g., `/posts` ).
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting, though, that targeting a different route will lead to a
    page transition to that route’s path, even if your action does not return a redirect
    response. In a later section of this chapter, entitled *Behind-the-Scenes Data
    Fetching and Submission* , you will learn how that behavior can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting the Current Navigation Status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After submitting a form, the `action()` function that’s triggered may need some
    time to perform all intended operations. Sending HTTP requests to APIs in particular
    can take up to a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it’s not a great user experience if the user doesn’t get any feedback
    about the current data submission status. It’s not immediately clear if anything
    happened at all after the submit button was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, you might want to show a loading spinner or update the button
    caption while the `action()` function is running. Indeed, one common way of providing
    user feedback is to disable the submit button and change its caption like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: The submit button is grayed out'
  prefs: []
  type: TYPE_NORMAL
- en: You can get the current React Router status (that is, whether it’s currently
    transitioning to another route or executing an `action()` function) via the `useNavigation()`
    Hook. This Hook provides a navigation object that contains various pieces of routing-related
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most importantly, this object has a `state` property that yields a string describing
    the current navigation status. This property is set to one of the following three
    possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`submitting` : If an `action()` function is currently executing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loading` : If a `loader()` function is currently executing (for example, because
    of a `redirect()` response)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idle` : If no `action()` or `loader()` functions are currently being executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can therefore use this `state` property to find out whether React Router
    is currently navigating to a different page or executing an `action()` . Hence,
    the submit button can be updated as shown in the preceding screenshot via this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `isSubmitting` constant is `true` if the current navigation
    state is anything but `'idle'` . This constant is then used to disable the submit
    button (via the `disabled` attribute) and adjust the button’s caption.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting Forms Programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, you won’t want to instantly trigger an `action()` when a form
    is submitted—for example, if you need to ask the user for confirmation first such
    as when triggering actions that delete or update data.
  prefs: []
  type: TYPE_NORMAL
- en: For such scenarios, React Router allows you to submit a form (and therefore
    trigger an `action()` function) programmatically. Instead of using the `Form`
    component provided by React Router, you handle the form submission manually using
    the default `<form>` element. As part of your code, you can then use a `submit()`
    function provided by React Router’s `useSubmit()` Hook to trigger the `action()`
    manually once you’re ready for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `action()` is manually triggered by programmatically submitting
    data via the `submit()` function provided by `useSubmit()` . This approach is
    required as it would otherwise be impossible to ask the user for confirmation
    (via the browser’s `window.confirm()` method).
  prefs: []
  type: TYPE_NORMAL
- en: Because data is submitted programmatically, the default `<form>` element should
    be used and the `submit` event handled manually. As part of this process, the
    browser’s default behavior of sending an HTTP request must also be prevented manually.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, using `<Form>` instead of programmatic submission is preferable.
    But in certain situations, such as the preceding example, being able to control
    form submission manually can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Behind-the-Scenes Data Fetching and Submission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also situations in which you may need to trigger an action or load
    data without causing a page transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Like button would be an example. When it’s clicked, a process should be triggered
    in the background (such as storing information about the user and the liked post),
    but the user should not be directed to a different page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: A Like button below a post'
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this behavior, you could wrap the button into a `<Form>` and, at
    the end of the `action()` function, simply redirect back to the page that is already
    active.
  prefs: []
  type: TYPE_NORMAL
- en: But technically, this would still lead to an extra navigation action. Therefore,
    `loader()` functions would be executed and other possible side-effects might occur
    (the current scroll position could be lost, for example). For that reason, you
    might want to avoid this kind of behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, React Router offers a solution: the `useFetcher()` Hook, which
    yields an object that contains a `submit()` method. Unlike the `submit()` function
    provided by `useSubmit()` , the `submit()` method yielded by `useFetcher()` is
    meant for triggering actions (or `loader()` functions) without starting a page
    transition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Like button, as described previously, can be implemented like this (with
    the help of `useFetcher()` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `fetcher` object returned by `useFetcher()` has various properties. For
    example, it also contains properties that provide information about the current
    status of the triggered action or loader (including any data that may have been
    returned).
  prefs: []
  type: TYPE_NORMAL
- en: 'But this object also includes two important methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`load()` : To trigger the `loader()` function of a route (e.g., `fetcher.load(''/route-path'')`
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit()` : To trigger an `action()` function with the provided data and configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the code snippet above, the `submit()` method is called to trigger the action
    defined on the `/posts/<post-id>/like` route. Without `useFetcher()` (i.e., when
    using `useSubmit()` or `<Form>` ), React Router would switch to the selected route
    path when triggering its action. With `useFetcher()` , this is avoided, and the
    action of that route can be called from inside another route (meaning the action
    defined for `/posts/<post-id>/like` is called while the `/posts/<post-id>` route
    is active).
  prefs: []
  type: TYPE_NORMAL
- en: 'This also allows you to define routes that don’t render any element (that is,
    in which there is no page component) and, instead, only contain a `loader()` or
    `action()` function. For example, the `/posts/<post-id>/like` route file ( `pages/like.js`
    ) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the code snippet, any data may be returned in this action. But
    you must at least return `null` —avoiding the `return` statement and not returning
    anything is not allowed and will cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s registered as a route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because this `action()` is only triggered via the `submit()` method
    provided by `useFetcher()` . `<Form>` and the `submit()` function yielded by `useSubmit()`
    would instead initiate a route transition to `/posts/<post-id>/like` . Without
    the `element` property being set on the route definition, this transition would
    lead to an empty page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: An empty (nested) page is displayed, along with a warning message'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the extra flexibility it offers, `useFetcher()` can be very useful
    when building highly interactive user interfaces. It’s not meant as a replacement
    for `useSubmit()` or `<Form>` , but rather, as an additional tool for situations
    where no route transition is required or wanted.
  prefs: []
  type: TYPE_NORMAL
- en: Deferring Data Loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point in the chapter, all data fetching examples have assumed that
    a page should only be displayed once all its data has been fetched. That’s why
    there was never any loading state that would have been managed (and hence no loading
    fallback content that would have been displayed).
  prefs: []
  type: TYPE_NORMAL
- en: In many situations, this is exactly the behavior you want as it does not often
    make sense to show a loading spinner or similar fallback content for a fraction
    of a second just to then replace it with the actual page data.
  prefs: []
  type: TYPE_NORMAL
- en: But there are also situations in which the opposite behavior might be desirable—for
    example, if you know that a certain page will take quite a while to load its data
    (possibly due to a complex database query that must be executed on the backend)
    or if you have a page that loads different pieces of data and some pieces are
    much slower than others.
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, it may make sense to render the page component even though
    some data is still missing. React Router also supports this use case by allowing
    you to defer data loading, which, in turn, enables the page component to be rendered
    before the data is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deferring data loading is as simple as returning a promise from the loader
    (instead of awaiting it there):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `getPosts()` is a function that returns a (slow) `Promise`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: React Router allows you to return raw promises. When doing so, you can wait
    for the actual values yielded by those promises in the client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the component function where `useLoaderData()` is used, you must also
    use a new component provided by React Router: the `Await` component. It’s used
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `<Await>` element takes a `resolve` prop that receives a value of type `Promise`
    from the loader data. It’s wrapped by the `<Suspense>` component provided by React.
  prefs: []
  type: TYPE_NORMAL
- en: The value passed to resolve is a `Promise` that was stored in the object returned
    by the `loader()` function. There, a key named posts was used to hold that `Promise`
    . The value for that key was the `Promise` returned by `getPosts()` . It’s this
    `Promise` that’s passed as a value to `resolve` via `<Await resolve={data.posts}>`
    . If a different key name were used (e.g., `blogPosts` ), that key name had to
    be referenced when setting `resolve` (e.g., `<Await resolve={data.blogPosts}>`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '`Await` automatically waits for the `Promise` to resolve before then calling
    the function that’s passed to `<Await>` as a child (that is, the function passed
    between the `<Await>` opening and closing tags). This function is executed by
    React Router once the data of the deferred operation is available. Therefore,
    inside that function, `loadedPosts` is received as a parameter, and the final
    user interface elements can be rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Suspense` component that’s used as a wrapper around `<Await>` defines some
    fallback content that is rendered as long as the deferred data is not yet available.
    In *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , the `Suspense` component was used to show some fallback content until the missing
    code was downloaded. Now, it’s used to bridge the time until the required data
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 14.8* , when returning a `Promise` (and using `<Await>`
    ) like this, other parts of the website, that are not loaded via `<Await>` , are
    already rendered and displayed while waiting for the posts data.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Post details are already visible while the list of posts is loading'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another big advantage of returning a `Promise` and awaiting it in the client-side
    code is that you can easily combine multiple fetching processes and control which
    processes should be deferred and which ones should not. For example, a route might
    be fetching different pieces of data. If only one process tends to be slow, you
    could defer only the slow one like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `getUserData()` is not deferred because the `await` keyword
    is added in front of it. Therefore, JavaScript waits for that `Promise` (the `Promise`
    returned by `getUserData()` ) to resolve before returning from `loader()` . Hence,
    the route component is rendered once `getUserData()` finishes but before `getPosts()`
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router can help you with data fetching and submission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can register `loader()` functions for your routes, causing data fetching
    to be initialized as a route becomes active.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader()` functions return data (or responses, wrapping data) that can be
    accessed via `useLoaderData()` in your component functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader()` data can be used across components via `useRouteLoaderData()` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also register `action()` functions on your routes that are triggered
    upon form submissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To trigger `action()` functions, you must use React Router’s `<Form>` component
    or submit data programmatically via `useSubmit()` or `useFetcher()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useFetcher()` can be used to load or submit data without initiating a route
    transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When fetching slow data, you can return promises without awaiting them in the
    `loader()` to defer loading some or all of a route’s data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fetching and submitting data are extremely common tasks, especially when building
    more complex React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, those tasks are closely connected to route transitions, and React
    Router is the perfect tool for handling this kind of operation. That’s why the
    React Router package offers powerful data management capabilities that vastly
    simplify these processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how React Router assists you with fetching or submitting
    data and which advanced features help you handle both basic and more complex data
    manipulation scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this chapter concludes the list of core React Router features you
    need to know.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapters will explore React’s server-side capabilities and how you
    may build fullstack applications with React, load data on a server, and use the
    Next.js framework.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to the examples found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/exercises/questions-answers.md)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: How are data fetching and submission related to routing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the purpose of `loader()` functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the purpose of `action()` functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between `<Form>` and `<form>` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between `useSubmit()` and `useFetcher()` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the idea behind returning promises instead of awaiting them in a `loader()`
    ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apply your knowledge about routing, combined with data manipulation, to the
    following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.1: A To-Dos App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, your task is to create a basic to-do list web app that allows
    users to manage their daily to-do tasks. The finished page must allow users to
    add to-do items, update to-do items, delete to-do items, and view a list of to-do
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following paths must be supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/` : The main page, responsible for loading and displaying a list of to-do
    items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/new` : A page, opened as a modal above the main page, allowing users to add
    a new to-do item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/:id` : A page, also opened as a modal above the main page, allowing users
    to update or delete a selected to-do item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no to-do items exist yet, a fitting info message should be shown on the `/`
    page. If users try to visit `/:id` with an invalid to-do ID, an error modal should
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For this activity, there is no backend API you could use. Instead, use `localStorage`
    to manage the to-do data. Keep in mind that the `loader()` and `action()` functions
    are executed on the client side and can therefore use any browser APIs, including
    `localStorage` .
  prefs: []
  type: TYPE_NORMAL
- en: You will find example implementations for adding, updating, deleting, and getting
    to-do items from `localStorage` at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/data/todos.js](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/data/todos.js)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Also, don’t be confused by the pages that open as modals above other pages.
    Ultimately, these are simply nested pages, styled as modal overlays. In case you
    get stuck, you can use the example `Modal` wrapper component found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/components/Modal.jsx](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/components/Modal.jsx)
    .
  prefs: []
  type: TYPE_NORMAL
- en: For this activity, you can write all CSS styles on your own if you so choose.
    But if you want to focus on the React and JavaScript logic, you can also use the
    finished CSS file from the solution at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/index.css](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/14-routing-data/activities/practice-1/src/index.css)
    .
  prefs: []
  type: TYPE_NORMAL
- en: If you use that file, explore it carefully to ensure you understand which IDs
    or CSS classes might need to be added to certain JSX elements of your solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the activity, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new React project and install the React Router package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create components (with the content shown in the screenshots below) that will
    be loaded for the three required pages. Also, add links (or programmatic navigation)
    between these pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable routing and add the route definitions for the three pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `loader()` functions to load (and use) all the data needed by the individual
    pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `action()` functions for adding, updating, and deleting to-dos.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Hint:* If you need to submit multiple forms for different actions from the
    same page, you could include a hidden input field that sets some value you can
    check for in your `action()` function, e.g., `<input type="hidden" name="_method"
    value="DELETE">` . Alternatively, you can also set `<Form method="delete">` (or
    set it to `"patch"` , `"put"` , or other HTTP verbs) and check for `request.method`
    in your `action()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Add error handling in case data loading or saving fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The finished pages should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: The main page displaying a list of to-dos'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: The /new page, opened as a modal, allowing users to add a new
    to-do'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: The /:id page, also opened as a modal, allowing users to edit
    or delete a to-do'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_14_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: An info message, displayed if no to-dos were found'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The full code, and solution, to this activity can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/14-routing-data/activities/practice-1)
    .
  prefs: []
  type: TYPE_NORMAL
