- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and Source Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The success of our application depends on many factors, beyond the quality of
    our code organization or patterns. Moreover, the very nature of software implies
    that there will be changes during and after development, changes in the requirements,
    the scope, and so on. With each feature developed, an item of complexity is introduced
    into the software, creating relationships and dependencies. New inclusions may
    disrupt these connections and introduce breaking changes, bugs, or even completely
    disable the system. The solution for this problem is to keep track of code changes
    and conduct tests on the application to identify problems and ensure as much as
    possible that the system complies with the desired software attributes and satisfies
    the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Different approaches to testing and the concept of **test-driven** **development
    (TDD)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a test suite (Vitest) and test tools (Vue Test Utils) for our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and running tests on an existing project for synchronous and asynchronous
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing our components by simulating user interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and managing our source code using Git and online repositories such
    as GitHub or GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concepts in this chapter are introductions to important professional skills
    for a developer to ensure the delivery of good-quality software. Often, these
    tasks are left aside or relegated as an afterthought. However, the lack of them
    may lead to expensive mistakes and lengthy overwork as the software complexity
    grows. For non-trivial applications with more than one developer involved, nowadays,
    it is hardly possible to conceive a project that does not use some of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on **unit testing** and the tools provided by
    the Vue team to perform it.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not have additional requirements to those of previous implementations
    of code examples. The final source code can be found in the official repository
    for this book at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://packt.link/UqRIi](https://packt.link/UqRIi)'
  prefs: []
  type: TYPE_NORMAL
- en: What are testing and TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is the process to verify that the software is doing what it is supposed
    to do, according to the requirements of the project. It involves the manual or
    automated execution of tools to evaluate and measure different properties and
    attributes of the software, identify errors and bugs, and provide feedback for
    developers to take action to correct them. There are many different approaches
    and types of tests to be performed, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: This is where relevant units of the source code are validated
    against a series of inputs and outputs. It is often automated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: All the components of a system are verified together
    as a group, looking for errors and bugs in the resulting integration, communication,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end testing**: This involves a complete validation of the application
    simulating real-world use, interacting with databases, network scenarios, and
    so on. It can be performed with automated tools that simulate human interaction,
    and manual testing using real-life users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types of testing are just a small sample of this discipline, as there
    are hundreds of possible tests to apply to the software. Large companies may have
    entire testing teams dedicated to ensuring the quality of the software. Usually,
    the more complex the software, the more complex the testing may be. In practice,
    the testing plan can be as complex as the development plan itself. As mentioned
    in the introduction, we will focus on the official tools provided by the Vue team
    for this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing can be done before, during, after, or in parallel with the development.
    **TDD** is a discipline that places the burden of testing as early in the project
    as possible, even before the actual coding begins, with the objective to match
    the requirements. It involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test case, based on the requirements and design of the application,
    with key inputs and expected outputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test, which should fail (as there is no code written yet).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the actual code to be tested (a function, Vue component, etc.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test against the created code. If it fails, refactor the code or design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start again with a new test case for the next unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process is repeated, and it is expected to provide developers with a significant
    reduction of “bugs” and errors and help them focus on the requirements. This does
    incur an overhead of effort early in the project, as opposed to refactoring, when
    the tests are performed toward the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD has become popular in some teams and with some frameworks, and it is supposed
    to help developers improve their own code as they now acquire a “testing” mindset.
    However, there are no specific studies made to confirm this, but practitioners
    of this discipline do report that it has improved their code and design. This,
    of course, begs the question: what needs to be tested, and how can we streamline
    the task into our workflow? That is the topic we will discuss next.'
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key factor in the success of a good testing plan and implementation is deciding
    what to test. It is not possible to test the full universe of possibilities or
    100% of the components and interactions in a project when considering internal
    and external factors. Even the attempt to fully cover all possibilities would
    be incredibly expensive and practically impossible. Instead, the focus needs to
    be on the real possibilities of what can be tested within our time and budget
    constraints, by carefully selecting the non-trivial elements that “make or break”
    our project requirements. This is often not an easy task.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to Vue applications, we need to focus on crucial services and
    components that perform key operations. We need to test the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Services**: Self-contained functions, both synchronous and asynchronous.
    Functions that don’t return a value but perform logical procedures will serve
    a different kind of testing than what we will see here. These will involve mocking
    network communications or database calls, application policies, and so on. However,
    the principles for testing these are similar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components**: We need to test inputs (props) and outputs (events and HTML).
    Higher-level components that group other components to perform a workflow or business
    logic can also be tested in the same way (props, events, and HTML rendered). However,
    these also will need other types of testing, such as end-to-end testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write our own functions and tools to perform tests, but apart from some
    edge cases, the obvious recommendation is to use stable test suites and tools.
    In our case, for Vue, there are official resources provided by the same team,
    called **Vitest** and **Vue Test Utils**. Using a testing suite/library has many
    benefits, akin to the use of a framework or library in the “regular” development
    of an application. Perhaps one of the major benefits has to do with **DX**, or
    **Developer eXperience**, as they streamline and make the development process
    easier or lighter in the best case. Let’s learn how to apply these tools in our
    workflow by going through an example application, which we will address in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Our base example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is best to understand the discipline of testing and learn about the tools
    by applying them to a real project through practice. As a learning exercise, we
    will first take a running application based on one of the examples presented in
    [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and
    Patterns*. We will build a **Fibonacci calculator** and install the Vitest test
    suite and Vue Testing Utils to the project. Later, we will explain what would
    change in this approach when applying the TDD discipline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this application can be found in the repository for this chapter.
    Once downloaded, you need to execute the following command to install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to run the application, you must run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is ready, loading the site in your web browser should present
    you with an application like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The example application with a Fibonacci calculator](img/Figure_9.01_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The example application with a Fibonacci calculator
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of this application has been made with the purpose of learning the
    basics of testing functions and components, so it is very basic but sufficient.
    We are presented with one service file (`/src/services/Fibonacci.js`) and three
    components: `App.vue`, `FibonacciInput.vue`, and `FibonacciOutput.vue`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Components and service for the application](img/Figure_9.02_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Components and service for the application
  prefs: []
  type: TYPE_NORMAL
- en: Our application-level component, `App.vue`, receives from `FibonacciInput.vue`
    a positive integer number through an event, which passes as a prop input to `FibonacciOutput.vue`.
    This component uses the `Fibonacci.js` service to calculate the respective Fibonacci
    number corresponding in the series and present it to the user. As simple as this
    application sounds, it gives us basic examples to create tests for the most common
    cases, which will give us a solid start. It is now time to install our test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and use of Vitest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`/src/__tests__` folder, some examples, and a few extra entries in our `package.json`
    file. But all this boilerplate can be a bit confusing unless we have previous
    experience in this area. Instead, we start from an already created project, so
    we will install Vitest as a development dependency – a task that will give us
    an insight into how it works and is organized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Vitest from the command line at the root directory of the project with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The package manager will take some time to include Vitest and all necessary
    dependencies but won’t modify our source code or organization. For convenience,
    we will use `npm` as well to run our tests, so we need to open our `package.json`
    file, and in the `scripts` section, enter the following lines so the section looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can now test our test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After you run that command, you will be graciously greeted with a red message
    explaining that the tests have failed. Perfect. This is what it should do, as
    we do not have any tests yet! So, let’s add them. We will start by testing our
    `Fibonacci.js` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vitest allows us to write our test functions in independent files or in-source,
    meaning that we place them alongside our component’s JavaScript. There are benefits
    and trade-offs with both approaches, but to start, we will place our test code
    in independent files, one for each service and component. In this way, we place
    these files in their own directory, which by convention can be either `/src/tests`
    or `/src/components/__tests__`, but they could also be placed alongside the Single
    File Components or with the services. Vitest will scan the entire source folder
    for the test files. Even though we can be very creative when placing these files,
    we will place them in `/src/test` to keep things neat and tidy. There is another
    convention to adhere to, which is that each test file must have the same name
    as the file being tested, plus the `.spec.js` or `.test.js` extension. Vitest
    uses this convention to identify and run the tests in an organized manner. So,
    in our case, our `Fibonacci.js` service will have its testing counterpart in `/src/tests/Fibonacci.test.js`.
    Go ahead and create that file, and enter the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/tests/Fibonacci.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we import three functions from Vitest, which are the foundation
    of all our testing, and the ones that we will be using most often. Here is what
    each one does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`describe(String, Function)`: This function groups together a number of tests,
    and Vitest will report the test group by using the description given as the first
    parameter. The second parameter is a function, where we will run the tests with
    the `test()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test(String, Function)`: The first parameter is a description of the tests
    encompassed in the second parameter, which is a function. The test will “pass”
    if no errors are thrown within it. This means that we can write our own test logic
    and tools following this condition and throw a JavaScript error when the validation
    fails. However, there is a simpler approach...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(value)`: This is the function that performs the “magic” of testing.
    It receives, as a unique argument, a single value or a function that resolves
    to a single value. The result of `expect()` is a chainable object that exposes
    many different and almost language-natural assertions (comparisons, validations,
    etc.) to perform on the argument value. Under the hood, it uses the Chia syntax
    to a certain extent and is also compatible with other test suites, such as Jest
    – for example, `expect(2).toBe(2)`. A full list of all the possible assertion
    methods can be found in the official documentation here: [https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second line of the test file, we directly import the two functions contained
    in the service: `Fibonacci()` and `FibonacciPromise()`. We need to import each
    function that we want to test, and then create as many test groups as necessary
    for each one. Let’s start with the self-contained `Fibonacci()` function by adding
    the following test group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a test group with `describe()` and create inside the passed
    function as many tests as needed. Inside each `test()` function, we can create
    as many assertions as needed, but it has to have at least one. Notice how we are
    executing the function from the service with different arguments, and then asserting
    them to the expected value as defined in the numerical series. In this case, we
    are using `.toBe()` to test equality, but in the same way, we could be testing
    strings, objects, types, and so on, using other assertions, such as `.not, .toEqual,
    .toBeGreaterThan`, etc. There are more than 50 assertion methods defined in the
    documentation ([https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html)).
    Take some time to review them, and remember that these are chainable, so you can
    make more than one assertion at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving this file, you can run the test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should receive a few messages in green, indicating the number of tests performed
    and whether they passed or not. In the case that one raises an error, it will
    be pointed out in red letters using the descriptive text and line where it occurred.
    That is a sign to start refactoring the code (assuming the test function and assertion
    were properly and correctly written; otherwise, you get a false positive!).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case that no assertion method works for a particular edge case, you
    can create inside `test()` your own logic in plain JavaScript and throw an error
    when the validation fails. For example, these two code snippets are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Even though this example is trivial, it is easy to see how the first case, using
    `expect()`, results in a better developer experience, as it is succinct, elegant,
    and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: Vitest is still running!
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you have noticed that running `npm run test` does not end the execution
    of the script once the tests have terminated. Just like with a developer server,
    Vitest keeps waiting for changes to occur to the source code or test files and
    automatically reruns all the tests for you. If you want to run the tests only
    once, use `npm run test:once` or `vitest –-run` to flag Vitest to run the tests
    only once and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: Special assertion case – fail on purpose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the previous assertions thus far have been made using the “positive” approach
    that a function will return what is expected. Using the “negative” approach in
    testing is to make sure that a function will fail when it is supposed to. For
    example, the Fibonacci series is not defined for negative numbers, so any calculation
    should not return a value but should throw an error. In these cases, we need to
    wrap the execution of the function in another function, thus encapsulating it
    to test the assertion against a thrown error. This would be the equivalent of
    using a `try..catch` block in plain JavaScript to avoid terminating the execution
    of the script when an error occurs. For example, executing `Fibonacci(-5)` should
    throw an error, so we will write our test case as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding assertion will work as expected, without interrupting the testing
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Special assertion case – asynchronous code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another special case to keep in mind is asynchronous code, such as network
    calls, promises, and so on. In this case, the solution is to use `async..await`,
    not on the function but on `expect`. For example, to test the `FibonacciPromise()`
    asynchronous function, we would write a test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are applying the `async` syntax to the entire test function, and
    `await` to the `expect()` function. We also need to use the `.resolves` assertion
    to indicate the successful resolution for the value to validate. If we needed
    to test a `Promise` rejection, we would use `.rejects` instead of `.resolves`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have covered the majority of tools and test approaches to get
    us started in unit-testing our plain JavaScript functions. However, all these
    tests are executed using **Node.js** (the server version of JavaScript), not on
    the browser where our Vue components will be executed. In Node.js, there is no
    **DOM** or **Windows** object, so we don’t have any HTML... so how do we test
    our **Single File Components**?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to provide Vitest with a simulated DOM where we can mount our
    components and run tests as if it were a browser window. Here is where the Vue
    Test Utils tools come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Vue Test Utils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of now, Vitest provides us, out of the box, with tools to test plain JavaScript
    functions, classes, events, and so on. To test our Single File Components, we
    need additional resources, and these are provided to us again by the official
    Vue team in the form of **Vue Test Utils** ([https://test-utils.vuejs.org/](https://test-utils.vuejs.org/)).
    To install them, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation has completed, we need to update our `vite.config.js`
    file to include the environment where the components will be tested, meaning a
    browser context. Modify the configuration file so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Vitest and Vue Test Utils both integrate seamlessly with Vite, to the point
    that they share the same configuration file. You can now run the test suite, and
    Vitest will attempt to download and install any missing dependencies on the first
    run after these modifications. If for some reason the installation of `jsdom`
    does not happen automatically, you can install it manually with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with these changes, we are ready to start our first component tests. Let’s
    start creating a file to test our `FibonacciOutput.vue` component, as it is the
    simplest, we have in our application. Create the following file in the test directory
    with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/tests/FibonacciOutput.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is not that different from a basic unit test as we have done
    before, but it does some things a bit differently. In line `#1`, we import a function
    from the Vue Test Utils library that allows us to “mount” our component in a test
    environment simulating a browser window with Vue 3\. In line `#2`, we import our
    component in the usual way, and then proceed to write our test group as before.
    The difference here is in line `#3`. We use the `mount` function to create our
    live component by passing it as the first argument and, as the second, we pass
    an object with properties that will be applied to the component. In this case,
    we are passing the `number` prop with a value of `10`. The `mount` function will
    return a wrapper object representing our component, exposing an API that we access
    to perform our assertions. In this case, in line `#4`, we are checking that the
    plain text rendered by the component contains the value 55, which we will find
    to be true when the test is run. It is by using this wrapper object that we can
    access the component properties, events, slots, and rendered HTML by accessing
    the proper methods. We will only discuss a few in this chapter, but a full list
    is available in the official documentation at [https://test-utils.vuejs.org/api/#wrapper-methods](https://test-utils.vuejs.org/api/#wrapper-methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'This short example gives us a template to write our tests, but now we move
    to a more complex example to test our `input` component. In the test directory,
    create the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/tests/FibonacciInput.test.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This final example starts in the same way as before, by importing the functions
    that we will use to describe the tests, mount our component, and the component
    itself. Our purpose here is to simulate to a certain degree the user interaction
    with the component by entering a value in the `input` field, clicking the button,
    and then capturing the event and the value passed programmatically. We will rely
    on the methods just like before. We start in line `#1` by mounting our component
    and creating the wrapper. Notice that, this time, we are not passing any options,
    as we don’t need them. In line `#2`, we use the wrapper’s `find()` method to locate
    an `input` element and set a value of `10`. The `find()` method retrieves elements
    using a string with the same syntax as `querySelector` in a browser window. The
    returned object is a wrapper around the element, which again exposes methods for
    users to interact with it – in this case, `.setValue()`. Using a similar logic,
    in line `#3`, we also locate the button and trigger the `click` event, which will
    emit the `input` event in our component. Notice how easy it is in lines `#2` and
    `#3` to manipulate our component. In this way, we can access and interact programmatically
    with it, much like it could happen in an end-to-end test. We could, in theory,
    create our end-to-end tests using this tool, but there are better options, such
    as **Cypress** ([https://www.cypress.io/](https://www.cypress.io/)), which work
    excellently with Vitest, giving us a great DX.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line `#3`, we have clicked a button, which we know should emit an event.
    In line `#4`, we capture all the emitted events with the name `input`. The result
    is an array of wrapped events that we can use in our assertions, by referencing
    each event by its ordinal index. In this case, we only triggered one event, so
    in line `#5`, we pass that to our expected function as `inputEvents[0]`. However,
    notice that the assertion matches the output to an array, `[10]`, instead of the
    value we entered in line `#2`. Why is that? The answer is that each *event* has
    an undetermined number of arguments it could pass, so these are captured in an
    array. An equivalent notation is shown here in line `#6`, where we pass to `expect()`
    directly the value of the first element in the array of arguments, from the first
    event captured: `inputEvents[0][0]`. Then, we can directly validate the result
    to a value with `.toBe(10)`. Now, this approach may seem a bit convoluted and
    clumsy, having to refer to events and their values in such a way, but it is very
    powerful. Consider that we can, in one single line, assert a full array with a
    set of related values!'
  prefs: []
  type: TYPE_NORMAL
- en: In these two files, we have now tested the input and output of our components
    and even validated the interactivity as expected. We have also learned how to
    retrieve elements rendered and access their properties. Any error thrown in these
    functions will invalidate the test and point us in the right direction, line,
    and comment on where to fix it. Placing tests in individual files is a very convenient
    alternative. However, Vitest also accepts in-source testing, which we will see
    next.
  prefs: []
  type: TYPE_NORMAL
- en: In-source testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With in-source testing, we can indicate to Vitest to look into our JavaScript
    and Single Component Files for the tests to run, as opposed to specific files.
    These alternatives are not exclusive to each other, so we could have both active
    at the same time. The reason behind this is that, in some cases, a test case would
    benefit to be “close” to the original code that it is trying to assert. Such code
    must be placed at the end of our file following this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for Vitest to find this code in our files, we also need to modify the
    `vite.config.js` file to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, to eliminate the test code from the production build, we need
    to add the following before the bundling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With these changes, we can then include the tests at the end of our JavaScript
    files, with the benefits and trade-offs that this brings. For example, if there
    is an in-house service that is shared or used among projects, it could be a good
    idea to place the tests in the same file as opposed to duplicating them for each
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our tests in place, let’s see two more benefits that we get
    from using Vitest: *coverage* and a live*web UI.*'
  prefs: []
  type: TYPE_NORMAL
- en: Coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of coverage is very simple, and it answers the question of how
    much of our code is covered by automated tests. We know that 100% coverage is
    only possible for small applications, as the same effort for large projects falls
    fast into the law of diminishing returns Vitest offers us a simple way to answer
    this question by running the `vitest –coverage` command. In our case, we have
    already set this option in our `package.json` scripts section, so we can run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding command is run, if any dependency is missing, it will prompt
    us on whether we want to try to download and install it:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.3 – Vitest prompts \uFEFFus to install missing dependencies for\
    \ coverage](img/Figure_9.03_B18602.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Vitest prompts us to install missing dependencies for coverage
  prefs: []
  type: TYPE_NORMAL
- en: 'For our chapter code example, the coverage report should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Vitest coverage report example](img/Figure_9.04_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Vitest coverage report example
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to retrieve this information on a file (as `json`, `text`, or
    `html`) if we need to. For that, we just need to include a new line in our `vite.config.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running the command again will be a website placed in a new directory
    called `coverage` at the root of our project. This static website provides for
    navigation and drills down in the report. In our example, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Coverage HTML report](img/Figure_9.05_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Coverage HTML report
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on our needs, this simple tool may provide us with insight into our
    project that would be hard to find otherwise. The export to JSON file comes also
    very handy if we need to integrate our project with other reporting software or
    format. There is yet another alternative that may come in handy: Vitest also provides
    a web UI to view and interact with the tests in the form of a dashboard. We will
    see this next.'
  prefs: []
  type: TYPE_NORMAL
- en: The Vitest UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Vitest is based on Vite, it does make good use of some of its features,
    not only for live testing but also to provide a live development server displaying
    the tests in real time. To make use of this option, we only need to install the
    appropriate dependency as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for convenience, we should add the following line in our `package.json`
    file so we can run the application using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the server with this command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The development test server will start and provide us with an address to open
    in the browser. For our application, this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.6 – Vitest UI \uFEFFdashboard](img/Figure_9.06_B18602.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Vitest UI dashboard
  prefs: []
  type: TYPE_NORMAL
- en: The web UI has also new possibilities to interact with the test cases, and even
    see the relationships between components and services in a graphical manner, all
    the way down to the test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have cleaned up our code and run tests, it is time to look into
    another tool to keep track of changes, a fundamental concept for today: source
    control with Git.'
  prefs: []
  type: TYPE_NORMAL
- en: What is source control... and why?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development is a “human-intensive” discipline, meaning that it depends
    heavily on the creativity and involvement of the developer and their know-how.
    It is common to try different approaches to the same situation and write and rewrite
    code. Even the process of refactoring after testing implies making changes in
    the code. It is not an anomaly that during this process, we need to “go back”
    to a previous code when a change or approach didn’t meet expectations. If we are
    constantly overwriting the same files... how do we keep track of what changed
    where? And by whom? Our own memory is not enough when time and complexity grow.
    Save files with different names? That would become impractical very soon. And
    what about combining source code from multiple developers? We can quickly see
    that managing the source code for non-trivial projects is a very important task
    in itself.
  prefs: []
  type: TYPE_NORMAL
- en: The historical solution to this early problem in computer science has been the
    creation of additional software in charge of keeping track of changes in the code,
    allowing a developer to go back on their tracks, and facilitating the chore of
    merging code from multiple developers to make a cohesive source code. The emerging
    discipline for this task is called **Source Control** (**SC**), and the software
    to implement it is called a **Source Control System** (**SCS**) or **Source Control
    Management System** (**SCMS**). There have been many, and still are many, different
    systems in use today, such as **Mercurial**, **Subversion**, **ClearCase**, **Git**,
    and **BitKeeper**. Each one has its trade-offs. In particular, Git is used today
    by most projects and developers around the globe. Statistics on the internet show
    different percentages for the most popular ones, but each one shows this trend.
    Because of this, it is important that we learn how to use Git, which is our next
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: Source control with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, the most popular SCS is Git, which was created by **Linus Torvalds**,
    who is also the creator of the Linux kernel. The story goes that the Linux kernel
    project used *BitKeeper* for source control, but the team hit many issues with
    the growing complexity and distributed nature of the development. Frustrated,
    Linus Torvalds decided to make his own SCS to solve the real-life problems they
    had... and it took him one weekend! (See [https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/](https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/).)
    That was the humble beginning of Git, and from there, it became popular in the
    open source community as well as in the enterprise world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git is a distributed SCMS, simple and effective to use from the command line.
    It offers the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates and manages a **repository**, where it collects the source files and
    the history of changes for each one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows sharing projects by cloning **remote repositories** into local projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the project to be branched and merged. This means that you can have different
    copies of the same project with different code (a **branch**), switch between
    them, join them, and unify them by request (a **merge**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizes changes from a remote repository into a local copy (called a **pull**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends local changes to a remote repository (called a **push**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s learn how to use Git by applying it to our current project for this chapter.
    Let’s start by installing it in our system, so it’s available for all our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Windows systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest and recommended way to install Git on Windows systems is to download
    the installers from the official Git website at [https://git-scm.com/download/win](https://git-scm.com/download/win).
    Click on the version you want to use, according to your operating system (32-
    or 64-bit), and then run the installer following the directions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Official Git installers for Windows](img/Figure_9.07_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Official Git installers for Windows
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is done, the command-line tools will be installed on your
    system so we can run them through a terminal. Also, if you are using a code editor
    such as Visual Studio Code, it will integrate the tools and provide you with a
    GUI to handle basic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Installation on Linux systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Linux systems, the installation is done through the command line, using
    the distribution’s package manager. The package name in (almost) all distributions
    is simply `git`. In Debian and Ubuntu systems, the installation can be run with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in these distributions, there may not be the latest version, so if
    you need the latest stable release, you need to add the official PPA repository.
    In this case, run the following commands in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands will update your system dependencies and install (or
    upgrade) Git on your system. For a complete list of distributions and commands
    to install Git, please refer to the official documentation at [https://git-scm.com/download/linux](https://git-scm.com/download/linux).
  prefs: []
  type: TYPE_NORMAL
- en: Installation on macOS systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In macOS systems, there are different ways to install Git:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have Homebrew installed, run `$ brew install git` in a Terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If instead, you have MacPorts, run `$ sudo port install git` in a Terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have installed Xcode, Git is included
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other alternatives, please check the official documentation at https://git-scm.com/download/mac.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regardless of which system you are working on, or the installation type you
    made, Git will be installed in your local path, so it can be executed from any
    terminal window. To verify the installation and version, run this command (does
    not require admin privileges):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of writing, the current stable version is *2.39.2*. With this done,
    open a terminal window in the root folder of our project. To start using Git,
    we need to create a local repository with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After the execution is done, a new hidden directory will be created in the folder.
    You don’t have to worry about it, as it will be managed by Git. If your File Explorer
    has deactivated the option to see hidden files, then you may not notice the creation.
    It is recommended that you have **Show/view hidden files** in your system activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created the repository, we can start using it. The steps to work
    with files usually includes the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Working stages of Git](img/Figure_9.08_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Working stages of Git
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have files created or edited, the next step is to “stage” the files.
    This indicates to Git that it needs to keep track of changes and include the file
    in the next commit event. **Committing** is the act of moving those files/changes
    into the repository. If a file is not staged, it will not be included in the commit.
    To add a file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the files, but it is quite verbose. Instead, if you want to add
    all changes in all files, run this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will come in handy in the first commit when the repository is initialized.
    After running this command, all the files will start to be tracked. However, we
    do not want to track everything in our root folder, so to exclude files or directories,
    we can use a special file named `.gitignore`. If you open this file in the example
    directory, you will find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: /chapter 10/.gitignore
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is a plain text file that indicates to Git not to track the files and directories
    indicated in each line. You can also use wildcards such as an asterisk (`*`) and
    question mark (`?`) to include a match pattern. This is very useful, as there
    are parts of your code base that you don’t need to track, such as the node dependencies
    and binary files (images and the like). Make sure to have this file in your directory
    before making a massive staging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have staged files, you can check them with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of our example project, it will show something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – First staging in Git](img/Figure_9.09_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – First staging in Git
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how Git informs us also that we are in the `master` branch, and that
    there have not been any commits yet. The `master` branch is the main branch for
    our code and is created by default. This is a special branch that is used to keep
    the stable code of our applications. In tools such as GitLab and GitHub (we will
    talk about them later), these branches also trigger certain events once committed.
    For now, let’s move forward and create our first commit with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see results like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Results from the first commit](img/Figure_9.10_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Results from the first commit
  prefs: []
  type: TYPE_NORMAL
- en: With these simple lines, we have started to keep track of our source code. Now,
    as mentioned before, we have committed our initial code to the `master` branch.
    Git allows us to make an instant copy of the state of our code, much like a screenshot,
    and continue working from there without affecting the original. This is called
    **branching** and is an important part of using Git.
  prefs: []
  type: TYPE_NORMAL
- en: Managing branches and merges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using branches to control our development is a very good way to move forward
    on a certain footing. Here are the most common commands to manage branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Action | Command example |'
  prefs: []
  type: TYPE_TB
- en: '| Create a branch and switch to it |'
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Create a branch but stay in current |'
  prefs: []
  type: TYPE_TB
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Delete branch |'
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Switch to a branch |'
  prefs: []
  type: TYPE_TB
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Merge a branch with current |'
  prefs: []
  type: TYPE_TB
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Check current branch |'
  prefs: []
  type: TYPE_TB
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have moved to another branch, you can perform all the regular Git operations
    (edit and delete files, etc.) without affecting the other ones.
  prefs: []
  type: TYPE_NORMAL
- en: Merging conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When merging multiple branches together or with `master`, it is possible and
    more than likely that some files will have a discrepancy with the current branch.
    In this case, the *merge* will fail, and the user will be prompted to solve the
    differences. What Git does is mark the target file (the file in the current branch)
    with markers in the text for the user to edit. Once these have been edited, the
    file can be staged and committed, thus ending the *merge*. Let’s try that without
    code, by purposely creating a discrepancy to fix. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new branch, `dev`, with this command: `$ git checkout –``b dev`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `index.html`, adding in line 11 (before the script tag) the following:
    `<div>A div created in` `branch dev</div>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file, stage it, and commit the change with `$ git add index.html` and
    then `$ git commit –m "added div` `in dev"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will move to the `master` branch with `$ git` `checkout master`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice how line 11 with the div has disappeared from `index.html`. This is
    because that edition was never made on this file. Now, add in that line the following:
    `<p>This change was made` `in master</p>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file, stage it, and commit it with a different message (look at *step
    3*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will try to merge both branches and, as `index.html` has been committed
    to both with a different code, it will fail! To start the *merge*, run `$ git
    merge dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see an error on the terminal, and new lines added to `index.html`
    indicating the discrepancies. In our code example, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Merge conflict](img/Figure_9.11_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Merge conflict
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the conflict, just edit the source code to your best judgment (also
    delete the extra labels added by Git), then save the file, stage it, and finally
    make a commit. You will receive a message indicating that the *merge* has been
    resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with branches and resolving mergers when they appear is a common practice
    and quite useful, but we are still not using the full potential of Git. As you
    remember, Git is a distributed SCMS, and this relies on its great potential. Enter
    the remote repository...
  prefs: []
  type: TYPE_NORMAL
- en: Working with remote repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the same way that we work with a local repository, Git can also synchronize
    code with a remote repository. This enables team members from anywhere in the
    world to collaborate together in the same code base, resolve conflicts, and also
    synchronize their own code with others’ contributions. Working with a remote repository
    involves the following steps to set up:'
  prefs: []
  type: TYPE_NORMAL
- en: The remote repository must be created, and a URL provided to connect to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add the remote repository as a new origin to our local repository with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set our `master` branch to synchronize with the remote repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We retrieve changes from the remote repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We submit our changes to the remote repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you have done *steps 1* to *3*, the regular activity will involve *steps
    4* and *5*. These activities will keep your local repository synchronized with
    your remote repository. In practice, modern IDEs such as Visual Studio Code will
    already provide you with graphical tools to make these operations, and this results
    in more convenience when you are working on a project. They also include visual
    tools to resolve conflicts during *merges*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Git server for your local network is outside the scope of this
    book, but this introduction would not be complete without a word about **GitHub**
    and **GitLab**. It is common that when people first hear about Git, they associate
    it with GitHub, which is understandable, as the latter has a much more popular
    media presence. GitHub is not Git. It is a web platform that provides tools built
    on top of Git, to host online projects hosting remote repositories. Thus, you
    can perfectly work with Git locally, and synchronize with a GitHub or GitLab remote
    repository. This is the most common case.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub provides messaging and documentation tools, and much more – even additional
    services that allow detecting events in our repository to trigger certain actions
    and services, some provided locally (at a cost), others remotely (for example,
    webhooks). For example, it is possible for you to commit locally, push the changes
    to the `master` branch on GitHub, and have a whole set of routines started, from
    compilation to website presentation. Again, managing all these options is outside
    our current scope in this chapter, but the important thing to remember is that
    all of this is based and built upon Git, so if you understand *how* it the works
    and *what* it does, you have a solid foundation to move ahead with other tools
    and services. There is one more concept that has become familiar with this topic,
    Continuous Integration and Delivery, which we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration and Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) is a practice enabled by the technologies
    we have seen thus far, where developers commit their changes to a central (remote)
    repository as frequently as possible. The central repository detects the incoming
    changes and triggers automated tests against the code. Then, it compiles/builds
    the final product. This is done continuously, as opposed to the practice of merging
    and compiling on a given date before launch.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Delivery** (**CD**) builds on top of CI, by also deploying the
    released product to its final location. You can configure this process to create
    preliminary versions of software or web applications, (for example, betas, nightly
    builds, etc.), and program a release date for the end location and delivery to
    the customers (sometimes, this last part may involve a process of its own and
    is called **Continuous Deployment**). Both services mentioned before (GitHub and
    GitLab) offer these types of services.'
  prefs: []
  type: TYPE_NORMAL
- en: By using these concepts, it is possible to set up a whole automated workflow
    from your desktop to the web, where a simple Git commit and a push to the server
    would trigger your application to be tested and published in its destination online.
    The way to implement this workflow is particular to the tool used to implement
    CI and CD.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered very important concepts regarding the care
    and quality of our code. We have learned how to install official tools to perform
    automated tests in our code and components, as well as how to keep track of changes
    and management in the source code. While the examples and information provided
    here are introductory, they are detailed enough to implement them in your own
    projects and keep your learning skills growing. The concepts of CI and CD, as
    well as services provided by online repositories, also give you a solid foundation
    to learn to use them, as they all are based on the functionality provided by Git.
    All these tools have professional value for a developer and are required in the
    industry today.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is automated testing important? Does it eliminate the need to perform manual
    testing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is necessary to test our Single File Components in Vue?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is source control, and why is it necessary?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Git, and how is it different from GitHub/GitLab?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you modify a file in a branch, does that modify it in all other branches?
    Why does or doesn’t this happen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the commands to control Git the same across all platforms?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do CI and CD stand for, and what is the value they add to a workflow?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
