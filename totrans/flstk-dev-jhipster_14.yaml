- en: Best Practices with JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters of the book, we learned about JHipster and the various
    tools and technologies it supports in detail. These are the things we have learned
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned to develop monolithic and microservice applications. We also learned
    about differences in the architecture and reasons to choose one over the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created entities using JDL, and we customized the generated applications
    for our business needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a CI-CD setup using Jenkins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We deployed the monolith application to the Heroku cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We deployed the microservice architecture to the Google cloud using Kubernetes
    and Docker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about Spring Framework, Spring Boot, Angular, React, Docker, and
    much more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will see what steps to take next and use what you have
    learned from this book, and we will also talk about some of the best practices,
    tips, tricks, and suggestions from the JHipster community. As core contributors
    of JHipster, we will also provide some insights and lessons learned by us in this
    chapter. The following are some of the topics that we will touch upon:'
  prefs: []
  type: TYPE_NORMAL
- en: The next steps to pursue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best practices to keep in mind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JHipster modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next steps to pursue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JHipster supports a lot of technologies and learning about all of them would
    require an insane amount of time and effort; it cannot be done in a single book.
    Each technology supported would require a book on its own to learn and master
    it. If you are already familiar with the core concepts of web development, you
    will have a fairly good idea how a JHipster application works by now. We hope
    this book gave you a good introduction to the technologies and JHipster itself.
    But this in itself isn't sufficient; you will have to keep learning more to become
    a master. The following are some of the tasks that you can pursue to hone your
    skills in web development using JHipster further. But, before that, we would recommend
    that you learn more about Spring Framework and the Angular/React ecosystem to
    complement what you have learned in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a shopping cart for the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](63e6ed92-1616-40b7-86b8-1b3332fcbfb7.xhtml)*, Customization
    and Further Development*, we saw how the generated application can be customized
    to make it look and behave like an e-commerce website. As mentioned there, it
    is not enough to make the application truly usable. The following are some of
    the features that you can try to implement to make the application more feature
    complete:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a simple shopping cart feature on the client-side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ProductOrder` object to hold the `OrderItems`. The `ProductOrder`
    is related to the Customer so tag it to the customer using details of the currently
    logged-in user.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an add to cart button to the product items in the list. On clicking the
    button, create a new `OrderItem` for the Product and add the `OrderItem` to the
    `ProductOrder`'s `OrderItems` array. If the same product is clicked more than
    once, increase the quantity attribute of the existing `OrderItem`. Add a shopping
    cart dialog to list down all the `OrderItems` added to the `ProductOrder`. It
    can use a similar listing UI to the products, or a simple table to show the product,
    total price, and quantity.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `view cart` button to the product list page to view the shopping cart
    dialog.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an order now feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an order now button to the product list page.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On clicking the button, send the `ProductOrder` to the REST API to create a
    new `ProductOrder`, use the `product-order.service.ts` for this.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: At the backend, modify the save method of `ProductOrderService.java` to create
    an Invoice and Shipment for the `ProductOrder` and save them all.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us assume that we accept cash on delivery so let us skip integrating with
    a payment gateway for now.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Send an order confirmation to the customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JHipster comes with mail configuration and templates out of the box. You can
    configure your own SMTP server details in `src/main/resources/config/application-*.yml`.
    Refer to [http://www.jhipster.tech/tips/011_tip_configuring_email_in_jhipster.html](http://www.jhipster.tech/tips/011_tip_configuring_email_in_jhipster.html)
    for instructions on how to configure popular SMTP services.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new email template in `src/main/resources/mails` for order confirmation.
    Provide the details of products, total price, and quantity in the email.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the provided `sendEmailFromTemplate` method in `MailService.java` to send
    the email when an Invoice is successfully created.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a customer profile when registering a new user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add fields to the registration page and create customer entity for every user
    from the details automatically.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to apply the changes to the microservice application as well.
  prefs: []
  type: TYPE_NORMAL
- en: Improving end-to-end tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](39f6bb2a-8691-42c6-b010-ba71ee36a6c9.xhtml), *Testing and Continuous
    Integration*, we saw that some of the e2e tests were commented out due to the
    difficulty in generating tests for an entity with a required relationship. Try
    to fix the tests with the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a method to delete entities after creation, similar to what we saw in [Chapter
    6](39f6bb2a-8691-42c6-b010-ba71ee36a6c9.xhtml), *Testing and Continuous Integration*,
    for the customer entity spec.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncomment the commented out e2e tests in the files under `src/test/javascript/e2e/entities`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate the protractor to the related entity page and create a new item. If
    the related entity has required relationships then follow the same approach and
    nest them until all the required entities are in place. This can be done in a `beforeAll`
    method of the test as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go back to the entity under test and see whether the test works fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the test is complete, delete the created entities in the `afterAll` method
    of the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explore whether you can automate the creation of an entity item on the page
    object of the entity and use it when needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improving the CI/CD pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](39f6bb2a-8691-42c6-b010-ba71ee36a6c9.xhtml), *Testing and Continuous
    Integration*, when we created the `Jenkinsfile` using the CI/CD sub-generator,
    we commented out the deployment stage. Re-enable it and check whether the application
    is deployed to Heroku when you make new commits:'
  prefs: []
  type: TYPE_NORMAL
- en: See if you can add e2e tests to the pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application is on GitHub, try to add Travis to the project using the
    ci-cd sub-generator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a JHipster module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JHipster has two mechanisms to extend its features:'
  prefs: []
  type: TYPE_NORMAL
- en: A modules system, which lets users build their own Yeoman generators ([http://www.jhipster.tech/modules/creating-a-module/](http://www.jhipster.tech/modules/creating-a-module/)) 
    to complement JHipster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new blueprint mechanism introduced with JHipster 5 to customize required parts
    of the code generated by JHipster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a **module** and a **blueprint** is that a blueprint
    lets you override certain parts of the generated application while JHipster scaffolds
    the remaining parts. For example, a blueprint can override the client-side code
    alone, while the server side is generated by JHipster. A module, on the other
    hand, can only change what is generated by JHipster and hence is more suitable
    for adding complementing features on top of the ones created by JHipster.
  prefs: []
  type: TYPE_NORMAL
- en: Try to build a module to add a simple page to your application.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the JHipster module generator ([https://github.com/jhipster/generator-jhipster-module](https://github.com/jhipster/generator-jhipster-module))
    to scaffold a new module.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices to keep in mind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, the JHipster community has identified and adopted a lot of best
    practices from the technologies and tools it supports and from the general technical
    community. While JHipster has tried to follow these best practices in the code
    it creates, the following are some best practices, tips, and tricks that you as
    a user should follow.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a client-side framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using JHipster you have an option to choose between Angular and React
    as the client-side framework. Do not choose something just for its hype, choose
    based on your requirement, team composition, and familiarity:'
  prefs: []
  type: TYPE_NORMAL
- en: If you come from a heavy Java/Spring background, then Angular will be much easier
    to follow and work with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application requires heavy state management and shared state, then React
    would be a more natural fit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are planning to build a native mobile client for your application then
    the more mature React is a good choice for this space, with React Native allowing
    you to reuse a lot of code between your web and mobile application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application depends heavily on HTML pages produced by a design team
    or a third-party, then Angular will be much easier to integrate than React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need a lot of widgets that are not part of standard Bootstrap, then use
    an existing widget library, such as PrimeNG or VMware Clarity, rather than assembling
    widgets from different origins. However, if you need only a few more widgets on
    top of Bootstrap, then stick to Bootstrap and use a Bootstrap compatible widget
    for Angular or React.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of what you choose, follow the guidelines and best practices from
    that project's community.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a database option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JHipster provides support for many kinds of databases, ranging from SQL to
    NoSQL. The following are some considerations when choosing a DB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For most cases, a SQL DB would be more than sufficient, hence if you do not
    see any reason to go with other NoSQL solutions, stick to SQL and choose from
    MySQL, Postgres, Oracle, MariaDB, and MS SQL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are on an enterprise with Oracle or MS SQL subscriptions, then it would
    make sense to choose them as you would benefit from the support and enterprise
    features provided
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to store and query a lot of JSON data, then Postgres offers the
    best JSON support with full-text search capabilities
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For most simple use cases, MySQL or MariaDB will suffice
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Always choose a second-level Hibernate cache when working with a SQL DB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When choosing a development database for SQL:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose an H2 file DB if you want a simple development setup with persistent
    data.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the same DB as the production DB if you want faster restarts and your
    persistent data doesn't need to be wiped every now and then. If you are using
    the provided Docker images, then wiping data will not be an issue.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose an H2 in-memory DB if you do not want any persistent data during development
    and would like a clean state on each restart
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If your use case requires a lot of heavy data reads/writes, and if the data
    is not very relational, then Cassandra would be a perfect fit, as it is distributed
    and can work under extremely heavy loads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a normal, non-relational data structure, MongoDB may be sufficient. You
    could also use Postgres as a NoSQL JSON store if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need enterprise support for NoSQL, CouchBase is a good option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Elasticsearch along with the primary DB for full-text search. If you only
    need simple filtering, use the JPA filtering option provided. Refer to: [http://www.jhipster.tech/entities-filtering/](http://www.jhipster.tech/entities-filtering/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed choosing a microservice or monolithic architecture
    in [Chapter 1](498dbd6d-b882-4551-92dd-97cdde4b62ac.xhtml), *Introduction to Modern
    Web Application Development*. Here are some more points when it comes to architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't use a microservice architecture if you're a small team. Microservices
    are about scaling teams more than anything. It's often easier to break up your
    monolith than start with microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use asynchronous messaging in your monolith if you think you may need to refactor
    to microservices in the future. JHipster provides support for Apache Kafka, which
    is a good solution for asynchronous messaging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous messaging is the best way of building stateless systems. It is
    important in a microservice architecture as you might often want communications
    to be stateless and non-blocking. Some of the popular solutions for this are Apache
    Kafka ([http://kafka.apache.org/](http://kafka.apache.org/)), RabbitMQ ([https://www.rabbitmq.com/](https://www.rabbitmq.com/)), and
    gRPC ([https://grpc.io](https://grpc.io)).  ReactiveX ([http://reactivex.io/](http://reactivex.io/))
    and Spring Reactor ([http://projectreactor.io/](http://projectreactor.io/)) are
    popular abstractions for working with asynchronous systems. Asynchronous messaging
    also makes the systems loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: If you intend to expose an API to a third party, do *API first* development.
    We now have a good workflow to do it with Swagger Codegen. Refer to [http://www.jhipster.tech/doing-api-first-development/](http://www.jhipster.tech/doing-api-first-development/)
    for more info.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When doing communication between microservices with REST, don't put interface
    code in a shared package; it would tightly couple APIs to their clients, thus
    arriving at a distributed monolith.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With JHipster, it is possible to split the client and server. Refer to [http://www.jhipster.tech/separating-front-end-and-api/](http://www.jhipster.tech/separating-front-end-and-api/).
    However, think twice before separating them, as it will require you to open up
    CORS, which makes the security more vulnerable, and such architecture brings its
    own issues. So do this only if you have a good reason to do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use DTOs at the service layer so that you can aggregate entities and define
    a better API without exposing entities to the client. You will have to enable
    the service layer for your entities to use this with JHipster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the technology stack of your application before you start development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make yourself familiar with the provided toolbelt, such as build tools (Maven/Gradle/Webpack),
    BrowserSync, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security is one of the most important aspects of any application, and you should
    consider the following when choosing a security mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: For most use cases JWT authentication will be sufficient, so stick to that if
    you are not sure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want single-sign-on in your application, use OAuth 2.0 / OIDC rather
    than trying to make JWT or session authentication work as an SSO solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you already have Keycloak or Okta set up in your company, choose OAuth 2.0/OIDC
    and connect to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose session-based authentication only if you want a stateful authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment and maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of good practices here; some of the important ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a must-have for integration testing of microservices, but going into
    production with Docker is not easy so use an orchestration tool, such as Kubernetes, for
    that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a prod build immediately after the application is generated and deploy to
    prod immediately while your app is still very simple. This will help ease any
    deployment issues, as you will be sure that the app works fine out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prod build is quite different from the dev build when it comes to the client
    side, as the resources are minified and optimized. When adding any frontend code,
    libraries always verify the prod build as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always run end-to-end protractor tests with the prod profile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embrace the embedded servlet engine and forget about deploying to a JEE server
    such as WebLogic, WebSphere, JBoss, and so on. The artifacts produced are executable
    and have an embedded Undertow server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you know that Java EE is being renamed to Jakarta EE? Refer to [https://www.infoq.com/news/2018/03/java-ee-becomes-jakarta-ee](https://www.infoq.com/news/2018/03/java-ee-becomes-jakarta-ee)
    for more info.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade often using the JHipster upgrade sub-generator. This will ensure the
    tools and technologies you use are up to date and secure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove all secrets from `application-prod.yml` and use placeholders to inject
    values from the command line or environment variables. Never put any secrets or
    passwords in code or config files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, these are some best practices you should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: If you start creating entities using the entity sub-generator, then use `export-jdl`
    and switch to JDL once you have more than a handful of entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate your application without any modules first and add required modules
    only when the need arises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate a module carefully before adding it. Make sure it supports the stack
    you have chosen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow each underlying technology's *best practices*. Angular best practices,
    Spring best practices, and so on. Change something only if there is a good reason
    to do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the provided library versions on the client side and server side. It's hard
    work to have them all working together, so stick to them. Update them when JHipster
    updates them or only if you really need to fix a bug or a security issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the workflows provided by JHipster. They are here to help you. There
    is usually a very good reason to use them in the recommended way. Read the JHipster documentation before
    looking for help outside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a great working environment out of the box; don't break it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend and backend updates are automatic and fast using live reload. Make
    use of them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Production deployment is easy using the provided sub-generators.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the provided sub-generators for the cloud platform you are deploying to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git is your friend. Commit each time you add a module or an entity, or when
    using a sub-generator. Every mistake (including in the database) should be easy
    to rollback with Git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JHipster modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JHipster modules and blueprints are a great way to add more features and functionality
    to your generated code. There are many modules (55 at the time of writing) available
    to choose from in the JHipster marketplace ([http://www.jhipster.tech/modules/marketplace](http://www.jhipster.tech/modules/marketplace)),
    and you can also build your own modules to suit your needs. Some of the modules
    worth noticing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignite JHipster**: This provides a React Native boilerplate for JHipster
    apps. An ideal way to kickstart your React Native application using JHipster as
    the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity Audit**: This module enables entity audits. It uses Hibernate audit
    hooks to create a custom audit for entity CRUD operations. It also provides Javers
    as the auditing mechanism instead of the custom Hibernate auditing. It also provides
    a nice UI to view the audits in an Angular application. It will enable auditing
    for new entities as well as existing entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ionic**: This provides an Ionic client for JHipster apps. It is an ideal
    solution if you want to create mobile applications with a JHipster backend and
    Angular frontend with Ionic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swagger CLI**: Module provides support for generating Swagger clients for
    a JHipster application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gRPC**: This module generates gRPC reactive endpoints for a JHipster application.
    It supports entities as well, and is an ideal choice if you want a non-blocking
    reactive API for your JHipster application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VueJS**: This module provides VueJS support for JHipster applications. It
    creates minimal boilerplate to start client-side development for JHipster apps
    using VueJS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To use a JHipster module first install it using `npm i -g generator-<module-name>`
    or `yarn add global generator-<module-name>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, go into the JHipster application directory and execute `yo <module-name>`
    to initiate the module and follow the prompts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contributing to JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best ways to learn JHipster and the technologies it supports is by
    contributing to JHipster directly. Refer to the contribution guide ([https://github.com/jhipster/generator-jhipster/blob/master/CONTRIBUTING.md](https://github.com/jhipster/generator-jhipster/blob/master/CONTRIBUTING.md))
    for details about setting up JHipster for development.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can contribute to the project in many ways; some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you find a bug, enter an issue in the GitHub project ([https://github.com/jhipster/generator-jhipster](https://github.com/jhipster/generator-jhipster)),
    follow the guidelines in the issue template, run `jhipster info`, and provide
    steps to reproduce. You can also try to fix the issue yourself and submit a PR
    if you're successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work on open issues and feature requests. This way you will learn the internals
    of JHipster and the technologies used along the way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer JHipster related questions on Stack Overflow ([https://stackoverflow.com/questions/tagged/jhipster](https://stackoverflow.com/questions/tagged/jhipster)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our journey together through JHipster and full stack development has come to
    an end. In this chapter, we learned about many best practices identified by the
    JHipster community. Try to complete the assignments in the *Next steps to pursue*
    section, as it will help you to apply what you have learned and will help you
    understand the concepts better.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you have had a fabulous learning experience, and hope what you have
    learned from the book about JHipster will help you with your next project.
  prefs: []
  type: TYPE_NORMAL
- en: Follow `@java_hipster` on Twitter so you can see when new releases come out
    and security vulnerabilities are revealed.
  prefs: []
  type: TYPE_NORMAL
- en: If you have questions or issues regarding JHipster, post your questions to Stack
    Overflow ([https://stackoverflow.com/questions/tagged/jhipster](https://stackoverflow.com/questions/tagged/jhipster))
    and add the `jhipster` tag. The team will be notified and will be happy to help!
  prefs: []
  type: TYPE_NORMAL
