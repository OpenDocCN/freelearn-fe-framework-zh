- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Implementing Redux in Our Funbook App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的Funbook应用中实现Redux
- en: 'In the previous chapter, we got our hands “dirty” a little bit. I hope you
    liked building the Funbook app! We managed to build the frontend of a functioning
    app. Of course, the functionalities we created were limited. A real-world social
    media app would be much more robust, with many more components and user flows.
    However, bigger apps bring their own set of problems: handling large datasets,
    establishing style guides, managing analytics, and many other problems that we
    don’t want to spend our time on. We are here to talk about different solutions
    for state management. In the interest of staying focused, I added a few functionalities
    to our app that were not described in detail in the previous chapter. I added
    a modal displaying an enlarged version of the images on the `example-app-full`
    folder on GitHub:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们稍微“沾染”了一些实际操作。我希望你喜欢构建Funbook应用！我们成功构建了一个功能应用的客户端。当然，我们创建的功能是有限的。一个现实世界的社交媒体应用将更加健壮，拥有更多的组件和用户流程。然而，更大的应用也会带来自己的一套问题：处理大量数据集、建立风格指南、管理分析以及许多其他我们不希望花费时间解决的问题。我们在这里讨论不同状态管理的解决方案。为了保持专注，我在应用中添加了一些在上一章中没有详细描述的功能。我添加了一个模态，显示GitHub上`example-app-full`文件夹中图像的放大版本：
- en: '[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/example-app-full](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/example-app-full).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/example-app-full](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/example-app-full).'
- en: 'This app will be the base for all our state management experiments throughout
    this book. We will start our experiments by looking at the oldest state management
    library: **Redux**.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用将成为我们在这本书中所有状态管理实验的基础。我们将从查看最古老的状态管理库：**Redux**开始。
- en: 'In this chapter, we will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行以下操作：
- en: Go over a brief history of **Redux**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要回顾一下**Redux**的历史
- en: Install and configure **Redux** in the Funbook app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Funbook应用中安装和配置**Redux**
- en: Add **Redux** functionalities to the app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用添加**Redux**功能
- en: Learn about debugging **Redux**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何调试**Redux**
- en: By the end of this chapter, you should feel comfortable using **Redux**-specific
    jargon, such as reducer, actions, and store. You should also have a good understanding
    of what it takes to configure and use **Redux** in a real **React** **Native**
    app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够熟练使用**Redux**特定的术语，如reducer、actions和store。你也应该对在真实的**React** **Native**应用中配置和使用**Redux**有很好的理解。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow along with this chapter, you will need some knowledge of
    JavaScript and ReactJS. If you have followed the previous two chapters of this
    book, you should be able to go forward without any issues.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上本章的内容，你需要具备一些JavaScript和ReactJS的知识。如果你已经跟随着本书的前两章，你应该能够没有问题地继续前进。
- en: Feel free to use an IDE of your choice, as React Native does not need any specific
    functionality. Currently, the most popular IDEs for frontend developers are Microsoft’s
    VSCode, Atom, Sublime Text, and WebStorm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用你选择的IDE，因为React Native不需要任何特定功能。目前，前端开发者中最受欢迎的IDE是微软的VSCode、Atom、Sublime
    Text和WebStorm。
- en: The code snippets provided in this chapter are here to illustrate what we should
    be doing with the code. They do not provide the whole picture. To code along easier,
    please open the GitHub repo in your IDE and look at the files in there. You can
    either start with the files in the folder named `example-app-full` or `chapter-5`.
    If you start with `example-app-full`, you will be responsible for implementing
    the solutions described in this chapter. If you choose to look at `chapter-5`,
    you will see the entire solution implemented by me.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的代码片段旨在说明我们应该如何使用代码。它们并不提供完整的画面。为了更容易地编码，请在你选择的IDE中打开GitHub仓库，查看其中的文件。你可以从名为`example-app-full`或`chapter-5`的文件夹中的文件开始。如果你从`example-app-full`开始，你将负责实现本章中描述的解决方案。如果你选择查看`chapter-5`，你将看到我实现的整个解决方案。
- en: 'If you get stuck or lost, you can check the code in the GitHub repo:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到了困难或迷失了方向，你可以在GitHub仓库中查看代码：
- en: '[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5).'
- en: What is Redux? A brief history
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Redux？简史
- en: We went over a brief history of **React** in [*Chapter 1*](B18396_01.xhtml#_idTextAnchor017),
    *What are React and React Native?.* If you skipped that chapter, or simply don’t
    remember, don’t worry. All you need to know is that **ReactJS** was published
    in 2013 and it opened doors to creating beautiful single-page applications. **ReactJS**
    was an exciting library to use! A lot of people jumped on the opportunity and
    started re-writing their websites. As time passed, many developers would discover
    that creating and maintaining large applications with **ReactJS** became tedious.
    Don’t forget this was happening before the **ReactJS** team introduced hooks and
    context. Developers had to pass props from parents to nested children, going through
    multiple levels of irrelevant components. This is called **prop** drilling, as
    getting to the child component through many ancestors feels like drilling.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 1 章*](B18396_01.xhtml#_idTextAnchor017) 中简要介绍了 **React** 的历史，*什么是 React
    和 React Native？* 如果你跳过了那一章，或者只是不记得了，不用担心。你需要知道的是，**ReactJS** 于 2013 年发布，它为创建美观的单页应用打开了大门。**ReactJS**
    是一个令人兴奋的库！很多人抓住了这个机会，开始重新编写他们的网站。随着时间的推移，许多开发者会发现，使用 **ReactJS** 创建和维护大型应用变得乏味。别忘了，在
    **ReactJS** 团队引入 hooks 和 context 之前，这种情况就已经发生了。开发者必须从父组件传递 props 到嵌套子组件，经过多个无关组件的层级。这被称为
    **prop** 钻孔，因为通过许多祖先到达子组件的感觉就像是在钻孔。
- en: 'In 2015, something very interesting happened: *Dan Abramov* and *Andrew Clark*
    wrote and published a new open source library called Redux. ReactJS developers
    were mostly confused at first, given that **Redux** introduced new concepts to
    the **ReactJS** world. We could start thinking about global states that are accessible
    from anywhere in the app. In order to change a global state, we would need to
    use special functions called “actions” and also use something called “reducers"...
    This was a lot to take in! Regardless, this new library solved a very real problem,
    so the only thing to do was to buckle up, watch Dan Abramov’s tutorials, and use
    this new and amazing tool!'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年，发生了一件非常有趣的事情：*丹·阿布拉莫夫* 和 *安德鲁·克拉克* 编写并发布了一个名为 Redux 的新开源库。最初，ReactJS
    开发者对此感到困惑，因为 **Redux** 为 **ReactJS** 世界引入了新的概念。我们可以开始思考那些可以从应用中的任何地方访问的全局状态。为了改变全局状态，我们需要使用称为“actions”的特殊函数，还需要使用称为“reducers”的东西...
    这需要吸收很多内容！不管怎样，这个新库解决了一个非常实际的问题，所以唯一要做的就是系好安全带，观看丹·阿布拉莫夫的教程，并使用这个新颖而神奇的工具！
- en: 'Thanks to Dan Abramov’s efforts to teach, explain, and popularize **Redux**,
    it became a staple of **ReactJS** development. As years passed, new concepts for
    managing global states were created, some similar and some very different from
    **Redux**. Compared to the newer solutions, **Redux** can feel clunky, as it has
    a large amount of boilerplate code. Even the library author expressed his doubts
    through Twitter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了丹·阿布拉莫夫（Dan Abramov）在教学、解释和推广 **Redux** 方面的努力，它成为了 **ReactJS** 开发的基础。随着岁月的流逝，为管理全局状态而创造的新概念不断涌现，有些与
    **Redux** 类似，有些则非常不同。与较新的解决方案相比，**Redux** 可能会显得有些笨拙，因为它有大量的样板代码。即使是库的作者也通过推特表达了他的疑虑：
- en: '![Figure 5.1 – Dan Abramov’s tweet saying he does not understand the Redux
    example code ](img/Figure_5.01_B18396.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 丹·阿布拉莫夫的推文，表示他不理解 Redux 示例代码](img/Figure_5.01_B18396.jpg)'
- en: Figure 5.1 – Dan Abramov’s tweet saying he does not understand the Redux example
    code
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 丹·阿布拉莫夫（Dan Abramov）的推文，表示他不理解 Redux 示例代码
- en: Around 2016, the maintenance of **Redux** was passed to *Mark Erikson* and *Tim
    Dorr*. I had the chance to exchange a few messages with Mark Erikson. He explained
    to me that he’s not getting paid for maintaining **Redux**; he does it in his
    spare time, even though it can be very time-consuming. He says himself that he
    became a **Redux** maintainer by accident, but after reading his excellent blog
    post on this topic, I would say he became a **Redux** maintainer because of the
    amazing amount of work he put into **Redux** documentation and the time he spent
    helping developers who use **Redux**. You can read the full story on his blog
    (link in the *Further reading* section). Mark added that he likes maintaining
    **Redux**. He butts heads with developers who are unhappy with the decisions he’s
    making sometimes, but he also receives support from fellow OSS maintainers, as
    well as conference invites. I asked Mark what he thinks about **Redux**’s place
    in the current state management libraries landscape. He pointed out there are
    many resources (NPM statistics, GitHub statistics, etc.) proving that **Redux**
    is still by far the most widely used state management library with **React** apps.
    However, as Mark said, **Redux** was heavily over-used from 2016 to 2017\. During
    that time, a lot of developers raised legitimate complaints about the size of
    **Redux**’s boilerplate. This situation led in turn to a backlash on Twitter,
    where a lot of people made claims that “**Redux** is dead” because one tool or
    another “killed it.”
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在 2016 年，**Redux** 的维护工作转交给了 *马克·埃里克森* 和 *蒂姆·多尔*。我有机会和马克·埃里克森交换了几条信息。他告诉我，他并没有因为维护
    **Redux** 而获得报酬；他是在业余时间做的，尽管这可能会非常耗时。他自己也表示，他成为 **Redux** 的维护者是个意外，但在我阅读了他关于这个主题的优秀博客文章后，我认为他成为
    **Redux** 的维护者是因为他在 **Redux** 文档上投入了大量的工作，以及他花费时间帮助使用 **Redux** 的开发者。你可以在他的博客上阅读完整的故事（*进一步阅读*
    部分中的链接）。马克补充说，他喜欢维护 **Redux**。他有时会与对他在做决策时感到不满意的开发者发生冲突，但他也收到了来自同行 OSS 维护者以及会议邀请的支持。我询问马克他对
    **Redux** 在当前状态管理库领域的看法。他指出，有许多资源（NPM 统计数据、GitHub 统计数据等）证明 **Redux** 仍然是迄今为止在
    **React** 应用中最广泛使用的状态管理库。然而，正如马克所说，从 2016 年到 2017 年，**Redux** 被过度使用了。在那段时间里，许多开发者提出了关于
    **Redux** 模板大小合理的投诉。这种情况反过来又导致了 Twitter 上的反弹，很多人声称“**Redux** 已死”，因为某个工具或另一个“杀死了它”。
- en: “**RTK** and **React-Redux** hooks changed that narrative. If you look at discussions
    on Reddit and Twitter today, you do see a good number of folks saying how much
    they love RTK and recommending it,” Mark said.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “**RTK** 和 **React-Redux** 钩子改变了这一说法。如果你看看今天的 Reddit 和 Twitter 上的讨论，你会看到很多人表示他们非常喜欢
    **RTK** 并推荐它，”马克说。
- en: '**Redux** is currently a mature and trusted solution for managing global states
    in **React** and **React Native** apps. We’ve looked briefly at its history in
    this section. It is obvious that it has its shortcomings. To quote Mark Erikson,
    “This is a useful tool, not meant for every situation, but a very valid choice.”
    It has its fans and haters, but it’s worth knowing about – and that’s why we’re
    here! Let’s go!'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redux** 目前是管理 **React** 和 **React Native** 应用程序全局状态的一个成熟且值得信赖的解决方案。我们在这个部分简要地回顾了其历史。很明显，它有其不足之处。引用马克·埃里克森的话，“这是一个有用的工具，并不适用于所有情况，但是一个非常合理的选择。”它有它的支持者和反对者，但了解它是有价值的——这就是我们在这里的原因！让我们开始吧！'
- en: Installing and configuring Redux
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 Redux
- en: As with any library that we would like to add to our project, we will start
    by reading the documentation. The **Redux** documentation has evolved a lot over
    the years. In 2022, the recommended install includes **Redux Toolkit**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们想要添加到项目中的任何库一样，我们首先会阅读文档。**Redux** 的文档在多年中已经发生了很大的变化。到 2022 年，推荐的安装包括 **Redux
    Toolkit**。
- en: '**Redux Toolkit** is the recommended official approach to using **Redux**.
    It contains commonly used packages and dependencies for building **Redux** apps.
    This toolkit also simplifies a lot of tasks necessary for using **Redux**, such
    as creating the store or reducers. Any user is free to install and use core **Redux**,
    but we will use the recommended approach and use **Redux Toolkit**.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redux Toolkit** 是使用 **Redux** 的官方推荐方法。它包含构建 **Redux** 应用程序常用的包和依赖项。这个工具包还简化了许多使用
    **Redux** 必须完成的任务，例如创建存储或减少器。任何用户都可以自由安装和使用核心 **Redux**，但我们将使用推荐的方法并使用 **Redux
    Toolkit**。'
- en: Why not just Redux?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接使用 Redux？
- en: The Redux library has evolved a lot since its conception in 2015\. Its ecosystem
    has also grown a lot. The recommended Redux Toolkit is the most practical addition
    to Redux apps written in 2022, although it is not a necessity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 库自 2015 年构思以来已经发生了很大的变化。其生态系统也增长了很多。2022 年推荐的 Redux Toolkit 是为用 Redux
    编写的应用程序最实用的补充，尽管它不是必需的。
- en: Let’s start by going into the files for the full app, which is placed in the
    `example-app-full` folder. Feel free to work directly on those files on your computer.
    You can also fork the repository or copy the files from this folder. These files
    include everything you need to run a complete app. If you prefer to follow along
    with the working code, you should look in the `chapter-5` folder. That is where
    all completed work for this chapter is placed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从完整应用程序的文件开始，这些文件位于 `example-app-full` 文件夹中。您可以直接在您的计算机上修改这些文件。您也可以分叉存储库或从该文件夹复制文件。这些文件包括运行完整应用程序所需的所有内容。如果您想跟随工作代码，您应该查看
    `chapter-5` 文件夹。那里放置了本章所有完成的工作。
- en: 'Let’s get started. Follow these steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。按照以下步骤操作：
- en: 'Once you are inside the `app` folder, run the following command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您进入 `app` 文件夹，请运行以下命令：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will go ahead and install the complementary packages recommended in the Redux
    documentation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续安装 Redux 文档中推荐的补充包。
- en: 'Let’s run the following commands:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that the dependencies are installed, we can take a minute to talk about
    **Redux** core concepts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在依赖项已安装，我们可以花一分钟时间讨论 **Redux** 的核心概念。
- en: The main concept, and the absolute most important one, is that with **Redux**,
    we consider the state a plain object. The **Redux** documentation uses a to-do
    app as an example, but we can go ahead and use our Funbook app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 主要概念，也是绝对最重要的一个，就是我们在 **Redux** 中将状态视为一个普通对象。**Redux** 文档使用待办事项应用作为示例，但我们可以继续使用我们的
    Funbook 应用程序。
- en: 'If we were to represent the state of the logged-in user of the Funbook app
    with a single object, it may look something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要用一个单独的对象来表示 Funbook 应用程序的登录用户的状态，它可能看起来像这样：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are trying to figure out holistically what user data will
    be necessary for the entire app. This is what is considered the GLOBAL state.
    We are not going surface to surface; we want to know all the data relevant to
    the user. Therefore, in the `userData` object here, you will find data such as
    the username and email, which will be used on the **Profile** surface, an array
    of IDs of followed users, which we can use on the **Feed** surface for the list
    of avatars, and the array of IDs of conversations necessary for the **Conversations**
    surface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们试图全面了解整个应用程序所需的所有用户数据。这被认为是全局状态。我们不是面向表面；我们想知道与用户相关的所有数据。因此，在 `userData`
    对象中，您将找到用于 **Profile** 界面的用户名和电子邮件，我们可以使用 **Feed** 界面中的用户头像的跟随用户 ID 数组，以及用于 **Conversations**
    界面的必要对话 ID 数组。
- en: 'Of course, not all our app data is directly dependent on the logged-in user.
    Let’s try and imagine the shape of the part of our global state for the modals
    present on the `Feed` surface. Here’s what the state of the modal opened on an
    image click may look like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应用程序的所有数据并不直接依赖于登录用户。让我们尝试想象 `Feed` 界面上出现的模态的全局状态部分的形状。以下是图像点击打开的模态的状态可能看起来像这样：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Going around the app, we may want to consider the shape of the slice of a global
    state related to the **Conversations** surface. In my opinion, the data shape
    we fetch from the fake API set up on GitHub Pages fits very well with the shape
    of the global state:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序周围走一圈，我们可能想要考虑与 **Conversations** 界面相关的全局状态切片的形状。在我看来，我们从 GitHub Pages
    上设置的模拟 API 中获取的数据形状与全局状态的形状非常吻合：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Having the global state be the same shape as the API response is generally welcome.
    In these cases, you, as the frontend developer, will not have to reshape the data
    or remember what keys are used where and why. In a perfect world, the API responses
    would always fit the shape of the data necessary to be shown on the UI. However,
    in the real world, that may mean that the frontend would be unnecessarily fetching
    data that can be shared between surfaces, or fetching unnecessarily big datasets
    or images.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，全局状态与 API 响应具有相同的形状是受欢迎的。在这些情况下，作为前端开发人员，您将不必重塑数据或记住在何处以及为什么使用哪些键。在一个完美的世界里，API
    响应将始终适合显示在 UI 上的数据形状。然而，在现实世界中，这可能意味着前端会不必要地获取可以在多个界面之间共享的数据，或者获取不必要的大数据集或图像。
- en: 'I feel we are getting the hang of this whole idea of a global state, right?
    Feel free to try and figure out on your own what other slices of the global state
    our app may need. Maybe you can sketch out the shape of the global state necessary
    for the modal displayed when an avatar is pressed – or maybe what exactly is needed
    for the `Favorited` images surface, and the same data on the `Profile` surface.
    Come back here when you feel ready to move on to the second **Redux** concept:
    dispatching actions.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得我们正在掌握全局状态这个整体概念，对吧？请随意尝试自己思考应用可能需要的其他全局状态片段。也许你可以勾勒出当点击头像时显示的模态所需的全球状态形状——或者也许是什么具体需求对于“收藏”图像的界面，以及“个人资料”界面上的相同数据。当你准备好继续学习第二个
    **Redux** 概念：分发动作时，请回到这里。
- en: Oh hi! You’re back! Great! Let’s talk more about **Redux** then!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，你好！你回来了！太好了！那么，让我们更深入地讨论 **Redux** 吧！
- en: Dispatching actions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发动作
- en: 'Let’s say we’ve set up the global state – we replaced a lot of unnecessary
    props and we’re happy – but what if we want to change something? What if the user
    likes an image? What if the user adds a new image or follows another user? We
    need to tell our state that something has changed. This is when we will dispatch
    actions. An action is a plain JavaScript object that describes what is happening.
    We could dispatch an action that looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经设置了全局状态——我们替换了很多不必要的属性，我们很满意——但如果我们想改变某些内容呢？如果用户喜欢一张图片呢？如果用户添加了一张新图片或关注了另一个用户呢？我们需要告诉我们的状态，某些内容已经改变。这就是我们分发动作的时候。一个动作是一个描述正在发生什么的普通
    JavaScript 对象。我们可以分发一个类似这样的动作：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What now? Has the global state changed magically? Unfortunately, no. We still
    need to tell **Redux** to change the state based on this action. The missing piece
    of this puzzle that ties the actions to the state is called a reducer. Reducer
    functions are plain **JavaScript** functions that take in the old state and the
    action and return the new state of the app. Here’s what a very simple reducer
    for liked images may look like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在怎么办？全局状态神奇地改变了？不幸的是，并没有。我们仍然需要告诉 **Redux** 根据这个动作来改变状态。将动作与状态联系起来的这个谜题的缺失部分被称为
    **reducer**。Reducer 函数是接收旧状态和动作并返回应用新状态的普通 **JavaScript** 函数。以下是一个非常简单的用于收藏图片的
    reducer 示例：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are taking in the old state – in this case, the array of liked images. We
    are then adding the new item and returning the new state. We also get some very
    elegant error handling in the `else` block, where if there are any problems, the
    app will return to the old state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接收旧状态——在这种情况下，收藏图片的数组。然后我们添加新项目并返回新状态。我们还在 `else` 块中获得了非常优雅的错误处理，如果在任何地方出现问题，应用将返回到旧状态。
- en: 'I have described three concepts in this section:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节中描述了三个概念：
- en: '**The store** – the single source of truth for the global state'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存储** – 全局状态的唯一真相来源'
- en: '**Reducers** – functions that take in the old state and the action, do what
    you need them to do, and return the new state'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Reducer** – 接收旧状态和动作的函数，执行所需操作，并返回新状态'
- en: '**Actions** – plain JavaScript objects containing information for the store'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Action** – 包含存储所需信息的普通 JavaScript 对象'
- en: These are basically all you need to know to start using **Redux** effectively.
    If you would like to read more about the concepts and the history of this great
    library, check out the *Further reading* section where you’ll find links to the
    **Redux** documentation. Now that we know the basics, we are ready to apply this
    fresh knowledge to a real app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本上就是您需要了解的，以有效地开始使用 **Redux**。如果您想了解更多关于这些概念和这个伟大库的历史，请查看 *进一步阅读* 部分，在那里您可以找到
    **Redux** 文档的链接。现在我们已经了解了基础知识，我们准备将这项新知识应用到实际应用中。
- en: Adding Redux functionalities to the app
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Redux 功能添加到应用中
- en: We have installed the **Redux Toolkit** with our friendly package manager in
    the previous section, but we haven’t made any real changes in our app yet. We
    have, however, thought about the data flows in our app in the previous chapters.
    The work that we need to do now is going to be very similar. We will start by
    designing the state structure and actions. When we have both of those, we will
    add reducers to tie everything together.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经使用友好的包管理器安装了 **Redux Toolkit**，但我们在应用中还没有做出任何真正的改变。然而，我们在前面的章节中已经思考了应用中的数据流。我们现在需要做的工作将与之前非常相似。我们将从设计状态结构和动作开始。当我们有了这两者，我们将添加
    reducer 来将一切联系起来。
- en: There’s a lot of work ahead of us, so let’s try to break it down into smaller
    chunks. We will start by looking at the user state and how we could manage a user’s
    logged-in and logged-out state with a global state in **Redux**. We will then
    do that same walkthrough for liked images in our app. When we have successfully
    set up those two pieces of the global state, we will look at how we can combine
    them and use them in our app. We will then create some actions to handle events
    in the app. Once we have the state and the actions, we’ll take a brief look at
    how data can be fetched in an app with **Redux**. Finally, we will be ready to
    get rid of the **React** context we used before for managing the state of our
    app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面前还有大量的工作要做，所以让我们尝试将其分解成更小的块。我们将从查看用户状态以及如何在**Redux**中使用全局状态管理用户的登录和注销状态开始。然后我们将对应用中的喜欢图片做同样的遍历。当我们成功设置这两个全局状态的片段后，我们将看看如何将它们结合起来并在我们的应用中使用它们。然后我们将创建一些处理应用事件的actions。一旦我们有了状态和actions，我们将简要地看看如何在**Redux**应用中获取数据。最后，我们将准备好丢弃之前用于管理我们应用状态的**React**上下文。
- en: User login state walkthrough
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户登录状态遍历
- en: 'Let’s start with the user state. We will create a new file called `store.js`
    where we will store our initial state slices. We will add this **JavaScript**
    object to that file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用户状态开始。我们将创建一个名为`store.js`的新文件，我们将在这个文件中存储我们的初始状态片段。我们将向该文件添加以下**JavaScript**对象：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the app is first loaded, we will assume the user is not logged in and there
    is no user data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用首次加载时，我们将假设用户未登录且没有用户数据。
- en: 'Now, we need to think of an action that will be dispatched when the user is
    logging in. It should look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要考虑一个当用户登录时将被分发的action。它应该看起来像这样：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last part is the reducer. Let’s create a new folder for our reducers, called…
    well, `reducers`. Inside this folder, we will create our reducer file, which should
    look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是reducer。让我们为我们的reducers创建一个新的文件夹，叫做……好吧，`reducers`。在这个文件夹内，我们将创建我们的reducer文件，它应该看起来像这样：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are importing our user object as the initial state and then we’re adding
    a switch that will listen to specific actions. Let’s listen to the `'``LOGIN'`
    action.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用户对象作为初始状态导入，然后添加一个switch，它会监听特定的action。让我们监听`'LOGIN'` action。
- en: 'But wait – what if our user would like to sign out? We need another action
    specifically for this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等——如果我们的用户想要注销呢？我们需要为这个特定的操作创建另一个action：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I didn’t add any action payload in this case, because we will not be passing
    any actual data. We only want to wipe the data and we will do that in the reducer.
    We could add another ‘`if`’ statement to the reducer, but big `if-else` statements
    become difficult to read and reason about. In the case of reducers, it’s a good
    idea to use the `switch` statement, since we’re effectively switching between
    different states of the app. Here’s what our reducer will look like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我没有添加任何action payload，因为我们不会传递任何实际的数据。我们只想清除数据，我们将在reducer中这样做。我们可以在reducer中添加另一个`if`语句，但大的`if-else`语句变得难以阅读和推理。对于reducers来说，使用`switch`语句是个好主意，因为我们实际上是在切换应用的不同状态。这就是我们的reducer将看起来像这样：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: OK – now when a user logs in, we will set the global state of the app to reflect
    that, right? Almost! We still need to find the right place in our code where we
    will dispatch this action, and that place is the login button on the **Login**
    surface – but our **Login** surface is shown based on the local state of the main
    component! That means there’s still a little bit more work that we need to do
    before we will see the magic of Redux. Don’t worry though, it will be worth it!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——现在当用户登录时，我们将设置应用的全局状态以反映这一点，对吧？几乎是这样！我们仍然需要找到我们代码中正确的位置来分发这个action，而这个位置是**登录**界面的登录按钮——但是我们的**登录**界面是基于主组件的本地状态显示的！这意味着在我们看到Redux的魔法之前，我们还需要做一点额外的工作。不过别担心，这会值得的！
- en: Important information
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: If you do have any doubts about all this extra work we seem to be doing, I invite
    you, my dear reader, to read the `useReducer` hook from `useReducer` sounds familiar
    at this point, that is because it’s a **ReactJS** hook with identical functionality
    to the **Redux** reducers. I hope by now you are starting to feel convinced that
    using a state management library such as **Redux** is a great solution for React
    Native apps.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对我们似乎在做的大量额外工作有任何疑问，我邀请你，我亲爱的读者，去阅读一下`useReducer`钩子。在这个时候，`useReducer`听起来可能很熟悉，那是因为它是一个具有与**Redux**
    reducers相同功能的**ReactJS**钩子。我希望到现在你已经开始相信，使用像**Redux**这样的状态管理库是React Native应用的绝佳解决方案。
- en: You may wonder why we used a spread operator with the state and then changed
    the value of `userLoggedIn`. Theoretically, it would be easier to just change
    the value in the state, no? Not in **Redux**. **Redux** is very adamant about
    the reducers NOT being able to modify the current state. Reducers can only copy
    the state and make changes to the copied values. This is important so that our
    code is predictable. If many reducers changed the same slice of state, who’s to
    say what would be the result?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在状态中使用扩展运算符然后改变了 `userLoggedIn` 的值。理论上，直接在状态中更改值不更简单吗？不是在 **Redux**
    中。**Redux** 非常坚决地认为减少器不能修改当前状态。减少器只能复制状态并对复制的值进行更改。这很重要，这样我们的代码才是可预测的。如果有许多减少器更改了相同的状态片段，谁能说结果会是什么？
- en: Immutability
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性
- en: This is a very fancy word, isn’t it? It means that something is not capable
    of change, or that it should not be changed. In the case of JavaScript apps, immutable
    data management can increase performance and make programming and debugging easier.
    Redux reducers take in the old state and the action and return a new state object;
    they should never apply changes to the “old” state object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常复杂的词，不是吗？它的意思是指某物不可更改，或者不应该更改。在 JavaScript 应用程序的情况下，不可变数据管理可以提高性能并使编程和调试更容易。Redux
    减少器接受旧状态和动作，并返回一个新的状态对象；它们永远不应该对“旧”状态对象应用更改。
- en: If you are curious about the key concepts of **Redux**, I invite you again to
    the *Further reading* section, where you will find a link to a free course on
    [Egghead.io](http://Egghead.io), created by the author of **Redux**, *Dan Abramov*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇 **Redux** 的关键概念，我再次邀请你到 *进一步阅读* 部分，在那里你可以找到一个链接到由 **Redux** 的作者 *Dan Abramov*
    创建的免费课程 [Egghead.io](http://Egghead.io)。
- en: Using Redux for liked images
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Redux 处理点赞的图片
- en: 'Our global state is rather poor so far. Keeping the user data in the global
    state is great but we can surely do more with this great tool. How about liking
    posts? The reducer for liking posts will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的全局状态到目前为止相当薄弱。将用户数据保留在全局状态中是很好的，但我们当然可以用这个伟大的工具做更多的事情。比如点赞帖子？点赞帖子的减少器看起来像这样：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And what if the user decided to unlike a post? Let’s add an action and a reducer
    for this scenario:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户决定取消点赞一个帖子呢？让我们为这种情况添加一个动作和一个减少器：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let’s adjust our reducer. Since we have multiple actions in a single reducer,
    we will use a `switch` statement again:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调整我们的减少器。由于我们在单个减少器中有多个动作，我们将再次使用 `switch` 语句：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Combining various pieces of global state
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合各种全局状态
- en: 'We have two reducers, each one meant to manage two different actions. What
    we need to do now is create a store that will represent the global state of the
    Funbook app and pass actions into reducers. We could use the `createStore` function
    from core `configureStore` function, which will do a lot of heavy lifting for
    us. All we need to do is add this function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个减少器，每个减少器都旨在管理两个不同的动作。我们现在需要做的是创建一个表示 Funbook 应用程序全局状态的存储库并将动作传递给减少器。我们可以使用来自核心
    `configureStore` 函数的 `createStore` 函数，这将为我们做很多繁重的工作。我们只需要添加这个函数：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `configureStore` function combined our two reducers for us, creating a root
    reducer required by **Redux**. This single root reducer is required to achieve
    a single source of truth in the app. This function also adds some useful middleware
    functionalities, which will check for common mistakes and expose our code for
    easier debugging.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`configureStore` 函数为我们合并了两个减少器，创建了 **Redux** 所需的根减少器。这个单一的根减少器是实现应用程序中单一事实来源所必需的。此函数还添加了一些有用的中间件功能，这些功能将检查常见错误并使我们的代码更容易调试。'
- en: We created the global state, and we configured it with the reducers thanks to
    `<Provider>` component wrapper provided (no pun intended) by the `<Provider>`
    components. The naming convention is not an accident. Both `<Provider>` components
    serve the same purpose and **React** context uses a lot of the same high-level
    logic as **Redux**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了全局状态，并通过 `<Provider>` 组件包装器配置了它（无意中开玩笑），这个命名约定不是偶然的。两个 `<Provider>` 组件都服务于相同的目的，**React**
    上下文使用了与 **Redux** 相同的大量高级逻辑。
- en: 'Let’s import the necessary elements into our main app file, `App.js`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将必要的元素导入我们的主应用文件，`App.js`：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And let’s wrap our app in the Redux `<Provider>`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的应用包裹在 Redux `<Provider>` 中：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This looks familiar, doesn’t it? `<Provider>` shares a lot of similarities with
    **React’s** context. I cannot give you any links to official blog posts from the
    Meta team where React maintainers officially explain this. I can, however, give
    you my personal opinion that the React team saw the solution that **Redux** was
    bringing to large **React** apps and thought that some of its principles were
    worth importing into the **React** repository itself. There are other state management
    solutions out there, obviously. If there weren’t, I wouldn’t be able to write
    this book! Regardless, **Redux** holds a special place in the React ecosystem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很熟悉，不是吗？`<Provider>` 与 **React** 的上下文有很多相似之处。我无法提供任何来自 Meta 团队的官方博客文章链接，React
    维护者正式解释了这一点。然而，我可以提供我的个人观点，即 React 团队看到了 **Redux** 为大型 **React** 应用带来的解决方案，并认为其中的一些原则值得引入到
    **React** 仓库本身。显然，还有其他的状态管理解决方案。如果没有，我就无法写这本书！无论如何，**Redux** 在 React 生态系统中占据着一个特殊的位置。
- en: 'After this short break, we will dive back into our code! We have our store
    and `Provider` set up. We also have two reducers ready: for user data and liked
    images data. Let’s start with replacing the liked images. We’ll go into the `surfaces`
    folder, where we will find the Favorited surface. This, in turn, will lead us
    to the component named `ListOfFavorites`, which displays data from the Favorited
    context.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在短暂的休息之后，我们将重新回到我们的代码！我们已经设置了我们的存储和 `Provider`。我们还准备好了两个减法器：用于用户数据和喜欢的图像数据。让我们从替换喜欢的图像开始。我们将进入
    `surfaces` 文件夹，在那里我们将找到 Favorited 表面。这将反过来引导我们到名为 `ListOfFavorites` 的组件，该组件显示来自
    Favorited 上下文的数据。
- en: 'We will remove this context and use `useSelector` hook from Redux, and then
    we will fetch the actual data from **Redux** using this hook:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将移除这个上下文，并使用 Redux 的 `useSelector` 钩子，然后我们将使用这个钩子从 **Redux** 获取实际数据：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Do you have our app running on your phone or in the simulator? I hope you do
    because then you will notice something just went very wrong!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你在我们的手机或模拟器上运行我们的应用了吗？我希望你已经运行了，因为这样你就会注意到刚刚发生了一些非常错误的事情！
- en: '![Figure 5.2 – iPhone simulator screenshot with a Redux error ](img/Figure_5.02_B18396.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 带有 Redux 错误的 iPhone 模拟器截图](img/Figure_5.02_B18396.jpg)'
- en: Figure 5.2 – iPhone simulator screenshot with a Redux error
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 带有 Redux 错误的 iPhone 模拟器截图
- en: '`switch` statement in the `likedImages` reducer! This is not really the default
    that we want, so let’s go ahead and change it so that it returns the initial state
    by default:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`likedImages` 减法器中的 `switch` 语句！这并不是我们想要的默认值，所以让我们继续修改，让它默认返回初始状态：'
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The app loads correctly – we’re back in business! We are passing the initial
    state as the default value to the `likedImages` reducer, which means we are passing
    an empty array – but we want to fetch image data. We did this before in the Context
    Providers using `fetch`. `FavoritedContextProvided` used React’s `useReducer`
    hook along with an `init_likes` action dispatched when the images were fetched
    successfully. When it comes to `Provider`. We will create a fetching function
    inside an action, and then we will dispatch that action when the Favorited surface
    is rendered. This is a simplistic solution for a simple app. If you are working
    on a bigger app, you would probably need to concern yourself with caching, avoiding
    duplicate requests or a cache lifetime. In that case, you should look into a tool
    provided by Redux Toolkit, called RTK Query, which simplifies data fetching and
    caching in Redux apps.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正确加载 – 我们又重新开始工作了！我们将初始状态作为默认值传递给 `likedImages` 减法器，这意味着我们传递了一个空数组 – 但我们想要获取图像数据。我们之前在上下文提供者中使用
    `fetch` 做过这件事。`FavoritedContextProvided` 使用了 React 的 `useReducer` 钩子，以及当图像成功获取时发出的
    `init_likes` 动作。当涉及到 `Provider` 时，我们将在一个动作中创建一个获取函数，然后当 Favorited 表面被渲染时，我们将发出这个动作。这是一个针对简单应用的简单解决方案。如果你正在开发一个更大的应用，你可能需要关注缓存、避免重复请求或缓存有效期。在这种情况下，你应该查看
    Redux Toolkit 提供的工具，称为 RTK 查询，它简化了 Redux 应用中的数据获取和缓存。
- en: A full toolbelt
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的工具包
- en: It may start to feel overwhelming learning about so many tools at once. We started
    with Redux, continued with Redux Toolkit, and now we’re adding RTK Query. Don’t
    worry too much at this point about libraries and tool names. We’re here to learn
    how to effectively write an app with a state managed by Redux, and we’re following
    the documentation and best practices to do so. Once you’re familiar with the suggested
    solution, feel free to look around the Redux ecosystem and find the approach that
    you like the most. There are no wrong answers when it comes to what you like and
    don’t like!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 同时学习这么多工具可能会开始感到有些压倒性。我们开始使用Redux，然后继续使用Redux Toolkit，现在我们正在添加RTK Query。在这个阶段，不必太担心库和工具的名称。我们在这里是为了学习如何有效地使用Redux管理状态来编写应用程序，并且我们正在遵循文档和最佳实践来做这件事。一旦你熟悉了建议的解决方案，你可以自由地探索Redux生态系统，找到你最喜欢的方法。关于你喜欢和不喜欢的东西，没有错误答案！
- en: Taking advantage of Redux Toolkit for creating actions
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用Redux Toolkit创建动作
- en: 'Our reducer is very limited so far. We can’t use it directly to fetch data,
    because as the rules of reducers state, reducers cannot be used to do any asynchronous
    logic. If we were writing our app sometime around 2018 or 2019, we would probably
    create a separate `actions` file, manually configure `createSlice`. A “slice”
    in `likedImages` reducer into a **Redux** Toolkit slice:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的红利器到目前为止非常有限。我们不能直接用它来获取数据，因为根据reducer状态规则，reducer不能用于执行任何异步逻辑。如果我们是在2018年或2019年左右编写应用程序，我们可能会创建一个单独的`actions`文件，手动配置`createSlice`。在`likedImages`reducer中，“slice”是一个**Redux
    Toolkit**切片：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Fetching data
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取数据
- en: Since `createAsyncThunk` function from **Redux Toolkit**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**Redux Toolkit**中的`createAsyncThunk`函数。
- en: What’s a thunk?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是thunk？
- en: A thunk is a special sort of function that’s returned by another function. This
    name is not related to **Redux** itself.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: thunk是一种特殊的函数，由另一个函数返回。这个名字与**Redux**本身无关。
- en: 'Here’s what our fetching thunk will look like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的获取数据thunk将看起来像：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we need to tell our `extraReducers` function provided by **Redux Toolkit**
    to keep our reducer clean and readable:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉由**Redux Toolkit**提供的`extraReducers`函数，以保持我们的reducer整洁和可读：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we have a pretty elegant way to manage fetching, including a pending
    state and rejected state, let’s actually fetch our data. We should not fetch it
    in the `ListOfFavorited` component, because we need to have the image data available
    as soon as the entire app is rendered. We should fetch the images in the parent
    component, `Home`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一种相当优雅的方式来管理获取数据，包括挂起状态和拒绝状态，让我们实际获取我们的数据。我们不应该在`ListOfFavorited`组件中获取它，因为我们需要在整个应用程序渲染后立即获取图像数据。我们应该在父组件`Home`中获取图像：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This way, the liked images data will be fetched when the app is rendered and
    the user is on the `ListOfFavorites` component:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当应用程序渲染并且用户在`ListOfFavorites`组件上时，将获取喜欢的图像数据：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You may have noticed how the fetched data is passed to the state hook:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了获取的数据是如何传递给状态钩子的：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are using the ES6 spread operator in order to apply the `reverse()` function
    to a copy of the `likedImages` array. This is because the `likedImages` array
    is read-only and we cannot operate directly on it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用ES6扩展运算符来将`reverse()`函数应用于`likedImages`数组的副本。这是因为`likedImages`数组是只读的，我们无法直接对其操作。
- en: Replacing the context
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换上下文
- en: Take a moment to look at what you have accomplished. You effectively replaced
    the Favorited context with Redux! The last thing we need to do is to replace the
    actions when an image is liked or not and then we’ll be ready to do some cleanup!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 抽取一点时间来审视你所取得的成就。你有效地用Redux替换了Favorited上下文！我们最后需要做的就是替换当图像被喜欢或不喜欢时的动作，然后我们就可以做一些清理工作了！
- en: 'Let’s go into the `ImageDetailsModal` surface and replace context-related code
    with Redux code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入`ImageDetailsModal`界面，并将与上下文相关的代码替换为Redux代码：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last thing we need to change is the function called when the **Like** button
    is clicked on:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要更改的是当点击**喜欢**按钮时调用的函数：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And we’re done with applying `Favorited` context **Provider**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了应用`Favorited`上下文**Provider**。
- en: Our app consists of functional components only, so we can use `mapStateToProps`
    and `mapDispatchToProps`. Modern **React** apps can be built without class components
    though – as you can see in the Funbook app.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序仅由功能组件组成，因此我们可以使用`mapStateToProps`和`mapDispatchToProps`。尽管如此，现代**React**应用程序可以不使用类组件来构建——正如你在Funbook应用程序中看到的那样。
- en: 'In this section, you learned how to create a Redux store for the user state
    and liked images. We added reducers for both pieces of the store, as well as actions.
    We took advantage of a few utilities provided by Redux Toolkit to make our lives
    easier. We pulled it all together and were finally able to remove a little bit
    of React’s context. Replacing all other pieces of context with **Redux** is a
    very good exercise to get the hang of this state management library. If you prefer
    to just take a look at what it would look like, check out the book repo and the
    folder: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何创建用于用户状态和喜欢图片的Redux存储库。我们为存储库的两个部分添加了reducer以及动作。我们利用Redux Toolkit提供的一些实用工具使我们的工作更轻松。我们将所有这些整合在一起，最终能够减少一些React的上下文。用**Redux**替换所有其他上下文是一个很好的练习，可以帮助你熟悉这个状态管理库。如果你只想看看它看起来会是什么样子，请查看书籍仓库和文件夹：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete)。
- en: We will now take a look at handling problems and debugging issues that may arise
    while using Redux.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨在使用Redux时可能出现的处理问题和调试问题。
- en: Debugging
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: 'Our Funbook app is quite simple so far. However, when working with bigger apps
    you will notice that the state becomes more and more complicated with every added
    feature. Sometimes, features have overlapping states or complex actions, responsible
    for many things happening across the app. In order to hunt down bugs related to
    complex state changes, we can use a dedicated debugger. Configuring developer
    tools in a bare **Redux** app takes a couple of steps, but we’re using **Redux
    Toolkit**! And it comes to the rescue yet again. **Redux Toolkit** is preconfigured
    to work with the **Redux** DevTools extension, which runs in the browser. Since
    we are working on a React Native app, we will need to use another tool, called
    **React Native** Debugger. Mac users can install it using the Homebrew tool:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Funbook应用程序目前相当简单。然而，当与更大的应用程序一起工作时，你会注意到随着每个新功能的添加，状态变得越来越复杂。有时，功能具有重叠的状态或复杂的操作，负责应用程序中发生的许多事情。为了追踪与复杂状态变化相关的错误，我们可以使用专门的调试器。在裸**Redux**应用程序中配置开发工具需要几个步骤，但我们使用的是**Redux
    Toolkit**！它再次伸出援手。**Redux Toolkit**预先配置为与**Redux** DevTools扩展一起工作，该扩展在浏览器中运行。由于我们正在开发React
    Native应用程序，我们需要使用另一个工具，称为**React Native**调试器。Mac用户可以使用Homebrew工具安装它：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you’re not using a Mac computer, you will find a prebuilt binary of this
    app on their installation instructions page: [https://github.com/jhen0409/react-native-debugger](https://github.com/jhen0409/react-native-debugger).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是使用Mac电脑，你将在他们的安装说明页面上找到一个预构建的二进制文件：[https://github.com/jhen0409/react-native-debugger](https://github.com/jhen0409/react-native-debugger)。
- en: 'Once the remote Debugger is installed, you can run it by typing the following
    command into your Terminal:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦远程调试器安装完成，你可以在终端中输入以下命令来运行它：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since we are using **Expo**, there are a few changes we need to make to actually
    be able to debug our app. So far, the **React** **Native** Debugger tool with
    the default config has not found our app:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是**Expo**，我们需要做一些更改才能实际调试我们的应用程序。到目前为止，默认配置的**React Native**调试工具还没有找到我们的应用程序：
- en: '![Figure 5.3 – React Native Debugger after installation ](img/Figure_5.03_B18396.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 安装后的React Native调试器](img/Figure_5.03_B18396.jpg)'
- en: Figure 5.3 – React Native Debugger after installation
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 安装后的React Native调试器
- en: 'We need to tell `19000`. You will probably need to stop the debugger and the
    app, then run the following command to open React Native Debugger on the right
    port:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉`19000`。你可能需要停止调试器和应用程序，然后运行以下命令以在正确的端口上打开React Native调试器：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, restart the app by stopping the server in the Terminal and rerunning
    it as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在终端中停止服务器并重新运行以下命令来重新启动应用程序：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**React Native** Debugger is a very useful tool, not only for debugging Redux
    but also for inspecting all sorts of bugs in **React** **Native** apps.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Native**调试器是一个非常有用的工具，不仅用于调试Redux，还用于检查**React Native**应用程序中的各种错误。'
- en: In this section, we went over installing and using the **React Native** Debugger
    tool. I encourage you to look around this very useful tool, inspect the app, and
    maybe add some bad code to see what an error in this tool may look like.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讲解了如何安装和使用**React Native**调试工具。我鼓励你探索这个非常有用的工具，检查应用，也许可以添加一些错误的代码来看看这个工具中的错误可能是什么样子。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve come a long way on our journey through the state management ecosystem.
    In this chapter, we talked about what is considered the most common solution for
    state management in `example-app-full` as our starting point and try to replace
    the `LikedImages` context as we did with **Redux**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们穿越状态管理生态系统的旅途中我们已经走了很长的路。在本章中，我们以`example-app-full`作为起点，讨论了被认为是该应用中最常见的状态管理解决方案，并尝试用**Redux**替换`LikedImages`上下文。
- en: Further reading
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://redux.js.org/introduction/why-rtk-is-redux-today](https://redux.js.org/introduction/why-rtk-is-redux-today)
    – Why use Redux Toolkit?'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/introduction/why-rtk-is-redux-today](https://redux.js.org/introduction/why-rtk-is-redux-today)
    – 为什么使用Redux Toolkit？'
- en: '[https://redux.js.org/introduction/core-concepts](https://redux.js.org/introduction/core-concepts)
    – Redux core concepts.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/introduction/core-concepts](https://redux.js.org/introduction/core-concepts)
    – Redux核心概念。'
- en: '[https://blog.isquaredsoftware.com/2016/09/how-i-got-here-my-journey-into-the-world-of-redux-and-open-source/](https://blog.isquaredsoftware.com/2016/09/how-i-got-here-my-journey-into-the-world-of-redux-and-open-source/)
    – Mark Erikson’s blog on how he became a Redux maintainer.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blog.isquaredsoftware.com/2016/09/how-i-got-here-my-journey-into-the-world-of-redux-and-open-source/](https://blog.isquaredsoftware.com/2016/09/how-i-got-here-my-journey-into-the-world-of-redux-and-open-source/)
    – Mark Erikson关于他成为Redux维护者的博客。'
- en: '[https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/](https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/)
    – Redux is not dead.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/](https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/)
    – Redux并未死去。'
- en: '[https://egghead.io/courses/fundamentals-of-redux-course-from-dan-abramov-bd5cc867](https://egghead.io/courses/fundamentals-of-redux-course-from-dan-abramov-bd5cc867)
    – Egghead tutorial by Dan Abramov.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://egghead.io/courses/fundamentals-of-redux-course-from-dan-abramov-bd5cc867](https://egghead.io/courses/fundamentals-of-redux-course-from-dan-abramov-bd5cc867)
    – Dan Abramov的Egghead教程。'
- en: '[https://stackoverflow.com/a/34582848/8798164](https://stackoverflow.com/a/34582848/8798164)
    – Stack Overflow answer about state mutations.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://stackoverflow.com/a/34582848/8798164](https://stackoverflow.com/a/34582848/8798164)
    – 关于状态变更的Stack Overflow回答。'
- en: '[https://redux.js.org/tutorials/essentials/part-2-app-structure#rules-of-reducers](https://redux.js.org/tutorials/essentials/part-2-app-structure#rules-of-reducers)
    – Rules of Reducers.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://redux.js.org/tutorials/essentials/part-2-app-structure#rules-of-reducers](https://redux.js.org/tutorials/essentials/part-2-app-structure#rules-of-reducers)
    – Reducers的规则。'
- en: '[https://daveceddia.com/what-is-a-thunk/](https://daveceddia.com/what-is-a-thunk/)
    – what is a thunk?'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://daveceddia.com/what-is-a-thunk/](https://daveceddia.com/what-is-a-thunk/)
    – 什么是thunk？'
