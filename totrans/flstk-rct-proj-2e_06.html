<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Adding a React Frontend to Complete MERN</h1>
                </header>
            
            <article>
                
<p class="mce-root">A <span>web application is incomplete without a frontend. It is the part that users interact with and it is crucial to any web experience. In this chapter, we will use React to add an interactive user interface to the basic user and auth features that have been implemented for the backend of the MERN skeleton application, which we started building in the previous chapter. This f</span><span>unctional frontend will add React components that connect to the backend API and allow users to navigate seamlessly within the application based on authorization. By the end of this chapter, you will have learned how to easily integrate a React client-side with a Node-Express-MongoDB server-side to make a full-stack web application.</span></p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li style="font-weight: 400">Frontend features of the skeleton</li>
<li style="font-weight: 400">Setting up development with React, React Router, and Material-UI</li>
<li>Rendering a home page built with React</li>
<li style="font-weight: 400">Backend user API integration</li>
<li style="font-weight: 400">Auth integration for restricted access</li>
<li style="font-weight: 400">User list, profile, edit, delete, sign up, and sign in UI to complete the user frontend</li>
<li style="font-weight: 400">Basic server-side rendering</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the skeleton application frontend</h1>
                </header>
            
            <article>
                
<p>In order to fully implement the skeleton application features we discussed in the <em>Feature breakdown</em> section of <a href="" target="_blank">Chapter 3</a>, <em>Building a Backend with MongoDB, Express, and Node</em>, we will add the following user interface components to our base application:</p>
<ul>
<li style="font-weight: 400"><strong>Home page</strong>: A view that renders at the root URL to welcome users to the web application.</li>
<li style="font-weight: 400"><strong>Sign-up page</strong>: A view with a form for user sign-up, allowing new users to create a user account and redirecting them to a sign-in page when successfully created.</li>
<li style="font-weight: 400"><strong>Sign-in page</strong>: A view with a sign-in form that allows existing users to sign in so they have access to protected views and actions.</li>
<li style="font-weight: 400"><strong>User list page</strong>: A view that fetches and shows a list of all the users in the database, and also links to individual user profiles.</li>
<li style="font-weight: 400"><strong>Profile page</strong>: A component that f<span>etches and displays an individual user's information. This i</span>s only accessible by signed-in users and also contains edit and delete options, which are only visible if the signed-in user is looking at their own profile.</li>
<li style="font-weight: 400"><strong>Edit profile page</strong>: A form that fetches the user's information to prefill the form fields. This allows the user to edit the information and this form is accessible only if the logged-in user is trying to edit their own profile.</li>
<li style="font-weight: 400"><strong>Delete user component</strong>: An option that allows the signed-in user to delete their own profile after confirming their intent.</li>
<li style="font-weight: 400"><strong>Menu navigation bar</strong>: A component that lists all the available and relevant views to the user, and also helps to indicate the user's current location in the application.</li>
</ul>
<p>The following React component tree diagram shows all the React components we will develop to build out the views for this base application:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-779 image-border" src="assets/dbd95d4d-c412-47f9-af09-4e8e52f511aa.png" style="width:32.17em;height:19.17em;"/></div>
<p><strong>MainRouter</strong> will be the main React component. This contains all the other custom React views in the application. <strong>Home</strong>, <strong>Signup</strong>, <strong>Signin</strong>, <strong>Users</strong>, <strong>Profile</strong>, and <strong>EditProfile</strong> will render at individual routes declared with React Router, whereas the <strong>Menu</strong> component will render across all these views. <strong>DeleteUser</strong> will be a part of the <strong>Profile</strong> view.</p>
<div class="packt_tip"><span>The code discussed in this chapter, as well as the complete skeleton, is available on GitHub at</span> <a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton" target="_blank">https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter03%20and%2004/mern-skeleton</a>. <span>You can clone this code and run the application as you go through the code explanations in the rest of this chapter. </span></div>
<p>In order to implement these frontend React views, we will have to extend the existing project code, which contains the standalone server application for the MERN skeleton. Next, we'll take a brief look at the files that will make up this frontend and that are needed to complete the full-stack skeleton application code.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Folder and file structure</h1>
                </header>
            
            <article>
                
<p>The following folder structure shows the new folders and files to be added to the skeleton project we started implementing in the previous chapter, in order to complete it with a React frontend:</p>
<pre>| mern_skeleton/<br/>   | -- client/<br/>      | --- assets/<br/>         | ---- images/<br/>      | --- auth/<br/>         | ---- api-auth.js<br/>         | ---- auth-helper.js<br/>         | ---- PrivateRoute.js<br/>         | ---- Signin.js<br/>      | --- core/<br/>         | ---- Home.js<br/>         | ---- Menu.js<br/>      | --- user/<br/>         | ---- api-user.js<br/>         | ---- DeleteUser.js<br/>         | ---- EditProfile.js<br/>         | ---- Profile.js<br/>         | ---- Signup.js<br/>         | ---- Users.js<br/>      | --- App.js<br/>      | --- main.js<br/>      | --- MainRouter.js<br/>      | --- theme.js<br/>  | -- server/<br/>      | --- devBundle.js<br/>  | -- webpack.config.client.js<br/>  | -- webpack.config.client.production.js</pre>
<p>The <kbd>client</kbd> folder will contain the React components, helpers, and frontend assets, such as images and CSS. Besides this folder and the Webpack configuration files for compiling and bundling the client code, we will also modify some of the other existing files to finish up the integration of the complete skeleton application in this chapter.</p>
<p>Before we start implementing the specific frontend features, we need to get set up for React development by installing the necessary modules and adding configuration to compile, bundle, and load the React views. We will go through these setup steps in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up for React development</h1>
                </header>
            
            <article>
                
<p>Before we can start developing with React in our existing skeleton codebase, we need to add configuration to compile and bundle the frontend code, add the React-related dependencies that are necessary to build the interactive interface, and tie this all together in the MERN development flow.</p>
<p class="mce-root"/>
<p>To achieve this, we will add frontend configuration for Babel, Webpack, and React Hot Loader to compile, bundle, and hot reload the code. Next, we will modify the server code to initiate code bundling for both the frontend and backend in one command to make the development flow simple. Then, we will update the code further so that it serves the bundled code from the server when the application runs in the browser. Finally, we will finish setting up by installing the React dependencies that are necessary to start implementing the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Babel and Webpack</h1>
                </header>
            
            <article>
                
<p>It is necessary to compile and bundle the React code that we will write to implement the frontend before the code can run in browsers. To compile and bundle the client code so that we can run it during development and also bundle it for production, we will update the configuration for Babel and Webpack. Then, we will configure the Express app to initiate frontend and backend code bundling in one command, so that just starting the server during development gets the complete stack ready for running and testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Babel</h1>
                </header>
            
            <article>
                
<p>To compile React, first, install the Babel React preset module as a development dependency by running the following command from the command line:</p>
<pre><strong>yarn add --dev @babel/preset-react </strong></pre>
<p>Then, update <kbd>.babelrc</kbd> with the following code. This will include the module and also configure the <kbd>react-hot-loader</kbd> Babel plugin as required for the <kbd>react-hot-loader</kbd> module.</p>
<p><kbd>mern-skeleton/.babelrc</kbd>:</p>
<pre>{<br/>    "presets": [<br/>      ["@babel/preset-env",<br/>        {<br/>          "targets": {<br/>            "node": "current"<br/>          }<br/>        }<br/>      ],<br/>      <strong>"@babel/preset-react"</strong><br/>    ],<br/>    <strong>"plugins": [</strong><br/><strong>      "react-hot-loader/babel"</strong><br/><strong>    ]</strong><br/>}</pre>
<p>To put this updated Babel configuration to use, we need to update the Webpack configuration, which we will look at in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Webpack</h1>
                </header>
            
            <article>
                
<p>To bundle client-side code after compiling it with Babel, and also to enable <kbd>react-hot-loader</kbd> for faster development, install the following modules by running these commands from the command line:</p>
<pre><strong>yarn add -dev webpack-dev-middleware webpack-hot-middleware file-loader<br/>yarn add react-hot-loader @hot-loader/react-dom</strong></pre>
<p>Then, to configure Webpack for frontend development and to build the production bundle, we will add a <kbd>webpack.config.client.js</kbd> file and a <span><kbd>webpack.config.client.production.js</kbd> file </span>with the same configuration code we described in <a href="fd935468-e403-4363-80b0-2d13845ea65c.xhtml" target="_blank">Chapter 2</a>, <em>Preparing the Development Environment</em>.</p>
<p>With Webpack configured and ready for bundling the frontend React code, next, we will add some code that we can use in our development flow. This will make the full-stack development process seamless.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading Webpack middleware for development</h1>
                </header>
            
            <article>
                
<p>During development, when we run the server, the Express app should also load the Webpack middleware that's relevant to the frontend with respect to the configuration that's been set for the client-side code, so that the frontend and backend development workflow is integrated. To enable this, we will use the <kbd>devBundle.js</kbd> file we discussed in <a href="fd935468-e403-4363-80b0-2d13845ea65c.xhtml" target="_blank">Chapter 2</a>, <em>Preparing the Development Environment</em>, in order <span>to set up a <kbd>compile</kbd> method that takes the Express app and configures it</span><span> to use the Webpack middleware. The <kbd>devBundle.js</kbd></span><span> file in the <kbd>server</kbd> folder will look as follows.</span></p>
<p><span><kbd>mern-skeleton/server/devBundle.js</kbd>:</span></p>
<pre>import config from './../config/config'<br/>import webpack from 'webpack'<br/>import webpackMiddleware from 'webpack-dev-middleware'<br/>import webpackHotMiddleware from 'webpack-hot-middleware'<br/>import webpackConfig from './../webpack.config.client.js'<br/><br/>const compile = (app) =&gt; {<br/>  if(config.env === "development"){<br/>    const compiler = webpack(webpackConfig)<br/>    const middleware = webpackMiddleware(compiler, {<br/>      publicPath: webpackConfig.output.publicPath<br/>    })<br/>    app.use(middleware)<br/>    app.use(webpackHotMiddleware(compiler))<br/>  }<br/>}<br/><br/>export default {<br/>  compile<br/>}</pre>
<p>In this method, the Webpack middleware uses the values set in <kbd>webpack.config.client.js</kbd>, and we enable hot reloading from the server-side u<span>sing Webpack Hot Middleware</span>.  </p>
<p>Finally, we need to <span>import and call this <kbd>compile</kbd> method in </span><kbd>express.js</kbd><span> by adding the following highlighted lines, but only during development.</span></p>
<p><kbd><span>mern-skeleton/server/express.js</span></kbd>:</p>
<pre><span><strong>import devBundle from './devBundle'</strong><br/>const app = express()<br/><strong>devBundle.compile(app)</strong><br/></span></pre>
<p>These two highlighted lines are only meant for development mode and should be commented out when building the code for production. W<span>hen the Express app runs in development mode, adding t</span>his code will import the middleware, along with the <span>client-side </span>Webpack configuration. Then, it will initiate Webpack to compile and bundle the client-side code and also enable hot reloading.</p>
<p>The bundled code will be placed in the <kbd>dist</kbd> folder. This code will be needed to render the views. Next, we will configure the Express server app so that it serves the static files from this <kbd>dist</kbd> folder. This will ensure that the bundled React code can be loaded in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading bundled frontend code</h1>
                </header>
            
            <article>
                
<p>The frontend views that we will see rendered in the browser will load from the bundled files in the <kbd>dist</kbd> folder. For it to be possible to add these bundled files to the HTML view containing our frontend, we need to configure the Express app so that it serves static files, which are files that aren't generated dynamically by server-side code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serving static files with Express</h1>
                </header>
            
            <article>
                
<p>To ensure that the Express server properly handles the requests to static files such as CSS files, images, or the bundled client-side JS, we will configure it so that it serves static files from the <kbd>dist</kbd> folder by adding the following configuration in <kbd>express.js</kbd>.</p>
<p><kbd><span>mern-skeleton/server/express.js</span></kbd>:</p>
<pre>import path from 'path'<br/>const CURRENT_WORKING_DIR = process.cwd()<br/>app.use('/dist', express.static(path.join(CURRENT_WORKING_DIR, 'dist')))</pre>
<p>With this configuration in place, when the Express app receives a request at a route starting with <kbd>/dist</kbd>, it will know to look for the requested static resource in the <kbd>dist</kbd> folder before returning the resource in the response. Now, we can load the bundled files from the <kbd>dist</kbd> folder in the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the template to load a bundled script</h1>
                </header>
            
            <article>
                
<p>To add the bundled frontend code in the HTML to render our React frontend, we will update the <kbd>template.js</kbd> file so that it adds the script file from the <kbd>dist</kbd> folder to the end of the <kbd>&lt;body&gt;</kbd> tag.</p>
<p><kbd><span>mern-skeleton/template.js</span></kbd>:</p>
<pre><span class="sb">...<br/>&lt;body&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;</span>
    <span class="sb"><strong>&lt;script type="text/javascript" src="/dist/bundle.js"&gt;&lt;/script&gt;</strong><br/>&lt;/body&gt;</span></pre>
<p class="mce-root">This script tag will load our React frontend code in the browser when we visit the root URL <kbd>'/'</kbd> with the server running. We are ready <span>to see this in action and can</span> start installing the dependencies that will add the React views.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding React dependencies</h1>
                </header>
            
            <article>
                
<p>The frontend views in our skeleton application will primarily be implemented using React. In addition, to enable client-side routing, we will use React Router, and to enhance the user experience with a sleek look and feel, we will use Material-UI. To add these libraries, we will install the following modules in this section:</p>
<ul>
<li><strong>Core React modules</strong>: <kbd>react</kbd> and <kbd>react-dom</kbd> </li>
<li><strong>React Router modules</strong>: <kbd>react-router</kbd> and <kbd>react-router-dom</kbd></li>
<li><strong>Material-UI modules</strong>: <kbd>@material-ui/core</kbd> and <kbd>@material-ui/icons</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">React</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we will use React to code up the frontend. To start writing the React component code, we will need to install the following modules as regular dependencies:</p>
<pre><strong>yarn add react react-dom</strong></pre>
<p>These are the core React library modules that are necessary for implementing the React-based web frontend. With other additional modules, we will add more functionality on top of React.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">React Router</h1>
                </header>
            
            <article>
                
<p>React Router provides a collection of navigational components that enable routing on the frontend for React applications. We will add the following React Router modules:</p>
<pre><strong>yarn add react-router react-router-dom</strong></pre>
<p><span>These modules will let us utilize declarative routing and have bookmarkable URL routes in the frontend.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Material-UI</h1>
                </header>
            
            <article>
                
<p>In order to keep the UI in our MERN applications sleek without delving too much into UI design and implementation, we will utilize the Material-UI library. It provides ready to use and customizable React components that implement Google's material design. To start using Material-UI components to make the frontend, we need to install the following modules:</p>
<pre><strong>yarn add @material-ui/core @material-ui/icons </strong></pre>
<div class="packt_infobox">At the time of writing, the latest version of Material-UI is <kbd>4.9.8</kbd>. It is recommended that you install this exact version in order to ensure the code for the example projects does not break.</div>
<p>To add the <kbd>Roboto</kbd><span> fonts that are </span><span>recommended by </span>Material-UI and to use the <kbd>Material-UI</kbd> icons, we will add the relevant style links into the <kbd>template.js</kbd> file, in the HTML document's <kbd>&lt;head&gt;</kbd> section:</p>
<pre>&lt;link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400"&gt;<br/>&lt;link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"&gt;</pre>
<p>With the development configuration all set up and the necessary React modules added to the code base, we can now implement the custom React components, starting with a home page. This should load up as the first view of the complete application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering a home page view </h1>
                </header>
            
            <article>
                
<p><span>To demonstrate how to implement a functional frontend for this MERN skeleton, we will start by detailing how to render a simple home page at the root route of the application, before covering backend API integration, user auth integration, and implementing the other view components in the rest of this chapter.</span></p>
<p>The process of implementing and rendering a working <kbd>Home</kbd> component at the root route will also expose the basic structure of the frontend code in the skeleton. We will start with the top-level entry component that houses the whole React app and renders the main router component, which links all the React components in the application.</p>
<p class="mce-root"/>
<p>In the following sections, we will begin implementing the React frontend. First, we will add the root React component, which is <span>integrated with React Router and Material-UI and </span>configured for hot reloading. We will also learn how to customize the Material-UI theme and make the theme available to all our components. Finally, we will implement and load the React component representing the home page, in turn demonstrating how to add and render React views in this application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entry point at main.js</h1>
                </header>
            
            <article>
                
<p>The <kbd>client/main.js</kbd> file in the client folder will be the entry point to render the complete React app, as already indicated in the client-side Webpack configuration object. In <kbd>client/main.js</kbd>, we import the root or top-level React component that will contain the whole frontend and render it to the <kbd>div</kbd> element with the <span><kbd>'root'</kbd> ID specified </span>in the HTML document<span> in</span> <kbd>template.js</kbd>.</p>
<p><kbd><span>mern-skeleton/client/main.js</span></kbd>:</p>
<pre>import React from 'react'<br/>import { render } from 'react-dom'<br/>import App from './App'<br/><br/>render(&lt;App/&gt;, document.getElementById('root'))</pre>
<p>Here, the top-level root React component is the <kbd>App</kbd> component and it is being rendered in the HTML. The <kbd>App</kbd> component is defined in <kbd>client/App.js</kbd>, as discussed in the next subsection. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Root React component</h1>
                </header>
            
            <article>
                
<p>The top-level React component that will contain all the components for the application's frontend is defined in the <kbd>client/App.js</kbd> file. In this file, we <span>configure the React app so that it renders the view components with a customized Material-UI theme, enables frontend routing, and ensures that the React Hot Loader can instantly load changes as we develop the components.</span></p>
<p><span>In the following sections, we will add code to customize the theme, make this theme and React Router capabilities available to our React components, and configure the root component for hot reloading. </span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing the Material-UI theme</h1>
                </header>
            
            <article>
                
<p>The Material-UI theme can be easily customized using the <kbd>ThemeProvider</kbd> component. It can also be used to configure the custom values of theme variables in <kbd>createMuiTheme()</kbd>. We will define a custom theme for the skeleton application in <kbd>client/theme.js</kbd> using <kbd>createMuiTheme</kbd>, and then export it so that it can be used in the <kbd>App</kbd> component.</p>
<p><kbd><span>mern-skeleton/client/theme.js</span></kbd>:</p>
<pre><span class="kr">import { createMuiTheme } from '@material-ui/core/styles'<br/>import { pink } from '@material-ui/core/colors'<br/><br/>const theme = createMuiTheme({<br/>    typography: {<br/>      useNextVariants: true,<br/>    },<br/>    palette: {<br/>      primary: {<br/>      light: '#5c67a3',<br/>      main: '#3f4771',<br/>      dark: '#2e355b',<br/>      contrastText: '#fff',<br/>    },<br/>    secondary: {<br/>      light: '#ff79b0',<br/>      main: '#ff4081',<br/>      dark: '#c60055',<br/>      contrastText: '#000',<br/>    },<br/>      openTitle: '#3f4771',<br/>      protectedTitle: pink['400'],<br/>      type: 'light'<br/>    }<br/>})<br/><br/>export default theme</span></pre>
<p>For the skeleton, we only apply minimal customization by setting some color values to be used in the UI. The theme variables that are generated here will be passed to, and available in, all the components we build.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping the root component with ThemeProvider and BrowserRouter</h1>
                </header>
            
            <article>
                
<p>The custom React components that we will create to make up the user interface will be accessed with the frontend routes specified in the <kbd>MainRouter</kbd> component. Essentially, this component houses all the custom views that have been developed for the application and needs to be given the theme values and routing features. This component will be our core component in the root <kbd>App</kbd> component, which is defined in the following code.</p>
<p><kbd><span>mern-skeleton/client/App.js</span></kbd>:</p>
<pre>import React from 'react'<br/>import MainRouter from './MainRouter'<br/>import {BrowserRouter} from 'react-router-dom'<br/>import { ThemeProvider } from '@material-ui/styles'<br/>import theme from './theme'<br/><br/>const App = () =&gt; {<br/>  return (<br/>    &lt;BrowserRouter&gt;<br/>      &lt;ThemeProvider theme={theme}&gt;<br/>        &lt;MainRouter/&gt;<br/>      &lt;/ThemeProvider&gt;<br/>    &lt;/BrowserRouter&gt;<br/>)}</pre>
<p><span>When defining this root component in </span><kbd>App.js</kbd><span>, we wrap the </span><kbd>MainRouter</kbd><span> component with</span> <kbd>ThemeProvider</kbd><span>, which gives it access to the Material-UI theme, and </span><kbd>BrowserRouter</kbd><span>, which enables frontend routing with React Router. The custom theme variables we defined previously are passed as a prop to</span> <kbd>ThemeProvider</kbd><span>, making the theme available in all our custom React components. Finally, in the <kbd>App.js</kbd> file, we need to export this <kbd>App</kbd> component so that it can be imported and used in <kbd>main.js</kbd>.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Marking the root component as hot-exported</h1>
                </header>
            
            <article>
                
<p>The last line of code in <kbd>App.js</kbd>, which exports the <kbd>App</kbd> component, uses<span> the<strong> </strong></span><strong>higher-order component</strong><span> (</span><strong>HOC</strong><span>)</span><span> </span> <kbd>hot</kbd> module from <kbd>react-hot-loader</kbd> to mark the root component as <kbd>hot</kbd>. </p>
<p><kbd><span>mern-skeleton/client/App.js</span></kbd>:</p>
<pre><strong>import { hot } from 'react-hot-loader'</strong><br/>const App = () =&gt; { ... }<br/><strong>export default hot(module)(App)</strong></pre>
<p>Marking the <kbd>App</kbd> component as <kbd>hot</kbd> in this way essentially<span> enables live reloading of our React components during development.</span></p>
<p>For our MERN applications, we won't have to change the <kbd>main.js</kbd> and <kbd>App.js</kbd> code all that much after this point, and we can continue building out the rest of the React app by injecting new components into the <kbd>MainRouter</kbd> component, which is what we'll do in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a home route to MainRouter</h1>
                </header>
            
            <article>
                
<p>The <kbd>MainRouter.js</kbd> code will help render our custom React components with respect to the routes or locations in the application. In this first version, we will only add the root route for rendering the <kbd>Home</kbd> component.</p>
<p><kbd><span>mern-skeleton/client/MainRouter.js</span></kbd>:</p>
<pre>import React from 'react'<br/>import {Route, Switch} from 'react-router-dom'<br/>import <strong>Home</strong> from './core/Home'<br/>const MainRouter = () =&gt; {<br/>    return ( &lt;div&gt;<br/>      &lt;Switch&gt;<br/>        <strong>&lt;Route exact path="/" component={Home}/&gt;</strong><br/>      &lt;/Switch&gt;<br/>    &lt;/div&gt;<br/>   )<br/>}<br/>export default MainRouter</pre>
<p>As we develop more view components, we will update the <kbd>MainRouter</kbd> and add routes for the new <span>components inside </span>the <kbd>Switch</kbd> component.</p>
<div class="packt_infobox">The <kbd>Switch</kbd> component in React Router renders a route exclusively. In other words, it only renders the first child that matches the requested route path. On the other hand, without being nested in a <kbd>Switch</kbd>, every <kbd>Route</kbd> component renders inclusively when there is a path match; for example, a request at <kbd>'/'</kbd> also matches a route at <kbd>'/contact'</kbd>.</div>
<p>The <kbd>Home</kbd> component, which we added this route for in <kbd>MainRouter</kbd>, needs to be defined and exported, which we'll do in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Home component</h1>
                </header>
            
            <article>
                
<p>The <kbd>Home</kbd> component will be the React component containing the home page view of the skeleton application. It will be rendered in the browser when the user visits the root route, and we will compose it with Material-UI components.</p>
<p>The following screenshot shows the <kbd>Home</kbd> component, as well as the <kbd>Menu</kbd> component, which will be implemented later in this chapter as an individual component that provides navigation across the application:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-780 image-border" src="assets/c93f1841-1700-46f7-ba0e-27e0b61d336a.png" style="width:19.33em;height:20.67em;"/></div>
<p>The <kbd>Home</kbd> component and other view components that will be rendered in the browser for the user to interact with will follow a common code structure that contains the following parts in the given order:</p>
<ul>
<li>Imports of libraries, modules, and files needed to construct the component</li>
<li>Style declarations to define the specific CSS styles for the component elements</li>
<li>A function that defines the React component</li>
</ul>
<p>Throughout this book, as we develop new React components representing the frontend views, we will focus mainly on the React component definition part.<span> But for our first implementation, w</span>e will elaborate on all these parts to introduce the necessary structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imports</h1>
                </header>
            
            <article>
                
<p>For each React component implementation, we need to import the libraries, modules, and files being used in the implementation code. The component file will start with imports from React, Material-UI, React Router modules, images, CSS, API fetch, and the auth helpers from our code, as required by the specific component. For example, for the <kbd>Home</kbd> component code in <kbd><span>Home.js</span></kbd>, we use the following imports.</p>
<p><kbd><span>mern-skeleton/client/core/Home.js</span></kbd>:</p>
<pre>import React from 'react'<br/>import { makeStyles } from '@material-ui/core/styles'<br/>import Card from '@material-ui/core/Card'<br/>import CardContent from '@material-ui/core/CardContent'<br/>import CardMedia from '@material-ui/core/CardMedia'<br/>import Typography from '@material-ui/core/Typography'<br/>import unicornbikeImg from './../assets/images/unicornbike.jpg'</pre>
<p>The image file is kept in the <kbd>client/assets/images/</kbd> folder and is imported so that it can be added to the <kbd>Home</kbd> component. These imports will help us build the component and also define the styles to be used in the component. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Style declarations</h1>
                </header>
            
            <article>
                
<p>After the imports, we will define the CSS styles that are required to style the elements in the component by utilizing the <kbd>Material-UI</kbd> theme variables and <span><span><kbd>makeStyles</kbd>,</span></span> which is a custom React hook API provided by <kbd>Material-UI</kbd>.</p>
<div class="packt_infobox">Hooks are new to React. Hooks are functions that make it possible to use <span>React state and life cycle features in function components, without having to write a class to define the component. React provides some built-in hooks, but we can also build custom hooks as needed to reuse stateful behavior across different components. To learn more about React Hooks, visit <a href="https://reactjs.org/docs/hooks-intro.html" target="_blank">reactjs.org/docs/hooks-intro.html</a>.</span></div>
<p>For the <kbd>Home</kbd> component in <kbd><span>Home.js</span></kbd>, we have the following styles.</p>
<p><kbd><span>mern-skeleton/client/core/Home.js</span></kbd>:</p>
<pre>const useStyles = makeStyles(theme =&gt; ({<br/>  card: {<br/>    maxWidth: 600,<br/>    margin: 'auto',<br/>    marginTop: theme.spacing(5)<br/>  },<br/>  title: {<br/>    padding:`${theme.spacing(3)}px ${theme.spacing(2.5)}px ${theme.spacing(2)}px`,<br/>    color: theme.palette.openTitle<br/>  },<br/>  media: {<br/>    minHeight: 400<br/>  }<br/>})) </pre>
<p>The JSS style objects defined here will be injected into the component using the hook returned by <kbd>makeStyles</kbd>. The <kbd>makeStyles</kbd> hook API takes a function as an argument and gives access to our custom theme variables, which we can use when defining the styles. </p>
<div class="packt_tip packt_infobox">Material-UI <span>uses</span> <span>JSS, which is </span><span>a CSS-in-JS styling solution for adding styles to components. JSS uses JavaScript as a language to describe styles. </span>This book will not cover CSS and styling implementations in detail. It will mostly rely on the default look and feel of Material-UI components. To learn more about JSS, visit <a href="http://cssinjs.org/?v=v9.8.1" target="_blank">http://cssinjs.org/?v=v9.8.1</a>. For examples of how to customize the <kbd>Material-UI</kbd> component styles, check out the Material-UI documentation at <a href="https://material-ui.com/" target="_blank">https://material-ui.com/</a>.</div>
<p><span>We can use these generated styles to style the elements in the component, as shown in the following </span><kbd>Home</kbd><span> component definition.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component definition</h1>
                </header>
            
            <article>
                
<p>While writing the function to define the component, we will compose the content and behavior of the component. The <kbd>Home</kbd> component will contain a Material-UI <kbd>Card</kbd> with a headline, an image, and a caption, all styled with the styles we defined previously and returned by calling the <kbd>useStyles()</kbd> hook.</p>
<p><kbd><span>mern-skeleton/client/core/Home.js</span></kbd>:</p>
<pre>export default function Home(){<br/>  const classes = useStyles()<br/>    return (<br/>     &lt;Card className={classes.card}&gt;<br/>        &lt;Typography variant="h6" className={classes.title}&gt;<br/>          Home Page<br/>        &lt;/Typography&gt;<br/>        &lt;CardMedia className={classes.media} <br/>                   image={unicornbikeImg} title="Unicorn Bicycle"/&gt;<br/>        &lt;CardContent&gt;<br/>          &lt;Typography variant="body2" component="p"&gt;<br/>            Welcome to the MERN Skeleton home page.<br/>          &lt;/Typography&gt;<br/>        &lt;/CardContent&gt;<br/>      &lt;/Card&gt;<br/>    )<br/>}</pre>
<p><span>In the preceding code, we defined and exported a function component named <kbd>Home</kbd>. The exported component can now be used for composition within other components. We already imported this <kbd>Home</kbd> component in a route in the <kbd>MainRouter</kbd> component, as we discussed earlier.</span></p>
<div class="packt_infobox">Throughout this book, we will define all our React components as functional components. We will utilize React Hooks, which is a new addition to React, to add state and life cycle features, instead of using class definitions to achieve the same.</div>
<p>The other view components to be implemented in our MERN applications will adhere to the same structure. In the rest of this book, we will focus mainly on the component definition, highlighting the unique aspects of the implemented component.</p>
<p>We are almost ready to run this code to render the home page component in the frontend. But before that, we need to update the Webpack configurations so that we can bundle and display images.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bundling image assets</h1>
                </header>
            
            <article>
                
<p>The static image file that we imported into the <kbd>Home</kbd> component view must also be included in the bundle with the rest of the compiled JS code so that the code can access and load it. To enable this, we need to update the Webpack configuration files and add a module rule to load, bundle, and emit image files to the <kbd>dist</kbd> output directory, which contains the compiled frontend and backend code.</p>
<p>Update the <kbd>webpack.config.client.js</kbd>, <kbd>webpack.config.server.js</kbd>, and <span><kbd>webpack.config.client.production.js</kbd> </span>files so that you can add the following module rule after the use of <kbd>babel-loader</kbd>:</p>
<pre>[ …<br/>    {<br/>       test: /\.(ttf|eot|svg|gif|jpg|png)(\?[\s\S]+)?$/,<br/>       use: 'file-loader'<br/>    }<br/>]</pre>
<p>This module rule uses the <kbd>file-loader</kbd> node module for Webpack, which needs to be installed as a development dependency, as follows:</p>
<pre><strong>yarn add --dev file-loader</strong></pre>
<p>With this image bundling configuration added, the home page component should successfully render the image when we run the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running and opening in the browser</h1>
                </header>
            
            <article>
                
<p>The client code up to this point can be run so that we can view the <kbd>Home</kbd> component in the browser at the root URL. To run the application, use the following command:</p>
<pre><strong>yarn development</strong></pre>
<p>Then, open the root URL (<kbd>http://localhost:3000</kbd>) in the browser to see the <kbd>Home</kbd> component.</p>
<p>The <kbd>Home</kbd> component we've developed in this section is a basic view component without interactive features and does not require the use of the backend APIs for user CRUD or auth. However, the remaining view components for our skeleton frontend will need the backend APIs and auth, so we will look at how to integrate these in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating backend APIs</h1>
                </header>
            
            <article>
                
<p>Users should be able to use the frontend views to fetch and modify user data in the database based on authentication and authorization. To implement these functionalities, the React components will access the API endpoints that are exposed by the backend using the Fetch API.</p>
<div class="packt_infobox">The Fetch API is a newer standard that <span>makes network requests similar to <strong>XMLHttpRequest</strong> (<strong>XHR</strong>) but using promises instead, enabling a simpler and cleaner API. To learn more about the Fetch API, visit</span> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetch for user CRUD</h1>
                </header>
            
            <article>
                
<p>In the <kbd>client/user/api-user.js</kbd> file, we will add methods for accessing each of the user CRUD API endpoints, which the React components can use to exchange user data with the server and database as required. In the following sections, we will look at the implementation of these methods and how they correspond to each CRUD endpoint. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a user</h1>
                </header>
            
            <article>
                
<p>The <kbd>create</kbd> method will take user data from the view component, which is where we will invoke this method. Then, it will use <kbd>fetch</kbd> to make a <kbd>POST</kbd> call at the create API route, <kbd>'/api/users'</kbd>, to create a new user in the backend with the provided data.</p>
<p><kbd><span>mern-skeleton/client/user/api-user.js</span></kbd>:</p>
<pre>const create = async (user) =&gt; {<br/>  try {<br/>      let response = await <strong>fetch</strong>('/api/users/', {<br/>        method: '<strong>POST</strong>',<br/>        headers: {<br/>          'Accept': 'application/json',<br/>          'Content-Type': 'application/json'<br/>        },<br/>        body: JSON.stringify(user)<br/>      })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p><span>Finally, in this method, we return the response from the server as a promise. So, the component calling this method can use this promise to handle the response appropriately, depending on what is returned from the server. Similarly, we will implement the <kbd>list</kbd> method next.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing users</h1>
                </header>
            
            <article>
                
<p>The <kbd>list</kbd> method will use fetch to make a <kbd>GET</kbd> call to retrieve all the users in the database, and then return the response from the server as a promise to the component.</p>
<p><kbd><span>mern-skeleton/client/user/api-user.js</span></kbd>:</p>
<pre>const list = async (signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/users/', {<br/>      method: 'GET',<br/>      signal: signal,<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>The returned promise, if it resolves successfully, will give the component an array containing the user objects that were retrieved from the database. In the case of a single user read, we will deal with a single user object instead, as demonstrated next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading a user profile</h1>
                </header>
            
            <article>
                
<p>The <kbd>read</kbd> method will use fetch to make a <kbd>GET</kbd> call to retrieve a specific user by ID. Since this is a protected route, besides passing the user ID as a parameter, the requesting component must also provide valid credentials, which, in this case, will be a valid JWT received after a successful sign-in.</p>
<p><kbd><span>mern-skeleton/client/user/api-user.js</span></kbd>:</p>
<pre>const read = async (params, credentials, signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/users/' + params.userId, {<br/>      method: 'GET',<br/>      signal: signal,<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      }<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>The JWT is attached to the <kbd>GET</kbd> fetch call in the <kbd>Authorization</kbd> header using the <kbd>Bearer</kbd> scheme, and then the response from the server is returned to the component in a promise. This promise, when it resolves, will either give the component the user details for the specific user or notify that access is restricted to authenticated users. Similarly, the updated user API method also needs to be passed valid JWT credentials for the fetch call, as shown in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating a user's data</h1>
                </header>
            
            <article>
                
<p>The <kbd>update</kbd> method will take changed user data from the view component for a specific user, then use <kbd>fetch</kbd> to make a <kbd>PUT</kbd> call to update the existing user in the backend. This is also a protected route that will require a valid JWT as the credential.</p>
<p><kbd><span>mern-skeleton/client/user/api-user.js</span></kbd>:</p>
<pre>const update = async (params, credentials, user) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/users/' + params.userId, {<br/>      method: 'PUT',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: JSON.stringify(user)<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>As we have seen with the other fetch calls, this method will also return a promise containing the server's response to the user update request. In the final method, we will learn how to call the user delete API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a user</h1>
                </header>
            
            <article>
                
<p>The <kbd>remove</kbd> method will allow the view component to delete a specific user from the database and use fetch to make a <kbd>DELETE</kbd> call. This, again, is a protected route that will require a valid JWT as a credential, similar to the <kbd>read</kbd> and <kbd>update</kbd> methods. </p>
<p><kbd><span>mern-skeleton/client/user/api-user.js</span></kbd>:</p>
<pre>const remove = async (params, credentials) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/users/' + params.userId, {<br/>      method: 'DELETE',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      }<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p><span>The response from the server to the delete request will be returned to the component as a promise, as in the other methods.</span></p>
<p><span>In these five helper methods, we have covered calls to all the user CRUD-related API endpoints that we implemented on the backend. </span>Finally, we can export these methods from the <span><kbd>api-user.js</kbd> file as follows.</span></p>
<p><kbd><span>mern-skeleton/client/user/api-user.js</span></kbd>:</p>
<pre>export { create, list, read, update, remove }</pre>
<p><span>These user CRUD methods can now be imported and used by the React components as required. Next, we will implement similar helper methods to integrate the auth-related API endpoints.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetch for the auth API</h1>
                </header>
            
            <article>
                
<p>In order to integrate the auth API endpoints from the server with the frontend React components, we will add methods for fetching sign-in and sign-out API endpoints in the <kbd>client/auth/api-auth.js</kbd> file. Let's take a look at them.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sign-in</h1>
                </header>
            
            <article>
                
<p>The <kbd>signin</kbd> method will take user sign-in data from the view component, then use <kbd>fetch</kbd> to make a <kbd>POST</kbd> call to verify the user with the backend. </p>
<p><kbd><span>mern-skeleton/client/auth/api-auth.js</span></kbd>:</p>
<pre>const signin = async (user) =&gt; {<br/>  try {<br/>    let response = await fetch('/auth/signin/', {<br/>      method: 'POST',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Content-Type': 'application/json'<br/>      },<br/>      credentials: 'include',<br/>      body: JSON.stringify(user)<br/>    })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p><span>The response from the server will be returned to the component in a promise, which may provide the JWT if sign-in was successful. The component invoking this method needs to handle the response appropriately, such as storing the received JWT locally so it can be used when making calls to other protected API routes from the frontend. We will look at the implementation for this when we implement the <strong>Sign In</strong> view later in this chapter. </span></p>
<p>After the user is successfully signed in, we also want the option to call the signout API when the user is signing out. The call to the signout API is discussed next.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sign-out</h1>
                </header>
            
            <article>
                
<p>We will add a <kbd>signout</kbd> method to <span><span><kbd>api-auth.js</kbd>,</span></span><span> which will</span> use fetch to make a GET call to the signout API endpoint on the server.</p>
<p><kbd><span>mern-skeleton/client/auth/api-auth.js</span></kbd>:</p>
<pre>const signout = async () =&gt; {<br/>  try {<br/>    let response = await fetch('/auth/signout/', { method: 'GET' })<br/>    return await response.json()<br/>  } catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>This method will also return a promise to inform the component about whether the API request was successful.</p>
<p>At the end of the <kbd>api-auth.js</kbd> file, we will export the <kbd>signin</kbd> and <kbd>signout</kbd> methods.</p>
<p><kbd><span>mern-skeleton/client/auth/api-auth.js</span></kbd>:</p>
<pre>export { signin, signout }</pre>
<p>Now, these methods can be imported into the relevant React components so that we can implement the user sign-in and signout features.</p>
<p>With these API fetch methods added, the React frontend has complete access to the endpoints we made available in the backend. Before we start putting these methods to use in our React components, we will look into how user auth state can be maintained across the frontend<span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding auth in the frontend</h1>
                </header>
            
            <article>
                
<p>As we discussed in the previous chapter, implementing authentication with JWT relinquishes responsibility to the client-side to manage and store user auth state. To this end, we need to write code that will allow the client-side to store the JWT that's received from the server on successful sign-in, make it available when accessing protected routes, delete or invalidate the token when the user signs out, and also restrict access to views and components on the frontend based on the user auth state.</p>
<p>Using examples of the auth workflow from the React Router documentation, in the following sections, we will write helper methods to manage the auth state across the components, and also use a custom <kbd>PrivateRoute</kbd> component to add protected routes to the frontend of the MERN skeleton application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing auth state</h1>
                </header>
            
            <article>
                
<p>To manage auth state in the frontend of the application, the frontend needs to be able to store, retrieve, and delete the auth credentials that are received from the server on successful user sign in. In our MERN applications, we will use the browser's <kbd>sessionsStorage</kbd> as the storage option to store the JWT auth credentials. </p>
<div class="packt_tip">Alternatively, you can use <kbd>localStorage</kbd> instead of <kbd>sessionStorage</kbd> to store the JWT credentials. With <kbd>sessionStorage</kbd>, the user auth state will only be remembered in the current window tab. With <kbd>localStorage</kbd>, the user auth state will be remembered across tabs in a browser.</div>
<p><span>In </span><kbd>client/auth/auth-helper.js</kbd><span>, we will define the helper methods discussed in the following sections to store and retrieve JWT credentials from client-side </span><kbd>sessionStorage</kbd><span>, and also clear out the </span><kbd>sessionStorage</kbd><span> on user sign-out.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving credentials</h1>
                </header>
            
            <article>
                
<p>In order to save the JWT credentials that are received from the server on successful sign-in, we use the <kbd>authenticate</kbd> method, which is defined as follows.</p>
<p><kbd><span>mern-skeleton/client/auth/auth-helper.js</span></kbd><span>:</span></p>
<pre style="padding-left: 60px">authenticate(jwt, cb) {<br/>    if(typeof window !== "undefined")<br/>        sessionStorage.setItem('jwt', JSON.stringify(jwt))<br/>    cb()<br/>}</pre>
<p>The <kbd>authenticate</kbd> method takes the JWT credentials, <kbd>jwt</kbd>, and a callback function, <kbd>cb</kbd>, as arguments. It stores the credentials in <kbd>sessionStorage</kbd> after ensuring <kbd>window</kbd> is defined, in other words ensuring this code is running in a browser and hence has access to <kbd>sessionStorage</kbd>. Then, it executes the callback function that is passed in. This callback will allow the component <span>–</span> in our case, the component where sign-in is called <span>–</span> to define actions that should take place after successfully signing in and storing credentials. Next, we will discuss the method that lets us access these stored credentials.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving credentials</h1>
                </header>
            
            <article>
                
<p>In our frontend components, we will need to retrieve the stored credentials to check if the current user is signed in. In the <kbd>isAuthenticated()</kbd> method, we can retrieve these credentials from <kbd>sessionStorage</kbd>.</p>
<p><kbd><span>mern-skeleton/client/auth/auth-helper.js</span></kbd><span>:</span></p>
<pre style="padding-left: 60px">isAuthenticated() {<br/>    if (typeof window == "undefined")<br/>      return false<br/><br/>    if (sessionStorage.getItem('jwt'))<br/>      return JSON.parse(sessionStorage.getItem('jwt'))<br/>    else<br/>      return false<br/>}</pre>
<p>A call to<span> </span><kbd>isAuthenticated()</kbd> will return either the stored credentials or <kbd>false</kbd>, depending on whether credentials were found in <kbd>sessionStorage</kbd>. Finding credentials in storage will mean a user is signed in, whereas not finding credentials will mean the user is not signed in. We will also add a method that allows us to delete the credentials from storage when a signed-in user signs out from the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting credentials</h1>
                </header>
            
            <article>
                
<p>When a user successfully signs out from the application, we want to clear the stored JWT credentials from <kbd>sessionStorage</kbd>. This can be accomplished by calling the <kbd>clearJWT</kbd> method, which is defined in the following code.</p>
<p><kbd><span>mern-skeleton/client/auth/auth-helper.js</span></kbd><span>:</span></p>
<pre style="padding-left: 60px">clearJWT(cb) {<br/>      if(typeof window !== "undefined")<br/>        sessionStorage.removeItem('jwt')<br/>      cb()<br/>      signout().then((data) =&gt; {<br/>          document.cookie = "t=; expires=Thu, 01 Jan 1970 00:00:00 <br/>          UTC; path=/;"<br/>      })<br/>}</pre>
<p>This <kbd>clearJWT</kbd> method takes a callback function as an argument, and it removes the JWT credential from <kbd>sessionStorage</kbd>. <span>The passed in <kbd>cb()</kbd> function allows the component initiating the</span> <kbd>signout</kbd> <span>functionality to dictate what should happen after a successful sign-out. </span></p>
<p>The <kbd>clearJWT</kbd> method also uses the <kbd>signout</kbd> method we defined earlier in <span><kbd>api-auth.js</kbd> to call the signout API in the backend. If we had used <kbd>cookies</kbd> to store the credentials instead of <kbd>sessionStorage</kbd>, the response to this API call would be where we clear the cookie, as shown in the preceding code. Using the signout API call is optional since this is dependent on whether cookies are used as the credential storage mechanism.</span></p>
<p>With these three methods, we now have ways of storing, retrieving, and deleting JWT credentials on the client-side. Using these methods, the React components we build for the frontend will be able to check and manage user auth state to restrict access in the frontend, as demonstrated in the following section with the custom <kbd>PrivateRoute</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The PrivateRoute component</h1>
                </header>
            
            <article>
                
<p>The code in the file defines the <kbd>PrivateRoute</kbd> component, as shown in the auth flow example at <a href="https://reacttraining.com/react-router/web/example/auth-workflow" target="_blank">https://reacttraining.com/react-router/web/example/auth-workflow</a>, which can be found in the React Router documentation. It will allow us to declare protected routes for the frontend to restrict view access based on user auth.</p>
<p><kbd><span>mern-skeleton/client/auth/PrivateRoute.js</span></kbd>:</p>
<pre>import React, { Component } from 'react'<br/>import { Route, Redirect } from 'react-router-dom'<br/><strong>import auth from './auth-helper'</strong><br/><br/>const PrivateRoute = ({ component: Component, ...rest }) =&gt; (<br/>  &lt;Route {...rest} render={props =&gt; (<br/>    <strong>auth.isAuthenticated()</strong> ? (<br/>      &lt;Component {...props}/&gt;<br/>    ) : (<br/>      &lt;Redirect to={{<br/>        pathname: '/signin',<br/>        state: { from: props.location }<br/>      }}/&gt;<br/>    )<br/>  )}/&gt;<br/>)<br/><br/>export default PrivateRoute</pre>
<p>Components to be rendered in this <kbd>PrivateRoute</kbd> will only load when the user is authenticated, which is determined by a call to the <kbd>isAuthenticated</kbd> method; otherwise, the user will be redirected to the <kbd>Signin</kbd> component. We load the components that should have restricted access, such as the user profile component, in a <kbd>PrivateRoute</kbd>. This will ensure that only authenticated users are able to view the user profile page.</p>
<p>With the backend APIs integrated and the auth management helper methods ready for use in the components, we can now start building the remaining view components that utilize these methods and complete the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Completing the User frontend </h1>
                </header>
            
            <article>
                
<p>The React components that will be described in this section complete the interactive features we defined for the skeleton by allowing users to view, create, and modify user data stored in the database with respect to auth restrictions. The components we will implement are as follows:</p>
<ul>
<li><kbd>Users</kbd>: To fetch and list all users from the database to the view</li>
<li><kbd>Signup</kbd>: To display a form that allows new users to sign up  </li>
<li><kbd>Signin</kbd>: <span>To display a form that allows existing users to sign in</span></li>
<li><kbd>Profile</kbd>: To display details for a specific user after retrieving from the database</li>
<li><kbd>EditProfile</kbd>: <span>To display details for a specific user and allow authorized user to update these details</span></li>
</ul>
<ul>
<li><kbd>DeleteUser</kbd>: To allow an authorized user to delete their account from the application</li>
<li><kbd>Menu</kbd>: To add a common navigation bar to each view in the application</li>
</ul>
<p>For each of these components, we will go over their unique aspects, as well as how to add them to the application in the <kbd>MainRouter</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Users component</h1>
                </header>
            
            <article>
                
<p>The <kbd>Users</kbd> component in <kbd>client/user/Users.js</kbd> shows the names of all the users that have been fetched from the database and links each name to the user profile. The following component can be viewed by any visitor to the application and will render at the <kbd>'/users'</kbd> route:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-781 image-border" src="assets/276f7c2c-23cf-4c9e-937e-8481d3924c81.png" style="width:19.25em;height:20.67em;"/></div>
<p>In the component definition, similar to how we implemented the <kbd>Home</kbd> component, we define and export a function component. In this component, we start by initializing the state with an empty array of users.</p>
<p><kbd><span>mern-skeleton/client/user/Users.js</span></kbd>:</p>
<div>
<pre><span>export default function Users() {<br/> ...<br/> const</span><span> [</span><span>users</span><span>, </span><span>setUsers</span><span>] </span><span>=</span><span> </span><span>useState</span><span>([])<br/> ...<br/>}</span></pre></div>
<p>We are using the built-in React hook, <kbd>useState</kbd>, to add state to this function component. By calling this hook, we are essentially declaring a state variable named <kbd>users</kbd>, which can be updated by invoking <kbd>setUsers</kbd>, and also set the initial value of <kbd>users</kbd> to <kbd>[]</kbd>.</p>
<p>Using the built-in <kbd>useState</kbd> hook allows us to add state behavior to a function component in React. Calling it will declare a state variable, similar to using <kbd>this.state</kbd> in class component definitions. The argument that's passed to <kbd>useState</kbd> is the initial value of this variable <span>–</span> in other words, the initial state. Invoking <kbd>useState</kbd> returns the current state and a function that updates the state value, which is similar to <kbd>this.setState</kbd> in a class definition.</p>
<p>With the <kbd>users</kbd> state initialized, next, we will use another built-in React hook named <kbd>useEffect</kbd> to fetch a list of users from the backend and update the <kbd>users</kbd> value in the state.</p>
<div class="packt_infobox">The Effect Hook, <kbd>useEffect</kbd>, serves the purpose of the <kbd>componentDidMount</kbd>, <kbd>componentDidUpdate</kbd>, and <kbd>componentWillUnmount</kbd> React life cycle methods that we would otherwise use in React classes. Using this hook in a function component allows us to perform side effects such as fetching data from a backend. By default, React runs the effects defined with <kbd>useEffect</kbd> after every render, including the first render. But we can also instruct the effect to only rerun if something changes in state. Optionally, we can also define how to clean up after an effect, for example, to perform an action such as aborting a fetch signal when the component unmounts to avoid memory leaks.</div>
<p>In our <kbd>Users</kbd> component, we use <kbd>useEffect</kbd> to call the <kbd>list</kbd> method from the <kbd>api-user.js</kbd> helper methods. This will fetch the user list from the backend and load the user data into the component by updating the state.</p>
<p><kbd><span>mern-skeleton/client/user/Users.js</span></kbd>:</p>
<pre>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>    list(signal).then((data) =&gt; {<br/>      if (data &amp;&amp; data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        setUsers(data)<br/>      }<br/>    })<br/><br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>  }, [])</pre>
<p>In this effect, we also add a cleanup function to abort the fetch call when the component unmounts. To associate a signal with the fetch call, we use the AbortController web API, which <span>allows us to abort DOM requests as needed.</span></p>
<p><span>In the second argument of this <kbd>useEffect</kbd> hook, we pass an empty array so that this effect cleanup runs only once upon mounting and unmounting, and not after every render.</span></p>
<p>Finally, in the return of the <kbd>Users</kbd> function component, we add the actual view content. The view is composed of Material-UI components such as <kbd>Paper</kbd>, <kbd>List</kbd>, and <kbd>ListItem</kbd>. These elements are styled with the CSS that is defined and made available with the <kbd>makeStyles</kbd> hook, the same way as in the <kbd>Home</kbd> component.</p>
<p><kbd><span>mern-skeleton/client/user/Users.js</span></kbd>:</p>
<pre>return (<br/>      &lt;Paper className={classes.root} elevation={4}&gt;<br/>        &lt;Typography variant="h6" className={classes.title}&gt;<br/>          All Users<br/>        &lt;/Typography&gt;<br/>        &lt;List dense&gt;<br/>         {<strong>users.map</strong>((item, i) =&gt; {<br/>          return &lt;Link to={"/user/" + item._id} key={i}&gt;<br/>                    &lt;ListItem button&gt;<br/>                      &lt;ListItemAvatar&gt;<br/>                        &lt;Avatar&gt;<br/>                          &lt;Person/&gt;<br/>                        &lt;/Avatar&gt;<br/>                      &lt;/ListItemAvatar&gt;<br/>                      &lt;ListItemText primary={item.name}/&gt;<br/>                      &lt;ListItemSecondaryAction&gt;<br/>                      &lt;IconButton&gt;<br/>                          &lt;ArrowForward/&gt;<br/>                      &lt;/IconButton&gt;<br/>                      &lt;/ListItemSecondaryAction&gt;<br/>                    &lt;/ListItem&gt;<br/>                 &lt;/Link&gt;<br/>               })<br/>             }<br/>        &lt;/List&gt;<br/>      &lt;/Paper&gt;<br/>)</pre>
<p>In this view, to generate each list item, we iterate through the array of users in the state using the <kbd>map</kbd> function. A list item is rendered with an individual user's name from each item that's accessed per iteration on the users array.</p>
<p>To add this <kbd>Users</kbd> component to the React application, we need to update the <kbd>MainRouter</kbd> component with a <kbd>Route</kbd> that renders this component at the <kbd>'/users'</kbd> path. Add the <kbd>Route</kbd> inside the <kbd>Switch</kbd> component after the <kbd>Home</kbd> route.</p>
<p><kbd><span>mern-skeleton/client/MainRouter.js</span></kbd>:</p>
<pre>&lt;Route path="/users" component={Users}/&gt;</pre>
<p>To see this view rendered in the browser, you can temporarily add a <kbd>Link</kbd> component to the <kbd>Home</kbd> component to be able to route to the <kbd>Users</kbd> component:</p>
<pre>&lt;Link to="/users"&gt;Users&lt;/Link&gt;</pre>
<p>Clicking on this link after rendering the Home view at the root route in the browser will display the <kbd>Users</kbd> component we implemented in this section. We will implement the other React components similarly, starting with the <kbd>Signup</kbd> component in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Signup component </h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>Signup</kbd><span> </span>component in<span> </span><kbd>client/user/Signup.js</kbd> presents a form with name, email, and password fields to the user for sign-up at the<span> </span><kbd>'/signup'</kbd> path, as displayed in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-952 image-border" src="assets/b786119b-9e65-40ee-bb58-1d26f7a0f4d9.png" style="width:17.67em;height:13.33em;"/></div>
<p>In the component definition, we initialize the state using the <kbd>useState</kbd> hook with empty input field values, an empty error message, and set the dialog open variable to false.</p>
<p><kbd><span>mern-skeleton/client/user/Signup.js</span></kbd>:</p>
<pre>export default function Signup() {<br/>  ...  <br/>  const [values, setValues] = useState({<br/>    name: '',<br/>    password: '',<br/>    email: '',<br/>    open: false,<br/>    error: ''<br/>  })<br/>  ...<br/>}</pre>
<p>We also define two handler functions to be called when the input values change or the <span class="packt_screen">submit</span><span> </span>button is clicked. The<span> </span><kbd>handleChange</kbd><span> </span>function takes the new value that's entered in the input field and sets it as the state.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Signup.js</span></kbd>:</p>
<pre>const handleChange = name =&gt; event =&gt; {<br/>    setValues({ ...values, [name]: event.target.value })<br/>}</pre>
<p>The<span> </span><kbd>clickSubmit</kbd><span> </span>function is called when the form is submitted. It takes the input values from the state and calls the<span> </span><kbd>create</kbd><span> </span>fetch method to sign up the user with the backend. Then, depending on the response from the server, either an error message is shown or a success dialog is shown.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Signup.js</span></kbd>:</p>
<pre>  const clickSubmit = () =&gt; {<br/>    const user = {<br/>      name: values.name || undefined,<br/>      email: values.email || undefined,<br/>      password: values.password || undefined<br/>    }<br/>    create(user).then((data) =&gt; {<br/>      if (data.error) {<br/>        setValues({ ...values, error: data.error})<br/>      } else {<br/>        setValues({ ...values, error: '', open: true})<br/>      }<br/>    })<br/>  }</pre>
<p>In the <kbd>return</kbd> function, we compose and style the form components in the signup view using components such as<span> </span><kbd>TextField</kbd><span> </span>from Material-UI.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Signup.js</span></kbd>:</p>
<pre>return (<br/>    &lt;div&gt;<br/>      &lt;Card className={classes.card}&gt;<br/>        &lt;CardContent&gt;<br/>          &lt;Typography variant="h6" className={classes.title}&gt;<br/>            Sign Up<br/>          &lt;/Typography&gt;<br/>          &lt;TextField id="name" label="Name" <br/>             className={classes.textField} <br/>             value={values.name} onChange={handleChange('name')} <br/>             margin="normal"/&gt;<br/>          &lt;br/&gt;<br/>          &lt;TextField id="email" type="email" label="Email" <br/>             className={classes.textField} <br/>             value={values.email} onChange={handleChange('email')} <br/>             margin="normal"/&gt;<br/>          &lt;br/&gt;<br/>          &lt;TextField id="password" type="password" label="Password" <br/>             className={classes.textField} value={values.password} <br/>             onChange={handleChange('password')} margin="normal"/&gt;<br/>          &lt;br/&gt; <br/>          <strong>{</strong><br/>            values.error &amp;&amp; (&lt;Typography component="p" color="error"&gt;<br/>              &lt;Icon color="error" className={classes.error}&gt;error&lt;/Icon&gt;<br/>              {values.error}&lt;/Typography&gt;)<br/>          <strong>}</strong><br/>        &lt;/CardContent&gt;<br/>        &lt;CardActions&gt;<br/>          &lt;Button color="primary" variant="contained" onClick={clickSubmit} <br/>            className={classes.submit}&gt;Submit&lt;/Button&gt;<br/>        &lt;/CardActions&gt;<br/>      &lt;/Card&gt;<br/>    &lt;/div&gt;<br/>)</pre>
<p>This return also contains an error message block, along with a<span> </span><kbd>Dialog</kbd><span> </span>component that is conditionally rendered depending on the signup response from the server. If the server returns an error, the error block that was added below the form, which we implemented in the preceding code, will render in the view with the corresponding error message. If the server returns a successful response, a <kbd>Dialog</kbd> component will be rendered instead. </p>
<p>The<span> </span><kbd>Dialog</kbd><span> </span>component in <kbd><span>Signup.js</span></kbd><span> </span>is composed as follows.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Signup.js</span></kbd>:</p>
<pre>&lt;Dialog open={values.open} disableBackdropClick={true}&gt;<br/>   &lt;DialogTitle&gt;New Account&lt;/DialogTitle&gt;<br/>   &lt;DialogContent&gt;<br/>      &lt;DialogContentText&gt;<br/>         New account successfully created.<br/>      &lt;/DialogContentText&gt;<br/>   &lt;/DialogContent&gt;<br/>   &lt;DialogActions&gt;<br/>       &lt;Link to="/signin"&gt;<br/>          &lt;Button color="primary" autoFocus="autoFocus" <br/>                  variant="contained"&gt;<br/>             Sign In<br/>          &lt;/Button&gt;<br/>       &lt;/Link&gt;<br/>   &lt;/DialogActions&gt;<br/>&lt;/Dialog&gt;</pre>
<p><span>On successful account creation, the user is given confirmation and asked to sign in using this <kbd>Dialog</kbd> component, which links to the <kbd>Signin</kbd> component, as shown in the following screenshot:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-783 image-border" src="assets/a3edd525-ab6e-4021-8e15-2f0b90fe1928.png" style="width:20.33em;height:15.92em;"/></div>
<p>To add the<span> </span><kbd>Signup</kbd><span> </span>component to the app, add the following<span> </span><kbd>Route</kbd><span> </span>to <kbd>MainRouter</kbd><span> </span>in the<span> </span><kbd>Switch</kbd><span> </span>component.</p>
<p><kbd><span>mern-skeleton/client/MainRouter.js</span></kbd>:</p>
<pre>&lt;Route path="/signup" component={Signup}/&gt;</pre>
<p>This will render the<span> </span><kbd>Signup</kbd><span> </span>view at<span> </span><kbd>'/signup'</kbd>. Similarly, we will implement the <kbd>Signin</kbd> component next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Signin component</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>Signin</kbd><span> </span>component in<span> </span><kbd>client/auth/Signin.js</kbd> is also a form with only email and password fields for signing in. <span>This component is quite similar to the <kbd>Signup</kbd> component and will render at the <kbd>'/signin'</kbd> path. The key difference is in the implementation of redirection after a successful sign-in and storing the received JWT credentials. The rendered <kbd>Signin</kbd> component can be seen in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-784 image-border" src="assets/c43a997a-7aac-4897-8e47-ac3c084e349e.png" style="width:20.42em;height:17.83em;"/></div>
<p>For redirection, we will use the<span> </span><kbd>Redirect</kbd><span> </span>component from React Router. First, initialize a<span> </span><kbd>redirectToReferrer</kbd><span> </span>value to<span> </span><kbd>false</kbd><span> </span>in the state with the other fields:</p>
<p><kbd><span>mern-skeleton/client</span><span>/auth/Signin.js</span></kbd>:</p>
<pre>export default function Signin(props) {<br/>  const [values, setValues] = useState({<br/>      email: '',<br/>      password: '',<br/>      error: '',<br/>      redirectToReferrer: false<br/>  })<br/>}</pre>
<p>The <kbd>Signin</kbd> function will take props in the argument that contain React Router variables. We will use these for the redirect. <kbd>redirectToReferrer</kbd><span> </span>should be set to<span> </span><kbd>true</kbd><span> </span>when the user successfully signs in after submitting the form and the received JWT is stored in <kbd>sessionStorage</kbd>. To store the JWT and redirect afterward, we will call the<span> </span><kbd>authenticate()</kbd><span> </span>method defined in<span> </span><kbd>auth-helper.js</kbd>. This implementation will go in the<span> </span><kbd>clickSubmit()</kbd><span> </span>function so that it can be called on form submit.</p>
<p><kbd><span>mern-skeleton/client</span><span>/auth/Signin.js</span></kbd>:</p>
<pre>const clickSubmit = () =&gt; {<br/>    const user = {<br/>      email: values.email || undefined,<br/>      password: values.password || undefined<br/>    }<br/><br/>    signin(user).then((data) =&gt; {<br/>      if (data.error) {<br/>        setValues({ ...values, error: data.error})<br/>      } else {<br/>        auth.authenticate(data, () =&gt; {<br/>          setValues({ ...values, error: '',redirectToReferrer: true})<br/>        })<br/>      }<br/>    })<br/>}</pre>
<p>The redirection will happen conditionally based on the<span> </span><kbd>redirectToReferrer</kbd><span> </span>value using the<span> </span><kbd>Redirect</kbd><span> </span>component from React Router. We add the redirect code inside the function before the return block, as follows.</p>
<p><kbd><span>mern-skeleton/client</span><span>/auth/Signin.js</span></kbd>:</p>
<pre>const {from} = props.location.state || {<br/>      from: {<br/>        pathname: '/'<br/>      }<br/>  }<br/>const {redirectToReferrer} = values<br/>if (redirectToReferrer) {<br/>      return (&lt;Redirect to={from}/&gt;)<br/>}</pre>
<p>The<span> </span><kbd>Redirect</kbd><span> </span>component, if rendered, will take the app to the last location that was received in the props or to the<span> </span><kbd>Home</kbd><span> </span>component at the root. </p>
<p>The function return code is not displayed here as it is very similar to the code in<span> </span><kbd>Signup</kbd>. It will contain the same form <span>elements</span> with just<span> </span><kbd>email</kbd><span> </span>and<span> </span><kbd>password</kbd><span> </span>fields, a conditional error message, and the<span> </span><kbd>submit</kbd><span> </span>button.</p>
<p>To add the<span> </span><kbd>Signin</kbd> component to the app, add the following Route to <kbd>MainRouter</kbd><span> </span>in the<span> </span><kbd>Switch</kbd><span> </span>component.</p>
<p><kbd><span>mern-skeleton/client</span><span>/MainRouter.js</span></kbd>:</p>
<pre>&lt;Route path="/signin" component={Signin}/&gt;</pre>
<p>This will render the<span> </span><kbd>Signin</kbd> component at<span> </span><kbd>"/signin"</kbd> and can be linked in the Home component, similar to the <kbd>Signup</kbd> component, so that it can be viewed in the browser. Next, we will implement the profile view to display the details of a single user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Profile component</h1>
                </header>
            
            <article>
                
<p>The <kbd>Profile</kbd> component in <kbd>client/user/Profile.js</kbd> shows a single user's information in the view at the <kbd>'/user/:userId'</kbd> path, where the <kbd>userId</kbd> parameter represents the ID of the specific user. The completed <kbd>Profile</kbd> will display user details, and also conditionally show edit/delete options. The following screenshot shows how the <kbd>Profile</kbd> renders when the user currently browsing is viewing someone else's profile and not their own profile: </p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-785 image-border" src="assets/cef473f4-40dc-4c07-9bb2-e6d42319711a.png" style="width:15.17em;height:11.00em;"/></div>
<p>This profile information can be fetched from the server if the user is signed in. To verify this, the component has to provide the JWT credential to the <kbd>read</kbd> fetch call; otherwise, the user should be redirected to the Sign In view.</p>
<p>In the <kbd>Profile</kbd> component definition, we need to initialize the state with an empty user and set <kbd>redirectToSignin</kbd> to <kbd>false</kbd>.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Profile.js</span></kbd>:</p>
<pre>export default function Profile({ match }) {<br/>    ...<br/>    const [user, setUser] = useState({})<br/>    const [redirectToSignin, setRedirectToSignin] = useState(false)<br/>    ...<br/>}</pre>
<p>We also need to get access to the <kbd>match</kbd> props passed by the <kbd>Route</kbd> component, which will contain a <kbd>:userId</kbd> parameter value. This can be accessed as <kbd>match.params.userId</kbd>.</p>
<p>The <kbd>Profile</kbd> component should fetch user information and render the view with these details. To implement this, we will use the <kbd>useEffect</kbd> hook, as we did in the <kbd>Users</kbd> component. </p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Profile.js</span></kbd>:</p>
<pre>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/>    const jwt = auth.isAuthenticated()<br/>    read({<br/>      userId: match.params.userId<br/>    }, {t: jwt.token}, signal).then((data) =&gt; {<br/>      if (data &amp;&amp; data.error) {<br/>        setRedirectToSignin(true)<br/>      } else {<br/>        setUser(data)<br/>      }<br/>    })<br/><br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/><br/>  }, [match.params.userId])</pre>
<p>This effect uses the <kbd>match.params.userId</kbd> value and calls the <kbd>read</kbd> user fetch method. Since this method also requires credentials to authorize the signed-in user, the JWT is retrieved from <kbd>sessionStorage</kbd> using the <kbd>isAuthenticated</kbd> method from <kbd>auth-helper.js</kbd>, and passed in the call to <kbd>read</kbd>.</p>
<p>Once the server responds, either the state is updated with the user information or the view is redirected to the Sign In view if the current user is not authenticated. We also add a cleanup function in this effect hook to abort the fetch signal when the component unmounts.</p>
<p>This effect only needs to rerun when the <kbd>userId</kbd><span> </span>parameter changes in the route, for example, when the app goes from one profile view to the other. To ensure this effect reruns when the <kbd>userId</kbd> value updates, we will add <kbd>[match.params.userId]</kbd> in the second argument to<span> </span><kbd>useEffect</kbd>.</p>
<p>If the current user is not authenticated, we set up the conditional redirect to the Sign In view.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Profile.js</span></kbd></p>
<pre>if (redirectToSignin) {<br/>   return &lt;Redirect to='/signin'/&gt;<br/>}</pre>
<p>The function will return the <kbd>Profile</kbd> view with the following elements if the user who's currently signed in is viewing another user's profile.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Profile.js</span></kbd>:</p>
<pre>return (<br/>      &lt;Paper className={classes.root} elevation={4}&gt;<br/>        &lt;Typography variant="h6" className={classes.title}&gt;<br/>          Profile<br/>        &lt;/Typography&gt;<br/>        &lt;List dense&gt;<br/>          &lt;ListItem&gt;<br/>            &lt;ListItemAvatar&gt;<br/>              &lt;Avatar&gt;<br/>                &lt;Person/&gt;<br/>              &lt;/Avatar&gt;<br/>            &lt;/ListItemAvatar&gt;<br/>            &lt;ListItemText primary={user.name} secondary={user.email}/&gt; <br/>          &lt;/ListItem&gt;<br/>          &lt;Divider/&gt;<br/>          &lt;ListItem&gt;<br/>            &lt;ListItemText primary={"Joined: " + (<br/>              new Date(user.created)).toDateString()}/&gt;<br/>          &lt;/ListItem&gt;<br/>        &lt;/List&gt;<br/>      &lt;/Paper&gt;<br/>)</pre>
<p>However, if the user that's currently <span>signed in</span> is viewing their own profile, they will be able to see edit and delete options in the <kbd>Profile</kbd> component, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-953 image-border" src="assets/1015c42c-63e0-4226-9868-f65ee50d15d4.png" style="width:28.33em;height:17.92em;"/></div>
<p>To implement this feature, in the first <kbd>ListItem</kbd> component in the <kbd>Profile</kbd>, add a <kbd>ListItemSecondaryAction</kbd> component containing the <kbd>Edit</kbd> button and a <kbd>DeleteUser</kbd> component, which will render conditionally based on whether the current user is viewing their own profile.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/Profile.js</span></kbd>:</p>
<pre>{ auth.isAuthenticated().user &amp;&amp; auth.isAuthenticated().user._id == user._id &amp;&amp;<br/>    (&lt;ListItemSecondaryAction&gt;<br/>        &lt;Link to={"/user/edit/" + user._id}&gt;<br/>           &lt;IconButton aria-label="Edit" color="primary"&gt;<br/>               &lt;Edit/&gt;<br/>           &lt;/IconButton&gt;<br/>         &lt;/Link&gt;<br/>         &lt;DeleteUser userId={user._id}/&gt;<br/>     &lt;/ListItemSecondaryAction&gt;)<br/>}</pre>
<p>The <kbd>Edit</kbd> button will route to the <kbd>EditProfile</kbd> component, while the custom <kbd>DeleteUser</kbd> component will handle the delete operation with the <kbd>userId</kbd> passed to it as a prop.</p>
<p>To add the <kbd>Profile</kbd> component to the app, add the <kbd>Route</kbd> to <kbd>MainRouter</kbd> in the <kbd>Switch</kbd> component.</p>
<p><kbd><span>mern-skeleton/client</span><span>/MainRouter.js</span></kbd>:</p>
<pre>&lt;Route path="/user/:userId" component={Profile}/&gt;</pre>
<p class="mce-root">To visit this route in the browser and render a <kbd>Profile</kbd> with user details, the link should be composed with a valid user ID in it. In the next section, we will use this same approach of retrieving single user details and rendering it in the component to implement the Edit Profile view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The EditProfile component</h1>
                </header>
            
            <article>
                
<p>The <kbd>EditProfile</kbd> component in <kbd>client/user/EditProfile.js</kbd> has similarities in its implementation to both the <kbd>Signup</kbd> and <kbd>Profile</kbd> components. It allows the authorized user to edit their own profile information in a form similar to the signup form, as shown in the following screenshot: </p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-787 image-border" src="assets/3df6da71-c22b-416b-bd85-8d3b6363b112.png" style="width:28.42em;height:21.83em;"/></div>
<p><span>Upon loading at <kbd>'/user/edit/:userId'</kbd>, the component will fetch the user's information with their ID after verifying JWT for auth, and then load the form with the received user information. The form will allow the user to edit and submit only the changed information to the <kbd>update</kbd> fetch call, and, on successful update, redirect the user to the <kbd>Profile</kbd> view with updated information.</span></p>
<p><kbd>EditProfile</kbd> will load the user information the same way as in the <kbd>Profile</kbd> component, that is, by fetching with <kbd>read</kbd> in <kbd>useEffect</kbd> using the <kbd>userId</kbd> parameter from <kbd>match.params</kbd>. It will gather credentials from <kbd>auth.isAuthenticated</kbd>. The form view will contain the same elements as the <kbd>Signup</kbd> component, with the input values being updated in the state when they change. </p>
<p><span>On form submit, the component</span> <span>will call the</span> <kbd>update</kbd> <span>fetch method</span> <span>with the</span> <kbd>userId</kbd><span>, JWT and updated user data.</span></p>
<p><kbd><span>mern-skeleton/client</span><span>/user/EditProfile.js</span></kbd>:</p>
<pre>const clickSubmit = () =&gt; {<br/>const jwt = auth.isAuthenticated()<br/>    const user = {<br/>      name: values.name || undefined,<br/>      email: values.email || undefined,<br/>      password: values.password || undefined<br/>    }<br/>    update({<br/>      userId: match.params.userId<br/>    }, {<br/>      t: jwt.token<br/>    }, user).then((data) =&gt; {<br/>      if (data &amp;&amp; data.error) {<br/>        setValues({...values, error: data.error})<br/>      } else {<br/>        setValues({...values, userId: data._id, redirectToProfile: true})<br/>      }<br/>    })<br/>}</pre>
<p>Depending on the response from the server, the user will either see an error message or be redirected to the updated Profile page using the <kbd>Redirect</kbd> component, as follows.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/EditProfile.js</span></kbd>:</p>
<pre>if (values.redirectToProfile) {<br/>      return (&lt;Redirect to={'/user/' + values.userId}/&gt;)<br/>}</pre>
<p>To add the <kbd>EditProfile</kbd> component to the app, we will use a <kbd>PrivateRoute</kbd>, which will restrict the component from loading at all if the user is not signed in. The order of placement in <kbd>MainRouter</kbd> will also be important.</p>
<p><kbd><span>mern-skeleton/client</span><span>/MainRouter.js</span></kbd>:</p>
<pre>&lt;Switch&gt;<br/>  ...<strong><br/>  &lt;PrivateRoute path="/user/edit/:userId" component={EditProfile}/&gt;</strong><br/>  &lt;Route path="/user/:userId" component={Profile}/&gt;<br/>&lt;/Switch&gt;</pre>
<p>The route with the <kbd>'/user/edit/:userId'</kbd> path needs to be placed before the route with the <kbd>'/user/:userId'</kbd> path, so that the edit path is matched first exclusively in the Switch component when this route is requested, and not confused with the <kbd>Profile</kbd> route.</p>
<p>With this profile edit view added, we only have the user delete UI implementation left to complete the user-related frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DeleteUser component</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>DeleteUser</kbd> component in <kbd>client/user/DeleteUser.js</kbd> is basically a button that we will add to the Profile view that, when clicked, opens a <kbd>Dialog</kbd> component asking the user to confirm the <kbd>delete</kbd> action, as shown in the following screenshot: </p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-788 image-border" src="assets/46ebac43-14ae-484d-8393-7445c320f5bf.png" style="width:34.08em;height:11.17em;"/></div>
<p>This component initializes the state with <kbd>open</kbd> set to <kbd>false</kbd> for the <kbd>Dialog</kbd> component, as well as <kbd>redirect</kbd> set to <kbd>false</kbd> so that it isn't rendered first.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/DeleteUser.js</span></kbd>:</p>
<pre>export default function DeleteUser(props) {<br/>    ...<br/>    const [open, setOpen] = useState(false)<br/>    const [redirect, setRedirect] = useState(false)<br/>    ...<br/>}</pre>
<p>The <kbd>DeleteUser</kbd> component will also receive props from the parent component. In this case, the props will contain the <kbd>userId</kbd> that was sent from the <kbd>Profile</kbd> component.</p>
<p>Next, we need some handler methods to open and close the <kbd>dialog</kbd> button. The dialog is opened when the user clicks the <kbd>delete</kbd> button.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/DeleteUser.js</span></kbd>:</p>
<pre>const clickButton = () =&gt; {<br/>    setOpen(true)<br/>}</pre>
<p>The dialog is closed when the user clicks <kbd>cancel</kbd> on the dialog.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/DeleteUser.js</span></kbd>:</p>
<pre>const handleRequestClose = () =&gt; {<br/>    setOpen(false)<br/>}  </pre>
<p>The component will have access to the <kbd>userId</kbd> that's passed in as a prop from the <kbd>Profile</kbd> component, which is needed to call the <kbd>remove</kbd> fetch method, along with the JWT credentials, after the user confirms the <kbd>delete</kbd> action in the dialog.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/DeleteUser.js</span></kbd>:</p>
<pre>const deleteAccount = () =&gt; { <br/>const jwt = auth.isAuthenticated()<br/>    remove({<br/>      userId: props.userId<br/>    }, {t: jwt.token}).then((data) =&gt; {<br/>      if (data &amp;&amp; data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        auth.clearJWT(() =&gt; console.log('deleted'))<br/>        setRedirect(true)<br/>      }<br/>    })<br/>}</pre>
<p><span>On confirmation, the <kbd>deleteAccount</kbd> function calls the <kbd>remove</kbd> fetch method with the <kbd>userId</kbd> from props and JWT from <kbd>isAuthenticated</kbd>. On successful deletion, the</span> user will be <span>signed out and redirected to the Home view. </span>The <kbd>Redirect</kbd> component from React Router is used to redirect the current user to the Home view, as follows:</p>
<pre>if (redirect) {<br/>    return &lt;Redirect to='/'/&gt;<br/>}</pre>
<p>The component function returns the <kbd>DeleteUser</kbd> component elements, including a <kbd>DeleteIcon</kbd> button and the confirmation <kbd>Dialog</kbd>.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/DeleteUser.js</span></kbd>:</p>
<pre>return (&lt;span&gt;<br/>      &lt;IconButton aria-label="Delete" <br/>          onClick={clickButton} color="secondary"&gt;<br/>        &lt;DeleteIcon/&gt;<br/>      &lt;/IconButton&gt;<br/><br/>      &lt;Dialog open={open} onClose={handleRequestClose}&gt;<br/>        &lt;DialogTitle&gt;{"Delete Account"}&lt;/DialogTitle&gt;<br/>        &lt;DialogContent&gt;<br/>          &lt;DialogContentText&gt;<br/>            Confirm to delete your account.<br/>          &lt;/DialogContentText&gt;<br/>        &lt;/DialogContent&gt;<br/>        &lt;DialogActions&gt;<br/>          &lt;Button onClick={handleRequestClose} color="primary"&gt;<br/> Cancel<br/>          &lt;/Button&gt;<br/>          &lt;Button onClick={deleteAccount} <br/>              color="secondary" autoFocus="autoFocus"&gt;<br/>            Confirm<br/>          &lt;/Button&gt;<br/>        &lt;/DialogActions&gt;<br/>      &lt;/Dialog&gt;<br/>    &lt;/span&gt;)</pre>
<p><kbd>DeleteUser</kbd><span> takes the </span><kbd>userId</kbd><span> as a prop to be used in the </span><kbd>delete</kbd><span> fetch call, so we need to add a required prop validation check for this React component. We'll do this next.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating props with PropTypes </h1>
                </header>
            
            <article>
                
<p>To validate the required injection of <kbd>userId</kbd> as a prop to the component, we'll add the<span> </span><kbd>PropTypes</kbd><span> </span>requirement validator to the defined component.</p>
<p><kbd><span>mern-skeleton/client</span><span>/user/DeleteUser.js</span></kbd>:</p>
<pre>DeleteUser.propTypes = {<br/>  userId: PropTypes.string.isRequired<br/>}</pre>
<p>Since we are using the <kbd>DeleteUser</kbd> component in the <kbd>Profile</kbd> component, it gets added to the application view when <kbd>Profile</kbd> is added in <kbd>MainRouter</kbd>.</p>
<p>With the delete user UI added, we now have a frontend that contains all the React component views in order to complete the skeleton application features. But, we still need a common navigation UI to link all these views together and make each view easy to access for the frontend user. In the next section, we will implement this navigation menu component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The  Menu component</h1>
                </header>
            
            <article>
                
<p>The <kbd>Menu</kbd> component will function as a navigation bar across the frontend application by providing links to all the available views, and also by indicating the user's current location in the application.</p>
<p>To implement these navigation bar functionalities, we will use the HOC <span><kbd>withRouter</kbd> </span>from React Router to get access to the <kbd>history</kbd> object's properties. The following code in the <kbd>Menu</kbd> component adds just the title, the <kbd>Home</kbd> icon linked to the root route, and the <kbd>Users</kbd> button, which is linked to the <kbd>'/users'</kbd> route.</p>
<p><kbd><span>mern-skeleton/client</span><span>/core/Menu.js</span></kbd>:</p>
<pre>const Menu = withRouter(({history}) =&gt; (<br/>  &lt;AppBar position="static"&gt;<br/>    &lt;Toolbar&gt;<br/>      &lt;Typography variant="h6" color="inherit"&gt;<br/>        MERN Skeleton<br/>      &lt;/Typography&gt;<br/>      &lt;Link to="/"&gt;<br/>        &lt;IconButton aria-label="Home" style={isActive(history, "/")}&gt;<br/>          &lt;HomeIcon/&gt;<br/>        &lt;/IconButton&gt;<br/>      &lt;/Link&gt;<br/>      &lt;Link to="/users"&gt;<br/>        &lt;Button style={isActive(history, "/users")}&gt;Users&lt;/Button&gt;<br/>      &lt;/Link&gt;<br/>    &lt;/Toolbar&gt;<br/>  &lt;/AppBar&gt;))</pre>
<p>To indicate the current location of the application on the <kbd>Menu</kbd>, we will highlight the link that matches the current location path by changing the color conditionally.</p>
<p><kbd><span>mern-skeleton/client</span><span>/core/Menu.js</span></kbd>:</p>
<pre>const isActive = (history, path) =&gt; {<br/>  if (history.location.pathname == path)<br/>    return {color: '#ff4081'}<br/>  else<br/>    return {color: '#ffffff'}<br/>}</pre>
<p>The <kbd>isActive</kbd> function is used to apply color to the buttons in the <kbd>Menu</kbd>, as follows:</p>
<pre>style={isActive(history, "/users")}</pre>
<p>The remaining links such as <span class="packt_screen">SIGN IN</span>, <span class="packt_screen">SIGN UP</span>, <span class="packt_screen">MY PROFILE</span>, and <span class="packt_screen">SIGN OUT</span> will show up on the <kbd>Menu</kbd> based on whether the user is signed in or not. The following screenshot shows how the Menu renders when the user is not signed in:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-789 image-border" src="assets/af094174-ddd9-4444-9c5c-90ae2230144d.png" style="width:26.25em;height:2.83em;"/></div>
<p>For example, the links to <span class="packt_screen">SIGN UP</span> and <span class="packt_screen">SIGN IN</span> should only appear on the menu when the user is not signed in. Therefore, we need to add it to the <kbd>Menu</kbd> component after the <kbd>Users</kbd> button with a condition.</p>
<p><kbd><span>mern-skeleton/client</span><span>/core/Menu.js</span></kbd>:</p>
<pre>{<br/><strong>  !auth.isAuthenticated() &amp;&amp;</strong> (&lt;span&gt;<br/>    &lt;Link to="/signup"&gt;<br/>       &lt;Button style={isActive(history, "/signup")}&gt; <strong>Sign Up</strong> &lt;/Button&gt;<br/>    &lt;/Link&gt;<br/>    &lt;Link to="/signin"&gt;<br/>       &lt;Button style={isActive(history, "/signin")}&gt; <strong>Sign In</strong> &lt;/Button&gt;<br/>    &lt;/Link&gt;<br/>&lt;/span&gt;)<br/>}</pre>
<p>Similarly, the link to <kbd>MY PROFILE</kbd> and the <kbd>SIGN OUT</kbd> button should only appear on the menu when the user is signed in, and should be added to the <kbd>Menu</kbd> component with the following condition check.</p>
<p><kbd><span>mern-skeleton/client</span><span>/core/Menu.js</span></kbd>:</p>
<pre>{<br/><strong> auth.isAuthenticated() &amp;&amp;</strong> (&lt;span&gt;<br/>   &lt;Link to={"/user/" + auth.isAuthenticated().user._id}&gt;<br/>      &lt;Button style={isActive(history, "/user/" <br/>            + auth.isAuthenticated().user._id)}&gt;<br/>          <strong> My Profile</strong> <br/>      &lt;/Button&gt;<br/>   &lt;/Link&gt;<br/>   &lt;Button color="inherit" <br/>           onClick={() =&gt; { auth.clearJWT(() =&gt; history.push('/')) }}&gt;<br/>        <strong>Sign out</strong><br/>   &lt;/Button&gt;<br/> &lt;/span&gt;)<br/>}</pre>
<p>The <span class="packt_screen">MY PROFILE</span> button uses the signed-in user's information to link to the user's own profile, while the <span class="packt_screen">SIGN OUT</span> button calls the <kbd>auth.clearJWT()</kbd> method when it's clicked. When the user is signed in, the <kbd>Menu</kbd> will look as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-790 image-border" src="assets/f0cc63b3-2970-4e7d-b313-6ff5cc246d62.png" style="width:23.58em;height:2.75em;"/></div>
<p>To have the <kbd>Menu</kbd> navigation bar present in all the views, we need to add it to the <kbd>MainRouter</kbd> before all the other routes, and outside the <kbd>Switch</kbd> component.</p>
<p><kbd><span>mern-skeleton/client</span><span>/MainRouter.js</span></kbd>:</p>
<pre><strong>    &lt;Menu/&gt;</strong><br/>    &lt;Switch&gt;<br/>    …<br/>    &lt;/Switch&gt;</pre>
<p>This will make the <kbd>Menu</kbd> component render on top of all the other components when these components are accessed at their respective routes.</p>
<p>The skeleton frontend is now complete and has all necessary components to allow a user to sign up, view, and modify user data on the backend while considering authentication and authorization restrictions. However, it is still not possible to visit the frontend routes directly in the browser address bar; these can only be accessed when they're linked from within the frontend view. To enable this functionality in the skeleton application, we need to implement basic server-side rendering.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing basic server-side rendering</h1>
                </header>
            
            <article>
                
<p>Currently, when the React Router routes or pathnames are directly entered in the browser address bar or when a view that is not at the root path is refreshed, the URL does not work. This happens because the server does not recognize the React Router routes we defined in the frontend. We have to implement basic server-side rendering on the backend so that the server is able to respond when it receives a request to a frontend route.</p>
<p>To render the <span>relevant </span>React components properly when the server receives requests to the frontend routes, we need to initially generate the React components on the server-side with regard to the React Router and Material-UI components, before the client-side JS is ready to take over the rendering.</p>
<p>The basic idea behind server-side rendering React apps is to use the <kbd>renderToString</kbd> method from <kbd>react-dom</kbd> to convert the root React component into a markup string. Then, we can attach it to the template that the server renders when it receives a request.</p>
<p>In <kbd>express.js</kbd>, we will replace the code that returns <kbd>template.js</kbd> in response to the <kbd>GET</kbd> request for <kbd>'/'</kbd> with code that, upon receiving any incoming GET request, generates some server-side rendered markup and the CSS of the relevant React component tree, before adding this markup and CSS to the template. This updated code will achieve the following:</p>
<pre>app.get('*', (req, res) =&gt; {<br/>     // 1. Generate CSS styles using Material-UI's <kbd>ServerStyleSheets</kbd><br/>     // 2. Use <kbd>renderToString</kbd> to generate markup which renders <br/>           components specific to the route requested<br/>     // 3. Return template with markup and CSS styles in the response<br/>})</pre>
<p>In the following sections, we will look at the implementation of the steps outlined in the preceding code block, and also discuss how to prepare the frontend so that it accepts and handles this server-rendered code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modules for server-side rendering</h1>
                </header>
            
            <article>
                
<p>To implement basic server-side rendering, we will need to import the following React, React Router, and Material-UI-specific modules into the server code. In our code structure, the following modules will be imported into <kbd>server/express.js</kbd>:</p>
<ul>
<li><strong>React modules</strong>: The following modules are required to render the React components and use <kbd>renderToString</kbd>:</li>
</ul>
<pre style="padding-left: 60px">import React from 'react'<br/>import ReactDOMServer from 'react-dom/server'</pre>
<ul>
<li style="font-weight: 400">
<p><strong>Router modules</strong>: <kbd>StaticRouter</kbd> is a stateless router that takes the requested URL to match with the frontend route which was declared in the <kbd>MainRouter</kbd> component. The <kbd>MainRouter</kbd> is the root component in our frontend.</p>
</li>
</ul>
<pre style="padding-left: 60px">import StaticRouter from 'react-router-dom/StaticRouter'<br/>import MainRouter from './../client/MainRouter'</pre>
<ul>
<li><strong>Material-UI modules and the custom theme</strong>: The following modules will help generate the CSS styles for the frontend components based on the stylings and Material-UI theme that are used on the frontend:</li>
</ul>
<pre style="padding-left: 60px">import { ServerStyleSheets, ThemeProvider } from '@material-ui/styles'<br/>import theme from './../client/theme'</pre>
<p>With these modules, we can prepare, generate, and return server-side rendered frontend code, as we will discuss next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating CSS and markup</h1>
                </header>
            
            <article>
                
<p><span>To generate the CSS and markup representing the React frontend views on the server-side, we will use Material-UI's <kbd>ServerStyleSheets</kbd> and React's <kbd>renderToString</kbd>.</span></p>
<p><span>On every request received by the Express app, we will create a new <kbd>ServerStyleSheets</kbd> instance. Then, we will render the relevant React tree with the server-side collector in a call to <kbd>renderToString</kbd>, which ultimately returns the associated markup or HTML string version of the React view that is to be shown to the user in response to the requested URL.</span></p>
<p><span>The following code will be executed on every GET request that's received by the Express app.</span></p>
<p><kbd><span>mern-skeleton/server</span><span>/express.js</span></kbd>:</p>
<pre><span class="p">const sheets = new ServerStyleSheets()<br/>const context = {}<br/>const markup = ReactDOMServer.renderToString(<br/>    sheets.collect(<br/>          &lt;StaticRouter location={req.url} context={context}&gt;<br/>            &lt;ThemeProvider theme={theme}&gt;<br/>              &lt;MainRouter /&gt;<br/>            &lt;/ThemeProvider&gt;<br/>          &lt;/StaticRouter&gt;<br/>        )<br/>  ) </span></pre>
<p><span>While rendering the React tree, the client app's</span> root <span>component, <kbd>MainRouter</kbd></span>, <span>is wrapped with the Material-UI  <kbd>ThemeProvider</kbd> to provide the styling props that are needed by the <kbd>MainRouter</kbd> child components. The stateless <kbd>StaticRouter</kbd> is used here instead of the <kbd>BrowserRouter</kbd> that's used on the client-side in order to wrap <kbd>MainRouter</kbd> and provide the routing props that are used for implementing the client-side components.</span></p>
<p><span>Based on these values, such as the requested <kbd>location</kbd> route and <kbd>theme</kbd> that are passed in as props to the wrapping components, <kbd>renderToString</kbd> will return the markup containing the relevant view.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending a template with markup and CSS</h1>
                </header>
            
            <article>
                
<p>Once the markup has been generated, we need to check if there was a <kbd>redirect</kbd> rendered in the component to be sent in the markup. If there was no redirect, then we get the CSS string from <kbd>sheets</kbd> using <kbd>sheets.toString</kbd>, and, in the response, we send the <kbd>Template</kbd> back with the markup and CSS injected, as shown in the following code.</p>
<p><kbd><span>mern-skeleton/server</span><span>/express.js</span></kbd>:</p>
<pre>if (context.url) {<br/>   return res.redirect(303, context.url)<br/>}<br/>const css = sheets.toString()<br/>res.status(200).send(Template({<br/>   markup: markup,<br/>   css: css<br/>}))</pre>
<p>An example of a case where redirect is rendered in the component is when we're trying to access a <kbd>PrivateRoute</kbd> via a server-side render. As the server-side cannot access the auth token from the browser's <kbd>sessionStorage</kbd>, the redirect in <kbd>PrivateRoute</kbd> will render. The <kbd>context.url</kbd> value , in this case, will have the <kbd>'/signin'</kbd> route, and hence, instead of trying to render the <kbd>PrivateRoute</kbd> component, it will redirect to the <kbd>'/signin'</kbd> route.</p>
<p>This completes the code we need to add to the server-side to enable the basic server-side rendering of the React views. Next, we need to update the frontend so it is able to integrate and render this server-generated code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating template.js</h1>
                </header>
            
            <article>
                
<p>The markup and CSS that we generated on the server must be added to the <kbd>template.js</kbd> HTML code for it to be loaded when the server renders the template. </p>
<p><kbd><span>mern-skeleton</span><span>/template.js</span></kbd>:</p>
<pre>export default (<strong>{markup, css}</strong>) =&gt; {<br/>    return `...<br/>           &lt;div <strong>id="root"</strong>&gt;<strong>${markup}</strong>&lt;/div&gt;<br/>           &lt;style <strong>id="jss-server-side"</strong>&gt;<strong>${css}</strong>&lt;/style&gt; <br/>           ...`<br/>}</pre>
<p>This will load the server-generated code in the browser before the frontend script is ready to take over. In the next section, we will learn how the frontend script needs to account for this takeover from server-rendered code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating App.js</h1>
                </header>
            
            <article>
                
<p>Once the code that's been rendered on the server-side reaches the browser and the frontend script takes over, we need to remove the server-side injected CSS when the root React component mounts, using the <kbd>useEffect</kbd> hook. </p>
<p><kbd><span>mern</span><span>-skeleton/client</span><span>/App.js</span></kbd>:</p>
<pre>React.useEffect(() =&gt; {<br/>    const jssStyles = document.querySelector('#jss-server-side')<br/>    if (jssStyles) {<br/>      jssStyles.parentNode.removeChild(jssStyles)<br/>    }<br/>}, [])</pre>
<p><span>This will give back full control over rendering the React app to the client-side. T</span>o ensure this transfer happens efficiently, we need to update how the ReactDOM renders the views.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hydrate instead of render</h1>
                </header>
            
            <article>
                
<p>Now that the React components will be rendered on the server-side, we can update the <kbd>main.js</kbd> code so that it uses <kbd>ReactDOM.hydrate()</kbd> instead of <kbd>ReactDOM.render()</kbd>:</p>
<pre>import React from 'react'<br/>import { <strong>hydrate</strong> } from 'react-dom'<br/>import App from './App'<br/><br/><strong>hydrate</strong>(&lt;App/&gt;, document.getElementById('root'))</pre>
<p>The <kbd>hydrate</kbd> function hydrates a container that already has HTML content rendered by <kbd>ReactDOMServer</kbd>. This means the server-rendered markup is preserved and only event handlers are attached when React takes over in the browser, allowing the initial load performance to be better.</p>
<p>With basic server-side rendering implemented, direct requests to the frontend routes from the browser address bar can now be handled properly by the server, making it possible to bookmark the React frontend views.</p>
<p>The skeleton MERN application that we've developed in this chapter is now a completely functioning MERN web application with basic user features. We can extend the code in this skeleton to add a variety of features for different applications. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we completed the MERN skeleton application by adding a working React frontend, including frontend routing and basic server-side rendering of the React views.</p>
<p>We started off by updating the development flow so that it included client-side code bundling for the React views. We updated the configuration for Webpack and Babel to compile the React code and discussed how to load the configured Webpack middleware from the Express app to initiate server-side and client-side code compilation from one place during development.</p>
<p>With the development flow updated, and <span>before building out the frontend</span>, we added the relevant React dependencies, along with React Router for frontend routing and Material-UI, to use their existing components in the skeleton app's user interface. </p>
<p>Then, we implemented the top-level root React components and integrated React Router, which allowed us to add client-side r<span>outes for navigation. Using these routes, we loaded the custom</span> React <span>components that we developed <span>using </span></span>Material-UI <span>components </span><span>to make up the skeleton application's user interface</span><span>.</span></p>
<p>To make these React views dynamic and interactive with data fetched from the backend, we used the Fetch API to connect to the backend user APIs. Then, we incorporated authentication and authorization on the frontend views. We did this using <kbd>sessionStorage</kbd>, which stores user-specific details, and JWT fetched from the server on successful sign-in, as well as by limiting access to certain views using a <kbd>PrivateRoute</kbd> component. </p>
<p>Finally, we modified the server code so that we could implement basic server-side rendering, which allows us to load <span>the frontend routes</span> directly in the browser with server-side rendered markup after the server recognizes that the incoming request is actually for a React route. </p>
<p>Now, you should be able to implement and integrate a React-based frontend that incorporates client-side routing and <span>auth management with a standalone server</span> application.</p>
<p>In the next chapter, we will use the concepts we've learned in this chapter to extend the skeleton application code so that we can build a fully-featured social media application.</p>


            </article>

            
        </section>
    </body></html>