- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Common Pitfalls to avoid when Building Microfrontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve come a long way! We’ve learned how to build microfrontends, how to deploy
    them to the native cloud, and how to manage them in production.
  prefs: []
  type: TYPE_NORMAL
- en: As we start working with microfrontends, we will make mistakes, but we will
    learn from them and eventually build our own set of best practices, discovering
    what works best for our use cases. However, it is always a smart thing to learn
    from others’ mistakes as well. In this chapter, we will cover some of the pitfalls
    earlier teams faced when working with microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will teach you about some common pitfalls and how to avoid them, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Not making your microapps too small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the overuse of common shared code/libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding multiple frameworks within a microfrontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inability to deploy individual micro apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessively relying on state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding build-time compilation to assemble Microfrontends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding packing your micro apps into NPM packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about the various pitfalls
    developers fall into when transitioning from single-page apps to microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t make your micro apps too small
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched upon this at the start of the book, but it’s important to stress
    it again. Way too many developers think that, in a microfrontend architecture,
    the micro apps need to be really small. This is not true, as creating very small
    microapps greatly increases the complexity and maintenance headaches, without
    achieving any benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In trying to identify what the right size is for your micro app, we’ve seen
    it helps if we take into consideration the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it the largest possible micro app that can independently exist?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it the largest possible micro app that’s owned by a single agile scrum team?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does this app undergo changes and updates that are at a pace different from
    the rest of the application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another point to consider is thinking in terms of domains, based on domain-driven
    design principles, to determine what business features a given micro app should
    support or not support.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your answer to all the preceding questions is yes, then the micro app is
    the right size. If the answer is no to any one of the preceding questions, then
    either we haven’t broken down our micro apps in the right way or microfrontends
    may not be the right architectural choice.
  prefs: []
  type: TYPE_NORMAL
- en: Another guide to help identify the right size for your app is to look at the
    atomic design pattern ([https://bradfrost.com/blog/post/atomic-web-design/](https://bradfrost.com/blog/post/atomic-web-design/)),
    which defines how components are structured in an application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Organisms and templates can be converted to micro apps](img/Figure_10.01_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Organisms and templates can be converted to micro apps
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the atomic design pattern in *Figure 10**.1*, the ideal level
    to break down your app into micro apps would be either at the organism level or
    the template level; anything other than that would be either too small or too
    big.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the application into the right-sized micro app is key to building
    a performant and scalable microfrontend architecture, and investing more time
    in getting this right will pay high dividends as we move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the overuse of Shared Component Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to building microservices or microfrontends, team independence
    is the highest priority. Anything that makes a team dependent on another team
    should be strongly discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: In our experience as software developers, we’ve always come across principles
    such as **reusability**, **Do not Repeat Yourself** (**DRY**), and so on. In fact
    most senior developers are constantly looking how do they create common utilities,
    helpers shared components, and so on, to help the teams be more productive.
  prefs: []
  type: TYPE_NORMAL
- en: However, when it comes to the world of microservices and microfrontends, overuse
    of these shared libraries can lead to what is called “dependency hell” or a “distributed
    monolith,” which is the worst of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: This is bad for microfrontends because using shared libraries or code immediately
    takes away the independence of teams, as now two or more teams are dependent on
    updates or bug fixes to be made for this shared library, in order for them to
    be able to proceed further.
  prefs: []
  type: TYPE_NORMAL
- en: As more and more teams start using a shared library, it tends to start getting
    bulkier, as it now needs to accommodate the use cases of the different teams.
    There is also a constant risk that changes or updates to this shared code may
    break the functionality of one or more teams.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, when it comes to microfrontends, we need to be strict about not falling
    into this trap. As a rule of thumb, we should avoid creating any business or application
    logic as shared common code. One item that can ideally be shared between micro-apps
    is the UI component library because we want to ensure that all micro apps have
    a consistent look and feel. Another item that can be put into a shared library
    is any other low-level utility function that doesn’t contain any business logic.
    Some examples of these would be an HTTP client, an error-handling utility, or
    other utilities to format dates or manipulate strings.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that with monorepos, it’s a lot easier to “find and replace” than to
    deal with the challenges of a distributed monolith.
  prefs: []
  type: TYPE_NORMAL
- en: While initially the whole idea of prioritizing team independence over code reuse
    may sound like an anti-pattern and not a smart thing to do, speaking from experience,
    this is the second most important point to keep in mind when you want your teams
    to move fast and frequently deploy code to production.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding using multiple frameworks in your microfrontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the benefits of microfrontends is that, technically, it’s possible to
    have each app built using a different framework. However, just because it’s possible
    doesn’t mean you have to. There are numerous drawbacks to using multiple frameworks
    within a single microfrontend:'
  prefs: []
  type: TYPE_NORMAL
- en: The cognitive overload for team members as they potentially switch from one
    team to the other over time is very high.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since every framework comes with its own JavaScript bundle, and since every
    framework will have a different set of NPM modules that the team uses, the amount
    of JavaScript code transferred to the user’s devices will be high. Therefore,
    we will not be able to take full advantage of browser caching or service worker
    caching, since each app uses its own bundle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different frameworks will have different performance challenges and issues,
    and each team will have to deal with them individually and not be able to use
    the collective knowledge within the broader team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having said that, it is fine to have multiple frameworks or multiple versions
    of them for a short transitional phase when you evaluate a new framework or incrementally
    upgrade to a newer version. Overall, though, having multiple frameworks as an
    architecture principle should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: An inability to deploy an individual micro app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary reasons to adopt a microfrontend architecture is to allow
    certain parts of an application to be independently updated without impacting
    the rest of it.
  prefs: []
  type: TYPE_NORMAL
- en: This obviously means that we need the ability to build and deploy each micro
    app independently. If your DevOps build and release pipeline can’t do this, then
    it’s better to go with **Single-Page Application** (**SPA**) architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, many DevOps tools weren’t sophisticated enough to work with monorepos
    or microfrontends; however, most of the latest tools are better equipped to detect
    which folders have changed and only trigger the necessary app builds.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, when working on a microfrontend architecture, it is critical that you’ve
    thought it through and through, including how it will be deployed, as this will
    impact the choice of tools you select for the DevOps pipeline or the monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your DevOps pipelines can be conditionally triggered based on
    which micro app has changed, then you are free to choose any monorepo tool.
  prefs: []
  type: TYPE_NORMAL
- en: However, if your DevOps pipeline is unable to detect changes, or if you are
    limited to a single pipeline for all your microfrontends, then going with a mono
    repo tool such as Nx, which has built-in change detection, would be more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Excessively relying on state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the advent of React, state management became a thing, and with it rose
    the popularity of tools such as Redux that advocated a single central data store
    to manage state. Over time, developers seem to have become obsessed with state
    management, relying far too much on these state management libraries. When developers
    make the shift from SPAs to microfrontends, they continue their obsession with
    state and spend a lot of time trying to persist state, making it work across different
    micro apps. With SPAs and also microfrontends, it is important to sparingly use
    these application-level states. When working with microfrontends, we encourage
    exploring concepts around Pub/Sub or an event emitter approach to sharing data
    between different micro apps. Alternatively, look at native browser data stores,
    such as session storage, IndexedDB, or local storage to manage persistent state,
    or if none of these is an option, then explore lightweight state management libraries
    such as Zustand or React’s Context API.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have realized by now, when building microfrontends, there is a fair
    bit of unlearning and relearning involved, especially if you have been building
    SPAs for a while. The use of state management in microfrontends is something that
    needs to be understood and is also the most difficult change that some developers
    occasionally have to deal with, especially those who have got used to excessively
    relying on state.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding build-time compilation to assemble Microfrontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a current trend in the frontend community to move as many tasks as
    possible to the build time phase of application compilation, rather than the runtime.
    Good examples of these are static site generation, where the HTML pages are generated
    at build time, or **Ahead of Time** (**AoT**) compilation in Angular, which improves
    the overall performance of an application.
  prefs: []
  type: TYPE_NORMAL
- en: While, in general, build-time compilation is a good practice, reducing the load
    on the browser and JavaScript engines during the runtime phase, it doesn’t help
    when assembling the microfrontend. This is because every time any microfrontend
    changes, you need to rebuild the assembly layer as well, defeating the principle
    of independent micro app deployments.
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to have individual micro apps do more work during build time (e.g.,
    generate static pages), but the assembling of micro apps or module federation
    should always be done on the server or at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This is another key point to keep in mind to ensure we don’t blindly follow
    “popular trends.” It is important to always remember what the key principles of
    your architecture pattern are and that you’ve thought through your pattern, end
    to end and all the way to how it will be deployed into production.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding packing your micro apps into NPM packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common trend within the SPA world is to convert any sharable modules
    into NPM packages for easier distribution and then import them into other apps.
  prefs: []
  type: TYPE_NORMAL
- en: In our experience, we have seen a few teams package and version their micro
    apps into NPM modules before importing them into the host or assembly app. We
    strongly discourage this practice for the primary reason that every time a new
    version of a micro app is published as an npm module, all the hosts using that
    micro app will need to update their `package.json` files and rebuild and redeploy
    their apps, defeating the primary principle of independent deployments. We covered
    this in a bit of detail in [*Chapter 2*](B18987_02.xhtml#_idTextAnchor029), *Key
    Principles and Components of Microfrontends*, in the *Prefer runtime* *integrations*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we come to the end of this chapter. Being a relatively new architecture
    pattern, the concepts and best practices around microfrontends are constantly
    evolving.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw some of the common pitfalls that teams have fallen into
    while building microfrontends – namely, things such as not being able to identify
    the right level at which to break down an app into a micro app, overuse of state
    management libraries, using multiple frameworks within a micro app, the inability
    to individually deploy a micro app, overuse of shared common code, and ending
    up with a build-time integration. Hopefully, this chapter will prevent you from
    repeating the same mistakes your peers have made in the past.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point to remember is to understand the reasoning behind these
    best practices, looking at them through the lens of your specific use case. Follow
    the best practices that apply to your use case and tweak the ones that don’t quite
    fit it.
  prefs: []
  type: TYPE_NORMAL
- en: As the famous saying goes, “*The answer to every architecture question is…*
    *it depends.*”
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some of the emerging trends in the world
    of microfrontends that you should keep an eye on.
  prefs: []
  type: TYPE_NORMAL
