- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Deploying Your Code to the Web
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码部署到网络
- en: In the previous two chapters, you had an in-depth look at testing and how it
    can benefit your application. Now that you’re confident in the stability and usability
    of your Vue.js application, it’s time to take a deeper look at how to get that
    code up on the web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，你深入了解了测试以及它如何对你的应用程序产生益处。现在，你对Vue.js应用程序的稳定性和可用性有了信心，是时候深入探讨如何将代码上传到网络上了。
- en: In this chapter, you will be able to explain the benefits of a CI/CD workflow
    and how it ties into the release cycle, release cadence, and development workflows.
    To this end, you’ll be able to articulate the differences between Vue.js development
    and production builds and what trade-offs are made.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将能够解释CI/CD工作流程的好处以及它与发布周期、发布节奏和开发工作流程的联系。为此，你将能够阐述Vue.js开发和生产构建之间的差异以及所做出的权衡。
- en: To test and deploy a Vue.js application, you’ll configure GitLab CI/CD with
    pipelines, jobs, and steps. You’ll become familiar with Netlify, **Amazon Web
    Services Simple Storage Service** (**AWS S3**), and AWS CloudFront, and their
    key similarities and differences.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和部署Vue.js应用程序，你需要配置GitLab CI/CD，使用管道、作业和步骤。你将熟悉Netlify、**亚马逊网络服务简单存储服务**（**AWS
    S3**）和AWS CloudFront，以及它们的关键相似之处和不同之处。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the benefits of CI/CD as part of an agile software development process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索CI/CD作为敏捷软件开发过程一部分的好处
- en: Building our apps for production
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为生产构建我们的应用程序
- en: Using GitLab CI/CD to test our code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitLab CI/CD测试我们的代码
- en: Deploying to Netlify
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到Netlify
- en: Deploying to AWS using S3 and CloudFront
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用S3和CloudFront部署到AWS
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need the `git` CLI, which you will have already used.
    You will also need accounts with both Netlify and Amazon AWS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要`git` CLI，你之前已经使用过了。你还需要Netlify和亚马逊AWS的账户。
- en: 'You may find this chapter’s source here: [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的源代码：[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13)
- en: Exploring the benefits of CI/CD as part of an agile software development process
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索CI/CD作为敏捷软件开发过程一部分的好处
- en: '**Continuous integration** (**CI**) is the practice of integrating code multiple
    times a day. To support this, a modern **version control system** (**VCS**), such
    as Git, which supports multiple working states (branches) in a single repository,
    is necessary to allow developers to work on code independently, while still allowing
    them to collaborate and integrate their changes safely.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是指每天多次将代码集成到一起的实践。为了支持这一做法，需要一个现代的**版本控制系统**（**VCS**），例如Git，它在一个仓库中支持多个工作状态（分支），这样开发者可以独立地工作在代码上，同时仍然能够安全地协作和集成他们的更改。'
- en: To augment the abilities of the VCS, hosting and collaboration tools around
    repositories (such as GitLab or GitHub) have been created that allow developers
    to view and manage code changes more efficiently through a web **user** **interface**
    (**UI**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强VCS的功能，围绕仓库（如GitLab或GitHub）创建了一些托管和协作工具，这些工具允许开发者通过网页**用户界面**（**UI**）更高效地查看和管理代码更改。
- en: As part of, or in addition to, these hosting platforms and the collaboration
    tools they provide, automated checks are crucial to maintaining high confidence
    in the quality of the code before, during, and after integration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些托管平台以及它们提供的协作工具的一部分，或作为补充，自动检查对于在集成前、集成中和集成后保持对代码质量的信心至关重要。
- en: Adopting a CI approach often entails including additional code quality steps,
    such as unit or integration tests, coverage checks, and building artifacts on
    the mainline branches (branches into which changes are integrated) every time
    any new code is integrated. The convention that a team follows for using Git for
    code collaboration and CI is called a **Git workflow**, which is often shortened
    to **Git flow**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 采用CI方法通常包括包括额外的代码质量步骤，例如单元或集成测试、覆盖率检查，以及每次任何新代码集成到主线分支（更改被集成的分支）时在主线分支上构建工件。团队遵循的用于代码协作和CI的Git使用惯例被称为**Git工作流程**，通常简称为**Git
    flow**。
- en: A Git flow will predicate branch naming conventions, as well as how and when
    changes are integrated. For example, a team might decide that branches should
    be prefixed with ticket numbers followed by a short dash-cased description, such
    as `WRK-2334-fix-ie-11-scroll`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Git流程将预测分支命名约定，以及何时以及如何集成更改。例如，一个团队可能会决定分支应该以票号开头，后面跟着一个简短的短划线小写描述，例如`WRK-2334-fix-ie-11-scroll`。
- en: Other examples of conventions that are decided on and adhered to as part of
    a Git flow are commit message lengths and titles, the automated checks that should
    pass or are allowed to fail, and the number of reviewers required to merge a change
    request, which is a pull request or merge request in GitHub and GitLab parlance,
    respectively.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Git流程的一部分，决定并遵守的其他约定示例包括提交消息长度和标题、应该通过或允许失败的自动检查，以及合并更改请求所需的审阅者数量，在GitHub和GitLab的术语中分别对应于拉取请求或合并请求。
- en: 'Git flows fall under two rough categories: (feature) branch-based development
    and trunk-based development. We’ll cover branch-based development first since
    its limitations have become quite clear and the majority of projects tend to use
    trunk-based development.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Git流程分为两大类：（功能）分支开发和主干开发。我们将首先介绍分支开发，因为其局限性已经变得非常明显，而且大多数项目倾向于使用主干开发。
- en: In a branch-based Git workflow, multiple working branches are kept in the repository.
    Branch-based flows can be used to keep branches that mirror the state of environments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于分支的Git工作流程中，多个工作分支被保存在仓库中。基于分支的流程可以用来保持反映环境状态的分支。
- en: 'The following diagram shows three branches – production, staging, and develop:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了三个分支——生产、预发布和开发：
- en: '![Figure 13.1 – A branch-based Git commit/branch tree with three environment
    branches](img/Figure_13.01_B18645.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 具有三个环境分支的基于分支的Git提交/分支树](img/Figure_13.01_B18645.jpg)'
- en: Figure 13.1 – A branch-based Git commit/branch tree with three environment branches
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 具有三个环境分支的基于分支的Git提交/分支树
- en: 'The *production* branch does not contain any changes from *staging* or *develop*.
    The *staging* is ahead of the *production* branch but has no changes in common
    with the *develop* branch other than the changes that are on the *production*
    branch. The *develop* branch is ahead of both the *staging* and *production* branches:
    it’s branched off the *production* branch at the same commit as the *staging*
    branch, but it doesn’t share any further commits with the *staging* branch.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*生产*分支不包含来自*预发布*或*开发*的任何更改。*预发布*分支领先于*生产*分支，但除了*生产*分支上的更改外，与*开发*分支没有共同的变化。*开发*分支领先于*预发布*和*生产*分支：它与*预发布*分支在同一个提交上分支出来，但它不与*预发布*分支共享任何进一步的提交。'
- en: A branch-based workflow can also be used to keep track of changes going into
    release lines. This is useful in cases where a project has to maintain two versions
    of an application or library, but bug fixes or security patches need to be applied
    to both versions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基于分支的工作流程也可以用来跟踪进入发布线的更改。在项目需要维护应用程序或库的两个版本，但需要对两个版本都应用错误修复或安全补丁的情况下，这很有用。
- en: 'In the following example, we have got a similar branching example as the environment
    branch one. Release 1.0.0 contains some changes that are not present in 1.0.1
    and 1.1.0 but does not share any of the newer code. Releases 1.0.1 and 1.1.0 are
    branched off of 1.0.0 at the same time, but they do not share further changes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们得到了一个与环境分支类似的分支示例。版本1.0.0包含了一些在1.0.1和1.1.0中不存在的变化，但并不共享任何新的代码。版本1.0.1和1.1.0同时从1.0.0分支出来，但它们没有共享进一步的更改：
- en: '![Figure 13.2 – A branch-based Git commit/branch tree with three release branches](img/Figure_13.02_B18645.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 具有三个发布分支的基于分支的Git提交/分支树](img/Figure_13.02_B18645.jpg)'
- en: Figure 13.2 – A branch-based Git commit/branch tree with three release branches
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 具有三个发布分支的基于分支的Git提交/分支树
- en: 'In a trunk-based Git flow, each member of the team will create new branches
    off of a single branch, usually the *master* branch. This process is often referred
    to as **branching** **off of**:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于主干的工作流程中，团队中的每个成员都会从一个分支创建新的分支，通常是从*master*分支。这个过程通常被称为**从**：
- en: '![Figure 13.3 – A sample trunk-based Git commit/branch tree with two feature
    branches branched off of the master](img/Figure_13.03_B18645.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 一个示例主干基于的Git提交/分支树，有两个从master分支分支出来的功能分支](img/Figure_13.03_B18645.jpg)'
- en: Figure 13.3 – A sample trunk-based Git commit/branch tree with two feature branches
    branched off of the master
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 一个基于主分支的Git提交/分支树示例，有两个从主分支分叉出来的功能分支
- en: An extreme case of a trunk-based workflow is to have a *single* branch that
    everyone commits on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主分支的工作流程的一个极端情况是拥有一个*单一*的分支，每个人都提交到这个分支。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a trunk-based environment, an alternative to *release branches* is to use
    Git tags to keep track of release snapshots. This gives the same advantages as
    maintaining branches but with reduced branch noise and the added benefit of immutability
    since tags cannot be changed once they’re created.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于主分支的环境中，除了*发布分支*之外，还可以使用Git标签来跟踪发布快照。这提供了与维护分支相同的优势，但减少了分支噪音，并且由于标签一旦创建就不能更改，因此具有不可变性的额外好处。
- en: '**Continuous delivery** (**CD**) is the ability of a team to deploy every good
    build to a production environment.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续交付**（**CD**）是团队能够将每个良好的构建部署到生产环境的能力。'
- en: A prerequisite to CD is CI since CI provides some initial confidence in the
    quality of a build. As part of CD, new systems, tools, and practices are required
    beyond CI.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CD的一个先决条件是CI，因为CI为构建的质量提供了一些初始的信心。作为CD的一部分，除了CI之外，还需要新的系统、工具和实践。
- en: 'The following diagram shows the tools and practices that relate more to CI
    and those that relate more to CD:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了与CI和CD实践相关的工具和那些更相关的工具：
- en: '![Figure 13.4 – The relationship between CI and CD practices](img/Figure_13.04_B18645.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – CI和CD实践之间的关系](img/Figure_13.04_B18645.jpg)'
- en: Figure 13.4 – The relationship between CI and CD practices
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – CI和CD实践之间的关系
- en: The extra ingredient required to adopt CD is a high level of confidence that
    the application is going to keep working as expected (for the end user) and that
    new defects have not been unwittingly introduced. This means an additional end-to-end
    testing step is needed during or after the CI checks, to validate the build before
    being able to deploy it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 采用CD所需的额外成分是对应用程序将继续按预期（对于最终用户）工作以及新缺陷没有无意中引入的高度信心。这意味着在CI检查期间或之后需要额外的端到端测试步骤，以在部署之前验证构建。
- en: These end-to-end tests can be conducted manually, or they can be automated.
    In an ideal CD setup, the latter (automated end-to-end tests) is preferred since
    it means deployments do not include manual interaction. If the end-to-end tests
    pass, the build can be deployed automatically.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端到端测试可以手动进行，也可以自动化。在一个理想的CD设置中，后者（自动端到端测试）是首选的，因为这意味着部署不包括手动交互。如果端到端测试通过，构建可以自动部署。
- en: To facilitate CD, systems that used to deploy software have had to be rethought.
    As part of CD, deployment cannot be a long-winded manual process. This has led
    to companies adopting cloud-native technologies, such as Docker, and **Infrastructure
    as Code** (**IaC**) tools, such as HashiCorp’s **Terraform**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于持续部署（CD），以前用于部署软件的系统必须重新思考。作为CD的一部分，部署不能是一个冗长的手动过程。这导致公司采用云原生技术，如Docker，以及**基础设施即代码**（**IaC**）工具，如HashiCorp的**Terraform**。
- en: The emphasis on moving toward CD practices has led to the inception of ideas
    such as **GitOps** and **ChatOps**. In GitOps and ChatOps, deployments and operational
    tasks are driven by the tools that developers and stakeholders interact with daily.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重视转向CD实践导致了**GitOps**和**ChatOps**等想法的诞生。在GitOps和ChatOps中，部署和运营任务是由开发人员和利益相关者每天交互的工具驱动的。
- en: In GitOps, deployments can be done through GitHub/GitLab (or another Git-hosting
    provider), directly with GitHub Actions or GitLab CI/CD, or through CI/CD software
    (such as CircleCI or Jenkins), which have tight integrations and reporting with
    GitHub/GitLab.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitOps中，部署可以通过GitHub/GitLab（或另一个Git托管提供商）直接进行，使用GitHub Actions或GitLab CI/CD，或者通过CI/CD软件（如CircleCI或Jenkins）进行，这些软件与GitHub/GitLab有紧密的集成和报告功能。
- en: In the case of ChatOps, conversational interfaces are used to deploy and operate
    the software. Some flavors of ChatOps can be considered a subset of GitOps – for
    example, interacting with tools such as **Dependabot** (a tool that keeps a project’s
    dependencies up to date) through comments on a GitHub pull request.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在ChatOps的情况下，使用对话界面来部署和操作软件。某些ChatOps的变体可以被认为是GitOps的一个子集——例如，通过GitHub拉取请求的评论与工具（如**Dependabot**，一个保持项目依赖项更新的工具）进行交互。
- en: ChatOps can also be implemented right into real-time chat tools, such as Slack
    or Microsoft Teams. Someone might send a message such as `deploy <service-name>
    <environment>`, which will deploy the service to the relevant environment. Note
    that chat interfaces are very reminiscent of command-line interfaces, which developers
    might be used to but other stakeholders might take some time to adopt them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ChatOps 也可以直接集成到实时聊天工具中，如 Slack 或 Microsoft Teams。有人可能会发送一条消息，例如 `deploy <service-name>
    <environment>`，这将把服务部署到相关环境。请注意，聊天界面非常类似于命令行界面，开发者可能已经习惯了，但其他利益相关者可能需要一些时间来适应。
- en: 'Now that we’ve looked at approaches to CI and CD, let’s discuss the advantages
    of using CI and CD:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了 CI 和 CD 的方法，让我们讨论使用 CI 和 CD 的优势：
- en: '| **Continuous Integration** | **Continuous Delivery** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **持续集成** | **持续交付** |'
- en: '| Ensures the changeset being integrated is small (at most, a couple of days’
    worth of work) | Delivering value to production can be done more often and more
    safely |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 确保正在集成的更改集很小（最多几天的工作量） | 更频繁、更安全地向生产交付价值 |'
- en: '| Reduces the chance of huge sweeping changes across the code base causing
    unforeseen bugs | A small changeset (a couple of days’ worth of work) can be rolled
    back without any issue |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 减少了在代码库中造成未预知错误的巨大全面更改的可能性 | 一小部分更改集（几天的工作量）可以无问题回滚 |'
- en: '| Testing, code quality, and review steps give confidence in a clean integration
    | A larger changeset due to a longer fixed (monthly, weekly, or every sprint)
    release cadence (as opposed to CD) can have unforeseen consequences; the effect
    rollbacks have on a large release is complicated to grasp |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 测试、代码质量和审查步骤为干净的集成提供了信心 | 由于较长的固定（每月、每周或每冲刺）发布周期（与 CD 相比），较大的更改集可能产生未预见的后果；回滚对大型发布的影响难以理解
    |'
- en: Figure 13.5 – Advantages of CI and CD
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – CI 和 CD 的优势
- en: Both practices also have an impact on the team’s mindset and performance. Being
    able to see the changes you make integrated within a day and in production in
    less than a week means that contributors can see their work having an impact immediately.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种实践也对团队的心态和表现产生影响。能够在一天内看到你做出的更改集成，并在一周内投入生产，这意味着贡献者可以立即看到他们的工作产生影响。
- en: CI/CD also helps promote agile principles, where changes are applied and deployed
    iteratively. This is as opposed to long timelines for projects, for which inaccuracies
    in estimations compound and can cause major delays.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 还有助于推广敏捷原则，其中更改是迭代应用和部署的。这与项目长期时间表形成对比，对于这些项目，估计不准确会累积并可能导致重大延误。
- en: With that, you’ve had a deep look at CI and CD. While both certainly imply more
    work in your process, the benefits will pay for themselves down the road with
    better stability and the ability to more nimbly respond to issues and add new
    features. Now, let’s put this into practice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经深入了解了 CI 和 CD。虽然两者确实意味着你的流程中会有更多的工作，但长远来看，这些好处将因更好的稳定性和更灵活地响应问题和添加新功能而得到回报。现在，让我们将其付诸实践。
- en: Building our apps for production
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生产构建我们的应用程序
- en: Deploying applications to production starts with creating an artifact that can
    be deployed. In the case of Vue.js, we’re building a client-side application,
    which means our build artifact will contain HTML, JavaScript, and CSS files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到生产环境始于创建一个可以部署的工件。在 Vue.js 的情况下，我们构建的是客户端应用程序，这意味着我们的构建工件将包含 HTML、JavaScript
    和 CSS 文件。
- en: A Vue project scaffolded with Vite will have a `build` command. As part of the
    build process, Vite will take JavaScript, Vue single-file components, and modules
    that are imported into each other and *bundle* them. **Bundling** means that related
    chunks of code that depend on each other will be output as a single JavaScript
    file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vite 框架搭建的 Vue 项目将包含一个 `build` 命令。在构建过程中，Vite 会处理 JavaScript、Vue 单文件组件以及相互导入的模块，并将它们
    *打包*。**打包**意味着相互依赖的相关代码块将输出为一个单一的 JavaScript 文件。
- en: The Vue CLI build step also includes a `dead code elimination` step. This means
    that it can analyze the code being generated and if any of it is never used –
    for example, a statement such as `if (false) { /* do something */}` – then it
    will not be present in the build output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Vue CLI 构建步骤还包括一个 `dead code elimination` 步骤。这意味着它可以分析正在生成的代码，如果其中任何部分从未使用过——例如，一个如
    `if (false) { /* do something */}` 的语句——那么它将不会出现在构建输出中。
- en: By default, the Vite builds for production when we call `vite build`, which,
    in Vue projects, is aliased to the `build` script, which can be run with `npm
    run build` or `yarn build`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们在 Vue 项目中调用 `vite build` 时，Vite 会为生产环境构建，在 Vue 项目中，这被别名设置为 `build`
    脚本，可以通过 `npm run build` 或 `yarn build` 来运行。
- en: 'In a sample Vue project, we’ll see something along these lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个示例 Vue 项目中，我们会看到类似以下的内容：
- en: '![Figure 13.6 – Output of “npm run build” in a fresh Vue project](img/Figure_13.06_B18645.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 新建 Vue 项目中“npm run build”的输出](img/Figure_13.06_B18645.jpg)'
- en: Figure 13.6 – Output of “npm run build” in a fresh Vue project
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 新建 Vue 项目中“npm run build”的输出
- en: The `dist` folder is now ready to deploy using a static hosting solution such
    as Netlify or AWS S3 and CloudFront.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist` 文件夹现在可以使用 Netlify 或 AWS S3 和 CloudFront 等静态托管解决方案进行部署。'
- en: With that, we’ve seen how to build a Vue.js application for production using
    the Vite CLI with the `npm run build` command. Next, we will learn how to use
    GitLab CI/CD to test our code (before deploying it).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经看到了如何使用 Vite CLI 和 `npm run build` 命令来构建 Vue.js 应用程序用于生产。接下来，我们将学习如何使用
    GitLab CI/CD 来测试我们的代码（在部署之前）。
- en: Using GitLab CI/CD to test our code
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitLab CI/CD 测试我们的代码
- en: GitLab has a built-in CI/CD tool called GitLab CI/CD. To use GitLab CI/CD, you’ll
    need a GitLab account. To interact with Git repositories hosted on GitLab, you’ll
    also need to associate an SSH key from your machine to your GitLab account.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 有一个内置的 CI/CD 工具，称为 GitLab CI/CD。要使用 GitLab CI/CD，你需要一个 GitLab 账户。要与 GitLab
    上托管的 Git 仓库交互，你还需要将你的机器上的 SSH 密钥关联到你的 GitLab 账户。
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instructions for adding an SSH key can be found in the GitLab documentation
    at [https://docs.gitlab.com/ee/ssh/index.html](https://docs.gitlab.com/ee/ssh/index.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab 文档中可以找到添加 SSH 密钥的说明，网址为 [https://docs.gitlab.com/ee/ssh/index.html](https://docs.gitlab.com/ee/ssh/index.html)。
- en: Once you’ve created an account, you can create a new repository using the **Create
    blank project** action, as shown in the following screenshot. If you are an existing
    user, you can use the **Create new project** button at the top right of the **Projects**
    page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了账户，你可以通过**创建空白项目**操作创建一个新的存储库，如下面的截图所示。如果你是现有用户，你可以在**项目**页面的右上角使用**创建新项目**按钮。
- en: '![Figure 13.7 – The GitLab Projects page with the New Project button](img/Figure_13.07_B18645.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 带有新建项目按钮的 GitLab 项目页面](img/Figure_13.07_B18645.jpg)'
- en: Figure 13.7 – The GitLab Projects page with the New Project button
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 带有新建项目按钮的 GitLab 项目页面
- en: 'Regardless of your choice, you will be taken to the **New project** page, where
    you can create a project by giving it a name and a slug, as seen in the following
    screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你的选择如何，你都会被带到**新项目**页面，在那里你可以通过给它一个名称和一个缩写来创建一个项目，如下面的截图所示：
- en: "![Figure 13.8 – The GitLab New \uFEFFproject page](img/Figure_13.08_B18645.jpg)"
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – GitLab 新建项目页面](img/Figure_13.08_B18645.jpg)'
- en: Figure 13.8 – The GitLab New project page
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – GitLab 新建项目页面
- en: 'Once you click **Create project**, the GitLab project page will appear in an
    empty state that displays instructions on how to clone it. You should run the
    commands required to clone the repository, which probably boils down to something
    similar to the following (which you are expected to run on your machine):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击**创建项目**，GitLab 项目页面将以空状态出现，显示如何克隆它的说明。你应该运行克隆存储库所需的命令，这很可能类似于以下内容（你需要在你的机器上运行）：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can find the proper URL by clicking on the blue **Clone** button.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击蓝色的**克隆**按钮来找到正确的 URL。
- en: On your machine, open the directory into which the repository was cloned. To
    add GitLab CI/CD, we need to add a `.gitlab-ci.yml` file to the root of the project.
    A sample `.gitlab-ci.yml` file that adds a `build` job to the `build` stage of
    the pipeline, installs dependencies (using `npm ci`), runs the production build
    (`npm run build`), and caches the output artifact is defined as follows.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的机器上，打开克隆存储库的目录。为了添加 GitLab CI/CD，我们需要在项目的根目录中添加一个 `.gitlab-ci.yml` 文件。一个示例
    `.gitlab-ci.yml` 文件，它将一个 `build` 作业添加到管道的 `build` 阶段，安装依赖项（使用 `npm ci`），运行生产构建（`npm
    run build`），并缓存输出工件，如下所示。
- en: It will begin with a job name that is defined by setting a top-level key in
    the YAML file – in this case, `build:`. In YAML syntax, we must increase the indent
    to denote that the `build` key points to an object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它将以一个在 YAML 文件中定义的顶级键命名的作业名称开始 – 在这种情况下，`build:`。在 YAML 语法中，我们必须增加缩进来表示 `build`
    键指向一个对象。
- en: 'In the `build job` object, we will define which Docker image is used to run
    the job, using `image: node:lts`. This means we want this job to run on a Node.js
    **Long-Term Support** (**LTS**) image, which will be Node.js 16 as of early 2022.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '在`build job`对象中，我们将定义用于运行作业的Docker镜像，使用`image: node:lts`。这意味着我们希望这个作业在Node.js
    **长期支持**（**LTS**）镜像上运行，截至2022年初将是Node.js 16。'
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can access the up-to-date Node.js LTS schedule at [https://nodejs.org/en/about/releases/](https://nodejs.org/en/about/releases/).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问最新的Node.js LTS发布计划，网址为[https://nodejs.org/en/about/releases/](https://nodejs.org/en/about/releases/)。
- en: 'The other property we can define in our job is the stage. By default, GitLab
    CI/CD pipelines have three stages: **Build**, **Test**, and **Deploy**. These
    stages can be replaced using custom stages when a team’s workflow doesn’t fit
    into these three categories (for example, if there is more than one environment
    to deploy to). Our pipeline only has one stage and one job at the moment, so most
    of the preceding doesn’t apply to us.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在作业中定义的另一个属性是阶段。默认情况下，GitLab CI/CD流水线有三个阶段：**构建**、**测试**和**部署**。当团队的工作流程不适合这三个类别时（例如，如果需要部署到多个环境），可以使用自定义阶段来替换这些阶段。我们的流水线目前只有一个阶段和一个作业，所以大部分前面的内容不适用于我们。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re curious, `stages` is used to define stages that can be used by jobs,
    and it is defined globally ([https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，`stages`用于定义作业可以使用的阶段，并且它是全局定义的（[https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages)）。
- en: 'The specification of `stages` allows for flexible multistage pipelines. The
    ordering of elements in stages defines the ordering of jobs’ execution:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`stages`的指定允许灵活的多阶段流水线。阶段中元素的顺序定义了作业执行的顺序：'
- en: a) Jobs of the same stage are run in parallel
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: a) 同一阶段的作业并行运行
- en: b) Jobs of the next stage are run after the jobs from the previous stage have
    been completed successfully
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: b) 下一个阶段的作业将在上一个阶段的作业成功完成后运行
- en: 'See the documentation for more information: [https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅文档：[https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages)。
- en: The final properties we set are `script`, which defines steps that should be
    run when the job is running, and `artifacts`, which configures artifact storage.
    In our case, we’ll run `npm ci` to install all the dependencies, followed by `npm
    run build`, which will run the production Vue.js build. Our artifact has been
    set up to be held for a week and to contain the `dist` folder (which is where
    the Vite CLI `build` output is stored).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的最后一个属性是`script`，它定义了作业运行时应运行的步骤，以及`artifacts`，它配置了工件存储。在我们的例子中，我们将运行`npm
    ci`来安装所有依赖项，然后是`npm run build`，这将运行生产Vue.js构建。我们的工件已设置为保留一周，并包含`dist`文件夹（这是Vite
    CLI `build`输出存储的地方）。
- en: 'In full, we have the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完整来说，我们有以下内容：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we push this `.gitlab-ci.yml` file to a repository containing a Vue CLI
    project, we will see the following in the repository view, where a pipeline with
    one step is running on the latest commit:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将此`.gitlab-ci.yml`文件推送到包含Vue CLI项目的存储库，我们将在存储库视图中看到以下内容，其中在最新提交上正在运行一个步骤的流水线：
- en: '![Figure 13.9 – GitLab repository view with the build job running on the latest
    commit](img/Figure_13.09_B18645.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – GitLab存储库视图，构建作业在最新提交上运行](img/Figure_13.09_B18645.jpg)'
- en: Figure 13.9 – GitLab repository view with the build job running on the latest
    commit
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – GitLab存储库视图，构建作业在最新提交上运行
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GitLab now requires user verification before running pipelines. This can be
    done with a credit card; GitLab will *not* charge your card. It is only used as
    part of the validation process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab现在在运行流水线之前需要用户验证。这可以通过信用卡完成；GitLab**不会**向您的信用卡收费。它仅作为验证过程的一部分使用。
- en: 'If we click on the `Build` represents the `state` pipeline (which we set as
    `build`), which represents the job name (which we defined as `build`). We will
    see the same in-progress indicator until the job completes, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击`Build`（表示`状态`流水线，我们将其设置为`build`），它表示作业名称（我们定义为`build`），我们将看到相同的进行中指示器，直到作业完成，如下所示：
- en: '![Figure 13.10 – GitLab CI pipeline view with the build job complete](img/Figure_13.10_B18645.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – GitLab CI流水线视图，构建作业已完成](img/Figure_13.10_B18645.jpg)'
- en: Figure 13.10 – GitLab CI pipeline view with the build job complete
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – GitLab CI流水线视图，构建作业已完成
- en: Once the job completes, we will see a **Success** icon (green checkmark). We
    can click this icon or the job name to access the **Job** view while the job is
    running or after it has been completed (whether it has failed or succeeded). When
    a job has been completed, we will also see a **Retry** icon, which can be useful
    if we wish to retry a failed pipeline step.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作业完成后，我们将看到一个**成功**图标（绿色勾号）。我们可以在作业运行时或完成后（无论它是否失败或成功）点击此图标或作业名称来访问**作业**视图。当作业完成后，我们还将看到一个**重试**图标，如果我们希望重试失败的管道步骤，这可能很有用。
- en: 'The following screenshot shows that the job ran successfully:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示作业运行成功：
- en: '![Figure 13.11 – GitLab CI pipeline view with the build job passing](img/Figure_13.11_B18645.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11 – 构建作业通过的GitLab CI管道视图](img/Figure_13.11_B18645.jpg)'
- en: Figure 13.11 – GitLab CI pipeline view with the build job passing
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 构建作业通过的GitLab CI管道视图
- en: 'After clicking the job, we will see the `docker_machine` executor, which load
    up the Node.js Docker image, we can see the steps for running the script, as well
    as cache and artifact restores, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 点击作业后，我们将看到`docker_machine`执行器，它加载Node.js Docker镜像，我们可以看到运行脚本的步骤，以及缓存和工件恢复，如下所示：
- en: '![Figure 13.12 – The GitLab CI job view with the successful build job](img/Figure_13.12_B18645.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12 – 成功构建作业的GitLab CI作业视图](img/Figure_13.12_B18645.jpg)'
- en: Figure 13.12 – The GitLab CI job view with the successful build job
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – 成功构建作业的GitLab CI作业视图
- en: If we want to add a `test` step to our GitLab CI/CD runs, we need to be in a
    project that supports unit testing. Installing and adding unit tests was covered
    in depth in [*Chapter 11*](B18645_11.xhtml#_idTextAnchor444), *Unit Testing*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在GitLab CI/CD运行中添加一个`test`步骤，我们需要在一个支持单元测试的项目中。安装和添加单元测试在[*第11章*](B18645_11.xhtml#_idTextAnchor444)，*单元测试*中进行了详细说明。
- en: 'We will need to add a new job to the `.gitlab-ci.yml` file; we will call it
    `test`, use the `node:lts` image, and assign the job to the `test` state. In the
    job, we must run `npm ci`, followed by `npm run test:unit` (which is the `npm`
    script added by the `unit-jest` CLI plugin):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`.gitlab-ci.yml`文件中添加一个新的作业；我们将称之为`test`，使用`node:lts`镜像，并将作业分配给`test`状态。在作业中，我们必须运行`npm
    ci`，然后是`npm run test:unit`（这是由`unit-jest`CLI插件添加的`npm`脚本）：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we push this new `.gitlab-ci.yml` file up, we will get the following view
    on the main repository page:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送这个新的`.gitlab-ci.yml`文件，我们将在主仓库页面上看到以下视图：
- en: '![Figure 13.13 – Repository view with GitLab CI/CD running the pipeline with
    the new test step](img/Figure_13.13_B18645.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13 – GitLab CI/CD运行带有新测试步骤的管道的仓库视图](img/Figure_13.13_B18645.jpg)'
- en: Figure 13.13 – Repository view with GitLab CI/CD running the pipeline with the
    new test step
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 – GitLab CI/CD运行带有新测试步骤的管道的仓库视图
- en: 'We can click through to the pipeline view. The reason GitLab CI/CD uses pipelines
    is that a failing step at a certain stage will mean steps in any subsequent stages
    will not run. For example, if we get a failing `build` job, the jobs that are
    part of the `test` stage will not run:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击进入管道视图。GitLab CI/CD使用管道的原因是，在某个阶段失败的步骤将意味着后续任何阶段的步骤都不会运行。例如，如果我们得到一个失败的`build`作业，属于`test`阶段的作业将不会运行：
- en: '![Figure 13.14 – GitLab CI/CD pipeline view with a failed build job that stops
    the test job/stage from running](img/Figure_13.14_B18645.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图13.14 – 带有停止测试作业/阶段的失败构建作业的GitLab CI/CD管道视图](img/Figure_13.14_B18645.jpg)'
- en: Figure 13.14 – GitLab CI/CD pipeline view with a failed build job that stops
    the test job/stage from running
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 – 带有停止测试作业/阶段的失败构建作业的GitLab CI/CD管道视图
- en: 'If we push another commit or retry the build step (if the failure is not caused
    by changes) and navigate to the pipeline view again, we’ll see the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们推送另一个提交或重试构建步骤（如果失败不是由更改引起的）并再次导航到管道视图，我们将看到以下内容：
- en: '![Figure 13.15 – GitLab CI/CD pipeline view with the test job running after
    the build stage jobs have all succeeded](img/Figure_13.15_B18645.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图13.15 – 构建阶段所有作业都成功后运行的测试作业的GitLab CI/CD管道视图](img/Figure_13.15_B18645.jpg)'
- en: Figure 13.15 – GitLab CI/CD pipeline view with the test job running after the
    build stage jobs have all succeeded
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 – 构建阶段所有作业都成功后运行的测试作业的GitLab CI/CD管道视图
- en: 'Once the `test` job has succeeded, we’ll see the following pipeline:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`test`作业成功，我们将看到以下管道：
- en: '![Figure 13.16 – GitLab CI/CD pipeline view with all jobs succeeding in the
    build and test stages](img/Figure_13.16_B18645.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图13.16 – 构建和测试阶段所有作业都成功的GitLab CI/CD管道视图](img/Figure_13.16_B18645.jpg)'
- en: Figure 13.16 – GitLab CI/CD pipeline view with all jobs succeeding in the build
    and test stages
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16 – GitLab CI/CD管道视图，所有作业在构建和测试阶段均成功
- en: We’ve now added a GitLab CI/CD pipeline with the `build` and `test` stages that
    will validate that, on every push to the GitLab repository, the code still integrates
    as expected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个包含`build`和`test`阶段的GitLab CI/CD管道，以确保在每次向GitLab仓库推送时，代码仍然按预期集成。
- en: Exercise 13.01 – adding a lint step to our GitLab CI/CD pipeline
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01 – 向我们的GitLab CI/CD管道添加代码风格检查步骤
- en: '**Linting** is a way to get automated formatting and code style checks. Integrating
    it as part of CI makes sure that all code merged into the mainline branches adheres
    to a team’s code style guide. It also reduces the number of code style review
    comments, which can be noisy and might detract from fundamental issues with the
    change request.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码风格检查**是一种获取自动化格式化和代码风格检查的方法。将其集成到CI过程中可以确保所有合并到主线分支的代码都遵循团队的代码风格指南。它还可以减少代码风格审查评论的数量，这些评论可能会很嘈杂，并可能分散对变更请求基本问题的关注。'
- en: You can find the complete code for this exercise at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.01)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.01)找到此练习的完整代码。
- en: 'To add linting, follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加代码风格检查，请按照以下步骤操作：
- en: 'First, we need to ensure that our `package.json` file includes the `lint` script.
    If it’s missing, we’ll need to add it. The `eslint-plugin-vue` website ([https://eslint.vuejs.org/](https://eslint.vuejs.org/))
    documents this. Once installed, use it in the lint script, like so:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要确保我们的`package.json`文件包含`lint`脚本。如果它缺失，我们需要添加它。`eslint-plugin-vue`网站([https://eslint.vuejs.org/](https://eslint.vuejs.org/))对此进行了说明。一旦安装，就可以在代码风格检查脚本中使用它，如下所示：
- en: '[PRE3]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To run the lint on GitLab CI/CD, add a new `lint` job that will run in a Node.js
    LTS Docker image at the `test` stage of the GitLab CI/CD pipeline. We will do
    this in `.gitlab-ci.yml`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在GitLab CI/CD上运行代码风格检查，请添加一个新的`lint`作业，该作业将在GitLab CI/CD管道的`test`阶段运行Node.js
    LTS Docker镜像。我们将在`.gitlab-ci.yml`文件中这样做：
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For the `lint` job to run the `lint` script as per `package.json`, we need
    to add a `script` section in the `.gitlab-ci.yml` file. First, it needs to run
    `npm ci` to install the dependencies, and then `npm run lint` to start the linting
    process:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让`lint`作业按照`package.json`中的设置运行`lint`脚本，我们需要在`.gitlab-ci.yml`文件中添加一个`script`部分。首先，它需要运行`npm
    ci`来安装依赖项，然后运行`npm run lint`以启动代码风格检查过程：
- en: '[PRE15]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, `commit` and `push` the code to GitLab using the following commands:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令将代码`commit`和`push`到GitLab：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the code has been pushed, we will see the pipeline run using the GitLab
    CI/CD UI, as follows (note how all the jobs at the `test` stage are run in parallel):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码被推送，我们将在GitLab CI/CD UI中看到管道运行，如下所示（注意`test`阶段的所有作业是如何并行运行的）：
- en: '![Figure 13.17 – The GitLab CI/CD pipeline view with all the jobs succeeding,
    including “test” and “lint” running in parallel](img/Figure_13.17_B18645.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图13.17 – GitLab CI/CD管道视图，所有作业均成功，包括并行运行的“测试”和“代码风格检查”](img/Figure_13.17_B18645.jpg)'
- en: Figure 13.17 – The GitLab CI/CD pipeline view with all the jobs succeeding,
    including “test” and “lint” running in parallel
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17 – GitLab CI/CD管道视图，所有作业均成功，包括并行运行的“测试”和“代码风格检查”
- en: We’ve now seen how to use GitLab CI/CD to run builds and tests on every commit.
    Next, we’ll learn how to deploy a Vue.js application to Netlify.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何使用GitLab CI/CD在每次提交时运行构建和测试。接下来，我们将学习如何将Vue.js应用程序部署到Netlify。
- en: Deploying to Netlify
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Netlify
- en: Netlify is a hosting provider that specializes in static hosting and relevant
    supporting services to provide a fully interactive site that uses static hosting.
    This includes offerings such as Netlify Functions (serverless functions), Netlify
    Forms (a no-backend form submission system), and Netlify Identity (an identity/authentication
    provider).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify是一家专注于静态网站托管和相关支持服务的托管提供商，它提供完全交互式的网站，使用静态网站托管。这包括Netlify Functions（无服务器函数）、Netlify
    Forms（无后端表单提交系统）和Netlify Identity（身份/认证提供商）等服务。
- en: The following sections require you to have a free Netlify account (you can sign
    up for one at [https://app.netlify.com/signup](https://app.netlify.com/signup)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分需要您拥有一个免费的Netlify账户（您可以在[https://app.netlify.com/signup](https://app.netlify.com/signup)注册一个账户）。
- en: 'The simplest way to deploy a site to Netlify is to use the drag-and-drop interface.
    You’ll find this at the bottom of the **Sites** page in the logged-in view, as
    follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将网站部署到 Netlify 最简单的方法是使用拖放界面。您可以在登录视图的 **站点** 页面的底部找到它，如下所示：
- en: '![Figure 13.18 – Netlify’s drag-and-drop deployment section at the bottom of
    the App home page](img/Figure_13.18_B18645.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.18 – Netlify 应用程序主页底部的拖放部署区域](img/Figure_13.18_B18645.jpg)'
- en: Figure 13.18 – Netlify’s drag-and-drop deployment section at the bottom of the
    App home page
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.18 – Netlify 应用程序主页底部的拖放部署区域
- en: 'Now, we can choose a project where we’ve run the `npm run build` command and
    deploy the `dist` folder by simply dragging it to the drag-and-drop deployment
    section, as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以选择一个已经运行了 `npm run build` 命令的项目，并通过简单地将其拖动到拖放部署区域来部署 `dist` 文件夹，如下面的截图所示：
- en: '![Figure 13.19 – Dragging and dropping the dist folder into the Netlify drag-and-drop
    deployment section](img/Figure_13.19_B18645.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.19 – 将 dist 文件夹拖放到 Netlify 拖放部署区域](img/Figure_13.19_B18645.jpg)'
- en: Figure 13.19 – Dragging and dropping the dist folder into the Netlify drag-and-drop
    deployment section
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.19 – 将 dist 文件夹拖放到 Netlify 拖放部署区域
- en: 'Once the upload has succeeded, Netlify will redirect you to your new website’s
    administration page:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上传成功，Netlify 将将您重定向到您新网站的管理页面：
- en: '![Figure 13.20 – The Netlify new app page for the drag-and-drop site](img/Figure_13.20_B18645.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.20 – Netlify 拖放站点的新应用页面](img/Figure_13.20_B18645.jpg)'
- en: Figure 13.20 – The Netlify new app page for the drag-and-drop site
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.20 – Netlify 拖放站点的新应用页面
- en: 'We can click on the link to the site. We’ll see the default Vue CLI home page
    template, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击到站点的链接。我们会看到默认的 Vue CLI 主页模板，如下所示：
- en: '![Figure 13.21 – Netlify new app displaying a greeting message](img/Figure_13.21_B18645.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.21 – Netlify 新应用显示问候信息](img/Figure_13.21_B18645.jpg)'
- en: Figure 13.21 – Netlify new app displaying a greeting message
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.21 – Netlify 新应用显示问候信息
- en: With that, we’ve learned how to manually deploy a site to Netlify using the
    drag-and-drop interface.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何使用拖放界面手动将网站部署到 Netlify。
- en: Next, we will learn how to deploy our site from GitLab to Netlify.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何从 GitLab 部署我们的网站到 Netlify。
- en: 'On the Netlify app’s **Sites** page, we need to click the **Add new site**
    button, as shown in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Netlify 应用程序的 **站点** 页面上，我们需要点击以下截图所示的 **添加新站点** 按钮：
- en: '![Figure 13.22 – Netlify home page with the New site from Git button](img/Figure_13.22_B18645.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.22 – Netlify 主页带有从 Git 创建新站点的按钮](img/Figure_13.22_B18645.jpg)'
- en: Figure 13.22 – Netlify home page with the New site from Git button
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22 – Netlify 主页带有从 Git 创建新站点的按钮
- en: 'In the dropdown, select **Import an existing project**. We’ll see a page asking
    us to choose a Git provider to connect to. For this example, we will use **GitLab**.
    The following screenshot shows what the screen will look like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下拉菜单中，选择 **导入现有项目**。我们将看到一个页面，要求我们选择一个 Git 提供商进行连接。在这个例子中，我们将使用 **GitLab**。以下截图显示了屏幕将看起来像什么：
- en: '![Figure 13.23 – Netlify – Create a new site | Connect to Git provider](img/Figure_13.23_B18645.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.23 – Netlify – 创建新站点 | 连接到 Git 提供商](img/Figure_13.23_B18645.jpg)'
- en: Figure 13.23 – Netlify – Create a new site | Connect to Git provider
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.23 – Netlify – 创建新站点 | 连接到 Git 提供商
- en: 'Upon clicking **GitLab**, we will get an OAuth authorization challenge from
    GitLab, which we need to accept by clicking on the **Authorize** button, as shown
    in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **GitLab** 后，我们将收到 GitLab 的 OAuth 授权挑战，我们需要通过点击以下截图所示的 **授权** 按钮来接受它：
- en: '![Figure 13.24 – GitLab OAuth authorization modal](img/Figure_13.24_B18645.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.24 – GitLab OAuth 授权对话框](img/Figure_13.24_B18645.jpg)'
- en: Figure 13.24 – GitLab OAuth authorization modal
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.24 – GitLab OAuth 授权对话框
- en: 'We will then be redirected to Netlify and asked to choose a repository to deploy,
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将被重定向到 Netlify，并被要求选择一个要部署的仓库，如下所示：
- en: '![Figure 13.25 – Selecting a GitLab repository to deploy](img/Figure_13.25_B18645.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.25 – 选择 GitLab 仓库进行部署](img/Figure_13.25_B18645.jpg)'
- en: Figure 13.25 – Selecting a GitLab repository to deploy
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.25 – 选择 GitLab 仓库进行部署
- en: After selecting the repository we want to deploy, we will be met with a configuration
    page. Since we’re now building on Netlify’s build servers, we need to configure
    Netlify to build the application and deploy the correct folder.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 选择我们想要部署的仓库后，我们将遇到一个配置页面。由于我们现在是在 Netlify 的构建服务器上构建，我们需要配置 Netlify 以构建应用程序并部署正确的文件夹。
- en: By default, Netlify figures out both the proper `build` command (`npm run build`)
    and publish directory (`dist`). If you need to change these values for some reason,
    you can, but the defaults should work for you.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Netlify会确定正确的`build`命令（`npm run build`）和发布目录（`dist`）。如果你需要出于某种原因更改这些值，你可以这样做，但默认值应该适用于你。
- en: 'Then, we must click the **Deploy site** button, which will start the deployment
    process, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须点击**部署站点**按钮，这将开始部署过程，如下所示：
- en: '![Figure 13.26 – The Netlify build configuration tab with configured settings](img/Figure_13.26_B18645.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图13.26 – Netlify构建配置标签页，已配置设置](img/Figure_13.26_B18645.jpg)'
- en: Figure 13.26 – The Netlify build configuration tab with configured settings
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26 – Netlify构建配置标签页，已配置设置
- en: 'We will then be redirected to the newly created app’s page, as shown here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将被重定向到新创建的应用程序页面，如图所示：
- en: '![Figure 13.27 – New Netlify app](img/Figure_13.27_B18645.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图13.27 – 新Netlify应用](img/Figure_13.27_B18645.jpg)'
- en: Figure 13.27 – New Netlify app
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 – 新Netlify应用
- en: We have now seen how to deploy an application to Netlify using the manual upload
    method while using GitLab as the Git hosting provider.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用GitLab作为Git托管提供商时，使用手动上传方法将应用程序部署到Netlify。
- en: Exercise 13.02 – deploying a site to Netlify from GitHub
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.02 – 从GitHub部署站点到Netlify
- en: 'In the previous exercise, you saw how to deploy a site to Netlify from GitLab.
    In this exercise, we’ll modify that process to deploy from GitHub. How different
    is it from deploying it from GitLab? The answer is that they are very similar;
    the only notable difference is the first step in the **Connect to Git** **provider**
    tab:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你看到了如何从GitLab部署站点到Netlify。在这个练习中，我们将修改这个过程以从GitHub部署。与从GitLab部署相比，有什么不同？答案是它们非常相似；唯一的显著区别是**连接到Git**
    **提供者**标签中的第一步：
- en: 'Begin by clicking the **Add new site** button on the **Sites** page, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**站点**页面点击**添加新站点**按钮，操作如下：
- en: '![Figure 13.28 – Add new site on the Netlify dashboard](img/Figure_13.28_B18645.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图13.28 – 在Netlify仪表板上添加新站点](img/Figure_13.28_B18645.jpg)'
- en: Figure 13.28 – Add new site on the Netlify dashboard
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 – 在Netlify仪表板上添加新站点
- en: 'Select **Import an existing project** and choose **GitHub** as the Git hosting
    provider, as shown in the following screenshot:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**导入现有项目**，并将**GitHub**作为Git托管提供商，如图下所示：
- en: '![Figure 13.29 – Continuous deployment](img/Figure_13.29_B18645.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图13.29 – 持续部署](img/Figure_13.29_B18645.jpg)'
- en: Figure 13.29 – Continuous deployment
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.29 – 持续部署
- en: 'When we get the GitHub OAuth authorization challenge, as shown in the following
    screenshot, we must authorize Netlify:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们遇到如图所示的GitHub OAuth授权挑战时，我们必须授权Netlify：
- en: '![Figure 13.30 – GitHub authorization challenge](img/Figure_13.30_B18645.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图13.30 – GitHub授权挑战](img/Figure_13.30_B18645.jpg)'
- en: Figure 13.30 – GitHub authorization challenge
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.30 – GitHub授权挑战
- en: 'Select the Vue CLI project we want to deploy from the repository list, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从仓库列表中选择我们想要部署的Vue CLI项目，如下所示：
- en: '![Figure 13.31 – Selecting the correct repository](img/Figure_13.31_B18645.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图13.31 – 选择正确的仓库](img/Figure_13.31_B18645.jpg)'
- en: Figure 13.31 – Selecting the correct repository
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.31 – 选择正确的仓库
- en: On the `master` (or `main`, depending on your repository) as the branch to deploy.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`master`（或`main`，取决于你的仓库）作为部署的分支。
- en: Set `npm` `run build`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`npm` `run build`。
- en: Set `dist`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`dist`。
- en: 'The last two points look as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点如下所示：
- en: '![Figure 13.32 – The Netlify build configuration tab has been filled in with
    the proper settings](img/Figure_13.32_B18645.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图13.32 – Netlify构建配置标签页已填写正确的设置](img/Figure_13.32_B18645.jpg)'
- en: Figure 13.32 – The Netlify build configuration tab has been filled in with the
    proper settings
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.32 – Netlify构建配置标签页已填写正确的设置
- en: Click **Deploy site** to start the deployment process.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**部署站点**以开始部署过程。
- en: We’ve now seen how to deploy an application to Netlify using the manual upload
    method and using GitLab or GitHub as the Git hosting provider. Next, we will learn
    how to use AWS S3 and AWS CloudFront to deploy a Vue.js application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用手动上传方法以及使用GitLab或GitHub作为Git托管提供商将应用程序部署到Netlify。接下来，我们将学习如何使用AWS
    S3和AWS CloudFront部署Vue.js应用程序。
- en: Deploying to AWS using S3 and CloudFront
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用S3和CloudFront部署到AWS
- en: Amazon S3 is a static storage offering that can be used as a host for static
    files, such as what is generated by the Vue CLI’s `build` script.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon S3是一种静态存储服务，可以用作静态文件的托管，例如由Vue CLI的`build`脚本生成的文件。
- en: CloudFront is AWS’s **Content Delivery Network** (**CDN**) offering. A CDN can
    improve a web application’s performance by serving static content from an **edge**
    location. These servers are positioned around the world and are more likely to
    be geographically located close to the end user than the **origin** servers (the
    ones that serve the content). The edge servers in a CDN request resources from
    the origin if they don’t have them cached but will serve subsequent requests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFront 是 AWS 的**内容分发网络**（**CDN**）。CDN 可以通过从**边缘**位置提供静态内容来提高 Web 应用程序的性能。这些服务器遍布全球，并且更有可能位于比**源**服务器（提供内容的服务器）更靠近最终用户的地方。如果
    CDN 的边缘服务器没有缓存资源，它们将从源请求资源，但会为后续请求提供服务。
- en: 'Let’s learn how to configure S3 to host a Vue.js application (to do this, make
    sure that you have an AWS account):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何配置 S3 以托管 Vue.js 应用程序（为此，请确保您有一个 AWS 账户）：
- en: Start by creating and configuring an S3 bucket.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建并配置一个 S3 存储桶。
- en: 'To do this, head to the S3 product page. It will look similar to the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请转到 S3 产品页面。它看起来类似于以下内容：
- en: '![Figure 13.33 – Selecting S3 from the AWS service list](img/Figure_13.33_B18645.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.33 – 从 AWS 服务列表中选择 S3](img/Figure_13.33_B18645.jpg)'
- en: Figure 13.33 – Selecting S3 from the AWS service list
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.33 – 从 AWS 服务列表中选择 S3
- en: 'On the S3 console home page, click the **Create bucket** button, which will
    take us to the bucket creation page, as seen here:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 S3 控制台主页面上，点击**创建存储桶**按钮，这将带我们到存储桶创建页面，如下所示：
- en: "![Figure 1\uFEFF3.34 – The Create bucket button in the AWS S3 console](img/Figure_13.34_B18645.jpg)"
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.34 – AWS S3 控制台中创建存储桶按钮](img/Figure_13.34_B18645.jpg)'
- en: Figure 13.34 – The Create bucket button in the AWS S3 console
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.34 – AWS S3 控制台中的创建存储桶按钮
- en: 'To begin, we will start by naming our bucket. Bucket names must be unique,
    so consider using `vue-workshop-yourname`. For this example, we’ve called it `vue-workshop-ray`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，我们将从命名我们的存储桶开始。存储桶名称必须是唯一的，因此考虑使用 `vue-workshop-yourname`。在这个例子中，我们将其命名为
    `vue-workshop-ray`：
- en: '![Figure 13.35 – Entering the bucket name on the bucket creation page](img/Figure_13.35_B18645.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.35 – 在存储桶创建页面上输入存储桶名称](img/Figure_13.35_B18645.jpg)'
- en: Figure 13.35 – Entering the bucket name on the bucket creation page
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.35 – 在存储桶创建页面上输入存储桶名称
- en: 'We will also need to set the S3 bucket to be public. This can be done by unselecting
    the **Block all public access** checkbox. Once this is done, we must check the
    acknowledgment checkbox, as seen here:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将 S3 存储桶设置为公开。这可以通过取消选择**阻止所有公开访问**复选框来完成。一旦完成，我们必须检查确认复选框，如下所示：
- en: '![Figure 13.36 – Setting the S3 bucket to be public and acknowledging the warning](img/Figure_13.36_B18645.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.36 – 将 S3 存储桶设置为公开并确认警告](img/Figure_13.36_B18645.jpg)'
- en: Figure 13.36 – Setting the S3 bucket to be public and acknowledging the warning
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.36 – 将 S3 存储桶设置为公开并确认警告
- en: 'Once this is done, we will be redirected to the bucket list page. We want to
    click into our new bucket. Then, we need to access the **Properties** tag to find
    the **Static website** **hosting** option:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将被重定向到存储桶列表页面。我们想要点击进入我们的新存储桶。然后，我们需要访问**属性**标签以找到**静态网站****托管**选项：
- en: '![Figure 13.37 – The Static website hosting option in the S3 bucket’s Properties
    tab](img/Figure_13.37_B18645.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.37 – S3 存储桶属性标签中的静态网站托管选项](img/Figure_13.37_B18645.jpg)'
- en: Figure 13.37 – The Static website hosting option in the S3 bucket’s Properties
    tab
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.37 – S3 存储桶属性标签中的静态网站托管选项
- en: 'We can fill in the `index.html`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以填写 `index.html`：
- en: '![Figure 13.38 – Filling out the Static website hosting S3 property](img/Figure_13.38_B18645.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.38 – 填写静态网站托管 S3 属性](img/Figure_13.38_B18645.jpg)'
- en: Figure 13.38 – Filling out the Static website hosting S3 property
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.38 – 填写静态网站托管 S3 属性
- en: 'After saving your changes, note the endpoint URL, which you will need for CloudFront:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改后，注意端点 URL，您将需要它用于 CloudFront：
- en: '![Figure 13.39 – Noting the endpoint URL](img/Figure_13.39_B18645.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.39 – 记录端点 URL](img/Figure_13.39_B18645.jpg)'
- en: Figure 13.39 – Noting the endpoint URL
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.39 – 记录端点 URL
- en: 'We can now go back to the `dist` folders, as seen in the following screenshot:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以回到 `dist` 文件夹，如下面的屏幕截图所示：
- en: '![Figure 13.40 – Adding files to the vue-workshop S3 bucket through drag and
    drop](img/Figure_13.40_B18645.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.40 – 通过拖放将文件添加到 vue-workshop S3 存储桶](img/Figure_13.40_B18645.jpg)'
- en: Figure 13.40 – Adding files to the vue-workshop S3 bucket through drag and drop
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.40 – 通过拖放将文件添加到 vue-workshop S3 存储桶
- en: Once the files have been dropped onto the **Overview** page, we must click **Upload**
    to complete the process.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件被拖放到 **概览** 页面，我们必须点击 **上传** 以完成此过程。
- en: 'Next, we need to set a bucket policy to allow for read access to the files
    we’ve just uploaded. To do this, click the **Permissions** tab, and then **Edit**
    in the **Bucket policy** section. In the **Policy editor** area, paste the following
    JSON:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置一个存储桶策略，以允许读取我们刚刚上传的文件。为此，点击 **权限** 选项卡，然后在 **存储桶策略** 部分中点击 **编辑**。在
    **策略编辑器** 区域，粘贴以下 JSON：
- en: '[PRE24]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Be sure to change `vue-workshop-ray` to the bucket name you chose and click
    **Save changes**:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将 `vue-workshop-ray` 更改为您选择的存储桶名称，然后点击 **保存更改**：
- en: '![Figure 13.41 – Setting file permissions to public on files being uploaded
    to the S3 bucket](img/Figure_13.41_B18645.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.41 – 将上传到 S3 存储桶的文件权限设置为公共](img/Figure_13.41_B18645.jpg)'
- en: Figure 13.41 – Setting file permissions to public on files being uploaded to
    the S3 bucket
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.41 – 将上传到 S3 存储桶的文件权限设置为公共
- en: 'Our S3 bucket should now be configured to host static content. By visiting
    the website endpoint (available under **Properties** | **Static website hosting**),
    we will see the following Vue.js application (which is what we uploaded):'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该已经配置了 S3 存储桶以托管静态内容。通过访问网站端点（在 **属性** | **静态网站托管** 下可用），我们将看到以下 Vue.js
    应用程序（这是我们上传的）：
- en: '![Figure 13.42 – The Vue.js application being served from our AWS S3 bucket](img/Figure_13.42_B18645.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.42 – 从我们的 AWS S3 存储桶提供服务的 Vue.js 应用程序](img/Figure_13.42_B18645.jpg)'
- en: Figure 13.42 – The Vue.js application being served from our AWS S3 bucket
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.42 – 从我们的 AWS S3 存储桶提供服务的 Vue.js 应用程序
- en: Note that S3 can only serve sites over HTTP, and domain names cannot be configured
    directly from S3 buckets. Beyond performance and robustness, being able to set
    custom domain names and HTTPS support are other reasons to set up AWS CloudFront
    as a CDN for our website.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，S3 只能通过 HTTP 提供网站服务，并且无法直接从 S3 存储桶配置域名。除了性能和健壮性之外，能够设置自定义域名和 HTTPS 支持也是将
    AWS CloudFront 设置为我们的网站 CDN 的其他原因。
- en: 'We will start by navigating to the CloudFront console and clicking the **Create
    distribution** button, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导航到 CloudFront 控制台，并点击 **创建分发** 按钮，如下所示：
- en: '![Figure 13.43 – Selecting CloudFront from the AWS service list](img/Figure_13.43_B18645.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.43 – 从 AWS 服务列表中选择 CloudFront](img/Figure_13.43_B18645.jpg)'
- en: Figure 13.43 – Selecting CloudFront from the AWS service list
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.43 – 从 AWS 服务列表中选择 CloudFront
- en: 'Now, we must fill out the `example.s3-website.us-west-1.amazonaws.com` for
    the `example` bucket in the `us-westwest-1` region. The following screenshot displays
    this:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须填写 `example.s3-website.us-west-1.amazonaws.com`，这是位于 `us-westwest-1`
    区域的 `example` 存储桶。以下截图显示了这一过程：
- en: '![Figure 13.44 – Entering the website’s endpoint domain  in the CloudFront
    distribution’s Origin domain field](img/Figure_13.44_B18645.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.44 – 在 CloudFront 分发的源域名字段中输入网站的端点域名](img/Figure_13.44_B18645.jpg)'
- en: Figure 13.44 – Entering the website’s endpoint domain in the CloudFront distribution’s
    Origin domain field
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.44 – 在 CloudFront 分发的源域名字段中输入网站的端点域名
- en: 'While we are setting up the distribution, it’s a good idea to select the **Redirect
    HTTP to HTTPS** option for the **Viewer protocol policy** field; this can be found
    in the **Default cache behavior** section, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在设置分发时，选择 **查看器协议策略** 字段的 **将 HTTP 重定向到 HTTPS** 选项是个好主意；这可以在 **默认缓存行为** 部分找到，如下所示：
- en: "![Figure 13.45 – Selecting Redirect HTTP to HTTPS for the Viewer \uFEFFprotocol\
    \ \uFEFFpolicy field](img/Figure_13.45_B18645.jpg)"
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.45 – 为查看器协议策略字段选择将 HTTP 重定向到 HTTPS](img/Figure_13.45_B18645.jpg)'
- en: Figure 13.45 – Selecting Redirect HTTP to HTTPS for the Viewer protocol policy
    field
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.45 – 为查看器协议策略字段选择将 HTTP 重定向到 HTTPS
- en: Once done, we are now ready to click the **Create distribution** button and
    wait for the changes to propagate.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们现在可以点击 **创建分发** 按钮，等待更改传播。
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: CloudFront distribution changes take a while to propagate since they are being
    deployed to servers around the world.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CloudFront 分发更改需要部署到世界各地的服务器，因此它们需要一段时间才能传播。
- en: We can open the domain name for the CloudFront distribution once the console’s
    status is **Deployed**. With that, we have seen how to set up S3 and CloudFront
    to serve a static website. We will now learn how to use the AWS CLI to synchronize
    a local directory to the S3 bucket.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制台的状态为 **已部署**，我们就可以打开 CloudFront 分发的域名。通过这种方式，我们已经了解了如何设置 S3 和 CloudFront
    以提供静态网站。现在，我们将学习如何使用 AWS CLI 将本地目录同步到 S3 存储桶。
- en: A prerequisite for the next section is to have a shell instance that has AWS
    credentials that have been injected using the `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`,
    and `AWS_DEFAULT_REGION` environment variables. The access key and secret key
    need to be generated from the **Account** dropdown by selecting **My Security
    Credentials** | **Access Keys**. It also requires version 2 of the AWS CLI.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分的前提条件是拥有一个具有使用 `AWS_ACCESS_KEY_ID`、`AWS_SECRET_ACCESS_KEY` 和 `AWS_DEFAULT_REGION`
    环境变量注入的 AWS 凭据的 shell 实例。访问密钥和秘密密钥需要从 **账户** 下拉菜单中选择 **我的安全凭证** | **访问密钥** 生成。它还需要
    AWS CLI 的第 2 版。
- en: If we’re in a Vue CLI project, we can deploy the `dist` folder (which can be
    built using `npm run build`) to our `vue-workshop` bucket using an AWS S3 CLI
    command. We want to update an `s3` resource so that our command will start with
    `aws s3`. The command we want to issue is to synchronize files, so we will use
    the `aws s3` `sync` command.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于 Vue CLI 项目中，我们可以使用 AWS S3 CLI 命令将 `dist` 文件夹（可以使用 `npm run build` 构建）部署到我们的
    `vue-workshop` 存储桶。我们想要更新一个 `s3` 资源，以便我们的命令以 `aws s3` 开头。我们想要执行的命令是同步文件，因此我们将使用
    `aws s3 sync` 命令。
- en: 'We will sync `./dist` to the `vue-workshop` S3 bucket using the AWS URI syntax
    – that is, `s3://vue-workshop`. We also want to make sure that the files we upload,
    just like the bucket configuration, allow `public-read`. In full, the command
    looks as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 AWS URI 语法将 `./dist` 同步到 `vue-workshop` S3 存储桶 – 即 `s3://vue-workshop`。我们还想要确保我们上传的文件，就像存储桶配置一样，允许
    `public-read`。完整的命令如下所示：
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, let’s take what we’ve learned and apply it to our GitLab process.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们所学应用到我们的 GitLab 流程中。
- en: Exercise 13.03 – deploying to S3 from GitLab CI/CD
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03 – 从 GitLab CI/CD 部署到 S3
- en: S3 is a very cost-effective and performant solution for storing static files
    at scale. In this exercise, we’ll learn how to integrate GitLab CI/CD and AWS
    S3 to deploy a Vue.js application. This automates the deployment of the Vue.js
    application. The deployment will run on every push to GitLab without any manual
    intervention.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: S3 是一种非常经济高效且性能出色的解决方案，用于大规模存储静态文件。在本练习中，我们将学习如何集成 GitLab CI/CD 和 AWS S3 来部署
    Vue.js 应用程序。这将自动化 Vue.js 应用程序的部署。部署将在每次向 GitLab 推送时运行，无需任何手动干预。
- en: You can find the complete code for this exercise at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.03)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Exercise13.03)
    找到本练习的完整代码。
- en: 'To deploy to the S3 bucket from GitLab CI/CD, we will need to set up credential
    management:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 GitLab CI/CD 部署到 S3 存储桶，我们需要设置凭证管理：
- en: 'Navigate to **CI/CD** in the **Settings** section of GitLab, as follows:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GitLab 的 **设置** 部分导航到 **CI/CD**，如下所示：
- en: '![Figure 13.46 – CI/CD in the Settings menu](img/Figure_13.46_B18645.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.46 – 设置菜单中的 CI/CD](img/Figure_13.46_B18645.jpg)'
- en: Figure 13.46 – CI/CD in the Settings menu
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.46 – 设置菜单中的 CI/CD
- en: 'We will want to add variables, so let’s expand that section. You will see an
    empty list of variables, as shown in the following screenshot:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将想要添加变量，因此让我们展开该部分。您将看到一个空变量列表，如下面的截图所示：
- en: '![Figure 13.47 – The Variables section of the GitLab CI/CD settings expanded](img/Figure_13.47_B18645.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.47 – GitLab CI/CD 设置的变量部分已展开](img/Figure_13.47_B18645.jpg)'
- en: Figure 13.47 – The Variables section of the GitLab CI/CD settings expanded
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.47 – GitLab CI/CD 设置的变量部分已展开
- en: 'Next, we’ll add two variables, `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`,
    using the UI (the values of these are not shown since they’re sensitive API keys),
    as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 UI（这些值未显示，因为它们是敏感的 API 密钥）添加两个变量，`AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY`，如下所示：
- en: '![Figure 13.48 – Entering the AWS_ACCESS_KEY_ID environment variable](img/Figure_13.48_B18645.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.48 – 输入 AWS_ACCESS_KEY_ID 环境变量](img/Figure_13.48_B18645.jpg)'
- en: Figure 13.48 – Entering the AWS_ACCESS_KEY_ID environment variable
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.48 – 输入 AWS_ACCESS_KEY_ID 环境变量
- en: 'Now, we can add the default `AWS_REGION` variable using the UI (this isn’t
    so sensitive, so its value is shown in the following screenshot):'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 UI 添加默认的 `AWS_REGION` 变量（这不是那么敏感，所以其值在下面的截图中显示）：
- en: '![Figure 13.49 – Entering the AWS_DEFAULT_REGION environment variable](img/Figure_13.49_B18645.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.49 – 输入 AWS_DEFAULT_REGION 环境变量](img/Figure_13.49_B18645.jpg)'
- en: Figure 13.49 – Entering the AWS_DEFAULT_REGION environment variable
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.49 – 输入 AWS_DEFAULT_REGION 环境变量
- en: Now that we have set up our environment variables on GitLab CI/CD, we can start
    updating our `.``gitlab-ci.yml` file.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 GitLab CI/CD 上设置了环境变量，我们可以开始更新我们的 `.gitlab-ci.yml` 文件。
- en: 'First, we want to start caching the `dist` directory after our `build` step.
    To do this, we need to add a `cache` property to the `build` job:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们希望在 `build` 步骤之后开始缓存 `dist` 目录。为此，我们需要在 `build` 作业中添加一个 `cache` 属性：
- en: '[PRE41]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now add our `deploy` job, which will be a part of the `deploy` stage.
    To access the AWS CLI, we will use a Python image (`python:latest`) and install
    the AWS CLI using `pip` (a Python package manager) in our `before_script` step.
    Once we’ve installed the AWS CLI, we will run the deployment in the `script` step
    using the `aws s3 sync` command we used to deploy from our local machine:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以添加我们的 `deploy` 作业，它将是 `deploy` 阶段的一部分。为了访问 AWS CLI，我们将使用 Python 映像（`python:latest`）并在
    `before_script` 步骤中使用 `pip`（一个 Python 包管理器）安装 AWS CLI。一旦我们安装了 AWS CLI，我们将在 `script`
    步骤中使用我们用于从本地机器部署的 `aws s3 sync` 命令来运行部署：
- en: '[PRE49]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t need to invalidate caches since the Vite `build` command has built-in
    cache-busting, which it does by fingerprinting the contents of a file in the filename.
    Fingerprinting means that if the contents of a file change, its name/URL will
    change accordingly. When this new file is requested, it will be loaded from an
    uncached URL and will therefore get the latest version of the file.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Vite `build` 命令内置了缓存清除功能，我们不需要清除缓存。它是通过在文件名中对文件内容进行指纹识别来实现的。指纹识别意味着如果文件内容发生变化，其名称/URL
    将相应地更改。当请求这个新文件时，它将从未缓存的 URL 加载，因此将获取文件的最新版本。
- en: 'Once this update to the configuration is pushed to the GitLab repository, we
    will see the pipeline running three stages that all pass, as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将此配置更新推送到 GitLab 仓库，我们将看到管道运行三个阶段，所有阶段都通过，如下所示：
- en: '![Figure 13.50 – Passing the build, test, and deploy jobs](img/Figure_13.50_B18645.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.50 – 通过构建、测试和部署作业](img/Figure_13.50_B18645.jpg)'
- en: Figure 13.50 – Passing the build, test, and deploy jobs
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.50 – 通过构建、测试和部署作业
- en: We have now seen how to configure and deploy a Vue.js application to S3 and
    CloudFront using the AWS CLI and GitLab CI/CD.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 AWS CLI 和 GitLab CI/CD 配置和部署 Vue.js 应用程序到 S3 和 CloudFront。
- en: Activity 13.01 – adding CI/CD to a Book Search app with GitLab and deploying
    it to Netlify
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 13.01 – 使用 GitLab 将 CI/CD 添加到图书搜索应用程序并部署到 Netlify
- en: Now, let’s take a fully built Book Search Vue.js application that loads data
    from the Google Books API and deploy it to GitLab CI/CD and Netlify. We will start
    by running the production build locally and checking the output.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们拿一个完全构建的从 Google Books API 加载数据的图书搜索 Vue.js 应用程序，并将其部署到 GitLab CI/CD 和
    Netlify。我们将从在本地运行生产构建并检查输出开始。
- en: Then, we will switch to running the build and code quality steps (linting) on
    GitLab CI/CD. Finally, we will set up a new Netlify application sourced to the
    GitLab repository.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将切换到在 GitLab CI/CD 上运行构建和代码质量步骤（linting）。最后，我们将设置一个新的 Netlify 应用程序，该应用程序源自
    GitLab 仓库。
- en: The starting code for this activity can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_initial](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_initial);
    we will start with a **Book Search** application built with the Vue CLI. The solution
    can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_solution](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_solution).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的起始代码可以在 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_initial](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_initial)
    找到；我们将从一个使用 Vue CLI 构建的 **图书搜索** 应用程序开始。解决方案可以在 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_solution](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter13/Activity13.01_solution)
    找到。
- en: 'To start, follow these steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤操作：
- en: We will run a production build locally. We can use the command used to build
    all Vue CLI projects for production. We will also want to check that the relevant
    assets (JavaScript, CSS, and HTML) are generated correctly.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在本地运行一个生产构建。我们可以使用用于构建所有 Vue CLI 项目的命令。我们还将检查相关的资产（JavaScript、CSS 和 HTML）是否正确生成。
- en: 'We expect the `dist` folder to contain a similar structure, as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望 `dist` 文件夹具有以下类似的结构：
- en: '![Figure 13.51 – Sample contents of the dist folder (generated using the tree
    command) after a production build run](img/Figure_13.51_B18645.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.51 – 生产构建运行后 dist 文件夹的示例内容（使用 tree 命令生成）](img/Figure_13.51_B18645.jpg)'
- en: Figure 13.51 – Sample contents of the dist folder (generated using the tree
    command) after a production build run
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.51 – 生产构建运行后 dist 文件夹的示例内容（使用 tree 命令生成）
- en: To run GitLab CI/CD, we will need a `.gitlab-ci.yml` file. We will add a job
    to `.gitlab-ci.yml` in which we will install the packages followed by the production
    build into a Node.js LTS Docker container, at the `build` stage. We will also
    make sure to cache the output of the production build.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 GitLab CI/CD，我们需要一个 `.gitlab-ci.yml` 文件。我们将在 `.gitlab-ci.yml` 中添加一个作业，该作业将在
    `build` 阶段将安装的包和 Node.js LTS Docker 容器中的生产构建进行安装，然后我们将确保缓存生产构建的输出。
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `build` job while
    it is running (note the moon-like icon):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `git add .gitlab-ci.yml` 并提交和推送更改，我们应该看到以下 GitLab CI/CD 流程运行，其中包含正在运行的
    `build` 作业（注意月亮图标）：
- en: "![Figure 1\uFEFF3.52 – The GitLab CI/CD pipeline with the build job running](img/Figure_13.52_B18645.jpg)"
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.52 – 运行中的 GitLab CI/CD 流程](img/Figure_13.52_B18645.jpg)'
- en: Figure 13.52 – The GitLab CI/CD pipeline with the build job running
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.52 – 运行中的 GitLab CI/CD 构建作业
- en: 'The following screenshot, on the other hand, shows the GitLab CI/CD pipeline
    when the `build` job has been completed and is in the `passed` state (look for
    the green check):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下截图显示了构建作业完成后处于 `passed` 状态的 GitLab CI/CD 流程（寻找绿色勾选标记）：
- en: '![Figure 13.53 – GitLab CI/CD pipeline with the build job passed](img/Figure_13.53_B18645.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.53 – 构建作业通过时的 GitLab CI/CD 流程](img/Figure_13.53_B18645.jpg)'
- en: Figure 13.53 – GitLab CI/CD pipeline with the build job passed
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.53 – 构建作业通过时的 GitLab CI/CD 流程
- en: Next, we will want to add a code quality job to the `test` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We’ll call the job `lint` and it will run an install
    of the dependencies as well as linting through the Vue CLI.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望在 GitLab CI/CD 的 `test` 阶段添加一个代码质量作业（通过更新 `.gitlab-ci.yml`）。我们将把这个作业命名为
    `lint`，它将运行依赖项的安装以及通过 Vue CLI 进行代码风格检查。
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `lint` job while
    it is running:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们使用 `git add .gitlab-ci.yml` 并提交和推送更改，我们应该看到以下 GitLab CI/CD 流程运行，其中包含正在运行的
    `lint` 作业：
- en: '![Figure 13.54 – The GitLab CI/CD pipeline with the lint job running](img/Figure_13.54_B18645.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.54 – 运行中的 GitLab CI/CD 流程的 lint 作业](img/Figure_13.54_B18645.jpg)'
- en: Figure 13.54 – The GitLab CI/CD pipeline with the lint job running
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.54 – 运行中的 GitLab CI/CD 流程的 lint 作业
- en: 'The following screenshot shows the GitLab CI/CD pipeline with the `lint` job
    completed:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `lint` 作业完成时的 GitLab CI/CD 流程：
- en: '![Figure 13.55 – GitLab CI/CD pipeline with the lint job completed](img/Figure_13.55_B18645.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.55 – GitLab CI/CD 流程的 lint 作业已完成](img/Figure_13.55_B18645.jpg)'
- en: Figure 13.55 – GitLab CI/CD pipeline with the lint job completed
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.55 – GitLab CI/CD 流程的 lint 作业已完成
- en: 'To deploy our application, we’ll need to create a new Netlify application.
    From the **Sites** menu, add a new site and select **GitLab** as the provider.
    You should see your repository in the list of repos:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要部署我们的应用程序，我们需要创建一个新的 Netlify 应用程序。从 **站点** 菜单中添加一个新的站点，并将提供者选择为 **GitLab**。您应该在仓库列表中看到您的仓库：
- en: '![Figure 13.56 – Selecting the repository for the Netlify site](img/Figure_13.56_B18645.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.56 – 选择 Netlify 网站的仓库](img/Figure_13.56_B18645.jpg)'
- en: Figure 13.56 – Selecting the repository for the Netlify site
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.56 – 选择 Netlify 网站的仓库
- en: 'In the next step, you can confirm that Netlify automatically recognizes how
    to build and deploy your site. Both the `build` command and `publish` directory
    should be set as follows:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，您可以确认 Netlify 自动识别如何构建和部署您的网站。`build` 命令和 `publish` 目录应设置如下：
- en: '![Figure 13.57 – The S3 bucket properties page with web hosting enabled and
    configured with the index and error page set to index.html](img/Figure_13.57_B18645.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.57 – 启用 Web 托管并配置索引和错误页面为 index.html 的 S3 存储桶属性页面](img/Figure_13.57_B18645.jpg)'
- en: Figure 13.57 – The S3 bucket properties page with web hosting enabled and configured
    with the index and error page set to index.html
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.57 – 启用 Web 托管并配置索引和错误页面为 index.html 的 S3 存储桶属性页面
- en: 'Then, click **Deploy site**. Netlify will fetch the code from GitLab and run
    its build script:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**部署站点**。Netlify 将从 GitLab 获取代码并运行其构建脚本：
- en: '![Figure 13.58 – Netlify running its deploy process](img/Figure_13.58_B18645.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.58 – Netlify 正在运行其部署过程](img/Figure_13.58_B18645.jpg)'
- en: Figure 13.58 – Netlify running its deploy process
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.58 – Netlify 正在运行其部署过程
- en: 'When done, you can click the URL for the site Netlify created and see the app
    running:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您可以点击 Netlify 创建的站点 URL，并看到应用程序正在运行：
- en: '![Figure 13.59 – The Vue application running on Netlify](img/Figure_13.59_B18645.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.59 – 在 Netlify 上运行的 Vue 应用程序](img/Figure_13.59_B18645.jpg)'
- en: Figure 13.59 – The Vue application running on Netlify
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.59 – 在 Netlify 上运行的 Vue 应用程序
- en: You’ve now walked through the process of taking a real (if simple) Vue application
    and creating a CI/CD process that lets you go from development to production in
    an automated and safe manner. Congratulations!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经走过了将一个真实（尽管简单）的 Vue 应用程序转化为 CI/CD 流程的过程，该流程可以让您以自动化和安全的模式从开发到生产。恭喜！
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we’ve looked at how to introduce CI and CD practices
    to Vue.js projects so that we can deploy to production safely and efficiently.
    We’ve also seen how CI and CD are beneficial in the context of an agile delivery
    process.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将 CI 和 CD 实践引入 Vue.js 项目，以便我们可以安全高效地部署到生产环境。我们还看到了 CI 和 CD 在敏捷交付过程中的好处。
- en: We used GitLab’s CI/CD features to run tests, linting, and builds on every commit.
    We also learned how to leverage Netlify to host a static website by connecting
    Netlify to our hosting provider. Finally, we looked at how to set up and deploy
    to AWS S3 and CloudFront.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 GitLab 的 CI/CD 功能在每次提交时运行测试、代码检查和构建。我们还学习了如何通过将 Netlify 连接到我们的托管提供商来利用
    Netlify 托管静态网站。最后，我们探讨了如何设置并部署到 AWS S3 和 CloudFront。
- en: Throughout this book, you have learned how to use Vue.js to successfully build
    powerful, yet easy-to-build, web applications. You’ve worked with data, animations,
    forms, and more to build multiple different types of applications with various
    styles of user interaction. You also learned how to test all aspects of the application
    and finally took the steps to get your application into a live, production environment!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，您学习了如何使用 Vue.js 成功构建强大且易于构建的 Web 应用程序。您使用数据、动画、表单等构建了多种不同类型的应用程序，并具有各种用户交互风格。您还学习了如何测试应用程序的所有方面，并最终采取了将应用程序部署到实时生产环境的步骤！
