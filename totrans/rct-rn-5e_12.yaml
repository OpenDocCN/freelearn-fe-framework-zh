- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Fetching Data from a Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器获取数据
- en: The evolution of web technologies has made the interaction of browsers with
    servers and the processing of server data an integral part of web development.
    Today, it’s challenging to draw a clear line between traditional web pages and
    full-fledged web applications. At the heart of this evolution is the ability of
    JavaScript in the browser to make requests to the server, efficiently process
    the received data, and dynamically display it on the page. This process has become
    the foundation for creating the interactive and responsive web applications we
    see today. In this chapter, we will explore various approaches and methods used
    to fetch data from the server, discuss their impact on the architecture of web
    applications, and acquaint ourselves with modern practices in this area.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络技术的发展使得浏览器与服务器之间的交互以及服务器数据的处理成为网络开发的一个核心部分。如今，很难在传统网页和完整的网络应用之间划清界限。这一变革的核心是浏览器中JavaScript的能力，它能够向服务器发起请求，高效地处理接收到的数据，并在页面上动态显示。这个过程已成为创建我们今天所看到的交互式和响应式网络应用的基础。在本章中，我们将探讨从服务器获取数据的各种方法和途径，讨论它们对网络应用架构的影响，并熟悉这一领域的现代实践。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Working with remote data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理远程数据
- en: Using the **Fetch API**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Fetch API**
- en: Using **Axios**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Axios**
- en: Using **TanStack Query**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **TanStack Query**
- en: Using **GraphQL**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **GraphQL**
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter11](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter11).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter11](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter11)。
- en: Working with remote data
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理远程数据
- en: In the realm of web development, the journey of fetching data from servers has
    seen remarkable transformations. In the early 90s, the web’s infancy with **HTTP
    1.0** marked the beginning of server communication. Web pages were static, and
    HTTP requests were basic, fetching whole pages or static assets. Every request
    meant establishing a new connection, and interactivity was minimal, mostly limited
    to HTML forms. Security was also basic, reflecting the nascent state of the web.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发领域，从服务器获取数据的过程经历了显著的变革。在20世纪90年代初，随着**HTTP 1.0**的出现，标志着服务器通信的开始。网页是静态的，HTTP请求也很基础，仅用于获取整个页面或静态资源。每次请求都需要建立新的连接，交互性非常有限，主要限于HTML表单。安全性也很基础，反映了网络的初级阶段。
- en: 'The turn of the millennium witnessed a significant shift with the rise of **Asynchronous
    JavaScript and XML** (**AJAX**). This brought an era of enhanced interactivity,
    allowing web applications to communicate with the server in the background without
    reloading the whole page. It was powered by the `XMLHttpRequest` object. Here’s
    a simple example of using `XMLHttpRequest` to fetch data:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 千禧年的转折点见证了**异步JavaScript和XML**（**AJAX**）的兴起，这带来了增强的交互性，允许网络应用在后台与服务器通信，而无需重新加载整个页面。它由`XMLHttpRequest`对象驱动。以下是一个使用`XMLHttpRequest`获取数据的简单示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example illustrates a typical **XHR request**. Success and error responses
    are managed with callback functions. This reflects the time when asynchronous
    code relied heavily on callbacks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了典型的**XHR请求**。成功和错误响应通过回调函数管理。这反映了异步代码严重依赖回调的时代。
- en: As we progressed, HTTP evolved to version **1.1**, enhancing efficiency with
    persistent connections and standardizing **RESTful APIs**. These APIs used standard
    HTTP methods and were designed around identifiable resources, greatly improving
    scalability and developer productivity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进步，HTTP演变为**1.1**版本，通过持久连接增强了效率，并标准化了**RESTful API**。这些API使用标准的HTTP方法，并围绕可识别的资源设计，大大提高了可扩展性和开发者的生产力。
- en: 'The advent of the **Fetch API** provided a modern, promise-based mechanism
    to make network requests. Fetch is more powerful and flexible compared to `XMLHttpRequest`.
    Here’s an example of using Fetch:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fetch API**的出现提供了一种现代的、基于Promise的机制来发起网络请求。Fetch比`XMLHttpRequest`更强大、更灵活。以下是一个使用Fetch的示例：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Moreover, there are a lot of tools based on top of the Fetch API and XHR, developed
    by the community. For example, Axios, GraphQL, and React Query have further simplified
    server communication and data fetching, enhancing developer experiences.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多基于Fetch API和XHR开发的社区工具。例如，Axios、GraphQL和React Query进一步简化了服务器通信和数据获取，增强了开发者的体验。
- en: '**Axios**, a modern HTTP client library, further simplified fetching data with
    its promise-based API and a host of useful features, such as intercepting requests
    and responses. Here’s how you can use Axios to make a **GET** request:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Axios**是一个现代的HTTP客户端库，通过基于Promise的API和一系列有用的功能（如拦截请求和响应）进一步简化了数据获取。以下是如何使用Axios进行**GET**请求的示例：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The example might look identical to the **Fetch** API, but in real projects
    where you set up interceptors, it becomes a game-changer that saves a lot of time
    with less code. **Interceptors** allow you to intercept and modify requests before
    they are sent and responses before they are handled. A common use case is to refresh
    access tokens when they expire. Interceptors can add the new token to all subsequent
    requests. By using a library like Axios, a lot of the low-level networking code
    is abstracted away, allowing you to focus on making requests and handling responses.
    Interceptors, error handling, and other features help address cross-cutting concerns
    in a reusable way, leading to cleaner code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能看起来与**Fetch** API相同，但在实际项目中，当你设置了拦截器时，它就变成了一个节省大量时间的游戏改变者。**拦截器**允许你在请求发送之前拦截并修改请求，在响应处理之前拦截并修改响应。一个常见的用例是在访问令牌过期时刷新访问令牌。拦截器可以将新令牌添加到所有后续请求中。通过使用像Axios这样的库，许多低级网络代码被抽象化，让你可以专注于发送请求和处理响应。拦截器、错误处理和其他功能以可重用的方式解决跨切面问题，从而产生更干净的代码。
- en: Next is **GraphQL**, which revolutionized data fetching by allowing clients
    to request exactly the data they need, eliminating over-fetching and under-fetching
    issues. It offers a flexible and efficient way to retrieve data from servers.
    Instead of predefined endpoints, clients specify their data requirements, and
    servers respond with precisely the requested data. This reduces network load and
    enhances application performance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**GraphQL**，它通过允许客户端请求他们确切需要的数据，从而彻底改变了数据获取方式，消除了过度获取和不足获取的问题。它提供了一种灵活且高效的方式从服务器检索数据。而不是预定义的端点，客户端指定他们的数据需求，服务器则返回精确请求的数据。这减少了网络负载并提高了应用程序的性能。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we request the user by `ID`, specifying only two fields: `name` and `email`.
    Regardless of the user object’s size, the GraphQL server efficiently handles it,
    sending only the requested data to the client.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过`ID`请求用户，只指定了两个字段：`name`和`email`。无论用户对象的大小如何，GraphQL服务器都能高效地处理它，只向客户端发送请求的数据。
- en: One more tool I would like to explore is **React Query**. The library is designed
    to simplify data fetching and state management in React applications. It abstracts
    away the complexities of fetching and caching data, handles background updates,
    and provides Hooks for easy integration with components. React Query enhances
    the development process by making it straightforward to work with server data
    in a highly efficient and maintainable manner.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想探讨另一个工具**React Query**。这个库旨在简化React应用程序中的数据获取和状态管理。它抽象掉了获取和缓存数据的复杂性，处理后台更新，并提供Hooks以方便与组件集成。React
    Query通过使以高效和可维护的方式与服务器数据一起工作变得简单，从而提高了开发过程。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we don’t even need to handle errors or set up and update the
    loading state manually. Everything is provided by one Hook.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们甚至不需要处理错误或手动设置和更新加载状态。所有这些都是由一个Hook提供的。
- en: 'Another remarkable development in server communication is **WebSockets**, enabling
    real-time, bidirectional communication. This is a game-changer for applications
    requiring live data updates, like chat apps or trading platforms. Below is a basic
    example of using WebSockets:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器通信的另一个显著发展是**WebSockets**，它实现了实时双向通信。这对于需要实时数据更新的应用程序，如聊天应用或交易平台来说是一个游戏改变者。以下是一个使用WebSockets的基本示例：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are still using the callback approach due to the mental model of bidirectional
    communication.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仍然使用回调方法，因为双向通信的心理模型。
- en: In conclusion, the evolution of server communication in web development has
    been pivotal in enhancing user experiences and developer productivity. From the
    rudimentary stages of **HTTP 1.0** to the sophisticated tools of today, we have
    witnessed a significant transformation. The introduction of technologies like
    Ajax, the Fetch API, Axios, GraphQL, and React Query not only streamlined server
    interactions but also standardized asynchronous behavior in applications. These
    advancements have been critical in efficiently managing states like loading, errors,
    and offline scenarios. The integration of these tools in modern web applications
    signifies a leap forward in building more responsive, robust, and user-friendly
    interfaces. It’s a testament to the ever-evolving nature of technology and its
    profound impact on both the creation and consumption of web content.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，服务器通信在Web开发中的演变对于提升用户体验和开发者生产力至关重要。从**HTTP 1.0**的初级阶段到今天的复杂工具，我们见证了巨大的转变。Ajax、Fetch
    API、Axios、GraphQL和React Query等技术的引入不仅简化了服务器交互，还标准化了应用程序中的异步行为。这些进步对于高效管理加载、错误和离线场景等状态至关重要。这些工具在现代Web应用程序中的集成标志着在构建更响应、更健壮和用户友好的界面方面迈出了重要一步。这是对技术不断演变及其对网络内容创建和消费深远影响的证明。
- en: In the next section, we will explore real examples of how to fetch data from
    a server using the Fetch API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用Fetch API从服务器获取数据的真实示例。
- en: Using the Fetch API
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fetch API
- en: Let’s explore how we can retrieve data from a server in practice. We’ll start
    with the **Fetch API**, the most common and fundamental approach provided by web
    browsers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何在实践中从服务器检索数据。我们将从最常见和基础的**Fetch API**开始。
- en: 'Before we begin, let’s create a small application that fetches user data from
    GitHub and displays their avatar and basic information on the screen. To do this,
    we’ll need an empty **Vite** project with React. You can create it with the following
    command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们创建一个小型应用程序，该应用程序从GitHub获取用户数据并在屏幕上显示他们的头像和基本信息。为此，我们需要一个空的**Vite**项目，并使用React。您可以使用以下命令创建它：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we’re using **TypeScript** in our examples, let’s start by defining the
    `GitHubUser` interface and all the necessary parameters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在示例中使用**TypeScript**，让我们首先定义`GitHubUser`接口和所有必要的参数。
- en: 'To find out what data the server returns, we often need to refer to the documentation,
    usually provided by backend developers. In our case, since we’re using the GitHub
    REST API, we can find user information in the official GitHub documentation at
    this link: [https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28](https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出服务器返回的数据，我们通常需要参考文档，通常由后端开发者提供。在我们的案例中，由于我们使用GitHub REST API，我们可以在官方GitHub文档中找到用户信息，链接如下：[https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28](https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28)。
- en: 'Let’s create the `GitHubUser` interface as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式创建`GitHubUser`接口：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These are the essential fields we will use in our application. In reality, there
    are more fields in the `user` object, but I’ve included the ones we’ll use.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在应用程序中使用的必要字段。实际上，`user`对象中还有更多字段，但我只包括了我们将要使用的那些。
- en: 'Now that we know the fields the user will have, let’s create a component that
    will display the user data on the screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了用户将拥有的字段，让我们创建一个组件，该组件将在屏幕上显示用户数据：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we render their avatar and some useful information about the user together
    with a link to open their GitHub profile page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将用户的头像和一些有用的信息以及一个打开他们GitHub个人资料页面的链接一起展示。
- en: 'Let’s now take a look at the `App` component, where we handle the server data
    retrieval logic:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`App`组件，在那里我们处理服务器数据检索逻辑：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the `useState` hook to store `user` data and loading state. In the `useEffect`,
    we make a Fetch API request to fetch data from the GitHub API. As you can see,
    the `fetch` function takes a URL as an argument. We process the response, save
    it in the state, handle errors with the `catch` block, and finally, turn off the
    loading process with the `finally` block.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`useState`钩子来存储`user`数据和加载状态。在`useEffect`中，我们通过Fetch API请求从GitHub API获取数据。如您所见，`fetch`函数接受一个URL作为参数。我们处理响应，将其保存到状态中，使用`catch`块处理错误，并最终使用`finally`块关闭加载过程。
- en: 'To complete the application, we display the retrieved user data:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成应用程序，我们展示检索到的用户数据：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can run your application using the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行您的应用程序：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open the link that will appear in the terminal and you’ll see:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端中出现的链接，你会看到：
- en: '![](img/B19636_11_01.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_11_01.png)'
- en: 'Figure 11.1: GitHub user requested by the Fetch API'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：由 Fetch API 请求的 GitHub 用户
- en: Now you know how to fetch data using the Fetch API. Let’s explore the implementation
    of a similar application where we request data using other tools.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用 Fetch API 获取数据。让我们探索一个类似的应用程序的实施，其中我们使用其他工具请求数据。
- en: Using Axios
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Axios
- en: In this section, we will explore one of the most popular libraries for working
    with the server, called **Axios**. This library is similar to the Fetch API but
    also provides additional features that make it a powerful tool for handling requests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索一个用于与服务器交互的最受欢迎的库，称为 **Axios**。这个库类似于 Fetch API，但也提供了额外的功能，使其成为处理请求的强大工具。
- en: 'Let’s take our previous project and make some changes to it. First, let’s install
    Axios as a dependency:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的前一个项目拿来做一些修改。首先，让我们将 Axios 作为依赖项安装：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One of Axios’s features is the ability to create instances with specific configurations,
    such as headers, base URLs, interceptors, and more. This allows us to have a preconfigured
    instance tailored to our needs, reducing code repetition and making it more scalable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Axios 的一个特性是能够创建具有特定配置的实例，例如头部信息、基本 URL、拦截器等。这使得我们可以拥有一个预先配置的实例，以满足我们的需求，减少代码重复，并使其更具可扩展性。
- en: 'Let’s create an API class that encapsulates all the necessary logic for working
    with the server:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 API 类，它封装了与服务器交互所需的所有必要逻辑：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the constructor of this class, we create and store an Axios instance and
    set the base URL, eliminating the need to repeat this domain in future requests.
    Next, we configure interceptors for each request and response. This is done for
    demonstration purposes, so when we run the application, we can see all the requests
    and responses in the console logs:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类的构造函数中，我们创建并存储一个 Axios 实例，并设置基本 URL，从而消除在未来的请求中重复此域的需要。接下来，我们为每个请求和响应配置拦截器。这是为了演示目的，所以当我们运行应用程序时，我们可以在控制台日志中看到所有的请求和响应：
- en: '![](img/B19636_11_02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_11_02.png)'
- en: 'Figure 11.2: Axios interceptor logs'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：Axios 拦截器日志
- en: 'Now, let’s see how the `App` component, which uses our new API class, will
    look:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用我们新的 API 类的 `App` 组件将是什么样子：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As mentioned earlier, Axios is not significantly different from the Fetch API,
    but it offers more powerful functionality, making it easy to create more complex
    solutions for working with server data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Axios 与 Fetch API 并无显著差异，但它提供了更强大的功能，使得创建更复杂的用于处理服务器数据的解决方案变得容易。
- en: In the next section, we will explore the same application implemented using
    TanStack Query.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索使用 TanStack Query 实现的相同应用程序。
- en: Using TanStack Query
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TanStack Query
- en: '**TanStack Query**, more commonly known as **React Query**, is a library that
    has taken server interaction to a new level. This library allows us to request
    data and cache it. As a result, we can call the same `useQuery` hook a lot of
    times during one rendering, but only one request will be sent to the server. The
    library also includes built-in loading and error states, simplifying the handling
    of request states.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**TanStack Query**，更常被称为 **React Query**，是一个将服务器交互提升到新高度的库。这个库允许我们请求数据并将其缓存。因此，我们可以在一次渲染期间多次调用相同的
    `useQuery` 钩子，但只需向服务器发送一个请求。该库还包括内置的加载和错误状态，简化了请求状态的处理。'
- en: 'To get started, let’s install the library as a dependency for our project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们将库作为我们项目的依赖项安装：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we need to configure the library by adding the `QueryClientProvider`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过添加 `QueryClientProvider` 来配置库：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After this setup, we can start working on the app. One of the unique features
    of this library is that it is agnostic to the tool you use for data fetching.
    You just need to provide a promise function that returns the data. Let’s create
    such a function using the Fetch API:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置之后，我们可以开始工作在应用程序上。这个库的一个独特特性是它对用于数据获取的工具是中立的。你只需要提供一个返回数据的承诺函数。让我们使用 Fetch
    API 创建这样一个函数：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s take a look at how simple our `App` component has become:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的 `App` 组件变得多么简单：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, all the logic for making the request and handling loading and error states
    is contained within a single `useQuery` hook.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有制作请求和处理加载和错误状态的逻辑都包含在一个单一的 `useQuery` 钩子中。
- en: In the next section, we will explore an even more powerful tool for data fetching
    using GraphQL.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索一个更强大的用于数据获取的工具，即 GraphQL。
- en: Using GraphQL
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GraphQL
- en: Earlier in this chapter, we discussed what **GraphQL** is and how it allows
    us to specify the exact data we want from the server, reducing the amount of transferred
    data and speeding up data fetching.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们讨论了 **GraphQL** 是什么以及它如何允许我们指定从服务器获取的确切数据，从而减少传输的数据量并加快数据获取速度。
- en: In this example, we will explore GraphQL in conjunction with the `@apollo/client`
    library, which provides similar functionality to React Query but works with GraphQL
    queries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探索与 `@apollo/client` 库结合使用的 GraphQL，该库提供了与 React Query 类似的功能，但与 GraphQL
    查询一起工作。
- en: 'To begin, let’s install the necessary dependencies using the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令安装必要的依赖项：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to add a provider to our application:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的应用程序中添加一个提供者：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this stage, during the client setup, we specify the server URL we want to
    work with, caching settings, and authentication. In earlier examples, we used
    the public GitHub API, but GitHub also supports GraphQL. For this, we need to
    provide a **GitHub personal access token**, which you can obtain in your GitHub
    profile settings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，在客户端设置过程中，我们指定我们想要与之工作的服务器 URL、缓存设置和身份验证。在早期示例中，我们使用了公共 GitHub API，但 GitHub
    也支持 GraphQL。为此，我们需要提供一个 **GitHub 个人访问令牌**，您可以在您的 GitHub 个人资料设置中获取。
- en: 'For our example, to demonstrate how we can select only the necessary fields
    we need, let’s trim down the user data. Here’s how our GraphQL query in the component
    will look:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，为了演示我们如何仅选择所需的字段，让我们缩减用户数据。组件中的 GraphQL 查询将如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that everything is set up, let’s see what the `App` component will look
    like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，让我们看看 `App` 组件将是什么样子：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similar to React Query, we have access to the loading state, errors, and the
    actual data. When we open the application, we will see the result:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与 React Query 类似，我们有访问加载状态、错误和实际数据的能力。当我们打开应用程序时，我们将看到结果：
- en: '![](img/B19636_11_03.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B19636_11_03](img/B19636_11_03.png)'
- en: 'Figure 11.3: GiHub user requested by GraphQL'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：通过 GraphQL 请求的 GitHub 用户
- en: 'To ensure that the server returns exactly the data we requested, we can open
    Chrome Dev Tools, go to the **Network** tab, and inspect our request:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保服务器返回我们请求的确切数据，我们可以打开 Chrome 开发者工具，转到 **网络** 选项卡，并检查我们的请求：
- en: '![](img/B19636_11_04.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B19636_11_04](img/B19636_11_04.png)'
- en: 'Figure 11.4: GraphQL request'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：GraphQL 请求
- en: As shown in *Figure 11.4*, the server sent us precisely the data we specified
    in the query. You can experiment with query parameters to see the difference.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11.4* 所示，服务器发送给我们我们在查询中指定的精确数据。你可以通过实验查询参数来查看差异。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how to fetch data from the server. We began by
    briefly reviewing the history of client-server communication and highlighting
    the primary methods of interacting with servers. Next, we built an application
    to retrieve GitHub user data using the Fetch API, Axios, TanStack Query, and Apollo
    GraphQL.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何从服务器获取数据。我们首先简要回顾了客户端-服务器通信的历史，并强调了与服务器交互的主要方法。接下来，我们构建了一个应用程序，使用
    Fetch API、Axios、TanStack Query 和 Apollo GraphQL 来检索 GitHub 用户数据。
- en: The techniques you learned in this chapter will enable you to significantly
    expand the capabilities of your own web applications. By efficiently fetching
    data from the server, you can create dynamic, data-driven experiences for your
    users. Whether you are building a social media app that displays real-time feeds,
    an e-commerce site with up-to-date product information, or a dashboard that visualizes
    live data, the skills you gained will prove invaluable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你学到的技术将使你能够显著扩展你自己的 Web 应用程序的功能。通过从服务器高效地获取数据，你可以为用户创建动态、数据驱动的体验。无论你是构建一个显示实时流的社交媒体应用程序，一个提供最新产品信息的电子商务网站，还是一个可视化实时数据的仪表板，你获得的技术将证明是无价的。
- en: In the next chapter, we will delve into managing the application state using
    state management libraries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨使用状态管理库来管理应用程序状态。
