- en: More Angular – SPA and Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多 Angular – 单页应用和路由
- en: The previous chapter was about building our first useful app in Angular, then
    this chapter is about adding a whole lot of Angular goodness to it. Within the
    learning curve, we have made a start in exploring a technology platform and now
    we can build some rudimentary apps using Angular. But that's just the start! There
    is a lot more to learn before we can make effective use of Angular in a decent-sized
    application. This chapter takes us one step closer to realizing this goal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章我们讲述了在 Angular 中构建我们的第一个有用应用，然后这一章将介绍如何为它添加大量的 Angular 优点。在学习曲线中，我们已经开始了探索一个技术平台，现在我们可以使用
    Angular 构建一些基本的应用。但这只是开始！在我们能够有效地在一个中等规模的应用中使用 Angular 之前，还有很多东西要学习。这一章让我们更接近实现这一目标。
- en: The *7-Minute Workout* app still has some rough edges that we can fix while making
    the overall app experience better. This chapter is all about adding those enhancements
    and features. And as always, this app-building process provides us with enough
    opportunities to enhance our understanding of the framework and learn new things
    about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*应用还有一些粗糙的边缘，我们可以在改进整体应用体验的同时修复它们。这一章完全是关于添加这些增强功能和特性。而且，像往常一样，这个应用构建过程为我们提供了足够的机会来增强我们对框架的理解，并学习关于它的新事物。'
- en: 'The topics we cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '**Exploring Angular''s Single Page Applications** (**SPAs**): We explore Angular''s
    SPA capabilities, which include route navigation, link generation, and routing
    events.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索 Angular 的单页应用**（**SPA**）：我们探索 Angular 的 SPA 功能，包括路由导航、链接生成和路由事件。'
- en: '**Understanding dependency injection**: One of the core platform features.
    In this chapter, we learn how Angular makes effective use of dependency injection to
    inject components and services across the application.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解依赖注入**：这是平台的核心功能之一。在这一章中，我们学习 Angular 如何有效地使用依赖注入来注入组件和服务到应用程序中。'
- en: '**Angular pure (stateless) and impure (stateful) pipes**: We explore the primary
    data transformation construct of Angular, pipes, in more detail as we build some
    new pipes.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 纯（无状态）和纯（有状态）管道**：当我们构建一些新的管道时，我们将更详细地探索 Angular 的主要数据转换结构——管道。'
- en: '**Cross-component communication**: Since Angular is all about components and
    their interactions, we look at how to do cross-component communication in a parent-child
    and sibling component setup. We learn how Angular''s *template variables* and *events* facilitate
    this communication.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨组件通信**：由于 Angular 的一切都是关于组件及其交互，我们来看看如何在父组件-子组件和兄弟组件设置中进行跨组件通信。我们学习 Angular
    的*模板变量*和*事件*如何促进这种通信。'
- en: '**Creating and consuming events**: We learn how a component can expose its
    own events and how to bind to these events from the HTML template and from other
    components.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和消费事件**：我们学习一个组件如何公开其自己的事件，以及如何从 HTML 模板和其他组件中绑定到这些事件。'
- en: As a side note, I expect you are using the *7-Minute Workout* on a regular basis
    and working on your physical fitness. If not, take a seven-minute exercise break
    and exercise now. I insist!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我期望你正在定期使用*7分钟锻炼*来锻炼你的身体。如果不是，现在就进行七分钟的锻炼休息吧。我坚持这样做！
- en: Hope the workout was fun! Now let's get back to some serious business. Let's
    start with exploring Angular's **Single Page Application** (**SPA**) capabilities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 希望锻炼很有趣！现在让我们回到一些严肃的业务。让我们从探索 Angular 的**单页应用**（**SPA**）功能开始。
- en: We are starting from where we left off in Chapter 2, *Building Our First App
    - 7-Minute Workout*. The `checkpoint2.4` Git branch can serve as the base for
    this chapter. The code is also available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint2.4` (a ZIP file) from
    the GitHub location: [http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第二章*构建我们的第一个应用 - 7分钟锻炼*中继续进行。`checkpoint2.4` Git 分支可以作为本章的基础。代码也已在 GitHub
    ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    上提供，供大家下载。检查点作为 GitHub 中的分支实现。如果你不使用 Git，可以从 GitHub 位置下载`checkpoint2.4`的快照（ZIP
    文件）：[http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Exploring Single Page Application capabilities
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单页应用功能
- en: The *7-Minute Workout* starts when we load the app, but it ends with the last
    exercise sticking to the screen permanently. Not a very elegant solution. Why
    don't we add a start and finish page to the app? This makes the app look more
    professional and allows us to understand the single-page nomenclature of Angular.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟健身法*在加载应用时开始，但最后一个练习会永久地停留在屏幕上。这不是一个非常优雅的解决方案。我们为什么不给应用添加一个开始和结束页面呢？这会让应用看起来更专业，并允许我们理解Angular的单页命名空间。'
- en: The Angular SPA infrastructure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular SPA基础设施
- en: With modern web frameworks, such as Angular and Vue.js, we are now getting used
    to apps that do not perform full-page refreshes. But if you are new to this scene,
    it's worth mentioning what *SPAs* are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现代Web框架，如Angular和Vue.js，我们现在已经习惯了不执行全页刷新的应用。但如果你是新手，那么提到*SPAs*是值得的。
- en: '**Single Page Applications** (**SPAs**) are browser-based apps devoid of any
    full-page refresh. In such apps, once the initial HTML is loaded, any future page
    navigations are retrieved using AJAX and HTML fragments and injected into the
    already loaded view. Google Mail is a great example of an SPA. SPAs make for a
    great user experience as the user gets a desktop app-like feel, with no constant
    post-backs and page refreshes, which are typically associated with traditional
    web apps.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用（SPAs**）是基于浏览器的应用，没有全页刷新。在这样的应用中，一旦初始HTML加载完毕，未来的页面导航将通过AJAX和HTML片段检索，并注入到已加载的视图中。Google
    Mail是SPA的一个很好的例子。SPAs提供了极佳的用户体验，因为用户会得到类似桌面应用的感觉，没有常规的回发和页面刷新，这些都是传统Web应用通常具有的。'
- en: Like any modern JavaScript framework, Angular also provides the necessary constructs
    for SPA implementation. Let's understand them and add our app pages too.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何现代JavaScript框架一样，Angular也提供了SPA实现所需的必要结构。让我们了解它们，并添加我们的应用页面。
- en: Angular routing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular路由
- en: Angular supports SPA development using its **routing infrastructure**. This
    infrastructure tracks browser URLs, enables hyperlink generation, exposes routing
    events, and provides a set of directives/components for views that react to URL
    changes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持使用其**路由基础设施**进行SPA开发。这个基础设施跟踪浏览器URL，启用超链接生成，公开路由事件，并为响应URL变化的视图提供一组指令/组件。
- en: 'There are four major framework pieces that work together to support the Angular
    routing infrastructure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个主要的框架组件协同工作，以支持Angular的路由基础设施：
- en: '**The Router (Router)**: The primary infrastructure piece that actually provides
    component navigation'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器（Router）**：实际上是提供组件导航的主要基础设施组件。'
- en: '**The Routing configuration (Route)**: The component router is dependent upon
    the routing configuration for setting up routes'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由配置（Route）**：组件路由依赖于路由配置来设置路由。'
- en: '**The RouterOutlet component**: The `RouterOutlet` component is the placeholder container
    (*host*) where route-specific views are loaded'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器组件**：`RouterOutlet`组件是用于加载特定路由视图的占位符容器（*宿主*）。'
- en: '**The RouterLink directive**: This generates hyperlinks that can be embedded
    in the anchor tags for navigation'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器链接指令**：这个指令生成可以在锚标签中嵌入的超链接，用于导航。'
- en: 'The following diagram highlights the roles these components play within the
    routing setup:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示突出了这些组件在路由设置中的作用：
- en: '![](img/00021.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00021.jpeg)'
- en: I highly encourage everyone to keep revisiting this diagram as we set up routing
    for *7-Minute Workout*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议大家在设置*7分钟健身法*的路由时，不断回顾这张图。
- en: '*The router* is the central piece of this complete setup; therefore a quick
    overview of the router will be helpful.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由器*是这个完整设置中的核心组件；因此，快速了解路由器将很有帮助。'
- en: Angular router
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular路由
- en: If you have worked with any JavaScript framework with SPA support, this is how
    things work. The framework watches the browser URL and serves views based on the
    URL loaded. There are dedicated framework components for this job. In the Angular world,
    this tracking is done by a *framework service*, **the router**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过任何支持SPA的JavaScript框架，那么工作原理是这样的。框架会监视浏览器URL，并根据加载的URL提供视图。为此，有专门的框架组件。在Angular的世界里，这种跟踪是通过一个*框架服务*，**路由器**来完成的。
- en: In Angular, any class, object, or function that provides some generic functionality
    is termed a **service**. *Angular does not provide any special construct to declare
    a service as it does for components, directives, and pipes*. Anything that can
    be consumed by components/directives/pipes can be termed a service. The router
    is one such service. And there are many more services that are part of the framework. *If
    you are from the Angular 1 realm, this is a pleasant surprise-no service, factory,
    provider, value, or constant!*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，任何提供一些通用功能的类、对象或函数都被称为**服务**。*Angular没有为组件、指令和管道提供任何特殊的声明服务结构，就像它对它们所做的那样。任何可以被组件/指令/管道消费的东西都可以称为服务。路由器就是这样一种服务。框架中还有许多其他服务。*如果你来自Angular
    1领域，这会是一个令人愉快的惊喜——没有服务、工厂、提供者、值或常量！*
- en: 'The Angular router is there to:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器的作用是：
- en: Enable navigation between components on route change
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由更改时启用组件之间的导航
- en: Pass routing data between component views
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件视图之间传递路由数据
- en: Make the state of the current route available to active/loaded components
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使当前路由的状态对活动/加载的组件可用
- en: Provide APIs that allow navigation from component code
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供API，允许从组件代码中进行导航
- en: Track the navigation history, allowing us to move back and forward between component
    views using browser buttons
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪导航历史，使我们能够使用浏览器按钮在组件视图之间前后移动
- en: Provide life cycle events and guard conditions that allow us to affect navigation
    based on some external factors
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供生命周期事件和守卫条件，使我们能够根据某些外部因素影响导航
- en: The router also supports some advanced routing concepts, such as parent-child
    routes. This gives us the ability to define routes at multiple levels inside the
    component tree. The parent component can define routes and child components can
    further add more sub-routes to the parent route definition. This is something
    that we cover in detail in Chapter 4, *Building Personal Trainer*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器还支持一些高级路由概念，例如父子路由。这使我们能够在组件树内部定义多级路由。父组件可以定义路由，子组件可以进一步向父路由定义中添加更多子路由。这是我们在第4章“构建个人教练”中详细讨论的内容。
- en: The router does not work alone. As highlighted in the preceding diagram, it
    depends upon other framework pieces to achieve the desired results. Let's add
    some app pages and work with each piece of the puzzle.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器不能单独工作。如前图所示，它依赖于其他框架组件以实现预期结果。让我们添加一些应用页面并处理每个拼图的一部分。
- en: Routing setup
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由设置
- en: 'The Angular router is not part of the core Angular framework. It has a separate
    Angular module and its own npm package. Angular CLI has already installed this
    package as part of the project setup. Look at `package.json` to confirm this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器不是Angular核心框架的一部分。它有一个独立的Angular模块和自己的npm包。Angular CLI已经作为项目设置的一部分安装了此包。查看`package.json`以确认这一点：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since the router is already installed, we just need to integrate it into *7-Minute
    Workout*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由器已经安装，我们只需将其集成到*7分钟锻炼*中。
- en: 'We can start by adding the  `base` reference (highlighted) to the `head` section
    of `index.html`, if not present:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先向`index.html`的`head`部分添加`base`引用（突出显示），如果尚未存在：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*The router requires `base href` to be set.* The `href` value specifies the
    base URL to use for all relative URLs within an HTML document, including links
    to CSS, scripts, images, and any other resource. This setting helps the router
    to create navigation URLs.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由器需要设置`base href`。`href`值指定了用于HTML文档中所有相对URL的基本URL，包括链接到CSS、脚本、图像以及其他资源。此设置有助于路由器创建导航URL*。'
- en: Adding start and finish pages
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加开始和结束页面
- en: 'The plan here is to have three pages for *7-Minute Workout*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的计划是为*7分钟锻炼*提供三个页面：
- en: '**Start page**: This becomes the landing page for the app'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始页面**：这成为应用的着陆页'
- en: '**Workout page**: What we have currently'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锻炼页面**：我们目前拥有的'
- en: '**Finish page**: We navigate to this once the workout is complete'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成页面**：当锻炼完成后，我们将导航到这个页面'
- en: The workout component and its view (`workout-runner.component.ts` and `workout-runner.component.html`)
    are already there. So let's create `StartComponent` and `FinishComponent`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼组件及其视图（`workout-runner.component.ts`和`workout-runner.component.html`）已经存在。因此，让我们创建`StartComponent`和`FinishComponent`。
- en: 'Again, using the Angular CLI generates the boilerplate for the start and finish
    components. Navigate to the `trainer/src/app` folder and execute the component-generation
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用Angular CLI生成开始和结束组件的样板代码。导航到`trainer/src/app`文件夹并执行组件生成命令：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, copy the views for the *start* and *finish* components from the `checkpoint3.1` Git
    branch (the GitHub location to download from is [http://bit.ly/ng6be-3-1-app](http://bit.ly/ng6be-3-1-app)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`checkpoint3.1` Git分支（下载位置为[http://bit.ly/ng6be-3-1-app](http://bit.ly/ng6be-3-1-app)）复制`start`和`finish`组件的视图。
- en: Both the *start* and *finish* components' implementations are empty. The interesting
    bits are in the view. The start component view has a link to navigate to the workout
    runner component (`<a routerLink="/workout" ...`) and so does finish. We have
    yet to define the routes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`finish`组件的实现都是空的。有趣的部分在视图中。开始组件视图有一个链接可以导航到锻炼运行者组件（`<a routerLink="/workout"
    ...`），结束组件也是如此。我们还没有定义路由。'
- en: The start and finish components have been added to *app module*, as they are
    rudimentary views, unlike workout runner, which has its own `WorkoutRunnerModule` module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`finish`组件已经被添加到`app module`中，因为它们是基本的视图，与拥有自己`WorkoutRunnerModule`模块的锻炼运行者不同。'
- en: All three components are ready. Time to define the route configurations!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个组件都已准备就绪。现在是定义路由配置的时候了！
- en: Route configuration
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由配置
- en: 'To set up the routes for *7-Minute Workout*, we are going to create a *route
    definition module file*. Create a file called `app-routing.module.ts` in the `trainer/src/app` folder
    defining the top-level routes for the app. Add the following routing setup or
    copy it from the `checkpoint3.1` Git branch:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`7-Minute Workout`的路由，我们将创建一个`route definition module file`。在`trainer/src/app`文件夹中创建一个名为`app-routing.module.ts`的文件，定义应用的顶级路由。添加以下路由设置或从`checkpoint3.1`
    Git分支复制：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Angular CLI also supports boilerplate route-generation for modules. We have
    not used that feature. We can learn about it from the CLI documentation at [http://bit.ly/ng-cli-routing](http://bit.ly/ng-cli-routing).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI还支持为模块生成样板路由。我们没有使用该功能。我们可以从CLI文档中了解它，文档地址为[http://bit.ly/ng-cli-routing](http://bit.ly/ng-cli-routing)。
- en: 'The `routes` variable is an array of `Route` objects. Each `Route` defines
    the configuration of a single route, which contains:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`变量是一个`Route`对象的数组。每个`Route`定义了一个单独路由的配置，它包含：'
- en: '`path`: The target path to match'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：要匹配的目标路径'
- en: '`component`: The component to be loaded when the path is hit'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：当路径被访问时需要加载的组件'
- en: Such a route definition can be interpreted as, "when the user navigates to a
    URL (defined in `path`), load the corresponding component defined in the `component` property."
    Take the first route example; navigating to `http://localhost:9000/start` loads
    the component view for `StartComponent`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的路由定义可以解释为：“当用户导航到URL（在`path`中定义）时，加载`component`属性中定义的相应组件。”以第一个路由示例为例；导航到`http://localhost:9000/start`将加载`StartComponent`的组件视图。
- en: You may have noticed that the last `Route` definition looks a bit different. `path` looks
    odd and it does not have a `component` property either. A path with `**` denotes
    a catch-all path or the **wildcard route** for our app. Any navigation that does
    not match one of the first three routes matches the catch-all route, causing the
    app to navigate to the start page (defined in the `redirectTo` property).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到最后一个`Route`定义看起来有点不同。`path`看起来很奇怪，它也没有`component`属性。带有`**`的路径表示一个通配符路径或应用的**通配符路由**。任何不匹配前三个路由的导航都将匹配通配符路由，导致应用导航到起始页面（在`redirectTo`属性中定义）。
- en: We can try this once the routing setup is complete. Type any random route, such
    as `http://localhost:9000/abcd`, and the app automatically redirects to `http://localhost:9000/start`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 路由设置完成后，我们可以尝试一下。输入任何随机的路由，例如`http://localhost:9000/abcd`，应用会自动重定向到`http://localhost:9000/start`。
- en: We finally create and import a new module into `AppRoutingModule` with the call
    to `RouterModule.forRoot`.  And by re-exporting Angular's `RouterModule`, we can
    import `AppRoutingModule` instead of `RouterModule` and have access to all of
    the routing constructs together with our app routes available in `AppModule`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终通过调用`RouterModule.forRoot`创建并导入一个新的模块到`AppRoutingModule`中。通过重新导出Angular的`RouterModule`，我们可以导入`AppRoutingModule`而不是`RouterModule`，并访问所有路由构造以及`AppModule`中可用的应用路由。
- en: 'The `enableTracing: true` property on the `forRoot` function parameter allows
    us to monitor the *router events* (such as `NavigationStart`, `NavigationEnd`,
    and `NavigationCancel`) that happen when navigation takes place and the correct
    route is resolved. The logs are visible in the browser''s debugger console. *Use
    it for debugging purposes only, remove it from production builds*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`forRoot` 函数参数上的 `enableTracing: true` 属性允许我们在导航发生并正确解析路由时监控 *路由事件*（例如 `NavigationStart`、`NavigationEnd`
    和 `NavigationCancel`）。日志在浏览器的调试控制台中可见。*仅用于调试目的，请从生产构建中移除*。'
- en: Could the preceding routing setup could have been done inside `AppModule`? Yes,
    it's definitely possible, but we would recommend against it. As the number of
    routes grow and the routing setup becomes more complex, having a separate routing
    module helps us organize the code better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的路由设置是否可以在 `AppModule` 内完成？是的，这绝对可能，但我们建议不要这样做。随着路由数量的增加和路由设置的复杂性增加，有一个独立的路由模块有助于我们更好地组织代码。
- en: An important thing to highlight here:* route ordering is important in route
    definition*. Since route matching is done in a top-down fashion, it stops at the
    first match to define your specific routes before any generic catch-all route,
    such as the `**` *wildcard route *in our definition, which is declared at the
    last.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要强调的一个重要事项是：*路由定义中的路由顺序很重要*。由于路由匹配是自顶向下的，它会在定义你的特定路由之前停止，在任何一个通用的捕获所有路由之前，例如在我们的定义中声明的
    `**` 通配符路由，这是在最后声明的。
- en: 'The default router setup uses the **pushstate** mechanism for URL navigation.
    In such a setup, URLs look like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的路由设置使用 **pushstate** 机制进行 URL 导航。在这种设置中，URL 看起来像：
- en: '`localhost:4200/start`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:4200/start`'
- en: '`localhost:4200/workout`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:4200/workout`'
- en: '`localhost:4200/finish`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:4200/finish`'
- en: 'This may not seem like a big deal, but remember that we are doing client-side
    navigation, not the full-page redirects that we are so used to. As the **developer
    guide** states:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是什么大问题，但请记住，我们正在进行客户端导航，而不是我们如此习惯的全页重定向。正如 **开发者指南** 所述：
- en: Modern HTML 5 browsers support `history.pushState`, a technique that changes
    a browser's location and history without triggering a server page request. The
    router can compose a "natural" URL that is indistinguishable from one that would
    otherwise require a page load.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现代HTML 5浏览器支持 `history.pushState`，这是一种在不触发服务器页面请求的情况下改变浏览器位置和历史的技巧。路由器可以组合一个“自然”的URL，这个URL与需要页面加载的URL无法区分。
- en: Pushstate API and server-side url-rewrites
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pushstate API 和服务器端 URL 重写
- en: 'The router uses the  pushstate API in one of two cases:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器在两种情况下使用 pushstate API：
- en: When we click on links embedded in the view (`<a>` tag)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们点击视图中嵌入的链接（`<a>` 标签）
- en: When we use the router API
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用路由器 API
- en: In both cases, the router intercepts any navigation events, loads the appropriate
    component view, and finally updates the browser URL. The request never goes to
    the server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，路由器拦截任何导航事件，加载适当的组件视图，并最终更新浏览器 URL。请求永远不会发送到服务器。
- en: But what if we refresh the browser window?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们刷新浏览器窗口会怎样呢？
- en: The Angular router cannot intercept the browser's refresh event, and hence a
    complete page refresh happens. In such a scenario, the server needs to respond
    to a resource request (URL) that only exists on the client side. A typical server
    response is to send the app entry file (such as `index.html`) for any arbitrary
    request that may result in a `404 (Not Found)` error. This is what we call the
    server **url-rewrite**. This implies requests to any non-existent URLs, such as `/start`, `/workout`,
    or `/finish` loads the index page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由无法拦截浏览器的刷新事件，因此会发生完整的页面刷新。在这种情况下，服务器需要响应仅存在于客户端的资源请求（URL）。典型的服务器响应是发送应用入口文件（例如
    `index.html`）以响应任何可能导致 `404 (Not Found)` 错误的任意请求。这就是我们所说的服务器 **URL 重写**。这意味着对任何不存在的
    URL 的请求，例如 `/start`、`/workout` 或 `/finish`，都会加载索引页面。
- en: Each server platform has a different mechanism to support url-rewrite. We suggest
    you look at the documentation for the server stack you use to enable url-rewrite
    for your Angular apps.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务器平台都有不同的机制来支持 URL 重写。我们建议您查看您使用的服务器堆栈文档，以启用 Angular 应用的 URL 重写。
- en: We can see the server-side rewrites in action once the app routing is complete.
    Once completed, try to refresh the app and see the browser's network log; *the
    server sends the same  generated* `index.html` *content every time irrespective
    of the URL requested*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用路由完成后，我们可以看到服务器端重写的实际效果。完成后，尝试刷新应用并查看浏览器的网络日志；*服务器每次都会发送相同的* 生成的 *`index.html`
    内容，无论请求的URL是什么。
- en: 'The routing module definition is complete now. Before proceeding further, open `app.module.ts` and
    import `AppRoutingModule`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模块定义现在已完成。在继续之前，打开 `app.module.ts` 并导入 `AppRoutingModule`：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have all the required components and all the routes defined, where
    do we inject these components on route change? We just need to define a placeholder
    for that in the host view.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有必需的组件和所有已定义的路由，在路由更改时我们在哪里注入这些组件？我们只需要在宿主视图中定义一个占位符即可。
- en: Rendering component views with router-outlet
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 router-outlet 渲染组件视图
- en: 'Look at the current `AppComponent` template (`app.component.html`), it has an embedded `WorkoutRunnerComponent`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当前的 `AppComponent` 模板（`app.component.html`），它包含一个内嵌的 `WorkoutRunnerComponent`：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This needs to change as we need to render different components based on the
    URL (`/start`, `/workout`, or `/finish`). Remove the preceding declaration and
    replace it with a *router directive*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要改变，因为我们需要根据 URL（`/start`，`/workout`，或 `/finish`）渲染不同的组件。删除前面的声明，并用一个 *router
    指令* 替换它：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`RouterOutlet` is an Angular component directive that acts as a placeholder
    for loading route-specific components when the route changes. It integrates with
    the router service to load the appropriate component based on the current browser
    URL and the route definition.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterOutlet` 是 Angular 组件指令，它在路由更改时充当加载特定路由组件的占位符。它与路由服务集成，根据当前浏览器 URL 和路由定义加载适当的组件。'
- en: 'The following diagram helps us to easily visualize what is happening with the `router-outlet` setup:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表帮助我们轻松地可视化 `router-outlet` 设置中正在发生的事情：
- en: '![](img/00022.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: We are almost done; it's time to trigger navigation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了；现在是时候触发导航。
- en: Route navigation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由导航
- en: 'Like standard browser navigation, Angular navigation happens:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准浏览器导航一样，Angular 导航发生：
- en: When a user enters a URL directly into the browser address bar
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户直接在浏览器地址栏中输入 URL
- en: On clicking on a link on the anchor tag
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在点击锚点标签上的链接
- en: On using a script/code to navigate
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用脚本/代码进行导航时
- en: If not started, start the app and load `http://localhost:4200` or `http://localhost:4200/start`.
    The start page should be loaded.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未启动，请启动应用程序并加载 `http://localhost:4200` 或 `http://localhost:4200/start`。启动页面应该被加载。
- en: Click on the Start button and the workout should start under the `http://localhost:4200/workout` URL.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Start 按钮，锻炼应该在 `http://localhost:4200/workout` URL 下开始。
- en: 'The Angular router also supports the old style of *hash (#)-based routing*.
    When hash-based routing is enabled, the routes appear as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器还支持基于 *hash (#)-based routing* 的旧式路由。当启用基于 hash 的路由时，路由如下所示：
- en: '`localhost:9000/#/start`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/start`'
- en: '`localhost:9000/#/workout`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/workout`'
- en: '`localhost:9000/#/finish`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/finish`'
- en: To change it to hash-based routing, the route configuration for the top-level
    routes should be augmented with an extra `useHash:true` property in the `RouterModule.forRoot` function
    (second parameter).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其更改为基于 hash 的路由，顶级路由的路由配置应在 `RouterModule.forRoot` 函数（第二个参数）中增加一个额外的 `useHash:true` 属性。
- en: 'Interestingly, the anchor link in the `StartComponent` view definition does
    not have an `href` attribute. Instead, there is a `RouterLink` directive (the
    directive name is `RouterLink`, the selector is `routerLink`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在 `StartComponent` 视图定义中的锚点链接没有 `href` 属性。相反，有一个 `RouterLink` 指令（指令名称为 `RouterLink`，选择器为 `routerLink`）：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding case, since the route is fixed, the directive takes a constant
    expression (`"/workout"`). We are not using the standard square bracket notation
    (`[]`) here, instead are assigning the directive a fixed value. This is known
    as **one-time binding**. For dynamic routes, we can use template expressions and
    the link parameter array. We'll touch upon dynamic routes and the link parameter
    array shortly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，由于路由是固定的，指令采用了一个常量表达式（`"/workout"`）。我们在这里不使用标准的方括号表示法（`[]`），而是将指令分配一个固定值。这被称为 **一次性绑定**。对于动态路由，我们可以使用模板表达式和链接参数数组。我们很快就会涉及到动态路由和链接参数数组。
- en: Notice the **/** prefix in the preceding route path. `/` is used to specify
    an absolute path. The Angular router also supports relative paths, which are useful
    when working with child routes. We will explore the concept of child routes in
    the next few chapters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在先前的路由路径中的 **/** 前缀。`/` 用于指定绝对路径。Angular 路由器也支持相对路径，这在处理子路由时非常有用。我们将在接下来的几章中探讨子路由的概念。
- en: 'Refresh the app and check the rendered HTML for `StartComponent`; the preceding
    anchor tag is rendered with the correct `href` value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新应用并检查渲染的HTML中的`StartComponent`；前面的锚标签被渲染为正确的`href`值：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Avoid hardcoding route links
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 避免硬编码路由链接
- en: While you could have directly used `<a href="/workout">`, prefer `routerLink` to
    avoid hardcoding routes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以直接使用`<a href="/workout">`，但为了避免硬编码路由，建议使用`routerLink`。
- en: The link parameter array
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接参数数组
- en: 'The route setup for the current *7-Minute Workout* is quite simple, and there
    isn''t a need to pass parameters as part of link generation. But the capability is
    there for non-trivial routes that require dynamic parameters. See this example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当前**7分钟锻炼**的路由设置相当简单，不需要在生成链接时传递参数。但非平凡路由需要动态参数时，这个功能是存在的。看看这个例子：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is how the first route can be generated:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何生成第一个路由的方法：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The array assigned to the `RouterLink` directive is what we called the **link
    parameter array**. The array follows a specific pattern:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给`RouterLink`指令的数组就是我们所说的**链接参数数组**。该数组遵循特定的模式：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first element is always the route path, and the next set of parameters is
    there to replace placeholder tokens defined in a route template.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素始终是路由路径，下一组参数用于替换在路由模板中定义的占位符标记。
- en: The Angular router is quite a beast and supports almost everything that we expect
    from a modern router library. It supports child routes, async routes, lifecycle
    hooks, secondary routes, and some other advanced scenarios. We'll delay discussion
    on these topics until later chapters. This chapter just gets us started with Angular
    routing, but there is more to come!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器非常强大，几乎支持我们从现代路由库中期望的所有功能。它支持子路由、异步路由、生命周期钩子、次要路由和一些其他高级场景。我们将推迟对这些主题的讨论，直到后面的章节。本章只是让我们开始使用Angular路由，但还有更多内容要介绍！
- en: 'The router link parameter can also be an object. Such objects are used to supply **optional
    parameters** to the route. See this example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 路由链接参数也可以是一个对象。这样的对象用于向路由提供**可选参数**。看看这个例子：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the generated link contains a semicolon to separate optional parameters
    from the route and other parameters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，生成的链接中包含分号，用于将可选参数与路由和其他参数分开。
- en: The last missing part of the implementation is routing to the finish page once
    the workout completes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的最后缺失部分是在锻炼完成后路由到完成页面。
- en: Using the router service for component navigation
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由服务进行组件导航
- en: Navigation from the workout page to the finish page is not triggered manually
    but on completion of the workout. `WorkoutRunnerComponent` needs to trigger this
    transition.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从锻炼页面到完成页面的导航不是手动触发的，而是在锻炼完成后触发的。`WorkoutRunnerComponent`需要触发这个转换。
- en: For this, `WorkoutRunnerComponent` needs to get hold of the router and invoke
    the `navigate` method on it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，`WorkoutRunnerComponent`需要获取路由并对其调用`navigate`方法。
- en: How does `WorkoutRunnerComponent` get the router instance? Using Angular's *dependency
    injection framework*. We have been shying away from this topic for some time now.
    We have achieved a lot without even knowing that there's a dependency injection
    framework in play all this time. Let's wait a tad longer and first concentrate
    on fixing the navigation issue.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`是如何获取路由实例的？使用Angular的**依赖注入框架**。我们至今一直对这个话题有所回避。我们取得了很多成就，甚至不知道一直都有依赖注入框架在发挥作用。让我们稍等片刻，首先集中精力解决导航问题。'
- en: 'For `WorkoutRunnerComponent` to get hold of the router service instance, it
    just needs to declare the service on the constructor. Update the `WorkoutRunnerComponent` constructor
    and add the imports:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`WorkoutRunnerComponent`获取路由服务实例，它只需要在构造函数中声明该服务。更新`WorkoutRunnerComponent`构造函数并添加导入：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Angular now magically injects the current router into the `router` private variable
    when `WorkoutRunnerComponent` is instantiated. The magic is done by *dependency
    injection framework*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当`WorkoutRunnerComponent`实例化时，Angular神奇地将当前路由注入到`router`私有变量中。这个魔法是通过**依赖注入框架**完成的。
- en: 'It''s now just a matter of replacing the `console.log("Workout complete!");` statement
    with the call to the `navigation` router:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需要将`console.log("Workout complete!");`语句替换为对`navigation`路由的调用即可：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `navigate` method takes the same *link parameter array* as the `RouterLink` directive.
    We can verify the implementation by patiently waiting for the workout to complete!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigate`方法接受与`RouterLink`指令相同的**链接参数数组**。我们可以通过耐心等待锻炼完成来验证实现。'
- en: If you are having a problem running the code, look at the `checkpoint3.1` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.1` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-1](http://bit.ly/ng6be-checkpoint-3-1). Refer
    to the `README.md` file in the trainer folder when setting up the snapshot for
    the first time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行代码时遇到问题，请查看`checkpoint3.1`Git分支，以获取我们迄今为止所做工作的一个可工作版本。或者，如果您不使用Git，可以从[http://bit.ly/ng6be-checkpoint-3-1](http://bit.ly/ng6be-checkpoint-3-1)下载`checkpoint3.1`的快照（ZIP文件）。在首次设置快照时，请参考训练文件夹中的`README.md`文件。
- en: The routes we have defined in *7-Minute Workout* are standard simple routes.
    But if there are dynamic routes that take parameters, how do we make the parameters
    available in our components? Angular has a service for that, the `ActivatedRoute` service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义的*7分钟健身法*中的路线是标准的简单路线。但如果存在需要参数的动态路线，我们如何使这些参数在我们的组件中可用？Angular有一个服务可以做到这一点，那就是`ActivatedRoute`服务。
- en: Using the ActivatedRoute service to access route params
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ActivatedRoute服务访问路由参数
- en: There are times when the app requires access to the active route state. Information
    such as the current URL fragment, the current route parameters, and other route-related
    data may come in handy during a component's implementation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，应用程序需要访问活动路由状态。在组件实现过程中，有关当前URL片段、当前路由参数和其他与路由相关的数据等信息可能会派上用场。
- en: The `ActivatedRoute` service is a one-stop shop for all current route-related
    queries. It has a number of properties, including `url` and `paramMap`, that can
    be used to query the route's current state.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedRoute`服务是所有当前路由相关查询的一站式商店。它有几个属性，包括`url`和`paramMap`，可以用来查询路由的当前状态。'
- en: 'Let''s look at an example of a parameterized route and how to access a parameter
    passed from a component,  given this route:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个参数化路由的例子以及如何访问从组件传递过来的参数，给定这个路由：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the user navigates to `/user/5`, the underlying component  can access
    the `:id` parameter value by first injecting `ActivatedRoute` into its constructor:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到`/user/5`时，底层组件可以通过首先将其构造函数中的`ActivatedRoute`注入来访问`:id`参数值：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And then, anywhere in the code where the parameter is required, call `get` methods
    on the `ActivatedRoute.paramMap` property:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在代码中需要参数的任何地方，调用`ActivatedRoute.paramMap`属性的`get`方法：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `paramMap` property on `ActivatedObject` is actually an **observable.** We
    will learn more about observables later in the chapter, but for now, it is enough
    to understand that observables are objects that let the outside world know about
    their state changes by raising events that others can listen into.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedObject`上的`paramMap`属性实际上是一个**可观察对象**。我们将在本章后面部分了解更多关于可观察对象的内容，但就目前而言，理解可观察对象是对象，通过引发其他人可以监听的事件来让外界了解其状态变化就足够了。'
- en: We'll use this router capability in the later chapters where we build a new
    app that can create workouts and edit existing workouts. In the upcoming chapters,
    we also look at some advanced routing concepts, including *child routes*, *lazy
    loaded routes*, and *guard conditions*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中使用这个路由器功能，在那里我们将构建一个新的应用程序，可以创建健身计划并编辑现有的健身计划。在即将到来的章节中，我们还将探讨一些高级路由概念，包括*子路由*、*懒加载路由*和*守卫条件*。
- en: We have covered the basics of Angular routing, it's now time to concentrate
    on a much overdue topic: *Dependency Injection*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了Angular路由的基础知识，现在是时候集中精力在一个久违的话题上了：*依赖注入*。
- en: Angular dependency Injection
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular依赖注入
- en: Angular makes heavy use of dependency injection to manage app and framework
    dependencies. The surprising part is that we could ignore this topic until we
    started our discussion on the router. All this time, the Angular dependency injection
    framework has been supporting our implementation. The hallmark of a good dependency
    injection framework is that the consumer can use it without bothering too much
    about the internals and with little ceremony.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Angular大量使用依赖注入来管理应用程序和框架的依赖。令人惊讶的是，我们可以在开始讨论路由器之前忽略这个话题。在这段时间里，Angular依赖注入框架一直在支持我们的实现。一个好的依赖注入框架的标志是，消费者可以在不太多关注内部结构和很少的仪式的情况下使用它。
- en: If you are not sure what dependency injection is or just have a vague idea about
    it, an introduction to DI surely does not hurt anyone.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定依赖注入是什么，或者只是对它有一个模糊的概念，那么DI的介绍肯定不会伤害任何人。
- en: Dependency injection 101
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入101
- en: For any application, its components (not to be confused with Angular components)
    do not work in isolation. There are dependencies between them. A component may
    use other components to achieve its desired functionalities. **Dependency injection** is
    a pattern for managing such dependencies.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何应用程序，其组件（不要与Angular组件混淆）并不是独立工作的。它们之间存在依赖关系。一个组件可能使用其他组件来实现其所需的功能。"**依赖注入**"是一种管理此类依赖的模式。
- en: The DI pattern is popular in many programming languages as it allows us to manage
    dependencies in a loosely coupled manner. With such a framework in place, dependent
    objects are managed by a DI container. This makes dependencies swappable and the
    overall code more decoupled and testable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式在许多编程语言中都很流行，因为它允许我们以松耦合的方式管理依赖。有了这样的框架，依赖对象由DI容器管理。这使得依赖可交换，整体代码更加解耦和可测试。
- en: The idea behind DI is that an object does not create/manage its own dependencies.
    Instead, the dependencies are provided from the outside. These dependencies are
    made available either through a constructor, which is called **constructor injection** (Angular
    also does this) or by directly setting the object properties, which is called **property
    injection**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入背后的理念是，一个对象不创建/管理自己的依赖。相反，依赖由外部提供。这些依赖可以通过构造函数提供，这被称为**构造函数注入**（Angular也这样做）或者通过直接设置对象属性，这被称为**属性注入**。
- en: 'Here is a rudimentary example of DI in action. Consider a class called `Tracker` that
    requires `Logger` for a logging operation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个依赖注入操作的初步示例。考虑一个名为`Tracker`的类，它需要一个`Logger`来进行日志操作：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The dependency of the `Logger` class is hardwired inside `Tracker` as `Tracker` itself
    instantiates the `Logger` instance. What if we externalize this dependency? So
    the class becomes:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger`类的依赖在`Tracker`内部硬编码，因为`Tracker`本身实例化了`Logger`实例。如果我们外部化这个依赖呢？所以这个类变成了：'
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This innocuous-looking change has a major impact. By adding the ability to
    provide the dependency externally, we can now:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似无害的更改产生了重大影响。通过添加提供依赖外部的能力，我们现在可以：
- en: '**Decouple these components and enable extensibility**. The DI pattern allows
    us to alter the logging behavior of the `Tracker` class without touching the class
    itself. Here is an example:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦这些组件并启用可扩展性**。依赖注入模式允许我们修改`Tracker`类的日志行为，而不需要触及该类本身。以下是一个示例：'
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The two `Tracker` objects we just saw have different logging capabilities for
    the same `Tracker` class implementation. `trackerWithDBLog` logs to a DB and `trackerWithMemoryLog` to
    the memory (assuming both `DBLogger` and `MemoryLogger` are derived from the `Logger` class).
    Since `Tracker` is not dependent on a specific implementation on  `Logger` (`DBLogger` or `MemoryLogger`),
    this implies `Logger` and `Tracker` are loosely coupled. In the future, we can
    derive a new `Logger` class implementation and use that for logging without changing
    the `Tracker` implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的两个`Tracker`对象具有相同的`Tracker`类实现的不同日志功能。"trackerWithDBLog"将日志记录到数据库，而"trackerWithMemoryLog"则记录到内存中（假设`DBLogger`和`MemoryLogger`都派生自`Logger`类）。由于`Tracker`不依赖于`Logger`的具体实现（`DBLogger`或`MemoryLogger`），这表明`Logger`和`Tracker`是松耦合的。在未来，我们可以派生一个新的`Logger`类实现，并用于日志记录，而无需更改`Tracker`的实现。
- en: '**Mock dependencies**: The ability to mock dependencies makes our components
    more testable. The `Tracker` implementation can be tested in isolation (unit testing)
    by providing a mock implementation for `Logger`, such as `MockLogger`, or by using
    a mocking framework that can easily mock the `Logger` interface.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟依赖**：模拟依赖的能力使得我们的组件更容易测试。`Tracker`实现可以通过提供`Logger`的模拟实现（如`MockLogger`）或使用可以轻松模拟`Logger`接口的模拟框架来独立（单元测试）测试。'
- en: We can now understand how powerful DI is.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以理解DI有多强大。
- en: 'Think carefully: once DI is in place, the responsibility for resolving the
    dependencies now falls on the calling/consumer code. In the preceding example,
    a class that was earlier instantiating `Tracker` now needs to create a `Logger` derivation
    and inject it into `Tracker` before using it.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考：一旦DI就位，解决依赖的责任现在落在调用/消费代码上。在先前的示例中，之前实例化`Tracker`的类现在需要创建一个`Logger`派生类并将其注入到`Tracker`中，然后再使用它。
- en: Clearly, this flexibility in swapping internal dependencies of a component comes
    at a price. The calling code implementation can become overly complex as it now
    has to manage child dependencies too. This may seem simple at first, but given
    the fact that dependent components may themselves have dependencies, what we are
    dealing with is a complex dependency-tree structure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: This is where DI containers/frameworks add value. They make managing dependencies
    less cumbersome for the calling code. These containers then construct/manage dependencies
    and provide it to our client/consumer code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The Angular DI framework manages dependencies for our Angular components, directives,
    pipes, and services.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Exploring dependency injection in Angular
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular employs its very own DI framework to manage dependencies across the
    application. The very first example of visible dependency injection was the injection
    of the component router into `WorkoutRunnerComponent`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the `WorkoutRunnerComponent` class gets instantiated, the DI framework
    internally locates/creates the correct router instance and injects it into the
    caller (in our case, `WorkoutRunnerComponent`).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: While Angular does a good job of keeping the DI infrastructure hidden, it's
    imperative that we understand how Angular DI works. Otherwise, everything may
    seem rather magical.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'DI is about creating and managing dependencies, and the framework component
    that does this is dubbed the **the injector**. For the injector to manage dependencies,
    it needs to understand the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**The what:** What is the dependency? The dependency could be a class, an object,
    a factory function, or a value. Every dependency needs to be registered with the
    DI framework before it can be injected.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The where/when:** The DI framework needs to know where to inject a dependency
    and when.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The how**: The DI framework also needs to know the recipe for creating the
    dependency when requested.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any injected dependency needs to answer these questions, irrespective of whether
    it's a framework construct or an artifact created by us.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, the `Router` instance injection done in `WorkoutRunnerComponent`.
    To answer the what and how parts, we register the `Router` service by importing
    the `RouterModule` into `AppRoutingModule`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `AppRoutingModule` is a module that exports multiple routes together with
    all the Angular-router-related services (technically it re-exports `RouterModule`).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The where and when are decided based on the component that requires the dependencies.
    The constructor of `WorkoutRunnerComponent` takes a dependency of `Router`. This
    informs the injector to inject the current `Router` instance when `WorkoutRunnerComponent` is
    created as part of route navigation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the injector determines the dependencies of a class based on the
    metadata reflected from it when converting TypeScript to ES5 code (done by the
    TypeScript compiler). The metadata is generated only if we add a decorator, such
    as `@Component` or `@Pipe`, on the class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we inject `Router` into another class? Is the same `Router` instance
    used? The short answer is yes. The Angular injector creates and caches dependencies
    for future reuse, and hence these services are singleton in nature.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: While dependencies in an injector are singleton, at any given time, there can
    be multiple injectors active throughout an Angular app. You'll learn about the
    injector hierarchy shortly. With the router, there is another layer of complexity.
    Since Angular supports the child route concept, each of these child routes has
    its own router instance. Wait until we cover child routers in the next chapter
    so that you can understand the intricacies!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an Angular service to track workout history. This process will
    help you understand how dependencies are wired using Angular DI.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Tracking workout history
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be a great addition to our app if we could track our workout history.
    When did we last exercise? Did we complete it? How much time did we spend on it?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: To answer these questions, we need to track when the workout starts and when
    it ends. This tracking data then needs to be persisted somewhere.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution could be to extend our `WorkoutRunnerComponent` with the
    desired functionality. But that adds unnecessary complexity to `WorkoutRunnerComponent` and
    that's not its primary job.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We need a dedicated history-tracking service for this job, a service that tracks
    historical data and shares it throughout the app. Let's start building the workout-history-tracker
    service.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Building the workout-history-tracker service
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workout-history-tracker service is going to track workout progress. The
    service will also expose an interface, allowing `WorkoutRunnerComponent` to start
    and stop workout tracking.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Inspired again by the *Angular style guide*, we are going to create a new module, **core
    module**, and add the service to this module. The role of the core module is to
    host services that are available across the application. It is also a good place
    to add single-use components that are required when the application starts. A
    nav bar and busy indicator are good examples of such components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'On the command line, navigate to the `trainer/src/app` folder and generate
    a new module:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This creates a new `CoreModule` module and imports it into `AppModule`. Next,
    create a new service inside the `trainer/src/app/core` folder, again using Angular
    CLI:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The generated code is quite simple. The generator creates a new class `WorkoutHistoryTrackerService` (`workout-history-tracker.service.ts`)
    with a `@Injectable` decorator applied on the class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `providedIn:'root'` property on `Injectable` instructs Angular to create **a
    provider** with the *root injector*. The sole job of this provider is to create
    the `WorkoutHistoryTrackerService` service and return it when Angular's DI injector
    desires. Any service that we create/use needs to be registered on an injector.
    As the Angular documentation on *providers* describes,
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '*Providers tell the injector how to create the service. Without a provider,
    the injector would not know that it is responsible for injecting the service nor
    be able to create the service*.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: A service in Angular is just a class that has been registered with Angular's
    DI framework. Nothing special about them!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is desirable to include the service as part of a module instead
    of registering it with the root injector. In such a case, the service can be registered
    at the module level. There are two ways to achieve this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**: Reference the module with the `providedIn` property:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Option 2**: Register the service on the module, using the `providers` array:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Registering services at module level is advantageous in scenarios where a module
    is lazy loaded.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Registering the service using `Injectable` (*option 1*) has another advantage.
    It enables Angular CLI build to perform advanced optimization with code bundling,
    leaving out any service that is declared but never used (a process called **tree
    shaking**).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of the two options we use, the service is still registered (via
    a provider) with the root injector.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `Injectable` approach to registering dependency throughout
    the book, unless stated otherwise. Open `workout-history-tracker.service.ts` and
    add the following implementation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are two classes defined: `WorkoutHistoryTrackerService` and `WorkoutLogEntry`.
    As the name suggests, `WorkoutLogEntry` defines log data for one workout execution. `maxHistoryItems` allows
    us to configure the maximum number of items to store in the `workoutHistory` array,
    the array that contains the historical data. The `get tracking()` method defines
    a getter property for `workoutTracked` in TypeScript. `workoutTracked` is set
    to `true` during workout execution.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the start tracking, stop tracking, and exercise complete functions
    to `WorkoutHistoryTrackerService`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `startTracking` function creates a `WorkoutLogEntry` and adds it to the `workoutHistory` array.
    By setting the `currentWorkoutLog` to the newly created log entry, we can manipulate
    it later during workout execution. The `endTracking` function and the `exerciseComplete` function
    just alter `currentWorkoutLog`. The `exerciseComplete` function should be called
    on completion of each exercise that is part of the workout.  To save you some
    keystrokes, get the complete code for implementation done thus far from this gist: [http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts](http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'The service implementation now also includes a function to get workout history
    data:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That completes the `WorkoutHistoryTrackerService` implementation; now it's time
    to integrate it into the workout execution.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with WorkoutRunnerComponent
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent` requires `WorkoutHistoryTrackerService` to track workout
    history; hence there is a dependency to be fulfilled. We already have registered `WorkoutHistoryTrackerService` with
    Angular''s DI framework using the `Injectable` decorator and now it''s time to
    consume the service.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Injecting dependencies with Constructor Injection
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consuming dependency is easy! *More often than not, we use constructor injection
    to consume a dependency*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `import` statement at the top and update the `WorkoutRunnerComponent` constructor,
    as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As with `router,` Angular injects `WorkoutHistoryTrackerService` too when `WorkoutRunnerComponent` is
    created. Easy!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Once the service is injected and available to `WorkoutRunnerComponent`, the
    service instance (`tracker`) needs to be called when the workout starts, when
    an exercise is complete, and when the workout finishes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this as the first statement in the `start` function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `startExerciseTimeTracking` function, add the highlighted code after
    the `clearInterval` call:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And the highlighted code inside the workout to complete the `else` condition
    in the same function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: History tracking is almost complete except for one case. What if the user manually
    navigates away from the workout page? How do we stop tracking?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: When that happens, we can always rely on the component's life cycle hooks/events
    to help us. Workout tracking can be stopped when the `NgOnDestroy` event is fired.
    An appropriate place to perform any cleanup work is before the component is removed
    from the component tree. Let's do it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this function and the corresponding life cycle event interface to `workout-runner.component.ts`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The workout-history-tracking implementation is complete. We are eager to start
    the workout history page/component implementation, but not before completing our
    discussion on Angular's DI capabilities.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skip the next section for now if you want to maintain the app-building
    velocity. Come back to this section with a fresh and relaxed mind. There are some
    very important core concepts we'll share in the next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in depth
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first try to understand the different places we can register a dependency
    using `WorkoutHistoryTrackerService` as an example.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Registering dependencies
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard way to register a dependency is to register it at the root/global
    level. This can be done either by passing the dependency type into the `provides` attribute
    (array) in the `NgModule` decorator, or by using the `providedIn` attribute on
    the `Injectable` service decorator.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember our `WorkoutHistoryTrackerService` registration? Check the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The same thing can be done on the module declaration too, as shown here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Technically speaking, when using any of the preceding mechanisms, the service
    gets registered with the **app's root injector**, irrespective of the Angular
    module it is declared in. Any Angular artifact across modules henceforth can use
    the service (`WorkoutHistoryTrackerService`). No module imports are required at
    all.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is different from component/directive/pipe registration. Such
    artifacts have to be exported from a module for another module to use them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '*Another place where dependencies can be registered is on the component*. The `@Component` decorator
    has a `providers` array parameter to register dependencies. With these two levels
    of dependency registration, the obvious question that we need to answer is, which
    one to use?'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: It seems obvious that if the dependency is exclusively used by a component and
    its children, it should be registered at the `@Component` decorator level. Not
    really! There is much more we need to understand before we can answer this question.
    There is a whole new world of hierarchical injectors that need to be introduced.
    Let's wait, and instead learn other ways of registering dependencies, by continuing
    our discussion on providers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '*Providers create dependencies when the Angular injector requests them*. *These
    providers have the recipe to create these dependencies*. While a class seems to
    be the obvious dependency that can be registered, we can also register:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: A specific object/value
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A factory function
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering `WorkoutHistoryTrackerService` using the `Injectable` decorator
    is the most common pattern of registration. But at times we need some flexibility
    with our dependency registrations. To register an object or a factory function,
    we need to use the expanded version of provider registrations available on `NgModule`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: To learn about these variations, we need to explore providers and dependency
    registration in a little more detail.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Angular providers
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providers create dependencies that are served by the DI framework.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this `WorkoutHistoryTrackerService` dependency registration done on `NgModule`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This syntax is a short-form notation for the following version:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first property (`provide`) is a token that acts as a key for registering
    a dependency. This key also allows us to locate the dependency during dependency
    injection.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The second property (`useClass`) is a *provider definition object* that defines
    the recipe for creating the dependency value.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: With `useClass`, we are registering a **class provider**.  *A class provider creates
    dependencies by instantiating the type of object requested for*. There are some
    other provider types.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Value providers
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A class provider* creates class objects and fulfills the dependency, but at times we
    want to register a specific object/primitive with the DI provider instead. **Value
    providers** solve this use case.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Had we registered `WorkoutHistoryTrackerService` using this technique, the
    registration would have looked like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*With the value provider, we have the responsibility to provide an instance
    of a service/object/primitive to Angular DI.*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'With the *value provider*, since we are creating the dependency manually, we
    are also responsible for constructing any child dependencies if there are dependencies
    further down the lineage. Take the example of `WorkoutHistoryTrackerService` again.
    If `WorkoutHistoryTrackerService` has some dependencies, those too need to be
    fulfilled by manual injection:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, we not only have to create an instance of `WorkoutHistoryTrackerService`,
    we also have to create an instance of the `LocalStorage` service. For a service
    with a complex dependency graph, setting up that service with a value provider
    becomes challenging.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, prefer *class provider* over *value provider*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Value providers still come in handy in specific scenarios. For example, we
    can register a common app configuration using a value provider:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or register a mock dependency while unit testing:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Factory providers
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when dependency construction is not a trivial affair. Construction
    depends upon external factors. These factors decide what objects or class instances
    are created and returned. **Factory providers** do this heavy lifting.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an example where we want to have different configurations for dev and
    production releases. We can very well use a factory implementation to select the
    right configuration:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A factory function can have its own dependencies too. In such a case, the syntax
    changes a bit:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The dependencies are passed as a parameters to the factory function and registered
    on the provider definition object property, `deps` (`Environment` is the dependency
    injected in the preceding example).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Use the `UseFactory` provide if the construction of the dependency is complex
    and not everything can be decided during dependency wire-up.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: While we have a number of options to declare dependencies, consuming dependencies
    is far simpler. We saw one way of constructor injection in the *Injecting dependencies
    with Constructor Injection *section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Explicit injection using injector
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can even do explicit injections using Angular''s **Injector service**. This
    is the same injector Angular uses to support DI. Here is how to inject the `WorkoutHistoryTrackerService` service
    using `Injector`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We inject the  `Injector` service and then ask for the `WorkoutHistoryTrackerService` instance
    explicitly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: When would someone want to do this? Well, almost never. Avoid this pattern as
    it exposes the DI container to your implementation and adds a bit of noise.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to register dependency and how to consume it, but how does the
    DI framework locate these dependencies?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Dependency tokens
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember this expanded version of dependency registration shown earlier:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `provide` property value is a **token**. This token is used to identify
    the dependency to inject. In the preceding example, we use class name or type
    to identify dependency and hence the token is called a **class token**.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding registration, whenever Angular sees a statement similar
    to the following, it injects the correct dependency based on the class type, here `WorkoutHistoryTrackerService`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Angular supports some other tokens too.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Using InjectionToken
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when the dependency we define is either a primitive, object,
    or function. In such a scenario, the class token cannot be used as there is no
    class. Angular solves this problem using `InjectionToken` (or **string tokens** as
    we'll see later). The app configuration registration examples that we shared earlier
    can be rewritten using string tokens if there is no `AppConfig` class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'To register a dependency using `InjectionToken`, we first need to create the `InjectionToken` class
    instance:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, use the token to register the dependency:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And finally, inject the dependency anywhere using the `@Inject` decorator:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Interestingly, when `@Inject()` is not present, the injector uses the type/class
    name of the parameter (*class token*) to locate the dependency.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Using string tokens
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular also supports **string tokens**, allowing us to use string literals
    to identify and inject dependencies. The preceding example with a string token
    becomes:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A downside to string tokens is that you can misspell the token across the declaration
    and injection.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Phew! This was a really long section on Angular's Dependency Injection and there's
    still stuff left to cover. For now, let's get back on track and add the workout
    history page.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Adding the workout history page
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workout history data that we are collecting during the execution of the
    workout can now be rendered in a view. Let's add a `History` component. The component
    will be available at the `/history` location and can be loaded by clicking on
    a link in the app header section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the route definition in `app.routes.ts` to include a new route and the
    related import:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The History link needs to be added to the app header section. Let''s refactor
    the header section into its own component. Update the `app.component.html` template
    and replace the `nav` element with the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `nav` element moves into a header component, which we still need to create.
    Use `ng generate` to generate a new `HeaderComponent` component by running the
    command inside the `trainer/src/app/core` folder:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This statement creates a new header component and declares it on the core module.
    Next, update the definition for the header component (`header.component.ts`) and
    its view (`header.component.html`) from the `checkpoint3.2` Git branch (GitHub
    location: [http://bit.ly/ng6be-3-2-header](http://bit.ly/ng6be-3-2-header)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'While we have added the header element to `app.component.html`, the header
    component will not render unless we import the core module and export the component
    from the core module. Angular CLI did the first part for us, for the second part,
    update `core.module.ts` to:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you look at the `HeaderComponent` view, the history link is now there. We
    had to import `RouterModule` as the following link is generated using the `RouterLink` directive,
    which is part of `RouterModule`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s add the workout history component by first generating the component''s
    boilerplate. From the command line, navigate to `trainer/src/app` and run:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `WorkoutHistoryComponent` implementation is available in the `checkpoint3.2` Git
    branch; the folder is `workout-history` (GitHub location: [http://bit.ly/ng6be-3-2-workout-history](http://bit.ly/ng6be-3-2-workout-history)).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WorkoutHistoryComponent` view code is trivial, to say the least: a few
    Angular constructs, including `ngFor` and `ngIf`. The component implementation
    too is pretty straightforward. Inject the `WorkoutHistoryTrackerService` service
    dependency and load the history data when `WorkoutHistoryComponent` is initialized:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And this time, we use the `Location` service instead of `Router` to navigate
    away from the `history` component:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The Location service is used to interact with the browser URL. Depending upon
    the URL strategy, either URL paths (such as `/start` or `/workout`) or URL hash
    segments (such as `#/start` or `#/workout`) are used to track location changes.
    The router service internally uses the location service to trigger navigation.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Router versus Location
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: While the `Location` service allows us to perform navigation, using `Router` is
    a preferred way of performing route navigation. We used the location service here
    because the need was to navigate to the last route without bothering about how
    to construct the route.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to test our workout history implementation. Load the start page
    and click on the History link. The history page is loaded with an empty grid.
    Go back, start a workout, and let an exercise complete. Check the history page
    again; there should be a workout listed:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: Looks good! If we run the workout multiple times and let the history list build,
    we realize there is one sore point in this listing. Historical data is not sorted
    in reverse-chronological order, with the newest at the top. Also, it would be
    great if we had some filtering capabilities.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and filtering history data using pipes
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter 2, *Building Our First App – 7-Minute Workout*, we explored pipes.
    We even built our own pipe to format the seconds values as hh:mm:ss. The primary
    purpose of pipes is to transform data and, surprisingly, they work on arrays too!
    For arrays, pipes can sort and filter data. We create two pipes, one for each sorting
    and filtering.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS has prebuilt filters (filters are pipes in Angular), `orderBy` and `filter`,
    for this very purpose. Angular does not come with these pipes and there is a good
    reason. These pipes are prone to poor performance. Learn the rationale behind
    this decision in the framework documentation on pipes at [http://bit.ly/ng-no-filter-orderby-pipe](http://bit.ly/ng-no-filter-orderby-pipe).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `orderBy` pipe.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The orderBy pipe
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `orderBy` pipe we implement is going to order an array of objects based
    on any of the object''s properties. The usage pattern for sorting items in ascending
    order based on the `fieldName` property is going to be:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And for sorting items in descending order, the usage pattern is:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Make note of the extra hyphen (`-`) before `fieldName`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: We plan to add `OrderByPipe` in a new shared module. Are you thinking, why not
    add it to core module? By convention, the core module contains global services
    and one-time-use components. This is exactly one core module per application.
    Shared modules, on the other hand, have components/directives/pipes that are shared across
    modules. Such shared modules can be also be defined at multiple levels, across
    the parent and child modules. In this case, we will define the shared module inside `AppModule`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `SharedModule` module by running this command in the `trainer/src/app` directory:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'From the command line, navigate to the `trainer/src/app/shared` folder and
    generate the order by pipe boilerplate:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Open `order-by.pipe.ts` and update the definition from the checkpoint3.2 code
    (GitHub location: [http://bit.ly/ng6be-3-2-order-by-pipe](http://bit.ly/ng6be-3-2-order-by-pipe)).
    While we are not going to delve into the pipe''s implementation details, some
    relevant parts need to be highlighted. Look at this pipe outline:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding `field` variable receives the field on which sorting is required. If
    the field has a `-` prefix, we truncate the prefix before sorting the array in
    descending order.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The pipe also uses the spread operator, `[...]`, which may be new to you. Learn
    more about the spread operator on MDN at [http://bit.ly/js-spread](http://bit.ly/js-spread).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `OrderByPipe`, update the template view for workout history:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And again, we need to export the pipe from the shared module allowing `WorkoutHistoryComponent` to
    use it. Add an exports property on `SharedModule` and set it to `OrderByPipe`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The historical data will now be sorted in descending order on the `startedOn` field.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Make note of the single quotes around the pipe parameter (`'-startedOn'`). We
    are passing a literal string to the `orderBy` pipe. Pipe parameters support data
    binding and can be bound to component properties too.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: That's enough for the `orderBy` pipe. Let's implement filtering.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Pipe chaining with search pipe
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating the search pipe boilerplate by running the following command
    from the `trainer/src/app/shared` folder:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The implementation can now be copied from checkpoint3.2 (GitHub location: [http://bit.ly/ng6be-3-2-search-pipe](http://bit.ly/ng6be-3-2-search-pipe)). `SearchPipe` does
    a basic equality-based filtering. Nothing special.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Look at the pipe code; the pipe takes two arguments, the first being the field
    to search, and the second the value to search. We use the JavaScript array's `filter` function
    to filter the record, doing a strict equality check. Wondering about the `pure` attribute
    on the `Pipe` decorator? This is going to be the subject of discussion in the
    next section.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the workout history view and incorporate the search pipe too.
    Open `workout-history.component.html` and uncomment the div with radio buttons.
    These radio buttons filter workouts based on whether they were completed or not.
    This is how the HTML filter selection looks:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We define three filters: `all`, `completed`, and `incomplete` workouts. The
    radio selection sets the component's `completed` property using the `change` event
    expression. `$event.target` is the radio button that was clicked.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'The `search` pipe can now be added to the `ngFor` directive expression. We
    are going to chain the `search` and `orderBy` pipes. Update the `ngFor` expression
    to:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A great example of Angular's pipe chaining capabilities!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: As we did with `OrderByPipe`, `SearchPipe` too needs to be exported from the
    shared module before using it.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'The `search` pipe first filters the historical data, followed by the `orderBy` pipe
    reordering it. Pay close attention to the `search` pipe parameters: the first
    parameter is a string literal denoting the field to search (`historyItem.completed`),
    whereas the second parameter is derived from the component''s `completed` property.
    Having the ability to bind pipe parameters to component properties allows us great
    flexibility.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and verify the search capabilities of the history page. Based on the
    radio selection, the history records are filtered, and of course, they are sorted
    in reverse-chronological order based on the workout start dates.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: While pipe usage with arrays looks simple, it can throw up some surprises if
    we do not understand when pipes are evaluated.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Pipe gotcha with arrays
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the issue with pipes applied to arrays, let's reproduce the problem.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `search.pipe.ts` and remove the `@Pipe` decorator''s `pure` attribute.
    Also, take the following statement:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And change it into this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add a button at the end of the radio list (in `workout-history.component.html`)
    that adds a new log entry to the `history` array:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add a function to `WorkoutHistoryComponent`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding function duplicates the first history item and adds back to the `history` array.
    If we load the page and click on the button, a new log entry gets added to the
    history array, but it does not show up on the view unless we change the filter
    (by clicking on the other radios). Interesting!
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Before calling `addLog` make sure at least one history log is already there;
    otherwise the `addLog` function will fail.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The pipes that we have built thus far are **stateless** (also called **pure**)
    in nature. They simply transform input data into output. **Stateless** **pipes** are
    reevaluated only if the pipe input changes (the expression on the left side of
    pipe symbol) or any pipe argument is updated.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: For arrays, this happens on an array assignment/reference change and not on
    the addition or deletion of elements. Switching the filter condition works, as
    it causes the search pipe to evaluate again as the search parameter (the `completed` status)
    changes. This behavior is something to be aware of.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the fix? For starters, we can make the history array immutable, which
    implies that it cannot be changed once created. To add a new element, we need
    to create a new array with the new value, something like:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This works perfectly, but we are changing our implementation to make it work
    with pipes which is incorrect. Instead, we can change the pipe. The pipe should
    be marked stateful.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a stateless and stateful pipe is that stateful pipes
    are evaluated by Angular every time the framework does a change-detection run,
    which involves checking the complete application for changes. Therefore, with
    stateful pipes, the check is not limited to the pipe input/argument changes.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a `search` pipe stateless, just revert the first change we made and
    add back `pure: false` on the `Pipe` decorator:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: It still does not work! The `search` pipe has one more quirk that needs a fix.
    The All radio selection does not work perfectly. Add a new workout log, and it
    still will not show up, unless we switch filters.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix here is to revert the second change. Isolate this line in the `search` pipe:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And change it to the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We changed the `if` condition to return a new array every time (using the spread
    operator), even when `searchTerm` is `null`. If we return the same array reference,
    Angular does not check for a size change in the array and hence does not update
    the UI.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: That completes our History page implementation. You may now be wondering what
    the last few fixes on pipes have to do with how change detection works. Or you
    may be wondering what change detection is. Let's put all of these doubts to rest
    and introduce everyone to *Angular's change-detection system*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Angular's change detection will be covered extensively in Chapter 8, *Some Practical
    Scenarios*. The aim of the next section is to introduce the concept of change
    detection and how Angular performs this process.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Angular change detection overview
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To put it succinctly, change detection is all about tracking changes done to
    the component's model during app execution. This helps Angular's data-binding
    infrastructure to identify what parts of the view need to be updated. Every data
    binding framework needs to address this issue, and the approach these frameworks
    take for tracking changes differs. It even differs from AngularJS to Angular.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: To understand how change detection works in Angular, there are a few things
    that we need to keep in mind.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: An Angular app is nothing but a hierarchy of components, from the root to the
    leaf.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is nothing special about the component properties that we bind to view;
    therefore Angular needs an efficient mechanism to know when these properties change.
    It cannot keep polling for changes in these properties.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To detect changes in a property value, Angular does a *strict comparison* (`===`)
    between the previous and current value. For reference types, it means only the
    references are compared. No deep comparison is done.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For precisely this reason, we had to mark our search pipe as stateful. Adding
    elements to an existing array does not change the array reference and hence Angular
    fails to detect any change in the array. Once the pipe is marked as stateful,
    the pipe is evaluated, irrespective of whether the array has changed or not.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular cannot know when any bound property is updated automatically,
    it instead resorts to checking every bound property when a change detection run
    is triggered. Starting from the root of the component tree, Angular checks each
    bound property for changes as it goes down the component hierarchy. If a change
    is detected, that component is marked for refresh. It's worth reiterating that
    changes in a bound property do not immediately update the view. Instead, a change-detection
    run works in two phases.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: In the *first phase*, it does the component tree walk and marks components that
    need to be refreshed due to model updates
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *second phase*, the actual view is synchronized with the underlying model
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model changes and view updates are never interleaved during a change-detection
    run.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'We now just need to answer two more questions:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: When is a change-detection run triggered?
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many times does it run?
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An Angular change-detection run is triggered when any of these events are triggered:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '**User input/browser events**: We click on a button, enter some text, scroll
    the content. Each of these actions can update the view (and the underlying model).'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setTimeout and setInterval**: As it turns out, we can use `setTimeout` and `setInterval` to
    execute some code asynchronously and at specific intervals. Such code can also
    update the model. For example, a `setInterval` timer may check for stock quotes
    at regular intervals and update the stock price on the UI.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To answer how many times, **it's one**. Each component model is checked only
    once, in a top-down fashion, starting from the root component to the tree leaves.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: The last statement is true when Angular is configured to run in production mode.
    In development mode, the component tree is traversed twice for changes. Angular
    expects the model to be stable after the first tree walk. If that is not the case,
    Angular throws an error in development mode, and ignores the changes in production
    mode. We can enable the production mode by invoking the `enableProdMode` function
    before the `bootstrap` function call.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: It's time now to pick another topic linked to Angular's depedency injection.
    The concept of **hierarchical injectors** will be our next topic of discussion. 
    It is a very powerful feature that can come in handy as we build bigger and better
    apps using Angular.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical injectors
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **injector** in Angular's dependency injection setup is a container that is responsible for
    storing dependencies and dispensing them when asked for. The provider registration
    examples shared earlier actually register the dependencies with a global injector.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Registering component-level dependencies
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the dependency registrations that we have done thus far were done on
    a module. Angular goes one step further and allows registration of dependencies
    at the component level too. There is a similar `providers` attribute on the `@Component` decorator
    that allows us to register dependency at the component level.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'We could''ve very well registered the `WorkoutHistoryTrackerService` dependency
    on `WorkoutRunnerComponent`. Something along these lines:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: But whether we should do it or not is something that we discuss here.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this discussion on hierarchical injectors, it's important
    to understand that Angular creates an injector per component (oversimplified).
    Dependency registration done at the component level is available on the component
    and its descendants.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that dependencies are singleton in nature. Once created, the
    injector will always return the same dependency every time. This feature is evident
    from the workout history implementation.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutHistoryTrackerService` was registered with the `CoreModule` and then
    injected into two components: `WorkoutRunnerComponent` and `WorkoutHistoryComponent`.
    Both components get the same instance of `WorkoutHistoryTrackerService`. The next
    diagram highlights this registration and injection:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
- en: 'To confirm, just add a `console.log` statement in the `WorkoutHistoryTrackerService` constructor:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Refresh the app and open the history page by clicking on the header link. The
    message log is generated once, irrespective of how many times we run the workout
    or open the history page.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: That's also a new interaction/data flow pattern!
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Think carefully; a service is being used to share state between two components. `WorkoutRunnerComponent` is
    generating data and `WorkoutHistoryComponent` is consuming it. And without any
    interdependence. We are exploiting the fact that dependencies are singleton in
    nature. This data-sharing/interaction/data-flow pattern can be used to share state
    between any number of components. Indeed, this is a very powerful weapon in our
    arsenal. The next time there is a need to share state between unrelated components,
    think of services.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: But what does all this have to do with hierarchical injectors? OK, let's not
    beat around the bush; let's get straight to the point.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: While dependencies registered with the injector are singleton, `Injector` itself
    is not! At any given point in time, there are multiple injectors active in the
    application. In fact, injectors are created in the same hierarchy as the component
    tree. Angular creates an `Injector` instance for every component in the component
    tree (oversimplification; see the next information box).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular does not literally create an injector for each component. As explained
    in the Angular developer guide: every component doesn''t need its own injector
    and it would be horribly inefficient to create masses of injectors for no good
    purpose. But it is true that every component has an injector (even if it shares
    that injector with another component) and there may be many different injector
    instances operating at different levels of the component tree. It is useful to
    pretend that every component has its own injector.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'The component and injector tree looks something like this when a workout is
    running:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
- en: The insert textbox denotes the component name. The **root injector** is the
    injector created as part of the application bootstrap process.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: What is the significance of this injector hierarchy? To understand the implications,
    we need to understand what happens when a component requests a dependency.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Angular DI dependency walk
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever requested for a dependency, Angular first tries to satisfy the dependency
    from the component''s own injector. If it fails to find the requested dependency,
    it queries the parent component injector for the dependency, and its parent if
    the probing fails again, and so on and so forth till it finds the dependency or
    reaches the root injector. The takeaway: any dependency search is hierarchy-based.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Earlier when we registered `WorkoutHistoryTrackerService`, it was registered
    with the root injector. The `WorkoutHistoryTrackerService` dependency request
    from both `WorkoutRunnerComponent` and `WorkoutHistoryComponent` gets satisfied
    by the root injector, and not by their own component injectors.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchical injector structure brings a lot of flexibility. We can configure
    different providers at different component levels and override the parent provider
    configuration in child components. This only applies to dependencies registered
    on components. If the dependency is added to a module, it gets registered on the
    root injector.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if a dependency is registered at the component level, its life cycle
    is bound to the component''s life cycle. The dependency is created every time
    the component is loaded, and destroyed when the component is destroyed. Unlike
    module-level dependencies that are created only once: when requested for the first
    time.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to override the global `WorkoutHistoryTrackerService` service in components
    that use it to learn what happens on such overrides. It's going to be fun and
    we will learn a lot!
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.component.ts` and add a `providers` attribute to the `@Component` decorator:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Do this in `workout-history.component.ts` too. Now if we refresh the app, start
    a workout, and then load the history page, the grid is empty. Irrespective of
    the times we try to run the workout, the history grid is always empty.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is quite obvious. After setting the `WorkoutHistoryTrackerService` provider
    on each `WorkoutRunnerComponent` and `WorkoutHistoryComponent`, the dependency
    is being fulfilled by the respective component injectors themselves. Both component
    injectors create their own instance of `WorkoutHistoryTrackerService` when requested,
    and hence the history tracking is broken. Look at the following diagram to understand
    how the request is fulfilled in both scenarios:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
- en: 'A quick question: what happens if we register the dependency in the root component, `TrainerAppComponent`,
    instead of doing it on the module? Something like this:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Interestingly, with this setup too, things work perfectly. That's pretty evident; `TrainerAppComponent` is
    a parent component for `RouterOutlet` that internally loads `WorkoutRunnerComponent` and `WorkoutHistoryComponent`.
    Hence in such a setup, the dependency gets fulfilled by the `TrainerAppComponent` injector.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Dependency lookup up on the component hierarchy can be manipulated if an intermediate
    component has declared itself as a host component. We will learn more about it
    in later chapters.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical injectors allow us to register dependencies at a component level,
    avoiding the need to register all dependencies globally.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: The predominant use case for this functionality is when building an Angular
    library component. Such components can register their own dependencies without
    requiring the consumer of the library to register library-specific dependencies.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: if you are having trouble loading the right service/dependency, make
    sure you check the component hierarchy for overrides done at any level.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: We now understand how dependency resolution works in components. But what happens
    if a service has a dependency? Yet more uncharted territory to explore. Let's
    extend our app further.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Remove any `provider` registration done on components before continuing further.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection with @Injectable
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WorkoutHistoryTrackerService` has a fundamental flaw: the history is not persisted.
    Refresh the app and the history is lost. We need to add persistence logic to store
    historical data. To avoid any complex setup, we are going to use the browser local
    storage to store historical data.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `LocalStorageService` service by invoking this CLI command from the `trainer/src/app/core` folder:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Copy the following two functions to the generated class, or copy them from
    the `checkpoint3.2` GitHub branch:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: A simple wrapper over the browser's `localStorage` object.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other dependency, inject it into the `WorkoutHistoryTrackerService` constructor
    (the `workout-history-tracker.ts` file) with the necessary import:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: It is advisable that the default `Injectable` decorator on the service is applied,
    even if we register the dependency on module (`NgModule` provider registrations
    syntax). Especially when the service itself has a dependency, as it does with
    the preceding example of `WorkoutHistoryTrackerService`. Do not use the `providedIn` decorator
    attribute of `Injectable`  when using the module-based service registration.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: By putting in the `@Injectable` decorator, we are forcing the TypeScript transpiler
    to generate metadata for the `WorkoutHistoryTrackerService` class. This includes
    details about the constructor arguments. Angular DI consumes this generated metadata
    to determine the types of dependency the service has, and in future, it fulfills
    these dependencies when the service is created.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: What about `WorkoutRunnerComponent`, which that uses `WorkoutHistoryTrackerService`?
    We have not used `@Injectable` there but still, the DI works. We don't need to.
    Any decorator works and there is already an `@Component` decorator applied to
    all components.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: The actual integration between the `LocalStorage` service and `WorkoutHistoryTrackerService` is
    a mundane process.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the constructor for `WorkoutHistoryTrackerService` as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And add a declaration for `storageKey`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The constructor loads the workout logs from the local storage. The `map` function
    call is necessary as everything stored in `localStorage` is a string. Therefore,
    while de-serializing, we need to convert the string back to the date value.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement last in the `startTracking`, `exerciseComplete`, and `endTracking` functions:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We save the workout history to local storage every time the historical data
    changes.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: That's it! We have built workout history tracking over `localStorage`. Verify
    it!
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to our big-ticket item, audio support, there are a few minor
    fixes that are needed for a better user experience. The first one is related to
    the History link.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Tracking route changes using the router service
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The History link in the `Header` component is visible for all routes other that
    when a workout is in progress. We don't want to lose an in-progress workout by
    accidentally clicking on the History link. Moreover, no one is interested in knowing
    about the workout history while doing a workout.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: The fix is easy. We just need to determine whether the current route is the
    workout route and hide the link. The `Router` service is going to help us with
    this job.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `header.component.ts` and look at the highlighted implementation:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `showHistoryLink` property binds to the view and decides whether the history
    link is shown to the user or not. In the constructor, we inject the `Router` service
    and subscribe to the observable `events` using the `subscribe` function.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about observables later in the chapter, but for now, it is
    enough to understand that observables are objects that raise events and can be
    subscribed to. Since the router raises a number of events throughout the component's
    life cycle, the `filter` operator allows us to filter the event we are interested
    in and the `subscribe` function registers a callback function that is invoked
    every time the route changes.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: To learn about the other router events, including `NavigationStart`, `NavigationEnd`, `NavigationCancel`,
    and `NavigationError`, look at the router documentation ([http://bit.ly/ng-router-events](http://bit.ly/ng-router-events))
    to understand when the events are raised.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback implementation just toggles the `showHistoryLink` state based
    on the current route URL. To use `showHistoryLink` in the view, just update the
    header template line with the anchor tag to:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: And that's it! The History link does not show up on the workout page.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the `checkpoint3.2` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.2` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-2](http://bit.ly/ng6be-checkpoint-3-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Another fix/enhancement is related to the video panel on the workout page.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the video playback experience
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current video panel implementation can at best be termed amateurish. The
    size of the default player is small. When we play the video, the workout does
    not pause. The video playback is interrupted on exercise transitions. Also, the
    overall video-load experience adds a noticeable lag at the start of every exercise
    routine. This is a clear indication that this approach to video playback needs
    some fixing.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we are going to do to fix the video panel:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Show the image thumbnail for the exercise video instead of loading the video
    player itself
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on the thumbnail, load a popup/dialog with a bigger video
    player that can play the selected video
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause the workout while the video playback is on
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get on with the job!
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Using thumbnails for video
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Replace the `ngFor` HTML template inside `video-player.component.html` with this snippet:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We have abandoned iframe, and instead loaded the thumbnail image of the video
    (check the `img` tag). All other content shown here is for styling the image.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: We have referenced the Stack Overflow post ([http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)) to
    determine the thumbnail image URL for our videos.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Start a new workout; the images should show up, but the playback functionality
    is broken. We need to add a video playback dialog.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Using the ngx-modialog library
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show the video in a dialog, we are going to incorporate a third-party library, **ngx-modialog**,
    available on GitHub at [http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog).
    Let's install and configure the library.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line (inside the `trainer` folder), run the following command
    to install the library:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Work on an Angular v6-compatible `ngx-modialog` library is in progress ([https://github.com/shlomiassaf/ngx-modialog/issues/426](https://github.com/shlomiassaf/ngx-modialog/issues/426)).
    To use the version 5 library, which is dependent on older version of RxJS, install
    the `rxjs-compat` package from command line, `npm i rxjs-compat --save`, before
    proceeding.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'Next import and configure the library in the core module. Open `core.module.ts` and
    add the highlighted configurations:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The library is now ready for use.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: While *ngx-modialog* has a number of predefined templates for standard dialogs,
    such as alert, prompt, and confirm, these dialogs provide little customization
    in terms of look and feel. To have better control over the dialog UI, we need
    to create a custom dialog, which thankfully the library supports.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom dialogs
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom dialogs in `ngx-modialog` are nothing but Angular components with some
    special library construct incorporated.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with building a video dialog component that shows the YouTube
    video in a popup dialog. Generate the component''s boilerplate by navigating to `trainer/src/app/workout-runner/video-player` and
    running the following command:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Copy the video dialog implementation from the `workout-runner/video-player/video-dialog` folder
    in the `checkpoint3.3` Git branch (GitHub location: [http://bit.ly/ng6be-3-3-video-dialog](http://bit.ly/ng6be-3-3-video-dialog))
    into your local setup. You need to update the component implementation and the
    view.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update `workout-runner.module.ts` and add a new `entryComponents` attribute
    to the module decorator:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The newly created `VideoDialogComponent` needs to be added to `entryComponents` as
    it is not explicitly used in the component tree.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '`VideoDialogComponent` is a standard Angular component, with some modal dialog
    and specific implementations that we describe later. The `VideoDialogContext` class
    declared inside `VideoDialogComponent` has been created to pass the `videoId` of
    the YouTube video clicked to the dialog instance. The library uses this context
    class to pass data between the calling code and the modal dialog. The `VideoDialogContext` class
    inherits a configuration class that the dialog library uses to alter the behavior
    and UI of the modal dialog from `BSModalContext`.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: To get a better sense of how `VideoDialogContext` is utilized, let's invoke
    the preceding dialog from the workout runner when the video image is clicked.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ngFor` div in `video-player.component.html` and add a `click` event
    handler:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The preceding handler invokes the `playVideo` method, passing in the video
    clicked. The `playVideo` function, in turn, opens the corresponding video dialog.
    Add the `playVideo` implementation to `video-player.component.ts` as highlighted:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `playVideo` function calls the `Modal` class' `open` function, passing in
    the dialog component to open and a new instance of the `VideoDialogContext` class
    with the `videoId` of the YouTube video. Before proceeding, delete the `ngOnChange` function
    and the interface declaration too.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the `VideoDialogComponent` implementation, the component implements
    the `ModalComponent<VideoDialogContext>` interface required by the modal library.
    Look at how the context (`VideoDialogContext`) to the dialog is passed to the
    constructor and how we extract and assign the `videoId` property from the context.
    Then it's just a matter of binding the `videoId` property to the template view
    (see the HTML template) and rendering the YouTube player.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: And we are good to go. Load the app and start the workout. Then click on any
    workout video images. The video dialog should load and now we can watch the video!
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we call the dialog implementation complete, there is one small issue
    that needs to be fixed. When the dialog opens, the workout should pause: that''s
    not happening currently. We will help you fix it at the end of the next section
    using Angular''s eventing infrastructure.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the `checkpoint3.3` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.3` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-3](http://bit.ly/ng6be-checkpoint-3-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last feature that we plan to add to *7-Minute Workout* before
    wrapping up the application and building something new with Angular: audio support.
    It teaches us some new cross-component communication patterns too.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Cross-component communication using Angular events
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched upon events in the last chapter when learning about Angular's binding infrastructure.
    It's time now to look at eventing in more depth. Let's add audio support to *7-Minute
    Workout*.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: Tracking exercise progress with audio
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the *7-Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues help the user perform the
    workout effectively as they can just follow the audio instructions.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: A ticking clock soundtrack progress during the exercise
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exercise-completion audio clip plays when the exercise is about to end
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An audio clip plays during the rest phase and informs users about the next exercise
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be an audio clip for each of these scenarios.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into HTML content. We too will use the `<audio>` tag
    to play back our clips.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: The `checkpoint3.4` Git and the `trainer/static/audio` folder contain all the
    audio files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Download and unzip the contents and copy the audio files.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Building Angular directives to wrap HTML audio
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked a lot with JavaScript and jQuery, you may have realized we have
    purposefully shied away from directly accessing the DOM for any of our component
    implementations. There has not been a need to do it. The Angular data-binding
    infrastructure, including property, attribute, and event binding, has helped us
    manipulate HTML without touching the DOM.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: For the audio element too, the access pattern should be Angularish. In Angular,
    the only place where direct DOM manipulation is acceptable and practiced is inside
    directives. Let's create a directive that wraps access to audio elements.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `trainer/src/app/shared` and run this command to generate a template
    directive:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Since it is the first time we are creating a directive, we encourage you to
    look at the generated code.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the directive is added to the shared module, it needs to be exported
    too. Add the `MyAudioDirective` reference in the `exports` array too (`shared.module.ts`).
    Then update the directive definition with the following code:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive` decorator
    is similar to the `@Component` decorator except we cannot have an attached view.
    Therefore, no `template` or `templateUrl` is allowed!
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. We have replaced the generated `[abeMyAudioDirective]` attribute
    selector with just `audio`. Using `audio` as the selector makes our directive
    load for every `<audio>` tag used in HTML. The new selector works as an element
    selector.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: In a standard scenario, directive selectors are attribute-based (such as `[abeMyAudioDirective]` for
    the generated code), which helps us identify where the directive has been applied.
    We deviate from this norm and use an element selector for the `MyAudioDirective` directive.
    We want this directive to be loaded for every audio element, and it becomes cumbersome
    to go to each audio declaration and add a directive-specific attribute. Hence
    an element selector.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementRef` object injected in the constructor is the Angular element (`audio` in
    this case) for which the directive is loaded. Angular creates the `ElementRef` instance
    for every component and directive when it compiles and executes the HTML template.
    When requested in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the underlying audio element in
    the code (the instance of `HTMLAudioElement`). The `audioPlayer` property holds
    this reference.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a Boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Creating WorkoutAudioComponent for audio support
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>` tags
    (two audio tags work together for next-up audio).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: From the command line go to the `trainer/src/app/workout-runner` folder and
    add a new `WorkoutAudioComponent` component using Angular CLI.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-audio.component.html` and replace the existing view template
    with this HTML snippet:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'There are five `<audio>` tags, one for each of the following:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '**Ticking audio**: The first audio tag produces the ticking sound and is started as
    soon as the workout starts.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next up audio and exercise audio**: There next two audio tags work together.
    The first tag produces the "Next up" sound. And the actual exercise audio is handled
    by the third tag (in the preceding code snippet).'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Halfway audio**: The fourth audio tag plays halfway through the exercise.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**About to complete audio**: The final audio tag plays a piece to denote the
    completion of an exercise.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you notice the usage of the `#` symbol in each of the `audio` tags? There
    are some variable assignments prefixed with `#`. In the Angular world, these variables are
    known as **template reference variables** or at times **template variables**.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: 'As the platform guide defines:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: A template reference variable is often a reference to a DOM element or directive
    within a template.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Don't confuse them with the template input variables that we have used with
    the `ngFor` directive earlier, `*ngFor="let` video `of videos"`. The **template
    input variable's** (`video` in this case) scope is within the HTML fragment it
    is declared, whereas the template reference variable can be accessed across the
    entire template.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the last section where `MyAudioDirective` was defined. The `exportAs` metadata
    is set to `MyAudio`. We repeat that same `MyAudio` string while assigning the `template
    reference variable` for each audio tag:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template-reference variable based on what is on the right
    side of equals.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Typically, template variables, once declared, give access to the view element/component
    they are attached to, to other parts of the view, something we will discuss shortly.
    But in our case, we will use template variables to refer to the multiple `MyAudioDirective` from
    the parent component's code. Let's understand how to use them.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the generated `workout-audio.compnent.ts` with the following outline:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The interesting bit in this outline is the `@ViewChild` decorator against the
    five properties. The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed to the decorator is the template
    variable name, which helps DI match the element/directive to inject. When Angular
    instantiates the main `WorkoutAudioComponent`, it injects the corresponding audio
    directives based on the `@ViewChild` decorator and the template reference variable
    name passed. Let's complete the basic class implementation before we look at `@ViewChild` in
    detail.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild` injection
    injects the related `ElementRef` instance instead of the `MyAudioDirective` instance.
    We can confirm this by removing the `exportAs` attribute from `myAudioDirective` and
    then looking at the injected dependencies in `WorkoutAudioComponent`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Having trouble writing these functions? They are available in the `checkpoint3.3` Git
    branch.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts`, as follows (again available in `checkpoint3.3`):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: These are model classes to track progress events. The `WorkoutAudioComponent` implementation
    consumes this data. Remember to import the reference for `ExerciseProgressEvent` and `ExerciseProgressEvent` in `workout-audio.component.ts`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, the audio component consumes the events by defining two event
    handlers: `onExerciseProgress` and `onExerciseChanged.` How the events are generated
    becomes clear as we move along.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, about to complete, or
    half-way audio playback. We just want to continue from where we left off.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line and helps `WorkoutAudioComponent` to
    decide when to play the next up exercise audio.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template reference variables
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Template reference variables** are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 'Template variables work with components too. We can easily do this:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In this case, `runner` has a reference to the `WorkoutRunnerComponent` object,
    and the button is used to start the workout.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Template variable assignment
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may not have noticed but there is something interesting about the template variable
    assignments described in the last few sections. To recap, the three examples that
    we have used are:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'What got assigned to the variable depends on where the variable was declared.
    This is governed by rules in Angular:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective` directive
    sets the `ticks` variable to an instance of `MyAudioDirective`.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `input` and `workout-runner` examples).
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be employing this technique to implement the workout audio component
    integration with the workout runner component. This introduction gives us the
    head start that we need.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Using the @ViewChild decorator
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@ViewChild` decorator instructs the Angular DI framework to search for
    some specific child component/directive/element in the component tree and inject
    it into the parent. This allows the parent component to interact with child components/element
    using the reference to the child, a new communication pattern!
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the audio element directive (the `MyAudioDirective` class)
    is injected into the `WorkoutAudioComponent` code.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent` property: `ticks`.
    The search is done based on the selector passed to the `@ViewChild` decorator.
    Let''s see the audio example again:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'Or it can be a *type.* This is valid and should inject an instance of `MyAudioDirective`:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: However, it does not work in our case. Why? Because there are multiple `MyAudioDirective` directives
    declared in the `WorkoutAudioComponent` view, one for each of the `<audio>` tags.
    In such a scenario, the first match is injected. Not very useful. Passing the
    type selector would have worked if there was only one `<audio>` tag in the view!
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit` event
    hook on the component is called. This implies such properties are `null` if accessed
    inside the constructor.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: Angular also has a decorator to locate and inject multiple child components/directives: `@ViewChildren`.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: The @ViewChildren decorator
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@ViewChildren` works similarly to `@ViewChild`, except it can be used to inject
    multiple child types into the parent. Again taking the previous audio component
    above as an example, using `@ViewChildren`, we can get all the `MyAudioDirective` directive
    instances in `WorkoutAudioComponent`, as shown here:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Look carefully; `allAudios` is not a standard JavaScript array, but a custom
    class, `QueryList<Type>`. The `QueryList` class is an immutable collection that
    contains the reference to the components/directives that Angular was able to locate
    based on the filter criteria passed to the `@ViewChildren` decorator. The best
    thing about this list is that Angular will keep this list in sync with the state
    of the view. When directives/components get added/removed from the view dynamically,
    this list is updated too. Components/directives generated using `ng-for` are a
    prime example of this dynamic behavior. Consider the preceding `@ViewChildren` usage
    and this view template:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into the `allAudio` property and keeps
    it in sync when items are added or removed from the `clips` array.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective` directives,
    it cannot be used to control the playback. You see, we need to get hold of individual `MyAudioDirective` instances
    as the audio playback timing varies. Hence the distinct `@ViewChild` implementation.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: Integrating WorkoutAudioComponent
  id: totrans-667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have componentized the audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to the `WorkoutRunnerComponent` implementation. `WorkoutAudioComponent` derives
    its operational intelligence from `WorkoutRunnerComponent`. Hence the two components
    need to interact. `WorkoutRunnerComponent` needs to provide the `WorkoutAudioComponent` state
    change data, including when the workout started, exercise progress, workout stopped,
    paused, and resumed.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent` API
    (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`,
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the `WorkoutAudioComponent` in the `WorkoutRunnerComponent''s` view,
    such as:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Doing so gives us a reference to the `WorkoutAudioComponent` inside the `WorkoutRunnerComponent` implementation:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `WorkoutAudioComponent` functions can then be invoked from `WorkoutRunnerComponent` from
    different places in the code. For example, this is how `pause` would change:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'And to play the next-up audio, we would need to change parts of the `startExerciseTimeTracking` function:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent` now
    needs to manage audio playback too.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative, however.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutRunnerComponent` can expose events that are triggered during different
    times of workout execution, such as workout started, exercise started, and workout
    paused. The advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components/directives with `WorkoutRunnerComponent` using
    the same events. Be it the `WorkoutAudioComponent` or components we create in
    future.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Exposing WorkoutRunnerComponent events
  id: totrans-682
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now we have only explored how to consume events. Angular allows us to raise
    events too. Angular components and directives can expose custom events using the `EventEmitter` class
    and the `@Output` decorator.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these event declarations to `WorkoutRunnerComponent` at the end of the
    variable declaration section:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent` implementation,
    we need to raise them at the appropriate times.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add the `ExerciseProgressEvent` and `ExerciseChangeEvent` imports
    to the `model` already declared on top. And add the `Output` and `EventEmitter` imports
    to `@angular/core`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter` class.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: The @Output decorator
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a decent amount of Angular eventing capabilities in Chapter 2, *Building
    Our First App – 7-Minute Workout*. Specifically, we learned how we can consume
    any event on a component, directive, or DOM element using the `bracketed ()` syntax.
    How about raising our own events?
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class, we can define and raise custom events.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: It's also a good time to refresh what we learned about events, by revisiting
    the *Eventing subsection* in the *Angular event binding infrastructure* section
    from Chapter 2, *Building Our First App – 7-Minute Workout*.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember this: it is through events that components can communicate with the
    outside world. When we declare:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: It signifies that `WorkoutRunnerComponent` exposes an event, `exercisePaused` (raised
    when the workout is paused).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: 'To subscribe to this event, we can do the following:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This looks absolutely similar to how we did the DOM event subscription in the
    workout runner template. See this sample stipped from the workout-runner''s view:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. Events created without the `@Output` decorator cannot be referenced in
    HTML.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Output` decorator can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> ...`. This declares a `workoutPaused` event
    instead of `exercisePaused`.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Like any decorator, the `@Output` decorator is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the `EventEmitter` class.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Eventing with EventEmitter
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular embraces **reactive programming** (also dubbed **Rx**-style programming)
    to support asynchronous operations with events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is all about programming against **asynchronous data streams**.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: The data can be anything, ranging from browser/DOM element events to user input
    to loading remote data using AJAX. With *Rx* style, we consume this data uniformly.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular **Observer design pattern**. **Observables** are streams that
    emit data. **Observers**, on the other hand, subscribe to these events.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an *observer* and *observable*. We can fire events on
    it and it can also listen to events.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` *is the observable side*.'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`. `subscribe` is
    the observer side.'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: Raising events from WorkoutRunnerComponent
  id: totrans-713
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the `EventEmitter` declaration. These have been declared with the `type` parameter.
    The `type` parameter on `EventEmitter` signifies the type of data emitted.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the event implementation to `workout-runner.component.ts`, starting
    from the top of the file and moving down.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement to the end of the `start` function:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We use the `emit` function of  `EventEmitter`  to raise a `workoutStarted` event
    with the current workout plan as an argument.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To `resume`, add the following line:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising the `exercisePaused` and `exerciseResumed` events.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'To the same function, add the highlighted code:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The event is raised when the workout is completed.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same function, we raise an event that communicates the workout progress.
    Add this statement:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: That completes our eventing implementation.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: Component communication patterns
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the implementation stands now, we have:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: A basic `WorkoutAudioComponent` implementation
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmented `WorkoutRunnerComponent` by exposing workout life cycle events
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two components just need to talk to each other now.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'If the parent needs to communicate with its children, it can do this by:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example, this property
    binding can stop the audio player when the workout is paused:'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Property binding, in this case, works fine. When the workout is paused, the
    audio is stopped too. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren` decorators
    in the `WorkoutAudioComponent` implementation. This approach and its shortcomings
    have also been discussed briefly in the *Integrating WorkoutAudioComponent* section.'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one more not-so-good option. Instead of the parent referencing the
    child component, the child references the parent component. This allows the child
    component to call the parent component's public functions or subscribe to parent
    component events.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a parent component into a child component
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before the
    last closing `div`:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Next, inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`. Open `workout-audio.component.ts` and
    add the following declaration and update the constructor:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'And remember to add these imports:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Let's try to understand what we have done before running the app. There is some
    amount of trickery involved in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`, it fails with
    Angular complaining of not being able to find all the dependencies. Read the code
    and think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent` is
    already dependent on `WorkoutAudioComponent`, as we have referenced `WorkoutAudioComponent` in
    the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent` in `WorkoutAudioComponent`,
    we have created a dependency cycle.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject` decorator
    and passing in the token created using the `forwardRef()` global framework function.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: Once the injection is done correctly, inside the constructor, we attach a handler
    to the `WorkoutRunnerComponent` events, using the `subscribe` function of `EventEmitter`.
    The arrow function passed to `subscribe` is called whenever the event occurs with
    a specific event argument. We collect all the subscriptions into a `subscription` array.
    This array comes in handy when we unsubscribe, which we need to, to avoid memory
    leaks.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit about `EventEmitter`: the `EventEmmiter` subscription (`subscribe` function)
    takes three arguments:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The first argument is a callback, which is invoked whenever an event is emitted
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all the `\` audio clips play at the right
    time. You may have to wait some time to hear the other audio clips. What is the
    problem?
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks` audio
    element or using the component life cycle events to trigger the ticking sound.
    Let's take the second approach.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: Using component life cycle events
  id: totrans-764
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The injected `MyAudioDirective` in `WorkoutAudioComponent`, shown as follows,
    is not available till the view is initialized:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    children of `WorkoutAudioComponent` to be initialized.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: The component's life cycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `WorkoutAudioComponent` by adding the interface implementation, and
    the necessary imports, as highlighted:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If, in the middle of the workout, we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: It seems that `WorkoutRunnerComponent` is not getting destroyed on route navigation,
    and due to this, none of the child components are destroyed, including `WorkoutAudioComponent`.
    The net result? A new `WorkoutRunnerComponent` is being created every time we
    navigate to the workout page but is never removed from the memory on navigating
    away.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will never
    be dereferenced.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` Add
    this implementation to the `WorkoutAudioComponent` class:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Also, remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts` from
    the *Injecting a parent component into a child component* section onward.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: Sibling component interaction using events and template variables
  id: totrans-781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` were organized
    as sibling components?
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular''s *eventing* and *template reference variables*.
    Confused? Well, to start with, this is how the components should be laid out:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Does it ring any bells? Starting from this template, can you guess how the final
    HTML template would look? Think about it before you proceed further.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `WorkoutAudioComponent` template variable, `wa`, is being manipulated by
    referencing the variable in the event handler expressions on `WorkoutRunnerComponent`.
    Quite elegant! We still need to solve the biggest puzzle in this approach: Where
    does the preceding code go? Remember, `WorkoutRunnerComponent` is loaded as part
    of route loading. Nowhere in the code have we had a statement like this:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We need to reorganize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a new component code from command line by navigating to `trainer/src/app/workout-runner` and
    executing:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Copy the HTML code with the events described to the template file. The workout
    container component is ready.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to rewire the routing setup. Open `app-routing.module.ts`. Change
    the route for the workout runner and add the necessary import:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eye!
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.4` code.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: Here is an obvious hint. Use the eventing infrastructure!
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: 'And one last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the `checkpoint3.4` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.4` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bit by bit, piece by piece, we have added a number of enhancements to the *7-Minute
    Workout* app that are imperative for any professional app. There is still scope
    for new features and improvements, but the core app works just fine.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by exploring the Single Page Application (SPA) capabilities
    of Angular. Here we learned about basic Angular routing, setting up routes, using
    route configuration, generating links using the `RouterLink` directive, and using
    the Angular `Router` and `Location` services to perform navigation.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: From the app perspective, we added start, finish, and workout pages to *7-Minute
    Workout*.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: We then built a workout history tracker service that was used to track historical
    workout executions. During this process, we learned about Angular's **Dependency
    Injection (DI)** in depth. We covered how a dependency is registered, what a dependency
    token is, and how dependencies are singleton in nature. We also learned about
    injectors and how hierarchical injectors affect dependency probing.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we touched upon an important topic: cross-component communication,
    primarily using Angular eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: The `@ViewChild` and `@ViewChildren` decorators that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling-component communication can happen using Angular events and template
    variables.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: What's next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7-Minute Workout* app into a generic *Workout Runner* app
    that can run workouts that we build using *Personal Trainer*.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: For the next chapter, we'll showcase Angular's form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
