<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-62"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.2.1">Designing Your React Components</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to this pivotal chapter on mastering React component design. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we’ll embark on an enriching journey to recognize and eradicate common anti-patterns in designing React components, including issues such as large monolithic components, prop drilling, and other prevalent pitfalls that often perplex developers and hamper the maintainability and scalability of React applications.</span></p>
<p><span class="koboSpan" id="kobo.4.1">First, we’ll introduce the single responsibility principle. </span><span class="koboSpan" id="kobo.4.2">In the realm of React, this guides us to ensure that each component has one specific purpose. </span><span class="koboSpan" id="kobo.4.3">Adhering to this principle makes components easier to understand, test, and maintain, all while making your code more readable and manageable.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Next, we’ll explore the don’t repeat yourself principle. </span><span class="koboSpan" id="kobo.5.2">One of the core tenets of effective programming, this encourages developers to minimize repetition and promote reuse. </span><span class="koboSpan" id="kobo.5.3">In the context of React, this principle can be the key to unlocking a more streamlined, efficient, and maintainable code base.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Finally, we’ll delve into the component composition principle. </span><span class="koboSpan" id="kobo.6.2">Composition allows us to build complex UIs by combining simpler, reusable components. </span><span class="koboSpan" id="kobo.6.3">In React, composition is favored over inheritance, leading to more flexible and easier-to-manage components.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Throughout this chapter, we’ll take a deep dive into each of these principles, providing real-world examples and practical applications. </span><span class="koboSpan" id="kobo.7.2">By doing so, we aim to guide you in crafting more efficient components, bolstering your understanding of React’s potential, and enhancing your problem-solving skills in this powerful library.</span></p>
<p><span class="koboSpan" id="kobo.8.1">So, in this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Exploring the single responsibility principle</span></li>
<li><span class="koboSpan" id="kobo.10.1">Learning about the don’t repeat yourself principle</span></li>
<li><span class="koboSpan" id="kobo.11.1">Using composition</span></li>
<li><span class="koboSpan" id="kobo.12.1">Combining component design principles</span></li>
</ul>
<h1 id="_idParaDest-64"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">A GitHub repository has been created to host all the code we discuss in the book. </span><span class="koboSpan" id="kobo.14.2">For this chapter, you can find the recommended structure under </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch4"><span class="koboSpan" id="kobo.15.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch4</span></a><span class="koboSpan" id="kobo.16.1">.</span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.17.1">Exploring the single responsibility principle</span></h1>
<p><span class="koboSpan" id="kobo.18.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.19.1">single responsibility principle</span></strong><span class="koboSpan" id="kobo.20.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.21.1">SRP</span></strong><span class="koboSpan" id="kobo.22.1">) is one of the fundamental concepts in software </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.23.1">engineering, asserting that a function, class, or, in the context of React, a component, should have only one reason to change. </span><span class="koboSpan" id="kobo.23.2">In other words, each component should ideally handle a single task or functionality. </span><span class="koboSpan" id="kobo.23.3">Following this principle can make your code more readable, maintainable, and easier to test and debug.</span></p>
<p><span class="koboSpan" id="kobo.24.1">Let’s illustrate this with an example. </span><span class="koboSpan" id="kobo.24.2">Suppose you initially have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">BlogPost</span></strong><span class="koboSpan" id="kobo.26.1"> component that fetches blog post data, displays the post, and handles the user liking the post, all in one component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.27.1">
import React, { useState, useEffect } from "react";
import fetchPostById from "./fetchPostById";
interface PostType {
  id: string;
  title: string;
  summary: string;
}
const BlogPost = ({ id }: { id: string }) =&gt; {
  const [post, setPost] = useState&lt;PostType&gt;(EmptyBlogPost);
  const [isLiked, setIsLiked] = useState(false);
  useEffect(() =&gt; {
    fetchPostById(id).then((post) =&gt; setPost(post));
  }, [id]);
  const handleClick = () =&gt; {
    setIsLiked(!isLiked);
  };
  return (
    &lt;div&gt;
      &lt;h2&gt;{post.title}&lt;/h2&gt;
      &lt;p&gt;{post.summary}&lt;/p&gt;
      &lt;button onClick={handleClick}&gt;
        {isLiked ? </span><span class="koboSpan" id="kobo.27.2">"Unlike" : "Like"}
      &lt;/button&gt;
    &lt;/div&gt;
  );
};
export default BlogPost;</span></pre> <p><span class="koboSpan" id="kobo.28.1">The code defines a </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.29.1">functional component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">BlogPost</span></strong><span class="koboSpan" id="kobo.31.1"> that takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">id</span></strong><span class="koboSpan" id="kobo.33.1"> prop of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">string</span></strong><span class="koboSpan" id="kobo.35.1"> type. </span><span class="koboSpan" id="kobo.35.2">Inside the component, there are two state variables defined using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">useState</span></strong><span class="koboSpan" id="kobo.37.1"> Hook: </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">post</span></strong><span class="koboSpan" id="kobo.39.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">isLiked</span></strong><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">post</span></strong><span class="koboSpan" id="kobo.43.1"> state represents the blog post data, initialized with a default value of an empty blog post. </span><span class="koboSpan" id="kobo.43.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">isLiked</span></strong><span class="koboSpan" id="kobo.45.1"> state represents whether the post is liked or not, initialized as </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">false</span></strong><span class="koboSpan" id="kobo.47.1">.</span></p>
<p><span class="koboSpan" id="kobo.48.1">Following this, we</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.49.1"> need to manage the side effect (sending network requests) in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">useEffect</span></strong><span class="koboSpan" id="kobo.51.1"> Hook. </span><span class="koboSpan" id="kobo.51.2">It is used to fetch the blog post data from the server based on the provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">id</span></strong><span class="koboSpan" id="kobo.53.1"> prop. </span><span class="koboSpan" id="kobo.53.2">It triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">fetch</span></strong><span class="koboSpan" id="kobo.55.1"> operation whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">id</span></strong><span class="koboSpan" id="kobo.57.1"> prop changes. </span><span class="koboSpan" id="kobo.57.2">Once the data is fetched, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">post</span></strong><span class="koboSpan" id="kobo.59.1"> state is updated with the retrieved post using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">setPost</span></strong><span class="koboSpan" id="kobo.61.1"> function.</span></p>
<p><span class="koboSpan" id="kobo.62.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">useEffect</span></strong><span class="koboSpan" id="kobo.64.1"> Hook call, for the network request, there is a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">fetchPostById</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">The function is simply a </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">fetch</span></strong><span class="koboSpan" id="kobo.68.1"> call to a remote API endpoint. </span><span class="koboSpan" id="kobo.68.2">We can assume the function is implemented with something like the following code snippet:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
const fetchPostById = (id: string) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; resolve({}), 2000);
  })
};</span></pre> <p><span class="koboSpan" id="kobo.70.1">The component renders the title and summary of the blog post from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">post</span></strong><span class="koboSpan" id="kobo.72.1"> state. </span><span class="koboSpan" id="kobo.72.2">It also renders a button that toggles the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">isLiked</span></strong><span class="koboSpan" id="kobo.74.1"> state when clicked, displaying </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">Like</span></strong><span class="koboSpan" id="kobo.76.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">Unlike</span></strong><span class="koboSpan" id="kobo.78.1"> based on the current value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">isLiked</span></strong><span class="koboSpan" id="kobo.80.1">.</span></p>
<p><span class="koboSpan" id="kobo.81.1">While this code works, it violates the SRP. </span><span class="koboSpan" id="kobo.81.2">It’s doing three separate things: fetching data, displaying the blog post, and handling the like functionality. </span><span class="koboSpan" id="kobo.81.3">Instead, let’s refactor it into smaller, single-responsibility components:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
const useFetchPost = (id: string): PostType =&gt; {
  const [post, setPost] = useState&lt;PostType&gt;(EmptyBlogPost);
  useEffect(() =&gt; {
    fetchPostById(id).then((post) =&gt; setPost(post));
  }, [id]);
  return post;
};
const LikeButton: React.FC = () =&gt; {
  const [isLiked, setIsLiked] = useState(false);
  const handleClick = () =&gt; {
    setIsLiked(!isLiked);
  };
  return &lt;button onClick={handleClick}&gt;
      {isLiked ? </span><span class="koboSpan" id="kobo.82.2">"Unlike" : "Like"}
  &lt;/button&gt;;
};
const BlogPost = ({ id }: { id: string }) =&gt; {
  const post = useFetchPost(id);
  return (
    &lt;div&gt;
      &lt;h2&gt;{post.title}&lt;/h2&gt;
      &lt;p&gt;{post.summary}&lt;/p&gt;
      &lt;LikeButton /&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.83.1">Here, we’ve refactored </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">BlogPost</span></strong><span class="koboSpan" id="kobo.85.1"> into smaller, single-responsibility components:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">useFetchPost</span></strong><span class="koboSpan" id="kobo.87.1"> is a custom Hook responsible for fetching the blog post data</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">LikeButton</span></strong><span class="koboSpan" id="kobo.89.1"> is a component responsible for handling the like functionality</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">BlogPost</span></strong><span class="koboSpan" id="kobo.91.1"> is now just responsible for rendering the blog post content and </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">LikeButton</span></strong></li>
</ul>
<p><span class="koboSpan" id="kobo.93.1">Each part </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.94.1">has a single responsibility and could be tested and maintained independently, leading to a more manageable code base.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.95.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.96.1">In a real-world application, clicking a </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Like</span></strong><span class="koboSpan" id="kobo.98.1"> button may send an API call to update the database; for example, it could be another </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">fetch</span></strong><span class="koboSpan" id="kobo.100.1"> request that is sent to an endpoint such as https://post.service/post/&lt;id&gt; to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">isLiked</span></strong><span class="koboSpan" id="kobo.102.1"> status.</span></p>
<p><span class="koboSpan" id="kobo.103.1">So, in the first section, we explored the SRP. </span><span class="koboSpan" id="kobo.103.2">This principle encourages each component to take charge of a single piece of functionality, making our code more maintainable and understandable. </span><span class="koboSpan" id="kobo.103.3">Here, we applied this principle to break down large, monolithic components into smaller, more manageable pieces.</span></p>
<p><span class="koboSpan" id="kobo.104.1">As we advance further into our design journey, our next section leads us to a principle that intertwines closely with the philosophy of SRP – the don’t repeat yourself princip</span><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.105.1">le.</span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.106.1">Don’t repeat yourself</span></h1>
<p><span class="koboSpan" id="kobo.107.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">don’t repeat yourself</span></strong><span class="koboSpan" id="kobo.109.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.110.1">DRY</span></strong><span class="koboSpan" id="kobo.111.1">) principle is a fundamental concept in software development </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.112.1">that aims to reduce repetition within the code. </span><span class="koboSpan" id="kobo.112.2">Following this principle leads to better maintainability, readability, and testability, and can prevent bugs that occur due to the duplication of logic.</span></p>
<p><span class="koboSpan" id="kobo.113.1">Let’s say that you have a shopping website, and you want to display a list of products and the user’s cart side by side, something like this:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.114.1"><img alt="Figure 4.1: The product list page" src="image/B31103_04_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.115.1">Figure 4.1: The product list page</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.116.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">ProductList</span></strong><span class="koboSpan" id="kobo.118.1"> component </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.119.1">will display the product’s image, name, and price, with an </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Add to Cart</span></strong><span class="koboSpan" id="kobo.121.1"> button, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Cart</span></strong><span class="koboSpan" id="kobo.123.1"> component will display a list of cart items with a </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">Remove from </span></strong><strong class="bold"><span class="koboSpan" id="kobo.125.1">Cart</span></strong><span class="koboSpan" id="kobo.126.1"> button.</span></p>
<p><span class="koboSpan" id="kobo.127.1">A naive implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">ProductList</span></strong><span class="koboSpan" id="kobo.129.1"> might look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
type Product = {
  id: string;
  name: string;
  image: string;
  price: number;
};
const ProductList = ({
  products,
  addToCart,
}: {
  products: Product[];
  addToCart: (id: string) =&gt; void;
}) =&gt; (
  &lt;div&gt;
    &lt;h2&gt;Product List&lt;/h2&gt;
    {products.map((product) =&gt; (
      &lt;div key={product.id} className="product"&gt;
        &lt;img src={product.image} alt={product.name} /&gt;
        &lt;div&gt;
          &lt;h2&gt;{product.name}&lt;/h2&gt;
          &lt;p&gt;${product.price}&lt;/p&gt;
          &lt;button onClick={() =&gt; addToCart(product.id)}&gt;Add to Cart
           &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    ))}
  &lt;/div&gt;
);
export default ProductList;</span></pre> <p><span class="koboSpan" id="kobo.131.1">This functional component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">ProductList</span></strong><span class="koboSpan" id="kobo.133.1"> accepts two props: </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">products</span></strong><span class="koboSpan" id="kobo.135.1"> (an array of product objects) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">addToCart</span></strong><span class="koboSpan" id="kobo.137.1"> (a function used to add a product to a shopping cart).</span></p>
<p><span class="koboSpan" id="kobo.138.1">Each product object is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">Product</span></strong><span class="koboSpan" id="kobo.140.1"> type, which has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">id</span></strong><span class="koboSpan" id="kobo.142.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">name</span></strong><span class="koboSpan" id="kobo.144.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">image</span></strong><span class="koboSpan" id="kobo.146.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">price</span></strong><span class="koboSpan" id="kobo.148.1"> properties.</span></p>
<p><span class="koboSpan" id="kobo.149.1">The component </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.150.1">maps over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">products</span></strong><span class="koboSpan" id="kobo.152.1"> array and renders a </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">div</span></strong><span class="koboSpan" id="kobo.154.1"> for each product, including an image, product name, price, and an </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">Add to Cart</span></strong><span class="koboSpan" id="kobo.156.1"> button. </span><span class="koboSpan" id="kobo.156.2">When the </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">Add to Cart</span></strong><span class="koboSpan" id="kobo.158.1"> button is clicked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">addToCart</span></strong><span class="koboSpan" id="kobo.160.1"> function is invoked with the corresponding product’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">id</span></strong><span class="koboSpan" id="kobo.162.1"> prop as an argument.</span></p>
<p><span class="koboSpan" id="kobo.163.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Cart</span></strong><span class="koboSpan" id="kobo.165.1"> component has a similar structure, as you can imagine; it requires a list of items and renders a button with the text </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Remove from Cart</span></strong><span class="koboSpan" id="kobo.167.1">, and a callback function for the user to invoke:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
const Cart = ({
  cartItems,
  removeFromCart,
}: {
  cartItems: Product[];
  removeFromCart: (id: string) =&gt; void;
}) =&gt; (
  &lt;div&gt;
    &lt;h2&gt;Shopping Cart&lt;/h2&gt;
    {cartItems.map((item) =&gt; (
      &lt;div key={item.id} className="product"&gt;
        &lt;img src={item.image} alt={item.name} /&gt;
        &lt;div&gt;
          &lt;h2&gt;{item.name}&lt;/h2&gt;
          &lt;p&gt;${item.price}&lt;/p&gt;
          &lt;button onClick={() =&gt; removeFromCart(item.id)}&gt;
            Remove from Cart
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    ))}
  &lt;/div&gt;
);</span></pre> <p><span class="koboSpan" id="kobo.169.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Cart</span></strong><span class="koboSpan" id="kobo.171.1"> component iterates over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">cartItems</span></strong><span class="koboSpan" id="kobo.173.1"> array and, for each item, it renders a </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">div</span></strong><span class="koboSpan" id="kobo.175.1"> with the</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.176.1"> item’s image, name, price, and a </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">Remove from Cart</span></strong><span class="koboSpan" id="kobo.178.1"> button. </span><span class="koboSpan" id="kobo.178.2">When this button is clicked, it invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">removeFromCart</span></strong><span class="koboSpan" id="kobo.180.1"> function with the respective item’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">id</span></strong><span class="koboSpan" id="kobo.182.1"> prop as an argument, signifying that this item should be removed from the cart.</span></p>
<p><span class="koboSpan" id="kobo.183.1">To reduce the duplication and make each component only do one thing, we can extract a </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">LineItem</span></strong><span class="koboSpan" id="kobo.185.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
import { Product } from "./types";
const LineItem = ({
  product,
  performAction,
  label,
}: {
  product: Product;
  performAction: (id: string) =&gt; void;
  label: string;
}) =&gt; {
  const { id, image, name, price } = product;
  return (
    &lt;div key={id} className="product"&gt;
      &lt;img src={image} alt={name} /&gt;
      &lt;div&gt;
        &lt;h2&gt;{name}&lt;/h2&gt;
        &lt;p&gt;${price}&lt;/p&gt;
        &lt;button onClick={() =&gt; performAction(id)}&gt;{label}&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default LineItem;</span></pre> <p><span class="koboSpan" id="kobo.187.1">We defined a</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.188.1"> functional component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">LineItem</span></strong><span class="koboSpan" id="kobo.190.1"> that renders a product’s details and a button. </span><span class="koboSpan" id="kobo.190.2">It accepts properties for </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">product</span></strong><span class="koboSpan" id="kobo.192.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">performAction</span></strong><span class="koboSpan" id="kobo.194.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">label</span></strong><span class="koboSpan" id="kobo.196.1">, and uses destructuring to extract the necessary values. </span><span class="koboSpan" id="kobo.196.2">The component returns JSX code to display the product’s information and trigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">performAction</span></strong><span class="koboSpan" id="kobo.198.1"> function when the button is clicked.</span></p>
<p><span class="koboSpan" id="kobo.199.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">ProductList</span></strong><span class="koboSpan" id="kobo.201.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Cart</span></strong><span class="koboSpan" id="kobo.203.1"> components, you can simply pass in different props to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">LineItem</span></strong><span class="koboSpan" id="kobo.205.1"> component to reduce the duplication we had before:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
const ProductList = ({
  products,
  addToCart,
}: {
  products: Product[];
  addToCart: (id: string) =&gt; void;
}) =&gt; (
  &lt;div&gt;
    &lt;h2&gt;Product List&lt;/h2&gt;
    {products.map((product) =&gt; (
      &lt;LineItem
        key={product.id}
        product={product}
        performAction={addToCart}
        label="Add to Cart"
      /&gt;
    ))}
  &lt;/div&gt;
);</span></pre> <p><span class="koboSpan" id="kobo.207.1">The new </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">ProductList</span></strong><span class="koboSpan" id="kobo.209.1"> component receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">products</span></strong><span class="koboSpan" id="kobo.211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">addToCart</span></strong><span class="koboSpan" id="kobo.213.1"> as props. </span><span class="koboSpan" id="kobo.213.2">It renders a list of products, with </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.214.1">each product having an </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">Add to </span></strong><strong class="bold"><span class="koboSpan" id="kobo.216.1">Cart</span></strong><span class="koboSpan" id="kobo.217.1"> button.</span></p>
<p><span class="koboSpan" id="kobo.218.1">Similarly, for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">Cart</span></strong><span class="koboSpan" id="kobo.220.1"> component, we’ll have a similar structure that reuses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">LineItem</span></strong><span class="koboSpan" id="kobo.222.1"> component for rendering the product details (</span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">image</span></strong><span class="koboSpan" id="kobo.224.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">name</span></strong><span class="koboSpan" id="kobo.226.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">price</span></strong><span class="koboSpan" id="kobo.228.1">):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
const Cart = ({
  cartItems,
  removeFromCart,
}: {
  cartItems: Product[];
  removeFromCart: (id: string) =&gt; void;
}) =&gt; (
  &lt;div&gt;
    &lt;h2&gt;Shopping Cart&lt;/h2&gt;
    {cartItems.map((item) =&gt; (
      &lt;LineItem
        key={item.id}
        product={item}
        performAction={removeFromCart}
        label="Remove from Cart"
      /&gt;
    ))}
  &lt;/div&gt;
);</span></pre> <p><span class="koboSpan" id="kobo.230.1">This is a </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.231.1">more maintainable and reusable approach by following the DRY principle. </span><span class="koboSpan" id="kobo.231.2">There is less chance of introducing bugs because changes only need to be made in one place, and if we must add new features of </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">LineItem</span></strong><span class="koboSpan" id="kobo.233.1">, we only need to touch a single component.</span></p>
<p><span class="koboSpan" id="kobo.234.1">In this section, we dove into the DRY principle. </span><span class="koboSpan" id="kobo.234.2">It guided us to eliminate redundancy in our code, reducing the likelihood of inconsistencies and bugs. </span><span class="koboSpan" id="kobo.234.3">By avoiding code duplication, we’ve simplified maintenance as changes in functionality need to be addressed in a single place. </span><span class="koboSpan" id="kobo.234.4">As we refined our understanding of DRY, we prepared ourselves to enhance our component structure using a key concept in React – com</span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.235.1">position.</span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.236.1">Using composition</span></h1>
<p><span class="koboSpan" id="kobo.237.1">In React, </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">composition</span></strong><span class="koboSpan" id="kobo.239.1"> is a</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.240.1"> natural pattern of the component model. </span><span class="koboSpan" id="kobo.240.2">For instance, JSX’s markup language syntax enables us to pair a </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">div</span></strong><span class="koboSpan" id="kobo.242.1"> with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">h2</span></strong><span class="koboSpan" id="kobo.244.1"> tag seamlessly, without the need to incorporate anything new.</span></p>
<p><span class="koboSpan" id="kobo.245.1">The custom component is nothing more special than the built-in ones like a </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">div</span></strong><span class="koboSpan" id="kobo.247.1">; you can use your </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Cart</span></strong><span class="koboSpan" id="kobo.249.1"> component with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">div</span></strong><span class="koboSpan" id="kobo.251.1"> just as you can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">p</span></strong><span class="koboSpan" id="kobo.253.1"> tag with it. </span><span class="koboSpan" id="kobo.253.2">This pattern enables more straightforward reuse of components, which can contribute to cleaner and more maintainable code.</span></p>
<p><span class="koboSpan" id="kobo.254.1">Let’s consider</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.255.1"> an example. </span><span class="koboSpan" id="kobo.255.2">Suppose we’re building a </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">UserDashboard</span></strong><span class="koboSpan" id="kobo.257.1"> component that displays user information. </span><span class="koboSpan" id="kobo.257.2">The profile includes an avatar, a name, and a list of the user’s friends and the latest posts. </span><span class="koboSpan" id="kobo.257.3">Here’s how it might look:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
type User = {
  name: string;
  avatar: string;
  friends: string[];
};
type Post = {
  author: string;
  summary: string;
};
type UserDashboardProps = {
  user: User;
  posts: Post[];
};
function UserDashboard({ user, posts }: UserDashboardProps) {
  return (
    &lt;div&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;img src={user.avatar} alt="profile" /&gt;
      &lt;h2&gt;Friends&lt;/h2&gt;
      &lt;ul&gt;
        {user.friends.map((friend) =&gt; (
          &lt;li key={friend}&gt;{friend}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;h2&gt;Latest Posts&lt;/h2&gt;
      {posts.map((post) =&gt; (
        &lt;div key={post.author}&gt;
          &lt;h3&gt;{post.author}&lt;/h3&gt;
          &lt;p&gt;{post.summary}&lt;/p&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}
export default UserDashboard;</span></pre> <p><span class="koboSpan" id="kobo.259.1">In this </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.260.1">simplified example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">UserDashboard</span></strong><span class="koboSpan" id="kobo.262.1"> is responsible for rendering the user’s profile, a list of friends, and the latest posts, which violates the SRP. </span><span class="koboSpan" id="kobo.262.2">We can break it down into smaller components, each responsible for one thing.</span></p>
<p><span class="koboSpan" id="kobo.263.1">First, we can extract the profile-related JSX into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">UserProfile</span></strong><span class="koboSpan" id="kobo.265.1"> component that displays the user’s profile, which includes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">h1</span></strong><span class="koboSpan" id="kobo.267.1"> tag (the user’s name) and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">avatar</span></strong><span class="koboSpan" id="kobo.269.1"> image:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
const UserProfile = ({ user }: { user: User }) =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;img src={user.avatar} alt="profile" /&gt;
    &lt;/&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.271.1">Next, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">FriendList</span></strong><span class="koboSpan" id="kobo.273.1"> component that displays a list of the user’s friends; it includes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">h2</span></strong><span class="koboSpan" id="kobo.275.1"> tag and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">friends</span></strong><span class="koboSpan" id="kobo.277.1"> list:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
const FriendList = ({ friends }: { friends: string[] }) =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Friends&lt;/h2&gt;
      &lt;ul&gt;
        {friends.map((friend) =&gt; (
          &lt;li key={friend}&gt;{friend}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.279.1">Finally, we </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.280.1">create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">PostList</span></strong><span class="koboSpan" id="kobo.282.1"> component that displays a feed of posts, which includes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">h2</span></strong><span class="koboSpan" id="kobo.284.1"> tag and a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">posts</span></strong><span class="koboSpan" id="kobo.286.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
const PostList = ({ posts }: { posts: Post[] }) =&gt; {
  return (
    &lt;&gt;
      &lt;h2&gt;Latest Posts&lt;/h2&gt;
      {posts.map((post) =&gt; (
        &lt;div key={post.author}&gt;
          &lt;h3&gt;{post.author}&lt;/h3&gt;
          &lt;p&gt;{post.summary}&lt;/p&gt;
        &lt;/div&gt;
      ))}
    &lt;/&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.288.1">Now, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">UserDashboard</span></strong><span class="koboSpan" id="kobo.290.1"> component becomes simpler and delegates its responsibilities </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.291.1">to these smaller components:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.292.1">
function UserDashboard({ user, posts }: UserDashboardProps) {
  return (
    &lt;div&gt;
      &lt;UserProfile user={user} /&gt;
      &lt;FriendList friends={user.friends} /&gt;
      &lt;PostList posts={posts} /&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.293.1">The refactored version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">UserDashboard</span></strong><span class="koboSpan" id="kobo.295.1"> component</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.296.1"> is superior due to several reasons:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.297.1">Separation of Concerns</span></strong><span class="koboSpan" id="kobo.298.1">: By separating different parts of the component (user profile, friend list, and post list) into their own components (</span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">UserProfile</span></strong><span class="koboSpan" id="kobo.300.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">FriendList</span></strong><span class="koboSpan" id="kobo.302.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">PostList</span></strong><span class="koboSpan" id="kobo.304.1">), you ensure that each component is responsible for one task. </span><span class="koboSpan" id="kobo.304.2">This improves the maintainability of the code.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">Readability</span></strong><span class="koboSpan" id="kobo.306.1">: The new version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">UserDashboard</span></strong><span class="koboSpan" id="kobo.308.1"> is easier to read and understand. </span><span class="koboSpan" id="kobo.308.2">It becomes immediately clear what this component is rendering: a user profile, a list of friends, and a list of posts. </span><span class="koboSpan" id="kobo.308.3">There’s no need to read through details about how each of these parts is rendered.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.309.1">Reusability</span></strong><span class="koboSpan" id="kobo.310.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">UserProfile</span></strong><span class="koboSpan" id="kobo.312.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">FriendList</span></strong><span class="koboSpan" id="kobo.314.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">PostList</span></strong><span class="koboSpan" id="kobo.316.1"> components can now be reused in other parts of the application if needed, thereby promoting code reuse and reducing redundancy.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.317.1">Testability</span></strong><span class="koboSpan" id="kobo.318.1">: Smaller, single-responsibility components are easier to test, as they tend to have less complex interactions and dependencies. </span><span class="koboSpan" id="kobo.318.2">We’ll cover the testing and testability in </span><a href="B21103_05.xhtml#_idTextAnchor124"><i class="italic"><span class="koboSpan" id="kobo.319.1">Chapter 5</span></i></a><span class="koboSpan" id="kobo.320.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.321.1">This is a </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.322.1">simple example, but it illustrates the basic idea of composition in React. </span><span class="koboSpan" id="kobo.322.2">Composition can become more complex as you deal with components that have their own state or logic, but the core principle remains the same: building larger components from smaller, reusable parts.</span></p>
<p><span class="koboSpan" id="kobo.323.1">This section brought us to the power of composition in React. </span><span class="koboSpan" id="kobo.323.2">With composition, we could efficiently structure and combine our components, creating complex user interfaces from simpler, single-responsibility components. </span><span class="koboSpan" id="kobo.323.3">We observed how composition allowed us to fully leverage the principles of SRP and DRY, leading to the creation of sophisticated UIs that remain easy to understand, tes</span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.324.1">t, and maintain.</span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.325.1">Combining component design principles</span></h1>
<p><span class="koboSpan" id="kobo.326.1">We’ve </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.327.1">separately analyzed the principles of single responsibility, don’t repeat yourself, and composition. </span><span class="koboSpan" id="kobo.327.2">However, in practical coding scenarios, things can get intricate, necessitating the simultaneous application of multiple principles to enhance the readability and maintainability of the code.</span></p>
<p><span class="koboSpan" id="kobo.328.1">Let’s consider an</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.329.1"> example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Page</span></strong><span class="koboSpan" id="kobo.331.1"> component, which might have many responsibilities such as managing the state and behavior of a header, sidebar, and main content area. </span><span class="koboSpan" id="kobo.331.2">Also, there are a bunch of props for configuring each of these sections. </span><span class="koboSpan" id="kobo.331.3">It’s typical to encounter such code when individuals simply replicate the existing code base without much consideration or critical thinking; so the prop list grows as new features are added.</span></p>
<p><span class="koboSpan" id="kobo.332.1">Here is a simplified example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
import React from "react";
type PageProps = {
  headerTitle: string;
  headerSubtitle: string;
  sidebarLinks: string[];
  isLoading: boolean;
  mainContent: React.ReactNode;
  onHeaderClick: () =&gt; void;
  onSidebarLinkClick: (link: string) =&gt; void;
};
function Page({
  headerTitle,
  headerSubtitle,
  sidebarLinks,
  mainContent,
  isLoading,
  onHeaderClick,
  onSidebarLinkClick,
}: PageProps) {
  return (
    &lt;div&gt;
      &lt;header onClick={onHeaderClick}&gt;
        &lt;h1&gt;{headerTitle}&lt;/h1&gt;
        &lt;h2&gt;{headerSubtitle}&lt;/h2&gt;
      &lt;/header&gt;
      &lt;aside&gt;
        &lt;ul&gt;
          {sidebarLinks.map((link) =&gt; (
            &lt;li key={link} onClick={() =&gt; onSidebarLinkClick(link)}&gt;
              {link}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/aside&gt;
      {!isLoading &amp;&amp; &lt;main&gt;{mainContent}&lt;/main&gt;}
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.334.1">We defined a </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">Page</span></strong><span class="koboSpan" id="kobo.336.1"> component; the component uses the preceding props to render a page with a clickable header, a sidebar containing clickable links, and a main content section. </span><span class="koboSpan" id="kobo.336.2">The component expects an</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.337.1"> object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">PageProps</span></strong><span class="koboSpan" id="kobo.339.1"> type as its properties.</span></p>
<p><span class="koboSpan" id="kobo.340.1">Let’s take a </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.341.1">closer look inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">PageProps</span></strong><span class="koboSpan" id="kobo.343.1">:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">headerTitle</span></strong><span class="koboSpan" id="kobo.345.1">: This string will be displayed as the main title in the page’s header</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">headerSubtitle</span></strong><span class="koboSpan" id="kobo.347.1">: This string will be displayed as the subtitle in the page’s header</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">sidebarLinks</span></strong><span class="koboSpan" id="kobo.349.1">: This is an array of strings, where each string represents a link that will be displayed in the page’s sidebar</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">isLoading</span></strong><span class="koboSpan" id="kobo.351.1">: This is a flag to determine whether the main content is ready or not</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">mainContent</span></strong><span class="koboSpan" id="kobo.353.1">: This can be any valid React node (a component, an element, null, etc.) that represents the main content of the page</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">onHeaderClick</span></strong><span class="koboSpan" id="kobo.355.1">: This function will be executed when the header section of the page is clicked</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">onSidebarLinkClick</span></strong><span class="koboSpan" id="kobo.357.1">: This function will be executed when any sidebar link is clicked. </span><span class="koboSpan" id="kobo.357.2">The function will receive the clicked link as an argument</span></li>
</ul>
<p><span class="koboSpan" id="kobo.358.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Page</span></strong><span class="koboSpan" id="kobo.360.1"> component has multiple responsibilities, and it has a long list of props that could make it hard to work with. </span><span class="koboSpan" id="kobo.360.2">A long prop list – when a component has over five props – typically signals a need for component breakdown. </span><span class="koboSpan" id="kobo.360.3">This is because remembering the purpose of each prop can be challenging, and it also increases the likelihood of passing the wrong prop or misordering them.</span></p>
<p><span class="koboSpan" id="kobo.361.1">We can group the props based on how they are used. </span><span class="koboSpan" id="kobo.361.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">headerTitle</span></strong><span class="koboSpan" id="kobo.363.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">headerSubtitle</span></strong><span class="koboSpan" id="kobo.365.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">onHeaderClick</span></strong><span class="koboSpan" id="kobo.367.1"> props can be split out into a group, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">isLoading</span></strong><span class="koboSpan" id="kobo.369.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">mainContent</span></strong><span class="koboSpan" id="kobo.371.1"> belong to another group.</span></p>
<p><span class="koboSpan" id="kobo.372.1">Extracting a small part of the large component is always a good starting point. </span><span class="koboSpan" id="kobo.372.2">Note that there might be many ways to do the extracting; if the information looks related to each other, we can group them and create a new component for that group of data. </span><span class="koboSpan" id="kobo.372.3">For example, we</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.373.1"> can extract a </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">Header</span></strong><span class="koboSpan" id="kobo.375.1"> component first:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
type HeaderProps = {
  headerTitle: string;
  headerSubtitle: string;
  onHeaderClick: () =&gt; void;
};
const Header = ({
  headerTitle,
  headerSubtitle,
  onHeaderClick,
}: HeaderProps) =&gt; {
  return (
    &lt;header onClick={onHeaderClick}&gt;
      &lt;h1&gt;{headerTitle}&lt;/h1&gt;
      &lt;h2&gt;{headerSubtitle}&lt;/h2&gt;
    &lt;/header&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.377.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">Header</span></strong><span class="koboSpan" id="kobo.379.1"> component in React takes three props – </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">headerTitle</span></strong><span class="koboSpan" id="kobo.381.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">headerSubtitle</span></strong><span class="koboSpan" id="kobo.383.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">onHeaderClick</span></strong><span class="koboSpan" id="kobo.385.1"> – and renders a header with the provided title and subtitle. </span><span class="koboSpan" id="kobo.385.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">onHeaderClick</span></strong><span class="koboSpan" id="kobo.387.1"> prop is then called when the header is clicked.</span></p>
<p><span class="koboSpan" id="kobo.388.1">Now, because </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">title</span></strong><span class="koboSpan" id="kobo.390.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">subtitle</span></strong><span class="koboSpan" id="kobo.392.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">onClick</span></strong><span class="koboSpan" id="kobo.394.1"> callback are already in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">Header</span></strong><span class="koboSpan" id="kobo.396.1"> component, we </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.397.1">don’t need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">header</span></strong><span class="koboSpan" id="kobo.399.1"> prefix in the prop names. </span><span class="koboSpan" id="kobo.399.2">Let’s rename these props:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
type HeaderProps = {
  title: string;
  subtitle: string;
  onClick: () =&gt; void;
};
const Header = ({
  title,
  subtitle,
  onClick,
}: HeaderProps) =&gt; {
  return (
    &lt;header onClick={onClick}&gt;
      &lt;h1&gt;{title}&lt;/h1&gt;
      &lt;h2&gt;{subtitle}&lt;/h2&gt;
    &lt;/header&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.401.1">It’s now much clearer regarding what </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Header</span></strong><span class="koboSpan" id="kobo.403.1"> does – it accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">title</span></strong><span class="koboSpan" id="kobo.405.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">subtitle</span></strong><span class="koboSpan" id="kobo.407.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">onClick</span></strong><span class="koboSpan" id="kobo.409.1"> and doesn’t need to know anything beyond that. </span><span class="koboSpan" id="kobo.409.2">This extraction also increases the reusability of </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Header</span></strong><span class="koboSpan" id="kobo.411.1">, meaning we might reuse the component in a different place.</span></p>
<p><span class="koboSpan" id="kobo.412.1">Now, we can extract a </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Sidebar</span></strong><span class="koboSpan" id="kobo.414.1"> component with the same approach:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
type SidebarProps = {
  links: string[];
  onLinkClick: (link: string) =&gt; void;
};
const Sidebar = ({ links, onLinkClick }: SidebarProps) =&gt; {
  return (
    &lt;aside&gt;
      &lt;ul&gt;
        {links.map((link) =&gt; (
          &lt;li key={link} onClick={() =&gt; onLinkClick(link)}&gt;
            {link}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/aside&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.416.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">Sidebar</span></strong><span class="koboSpan" id="kobo.418.1"> component</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.419.1"> accepts an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">links</span></strong><span class="koboSpan" id="kobo.421.1"> and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">onLinkClick</span></strong><span class="koboSpan" id="kobo.423.1"> function as props and generates a list of clickable items from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">links</span></strong><span class="koboSpan" id="kobo.425.1"> array. </span><span class="koboSpan" id="kobo.425.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">onLinkClick</span></strong><span class="koboSpan" id="kobo.427.1"> function is triggered when a link is clicked, passing the clicked link as an argument.</span></p>
<p><span class="koboSpan" id="kobo.428.1">After we extracted </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Header</span></strong><span class="koboSpan" id="kobo.430.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Sidebar</span></strong><span class="koboSpan" id="kobo.432.1">, the only thing left in </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">Page</span></strong><span class="koboSpan" id="kobo.434.1"> is the part related to the main content. </span><span class="koboSpan" id="kobo.434.2">We can apply the same approach for the main content, extracting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">Main</span></strong><span class="koboSpan" id="kobo.436.1"> component with the simple JSX fragment, as in the following code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.437.1">
type MainProps = {
  isLoading: boolean;
  content: React.ReactNode;
};
const Main = ({ isLoading, content }: MainProps) =&gt; {
  return &lt;&gt;{!isLoading &amp;&amp; &lt;main&gt;{content}&lt;/main&gt;}&lt;/&gt;;
};</span></pre> <p><span class="koboSpan" id="kobo.438.1">As we extracted</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.439.1"> most of the content out of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">Page</span></strong><span class="koboSpan" id="kobo.441.1"> component, we can now use these simple components without changing the public interface of </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Page</span></strong><span class="koboSpan" id="kobo.443.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
function Page({
  headerTitle,
  headerSubtitle,
  sidebarLinks,
  mainContent,
  isLoading,
  onHeaderClick,
  onSidebarLinkClick,
}: PageProps) {
  return (
    &lt;div&gt;
      &lt;Header
        title={headerTitle}
        subtitle={headerSubtitle}
        onClick={onHeaderClick}
      /&gt;
      &lt;Sidebar links={sidebarLinks} onLinkClick={onSidebarLinkClick} 
       /&gt;
      &lt;Main isLoading={isLoading} content={mainContent} /&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.445.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">Page</span></strong><span class="koboSpan" id="kobo.447.1"> component</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.448.1"> arranges the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Header</span></strong><span class="koboSpan" id="kobo.450.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">Sidebar</span></strong><span class="koboSpan" id="kobo.452.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">Main</span></strong><span class="koboSpan" id="kobo.454.1"> components and takes in several props. </span><span class="koboSpan" id="kobo.454.2">It then passes these props to the respective child components – </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">Header</span></strong><span class="koboSpan" id="kobo.456.1"> gets the title, subtitle, and a click handler; </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Sidebar</span></strong><span class="koboSpan" id="kobo.458.1"> receives a list of links and a click handler; and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">Main</span></strong><span class="koboSpan" id="kobo.460.1"> component gets the main content and a loading state.</span></p>
<p><span class="koboSpan" id="kobo.461.1">The refactored </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">Page</span></strong><span class="koboSpan" id="kobo.463.1"> looks much nicer, but it’s not perfect. </span><span class="koboSpan" id="kobo.463.2">Let’s consider a common issue with the current code. </span><span class="koboSpan" id="kobo.463.3">What happens if we need to pass in new props to </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">Sidebar</span></strong><span class="koboSpan" id="kobo.465.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">Main</span></strong><span class="koboSpan" id="kobo.467.1">?</span></p>
<p><span class="koboSpan" id="kobo.468.1">To accept the new props passed into </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Sidebar</span></strong><span class="koboSpan" id="kobo.470.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">Main</span></strong><span class="koboSpan" id="kobo.472.1">, we need to extend the prop list, which already has seven props. </span><span class="koboSpan" id="kobo.472.2">For people who use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Page</span></strong><span class="koboSpan" id="kobo.474.1"> component, as more props are added, they will have to remember even more props, which wouldn’t be a good experience (not to mention the additional testing efforts because of these props).</span></p>
<p><span class="koboSpan" id="kobo.475.1">Instead of accepting these detailed descriptions to customize </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">Header</span></strong><span class="koboSpan" id="kobo.477.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Sidebar</span></strong><span class="koboSpan" id="kobo.479.1">, we can pass in an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">Header</span></strong><span class="koboSpan" id="kobo.481.1"> and then just plug it into the correct slot (to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Header</span></strong><span class="koboSpan" id="kobo.483.1"> component):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
type PageProps = {
  header: React.ReactNode;
  sidebarLinks: string[];
  isLoading: boolean;
  mainContent: React.ReactNode;
  onSidebarLinkClick: (link: string) =&gt; void;
};
function Page({
  header,
  sidebarLinks,
  mainContent,
  isLoading,
  onSidebarLinkClick,
}: PageProps) {
  return (
    &lt;div&gt;
      {header}
      &lt;Sidebar links={sidebarLinks}
       onLinkClick={onSidebarLinkClick} /&gt;
      &lt;Main isLoading={isLoading} content={mainContent} /&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.485.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Page</span></strong><span class="koboSpan" id="kobo.487.1"> component </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.488.1">accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">header</span></strong><span class="koboSpan" id="kobo.490.1"> prop (along with a list of sidebar links, a loading state, main content, and a link click handler as props) and renders the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Header</span></strong><span class="koboSpan" id="kobo.492.1"> component directly. </span><span class="koboSpan" id="kobo.492.2">That means we can pass in any </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">header</span></strong><span class="koboSpan" id="kobo.494.1"> instance from outside of </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">Page</span></strong><span class="koboSpan" id="kobo.496.1">.</span></p>
<p><span class="koboSpan" id="kobo.497.1">Similarly, we can do the same for </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Sidebar</span></strong><span class="koboSpan" id="kobo.499.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">Main</span></strong><span class="koboSpan" id="kobo.501.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
type PageProps = {
  header: React.ReactNode;
  sidebar: React.ReactNode;
  main: React.ReactNode;
};
function Page({ header, sidebar, main }: PageProps) {
  return (
    &lt;div&gt;
      {header}
      {sidebar}
      {main}
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.503.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Page</span></strong><span class="koboSpan" id="kobo.505.1"> component accepts three props – </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">header</span></strong><span class="koboSpan" id="kobo.507.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">sidebar</span></strong><span class="koboSpan" id="kobo.509.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">main</span></strong><span class="koboSpan" id="kobo.511.1"> – with each expected to be a </span><strong class="bold"><span class="koboSpan" id="kobo.512.1">ReactNode</span></strong><span class="koboSpan" id="kobo.513.1">, a type </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.514.1">that includes practically anything that can be rendered in</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.515.1"> React (strings, elements, arrays, etc.). </span><span class="koboSpan" id="kobo.515.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">Page</span></strong><span class="koboSpan" id="kobo.517.1"> component simply renders these three props in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">div</span></strong><span class="koboSpan" id="kobo.519.1"> in the order they are provided, effectively forming a simple page layout with a header, a sidebar, and a main section.</span></p>
<p><span class="koboSpan" id="kobo.520.1">You can then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">Page</span></strong><span class="koboSpan" id="kobo.522.1"> in the most flexible way – you can pass in a fully customized </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">Header</span></strong><span class="koboSpan" id="kobo.524.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Sidebar</span></strong><span class="koboSpan" id="kobo.526.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">Main</span></strong><span class="koboSpan" id="kobo.528.1"> as parameters into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">Page</span></strong><span class="koboSpan" id="kobo.530.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
const MyPage = () =&gt; {
  return (
    &lt;Page
      header={
        &lt;Header
          title="My application"
          subtitle="Product page"
          onClick={() =&gt; console.log("toggle header")}
        /&gt;
      }
      sidebar={
        &lt;Sidebar
          links={["Home", "About", "Contact"]}
          onLinkClick={() =&gt; console.log("toggle sidebar")}
        /&gt;
      }
      main={&lt;Main isLoading={false}
            content={&lt;div&gt;The main&lt;/div&gt;} /&gt;}
    /&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.532.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">MyPage</span></strong><span class="koboSpan" id="kobo.534.1"> component renders a </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">Page</span></strong><span class="koboSpan" id="kobo.536.1"> component, passing in </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Header</span></strong><span class="koboSpan" id="kobo.538.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">Sidebar</span></strong><span class="koboSpan" id="kobo.540.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">Main</span></strong><span class="koboSpan" id="kobo.542.1"> components as props, while click events on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">Header</span></strong><span class="koboSpan" id="kobo.544.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">Sidebar</span></strong><span class="koboSpan" id="kobo.546.1"> components will log certain messages to the console.</span></p>
<p><span class="koboSpan" id="kobo.547.1">Note that here you </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.548.1">can pass anything into </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">Page</span></strong><span class="koboSpan" id="kobo.550.1"> to define </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">header</span></strong><span class="koboSpan" id="kobo.552.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">sidebar</span></strong><span class="koboSpan" id="kobo.554.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">main</span></strong><span class="koboSpan" id="kobo.556.1">. </span><span class="koboSpan" id="kobo.556.2">Here’s an example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
const MySimplePage = () =&gt; {
  return (
    &lt;Page
      header={
        &lt;h1&gt;A simple header&lt;/h1&gt;
      }
      sidebar={
        &lt;aside&gt;
          &lt;ul&gt;
            &lt;li&gt;Home&lt;/li&gt;
            &lt;li&gt;About&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/aside&gt;
      }
      main={&lt;div&gt;The main content&lt;/div&gt;}
    /&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.558.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">MyPage</span></strong><span class="koboSpan" id="kobo.560.1"> component wraps a </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Page</span></strong><span class="koboSpan" id="kobo.562.1"> component. </span><span class="koboSpan" id="kobo.562.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Page</span></strong><span class="koboSpan" id="kobo.564.1"> component receives three props: </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">header</span></strong><span class="koboSpan" id="kobo.566.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">sidebar</span></strong><span class="koboSpan" id="kobo.568.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">main</span></strong><span class="koboSpan" id="kobo.570.1">, each containing JSX elements that specify what’s to be rendered in each respective section of the page. </span><span class="koboSpan" id="kobo.570.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">header</span></strong><span class="koboSpan" id="kobo.572.1"> prop has a heading, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">sidebar</span></strong><span class="koboSpan" id="kobo.574.1"> prop includes a list with </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">Home</span></strong><span class="koboSpan" id="kobo.576.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">About</span></strong><span class="koboSpan" id="kobo.578.1"> items, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">main</span></strong><span class="koboSpan" id="kobo.580.1"> section contains the main content of the page.</span></p>
<p><span class="koboSpan" id="kobo.581.1">The original </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Page</span></strong><span class="koboSpan" id="kobo.583.1"> component was heavily burdened with a multitude of responsibilities, leading to a long list of props. </span><span class="koboSpan" id="kobo.583.2">This </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.584.1">design presented a </span><strong class="bold"><span class="koboSpan" id="kobo.585.1">prop drilling</span></strong><span class="koboSpan" id="kobo.586.1"> problem, where a large amount of data had to be passed down through multiple layers of components. </span><span class="koboSpan" id="kobo.586.2">This setup was both complex and hard to maintain.</span></p>
<p><span class="koboSpan" id="kobo.587.1">With that, let’s</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.588.1"> review our process of how we applied different principles. </span><span class="koboSpan" id="kobo.588.2">The refactoring process started by breaking down the monolithic </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">Page</span></strong><span class="koboSpan" id="kobo.590.1"> component into smaller, more manageable components – </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">Header</span></strong><span class="koboSpan" id="kobo.592.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">Sidebar</span></strong><span class="koboSpan" id="kobo.594.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">Main</span></strong><span class="koboSpan" id="kobo.596.1"> – using the SRP. </span><span class="koboSpan" id="kobo.596.2">These sub-components were designed to handle their respective responsibilities, thus simplifying their individual prop requirements.</span></p>
<p><span class="koboSpan" id="kobo.597.1">Once these components were extracted, we modified the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Page</span></strong><span class="koboSpan" id="kobo.599.1"> component to accept these sub-components (</span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">Header</span></strong><span class="koboSpan" id="kobo.601.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">Sidebar</span></strong><span class="koboSpan" id="kobo.603.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">Main</span></strong><span class="koboSpan" id="kobo.605.1">) as props using composition. </span><span class="koboSpan" id="kobo.605.2">This approach significantly reduced the prop drilling issue, as each sub-component now receives props directly at the point of usage.</span></p>
<p><span class="koboSpan" id="kobo.606.1">This refactoring exercise streamlined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">Page</span></strong><span class="koboSpan" id="kobo.608.1"> component, resulting in a cleaner, more manageable code base. </span><span class="koboSpan" id="kobo.608.2">It utilized the principles of component composition and single responsibility to solve the pro</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.609.1">p drilling problem effectively.</span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.610.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.611.1">This chapter covered several key principles in designing and developing components in React: the SRP, DRY, and the use of component composition. </span><span class="koboSpan" id="kobo.611.2">Each of these principles provides different strategies for achieving clean, maintainable, and scalable code bases.</span></p>
<p><span class="koboSpan" id="kobo.612.1">By understanding and applying these principles, we can create a solid foundation for our React applications. </span><span class="koboSpan" id="kobo.612.2">These strategies lead to more organized, scalable, and robust code bases, ultimately making our work as developers more effective and enjoyable.</span></p>
<p><span class="koboSpan" id="kobo.613.1">In the next chapter, we’ll start to look into an exciting topic in React applications – testing – and see how good structured tests can protect us from making mistakes while helping us to improve the code quality.</span></p>
</section>


<section class="Content" epub:type="part" id="_idContainer027" role="doc-part">
<h1 id="_idParaDest-70"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1.1">Part 2: Embracing Testing Techniques</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will delve into the significance of testing in frontend development, exploring various testing methodologies and refactoring techniques that will ensure the robustness and maintainability of your React applications.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This part contains the following chapters:</span></p>
<ul>
<li><a href="B21103_05.xhtml#_idTextAnchor124"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Testing in React</span></em></li>
<li><a href="B21103_06.xhtml#_idTextAnchor153"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Exploring Common Refactoring Techniques</span></em></li>
<li><a href="B21103_07.xhtml#_idTextAnchor176"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Introducing Test-Driven Development with React</span></em></li>
</ul>
</section>
</body></html>