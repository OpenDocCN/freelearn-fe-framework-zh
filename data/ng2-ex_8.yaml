- en: Chapter 8.  Some Practical Scenarios
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。一些实际场景
- en: 'With seven chapters under our belt, it should feel nice. What you have learned
    thus far is a direct consequence of the apps we have built in the last few chapters.
    I believe you now have an adequate understanding of the framework, how it works,
    and what it supports. Armed with this knowledge, as soon as we start to build
    some decent size apps, there are some common problems/patterns that will invariably
    surface, such as these:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的带领下已经有了七章，应该感觉不错。到目前为止，你所学到的是我们在过去几章中构建的应用程序的直接结果。我相信你现在对框架有了足够的了解，知道它是如何工作的，以及它支持什么。拥有这些知识，一旦我们开始构建一些相当大的应用程序，一些常见的问题/模式将不可避免地出现，比如这些：
- en: How to authenticate the user and control his/her access (authorize)?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何验证用户并控制他/她的访问（授权）？
- en: How to make sure that the app is performing enough?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保应用程序的性能足够？
- en: My app requires localized content. What do I do?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用程序需要本地化内容。我该怎么办？
- en: What tools can I use to expedite app development?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以使用哪些工具来加快应用程序开发？
- en: I have an Angular 1 app. How do I migrate it?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个Angular 1应用程序。我该如何迁移它？
- en: And some more!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些！
- en: In this chapter, we will try to address such common scenarios and provide some
    working solutions and/or prescriptive guidance to handle such use cases.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试解决这些常见场景，并提供一些可行的解决方案和/或指导方针来处理这些用例。
- en: 'The topics we will cover in this chapter include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: '**Angular seed projects**: You will learn how some seed projects in Angular
    can help us when starting a new engagement.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular种子项目**：您将学习如何在开始新的项目时，一些Angular种子项目可以帮助我们。'
- en: '**Authenticating Angular applications**: This is a common requirement. We look
    at how to support cookie- and token-based Authentication in Angular.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Angular应用程序：这是一个常见的要求。我们将看看如何在Angular中支持基于cookie和令牌的身份验证。
- en: '**Angular performance**: A customary performance section is a must as we try
    to detail what makes Angular 2 performant and things you can do to make your apps
    faster.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular性能**：作为我们试图详细说明Angular 2的性能以及您可以做些什么来使您的应用程序更快的必要性，一个习惯性能部分是必不可少的。'
- en: '**Migrating Angular 1 apps to Angular 2**: Angular 1 and Angular 2 are altogether
    different beasts. In this chapter, you will learn how to gradually migrate an
    Angular 1 app to Angular 2.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将Angular 1应用程序迁移到Angular 2**：Angular 1和Angular 2完全是不同的东西。在本章中，您将学习如何逐步将Angular
    1应用程序迁移到Angular 2。'
- en: Let's start from the beginning!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始！
- en: Building a new app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个新的应用程序
- en: 'Imagine a scenario here: we are building a new application and given the super
    awesomeness of the Angular framework, we have unanimously decided to use Angular.
    Great! What next? Next is the mundane process of setting up the project.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这样一个场景：我们正在构建一个新的应用程序，并且由于Angular框架的超级强大，我们已经一致决定使用Angular。太棒了！接下来呢？接下来是设置项目的平凡过程。
- en: 'Although a mundane activity, it''s still a critical part of any engagement.
    Setting up a new project typically involves:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个平凡的活动，但仍然是任何项目的关键部分。设置新项目通常涉及：
- en: Creating a standard folder structure. This is at times influenced by the server
    framework (such as *RoR*, *ASP.Net*, *Node.js*, and others).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标准的文件夹结构。这有时受服务器框架的影响（如*RoR*，*ASP.Net*，*Node.js*等）。
- en: Adding standard assets to specific folders.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标准资产添加到特定文件夹。
- en: 'Setting up the build, which in case we are developing an Angular 2-based web
    application includes:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置构建，如果我们正在开发基于Angular 2的Web应用程序，则包括：
- en: Compiling/transpiling content if using TypeScript
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用TypeScript，编译/转译内容
- en: Configuring the Module loader
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置模块加载器
- en: Dependency management in terms of framework and third-party components
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖管理，包括框架和第三方组件
- en: Setting up unit/E2E testing
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单元/E2E测试
- en: Configuring builds for different environments such as dev, test, and production.
    Again, this is influenced by the server technology involved.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置不同环境的构建，如开发、测试和生产。同样，这受到所涉及的服务器技术的影响。
- en: Code bundling and minification.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码捆绑和最小化。
- en: There is a lot of stuff to do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情要做。
- en: What if we can short-circuit the overall setup process? This indeed is possible;
    we just need a **seed project** or a **starter site**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够简化整个设置过程会怎么样？这确实是可能的；我们只需要一个**种子项目**或者一个**起始站点**。
- en: Seed projects
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种子项目
- en: As we write this book, Angular 2 has just surfaced. There are a number of *seed
    projects* that can get us started in no time. Some seed projects integrate the
    framework with a specific backend and some only dictate/provide Angular-specific
    content. Some come preconfigured with vendor-specific libraries/frameworks (such
    as *LESS*, *SASS*, *Bootstrap*, and *FontAwesome*) whereas others just provide
    a plain vanilla setup.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们写这本书的时候，Angular 2 刚刚出现。有许多*种子项目*可以让我们立即开始。一些种子项目将框架与特定的后端集成在一起，而另一些只提供 Angular
    特定的内容。有些预先配置了特定供应商的库/框架（如*LESS*、*SASS*、*Bootstrap*和*FontAwesome*），而其他一些只提供了一个简单的设置。
- en: 'Some of the notable seed projects worth exploring are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得探索的著名种子项目包括：
- en: '**Angular 2 Webpack Starter** ([http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)):
    This seed repo serves as an Angular 2 starter for anyone looking to get up and
    running with Angular 2 and TypeScript fast. It uses Webpack (module bundler) to
    build our files and assist with boilerplate. It is a complete build system with
    a substantial number of integrations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 2 Webpack Starter** ([http://bit.ly/ng2webpack](http://bit.ly/ng2webpack))：这个种子存储库是一个
    Angular 2 的起始项目，适用于任何想要快速上手使用 Angular 2 和 TypeScript 的人。它使用 Webpack（模块捆绑器）来构建我们的文件并帮助处理样板。它是一个完整的构建系统，具有大量的集成。'
- en: '**Angular 2 Seed** ([http://bit.ly/ng2seed](http://bit.ly/ng2seed)): Another
    seed project similar to Angular 2 Webpack starter. This seed project uses gulp
    for build automation, and the module bundler system is not as advanced as Webpack.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 2 Seed** ([http://bit.ly/ng2seed](http://bit.ly/ng2seed))：另一个类似于
    Angular 2 Webpack starter 的种子项目。这个种子项目使用 gulp 进行构建自动化，模块捆绑系统不像 Webpack 那样先进。'
- en: '**angular-cli** ([http://bit.ly/ng2-cli](http://bit.ly/ng2-cli)): This is a
    command-line tool created by the Angular team that not only sets up a seed project
    for us but also has scaffolding capabilities. We can generate boilerplate components,
    directives, pipes, and services.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**angular-cli** ([http://bit.ly/ng2-cli](http://bit.ly/ng2-cli))：这是由 Angular
    团队创建的命令行工具，不仅为我们设置了一个种子项目，还具有脚手架功能。我们可以生成样板组件、指令、管道和服务。'
- en: These projects provide a head start when building with Angular.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目在使用 Angular 构建时提供了一个快速起步。
- en: 'If the app is tied to a specific backend stack, we have two choices, which
    are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序与特定的后端堆栈绑定，我们有两个选择，如下所示：
- en: Use one of these seed projects and integrate it with the backend manually.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其中一个种子项目并手动将其与后端集成。
- en: Find a seed project/implementation that does it for us. Angular 2 is relatively
    new, but there is a good chance that such seed projects will come up over time.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一个为我们做这些事情的种子项目/实现。Angular 2 相对较新，但很有可能随着时间的推移会出现这样的种子项目。
- en: This discussion cannot be complete without mentioning tools that go a step further.
    They not only come with a seed implementation but also have scaffolding capabilities
    that make our lives easier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论这些种子项目时，不能不提及更进一步的工具。它们不仅提供了种子实现，还具有脚手架功能，使我们的生活更加轻松。
- en: Seed and scaffolding tools
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种子和脚手架工具
- en: Two of the noteworthy to mention in this space are **Yeoman** and **angular-cli**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域值得一提的两个是**Yeoman**和**angular-cli**。
- en: Yeoman
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Yeoman
- en: 'Yeoman ([http://yeoman.io/](http://yeoman.io/)) is a suite of tools targeted
    toward web application development. It defines a workflow for building modern
    web applications. It consists of:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Yeoman ([http://yeoman.io/](http://yeoman.io/))是一套针对Web应用程序开发的工具。它定义了构建现代Web应用程序的工作流程。它包括：
- en: '**yo**: This is a scaffolding tool used to generate code on-the-fly'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**yo**：这是一个用于即时生成代码的脚手架工具'
- en: '**Grunt/Gulp**: The de facto choices when it comes to building systems on Node'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grunt/Gulp**：在Node上构建系统的事实标准选择'
- en: '**Bower/npm**: Bower is a package manager for the Web and works similarly to
    npm'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bower/npm**：Bower是Web的包管理器，与npm类似'
- en: The scaffolding component of Yeoman is quite interesting. *yo*, as it is named,
    uses the concept of a generator to achieve scaffolding.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Yeoman的脚手架组件非常有趣。*yo*，正如它的名字，使用了生成器的概念来实现脚手架。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Scaffolding is the process of generating a code skeleton that can be built upon.
    Using scaffolding, we can save some initial effort and provide some guidance around
    how the overall structure of any coding artefact should look.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 脚手架是生成可以构建的代码骨架的过程。使用脚手架，我们可以节省一些初始工作，并提供一些关于任何编码工件的整体结构应该如何看起来的指导。
- en: Generators in Yeoman are used to set up the initial seed project, and later
    for individual script generation too. Since Yeoman is not targeted specifically
    towards Angular, there are generators for various client and server stacks. There
    are a number of generators available for Angular 2 with varied configurations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Yeoman中的生成器用于设置初始种子项目，以及后续用于生成单个脚本。由于Yeoman并不专门针对Angular，因此有各种客户端和服务器堆栈的生成器。对于Angular
    2，有许多可用的生成器，具有不同的配置。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Check out [http://bit.ly/yogenerators](http://bit.ly/yogenerators) for an exhaustive
    list of generators supported on Yeoman! You need to filter down to Angular 2 generators
    and select something that works for you. Feel free to experiment with these generators
    and see what best fits your needs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[http://bit.ly/yogenerators](http://bit.ly/yogenerators)以获取Yeoman支持的生成器的详尽列表！您需要筛选出Angular
    2生成器，并选择适合您的内容。随意尝试这些生成器，看看哪个最适合您的需求。
- en: angular-cli
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: angular-cli
- en: A scaffolding tool officially endorsed by the Angular team, **angular-cli**
    works in the same way as Yeoman but specifically targets Angular 2\. Let's try
    it out.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**angular-cli**是Angular团队正式认可的脚手架工具，与Yeoman的工作方式相同，但专门针对Angular 2。让我们试一试。'
- en: 'To install angular-cli, from the command line, run:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装angular-cli，从命令行运行：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then run this set of commands to generate the initial artefacts and build
    the setup for a new project:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行这组命令来生成初始工件并为新项目构建设置：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open the browser at `http://localhost:4200/`, and we have a running app!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:4200/`，我们有一个正在运行的应用程序！
- en: Let's check its scaffolding capabilities too.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来检查它的脚手架能力。
- en: 'To generate a component, we just need to invoke this command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个组件，我们只需要调用这个命令：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It generates a boilerplate implementation for our component *Home*. The tool
    creates a `home` folder inside the `src/app` folder, and adds a number of files
    related to the component. Not only does this save us some mouse clicks and typing
    effort, but also the generated code adheres to the best practices outlined by
    the Angular community. A nice start! Go check out the generated code to understand
    this structure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它为我们的组件*Home*生成了一个样板实现。该工具在`src/app`文件夹内创建了一个`home`文件夹，并添加了一些与组件相关的文件。这不仅节省了我们一些鼠标点击和输入的工作，而且生成的代码符合Angular社区概述的最佳实践。一个不错的开始！去查看生成的代码，了解这个结构。
- en: We just saw component generation using angular-cli, but this tool can also generate
    *directives*, *pipes*, *services*, and *routes*. Look at the tool documentation
    on the GitHub site [http://bit.ly/ng2-cli](http://bit.ly/ng2-cli).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了使用angular-cli生成组件，但这个工具也可以生成*指令*、*管道*、*服务*和*路由*。在GitHub网站的工具文档中查看[http://bit.ly/ng2-cli](http://bit.ly/ng2-cli)。
- en: Time to look at the most touted area in Angular, **performance**. Let's understand
    what makes Angular run fast and what switches/knobs are available with Angular
    to improve the overall app performance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看Angular最被吹捧的领域了，**性能**。让我们了解是什么让Angular运行得如此快，以及Angular提供了哪些开关/旋钮来改善整体应用程序的性能。
- en: Angular 2 performance
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2性能
- en: Angular 2 has been designed with performance in mind. Every part of the framework,
    starting from the framework footprint, initial load time, memory utilization,
    change detection plus data binding, and DOM rendering, has been tweaked or is
    being tweaked for better performance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2的设计考虑了性能。从框架占用空间、初始加载时间、内存利用率、变化检测加数据绑定，到DOM渲染，框架的每个部分都经过了调整或正在调整以获得更好的性能。
- en: The next few sections are dedicated to understanding how performant Angular
    is and the tricks it uses to achieve some impressive performance gains.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节专门讨论了Angular的性能和它使用的技巧，以实现一些令人印象深刻的性能提升。
- en: Byte size
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节大小
- en: '*Byte size* of the framework is a good starting point for performance optimization.
    While the world is moving towards a high-speed Internet, a sizable population
    among us is on a slow connection and are using their mobile to connect to the
    Web. We may not think too much about few KB here or there, but it does matter!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的*字节大小*是性能优化的一个很好的起点。虽然世界正在向高速互联网发展，但我们中间有相当一部分人在使用较慢的连接，并且使用手机连接到网络。我们可能不会太在意这里或那里的几KB，但这确实很重要！
- en: While the byte size of Angular 2 out-of-the-box is bigger than Angular 1, there
    are techniques that can drastically reduce the size of an Angular 2 bundle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular 2的开箱即用的字节大小比Angular 1大，但有一些技术可以大大减少Angular 2捆绑包的大小。
- en: To start with, the standard techniques of *minification* and *gzipping* can
    reduce this gap substantially. And with Angular 2, we can do some nifty tricks
    with *module bundler/loaders* to reduce the Angular 2 bundle size even more.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*最小化*和*压缩*的标准技术可以大大减少这一差距。而且使用Angular 2，我们可以通过*模块捆绑器/加载器*来做一些巧妙的技巧，进一步减少Angular
    2捆绑包的大小。
- en: '**Tree shaking** may be a quirky name for a process, but it literally does
    what it says! As we build apps using TypeScript (or ES2015), containing *modules*
    and *exports*, a module bundler such as *Rollup* ([http://rollupjs.org](http://rollupjs.org))
    can perform static code analysis on such code, determine what parts of the code
    are never used, and remove them before bundling the release bits. Such module
    bundlers, when added to the app''s build process, can analyze the framework bit,
    any third-party library, and the app code to remove any dead code before creating
    bundles. *Tree shaking can result in enormous size reduction as you don''t bundle
    framework bits that you don''t use.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**摇树**可能是一个古怪的名字，但它确实做到了！当我们使用TypeScript（或ES2015）构建应用程序时，包含*模块*和*导出*，像*Rollup*（[http://rollupjs.org](http://rollupjs.org)）这样的模块捆绑器可以对这样的代码进行静态代码分析，确定哪些代码部分从未被使用，并在捆绑发布版本之前将其删除。这样的模块捆绑器在添加到应用程序的构建过程中时，可以分析框架部分、任何第三方库和应用程序代码，以删除创建捆绑包之前的任何死代码。*摇树*可以导致巨大的大小减小，因为你不会捆绑你不使用的框架部分。'
- en: One of the biggest framework pieces that can be removed from the framework bundle
    is the *compiler*. Yes, you read right, it's the compiler!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从框架捆绑包中删除的最大框架部分之一是*编译器*。是的，你没看错，就是编译器！
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For curious readers, the compiler is the single biggest framework piece contributing
    a whopping *500 KB+* to the Angular bundle (In Angular 2 *v2.0.0*).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的读者来说，编译器是Angular捆绑包中贡献最大的框架部分，为*500 KB+*（在Angular 2 *v2.0.0*中）。
- en: Using tree shaking together with **Ahead-of-Time** (**AoT**) compilation, we
    can just get rid of the Angular compiler (in the browser) altogether.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用树摇和**预编译**（**AoT**）编译，我们可以完全摆脱Angular编译器（在浏览器中）。
- en: With AoT compilation, the view templates (HTML) are compiled beforehand on the
    server side. This compilation again is done as part of the app's build process
    where a server version of Angular 2 compiler (a node package) compiles every view
    in the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过AoT编译，视图模板（HTML）在服务器端预先编译。这种编译再次是作为应用程序构建过程的一部分进行的，其中Angular 2编译器的服务器版本（一个节点包）编译应用程序中的每个视图。
- en: With all the templates compiled, there is no need to send the Angular compiler
    bits to the client side at all. Tree shaking can now just get rid of the compiler
    and create a far slimmer framework package.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模板都已经编译，根本不需要将Angular编译器位发送到客户端。现在，树摇可以摆脱编译器，并创建一个更精简的框架包。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Read more about AoT in the framework documentation available at [http://bit.ly/ng2-aot](http://bit.ly/ng2-aot).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://bit.ly/ng2-aot](http://bit.ly/ng2-aot)提供的框架文档中了解更多关于AoT的信息。
- en: Initial load time and memory utilization
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始加载时间和内存利用
- en: The initial load time for any web app with a full-fledged framework is typically
    slow. This effect is more pronounced on mobile devices, where the JavaScript engine
    may not be as powerful as a desktop client. For a better user experience, it becomes
    imperative that the framework initial load time is optimized, especially for mobile
    devices.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有成熟框架的Web应用程序的初始加载时间通常很慢。这种影响在移动设备上更为明显，因为JavaScript引擎可能没有桌面客户端那么强大。为了获得更好的用户体验，优化框架的初始加载时间尤为重要，特别是对于移动设备。
- en: Out of the box, **Angular 2 is five times faster than Angular 1** when it comes
    to initial load time and re-rendering the view. These numbers will get better
    as the Angular team evolves the framework.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular 2的初始加载时间和重新渲染视图速度是Angular 1的五倍**。随着Angular团队不断发展框架，这些数字将会变得更好。'
- en: Further, AoT compilation too can improve the initial load time of the application
    as a time-consuming activity (view compilation) is not required.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AoT编译也可以提高应用程序的初始加载时间，因为不需要耗时的活动（视图编译）。
- en: The same holds good for memory utilization. Angular 2 fares better here too,
    and things will get even better with future releases.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 内存利用也是如此。Angular 2在这方面表现更好，未来的版本将会更好。
- en: 'If you are planning to switch to Angular 2, this is something that you should
    look forward to: a performant framework built for the future.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划切换到Angular 2，这是您应该期待的事情：一个为未来构建的高性能框架。
- en: 'The next three performance improvements that we are going to talk about have
    been made possible because of a single architectural decision: *the creation of
    a separate renderer layer*.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的下面三个性能改进之所以成为可能，是因为做出了一个单一的架构决策：*创建一个单独的渲染器层*。
- en: The Angular rendering engine
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular渲染引擎
- en: The biggest disadvantage of Angular 1 was that the framework was tied to the
    browser DOM. The directives, the binding, and the interpolations all worked against
    the DOM.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1最大的缺点是该框架与浏览器DOM绑定在一起。指令、绑定和插值都针对DOM工作。
- en: 'With Angular 2, the biggest architectural change that came in was a separate
    rendering layer. Now an Angular 2 app has two layers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2中，最大的架构变化是引入了一个单独的渲染层。现在，Angular 2应用程序有两个层：
- en: '**Application layer**: This is the layer our code resides in. It uses an abstraction
    build over the renderer layer to interact with it. The Renderer class we saw in
    [Chapter 6](part0066.xhtml#aid-1UU542 "Chapter 6.  Angular 2 Directives in Depth"),
    *Angular 2 Directives in Depth*, is the interface that we use to interact with
    the rendering layer.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层：这是我们的代码所在的层。它使用在渲染层上构建的抽象与其进行交互。我们在[第6章](part0066.xhtml#aid-1UU542 "Chapter 6. 
    Angular 2 Directives in Depth")中看到的Renderer类，*Angular 2 Directives in Depth*，就是我们用来与渲染层交互的接口。
- en: '**Rendering layer**: This layer is responsible for translating requests from
    the application layer into rendered components, and reacting to user input and
    view updates.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染层：这一层负责将应用层的请求转换为渲染组件，并对用户输入和视图更新做出反应。
- en: The default renderer implementation for the renderer is `DomRenderer`, which
    runs inside the browser. But there are other rendering abstractions too and we
    will discuss them in the following section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器的默认实现是`DomRenderer`，它在浏览器内部运行。但也有其他渲染抽象，我们将在下一节中讨论它们。
- en: Server-side rendering
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: '**Prerendering** on the server side is yet another technique for improving
    the initial load time of an Angular 2 app. This technique is really helpful on
    mobile devices, as it improves the perceived load time considerably.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的预渲染是改善Angular 2应用程序初始加载时间的另一种技术。这种技术在移动设备上非常有用，因为它显著提高了感知加载时间。
- en: Server-side rendering takes care of the initial page load before client-side
    rendering kicks in (and handles view rendering henceforth).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染负责在客户端渲染启动之前处理初始页面加载（并处理视图渲染）。
- en: In such a scenario, when the user requests for a view/page, a piece of software
    on the server generates a fully materialized HTML page with data pre-bound to
    the view and sends it to the client along with a small script. The app view hence
    is immediately rendered, ready for interaction. While the framework loads in the
    background, the small script that was sent along the first time captures all user
    inputs and makes them available to the framework, allowing it to replay the interactions
    once it is loaded.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当用户请求查看/页面时，服务器上的一款软件会生成一个完全实现的HTML页面，其中数据预先绑定到视图，并将其与一个小脚本一起发送到客户端。因此，应用视图立即被渲染，准备好进行交互。在后台加载框架的同时，第一次发送的小脚本会捕获所有用户输入，并使其可用于框架，从而允许在加载后重放交互。
- en: Angular Universal, as it is touted, allows rendering and sharing of the view
    both on the server- and client-side.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Universal允许在服务器端和客户端上渲染和共享视图。
- en: Server-side rendering is only made possible because of separation of the rendering
    layer as described previously. The initial view is generated by a renderer implementation
    on the server, named `ServerDomRenderer`. There is a Node.js plugin ([http://bit.ly/ng2-universal-node](http://bit.ly/ng2-universal-node))
    that can be used in a number of node web frameworks such as *Express*, *Hapi*,
    *Sail*, and others. Efforts are also ongoing to have a rendered implementation
    for other popular server platforms such as .NET and PHP.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染之所以成为可能，是因为之前所述的渲染层的分离。初始视图由服务器上的渲染器实现生成，名为`ServerDomRenderer`。有一个Node.js插件可以在多个Node
    web框架中使用，例如*Express*、*Hapi*、*Sail*等。还在努力为其他流行的服务器平台（如.NET和PHP）开发渲染实现。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Look at the Angular design docs for Angular Universal ([http://bit.ly/ng2-universal-design](http://bit.ly/ng2-universal-design))
    and the embedded YouTube videos at the top of the design doc to learn more about
    server-side rendering.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Angular设计文档以了解有关服务器端渲染的更多信息。
- en: Performance is not the only benefit with server-side rendering. As it turns
    out, search indexers too like pre-rendered HTML content. Server-side rendering
    is really useful in areas such as **search engine optimization (SEO)** and deep
    linking, which allows easy content sharing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不是服务器端渲染的唯一好处。事实证明，搜索索引器也喜欢预渲染的HTML内容。服务器端渲染在**搜索引擎优化（SEO）**和深度链接等领域非常有用，这使得内容共享变得更加容易。
- en: Offloading work to a web worker
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将工作卸载到Web Worker
- en: Offloading work to a **web worker** is a neat idea, again made possible due
    to the separation of the rendering layer from the application layer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作卸载到**Web Worker**是一个很好的主意，这也是由于渲染层与应用程序层的分离才变得可能。
- en: '*Web workers* provide a mechanism for running scripts in background threads.
    These threads can execute work that does not involve the browser DOM. Be it a
    CPU-intensive task or a remote XHR invocation, all can be delegated to web workers.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web Worker*提供了在后台线程中运行脚本的机制。这些线程可以执行不涉及浏览器DOM的工作。无论是CPU密集型任务还是远程XHR调用，都可以委托给Web
    Worker。'
- en: In today's world, CPUs with multiple cores are the norm, but JavaScript execution
    is still single-threaded. There is a need for a standard/mechanism to utilize
    these idle cores for our apps. Web worker fits the bill perfectly, and since most
    modern browsers support them, we all should be writing code that utilizes web
    workers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，多核CPU是常态，但JavaScript执行仍然是单线程的。我们需要一种标准/机制来利用这些空闲核心来运行我们的应用程序。Web Worker完全符合要求，由于大多数现代浏览器都支持它们，我们都应该编写利用Web
    Worker的代码。
- en: 'Sadly that''s not happening. Web workers are still not mainstream and there
    are good reasons for that. Web workers impose a good number of restrictions on
    what is allowed and what is not. These limitations include:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，情况并非如此。Web Worker仍然不是主流，这其中有很多充分的理由。Web Worker对允许和不允许的事项施加了许多限制。这些限制包括：
- en: '**No direct access to DOM**: Web workers cannot directly manipulate the DOM.
    In fact, web workers do not have access to multiple globals such as *window* and
    *document*, and others are not available on the web worker thread. This severely
    limits the number of use cases where a web worker can be utilized.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法直接访问DOM**：Web Worker无法直接操作DOM。事实上，Web Worker无法访问多个全局对象，如*window*和*document*，而其他一些在Web
    Worker线程上也不可用。这严重限制了Web Worker可以被利用的用例数量。'
- en: '**Browser support**: Web workers are only available for modern/evergreen browsers
    (IE 10+).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器支持**：Web Worker仅适用于现代/常青浏览器（IE 10+）。'
- en: '**Inter process communication**: Web workers do not share memory with your
    main browser process and hence need to communicate with the main thread (UI thread)
    only through *message passing* (serialized data). Adding to that, the message
    passing mechanism is asynchronous in nature, adding another layer of complexity
    to the communication model.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**：Web Worker不与主浏览器进程共享内存，因此需要通过*消息传递*（序列化数据）与主线程（UI线程）进行通信。此外，消息传递机制是异步的，增加了通信模型的另一层复杂性。'
- en: Clearly, web workers are hard to use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Web Worker很难使用。
- en: Angular 2 tries to alleviate these limitations by integrating the web worker
    usage into the framework itself. It does that by running the complete application
    in the web worker thread, except the rendering part.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2试图通过将Web Worker的使用集成到框架本身中来缓解这些限制。它通过在Web Worker线程中运行完整的应用程序，除了渲染部分来实现这一点。
- en: The framework takes care of the communication between the application code running
    inside the web worker, and the renderer running inside the main UI thread. From
    a developer's perspective, there are no visible differences.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架负责处理应用程序代码在Web Worker内部运行和主UI线程内部运行的渲染器之间的通信。从开发者的角度来看，没有可见的区别。
- en: 'This is again made possible due to the separation of the renderer layer in
    Angular 2\. The following diagram shows the layers that run on the app main thread
    and what runs inside the web worker:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次得益于Angular 2中渲染器层的分离。以下图表显示了在应用程序主线程上运行的层以及在Web Worker中运行的内容：
- en: '![Offloading work to a web worker](../Images/image00408.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![将工作分配给Web Worker](../Images/image00408.jpeg)'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go through at this talk ([http://bit.ly/yt-ng2-web-worker](http://bit.ly/yt-ng2-web-worker))
    from Jason Teplitz to learn about what web workers have to offer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 观看Jason Teplitz的演讲（[http://bit.ly/yt-ng2-web-worker](http://bit.ly/yt-ng2-web-worker)）了解Web
    Worker的优势。
- en: Performant mobile experience
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高性能移动体验
- en: Angular's rendering abstraction again opens up a host of integration avenues,
    especially on the mobile platform. Rather than running an app on a mobile browser,
    Angular renderers can be created that can tap the device's native UI capabilities.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的渲染抽象再次为我们打开了许多集成途径，特别是在移动平台上。与其在移动浏览器上运行应用程序，不如创建可以利用设备原生UI功能的Angular渲染器。
- en: 'Two notable projects in this domain are renderers for platforms:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此领域中两个值得注意的项目是平台的渲染器：
- en: '**ReactNative** ([http://bit.ly/rnative](http://bit.ly/rnative)): A renderer
    for ReactNative ([http://bit.ly/ng2-rnative](http://bit.ly/ng2-rnative)). It allows
    writing of Angular 2 apps using ReactNative''s rendering capabilities.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReactNative** ([http://bit.ly/rnative](http://bit.ly/rnative))：ReactNative的渲染器（[http://bit.ly/ng2-rnative](http://bit.ly/ng2-rnative)）。它允许使用ReactNative的渲染能力编写Angular
    2应用程序。'
- en: '**NativeScript** ([https://www.nativescript.org/](https://www.nativescript.org/)):
    Angular and NativeScript teams have collaborated to create a renderer for NativeScript
    ([http://bit.ly/ng2-native-script](http://bit.ly/ng2-native-script)).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NativeScript** ([https://www.nativescript.org/](https://www.nativescript.org/))：Angular和NativeScript团队合作创建了NativeScript的渲染器（[http://bit.ly/ng2-native-script](http://bit.ly/ng2-native-script)）。'
- en: App platforms such as *ReactNative* and *NativeScript* already do a superb job
    of providing JavaScript-based APIs for the native mobile platforms (iOS and Android),
    allowing us to utilize a single code base, with a familiar language. Angular renderers
    take things a step further. With Angular integration, a good amount of code can
    be shared across browsers and mobile devices. Things may only differ in terms
    of view templates and view-related services such as dialogs, popups, and others.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用平台，如*ReactNative*和*NativeScript*，已经非常出色地为原生移动平台（iOS和Android）提供了基于JavaScript的API，使我们能够利用单一的代码库和熟悉的语言。Angular渲染器将事情推向了更高层次。通过与Angular集成，大量代码可以在浏览器和移动设备之间共享。只有视图模板和与视图相关的服务（如对话框、弹出窗口等）可能有所不同。
- en: Look at the documentation for the respective renderers to understand how they
    work and the features they support.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 查看各自渲染器的文档，了解它们的工作原理和支持的功能。
- en: Next up on the line, we have framework improvements in terms of *change detection*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在*变更检测*方面进行框架改进。
- en: Change detection improvements
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进变更检测
- en: One of the major performance improvements in Angular 2 over Angular 1 is in
    how *change detection* works in Angular 2\. Angular 2 change detection out of
    the box is insanely fast, and it can be tweaked further for even better results.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2相对于Angular 1的主要性能改进之一是*变更检测*的工作方式。Angular 2的变更检测开箱即用，速度非常快，而且可以进一步调整以获得更好的结果。
- en: The next few sections talk about Angular change detection in depth. It's an
    important topic to understand when building anything at scale. It also helps us
    debug scenarios where it may seem that change detection is not working as advertised.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将深入讨论Angular变更检测。这是一个重要的主题，当构建大规模应用时需要了解。它还有助于我们调试一些看似变更检测不起作用的情况。
- en: Let's start the discussion by understanding what change detection is and why
    it is important.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解什么是变更检测以及为什么它很重要开始讨论。
- en: Change detection
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更检测
- en: Angular's *data binding engine* does a great job of binding the view with the
    model data (component data). These are live bindings where Angular keeps the view
    in sync with model changes. Any time the model changes, the binding engine re-renders
    parts of the view that are dependent on the model. To manage this view-model synchronization,
    Angular needs to know when the model changed and what changed exactly. This is
    what **change detection** is all about. During app execution, Angular frequently
    does what we call **change detection runs** to determine what changed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的*数据绑定引擎*很好地将视图与模型数据（组件数据）进行绑定。这些是实时绑定，Angular会保持视图与模型更改同步。每当模型更改时，绑定引擎会重新渲染依赖于模型的视图部分。为了管理这种视图模型同步，Angular需要知道模型何时发生了变化以及发生了什么变化。这就是**变更检测**的全部内容。在应用程序执行期间，Angular经常进行我们所谓的**变更检测运行**，以确定发生了什么变化。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are from Angular 1, *change detection run* is roughly equivalent to **digest
    cycles**, except that in Angular 2 there are no cycles.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Angular 1，*变更检测运行*大致相当于**脏检查循环**，只是在Angular 2中没有循环。
- en: While this problem of keeping the model and view in sync may sound simple, it's
    a tough nut to crack. Unlike the component tree, the interconnection between multiple
    models can be complex. Changes in one component model can trigger changes in multiple
    component models. Furthermore, these interconnections may have cycles. A single
    model property could be bound to multiple views. All these complex scenarios need
    to be managed using a robust change detection infrastructure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然保持模型和视图同步的问题听起来很简单，但实际上却很棘手。与组件树不同，多个模型之间的相互关联可能很复杂。一个组件模型的变化可能会触发多个组件模型的变化。此外，这些相互关联可能会形成循环。单个模型属性可能绑定到多个视图。所有这些复杂的情况都需要使用强大的变更检测基础设施来管理。
- en: In the next few sections, we explore how the Angular change detection infrastructure
    works, when change detection triggers, and how can we influence change detection
    behavior in Angular.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨Angular变更检测基础设施的工作原理，变更检测触发的时机，以及我们如何影响Angular中的变更检测行为。
- en: Change detection setup
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更检测设置
- en: 'It all starts with Angular setting up change detectors for every component
    rendered on the view. Since every Angular app is a hierarchy of components, these
    change detectors are also set up in the same hierarchy. The following diagram
    highlights the **change detector hierarchy** of the *Workout Builder* app at a
    point in time:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于Angular为视图上渲染的每个组件设置变更检测器。由于每个Angular应用程序都是一个组件层次结构，这些变更检测器也是按照相同的层次结构设置的。以下图表突出显示了*Workout
    Builder*应用程序在某个时间点的**变更检测器层次结构**：
- en: '![Change detection setup](../Images/image00409.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![变更检测设置](../Images/image00409.jpeg)'
- en: A *change detector* attached to a component has the responsibility of detecting
    changes in the component. It does that by parsing the binding on the component's
    template HTML and sets up the necessary change detection watches.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到组件的*变更检测器*负责检测组件中的变化。它通过解析组件模板HTML上的绑定来实现，并设置必要的变更检测监视。
- en: Remember, the detector only sets up watches on model properties used in the
    template, not on all component properties.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，检测器只在模板中使用的模型属性上设置监视，而不是在所有组件属性上。
- en: Another important point worth highlighting here is that *change detection is
    set up one way, from model to view*. Angular does not have the concept of two-way
    data binding and hence the preceding figure is a directed tree without cycles.
    This also makes change detection more predictable. Interleaving model and view
    updates is disallowed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得强调的重要点是*变更检测是单向的，从模型到视图*。Angular没有双向数据绑定的概念，因此前面的图是一个没有循环的有向树。这也使得变更检测更加可预测。禁止交错地更新模型和视图。
- en: When does change detection kick in?
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时启动变更检测？
- en: Does Angular constantly check for changes in the model data? Considering the
    fact that the component properties we bind the view to do not inherit from any
    special class, Angular has no way of knowing which property changed. The only
    way out for Angular is to constantly query each data-bound property to know its
    current value and compare it against its old value for changes. Highly inefficient
    to say the least!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是否会不断检查模型数据的变化？考虑到我们绑定视图的组件属性并不继承自任何特殊类，Angular无法知道哪个属性发生了变化。Angular唯一的出路就是不断查询每个数据绑定的属性，了解它的当前值，并将其与旧值进行比较以检测变化。至少可以说这是非常低效的！
- en: Angular does better than that, as change detection runs get executed only at
    specific times during app execution. Think carefully about any web application;
    what causes a view to update?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Angular做得比这更好，因为变更检测运行只会在应用程序执行过程中的特定时间执行。仔细考虑任何Web应用程序；是什么导致视图更新？
- en: 'View can get updated due to:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可能因为以下原因而更新：
- en: '**User input/ browser events**: We click on a button, enter some text, and
    scroll the content. Each of these actions can update the view (and the underlying
    model).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入/浏览器事件**：我们点击按钮，输入一些文本，滚动内容。这些操作中的每一个都可以更新视图（和底层模型）。'
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程XHR请求**：这是视图更新的另一个常见原因。从远程服务器获取数据以显示在网格上，以及获取用户数据以渲染视图都是这种情况的例子。'
- en: '**setTimeout and setInterval timers**: As it turns out, we can use `setTimeout`
    and `setInterval` to execute some code asynchronously and at specific intervals.
    Such code can also update the model. For example, a `setInterval` timer may check
    for stock quotes at regular intervals and update the stock price on the UI.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setTimeout和setInterval定时器**：事实证明，我们可以使用`setTimeout`和`setInterval`来异步执行一些代码，并在特定间隔内执行。这样的代码也可以更新模型。例如，`setInterval`定时器可以定期检查股票报价并在UI上更新股价。'
- en: For obvious reasons, Angular change detection too kicks in only when any of
    these conditions occur.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 出于明显的原因，Angular的变更检测也只有在这些条件发生时才会启动。
- en: The interesting part here is not when Angular's change detection kicks in but
    how Angular is able to intercept all *browser events*, *XHR requests*, and `setTimeout`
    and `setInterval` functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的地方不在于Angular的变更检测何时启动，而在于Angular如何拦截所有*浏览器事件*、*XHR请求*以及`setTimeout`和`setInterval`函数。
- en: 'This feat in Angular is performed by a library called **zone.js**. As the documentation
    describes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，这一功能是由一个叫做**zone.js**的库执行的。正如文档所描述的：
- en: '*A Zone is an execution context that persists across async tasks.*'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*区域是一个持续存在的执行上下文，跨越异步任务。*'
- en: 'One of the basic abilities of this library is that it can hook into a piece
    of code and trigger callbacks when code execution starts and when it ends. The
    code being monitored could be a sequence of calls that are both synchronous and
    asynchronous in nature. Consider this example, which highlights the usage:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的一个基本能力是它可以钩入一段代码，并在代码执行开始和结束时触发回调。被监视的代码可能是一系列既同步又异步的调用。考虑下面的例子，突出了使用方法：
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We wrap a piece of code inside a call to the `zone.run` call. This code calls
    the `doWork` function synchronously twice, interleaved with a `setTimeout` call
    that invokes the same function after a lapse of 200 milliseconds.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一段代码包装在`zone.run`调用中。这段代码两次同步调用`doWork`函数，并与一个`setTimeout`调用交错，该调用在200毫秒后调用相同的函数。
- en: 'By wrapping this sequence inside `zone.run`, we can know when the call execution
    is complete. In zone terminology, these are **turns**. The code before `zone.run`
    sets up a subscriber that gets called when execution is complete, using the `zone.onMicrotaskEmpty`
    function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个序列包装在`zone.run`中，我们可以知道调用执行何时完成。在区域术语中，这些是**轮次**。在`zone.run`之前的代码设置了一个订阅者，当执行完成时会被调用，使用`zone.onMicrotaskEmpty`函数：
- en: 'If we execute the preceding code, the logs look like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行上述代码，日志看起来像：
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `onMicrotaskEmpty` subscription is executed twice, once after the sequential
    execution completes (defined inside `run` callback) and one after the asynchronous
    `setTimeout` execution is complete.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMicrotaskEmpty`订阅会执行两次，一次是在顺序执行完成后（在`run`回调中定义），一次是在异步的`setTimeout`执行完成后。'
- en: Angular 2 change detection uses the same technique to execute our code within
    zones. This code could be an *event handler*, which internally makes more synchronous
    and asynchronous calls before completing. Or it could be a `setTimeout`/`setInterval`
    operation that may again require a UI update.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2变化检测使用相同的技术在区域内执行我们的代码。这段代码可能是一个*事件处理程序*，在完成之前内部进行更多的同步和异步调用。或者它可能是一个`setTimeout`/`setInterval`操作，可能再次需要UI更新。
- en: 'The Angular change detection framework subscribes to the `onMicrotaskEmpty`
    observable for the executing zone, and kicks in change detection whenever a turn
    is complete. The following diagram highlights what happens when code similar to
    the one just described is run on a button click:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Angular变化检测框架订阅执行区域的`onMicrotaskEmpty`可观察对象，并在每个轮次完成时启动变化检测。以下图表突出显示了当类似于刚才描述的代码在按钮点击时运行时会发生什么：
- en: '![When does change detection kick in?](../Images/image00410.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: 当变化检测启动时是什么时候？
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: During the execution of the code block, if the zone library determines that
    the call is asynchronous in nature, it spawns a new micro task that has its own
    life cycle. It is the completion of these micro tasks that also triggers `onMicrotaskEmpty`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块执行期间，如果区域库确定调用是异步的，它会生成一个新的微任务，具有自己的生命周期。这些微任务的完成也会触发`onMicrotaskEmpty`。
- en: 'If you want to know how the change detection trigger looks inside Angular,
    here is an excerpt from the Angular source code (simplified further):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道在Angular内部变化检测触发器是什么样的，这里是从Angular源代码中摘录的一部分（进一步简化）：
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ApplicationRef` class tracks all the change detectors attached throughout
    the app and triggers a change detection cycle when the application-level zone
    object fires the `onMicrotaskEmpty` event. We will shortly touch upon what happens
    during this change detection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationRef`类跟踪整个应用程序中附加的所有变化检测器，并在应用程序级别的区域对象触发`onMicrotaskEmpty`事件时触发变化检测周期。我们很快将会讨论在这个变化检测期间发生了什么。'
- en: '*Zonejs* gets the ability to track execution context across any asynchronous
    call because it overrides the default browser API. The override, also termed **monkey
    patching**, overrides the *event subscription*, *XHR requests*, and `setTimeout`/`setInterval`
    API. In the example highlighted previously, the `setTimeout` we invoke is a monkey-patched
    version of the original browser API.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*Zonejs*能够跟踪任何异步调用的执行上下文，因为它覆盖了默认的浏览器API。这种覆盖，也称为**monkey patching**，覆盖了*事件订阅*、*XHR请求*和`setTimeout`/`setInterval`API。在之前突出的示例中，我们调用的`setTimeout`是原始浏览器API的一个monkey-patched版本。'
- en: Now that we know how change detectors are set up and when this activity kicks
    in, we can look at how it works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了变化检测器是如何设置的以及何时启动这一活动，我们可以看看它是如何工作的。
- en: How does change detection work?
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变化检测是如何工作的？
- en: Once the change detectors are set up and the browser API is monkey-patched to
    trigger change detection, the real change detection kicks in. This is quite a
    simple process.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变化检测器设置好并且浏览器API被修改以触发变化检测，真正的变化检测就开始了。这是一个非常简单的过程。
- en: As soon as any of the asynchronous event callbacks is triggered (execution of
    an event handler is also an async activity), Angular first executes the application
    code we have attached to the callback. This code execution may result in some
    model updates. Post the execution of the callback, Angular needs to respond to
    the changes by triggering a *change detection run*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发了任何异步事件回调（事件处理程序的执行也是异步活动），Angular首先执行我们附加到回调的应用程序代码。这段代码执行可能会导致一些模型更新。在回调执行后，Angular需要通过触发*变化检测运行*来响应这些变化。
- en: In a change detection run, starting from the top of the component tree, every
    change detector evaluates its respective component's template bindings to see
    if the value of the binding expression has changed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在变化检测运行中，从组件树顶部开始，每个变化检测器评估其相应组件的模板绑定，以查看绑定表达式的值是否发生了变化。
- en: 'There are some things that we need to highlight regarding this execution:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种执行，有一些需要强调的事情：
- en: Angular does a strict equality check (using `===`) to detect changes. Since
    it's not a deep comparison, for a binding that refers to an object Angular will
    only update the view when the object reference changes.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular使用严格的相等性检查（使用`===`）来检测变化。由于它不是深度比较，对于引用对象的绑定，Angular只会在对象引用发生变化时更新视图。
- en: The change detection flow is unidirectional (starting from root), from parent
    to child in a top-down fashion. The detectors on the parent component run before
    the child detectors.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化检测流是单向的（从根开始），从父级向子级以自顶向下的方式运行。父组件上的检测器在子检测器之前运行。
- en: By default, the change detection algorithm navigates the complete tree, irrespective
    of where the change was triggered in the tree. This implies all binding is evaluated
    on every change detection run.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，变化检测算法会导航整个树，无论变化是在树的哪个位置触发的。这意味着在每次变化检测运行时都会评估所有绑定。
- en: '![How does change detection work?](../Images/image00411.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![变化检测是如何工作的？](../Images/image00411.jpeg)'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Binding evaluation on every run may seem inefficient but it is not. Angular
    employs some advance optimizations to make this check superfast. Still if we want
    to tweak this behavior, we do have some switches that can reduce the number of
    checks performed. We will touch upon this topic soon.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次运行时进行绑定评估可能看起来效率低下，但实际上并非如此。Angular采用了一些先进的优化方法，使这种检查变得超快。但是，如果我们想要调整这种行为，我们确实有一些开关可以减少执行的检查次数。我们将很快涉及这个话题。
- en: Change detectors only track properties that are part of template bindings, not
    the complete object/component properties.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化检测器只跟踪模板绑定的属性，而不是完整的对象/组件属性。
- en: To detect changes in the bound value, the change detectors need to track the
    previous value of the expression evaluated during the last change detection run.
    Clearly some amount of book keeping is required for every template binding we
    use.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检测绑定值的变化，变化检测器需要跟踪上一次变化检测运行期间评估的表达式的先前值。显然，对于我们使用的每个模板绑定，都需要一定数量的簿记。
- en: 'The obvious next question would be: What happens when a change is detected
    (by a change detector)?'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的下一个问题是：当变化检测器检测到变化时会发生什么？
- en: Since all the hard work of setting up change detection and identifying changes
    has already been done, this step just involves updating the component state and
    synchronizing the component DOM.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经完成了设置变更检测和识别更改的所有艰苦工作，这一步只涉及更新组件状态和同步组件DOM。
- en: 'There are a few more observations worth highlighting here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些值得注意的观察：
- en: First and foremost, Angular separates the model update step from the DOM update.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，Angular将模型更新步骤与DOM更新分开。
- en: 'Consider this code snippet, which is invoked when someone clicks on a button:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，当有人点击按钮时调用：
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assuming that both `firstName` and `lastName` are bound to the component view,
    a change to `firstName` does not update the DOM binding immediately. Instead,
    Angular waits for the `doWork` function to complete before triggering a change
    detection run and DOM update.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`firstName`和`lastName`都绑定到了组件视图，对`firstName`的更改不会立即更新DOM绑定。相反，Angular会等待`doWork`函数完成后再触发变更检测运行和DOM更新。
- en: 'Secondly, a change detection run does not (and should not) update the model
    state. This avoids any cycles and cascading updates. A change detection run is
    only responsible for evaluating the bindings and updating the view. This also
    means that we should not update the model state during change detection. If we
    update the model during change detection, Angular throws an error. Let''s see
    an example of this behavior:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，变更检测运行不会（也不应该）更新模型状态。这避免了任何循环和级联更新。变更检测运行只负责评估绑定并更新视图。这也意味着我们不应该在变更检测期间更新模型状态。如果在变更检测期间更新模型，Angular会抛出错误。让我们看一个例子：
- en: 'Open `start.html` and update the last div to:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`start.html`并更新最后一个div为：
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And add a `changeDetectionDone` function to the component implementation (`start.component.ts`),
    which looks like:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且在组件实现（`start.component.ts`）中添加一个`changeDetectionDone`函数，如下所示：
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the app, load the start page, and then look at the browser console. Angular
    has logged a number of errors that look like:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，加载起始页面，然后查看浏览器控制台。Angular已记录了一些看起来像这样的错误：
- en: '[PRE9]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are changing the state of the component when calling the `changeDetectionDone`
    function (inside an interpolation), and Angular throws an error because it does
    not expect the component state to update.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`changeDetectionDone`函数（在插值内部）时，我们正在改变组件的状态，Angular会抛出错误，因为它不希望组件状态更新。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This change detection behavior is enabled only when **production mode** in Angular
    has not been enabled. Angular's *production mode* can be enabled by calling the
    `enableProdMode()` function before bootstrapping the application (in `bootstrap.ts`).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变更检测行为仅在未启用Angular的**生产模式**时才启用。可以通过在引导应用程序（在`bootstrap.ts`中）之前调用`enableProdMode()`函数来启用Angular的*生产模式*。
- en: When enabled, Angular behaves a bit differently. It turns off assertions and
    other checks within the framework. Production mode also affects the change detection
    behavior.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用时，Angular的行为会有些不同。它会关闭框架内的断言和其他检查。生产模式还会影响变更检测行为。
- en: In non-production mode, Angular traverses the component tree twice to detect
    changes. If on the second pass any binding expression has changed, it throws an
    error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在非生产模式下，Angular会遍历组件树两次以检测更改。如果在第二次遍历中任何绑定表达式发生了变化，它会抛出错误。
- en: In contrast, when in production mode, change detection tree traversal is done
    only once. The change detection error that we saw in the console will not show
    up if we enable production mode. This can lead to an inconsistency between the
    model and view state. Something we should be aware of!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在生产模式下，变更检测树遍历只进行一次。如果启用生产模式，控制台中看到的变更检测错误将不会出现。这可能导致模型和视图状态不一致。这是我们应该注意的事情！
- en: 'The bottom-line is that we cannot alter the state of a component when change
    detection is in progress. A direct corollary: if we are using a function inside
    the binding expression, function executions should be stateless, without any side
    effects.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，当变更检测正在进行时，我们不能改变组件的状态。一个直接的推论是：如果我们在绑定表达式中使用函数，函数执行应该是无状态的，没有任何副作用。
- en: And lastly, this change detection traversal from root to leaf node executes
    only once during the change detection run.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这种从根节点到叶节点的变更检测遍历只在变更检测运行期间执行一次。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A pleasant surprise for folks with an Angular 1 background! *The digest cycle
    count is Angular 2 is 1*. Angular 2 developers will never face "the digest iterations
    exceeded exception!" A far more performant change detection system!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有Angular 1背景的人来说，这是一个惊喜！*Angular 2中的digest循环计数为1*。Angular 2开发人员永远不会遇到“digest迭代超出异常！”更高性能的变更检测系统！
- en: Change detection performance
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测性能
- en: Let's talk about change detection performance. If you think checking the complete
    component tree every time for change is inefficient, you would be surprised to
    know how fast it is. Due to some optimization done in terms of how expressions
    are evaluated and compared, Angular can perform thousands of checks in a couple
    of milliseconds.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈变更检测的性能。如果你认为每次检查完整的组件树以进行更改是低效的，你会惊讶地知道它有多快。由于在表达式评估和比较方面进行了一些优化，Angular可以在几毫秒内执行数千次检查。
- en: Under the hood, for every expression involved in the view binding, Angular generates
    a change detection function that specifically targets a particular binding. While
    it may seem counterintuitive at first, Angular does not have a common function
    for determining whether an expression has changed. Instead, it's like writing
    our own change detection function for every property that we bind to. This allows
    the JavaScript VM to optimize the code, resulting in improved performance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，对于视图绑定中涉及的每个表达式，Angular都会生成一个特定于特定绑定的变更检测函数。虽然乍一看可能有些反直觉，但Angular并没有一个用于确定表达式是否发生变化的通用函数。相反，这就像为我们绑定的每个属性编写自己的变更检测函数。这使得JavaScript虚拟机能够优化代码，从而提高性能。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Want to learn more about it? Check out this video by Victor Savkin: [https://youtu.be/jvKGQSFQf10](https://youtu.be/jvKGQSFQf10).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多吗？查看Victor Savkin的这个视频：[https://youtu.be/jvKGQSFQf10](https://youtu.be/jvKGQSFQf10)。
- en: In spite of all this optimization, there may still be cases where traversing
    the complete component tree may not be performant enough. This is especially true
    when we have to render a large dataset on the view, keeping the bindings intact.
    The good news is that the Angular change detection mechanism can be tweaked.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管进行了所有这些优化，仍然可能存在遍历完整组件树性能不足的情况。特别是当我们需要在视图上呈现大量数据集并保持绑定完整时，这一点尤为真实。好消息是，Angular变更检测机制可以进行调整。
- en: The reason Angular needs to do the complete tree walk is that model changes
    at one place may trigger model changes at other places. In other words, a model
    change may have a cascading effect, where interconnected model objects are also
    updated. Since Angular has no way to know what exactly changed, it checks the
    complete component tree and associated model.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Angular需要完成树遍历的原因是，一个地方的模型更改可能会触发其他地方的模型更改。换句话说，模型更改可能会产生级联效应，其中相互连接的模型对象也会更新。由于Angular无法知道到底发生了什么变化，它会检查完整的组件树和相关模型。
- en: If we can help Angular determine what parts of the application state are updated,
    Angular can be pretty smart about what part of the component tree it traverses
    to detect changes. We do this by storing the app data in some special data structures
    that help Angular decide what components need to be checked for changes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以帮助Angular确定应用程序状态的哪些部分已更新，Angular就可以对需要检查更改的组件树的哪一部分进行智能处理。我们可以通过将应用数据存储在一些特殊的数据结构中来实现这一点，这些数据结构有助于Angular决定需要检查哪些组件的更改。
- en: There are three ways in which we can make Angular change detection smarter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三种方式使Angular的变更检测更智能。
- en: Using immutable data structures
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用不可变数据结构
- en: '**Immutable objects/collections** are objects that cannot be changed once created.
    Any property change results in a new object being created. This is what **immutable.js**,
    a popular library for immutable data structures, has to say:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变对象/集合**是一旦创建就无法更改的对象。任何属性更改都会导致创建一个新对象。这就是流行的不可变数据结构库**immutable.js**的说法：'
- en: '*Immutable data cannot be changed once created, leading to much simpler application
    development, no defensive copying, and enabling advanced memoization and change
    detection techniques with simple logic.*'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一旦创建，不可变数据就无法更改，从而大大简化了应用程序开发，无需进行防御性复制，并且可以使用简单的逻辑实现高级记忆和变更检测技术。*'
- en: Let's try to understand how immutable data structures help in the Angular context
    with an example.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着了解不可变数据结构如何在Angular上下文中帮助的一个例子。
- en: 'Imagine we are building a set of components to collect employee information
    for a **Human Resource** (**HR**) software. The employee component view looks
    something like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在构建一组组件来收集**人力资源**（**HR**）软件的员工信息。员工组件视图看起来像这样：
- en: '[PRE10]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It has sections for taking personal, professional, and address information.
    The `summary` components provide a read-only view for employee data being entered.
    Each of the components has a property called `model`, highlighting what part of
    employee data these components manipulate. Each of these components'' summary,
    professional, personal, and address internally may have other child components.
    This is how the component tree looks:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它有用于输入个人、专业和地址信息的部分。`summary`组件为正在输入的员工数据提供只读视图。每个组件都有一个名为`model`的属性，突出显示这些组件操作的员工数据的哪一部分。每个这些组件的summary、professional、personal和address内部可能有其他子组件。这就是组件树的样子：
- en: '![Using immutable data structures](../Images/image00412.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![使用不可变数据结构](../Images/image00412.jpeg)'
- en: What happens when we update an employee's personal information? With standard
    objects (mutable), Angular cannot make any assumption about the shape of data
    and what all has changed; hence, it does the complete tree walk.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新员工的个人信息时会发生什么？对于标准对象（可变的），Angular无法对数据的形状和所有更改做出任何假设；因此，它会进行完整的树遍历。
- en: 'How does immutability help here? When using an immutable data structure, any
    change to an object''s properties results in a new object being created. For example,
    if we create an immutable object using a popular library, *immutablejs*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性在这里如何帮助？当使用不可变的数据结构时，对对象属性的任何更改都会导致创建一个新对象。例如，如果我们使用一个流行的库*immutablejs*来创建一个不可变的对象：
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Changes to either the `name` or `age` property of `personalInfo` create a new
    object:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对`personalInfo`的`name`或`age`属性的更改会创建一个新对象：
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This immutability comes in handy if each of the employee model properties (`personal`,
    `professional`, `home` and `work`) is immutable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果员工模型的每个属性（`personal`、`professional`、`home`和`work`）都是不可变的，这种不可变性就会派上用场。
- en: 'Take for instance the `PersonalInfo` component definition that binds to personal
    info data:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以`PersonalInfo`组件定义为例，该组件绑定到个人信息数据：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the only thing `PersonalInfo` depends upon is the `model` property, and
    the `model` property binds to an immutable object, Angular only needs to do a
    check for changes if the `model` reference changes. Otherwise, the complete `PersonalInfo`
    component subtree can be skipped.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PersonalInfo`所依赖的唯一事物是`model`属性，而`model`属性绑定到一个不可变对象，因此只有在`model`引用发生变化时，Angular才需要进行变化检测。否则，完整的`PersonalInfo`组件子树可以被跳过。
- en: By setting the `PersonalInfo` component property `changeDetection` to `ChangeDetectionStrategy.OnPush`,
    we instruct Angular to trigger change detection only when the component's inputs
    change.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`PersonalInfo`组件属性`changeDetection`设置为`ChangeDetectionStrategy.OnPush`，我们指示Angular只在组件的输入发生变化时触发变化检测。
- en: 'If we change the change detection strategy to `OnPush` for each of the Employee
    component children and update the employee''s personal info, only the `PersonalInfo`
    component subtree is checked for changes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将每个Employee组件子代的变化检测策略更改为`OnPush`，并更新员工的个人信息，那么只有`PersonalInfo`组件子树会被检查是否有变化：
- en: '![Using immutable data structures](../Images/image00413.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![使用不可变数据结构](../Images/image00413.jpeg)'
- en: For a large component tree, such an optimization will improve the app/view performance
    manifold.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型组件树，这样的优化将大大提高应用程序/视图性能。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When set to `OnPush`, Angular triggers change detection only when the component's
    input property changes or there is an event raise inside the component or its
    children.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置为`OnPush`时，Angular只有在组件的输入属性发生变化或组件或其子代内部触发事件时才会触发变化检测。
- en: Developing applications using immutable data structures departs from the standard
    development paradigm where the applicate state is totally mutable. What we have
    highlighted in this section is how Angular takes advantage of immutable data structures
    to optimize the change detection process.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变数据结构开发应用程序偏离了标准的开发范式，其中应用状态是完全可变的。我们在本节中重点介绍了Angular如何利用不可变数据结构来优化变化检测过程。
- en: '*Observables* are another kind of data structure that can help us optimize
    Angular change detection.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*可观察对象*是另一种数据结构，可以帮助我们优化Angular的变化检测。'
- en: Using Observables
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可观察对象
- en: '**Observables** are data structures that trigger events when their internal
    state changes. The Angular *eventing infrastructure* extensively uses *observables*
    to communicate the components'' internal state to the outside world.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察对象**是在其内部状态发生变化时触发事件的数据结构。Angular的*事件基础设施*广泛使用*可观察对象*来将组件的内部状态传达给外部世界。'
- en: While we have used observable *output * *properties* (the `EventEmitter` class)
    to raise events, *input * *properties* too can take observables. Such observable
    inputs can help Angular optimize change detection.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经使用可观察对象*输出属性*（`EventEmitter`类）来触发事件，但*输入属性*也可以接受可观察对象。这样的可观察对象输入可以帮助Angular优化变化检测。
- en: When using observables, the change detection switch still remains `ChangeDetectionStrategy.OnPush`.
    But this time, only if a component input triggers an event (as they are observables)
    will Angular perform the dirty check. When the input triggers an event, the complete
    component tree path, starting from the affected component to the root, is marked
    for verification.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可观察对象时，变化检测开关仍然保持为`ChangeDetectionStrategy.OnPush`。但这次，只有当组件输入触发事件（因为它们是可观察的）时，Angular才会执行脏检查。当输入触发事件时，从受影响的组件到根的完整组件树路径都被标记为需要验证。
- en: When performing the view update, Angular will only sync the affected path and
    ignore the rest of the tree.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行视图更新时，Angular只会同步受影响的路径，忽略其余部分的树。
- en: Manual change detection
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动变化检测
- en: 'We can actually disable change detection on a component completely and trigger
    manual change detection when required. To disable change detection, we just need
    to inject the component-specific change detector (the `ChangeDetectorRef` class
    instance) into the component and call the `detach` function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以完全禁用组件上的变更检测，并在需要时触发手动变更检测。要禁用变更检测，我们只需要将组件特定的变更检测器（`ChangeDetectorRef`类的实例）注入到组件中，并调用`detach`函数：
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now the onus is on us to inform Angular when the component should be checked
    for changes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通知 Angular 在何时检查组件的变更。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can reattach the component to the change detection tree by using the `reattach`
    function on `ChangeDetectorRef.`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ChangeDetectorRef`上的`reattach`函数将组件重新附加到变更检测树上。
- en: 'The `ChangeDetectorRef` class has two functions that can be utilized for manual
    change detection:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChangeDetectorRef`类有两个可用于手动变更检测的函数：'
- en: '`markForCheck`: This marks the path from the detector to the root for dirty
    checking. Remember, the actual dirty check is only performed once all of the app
    code has executed, and not as soon as we call `markForCheck`. This snippet shows
    the use of this function:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markForCheck`：这标记了从检测器到根的路径进行脏检查。请记住，实际的脏检查只有在所有应用程序代码执行完毕后才会执行，而不是在我们调用`markForCheck`时立即执行。这段代码展示了这个函数的使用：'
- en: '[PRE15]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`detectChanges`: This function actually performs change detection on the component
    on which it is called (and its children). Using `detectChanges` is like isolating
    the tree from the rest of the application and performing local change detection.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detectChanges`：此函数实际上在调用它的组件（及其子组件）上执行变更检测。使用`detectChanges`就像将树与应用程序的其余部分隔离开，并执行局部变更检测。'
- en: We seldom need to disable the standard change detector setup, unless there are
    situations where standard change detection becomes an expensive affair.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除非标准变更检测变得昂贵，我们很少需要禁用标准变更检测设置。
- en: Take, for example, a public chatroom app, which is receiving messages from thousands
    of people connected to it. If we constantly keep pulling the messages and refreshing
    the DOM, the app may become unresponsive. In such a scenario, we can disable change
    detection on parts of the chat app component tree and manually trigger change
    detection to update the UI at specific intervals.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，一个公共聊天室应用程序，它接收来自连接到它的成千上万人的消息。如果我们不断地拉取消息并刷新 DOM，应用程序可能会变得无响应。在这种情况下，我们可以禁用聊天应用程序组件树的部分的变更检测，并在特定间隔手动触发变更检测以更新
    UI。
- en: While we have seen three ways to tweak change detection behavior, the good thing
    is that these are not exclusive. Parts of the component tree can use immutable
    data structures, parts can use observables, parts can employ manual change detection,
    and the rest can still use the default change detection. And Angular will happily
    oblige!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经看到了三种调整变更检测行为的方法，但好处在于这些方法并不是互斥的。组件树的部分可以使用不可变数据结构，部分可以使用 observables，部分可以使用手动变更检测，其余部分仍然可以使用默认的变更检测。Angular
    将乐意配合！
- en: Enough on change detection for now. We may never need it unless we are building
    some large views with a chatty UI. Such scenarios require us to squeeze every
    bit of performance out of the change detection system, and the system is ready
    for it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于变更检测就说到这里。除非我们正在构建一些具有繁忙 UI 的大型视图，否则我们可能永远不需要它。这种情况需要我们从变更检测系统中挤出每一点性能，而系统已经为此做好了准备。
- en: 'Next, we will have a look at another common requirement that most apps invariably
    have: authenticating their users.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下大多数应用程序不可避免地具有的另一个常见需求：对其用户进行身份验证。
- en: Handling authentication and authorization
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理身份验证和授权
- en: Most, if not all, apps have a requirement to authenticate/authorize their users.
    We may argue that authentication and authorization are more of a server concern
    than a client one, and that is correct. Still, the client side needs to adapt
    and integrate with the authentication and authorization requirement imposed by
    the server.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数，如果不是所有的应用程序都有要求对其用户进行身份验证/授权。我们可以说身份验证和授权更多是服务器的问题而不是客户端的问题，这是正确的。但是，客户端需要适应并与服务器强加的身份验证和授权要求进行集成。
- en: In a typical app execution workflow, the app first loads the partial views,
    then makes calls to pull data from the server, and finally binds data to its view.
    Clearly, the views and the remote data API are two assets that need to be secured.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的应用程序执行工作流程中，应用程序首先加载部分视图，然后从服务器获取数据，并最终将数据绑定到其视图。显然，视图和远程数据API是需要进行安全保护的两个资产。
- en: 'To guard these resources, you need to understand how a typical application
    is secured on the server. There are primarily two broad approaches to securing
    any web applications: *cookie-based authentication* and *token-based authentication*.
    Each of them requires different handling on the client part. The next two sections
    describe how we can integrate with either of these approaches.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护这些资源，您需要了解典型应用程序在服务器上是如何安全的。保护任何Web应用程序主要有两种广泛的方法：*基于Cookie的身份验证*和*基于令牌的身份验证*。它们每个都需要在客户端部分进行不同的处理。接下来的两节描述了我们如何与这两种方法中的任何一种集成。
- en: Cookie-based authentication
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于Cookie的身份验证
- en: 'This authentication mechanism is the easiest to implement if the server stack
    supports it. It''s non-intrusive and may require bare minimum changes to the Angular
    application. **Cookie-based authentication** involves setting the browser cookie
    to track the user authentication session. The following sequence diagram explains
    a typical cookie-based authentication workflow:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器堆栈支持，这种身份验证机制是最容易实现的。它是非侵入性的，可能对Angular应用程序的更改要求最少。**基于Cookie的身份验证**涉及设置浏览器cookie以跟踪用户身份验证会话。下面的序列图解释了典型的基于Cookie的身份验证工作流程：
- en: '![Cookie-based authentication](../Images/image00414.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![基于Cookie的身份验证](../Images/image00414.jpeg)'
- en: 'Here is how a typical authentication workflow works:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是典型的身份验证工作流程：
- en: When trying to access a secured resource from the browser, if the user is not
    authenticated, the server sends an HTTP 401 Unauthorized status code. As we will
    see later, a user request is an unauthorized request if there is no cookie attached
    to the request or the cookie is expired/invalid.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当尝试从浏览器访问受保护的资源时，如果用户未经身份验证，服务器会发送HTTP 401未经授权状态码。正如我们将在后面看到的那样，如果请求中没有附加cookie或者cookie已过期/无效，用户请求就是未经授权的请求。
- en: This unauthorized response is intercepted by the server or, at times, by the
    client framework (Angular in our case) and it typically results in a 302 redirect
    (if intercepted by the server). The redirect location is the URL to the login
    page (the login page allows anonymous access).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个未经授权的响应被服务器或者有时是客户端框架（在我们的情况下是Angular）拦截，通常会导致302重定向（如果被服务器拦截）。重定向的位置是登录页面的URL（登录页面允许匿名访问）。
- en: The user then enters the username and password on the login page and does a
    POST to the login endpoint.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后用户在登录页面上输入用户名和密码，并对登录端点进行POST。
- en: The server validates the credentials, sets a browser cookie, and redirects the
    user to the original requested resource.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器验证凭据，设置浏览器cookie，并将用户重定向到原始请求的资源。
- en: Henceforth, the authentication cookie is a part of every request (added by the
    browser automatically), and the server uses this cookie to confirm his identity
    and whether the user is authenticated.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，身份验证cookie是每个请求的一部分（由浏览器自动添加），服务器使用此cookie来确认用户的身份和用户是否已经通过身份验证。
- en: Note
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This scenario assumes that the HTML and API exist under a single domain.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况假设HTML和API存在于单个域下。
- en: As we can see, with this approach, the Angular infrastructure is not involved;
    or the involvement is minimal. Even the login page can be a standard HTML page
    that just sends data to the login endpoint for authentication. If the user lands
    on the Angular app, it implicitly means that the user has been authenticated.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，采用这种方法，Angular基础设施并不涉及；或者涉及很少。甚至登录页面可以是一个标准的HTML页面，只需将数据发送到登录端点进行身份验证。如果用户登陆到Angular应用程序，这意味着用户已经通过了身份验证。
- en: Note
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The cookie-based authentication flow may vary depending on the server framework,
    but the general pattern of setting a cookie and attaching a cookie with every
    subsequent request remains the same.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 基于cookie的身份验证流程可能会根据服务器框架而有所不同，但设置一个cookie并在随后的每个请求中附加一个cookie的一般模式仍然是相同的。
- en: In a cookie-based application authentication, if the application wants to get
    the user context, a server endpoint (such as `/user/details` ) is exposed that
    returns the logged-in-user-specific data. The client application can then implement
    a service such as `UserService` that loads and caches the user profile data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于cookie的应用程序身份验证中，如果应用程序想要获取用户上下文，那么会暴露一个服务器端点（如`/user/details`），返回已登录用户的特定数据。然后客户端应用程序可以实现一个诸如`UserService`的服务，加载并缓存用户配置文件数据。
- en: The scenario described here assumes that the API server (the server that returns
    data) and the site where the application is hosted are in a single domain. That
    may not be the case always. Even for *Personal Trainer*, the data resides on the
    *MongoLab* servers and the application resides on a different server (even if
    it is local). And we already know that this is a cross-domain access and it comes
    with its own set of challenges.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的情景假设API服务器（返回数据的服务器）和托管应用程序的站点位于单个域中。这并不总是情况。即使对于*个人健身教练*，数据存储在*MongoLab*服务器上，而应用程序存储在不同的服务器上（即使是本地）。我们已经知道这是一个跨域访问，并且它带来了自己一套挑战。
- en: In such a setup, even if the API server is able to authenticate the request
    and send a cookie back to the client, the client application still does not send
    the authentication cookie on a subsequent request.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的设置中，即使API服务器能够验证请求并向客户端发送一个cookie，客户端应用程序仍然不会在随后的请求中发送身份验证cookie。
- en: To fix this, we need to set a Boolean variable, `withCredentials`, to `true`
    on the XHR request. This can be enabled at the global level by overriding `BaseRequestOptions`
    (the `withCredentials` property). The framework uses the `BaseRequestOptions`
    class for the default HTTP request option. See the next section, *Token-based
    authentication*, to learn how to override `BaseRequestOptions`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要在XHR请求中将一个布尔变量`withCredentials`设置为`true`。这可以通过覆盖`BaseRequestOptions`（`withCredentials`属性）在全局级别启用。框架使用`BaseRequestOptions`类作为默认的HTTP请求选项。请参阅下一节，*基于令牌的身份验证*，了解如何覆盖`BaseRequestOptions`。
- en: 'This can also be enabled on a per-request level by passing in the `withCredentials:true`
    flag in each HTTP request method as the last parameter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过在每个HTTP请求方法的最后一个参数中传递`withCredentials:true`标志来在每个请求级别上启用：
- en: '[PRE16]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last parameter to every HTTP function, including `get`, `post`, and `put`,
    is a `RequestOptionsArgs` object. This allows us to override some properties of
    the request being made.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP函数的最后一个参数，包括`get`、`post`和`put`，都是一个`RequestOptionsArgs`对象。这允许我们覆盖正在进行的请求的一些属性。
- en: Once this flag is enabled, the client browser will start attaching the authentication
    cookie for the cross-domain requests.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了这个标志，客户端浏览器将开始为跨域请求附加身份验证cookie。
- en: The server too needs to have **cross-origin resource sharing** (**CORS**) enabled
    and needs to respond in a specific manner for the request to succeed. It should
    set the **access-control-allow-credentials** header to true and the **access-control-allow-origin**
    header to the host site making the request.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也需要启用**跨域资源共享**（**CORS**），并且需要以特定方式响应请求才能成功。它应该将**access-control-allow-credentials**标头设置为true，并将**access-control-allow-origin**标头设置为发出请求的主机站点。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Check out the MDN documentation ([http://bit.ly/http-cors](http://bit.ly/http-cors))
    to learn about this scenario in detail.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 查看MDN文档（[http://bit.ly/http-cors](http://bit.ly/http-cors)）以详细了解这种情况。
- en: 'Cookie-based authentication is definitely less work on the client side, but
    there are times when you have to revert to token-based access. This could be because:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 基于cookie的身份验证在客户端方面确实更省事，但有时您必须返回到基于令牌的访问。这可能是因为：
- en: Cookies and cross-domain requests do not play nicely across browsers. Specifically,
    IE8 and IE9 do not support it.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie和跨域请求在各种浏览器中表现不佳。特别是，IE8和IE9不支持它。
- en: The server may not support generating cookies, or the server only exposes token-based
    authentication.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器可能不支持生成cookie，或者服务器只暴露基于令牌的身份验证。
- en: Token-based solutions are easy to integrate with native mobile application and
    desktop clients.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的解决方案易于与原生移动应用程序和桌面客户端集成。
- en: Tokens are not susceptible to cross-site request forgery (CSRF) attacks.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌不容易受到跨站点请求伪造（CSRF）攻击的影响。
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To know more about CSRF, look at the CRSF Prevention cheat sheet here at [http://bit.ly/csrf-cs](http://bit.ly/csrf-cs).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关CSRF的更多信息，请查看这里的CRSF Prevention cheat sheet [http://bit.ly/csrf-cs](http://bit.ly/csrf-cs)。
- en: The next section talks about supporting token-based authentication.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论支持基于令牌的身份验证。
- en: Token-based authentication
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于令牌的身份验证
- en: '**Token-based access** is all about sending a token (typically in HTTP headers)
    with each request instead of a cookie. A simplified token-based workflow looks
    something like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的访问是指在每个请求中发送令牌（通常在HTTP标头中），而不是cookie。简化的基于令牌的工作流程看起来像这样：
- en: '![Token-based authentication](../Images/image00415.jpeg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![基于令牌的身份验证](../Images/image00415.jpeg)'
- en: Many public APIs (such as *Facebook* and *Twitter*) use token-based authentication.
    The format of the token, where it goes, and how it is generated depends on the
    protocol used and the server implementation. Popular services that use token-based
    authentication implement the **OAuth 2.0** protocol for token generation and exchange.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公共API（如*Facebook*和*Twitter*）使用基于令牌的身份验证。令牌的格式、它的去向以及如何生成取决于所使用的协议和服务器实现。使用基于令牌的身份验证的流行服务实施**OAuth
    2.0**协议进行令牌生成和交换。
- en: In a typical token-based authentication setup, the views are available publically
    but the API is secured. If the application tries to pull data through API calls
    without attaching the appropriate token to the outgoing request, the server returns
    an *HTTP 401 Unauthorized* status code.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于令牌的身份验证设置中，视图是公开可用的，但API是受保护的。如果应用程序尝试通过API调用拉取数据而没有将适当的令牌附加到传出请求中，服务器将返回HTTP
    401未经授权的状态代码。
- en: Integrating with a token-based authentication system requires a decent amount
    of setup on the client side too. Let's take the simplified example of a *Human
    Resource (HR)* system that supports token-based authentication so that you understand
    how the authentication workflow works with the Angular application as a client.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于令牌的身份验证系统集成还需要在客户端方面进行相当多的设置。让我们以支持基于令牌的身份验证的*人力资源（HR）*系统为例，以便您了解身份验证工作流程如何与作为客户端的Angular应用程序一起工作。
- en: The HR system has a page showing a list of employees and a login page. It also
    has API endpoints to get a list of employees and generate access tokens. The API
    endpoint that returns the employee list is secured by token-based access.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: HR 系统有一个显示员工列表和登录页面的页面。它还有用于获取员工列表和生成访问令牌的 API 端点。返回员工列表的 API 端点受基于令牌的访问控制。
- en: The workflow starts with the user loading the employee list page. The view is
    loaded but the API call fails, with the server returning *HTTP 401 Unauthorized*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程从用户加载员工列表页面开始。视图加载了，但 API 调用失败，服务器返回 *HTTP 401 未经授权*。
- en: On receiving a 401 HTTP error code, the app should respond by either routing
    the user to a login view (remember this is an SPA) or opening a login popup.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到 401 HTTP 错误代码时，应用程序应该通过将用户路由到登录视图（记住这是一个单页应用程序）或打开登录弹出窗口来做出响应。
- en: 'A naive implementation for this could be:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的天真实现可能是：
- en: '[PRE17]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The biggest problem with the preceding implementation is that we need to add
    the catch block to every component that requires remote data access as the call
    may fail. Not very smart!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 前面实现的最大问题是我们需要为每个需要远程数据访问的组件添加 catch 块，因为调用可能会失败。不太聪明！
- en: Instead we have to centralize this check. Given that an Angular app is basically
    a component tree, such a check can be added to a top-level component. The `canActivate`
    component guard hook will be the right place to add this check.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须将这个检查集中起来。鉴于 Angular 应用基本上是一个组件树，这样的检查可以添加到顶层组件中。`canActivate` 组件守卫钩子将是添加这个检查的正确位置。
- en: 'So given this route configuration on the app root:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在应用根目录上给出了这个路由配置：
- en: '[PRE18]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To block unauthorized access to `/home`, we can implement the `canActivate`
    guard class as:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止对 `/home` 的未经授权访问，我们可以实现 `canActivate` 守卫类如下：
- en: '[PRE19]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And then extend the route definition for home to include this guard:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后扩展 home 的路由定义以包括这个守卫：
- en: '[PRE20]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To understand how the `canActivate` function can be implemented, we need to
    know what happens on the client during token authentication.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何实现 `canActivate` 函数，我们需要知道在令牌身份验证期间客户端发生了什么。
- en: With token-based authentication, the login page looks similar to a cookie-based
    login page, but instead of cookies being set on the server as part of the login
    process, a token is returned. This token needs to be attached to all subsequent
    API requests that are secure. This token hence needs to be persisted in the *browser's
    local storage*, and all this is done the first time the token is received.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于令牌的身份验证，登录页面看起来类似于基于 cookie 的登录页面，但是在登录过程的一部分，服务器会返回一个令牌，而不是在服务器上设置 cookie。这个令牌需要附加到所有后续的安全
    API 请求中。因此，这个令牌需要在*浏览器的本地存储*中持久化，并且这是在第一次接收到令牌时完成的。
- en: 'An *authentication service* can perform such chores. A sample implementation
    of the service looks like:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份验证服务*可以执行这样的任务。服务的一个示例实现如下：'
- en: '[PRE21]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The service does an HTTP `post` to the login endpoint, and on receiving the
    authentication token, it stores the token in the browser's local storage.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对登录端点进行 HTTP `post`，并在接收到身份验证令牌时，将令牌存储在浏览器的本地存储中。
- en: Post authentication, the next task is to attach the token on subsequent requests
    that access the secured API resource. For most API implementations, this token
    needs to be added to the request header.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证后，下一个任务是在访问受保护的 API 资源的后续请求中附加令牌。对于大多数 API 实现，这个令牌需要添加到请求头中。
- en: 'All `http` service functions: `get`, `post`, and others-take an extra parameter
    of type `RequestOptionsArgs`, used to pass some extra parameter to the request.
    We can use the `headers` property to set the *auth token* for HTTP requests that
    require authorization. The name of the token may vary based on the backend implementation,
    but this is how a typical request with a token looks:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`http`服务函数：`get`，`post`和其他-都需要一个额外的`RequestOptionsArgs`类型参数，用于传递一些额外的参数给请求。我们可以使用`headers`属性为需要授权的HTTP请求设置*auth
    token*。令牌的名称可能根据后端实现而有所不同，但这是一个典型的带有令牌的请求的样子：
- en: '[PRE22]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although this approach works, it's quite verbose and cumbersome. Each call to
    the secured API now needs this extra parameter to be set. We need some better
    alternatives.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法有效，但非常冗长和繁琐。现在每次调用安全API都需要设置这个额外的参数。我们需要一些更好的替代方案。
- en: 'Angular has a `BaseRequestOptions` class that contains the default options
    for an HTTP request. We can replace `BaseRequestOptions` with our own options
    using Angular DI. This can be done by inheriting from the `BaseRequestOptions`
    class and overriding the DI provider for `BaseRequestOptions` during bootstrap:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有一个`BaseRequestOptions`类，其中包含HTTP请求的默认选项。我们可以使用Angular DI将`BaseRequestOptions`替换为我们自己的选项。这可以通过继承`BaseRequestOptions`类并在引导期间覆盖`BaseRequestOptions`的DI提供程序来实现：
- en: '[PRE23]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Sadly, this doesn't work! Since the authorization token is not available till
    authentication is done, setting up `RequestOptions` during bootstrap will result
    in an empty `Authorization` header being set on all future HTTP requests.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 可悲的是，这不起作用！因为在进行身份验证之前授权令牌不可用，所以在引导期间设置`RequestOptions`将导致所有未来的HTTP请求上设置一个空的`Authorization`头部。
- en: Tip
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Overriding `RequestOptions` during bootstrapping is only useful if we have the
    necessary content available during that phase.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导期间覆盖`RequestOptions`只有在我们在那个阶段有必要的内容可用时才有用。
- en: What other options are we left with? Angular 2, unlike Angular 1, does not have
    **global interceptors** that can be used to inject the headers before the request
    is made. Therefore, the only viable alternative is to create a custom HTTP client
    service to communicate with the secure API. This service can attach the token
    transparently when available.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有什么其他选择？与Angular 1不同，Angular 2没有**全局拦截器**可以在请求发出之前用于注入头部。因此，唯一可行的替代方案是创建一个自定义的HTTP客户端服务来与安全API通信。当可用时，该服务可以透明地附加令牌。
- en: We have created a sample service implementation for this purpose and the implementation
    is available at [http://bit.ly/ng2-auth-svc](http://bit.ly/ng2-auth-svc). We will
    be highlighting some relevant parts of this `AuthHttp` service.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为此创建了一个示例服务实现，该实现可在[http://bit.ly/ng2-auth-svc](http://bit.ly/ng2-auth-svc)上找到。我们将重点介绍这个`AuthHttp`服务的一些相关部分。
- en: 'This `AuthHttp` exposes the same interface as the HTTP service, with its function
    internally delegating the request to the original `http` service. The next snippets
    detail two such HTTP functions, `get` and `post`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`AuthHttp`暴露了与HTTP服务相同的接口，它的函数在内部将请求委托给原始的`http`服务。下面的片段详细介绍了两个这样的HTTP函数，`get`和`post`：
- en: '[PRE24]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each of the HTTP function wrappers internally calls the `_request` private
    method. This function does most of the heavy lifting, which involves setting the
    HTTP authorization header, making a request, and receiving the response. The function
    implementation looks like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP函数包装器内部都调用`_request`私有方法。这个函数大部分工作都是设置HTTP授权头部，发出请求和接收响应。函数的实现看起来像这样：
- en: '[PRE25]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After merging the request options and setting the authorization header, the
    function creates a custom observable that makes a request using the `http` service
    `request` function. On receiving a response, the observer emits the response and
    is marked complete (no more events).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并请求选项并设置授权标头之后，该函数创建一个自定义可观察对象，使用`http`服务的`request`函数发出请求。在收到响应后，观察者发出响应并标记为完成（没有更多事件）。
- en: '*401* error handling is a bit different in the preceding function. The function
    calls `this.authFailed.next(err)` and raises an event on an `EventEmitter` defined
    on the `AuthHttp` class:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，*401*错误处理有点不同。该函数调用`this.authFailed.next(err)`并在`AuthHttp`类上定义的`EventEmitter`上引发事件：
- en: '[PRE26]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then it triggers the standard error triggering mechanism with `observer.error(err)`;
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它使用`observer.error(err)`触发标准的错误触发机制；
- en: The usefulness of this event will be clear pretty soon.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件的用处很快就会变得清楚。
- en: 'The `_buildAuthHeader` implementation is simple as it pulls the authorization
    token from the browser''s local storage:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`_buildAuthHeader`的实现很简单，它从浏览器的本地存储中获取授权令牌：'
- en: '[PRE27]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This service can now be injected and used to invoke any secure API, such as:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以注入此服务并用于调用任何安全API，例如：
- en: '[PRE28]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This call will add the authorization token if available to the API request.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用将在API请求中添加授权令牌（如果可用）。
- en: What have we done thus far? The views have been secured using the `@CanActivate`
    decorator and the API endpoints are secured too, but there is still one scenario
    that needs to be handled. What happens when the token expires?
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们做了什么？视图已经使用`@CanActivate`装饰器进行了保护，API端点也是安全的，但仍然有一个需要处理的情况。令牌过期时会发生什么？
- en: When the API token expires, any access to API endpoints again results in 401
    errors. In such a scenario, the app should either redirect to the login page or
    show a login popup to continue.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当API令牌过期时，再次访问API端点会导致401错误。在这种情况下，应用程序应该要么重定向到登录页面，要么显示登录弹出窗口以继续。
- en: To know when a request failed, we again use the `AuthHttp` service. The `authFailed`
    event on `AuthHttp` can be subscribed to. The best place to subscribe and react
    to this event would be in the *root component implementation*.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道请求失败时，我们再次使用`AuthHttp`服务。可以订阅`AuthHttp`上的`authFailed`事件。订阅和对此事件做出反应的最佳位置将是*根组件实现*。
- en: 'In the root component of the app, we just need to do:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的根组件中，我们只需要做：
- en: '[PRE29]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And with that, we have now handled most of the scenarios related to token-based
    authentication.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一点，我们现在已经处理了大部分与基于令牌的身份验证相关的情况。
- en: Clearly, token-based authentication, even though flexible, requires a decent
    amount of setup and coordination among various components/services.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，基于令牌的身份验证，即使灵活，也需要在各种组件/服务之间进行相当数量的设置和协调。
- en: This walkthrough just outlines one mechanism to send a token to the server,
    but the process may vary based on the server stack too. Always refer to the backend/server
    documentation before implementing a token-based authentication in Angular.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程仅概述了向服务器发送令牌的一种机制，但该过程可能根据服务器堆栈而有所不同。在Angular中实现基于令牌的身份验证之前，始终参考后端/服务器文档。
- en: Note
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While working on this book, there were not many libraries out there that implemented
    these standard chores required for token-based authentication. In future, before
    you start, do check whether there is a popular/mature community offering for the
    same.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，并没有太多实现基于令牌的身份验证所需的标准任务的库。未来，在开始之前，请检查是否有相同的流行/成熟社区提供。
- en: We have taken care of authentication, but what about authorization? Once the
    user context is established, we still need to make sure that the user is only
    able to access parts that he/she is allowed to. *Authorization* is still missing.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了身份验证，但授权呢？一旦用户上下文建立，我们仍然需要确保用户只能访问他/她被允许访问的部分。*授权*仍然缺失。
- en: Handling authorization
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理授权
- en: Like authentication, authorization support too needs to be implemented on both
    the server and client side, more so on the server than the client. Remember, anyone
    can hack into the JavaScript code and circumvent the complete authentication/authorization
    setup. So, always tighten your server infrastructure irrespective of whether the
    client has the necessary checks in place or not.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 与身份验证一样，授权支持也需要在服务器和客户端上实现，尤其是在服务器端而不是客户端。请记住，任何人都可以入侵JavaScript代码并规避完整的身份验证/授权设置。因此，无论客户端是否具有必要的检查，都应始终加强服务器基础设施。
- en: This still does not mean that we do not do any authorization check, on the client.
    For standard users, this is the first line of defence against unwarranted access.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们在客户端不进行任何授权检查。对于标准用户来说，这是防止未经授权访问的第一道防线。
- en: 'When working on an authorization requirement for any application, there are
    three essential elements that are part of the setup:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何应用程序的授权需求时，有三个基本元素是设置的一部分：
- en: The resources that need to be secured/authorized
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要进行安全/授权的资源
- en: A list of roles and users that are part of these roles
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色和属于这些角色的用户列表
- en: A mapping between the resources and the roles that defines who can access what
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源和角色之间的映射，定义了谁可以访问什么
- en: From an Angular app perspective, the resources are the pages and, sometimes,
    sections of pages that need to be restricted to specific roles. If the user is
    in a specific role, depending upon the role-resource mapping, they get access
    to some pages; else they are denied access.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular应用程序的角度来看，资源是需要限制到特定角色的页面，有时也包括页面的部分。如果用户处于特定角色，根据角色-资源的映射，他们可以访问一些页面；否则他们将被拒绝访问。
- en: While authorization in an Angular application can be implemented in a number
    of ways, we will outline a generic implementation that can be further customized
    to suite your needs in the future.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Angular应用程序中可以以多种方式实现授权，但我们将概述一种通用实现，可以根据未来的需求进行进一步定制。
- en: Adding authorization support
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加授权支持
- en: To enable authorization, the first thing that we need to do is expose the logged-in
    user data, including his/her roles throughout the application.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用授权，我们需要做的第一件事是在整个应用程序中公开已登录用户的数据，包括他/她的角色。
- en: Sharing user authentication context
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享用户身份验证上下文
- en: 'User context can be shared using an Angular service, which can then be injected
    into components that require the authorization context. Look at this service interface:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 用户上下文可以使用Angular服务共享，然后注入到需要授权上下文的组件中。查看此服务接口：
- en: '[PRE30]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `SessionContext` service tracks the user login session and provides details
    such as:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionContext`服务跟踪用户登录会话，并提供以下详细信息：'
- en: The logged-in user (`currentUser`)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已登录用户（`currentUser`）
- en: Whether the user is authenticated (`isAuthenticated`)
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否经过身份验证（`isAuthenticated`）
- en: The `isUserInRole` function, which returns `true` or `false` based on whether
    the user is part of any of the roles passed into the `roles` parameter
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isUserInRole`函数根据传入`roles`参数的角色，返回`true`或`false`'
- en: With such a service in place, we can add authorization for routes, thereby restricting
    access to some routes to specific roles only.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样一个服务，我们可以为路由添加授权，从而仅限制特定角色访问某些路由。
- en: Restricting routes
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制路由
- en: 'Like authentication, the `canActivate` guard check can also be used for authorization.
    Implement a class with the `CanActivate` interface and inject the `SessionContext`
    service into the constructor; then check whether the user belongs to a specific
    role in the `canActivate` function using the `SessionContext` service. Check out
    the following code snippet:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 像身份验证一样，`canActivate`守卫检查也可以用于授权。实现一个带有`CanActivate`接口的类，并将`SessionContext`服务注入到构造函数中；然后在`canActivate`函数中使用`SessionContext`服务检查用户是否属于特定角色。请查看以下代码片段：
- en: '[PRE31]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Only users with roles of *Contributor* and *Admin* now have access to Home.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有*Contributor*和*Admin*角色的用户才能访问主页。
- en: We register the preceding guard class with our routes in the same manner as
    we did earlier in the *Token-based Authentication* section.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与*基于令牌的身份验证*部分相同的方式在路由中注册前面的守卫类。
- en: And this is how we authorized access to our routes.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们授权访问我们的路由的方式。
- en: But what happens when a page has view elements that are rendered based on the
    user's role?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当页面上的视图元素是根据用户的角色渲染时会发生什么？
- en: Conditionally rendering content based on roles
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于角色有条件地渲染内容
- en: 'Conditionally rendering content is easy to implement. We just need to show/hide
    HTML elements based on the user role. We can build a *structural directive* such
    as `ng-if` that can verify that the user belongs to a role before rendering the
    content. The directive usage looks like:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有条件地渲染内容很容易实现。我们只需要根据用户角色显示/隐藏HTML元素。我们可以构建一个*结构指令*，比如`ng-if`，它可以在渲染内容之前验证用户是否属于某个角色。指令的使用方式如下：
- en: '[PRE32]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code checks whether the user is in an admin role before rendering
    a **Site Setting** hyperlink.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在渲染**站点设置**超链接之前检查用户是否处于管理员角色。
- en: 'The directive implementation mimics how `ng-if` works, except that our show/hide
    logic depends upon the `SessionContext` service. Here is a sample implementation
    for the `a2beRolesAllowed` directive:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的实现模仿了`ng-if`的工作方式，只是我们的显示/隐藏逻辑取决于`SessionContext`服务。以下是`a2beRolesAllowed`指令的示例实现：
- en: '[PRE33]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a trivial implementation that uses `SessionContext` and the roles passed
    as input (`a2beRolesAllowed`) to show hide a fragment.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`SessionContext`和作为输入传递的角色（`a2beRolesAllowed`）来显示或隐藏片段的微不足道的实现。
- en: This brings us to the end of authentication and authorization implementation.
    The reference implementation walkthrough should help us build authentication and
    authorization into our apps. With this basic understanding in place, any setup
    can be tweaked to handle other custom authentication/authorization scenarios.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到了身份验证和授权实现的尽头。参考实现演练应该帮助我们将身份验证和授权构建到我们的应用中。有了这个基本的理解，任何设置都可以被调整以处理其他自定义的身份验证/授权场景。
- en: 'It''s now time to address the elephant in the room: migrating from Angular
    1 to Angular 2\. If you are starting afresh on Angular 2, you can very well skip
    the next section.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决房间里的大象了：从Angular 1迁移到Angular 2。如果您在Angular 2上重新开始，您可以很好地跳过下一节。
- en: Migrating Angular 1 apps
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移Angular 1应用
- en: 'If you have been working extensively on Angular 1, Angular 2 poses some pertinent
    questions:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Angular 1上进行了大量工作，那么Angular 2会提出一些相关的问题：
- en: Should I migrate my Angular 1 apps to Angular 2?
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该将我的Angular 1应用迁移到Angular 2吗？
- en: Is the framework ready for prime time?
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架是否已经准备好投入使用？
- en: When should the migration happen?
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移应该何时发生？
- en: Is the migration one-shot or can it be done in an incremental fashion?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移是一次性的还是可以分阶段进行？
- en: What is the effort involved?
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及的工作量是多少？
- en: Can I do something today that helps with the migration in the future?
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天我能做些什么，以帮助未来的迁移？
- en: I am starting with a new Angular 1 app today. What should I do to make the migration
    seamless in the future when Angular 2 is released?
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天我要开始一个新的Angular 1应用。当Angular 2发布时，我应该怎么做才能使迁移无缝进行呢？
- en: Every such query needs be addressed to make sure the transition is as smooth
    as possible. No one like surprises later in the game! In the coming sections,
    we will try to answer a number of such questions. As part of the learning, we
    will also walk you through migrating the Angular 1 version of the Trainer app
    (developed for the first version of this book) to Angular 2\. This will help everyone
    make some informed decisions on when and how to migrate to Angular 2.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保过渡尽可能顺利，每个这样的问题都需要得到解决。在接下来的章节中，我们将尝试回答许多这样的问题。作为学习的一部分，我们还将带您逐步将Trainer应用的Angular
    1版本（为本书第一版开发）迁移到Angular 2。这将帮助每个人做出一些明智的决定，决定何时以及如何迁移到Angular 2。
- en: '"Should I migrate or not?" is something that we will address first.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: “我应该迁移还是不迁移？”这是我们首先要解决的问题。
- en: Should I migrate?
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我应该迁移吗？
- en: Just because Angular 2 is here does not mean Angular 1 is gone. Angular 1 is
    still being actively developed in parallel with Angular 2\. Google is committed
    to supporting Angular 1 for a good amount of time, and there have been a steady
    number of releases in Angular 1, with Angular 1.5 released in Feb 2016\. Given
    that Angular 1 will not be going away any time soon, we can think from our app's
    perspective now.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2的出现并不意味着Angular 1消失。Angular 1仍在与Angular 2并行进行积极开发。Google承诺将长时间支持Angular
    1，并且在Angular 1中已经发布了一系列版本，其中包括2016年2月发布的Angular 1.5。鉴于Angular 1短时间内不会消失，我们现在可以从我们应用的角度来考虑。
- en: First things first, what has Angular 2 to offer over its predecessor?
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Angular 2相比于其前身有什么优势？
- en: Advantages of Angular 2
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular 2的优势
- en: Angular 2 is designed for the future and overcomes a number of shortcomings
    of its predecessor. In this section, we emphasize on what makes Angular 2 a better
    framework than Angular 1.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2是为未来设计的，并克服了其前身的许多缺点。在本节中，我们强调了Angular 2比Angular 1更好的框架的特点。
- en: 'Things you should be aware of while making a decision to move to Angular 2:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否迁移到Angular 2时，您应该注意的事项：
- en: '**Better behavioral encapsulation**: Admittedly, while Angular 1 scopes seem
    to be god sent when we started learning Angular 1, we have now realized how difficult
    it is to manage the hierarchical nature of scopes. Component-based development
    in Angular 2 provides a better encapsulation in terms of the state of the application.
    A component manages its own state, takes input, and raises events: a clear demarcation
    of responsibilities that are easy to reason with!'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的行为封装**：诚然，当我们开始学习Angular 1时，作用域似乎是上帝赐予的，但现在我们意识到了管理层次性质的作用域是多么困难。Angular
    2中的基于组件的开发在应用状态方面提供了更好的封装。组件管理自己的状态，接受输入，并触发事件：这是一种易于理解的责任清晰划分！'
- en: '**Less of framework in app code**: You don''t need special objects such as
    scope. DI works with annotation (in TypeScript). You don''t set up watches. All
    in all, when reading a component code, you will not find framework-level constructs
    in it.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用代码中的框架减少**：您不需要像作用域这样的特殊对象。DI使用注解（在TypeScript中）。您不需要设置监视。总的来说，当阅读组件代码时，您不会在其中找到框架级别的构造。'
- en: '**Smaller framework API to explore**: Angular 1 had a host of directives that
    one had to be aware of. With Angular 2 template syntax, directives related to
    browser events are gone. This reduces the number of directives that one needs
    to be aware of.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的框架API可供探索**：Angular 1有许多指令需要了解。而在Angular 2模板语法中，与浏览器事件相关的指令已经消失。这减少了需要了解的指令数量。'
- en: '**Performance**: Angular 2 is faster compared to its predecessor. A complete
    section of this book was dedicated to understanding what makes Angular 2 a high-performance
    framework.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：与其前身相比，Angular 2更快。本书的一个完整部分专门讨论了什么使Angular 2成为高性能框架。'
- en: '**Mobile-friendly**: Angular 2 tries to optimize the user''s mobile experience
    by utilizing technologies such as server-side rendering and web workers. Angular
    2 applications on mobile are more performant that those of its predecessor.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动友好**：Angular 2试图通过利用诸如服务器端渲染和Web Workers等技术来优化用户的移动体验。在移动设备上，Angular 2应用程序比其前身更具性能。'
- en: '**Cross-platform**: Angular 2 targets to run on most devices and across platforms.
    You can use Angular 2 to build applications for web and mobile. As we learned
    earlier, the separation of the rendering layer has open up a great number of possibilities
    in terms of where Angular 2 can be utilized.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：Angular 2的目标是在大多数设备和各种平台上运行。您可以使用Angular 2构建Web和移动应用程序。正如我们之前所了解的，渲染层的分离为Angular
    2的利用提供了大量可能性。'
- en: In true sense, Angular 2 supersedes its predecessor, and in a perfect world,
    everyone should be working on a better framework/technology. But if you are the
    cautious type and want to try Angular 2 only once things become stable, we suggest
    you build your Angular 1 apps today in ways that allow easy migration to Angular
    2.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 从真正意义上讲，Angular 2取代了其前身，在一个完美的世界中，每个人都应该在更好的框架/技术上工作。但是，如果您是谨慎的类型，并且希望在事情变得稳定之后尝试Angular
    2，我们建议您今天构建您的Angular 1应用程序的方式，以便轻松迁移到Angular 2。
- en: The next section talks about the principles and practices to follow for Angular
    1 today, allowing easy migration in future.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节讨论了今天遵循的Angular 1的原则和实践，以便未来方便迁移。
- en: Developing Angular 1 apps today for easy migration
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 今天为易迁移开发Angular 1应用程序
- en: Angular 2 is a paradigm shift and the way we develop components in Angular 2
    is quite different from Angular 1\. For easy migration, Angular 1 too should embrace
    component-based development. This can be achieved if we follow some guidelines/principles
    while building Angular 1 apps. The next few sections detail these guidelines.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2是一个范式转变，我们在Angular 2中开发组件的方式与Angular 1完全不同。为了方便迁移，Angular 1也应该采用基于组件的开发。如果我们在构建Angular
    1应用程序时遵循一些准则/原则，就可以实现这一点。接下来的几节将详细介绍这些准则。
- en: Tip
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The advices listed here are highly recommended even if you do not plan to migrate
    to Angular 2\. These recommendation bits will make Angular 1 code more modular,
    organized, and testable.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不打算迁移到Angular 2，这里列出的建议也是强烈推荐的。这些建议将使Angular 1代码更加模块化、有组织和可测试。
- en: One component per file
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个文件一个组件
- en: 'This can be anything: an Angular 1 *controller*, *directive*, *filter*, or
    *service*. One component per file allows better organization of code and easy
    migration, allowing us to clearly identify how much progress has been made.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是任何东西：一个Angular 1 *控制器*、*指令*、*过滤器*或*服务*。一个文件一个组件可以更好地组织代码并实现轻松迁移，使我们能够清楚地识别已经取得了多少进展。
- en: Avoiding inline anonymous functions
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免内联匿名函数
- en: 'Use named functions instead to declare controllers, directives, filters, and
    services. A declaration such as this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名函数而不是内联匿名函数来声明控制器、指令、过滤器和服务。这样的声明：
- en: '[PRE34]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Should be converted to this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 应该转换为：
- en: '[PRE35]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The advantages of using named functions are ease of debugging and ease of migration
    to TypeScript. Using named functions also requires that the dependencies be registered
    using the `$inject` function property.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名函数的优点是易于调试和迁移到TypeScript。使用命名函数还要求使用`$inject`函数属性注册依赖项。
- en: Note
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`$inject`-based dependency declaration safeguards against minification and
    adds to the readability of the functions.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`$inject`的依赖声明可以防止缩小，并增加函数的可读性。
- en: 'To avoid exposing global name functions with this approach, it is advisable
    to wrap the function in an **Immediately Invoked Function Expression** (**IIFE**):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用这种方法暴露全局名称函数，建议将函数包装在**立即调用的函数表达式**（**IIFE**）中：
- en: '[PRE36]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Avoiding $scope!
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用$scope！
- en: Yes, you read it right; avoid the $scope object or using scopes directly!
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你读对了；避免使用$scope对象或直接使用作用域！
- en: The biggest problem with Angular 1 scopes is their hierarchical nature. Accessing
    the parent scope from the child scope gives us tremendous flexibility but it comes
    at a cost. This can unknowingly create unwarranted dependencies that make the
    app really hard to debug and, of course, migrate. In contrast, in Angular 2 a
    view is bound to its component implementation and cannot access data outside its
    boundary implicitly. Therefore, if you plan to migrate to Angular 2, *avoid scopes
    at all costs*.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1作用域最大的问题是它们的层次结构性质。从子作用域访问父作用域给了我们巨大的灵活性，但代价是很高的。这可能会不知不觉地创建不必要的依赖，使应用程序变得非常难以调试和迁移。相比之下，在Angular
    2中，视图绑定到其组件实现，不能隐式地访问其边界之外的数据。因此，如果你计划迁移到Angular 2，*尽量避免使用作用域*。
- en: There are a number of techniques that can be used to remove the `$scope` object
    dependency. The next few subsections elaborate on some techniques that can help
    us avoid Angular 1 scopes.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术可以用来消除对`$scope`对象的依赖。接下来的几个小节详细阐述了一些可以帮助我们避免Angular 1作用域的技术。
- en: Using controller as (controller aliasing) syntax everywhere
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在所有地方使用controller as（控制器别名）语法
- en: Angular 1.3+ has the *controller as* syntax for *controller*, *directive*, and
    *routes*. *controller as* allows Angular 1 databinding expressions to bind to
    controller instance properties instead of the current scope object properties.
    With the controller as a paradigm in place, we never need to interact with the
    scope directly, and hence future migration becomes easy.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1.3+有*controller as*语法用于*controller*，*directive*和*routes*。*controller
    as*允许Angular 1数据绑定表达式绑定到控制器实例属性，而不是当前作用域对象属性。有了控制器的范式，我们就不需要直接与作用域交互，因此未来的迁移变得容易。
- en: Note
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While controller aliasing gets rid of scope access, scopes are still there in
    Angular 1\. The complete Angular 1 databinding infrastructure depends upon scopes.
    Controller aliasing just puts an indirection between our code and scope access.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然控制器别名消除了作用域访问，但在Angular 1中仍然存在作用域。完整的Angular 1数据绑定基础设施依赖于作用域。控制器别名只是在我们的代码和作用域访问之间增加了一个间接。
- en: 'Consider the following syntax for *controller as* in views:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中考虑以下*controller as*的语法：
- en: '[PRE37]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And the corresponding controller implementation:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的控制器实现如下：
- en: '[PRE38]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`WorkoutListController` as `workoutList` creates an alias `workoutList` for
    `WorkoutListController` on the current scope, hence allowing us to bind to the
    `workouts` property defined on the controller.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutListController` as `workoutList`在当前作用域上为`WorkoutListController`创建了一个别名`workoutList`，因此允许我们绑定到控制器上定义的`workouts`属性。'
- en: 'Route definition too allows controller aliasing using the `controllerAs` property
    in a *route definition object*:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义也允许使用`controllerAs`属性在*路由定义对象*中进行控制器别名：
- en: '[PRE39]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, directives too can use `controllerAs`, and together with the `bindToController`
    property on the *directive definition object*, we can get rid of any direct scope
    access.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，指令也可以使用`controllerAs`，并且与*指令定义对象*上的`bindToController`属性一起，我们可以摆脱任何直接作用域访问。
- en: Note
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Look at the angular documentation on controller, routes, and directive to get
    a basic understanding of the controller as syntax. Also look at the following
    posts for some more detailed samples on this topic: [http://bit.ly/ng1-controller-as](http://bit.ly/ng1-controller-as)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 查看关于控制器、路由和指令的Angular文档，以对控制器别名语法有基本的了解。还可以查看以下帖子，了解更多关于这个主题的详细示例：[http://bit.ly/ng1-controller-as](http://bit.ly/ng1-controller-as)
- en: Note
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[http://bit.ly/ng1-bind-to](http://bit.ly/ng1-bind-to)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/ng1-bind-to](http://bit.ly/ng1-bind-to)'
- en: Avoiding ng-controller
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免ng-controller
- en: If scopes can be avoided, so can controllers!
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以避免作用域，那么控制器也可以避免！
- en: This may again seem counterintuitive, but the approach has real benefits. What
    we ideally want to do is emulate component behavior in Angular 1\. Since the closest
    thing to components in Angular 1 is *element directives* (with `restrict='E'`),
    we should utilize *element directives* everywhere.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能再次看起来违反直觉，但这种方法确实有实际好处。我们理想情况下要做的是在Angular 1中模拟组件行为。由于在Angular 1中最接近组件的东西是*元素指令*（带有`restrict='E'`），我们应该在任何地方都使用*元素指令*。
- en: An Angular 1 element directive with its own template and isolated scope can
    very well behave like an Angular 2 component and only be dependent on its internal
    state for its view binding. We just don't need `ng-controller`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 具有自己模板和隔离作用域的Angular 1元素指令可以很好地像Angular 2组件一样工作，并且只依赖于其内部状态进行视图绑定。我们只是不需要`ng-controller`。
- en: 'Consider the usage of `ng-controller` for audio tracking from the Angular 1
    version of the *Personal Trainer* app:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在*个人健身教练*应用程序的Angular 1版本中使用`ng-controller`进行音频跟踪：
- en: '[PRE40]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Instead of using `WorkoutAudioController`, an element directive can encapsulate
    the workout audio''s view and behavior. Such a directive can then replace the
    complete `ng-controller` declaration and its view:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`WorkoutAudioController`，一个元素指令可以封装训练音频的视图和行为。然后，这样的指令可以替换完整的`ng-controller`声明及其视图：
- en: '[PRE41]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When replacing `ng-controller` with an element directive, the scope variables
    that the controller depends upon should be passed to the directive using the `bindToController`
    property on the *directive definition object*. Something like this:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 当用元素指令替换`ng-controller`时，控制器依赖的作用域变量应该使用*指令定义对象*上的`bindToController`属性传递给指令。类似这样：
- en: '[PRE42]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This topic has been extensively covered in these two blog posts by Tero:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Tero在这两篇博客文章中广泛讨论了这个主题：
- en: '[http://bit.ly/ng2-no-controllers](http://bit.ly/ng2-no-controllers)'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://bit.ly/ng2-no-controllers](http://bit.ly/ng2-no-controllers)'
- en: '[http://bit.ly/ng2-refactor-to-component](http://bit.ly/ng2-refactor-to-component)'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://bit.ly/ng2-refactor-to-component](http://bit.ly/ng2-refactor-to-component)'
- en: These are must-read posts with a wealth of information!
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是必读的帖子，包含大量信息！
- en: Building using the Angular 1.5+ component API
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Angular 1.5+组件API构建
- en: Angular 1.5+ has a **component API** that allows us to create directives that
    can be easily migrated to Angular 2\. The component API is preconfigured with
    sensible defaults, hence incorporating the best practices when it comes to building
    truly isolated + reusable directives.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1.5+有一个**组件API**，允许我们创建指令，这些指令可以很容易地迁移到Angular 2。组件API预先配置了合理的默认值，因此在构建真正隔离和可重用的指令时，可以合并最佳实践。
- en: Look at the component API ([http://bit.ly/ng1-dev-guide-components](http://bit.ly/ng1-dev-guide-components))
    and this informative post by Tod Motto ([http://bit.ly/1MahwNs](http://bit.ly/1MahwNs))
    to learn about the component API.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 查看组件API（[http://bit.ly/ng1-dev-guide-components](http://bit.ly/ng1-dev-guide-components)）和Tod
    Motto的这篇信息性文章（[http://bit.ly/1MahwNs](http://bit.ly/1MahwNs)）来了解组件API。
- en: To reiterate what has been emphasized earlier, these steps are not just targeted
    towards easy Angular 2 migration but also towards making Angular 1 code better.
    Component-based UI development is a better paradigm than what we are used to with
    Angular 1.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 重申之前强调的内容，这些步骤不仅针对简化Angular 2迁移，也针对使Angular 1代码更好。基于组件的UI开发是比我们在Angular 1中习惯的更好的范例。
- en: Tip
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We highly recommend that you go through the Angular 1 style guide ([http://bit.ly/ng2-styleguide](http://bit.ly/ng2-styleguide)).
    This guide contains a wealth of tips/patterns that allow us to build better Angular
    1 apps, and is in sync with the guidelines provided previously for easy Angular
    2 migration.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您阅读Angular 1风格指南（[http://bit.ly/ng2-styleguide](http://bit.ly/ng2-styleguide)）。这个指南包含了大量的提示/模式，可以让我们构建更好的Angular
    1应用程序，并且与之前提供的易于迁移到Angular 2的指南保持一致。
- en: Finally, if you have decided to migrate, it's time to decide what to migrate.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您已经决定迁移，现在是时候决定迁移什么了。
- en: What to migrate?
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移什么？
- en: For an app in maintenance mode, where most of the development activity revolves
    around bug fixes and some enhancements, it would be prudent to stick to Angular
    1\. Remember the old saying "*If it ain't broke, don't fix it*."
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处于维护模式的应用程序，其中大部分开发活动都围绕着错误修复和一些增强，坚持使用Angular 1是明智的。记住那句老话“*如果它没坏，就别修*。”
- en: If the app is being actively developed and has a clear long-term roadmap, migrating
    to Angular 2 is worth considering. As we dig deeper into the intricacies of migration,
    we will realize the time and effort involved in the process. While the Angular
    team has worked really hard to make this migration smooth, by no stretch of imagination
    is this a trivial job. It is going to take a good amount of time and effort to
    perform the actual migration.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序正在积极开发并且有明确的长期路线图，考虑迁移到Angular 2是值得的。随着我们深入挖掘迁移的复杂性，我们将意识到这个过程所涉及的时间和精力。虽然Angular团队已经非常努力地使这次迁移顺利进行，但毫无疑问，这并不是一项琐碎的工作。实际迁移将需要大量的时间和精力。
- en: The silver lining here is that we do not need to migrate everything at once.
    We can work slowly towards migrating parts of the Angular 1 code base to Angular
    2\. Both the frameworks can coexist, and can depend on each other too. This also
    allows us to develop new parts of applications in Angular 2\. How cool is that!
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一线希望是我们不需要一次性迁移所有内容。我们可以慢慢地将Angular 1代码库的部分迁移到Angular 2。两种框架可以共存，也可以相互依赖。这也使我们能够在Angular
    2中开发应用程序的新部分。这是多么酷！
- en: But again, this flexibility comes at a cost-the cost of bytes. As both frameworks
    are downloaded, the page bytes do increase, something that we should be aware
    of.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种灵活性也是有代价的-字节的代价。由于两种框架都被下载，页面字节会增加，这是我们应该注意的事情。
- en: Also, while the coexistence of both the frameworks allows us to migrate without
    much disruption, we cannot make it a perpetual activity. Eventually, Angular 1
    has to go, and the sooner it does the better.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虽然两种框架的共存使我们能够在不造成太多中断的情况下进行迁移，但我们不能让它成为一个永久性的活动。最终，Angular 1必须离开，而且越早离开越好。
- en: During migration, the best thing that can be done is to carve out new SPA's
    within the existing application. For example, we can build the Admin area of an
    app entirely using Angular 2, with a separate host page, but still share the common
    infrastructure of style sheets, images, and even Angular 1 services if we refactor
    the code a bit. As we will learn later, migrating services to Angular 2 is the
    easiest.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移过程中，最好的做法是在现有应用程序中划分出新的SPA。例如，我们可以完全使用Angular 2构建应用程序的管理区域，使用单独的主机页面，但仍然共享样式表、图像，甚至Angular
    1服务的公共基础设施，如果我们稍微重构代码。正如我们将在后面学到的，将服务迁移到Angular 2是最容易的。
- en: Breaking an application into multiple smaller ones introduces full-page refreshes,
    but this is a cleaner approach when it comes to migration.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解为多个较小的应用程序会引入全页刷新，但在迁移时，这是一种更清晰的方法。
- en: Taking all of this into consideration, if you have decided to migrate and identified
    areas of migration, you need to do the prep work for migration.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，如果您已经决定迁移并确定了迁移的区域，您需要为迁移做好准备工作。
- en: Preparing for Angular 2 migration
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Angular 2迁移做准备
- en: Welcome to the big brave world of Angular 2 migration! A successful migration
    strategy involves making sure that we do the groundwork beforehand, hence avoiding
    any late surprises.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Angular 2迁移的大胆世界！成功的迁移策略包括确保我们事先做好准备，从而避免任何晚期的意外。
- en: As a prep work, the first step is to analyze the application from a third-party
    library dependency perspective.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 作为准备工作，第一步是从第三方库依赖的角度分析应用程序。
- en: Identifying third-party dependencies
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别第三方依赖
- en: Any third-party library that an Angular 1 app uses needs a migration strategy
    too. These could be either jQuery-based libraries or Angular 1 libraries.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Angular 1应用程序使用的第三方库也需要一个迁移策略。这些可能是基于jQuery的库或Angular 1库。
- en: jQuery libraries
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: jQuery库
- en: jQuery libraries in Angular 1 were consumed by creating a directive wrapper
    over them. We will have to migrate such directives to Angular 2.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 1中使用jQuery库是通过在其上创建一个指令包装器来消耗的。我们将不得不将这些指令迁移到Angular 2。
- en: Angular 1 libraries
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular 1库
- en: Migrating Angular 1 libraries is bit of a tricky affair. Angular 1 has a massive
    ecosystem, whereas Angular 2 is a new kid on the block. It will take some time
    for the Angular 2 community offerings to be as rich as Angular 1\. Hence, for
    every Angular 1 library we use, we need to find a substitute in Angular 2 or create
    one, or get rid of the library altogether.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移Angular 1库有点棘手。Angular 1有一个庞大的生态系统，而Angular 2是一个新生事物。Angular 2社区的成果要像Angular
    1那样丰富还需要一些时间。因此，对于我们使用的每个Angular 1库，我们需要在Angular 2中找到一个替代品，或者创建一个，或者完全摆脱这个库。
- en: 'Take for example the every-so-popular UI framework **ui-bootstrap** ([http://bit.ly/ng1-ui-bootstrap](http://bit.ly/ng1-ui-bootstrap)).
    There are multiple efforts going on to rewrite this library for Angular 2, but
    none are complete. If we have a dependency on *ui-bootstap*:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以每个如此受欢迎的UI框架**ui-bootstrap**（[http://bit.ly/ng1-ui-bootstrap](http://bit.ly/ng1-ui-bootstrap)）为例。目前有多个项目正在重写这个库以适配Angular
    2，但都尚未完成。如果我们依赖*ui-bootstrap*：
- en: We can either use the ports, assuming that the components we want to use have
    been migrated. The notable ports here are **ng-bootstrap** ([https://goo.gl/3dHkaU](https://goo.gl/3dHkaU))
    and **ng2-bootstrap** ([https://goo.gl/u4hOJn](https://goo.gl/u4hOJn)).
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用端口，假设我们想要使用的组件已经迁移。这里值得注意的端口有**ng-bootstrap**（[https://goo.gl/3dHkaU](https://goo.gl/3dHkaU)）和**ng2-bootstrap**（[https://goo.gl/u4hOJn](https://goo.gl/u4hOJn)）。
- en: Or wait for the port to be complete.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者等待端口完成。
- en: Or take a more radical approach of building our own bootstrap library in Angular
    2.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者采取更激进的方法，在Angular 2中构建我们自己的bootstrap库。
- en: Each of these choices has trade-offs in terms of time and complexity.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择每一个在时间和复杂性方面都有权衡。
- en: Another choice that needs to be made is the development language. Should we
    use TypeSript, ES2015, or plain old JavaScript (ES5)?
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要做出的另一个选择是开发语言。我们应该使用TypeSript、ES2015还是普通的旧JavaScript（ES5）？
- en: Choice of language
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言的选择
- en: We would definitely recommend TypeScript. It's a super awesome language, and
    it integrates very well with Angular 2, vastly reducing the verbosity of Angular
    2 declarations. Also, given that it can coexist with JavaScript, it makes our
    life easier. Even without Angular 2, TypeScript is one language that we should
    embrace for the web platform.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定会推荐使用TypeScript。这是一种非常棒的语言，与Angular 2集成非常好，大大减少了Angular 2声明的冗长。而且，它可以与JavaScript共存，使我们的生活更加轻松。即使没有Angular
    2，TypeScript也是我们应该在Web平台上采用的一种语言。
- en: In the coming sections, we will migrate the Angular 1 **Personal Trainer** app
    to Angular 2\. The app is currently available on *GitHub* at [http://bit.ly/a1begit](http://bit.ly/a1begit).
    This app was part of the first version of this book, *AngularJS by Example*, and
    was built using JavaScript.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将把Angular 1 **个人教练**应用迁移到Angular 2。该应用当前可在*GitHub*上找到，网址为[http://bit.ly/a1begit](http://bit.ly/a1begit)。该应用是本书第一版*AngularJS
    by Example*的一部分，是用JavaScript构建的。
- en: Note
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are again going to follow the checkpoint-based approach for this migration.
    The checkpoints that we highlight during the migration have been implemented as
    GitHub branches. Only this time, there is not companion code base to download.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次遵循基于检查点的方法进行迁移。在迁移过程中我们突出的检查点已经实现为GitHub分支。只是这一次，没有伴随的代码库可供下载。
- en: Since we will be interacting with a *git* repository for v1 code and using N*ode.js*
    tools for the build, please set up *git* and *nodejs* on your dev box before proceeding
    further.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将与v1代码的*git*存储库进行交互，并使用N*ode.js*工具进行构建，请在继续之前在开发环境中设置*git*和*nodejs*。
- en: Migrating Angular 1's Personal Trainer
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移Angular 1的个人教练
- en: Before we even begin the migration process we need to set up the v1 *Personal
    Trainer* locally.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在我们开始迁移过程之前，我们需要在本地设置v1 *个人教练*。
- en: The code for the migrated app can be downloaded from the GitHub site at [https://github.com/chandermani/angularjsbyexample](https://github.com/chandermani/angularjsbyexample).
    Since we migrate in chunks, we have created multiple checkpoints that map to **GitHub
    branches** dedicated to migration. Branches such as `ng2-checkpoint8.1`, `ng2-checkpoint8.2`,
    and so on highlight this progression. During the narration, we will highlight
    the branch for reference. These branches will contain the work done on the app
    up to that point in time.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移后的应用代码可以从GitHub网站[https://github.com/chandermani/angularjsbyexample](https://github.com/chandermani/angularjsbyexample)下载。由于我们是分阶段迁移，我们创建了多个检查点，这些检查点对应于专门用于迁移的**GitHub分支**。例如`ng2-checkpoint8.1`、`ng2-checkpoint8.2`等分支突出了这一进展。在叙述过程中，我们将突出显示分支以供参考。这些分支将包含到目前为止在应用上完成的工作。
- en: Note
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *7 Minute Workout* code is available inside the repository folder named
    `trainer`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*代码位于名为`trainer`的存储库文件夹中。'
- en: So let's get started!
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧！
- en: Setting up Angular 1's Personal Trainer locally
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地设置Angular 1的个人教练
- en: 'Follow these steps and you will be up and running in no time:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，您将很快就能上手：
- en: 'From the command line, clone the v1 github repository:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行中，克隆v1 github存储库：
- en: '[PRE43]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Navigate to the new git repo and check out the `ng2-base` branch to get started:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新的git存储库并检出`ng2-base`分支以开始：
- en: '[PRE44]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since the app loads its workout data from **MongoDB** hosted in **mLab **([https://mlab.com/](https://mlab.com/)),
    you need an mLab account to host workout-related data. Set up an mLab account
    by signing up with them. Once you have an mLab account, you need to retrieve your
    API key from mLab's management portal. Follow the instructions provided in the
    API documentation ([http://bit.ly/mlab-docs](http://bit.ly/mlab-docs)) to get
    your API key.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于该应用从**mLab**中托管的**MongoDB**中加载其锻炼数据（[https://mlab.com/](https://mlab.com/)），您需要一个mLab账户来托管与锻炼相关的数据。通过注册mLab账户来设置mLab账户。一旦您有了mLab账户，您需要从mLab的管理门户中检索您的API密钥。请按照API文档提供的说明([http://bit.ly/mlab-docs](http://bit.ly/mlab-docs))获取您的API密钥。
- en: 'Once you have the API key, update this line in `app/js/config.js` with your
    API key:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您获得API密钥，请在`app/js/config.js`中更新此行与您的API密钥：
- en: '[PRE45]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And add some seed workout data into your mLab instance. The instructions to
    add the seed data into mLab are available in the source code file, `app/js/seed.js`.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并将一些种子锻炼数据添加到您的mLab实例中。将种子数据添加到mLab的说明在源代码文件`app/js/seed.js`中可用。
- en: 'Next, install the necessary *npm packages* required for v1 *Personal Trainer*:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装v1 *Personal Trainer*所需的必要*npm包*：
- en: '[PRE46]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Install **http-server**; it will act as a development server for our v1 app:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装**http-server**；它将作为我们v1应用的开发服务器：
- en: '[PRE47]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Verify that the setup is complete by starting the `http-server` from the `app`
    folder:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`app`文件夹启动`http-server`来验证设置是否完成：
- en: '[PRE48]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And open the browser location `http://localhost:8080`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 并打开浏览器位置`http://localhost:8080`。
- en: The v1 *Personal Trainer* start page should show up. Play around with the app
    to verify that the app is working fine. Now the migration can begin.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: v1 *Personal Trainer*的起始页面应该显示出来。玩转应用程序以验证应用程序是否正常工作。现在迁移可以开始了。
- en: Identifying dependencies
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别依赖关系
- en: The first step before we begin migrating v1 *Personal Trainer* is to identify
    the external libraries that we are using in the Angular 1 version of Personal
    Trainer.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始迁移v1 *Personal Trainer*之前的第一步是识别我们在Personal Trainer的Angular 1版本中使用的外部库。
- en: 'The external libraries that we are using in v1 are:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在v1中使用的外部库有：
- en: '`angular-media-player`'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-media-player`'
- en: '`angular-local-storage`'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-local-storage`'
- en: '`angular-translate`'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-translate`'
- en: '`angular-ui-bootstrap`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-ui-bootstrap`'
- en: '`owl. carousel`'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owl. carousel`'
- en: Libraries such as *angular-media-player* and *angular-local-storage* are easy
    to migrate/replace. We have already done this in the earlier chapters of this
    book.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 像*angular-media-player*和*angular-local-storage*这样的库很容易迁移/替换。我们在本书的早期章节中已经做过这个。
- en: '*angular-translate* can be replaced with *ng2-translate*, and as we will see
    in the coming sections, it is not a very challenging task.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '*angular-translate*可以用*ng2-translate*替换，正如我们将在接下来的章节中看到的，这并不是一个非常具有挑战性的任务。'
- en: We use *angular-ui-bootstrap* for **modal dialogs** in *Personal Trainer*. *ng2-bootstrap*
    ([http://bit.ly/ng2-bootstrap](http://bit.ly/ng2-bootstrap)) is a worthy successor
    and plans to have a 1-1 parity with the older bootstrap version, but while writing
    this book, the modal dialog implementation was a work in progress; hence we had
    look for alternatives.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*Personal Trainer*中使用*angular-ui-bootstrap*来进行**模态对话框**。*ng2-bootstrap* ([http://bit.ly/ng2-bootstrap](http://bit.ly/ng2-bootstrap))是一个值得接替的版本，并计划与旧版本的bootstrap具有1-1的对应关系，但在撰写本书时，模态对话框的实现还在进行中；因此我们不得不寻找替代方案。
- en: 'There are two other libraries available specifically targeting modal dialogs:
    **angular2-modal** ([http://bit.ly/ng2-modal](http://bit.ly/ng2-modal)) and **ng2-bs3-modal**
    ([http://bit.ly/ng2-bs3-modal](http://bit.ly/ng2-bs3-modal)). We can pick one
    of these and get rid of the *angular-ui-bootstrap* library.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外两个专门针对模态对话框的库：**angular2-modal** ([http://bit.ly/ng2-modal](http://bit.ly/ng2-modal))和**ng2-bs3-modal**
    ([http://bit.ly/ng2-bs3-modal](http://bit.ly/ng2-bs3-modal))。我们可以选择其中一个并摆脱*angular-ui-bootstrap*库。
- en: '*Owl. Carousel* is a jQuery library, and we can write an Angular 2 component
    to wrap this plugin.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '*Owl. Carousel*是一个jQuery库，我们可以编写一个Angular 2组件来包装这个插件。'
- en: Now that we have sorted out the external dependencies, let's decide the language
    to use.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了外部依赖关系，让我们决定要使用的语言。
- en: While the existing code base is JavaScript, we love TypeScript. Its type safety,
    its terse syntax, and how well it plays with Angular 2 makes it our language of
    choice. Hence, it's going to be TypeScript all the way.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现有的代码库是JavaScript，但我们喜欢TypeScript。它的类型安全性，简洁的语法以及与Angular 2的良好兼容性使其成为我们的首选语言。因此，我们将全面采用TypeScript。
- en: Another thing that tilts the decision in favor of TypeScript is that we do not
    need to migrate the existing code base to TypeScript. Anything we migrate/build
    new, we build it in TypeScript. Legacy code still remains in JavaScript.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个倾向于选择TypeScript的因素是我们不需要将现有的代码库迁移到TypeScript。我们迁移/构建新的任何东西，都会用TypeScript构建。遗留代码仍然保留在JavaScript中。
- en: Let's start. As a first migration task, we need to set up a module loader for
    our v1 Personal Trainer.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。作为第一个迁移任务，我们需要为我们的v1 Personal Trainer设置一个模块加载器。
- en: Setting up the module loader
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置模块加载器
- en: 'Since we are going to create a number of new Angular 2 components spread across
    numerous small files, adding direct script reference is going to be tedious and
    error-prone. We need a module loader. A module loader can help us with:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在许多小文件中创建许多新的Angular 2组件，直接添加脚本引用将变得繁琐且容易出错。我们需要一个模块加载器。模块加载器可以帮助我们：
- en: Creating isolated/reusable modules based on some common module formats
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于一些常见模块格式创建隔离/可重用模块
- en: Managing the script loading order based on dependencies
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据依赖关系管理脚本加载顺序
- en: Allowing bundling/packaging of a module and on-demand loading for dev/production
    deployments
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对模块进行捆绑/打包，并在开发/生产部署时进行按需加载
- en: We use the **SystemJS** module loader for this migration too.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也使用**SystemJS**模块加载器进行此迁移。
- en: 'Install SystemJS from the command line using:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行安装SystemJS：
- en: '[PRE49]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the commands need to be executed from the `trainer/app` folder.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令都需要从`trainer/app`文件夹中执行。
- en: We open `index.html` and remove all the script references of our app scripts.
    All script references with the source as `src='js/*.*'` should be removed, except
    `angular-media-player.js` and `angular-local-storage.js`, as they are external
    libraries.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开`index.html`并删除所有应用程序脚本的脚本引用。应删除所有源为`src='js/*.*'`的脚本引用，除了`angular-media-player.js`和`angular-local-storage.js`，因为它们是外部库。
- en: Note
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: We are not removing script references for third-party libraries but only
    app files.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们不会删除第三方库的脚本引用，只删除应用程序文件。
- en: 'Add SystemJS configurations after all third-party script references:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有第三方脚本引用之后添加SystemJS配置：
- en: '[PRE50]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Remove the `ng-app` attribute on the body tag, keeping the `ng-controller`
    declaration intact:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在body标签上删除`ng-app`属性，保持`ng-controller`声明不变：
- en: '[PRE51]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `ng-app` way of bootstrapping has to go as we switch to the `angular.bootstrap`
    function. Manual bootstrapping helps when we bring Angular 2 into the mix.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-app`引导的方式必须消失，因为我们要切换到`angular.bootstrap`函数。手动引导有助于我们将Angular 2引入其中时。'
- en: The preceding `SystemJS.import` call loads the application by loading the first
    app module defined in `js/app.js`. We are going to define this module shortly.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`SystemJS.import`调用通过加载`js/app.js`中定义的第一个应用程序模块来加载应用程序。我们将很快定义这个模块。
- en: Create a new file called `app.module.js` in the same folder as `app.js` and
    copy the complete contents of `app.js` into `app.module.js`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在与`app.js`相同的文件夹中创建一个名为`app.module.js`的新文件，并将`app.js`的全部内容复制到`app.module.js`中。
- en: Note
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to get rid of the `use strict` statement. The TypeScript compiler does
    not like it.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要摆脱`use strict`语句。TypeScript编译器不喜欢它。
- en: All the app module definitions are not in `app.module.js`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序模块定义都不在`app.module.js`中。
- en: 'Next, clear `app.js` and add the following imports and bootstrap code:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，清空`app.js`并添加以下导入和引导代码：
- en: '[PRE52]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have added *ES6 import statements* to `app.js`. These are the same scripts
    that were earlier referenced in `index.html`. SystemJS now loads these script
    files when loading `app.js`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`app.js`中添加了*ES6导入语句*。这些是之前在`index.html`中引用的相同脚本。现在SystemJS在加载`app.js`时会加载这些脚本文件。
- en: Moving all of theAngular 1 module declaration into a new file `app.module.js`
    and importing it first in `app.js` makes sure that the Angular 1 modules are defined
    before any of the `import` statements are executed.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有的Angular 1模块声明移到一个新文件`app.module.js`中，并首先在`app.js`中导入它，以确保在执行任何`import`语句之前定义了Angular
    1模块。
- en: Tip
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do not confuse between *ES6 modules* and *Angular 2 modules* defined/accessed
    using `angular.module('name')`. These two are altogether different concepts.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆*ES6模块*和使用`angular.module('name')`定义/访问的*Angular 2模块*。这两个概念完全不同。
- en: The last few lines bootstrap the Angular 1 application using the `angular.bootstrap`
    function.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行使用`angular.bootstrap`函数引导了Angular 1应用程序。
- en: Module loading is enabled now; let's enable TypeScript too.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载现在已启用；让我们也启用TypeScript。
- en: Enabling TypeScript
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用TypeScript
- en: 'To enable TypeScript, install the TypeScript compiler using *npm*:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用TypeScript，请使用*npm*安装TypeScript编译器：
- en: '[PRE53]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can also install the TypeScript *type definition manager*, which allows
    us to use type definition for the libraries we use:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以安装TypeScript*类型定义管理器*，允许我们为我们使用的库使用类型定义：
- en: '[PRE54]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Type definitions** or **typings** are files that define the public interface
    for a TypeScript/JavaScript library. These type definitions help IDEs provide
    intellisense around the library functions. Typings are available for most of the
    popular JavaScript libraries and for frameworks/libraries written in TypeScript.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型定义**或**typings**是定义TypeScript/JavaScript库的公共接口的文件。这些类型定义帮助IDE在库函数周围提供智能感知。大多数流行的JavaScript库和TypeScript编写的框架/库都有类型定义。'
- en: 'Next, open `package.json` and add these lines inside the script configuration:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`package.json`并在脚本配置内添加以下行：
- en: '[PRE55]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The two `scripts` properties that we just added are used to provide shortcuts
    for commonly executed scripts. See the following example, where we use the `typings`
    command to install `typings` (`npm run typings`).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的两个`scripts`属性用于提供常用脚本的快捷方式。请参考以下示例，我们使用`typings`命令来安装`typings`（`npm run
    typings`）。
- en: 'Install the *type definitions* for Angular 1 and jQuery. From the command line,
    run:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 为Angular 1和jQuery安装*类型定义*。从命令行运行：
- en: '[PRE56]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Tip
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are having trouble installing the *typings*, make sure that the installed
    `typings` package is the latest one, and then try again. We can check the latest
    version of the package using this command:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装*typings*时遇到问题，请确保安装的`typings`包是最新的，然后重试。我们可以使用此命令检查包的最新版本：
- en: '[PRE57]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Tip
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Update `package.json` with the latest version and call `npm install` from the
    command line.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行更新`package.json`到最新版本，并调用`npm install`。
- en: 'We now need to set up some configurations for the TypeScript compiler. Create
    a file called `tsconfig.json` (in the `trainer/app` folder) and copy the configuration
    from the `ng2-checkpoint8.1` repo branch (also available remotely at [http://bit.ly/ng2be-8-1-tsconfig](http://bit.ly/ng2be-8-1-tsconfig)):
    Run the compiler using:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为TypeScript编译器设置一些配置。创建一个名为`tsconfig.json`的文件（在`trainer/app`文件夹中），并从`ng2-checkpoint8.1`存储库分支（也可以远程获取[http://bit.ly/ng2be-8-1-tsconfig](http://bit.ly/ng2be-8-1-tsconfig)）复制配置：运行编译器：
- en: '[PRE58]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This should start the TypeScript compiler and there should be no errors reported.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该启动TypeScript编译器，并且不应报告任何错误。
- en: Note
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep this command running in a separate console window at all times during development.
    The compiler will continuously watch for changes to the TypeScript file and rebuild
    the code if changes are detected.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，始终在单独的控制台窗口中运行此命令。编译器将持续监视TypeScript文件的更改，并在检测到更改时重新构建代码。
- en: Change the extension for the `app.js` and `app.module.js` files to `app.ts`
    and `app.module.ts`. The TypeScript compiler detects these changes and compiles
    the TypeScript files. Post compilation, the compiler produces two files for each
    TypeScript file. One is the compiled JavaScript file (such as `app.js`) and the
    other is a map file (`app.js.map`) for debugging purposes.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 将`app.js`和`app.module.js`文件的扩展名更改为`app.ts`和`app.module.ts`。TypeScript编译器会检测这些更改并编译TypeScript文件。编译后，编译器为每个TypeScript文件生成两个文件。一个是编译后的JavaScript文件（例如`app.js`），另一个是用于调试目的的映射文件（`app.js.map`）。
- en: Note
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have not set up an elaborate build for this exercise as our primary focus
    is around migration.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为这个练习设置复杂的构建，因为我们的主要重点是迁移。
- en: For your own apps, the initial setup steps may vary depending upon how the build
    is already set up.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您自己的应用程序，初始设置步骤可能会有所不同，这取决于构建的当前设置方式。
- en: 'Before we test our new changes, `config.js` needs to be fixed because we have
    enabled *strict DI check* in Angular 1 through:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试新更改之前，需要修复`config.js`，因为我们已经通过以下方式在Angular 1中启用了*strict DI check*：
- en: '[PRE59]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Replace the `config.js` content with updated content available in `ng2-checkpoint8.1`
    or at [http://bit.ly/ng2be-8-1-configjs](http://bit.ly/ng2be-8-1-configjs) (*and
    remember to set the API key again*). The update fixes the `config` function and
    makes it minification-friendly. Time to test the app!
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 用`ng2-checkpoint8.1`中提供的更新内容或[http://bit.ly/ng2be-8-1-configjs](http://bit.ly/ng2be-8-1-configjs)中提供的更新内容替换`config.js`的内容（*并记得重新设置API密钥*）。此更新修复了`config`函数，并使其适用于缩小。是时候测试应用程序了！
- en: Make sure the TypeScript compiler is running in one console; run `http-server
    -c-1` on a new console window.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 确保TypeScript编译器在一个控制台中运行；在新的控制台窗口上运行`http-server -c-1`。
- en: Navigate to `http://localhost:8080;` the app start page should load.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 导航至`http://localhost:8080;`，应用程序的起始页面应该加载。
- en: Commiting your local changes
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 提交您的本地更改
- en: Tip
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If things work fine, you can even commit your local changes to your git repo.
    This will help you track what has changed over the time as we migrate the app
    piece by piece.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，甚至可以将您的本地更改提交到git存储库。这将帮助您跟踪随着我们逐步迁移应用程序而发生的变化。
- en: The implementation till this point is available in the `ng2-checkpoint8.1` GitHub
    branch.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的实现可在`ng2-checkpoint8.1` GitHub分支中找到。
- en: 'If you are facing problems, compare the `ng2-base` and `ng2-checkpoint8.1`
    branches to understand the changes made. Since the code is hosted in GitHub, we
    can use the *GitHub compare* interface to compare commits in a single branch.
    See the documentation on how to do it here: [http://bit.ly/github-compare](http://bit.ly/github-compare).'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到问题，请比较`ng2-base`和`ng2-checkpoint8.1`分支，以了解所做的更改。由于代码托管在GitHub上，我们可以使用*GitHub比较*界面来比较单个分支中的提交。请参阅此处的文档以了解如何操作：[http://bit.ly/github-compare](http://bit.ly/github-compare)。
- en: The [http://bit.ly/ng2be-compare-base-8-1](http://bit.ly/ng2be-compare-base-8-1) link shows
    a comparison between `ng2-base` and `ng2-checkpoint8.1`.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/ng2be-compare-base-8-1](http://bit.ly/ng2be-compare-base-8-1)链接显示了`ng2-base`和`ng2-checkpoint8.1`之间的比较。'
- en: You can ignore the diff view for `app.js` and `app.module.js`, generated as
    part of the TypeScript compilation.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以忽略作为TypeScript编译的一部分生成的`app.js`和`app.module.js`的差异视图。
- en: Time to introduce Angular 2!
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候介绍Angular 2了！
- en: Adding Angular 2
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Angular 2
- en: We start by installing Angular 2 and dependent *npm modules* for our app. We
    will update the `package.json` file with the necessary packages first.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要为我们的应用程序安装Angular 2和依赖的*npm模块*。我们将首先使用必要的软件包更新`package.json`文件。
- en: Copy all of the updated package file from [http://bit.ly/ng2be-8-2-package-json](http://bit.ly/ng2be-8-2-package-json)
    into your local installation.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://bit.ly/ng2be-8-2-package-json](http://bit.ly/ng2be-8-2-package-json)中复制所有更新的软件包文件到您的本地安装。
- en: '`package.json` now references some new packages related to Angular 2\. Install
    the referenced packages by calling:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`现在引用了一些与Angular 2相关的新软件包。通过调用来安装引用的软件包：'
- en: '[PRE60]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Tip
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are having trouble with installing packages with `npm install`, delete
    the `node_modules` folder and run `npm install` again.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用`npm install`安装软件包时遇到问题，请删除`node_modules`文件夹，然后再次运行`npm install`。
- en: 'Then add a few library references that Angular 2 is dependent upon (and not
    loaded using SystemJS) in `index.html` before the `system.src.js` script reference
    (three in total):'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`index.html`中的`system.src.js`脚本引用之前（总共三个）添加Angular 2所依赖的一些库引用（并且不使用SystemJS加载）：
- en: '[PRE61]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As it stands now, the SystemJS configuration is present in the `index.html`
    file itself. Since Angular 2 requires some decent amount of configuration, we
    are going to create a separate *SystemJS configuration file* instead, and reference
    that in `index.html`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，SystemJS配置存在于`index.html`文件本身中。由于Angular 2需要一定数量的配置，我们将创建一个单独的*SystemJS配置文件*，并在`index.html`中引用它。
- en: 'Add this script reference after the `system.src.js` reference:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在`system.src.js`引用之后添加这个脚本引用：
- en: '[PRE62]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now clear the script section containing the call to the `System.config` function
    and replace it with:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 现在清除包含对`System.config`函数调用的脚本部分，并替换为：
- en: '[PRE63]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Copy the `systemjs.config.js` from [http://bit.ly/ng2be-migrate-systemjs-config](http://bit.ly/ng2be-migrate-systemjs-config)
    and place it in the same folder as `package.json`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://bit.ly/ng2be-migrate-systemjs-config](http://bit.ly/ng2be-migrate-systemjs-config)复制`systemjs.config.js`并将其放在与`package.json`相同的文件夹中。
- en: Note
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This configuration file derives from the *Quick Start Guide* for Angular available
    at [http://bit.ly/ng2-qsguide](http://bit.ly/ng2-qsguide). You can learn more
    about this configuration from the online guide.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件源自Angular的*快速入门指南*，可在[http://bit.ly/ng2-qsguide](http://bit.ly/ng2-qsguide)上找到。您可以从在线指南中了解更多关于这个配置的信息。
- en: 'Also update `tsconfig.json` and add a new property called `moduleResolution`
    to `compilerOptions`:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 还要更新`tsconfig.json`并在`compilerOptions`中添加一个名为`moduleResolution`的新属性：
- en: '[PRE64]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This instructs TypeScript to look for type definitions in the `node_modules`
    folder. Remember, Angular 2 typings are bundled as part of the Angular 2 library
    itself, and hence separate type definition import is not required.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示TypeScript在`node_modules`文件夹中查找类型定义。请记住，Angular 2的类型定义已经作为Angular 2库的一部分捆绑在一起，因此不需要单独的类型定义导入。
- en: Now that the Angular 2-specific references have been added, we need to modify
    the existing bootstrap process to also load Angular 2.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经添加了Angular 2特定的引用，我们需要修改现有的引导过程以加载Angular 2。
- en: 'The Angular team has come up with an Angular 2 service, **UpdateAdapter**,
    that allows Angular 2 to bootstrap within an Angular 1 setup. The `UpgradeAdapter`
    service enables a number of common migration use cases. Using `UpgradeAdapter`,
    we can:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队提出了一个名为**UpdateAdapter**的Angular 2服务，它允许在Angular 1设置中引导Angular 2。`UpgradeAdapter`服务实现了许多常见的迁移用例。使用`UpgradeAdapter`，我们可以：
- en: Bootstrap an app with both the Angular 1 and Angular 2 frameworks loaded. This
    is the first thing we are going to do.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导一个同时加载Angular 1和Angular 2框架的应用程序。这是我们要做的第一件事。
- en: Incorporate an Angular 2 component in an Angular 1 view.
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular 1视图中合并一个Angular 2组件。
- en: Incorporate an Angular 1 component in an Angular 2 view, albeit with some limitations.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular 2视图中合并一个Angular 1组件，尽管有一些限制。
- en: Register an Angular 1 service with Angular 2 and vice versa.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个Angular 1服务到Angular 2，反之亦然。
- en: The sole purpose of the `UpgradeAdpater` service is to allow the gradual migration
    of artefacts from Angular 1 to Angular 2\. As we make progress with our migration
    efforts, the role of `UpgradeAdpater` becomes clear.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpgradeAdpater`服务的唯一目的是允许逐步将Angular 1的构件迁移到Angular 2。随着我们迁移工作的进展，`UpgradeAdpater`的作用变得清晰起来。'
- en: Let's learn how to bootstrap the hybrid Angular 1 and Angular 2 app using `UpgradeAdpater`.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用`UpgradeAdpater`引导混合的Angular 1和Angular 2应用程序。
- en: Bootstrapping the hybrid app
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导混合应用程序
- en: Since we are starting with Angular 2, we need to define a root app module.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从Angular 2开始，我们需要定义一个根应用程序模块。
- en: 'Create a new file, `app-ng1.module.js`, and copy the complete content of `app.module.ts`
    to the new file. Also remember to update the `import` statement in `app.ts`:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`app-ng1.module.js`，并将`app.module.ts`的完整内容复制到新文件中。还要记得更新`app.ts`中的`import`语句：
- en: '[PRE65]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let's now add the Angular 2 root module definition (`AppModule`) to `app.module.ts`.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将Angular 2根模块定义（`AppModule`）添加到`app.module.ts`中。
- en: 'Replace the content of `app.module.ts` with the Angular 2 module definition.
    Copy the new definition from `ng2-checkpoint8.2` (GitHub location: [http://bit.ly/ng2be-8-2-app-module-ts](http://bit.ly/ng2be-8-2-app-module-ts)).'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 用Angular 2模块定义替换`app.module.ts`的内容。从`ng2-checkpoint8.2`（GitHub位置：[http://bit.ly/ng2be-8-2-app-module-ts](http://bit.ly/ng2be-8-2-app-module-ts)）复制新的定义。
- en: 'Next, create a file called `upgrade-adapter.ts` in the same folder as `app.ts`
    and add a *global export* for the `UpdateAdapter` instance:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在与`app.ts`相同的文件夹中创建一个名为`upgrade-adapter.ts`的文件，并为`UpdateAdapter`实例添加一个*全局导出*：
- en: '[PRE66]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This instance of `UpgradeAdpater` (named `upgradeAdapter`) is now available
    globally, and can be used to bootstrap the hybrid app.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`UpgradeAdpater`实例（名为`upgradeAdapter`）现在全局可用，并且可以用来引导混合应用程序。
- en: Note
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Exporting an instance of `UpgradeAdapter` allows us to reuse the same instance
    across the app. This is a mandatory requirement for interoperability between the
    frameworks.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 导出`UpgradeAdapter`的实例允许我们在整个应用程序中重用相同的实例。这是框架之间互操作的强制要求。
- en: 'Import the file we just created into `app.ts`. Add this import statement after
    other imports in `app.ts`:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们刚创建的文件导入到`app.ts`中。在`app.ts`的其他导入之后添加此导入语句：
- en: '[PRE67]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And replace the bootstrap code with:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 并用以下代码替换引导代码：
- en: '[PRE68]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Refresh your app and make sure it works as before. Do watch out for errors in
    TypeScript compiler console window.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新您的应用程序，并确保它像以前一样工作。确保在TypeScript编译器控制台窗口中注意错误。
- en: Congratulations! We now have a hybrid app up and running. Both frameworks are
    now working in tandem.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们现在有一个混合应用程序正在运行。两个框架现在同时工作。
- en: Note
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Look at the `ng2-checkpoint8.2` branch if you are facing issues upgrading to
    Angular 2. Again, you can also compare these git branches `ng2-checkpoint8.1`
    and `ng2- checkpoint8.2` to understand what has changed ([http://bit.ly/ng2be-compare-8-1-8-2](http://bit.ly/ng2be-compare-8-1-8-2)).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在升级到Angular 2时遇到问题，请查看`ng2-checkpoint8.2`分支。同样，您也可以比较这些git分支`ng2-checkpoint8.1`和`ng2-
    checkpoint8.2`，以了解发生了什么变化（[http://bit.ly/ng2be-compare-8-1-8-2](http://bit.ly/ng2be-compare-8-1-8-2)）。
- en: The migration process can start now. We can start by migrating a part of an
    Angular 1 view/directive to Angular 2.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移过程现在可以开始。我们可以从将Angular 1视图/指令的一部分迁移到Angular 2开始。
- en: Injecting Angular 2 components into Angular 1 views
  id: totrans-666
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Angular 2组件注入到Angular 1视图中
- en: The most common migration pattern involves migrating lower-level Angular 1 directives/views
    to Angular 2 components. If we visualize the Angular 1 HTML view structure as
    a tree of directives, we start at the leaf. We migrate parts of a directive/view
    to an Angular 2 component and embed the component inside the Angular 1 view template.
    This Angular 2 component is injected into the Angular 1 view as an *element directive*.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的迁移模式涉及将较低级别的Angular 1指令/视图迁移到Angular 2组件。如果我们将Angular 1 HTML视图结构可视化为指令树，我们从叶子开始。我们将指令/视图的部分迁移到Angular
    2组件，并将该组件嵌入到Angular 1视图模板中。这个Angular 2组件被注入到Angular 1视图中作为*元素指令*。
- en: Note
  id: totrans-668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The closest thing to Angular 2 components that Angular 1 has is element directives.
    During migration, we are either migrating element directives or controller (`ng-controller`)-view
    pairs.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1最接近Angular 2组件的东西是元素指令。在迁移过程中，我们要么迁移元素指令，要么迁移控制器（`ng-controller`）-视图对。
- en: 'This is a bottom-up approach to migrating view/directives to Angular 2 components.
    The following diagram highlights how the Angular 1 view hierarchy gradually transforms
    into an Angular 2 component tree:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将视图/指令逐步迁移到Angular 2组件的自下而上方法。以下图表突出显示了Angular 1视图层次结构如何逐渐转变为Angular 2组件树：
- en: '![Injecting Angular 2 components into Angular 1 views](../Images/image00416.jpeg)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
  zh: 将Angular 2组件注入到Angular 1视图中
- en: Let's migrate something small and get a feel of how things work. `ExerciseNavController`
    and its corresponding view fit the bill.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们迁移一些小的东西，感受一下事情是如何运作的。`ExerciseNavController`及其对应的视图符合要求。
- en: Migrating our first view to Angular 2 component
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的第一个视图迁移到Angular 2组件
- en: '`ExerciseNavController` is part of *workout builder* and is located inside
    `trainer/app/js/WorkoutBuilder/exercise.js`. The corresponding view is served
    from `trainer/app/partials/workoutbuilder/left-nav-exercises.html`.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseNavController`是*训练建造者*的一部分，位于`trainer/app/js/WorkoutBuilder/exercise.js`内。相应的视图是从`trainer/app/partials/workoutbuilder/left-nav-exercises.html`提供的。'
- en: 'The primary purpose of this this controller-view pair is to show the list of
    available exercises when building a workout (available user path `http://localhost:8080/#/builder/workouts/new`):'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器-视图对的主要目的是在构建训练时显示可用的练习列表（可用用户路径`http://localhost:8080/#/builder/workouts/new`）：
- en: '![Migrating our first view to Angular 2 component](../Images/image00417.jpeg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![将我们的第一个视图迁移到Angular 2组件](../Images/image00417.jpeg)'
- en: Clicking on any of these exercise names adds the exercise to the workout being
    constructed.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何这些练习名称都会将练习添加到正在构建的训练中。
- en: Let's start with creating a component for the above view.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为上述视图创建一个组件开始。
- en: Note
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before starting on the new component, add a new workout builder module (`WorkoutBuilderModule`)
    to the application. Copy the module definition from `ng2-checkpoint8.3` in the
    `WorkoutBuilder` folder (GitHub location: [http://bit.ly/ng2be-8-3-workout-builder-module-ts](http://bit.ly/ng2be-8-3-workout-builder-module-ts)).
    Also import the newly created module in `app.module.ts`.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新组件之前，将一个新的训练建造者模块（`WorkoutBuilderModule`）添加到应用程序中。从`WorkoutBuilder`文件夹中的`ng2-checkpoint8.3`中复制模块定义（GitHub位置：[http://bit.ly/ng2be-8-3-workout-builder-module-ts](http://bit.ly/ng2be-8-3-workout-builder-module-ts)）。还要在`app.module.ts`中导入新创建的模块。
- en: Instead of inlining the complete code here, we suggest copying the `exercise-nav-component.ts`
    file from GitHub branch `ng2-checkpoint8.3` ([http://bit.ly/ng2be-8-3-exercisenavts](http://bit.ly/ng2be-8-3-exercisenavts))
    and adding it to the `WorkoutBuilder` folder locally. Since there is a decent
    amount of boilerplate, we will highlight only the relevant parts.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议不要在这里内联完整的代码，而是从GitHub分支`ng2-checkpoint8.3`中复制`exercise-nav-component.ts`文件（[http://bit.ly/ng2be-8-3-exercisenavts](http://bit.ly/ng2be-8-3-exercisenavts)），并将其添加到本地的`WorkoutBuilder`文件夹中。由于有相当多的样板代码，我们只会突出显示相关的部分。
- en: Contrasting template syntax
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 对比模板语法
- en: Tip
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Angular team has published an excellent reference ([http://bit.ly/ng2-a1-a2-quickref](http://bit.ly/ng2-a1-a2-quickref))
    that details the common view syntaxes in Angular 1 and their equivalents in Angular
    2\. Highly recommended when migrating an Angular 1 app!
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队已经发布了一个优秀的参考资料（[http://bit.ly/ng2-a1-a2-quickref](http://bit.ly/ng2-a1-a2-quickref)），详细介绍了Angular
    1中的常见视图语法及其在Angular 2中的等价物。在迁移Angular 1应用程序时强烈推荐！
- en: 'To start with, if you look at the `exercise-nav-component.ts` file, the component
    template is similar to `left-nav-exercises.html` used in Angular 1, except there
    is no `ng-controller` and the template bindings are Angular 2-based:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你看一下`exercise-nav-component.ts`文件，组件模板类似于Angular 1中使用的`left-nav-exercises.html`，只是没有`ng-controller`，模板绑定是基于Angular
    2的：
- en: '[PRE69]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we focus on the component implementation (`ExercisesNavComponent`), the
    first striking thing is the component''s dependencies:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们关注组件实现（`ExercisesNavComponent`），第一个显著的是组件的依赖关系：
- en: '[PRE70]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`WorkoutService` and `WorkoutBuilderService` are Angular 1 services injected
    into Angular 2 components.'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutService`和`WorkoutBuilderService`是注入到Angular 2组件中的Angular 1服务。'
- en: Nice! If that is your initial reaction, we can't blame you. It is pretty cool!
    But the story is still incomplete. There is no magic happening here. Angular 2
    cannot access Angular 1 services unless it is told where to look. It's `UpgradeAdapter`
    that does most of the heavy lifting here.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！如果这是你的初步反应，我们也不怪你。这很酷！但故事还没有完全结束。这里没有发生魔法。Angular 2 不能访问 Angular 1 的服务，除非告诉它在哪里找。`UpgradeAdapter`
    在这里承担了大部分的重活。
- en: Injecting Angular 1 dependencies into Angular 2
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Angular 1 依赖注入到 Angular 2
- en: '`UpgradeAdapter` has an API method that allows us to register an *Angular 1
    service* with Angular 2\. Open `app.ts` and add these lines after the `upgrade-adapter`
    import:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpgradeAdapter` 有一个 API 方法，允许我们在 Angular 2 中注册一个 *Angular 1 服务*。打开 `app.ts`
    并在 `upgrade-adapter` 导入后添加这些行：'
- en: '[PRE71]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `updateNg1Provider,` as its name suggests, registers an Angular 1 dependency
    with the *Angular 2 root injector*. Once registered, the dependency is available
    throughout the Angular 2 application.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateNg1Provider`，顾名思义，将一个 Angular 1 依赖注册到 *Angular 2 根注入器*。一旦注册，该依赖就可以在整个
    Angular 2 应用程序中使用。'
- en: Tip
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Sharing functionality with services**'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**与服务共享功能**'
- en: '`UpgradeAdapter` will also make sure that the same instance of the service
    is shared across the two frameworks. This makes services a prime candidate for
    sharing behavior across the frameworks. And, as we will see soon, it works the
    other way round too.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpgradeAdapter` 还会确保服务的同一个实例在两个框架中共享。这使得服务成为在两个框架之间共享行为的首选候选者。而且，正如我们很快将看到的那样，它也可以反过来工作。'
- en: Dependencies at times have other dependencies, and hence it's better if we bring
    in all the service dependencies from Angular 1 at one go. Copy the list of Angular
    1 dependency registrations (done using `upgradeNg1Provider`) from [http://bit.ly/ng2be-8-3-appts](http://bit.ly/ng2be-8-3-appts)
    into your local `app.ts`. Remember to delete the two extraneous declarations that
    we have already imported above.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 有时依赖关系还有其他依赖，因此最好一次性从 Angular 1 中引入所有服务依赖。将 Angular 1 依赖注册的列表（使用 `upgradeNg1Provider`
    完成）从 [http://bit.ly/ng2be-8-3-appts](http://bit.ly/ng2be-8-3-appts) 复制到你的本地 `app.ts`。记得删除我们已经导入的两个多余的声明。
- en: Back to component integration! As the `ExercisesNavComponent` is rendered inside
    an Angular 1 view, it needs to be registered as an *Angular 1 directive*.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 回到组件集成！由于 `ExercisesNavComponent` 在 Angular 1 视图中呈现，因此需要将其注册为 *Angular 1 指令*。
- en: Registering Angular 2 components as directives
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Angular 2 组件注册为指令
- en: '`ExercisesNavComponent` is an Angular 2 component, but it can be converted
    into an Angular 1 directive. Open `app.ts` and add the highlighted lines:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExercisesNavComponent` 是一个 Angular 2 组件，但它可以转换为 Angular 1 指令。打开 `app.ts` 并添加以下突出显示的行：'
- en: '[PRE72]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This time the `UpgradeAdapter` function used is `downgradeNg2Component`. This
    function returns a *factory function* containing the *directive definition object*.
    We register the component as an Angular 1 directive, `exerciseNav`.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 这次使用的 `UpgradeAdapter` 函数是 `downgradeNg2Component`。该函数返回一个包含 *指令定义对象* 的 *工厂函数*。我们将组件注册为
    Angular 1 指令，`exerciseNav`。
- en: Note
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every Angular 2 component is registered as an *element directive* when used
    in Angular 1.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Angular 2 组件在 Angular 1 中使用时都被注册为 *元素指令*。
- en: The component implementation is complete. We now need to clean up the old code
    and inject the new directive in the view.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 组件实现已经完成。现在我们需要清理旧代码，并在视图中注入新指令。
- en: 'Open `app.ts` and add the import statement to import the newly created component:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app.ts` 并添加导入语句以导入新创建的组件：
- en: '[PRE73]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Delete the definition of `ExercisesNavController` from `exercise.js`, and replace
    the content of `left-nav-exercises.html` (located in the `partials` folder) with:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `exercise.js` 中删除 `ExercisesNavController` 的定义，并用 `partials` 文件夹中的 `left-nav-exercises.html`
    替换其内容：
- en: '[PRE74]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: And we are good to go.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备就绪。
- en: Angular 1 still loads `left-nav-exercises.html` as part of the route transition,
    but the view inside is an Angular 2 component.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 1仍然将`left-nav-exercises.html`作为路由转换的一部分加载，但内部视图是一个Angular 2组件。
- en: Go ahead and try out the new implementation. Create a new workout and try to
    add exercises from the left nav. The functionality should work as before.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 继续尝试新的实现。创建一个新的锻炼并尝试从左侧导航中添加练习。功能应该像以前一样工作。
- en: Note
  id: totrans-714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Look at `ng2-checkpoint8.3` in case you are facing issues upgrading to Angular
    2.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在升级到Angular 2时遇到问题，请查看`ng2-checkpoint8.3`。
- en: You can compare the git branches `ng2-checkpoint8.2` and `ng2-checkpoint8.3`
    to understand what has changed ([http://bit.ly/ng2be-compare-8-2-8-3](http://bit.ly/ng2be-compare-8-2-8-3)).
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以比较git分支`ng2-checkpoint8.2`和`ng2-checkpoint8.3`来了解发生了什么变化（[http://bit.ly/ng2be-compare-8-2-8-3](http://bit.ly/ng2be-compare-8-2-8-3)）。
- en: While we have only migrated a trivial component, this exercise highlights how
    easy it is to convert/downgrade an Angular 2 component to the Angular 1 directive
    and use it in Angular 1 view. The overall encapsulation of an Angular 2 component
    makes this chore easy.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只迁移了一个微不足道的组件，但这个练习突显了将Angular 2组件转换/降级为Angular 1指令并在Angular 1视图中使用是多么容易。Angular
    2组件的整体封装使得这个任务变得容易。
- en: 'This downgraded component can even take an input from the parent scope using
    the all-so-familiar Angular 2 property binding syntax:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 这个降级的组件甚至可以使用所有熟悉的Angular 2属性绑定语法从父作用域中获取输入：
- en: '[PRE75]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Add to that, the event raised by the component can be subscribed by the Angular
    1 container scope too:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组件引发的事件也可以由Angular 1容器作用域订阅：
- en: '[PRE76]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We now have an Angular 2 component running inside Angular 1 using services initially
    designed for Angular 1\. A promising start to our migration journey!
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个Angular 2组件在最初设计用于Angular 1的服务中运行。这是我们迁移旅程的一个有希望的开始！
- en: Before we move any further, it's time to highlight how this collaboration works
    and the rules of engagement.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，是时候强调这种协作是如何工作的和规则的参与了。
- en: Rules of engagement
  id: totrans-724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规则的参与
- en: The migration story from Angular 1 to Angular 2 is only possible because these
    frameworks can coexist, and possibly share data. There are some touch points where
    the boundaries can be crossed. To have a better sense of how a hybrid application
    works and what is achievable in such a setup, we need to understand the areas
    of collaboration between the two frameworks.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular 1到Angular 2的迁移故事之所以可能，是因为这些框架可以共存，并可能共享数据。有一些接触点可以跨越边界。为了更好地了解混合应用程序的工作原理以及在这种设置中可以实现什么，我们需要了解两个框架之间的协作领域。
- en: 'There are three areas that need discussion:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个需要讨论的领域：
- en: Template interleaving in DOM
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM中的模板交错
- en: Dependency injection
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Change detection
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更检测
- en: 'Since Angular 2 components and Angular 1 directives can coexist in a DOM, the
    question we need to answer is: Who owns what parts of the DOM?'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular 2组件和Angular 1指令可以共存于DOM中，我们需要回答的问题是：谁拥有DOM的哪些部分？
- en: Angular 1 directives and Angular 2 components
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular 1指令和Angular 2组件
- en: 'When it comes to ownership of a DOM element, the golden rule is:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到DOM元素的所有权时，黄金法则是：
- en: '*Every DOM element is owned/managed by exactly one of the Angular frameworks.*'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个DOM元素都由Angular框架中的一个管理/拥有。*'
- en: Take our previous migration example. The view that is part of `ExercisesNavComponent`
    is managed by Angular 2, whereas the container view (`left-nav-exercises.html`)
    is managed by Angular 1.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的迁移示例。`ExercisesNavComponent`的视图由Angular 2管理，而容器视图（`left-nav-exercises.html`）由Angular
    1管理。
- en: 'Things get a bit tricky at the boundaries of these directives and components.
    Consider the declaration inside `left-nav-exercises.html`:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些指令和组件的边界处有些棘手的事情。考虑`left-nav-exercises.html`中的声明：
- en: '[PRE77]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Who owns this? The short answer is Angular 1.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 谁拥有这个？简短的答案是Angular 1。
- en: 'While this is an Angular 2 component, the host element is owned by Angular
    1\. This means all Angular 1 template syntax works:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个Angular 2组件，但宿主元素由Angular 1拥有。这意味着所有Angular 1模板语法都适用：
- en: '[PRE78]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As these components and directives coexist in the same view, they often need
    to communicate. There are two ways to manage this communication:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些组件和指令共存于同一个视图中，它们经常需要进行通信。管理这种通信有两种方式：
- en: 'Using templating capabilities of Angular 1 and Angular 2:'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular 1和Angular 2的模板能力：
- en: An Angular 2 component embedded inside an Angular 1 view can take inputs from
    the parent scope using event and property binding
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入在Angular 1视图中的Angular 2组件可以通过事件和属性绑定从父作用域获取输入
- en: In a similar fashion, if a directive is injected into an Angular 2 component
    view, it too can get inputs from the parent component and call the parent component
    function (through its isolated scope)
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，如果一个指令被注入到Angular 2组件视图中，它也可以从父组件获取输入，并调用父组件函数（通过其隔离作用域）
- en: Using shared services. We saw an example of this previously as we injected the
    `WorkoutService` and `WorkoutBuilderService` Angular 1 services into `ExercisesNavComponent`.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享服务。我们之前看到了一个例子，我们将`WorkoutService`和`WorkoutBuilderService` Angular 1服务注入到`ExercisesNavComponent`中。
- en: Note
  id: totrans-745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Injecting Angular 1 directives into Angular 2 is a bit tricky. To be able to
    inject an Angular 1 directive into an Angular 2 template, the directive needs
    to abide by some rules. We will talk about these rules in the coming sections.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 将Angular 1指令注入到Angular 2中有点棘手。要能够将Angular 1指令注入到Angular 2模板中，该指令需要遵守一些规则。我们将在接下来的部分讨论这些规则。
- en: Sharing functionality using services is far more flexible compared to sharing
    through view templates. Injecting services across framework boundaries requires
    us to register the service across both frameworks and let Angular take care of
    the rest. Let's learn how dependency injection works across boundaries.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务共享功能比通过视图模板共享要灵活得多。在跨框架边界注入服务需要我们在两个框架中注册服务，并让Angular来处理其余部分。让我们学习一下跨边界的依赖注入是如何工作的。
- en: Resource sharing and dependency injection
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源共享和依赖注入
- en: How dependencies are registered in a hybrid app is driven by how DI works in
    these two frameworks. For Angular 1, there is only one global injector, whereas
    Angular 2 has a concept of hierarchical injectors. In a hybrid environment, the
    least common denominator is the global injector that both the frameworks support.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合应用中，依赖项的注册方式受这两个框架中DI的工作方式的驱动。对于Angular 1，只有一个全局注入器，而Angular 2有一个分层注入器的概念。在混合环境中，最小公分母是两个框架都支持的全局注入器。
- en: Sharing an Angular 1 service
  id: totrans-750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享一个Angular 1服务
- en: 'Dependencies defined in Angular 1 can be used in Angular 2 once they are registered
    with Angular 2''s *app injector* (root injector). The `UpgradeAdapter` function
    `upgradeNg1Provider` handles this:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 1中定义的依赖项一旦在Angular 2的*app注入器*（根注入器）中注册后，就可以在Angular 2中使用。`UpgradeAdapter`函数`upgradeNg1Provider`处理了这个问题：
- en: '[PRE79]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Since dependency injection in Angular 1 is *string-token-based*, the first parameter
    is the name of the service (the string token). The second parameter allows us
    to register a custom Angular 2 token for the v1 service.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular 1中的依赖注入是*基于字符串标记*的，第一个参数是服务的名称（字符串标记）。第二个参数允许我们为v1服务注册一个自定义的Angular
    2标记。
- en: 'This is what we did in the exercise `nav` component migrated earlier:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前迁移的`nav`组件中所做的练习：
- en: '[PRE80]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'When it comes to injecting the dependency in Angular 2, we require the `Inject`
    decorator (*with string token*) for injection:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及在Angular 2中注入依赖时，我们需要使用`Inject`装饰器（*带有字符串标记*）进行注入：
- en: '[PRE81]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `WorkoutService` is a generic provider registers with Angular 1\. Had this
    been a TypeScript class, the registration could have been done using an extra
    class token:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutService`是一个通用的提供者，注册到Angular 1中。如果这是一个TypeScript类，注册可以使用额外的类令牌完成：'
- en: '[PRE82]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'And injected using the all-so-familiar type injection with no decorators required:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以使用熟悉的类型注入而无需装饰器：
- en: '[PRE83]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Sharing an Angular 2 service
  id: totrans-762
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享一个Angular 2服务
- en: 'Services from Angular 2 too can be injected into Angular 1\. Since Angular
    1 only has a global injector, the dependency is registered at the global level.
    The `UpgradeAdapter` function that does this is:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Angular 2的服务也可以被注入到Angular 1中。由于Angular 1只有一个全局注入器，所以依赖项是在全局级别注册的。执行此操作的`UpgradeAdapter`函数是：
- en: '[PRE84]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `downgradeNg2Provider` creates a factory function than can be consumed
    by the Angular 1 module''s `factory` API:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '`downgradeNg2Provider`创建了一个工厂函数，可以被Angular 1模块的`factory` API使用：'
- en: '[PRE85]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`MyService` can now be injected across the Angular 1 app, like any other service.'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyService`现在可以像任何其他服务一样在整个Angular 1应用程序中被注入。'
- en: '`UpgradeAdapter` makes sure that only a single instance of the dependency is
    created and shared across the frameworks.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpgradeAdapter`确保只创建一个依赖项的单个实例，并在框架之间共享。'
- en: 'Look at the following diagram; it summarizes what we have discussed:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表；它总结了我们讨论过的内容：
- en: '![Sharing an Angular 2 service](../Images/image00418.jpeg)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
  zh: '![共享一个Angular 2服务](../Images/image00418.jpeg)'
- en: One last topic of this discussion is *change detection*.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 本次讨论的最后一个主题是*变更检测*。
- en: Change detection
  id: totrans-772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更检测
- en: In a hybrid application, change detection is managed by Angular 2\. If you are
    used to calling `$scope.$apply()` in your code, you don't need to in a hybrid
    application.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合应用程序中，变更检测由Angular 2管理。如果你习惯在你的代码中调用`$scope.$apply()`，在混合应用程序中就不需要了。
- en: We have already discussed how Angular 2 change detection works. The Angular
    2 framework takes care of triggering Angular 1 change detection by internally
    calling `$scope.$apply()` on standard triggering points.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Angular 2变更检测的工作原理。Angular 2框架通过在标准触发点内部调用`$scope.$apply()`来触发Angular
    1变更检测。
- en: Now that we understand the rules of engagement, it is easier to comprehend how
    things work, what's feasible, and what's not.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了参与规则，更容易理解事情是如何工作的，什么是可行的，什么是不可行的。
- en: Let's set some bigger/meatier targets and migrate the start and finish pages
    of the v1 app.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设定一些更大/更丰富的目标，并迁移v1应用程序的起始页和完成页。
- en: Migrating the start and finish pages
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移起始页和完成页
- en: The finish page is easy to migrate, and I suggest you do it yourself. Create
    a folder called `finish` inside the `js` folder, and create three files, `finish-component.ts`,
    `finish-component.tpl.html`, and `finish.module.ts`, for the component's code
    and view template and the module definition. Implement the component.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 完成页很容易迁移，我建议你自己来做。在`js`文件夹内创建一个名为`finish`的文件夹，并创建三个文件，`finish-component.ts`，`finish-component.tpl.html`和`finish.module.ts`，用于组件的代码和视图模板以及模块定义。实现这个组件。
- en: Import the finish module into `AppModule` (`app.module.ts`). And then fix the
    route for finish to load the finish component.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 将完成模块导入到`AppModule`（`app.module.ts`）中。然后修复完成的路由以加载完成组件。
- en: '[PRE86]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Lastly, remember to delete the finish html template from the `partials/workout`
    folder.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记得从`partials/workout`文件夹中删除完成的html模板。
- en: Note
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are stuck in migrating the finish page, compare the `ng2-checkpoint8.3`
    and `ng2-checkpoint8.4` git branches to understand what has changed in the `8.4`
    branch ([http://bit.ly/ng2be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)).
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在迁移完成页时遇到困难，请比较`ng2-checkpoint8.3`和`ng2-checkpoint8.4` git分支，了解`8.4`分支中发生了什么变化（[http://bit.ly/ng2be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)）。
- en: The finish page was easy, the start page is not! While the start page seems
    to be an easy target, there are some challenges that require some head-scratching.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 完成页面很容易，但起始页面不是！虽然起始页面似乎是一个容易的目标，但有一些挑战需要一些深思熟虑。
- en: The biggest issue with the start page is that it uses a third-party library,
    *angular-translate*, to localize the content of the page. Since we are migrating
    the complete page/view to Angular 2, we need a mechanism to handle these Angular
    1 library dependencies.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 起始页面最大的问题是它使用了第三方库*angular-translate*来本地化页面的内容。由于我们将完整页面/视图迁移到Angular 2，我们需要一种机制来处理这些Angular
    1库的依赖关系。
- en: '*angular-translate* comes with a *filter* (*pipe* in the Angular 2 world) and
    a directive, both named `translate`. Their job is to translate string tokens into
    localized string literals.'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '*angular-translate*带有一个*filter*（在Angular 2世界中是*pipe*）和一个指令，都名为`translate`。它们的工作是将字符串标记翻译成本地化的字符串文字。'
- en: 'Now that the *start* page becomes an Angular 2 component, we need to convert
    the filter into an Angular 2 pipe and, in some way, make the `translate` directive
    work in Angular 2\. The migration choices we have in this case are as follows:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 现在*start*页面变成了一个Angular 2组件，我们需要将过滤器转换为Angular 2管道，并以某种方式使`translate`指令在Angular
    2中工作。在这种情况下，我们的迁移选择如下：
- en: Create a new filter and upgrade the v1 `translate` directive using `UpgradeAdapter`.
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的过滤器，并使用`UpgradeAdapter`升级v1的`translate`指令。
- en: Find a suitable replacement for angular-translate in Angular 2 world.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular 2世界中找到*angular-translate*的合适替代品。
- en: Although the first choice seems to be the easiest, it has some serious limitations.
    Angular 2 `UpgradeApapter` comes with an `upgradeNg1Component` function, which
    can upgrade any Angular 1 directive. Not really! There are some stringent requirements
    around which a directive can be upgraded to Angular 2.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第一个选择似乎是最简单的，但它有一些严重的限制。Angular 2 `UpgradeApapter`带有一个`upgradeNg1Component`函数，可以升级任何Angular
    1指令。并非如此！在哪些指令可以升级到Angular 2周围有一些严格的要求。
- en: Note
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Upgrade of an Angular 1 component does not mean the component has been migrated.
    Angular 2 instead allows us to use an Angular 1 element directive as-is inside
    Angular 2 component views.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 升级Angular 1组件并不意味着该组件已经迁移。相反，Angular 2允许我们在Angular 2组件视图中直接使用Angular 1元素指令。
- en: Angular 1 directive upgrade
  id: totrans-793
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular 1指令升级
- en: 'At times, the parts of an application may be migrated in a top-down fashion;
    a higher order view is converted into a component. In such a case, instead of
    migrating all the custom directives that are part of the Angular 1 view, we just
    upgrade them to Angular 2 components using the `UpgradeAdpater` function `upgradeNg1Component`.
    The following diagram illustrates this migration path:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序的部分可能以自上而下的方式迁移；一个高级别视图被转换为一个组件。在这种情况下，我们不是迁移Angular 1视图中的所有自定义指令，而是使用`UpgradeAdpater`函数`upgradeNg1Component`将它们升级为Angular
    2组件。以下图表说明了这种迁移路径：
- en: '![Angular 1 directive upgrade](../Images/image00419.jpeg)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 1指令升级](../Images/image00419.jpeg)'
- en: The Angular 2 framework puts some restrictions around what can be upgraded to
    an Angular 2 component. Here is an excerpt from the Angular 2 migration guide.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2框架对可以升级为Angular 2组件的内容施加了一些限制。以下是来自Angular 2迁移指南的摘录。
- en: 'To be Angular 2 compatible, an Angular 1 component directive should configure
    these attributes: `restrict: ''E''`. Components are usually used as elements.'
  id: totrans-797
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '要使Angular 1组件指令与Angular 2兼容，应配置这些属性：`restrict: ''E''`。组件通常用作元素。'
- en: '>'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '`scope: {}` - an isolated scope. In Angular 2, components are always isolated
    from their surroundings, and we should do this in Angular 1 too.'
  id: totrans-799
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`scope: {}` - 一个隔离的作用域。在Angular 2中，组件总是与其周围隔离的，我们在Angular 1中也应该这样做。'
- en: '>'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '`bindToController: {}`. Component inputs and outputs should be bound to the
    controller instead of using the $scope.'
  id: totrans-801
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`bindToController: {}`。组件的输入和输出应该绑定到控制器，而不是使用$scope。'
- en: '>'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '`controller` and `controllerAs`. Components have their own controllers. template
    or templateUrl. Components have their own templates.'
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`controller`和`controllerAs`。组件有自己的控制器。template或templateUrl。组件有自己的模板。'
- en: '>'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: 'Component directives may also use the following attributes:'
  id: totrans-805
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 组件指令也可以使用以下属性：
- en: '>'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '`transclude: true`, if the component needs to transclude content from elsewhere.'
  id: totrans-807
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`transclude: true`，如果组件需要从其他地方传递内容。'
- en: '>'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '`require`, if the component needs to communicate with some parent component''s
    controller.'
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`require`，如果组件需要与某个父组件的控制器通信。'
- en: '>'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: 'Component directives **may not** use the following attributes:'
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 组件指令**不得**使用以下属性：
- en: '>'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '`compile`. This will not be supported in Angular 2.'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`compile`。这在Angular 2中将不再受支持。'
- en: '>'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '`replace`: true. Angular 2 never replaces a component element with the component
    template. This attribute is also deprecated in Angular 1.'
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`replace`: true。Angular 2永远不会用组件模板替换组件元素。这个属性在Angular 1中也已经被弃用。'
- en: '>'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '`priority` and `terminal`. While Angular 1 components may use these, they are
    not used in Angular 2 and it is better not to write code that relies on them.'
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`priority`和`terminal`。虽然Angular 1组件可以使用这些属性，但在Angular 2中不使用，最好不要编写依赖于它们的代码。'
- en: Tip
  id: totrans-818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The only Angular 1 directives that can be upgraded to Angular 2 are element
    directives, given that all other conditions are met.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一可以升级到Angular 2的Angular 1指令是元素指令，前提是满足所有其他条件。
- en: With this sizeable laundry list, upgrading an Angular 1 directive to Angular
    2 is difficult, when compared to an Angular 2 component downgrade. More often
    than not, we have to do an actual code migration of an Angular 1 directive if
    the parent view has been migrated to Angular 2.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这么多的待办事项清单，将Angular 1指令升级到Angular 2相对困难，而将Angular 2组件降级则更容易。往往情况下，如果父视图已经迁移到Angular
    2，我们必须对Angular 1指令进行实际的代码迁移。
- en: Looking at the *angular-translate* source code, we realize it uses the `$compile`
    service; therefore, the upgrade option is ruled out. We need to find an alternative
    library.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 查看*angular-translate*的源代码，我们意识到它使用了`$compile`服务；因此，升级选项被排除在外。我们需要找到一个替代库。
- en: We do have an internationalization library for Angular 2, `ng2-translate` ([http://bit.ly/ng2-translate](http://bit.ly/ng2-translate)).
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实有一个针对Angular 2的国际化库，`ng2-translate` ([http://bit.ly/ng2-translate](http://bit.ly/ng2-translate))。
- en: Replacing angular-translate with ng2-translate
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用ng2-translate替换angular-translate
- en: '*ng2-translate* is an internationalization library that targets Angular 2\.
    This library can replace v1 *angular-translate*.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '*ng2-translate*是一个针对Angular 2的国际化库。这个库可以替代v1 *angular-translate*。'
- en: 'Install the npm package for `ng2-translate`:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`ng2-translate`的npm包：
- en: '[PRE87]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Update `systemjs.config.js` to include the `ng2-translate` library. Add entries
    to the `map` and `packages` properties:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`systemjs.config.js`以包括`ng2-translate`库。在`map`和`packages`属性中添加条目：
- en: '[PRE88]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`ng2-translate` needs to be configured at the module level, so update `app.module.ts`
    with the highlighted code:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng2-translate`需要在模块级别进行配置，因此请使用突出显示的代码更新`app.module.ts`：'
- en: '[PRE89]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The preceding provider declaration sets up a loader that loads the translation
    files (`.json`) from the `i18n` folder. The `HttpModule` import is required for
    the translate library to load translations from server.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的提供者声明设置了一个加载器，从`i18n`文件夹加载翻译文件（`.json`）。`HttpModule`导入是必需的，以便翻译库从服务器加载翻译。
- en: 'These statements require imports to keep the TypeScript compiler happy. Add
    these import statements to `app.module.ts`:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句需要导入以使TypeScript编译器满意。将这些导入语句添加到`app.module.ts`：
- en: '[PRE90]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `ng2-translate` library is now ready to be used.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng2-translate`库现在已经准备好使用。'
- en: The first thing that we are going to do is set the default translation language
    as soon as the application bootstraps.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事就是在应用程序引导时设置默认的翻译语言。
- en: Using a bootstrap-ready callback for initialization
  id: totrans-836
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用一个用于初始化的bootstrap-ready回调
- en: With Angular 2, luckily the bootstrap function on `UpdateAdapter` has a `ready`
    callback function just for this purpose. It is invoked after both the frameworks
    bootstrap.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Angular 2，幸运的是`UpdateAdapter`上的bootstrap函数有一个专门用于此目的的`ready`回调函数。它在两个框架的引导之后被调用。
- en: 'Update the bootstrap function in `app.ts` with the following code snippet:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.ts`中更新bootstrap函数，使用以下代码片段：
- en: '[PRE91]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And add an import for `TranslateService`:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 并添加一个对`TranslateService`的导入：
- en: '[PRE92]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The code tries to determine the current browser language and sets the current
    language for translations accordingly. Make note of how we get hold of `TranslateService`.
    The `UpgradeAdapterRef` object holds the reference to the Angular 2 *root injector*,
    which in turn loads `ng2-translate`'s `TranslateService`.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 代码尝试确定当前浏览器语言，并相应地设置翻译的当前语言。注意我们如何获取`TranslateService`。`UpgradeAdapterRef`对象持有对Angular
    2 *root injector*的引用，后者又加载了`ng2-translate`的`TranslateService`。
- en: Next copy the three files related to start page implementation, from the `ng2-checkpoint8.4`
    branch ([http://bit.ly/ng2be-8-4-start](http://bit.ly/ng2be-8-4-start)) into a
    new folder `app/js/start`.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`ng2-checkpoint8.4`分支（[http://bit.ly/ng2be-8-4-start](http://bit.ly/ng2be-8-4-start)）复制与开始页面实现相关的三个文件到一个新的文件夹`app/js/start`中。
- en: 'The start component now needs to be registered as an Angular 1 directive before
    use. Add this statement to `app.ts`:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始组件在使用之前需要注册为Angular 1指令。将此语句添加到`app.ts`中：
- en: '[PRE93]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The start template file now uses the `translate` pipe (*the name of the pipe
    is the same as the Angular 1 filter * `translate`).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始模板文件使用`translate` pipe（*pipe的名称与Angular 1的filter `translate`相同*）。
- en: 'The page also has some pipes, which are used to search and sort the workout
    list shown on the page:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 页面还有一些pipes，用于搜索和排序页面上显示的训练列表：
- en: '[PRE94]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We now need to add implementation for the pipes `orderBy` and `search`. Copy
    the complete code from `ng2-checkpoint8.4` ([http://bit.ly/ng2be-8-4-pipests](http://bit.ly/ng2be-8-4-pipests))
    and add it to a new file, `js/shared/pipes.ts` locally. We will not dwell into
    any of the pipe implementation here as we have done that already in earlier chapters.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为`orderBy`和`search`的pipes添加实现。从`ng2-checkpoint8.4`（[http://bit.ly/ng2be-8-4-pipests](http://bit.ly/ng2be-8-4-pipests)）复制完整的代码，并将其添加到一个新文件`js/shared/pipes.ts`中。我们不会在这里深入讨论任何pipe的实现，因为我们在之前的章节中已经做过了。
- en: Yet again we create a new Angular 2 module to share these pipes across the application.
    Copy the module definition from `ng2-checkpoint8.4` ([http://bit.ly/ng2be-shared-module-ts](http://bit.ly/ng2be-shared-module-ts))
    into the local `js/shared` folder, and import it into `app.module.ts`.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 再次创建一个新的Angular 2模块，以在整个应用程序中共享这些pipes。从`ng2-checkpoint8.4`（[http://bit.ly/ng2be-shared-module-ts](http://bit.ly/ng2be-shared-module-ts)）复制模块定义到本地的`js/shared`文件夹，并将其导入`app.module.ts`。
- en: Note
  id: totrans-851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have previously migrated the `secondsToTime` (available in `js/7MinWorkout/filters.js`)
    filter to Angular 2, and the implementation is available in the `pipes.ts` file.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经将`secondsToTime`（在`js/7MinWorkout/filters.js`中可用）过滤器迁移到了Angular 2，并且实现已经在`pipes.ts`文件中可用。
- en: Start and finish component implementation is complete. Let's integrate them
    into the app.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和结束组件的实现已经完成。让我们将它们集成到应用程序中。
- en: Integrating the start and finish pages
  id: totrans-854
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成开始和结束页面
- en: Start/finish views are loaded as part of route change; hence we need to fix
    the route definition.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 开始/结束视图作为路由更改的一部分加载；因此我们需要修复路由定义。
- en: 'Open `app.ts` and add imports for start and finish:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.ts`并添加对start和finish的导入：
- en: '[PRE95]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The route definitions are in `config.js`. Update the start and finish route
    definitions to:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义在`config.js`中。将开始和结束路由定义更新为：
- en: '[PRE96]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The route template html is a part of the Angular 1 view. Since we have registered
    both `StartComponent` and `FinishComponent` as Angular 1 directives, the route
    loads the correct components.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模板html是Angular 1视图的一部分。由于我们已经将`StartComponent`和`FinishComponent`注册为Angular
    1指令，路由加载了正确的组件。
- en: Note
  id: totrans-861
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have already migrated the finish page, you do not need to redo the import
    and route setup for finish as described.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经迁移了完成页面，那么您不需要按照描述重新导入和设置完成的路由。
- en: A few more fixes are pending before we can test the implementation.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试实现之前还有一些修复工作要做。
- en: 'Update `app-ng1.module.ts` with modules for `start` and `finish`:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块更新`app-ng1.module.ts`，包括`start`和`finish`：
- en: '[PRE97]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Finally copy the translation files `de.json` and `en.json` from the `ng2-checkpoint8.4`
    folder `i18n` ([http://bit.ly/ng2-8-4-i18n](http://bit.ly/ng2-8-4-i18n)). Now
    we are ready to be test what we have developed.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从`ng2-checkpoint8.4`文件夹`i18n`中复制翻译文件`de.json`和`en.json`（[http://bit.ly/ng2-8-4-i18n](http://bit.ly/ng2-8-4-i18n)）。现在我们准备测试我们开发的内容。
- en: If not started, start the TypeScript compiler and *HTTP-server*, and then launch
    the browser. The start and finish pages should load just fine. But the translations
    do not work! Clicking on the language translation links on the top nav has no
    affect. Content always renders in English.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有启动，请启动TypeScript编译器和*HTTP服务器*，然后启动浏览器。开始和结束页面应该可以正常加载。但是翻译不起作用！点击顶部导航栏上的语言翻译链接没有任何影响。内容始终以英文呈现。
- en: Note
  id: totrans-868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are stuck, compare the git branches `ng2-checkpoint8.3` and `ng2-checkpoint8.4`
    to understand what changed ([http://bit.ly/ng2be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)).
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到困难，请比较git分支`ng2-checkpoint8.3`和`ng2-checkpoint8.4`，了解发生了什么变化（[http://bit.ly/ng2be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)）。
- en: Translations still do not work because the top nav code (`root.js`) that enables
    translation is still using the older library. We need to get rid of angular-translate
    (the v1 library) altogether. Having two libraries doing the same work is not something
    we want, but removing it is also not that simple.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译仍然不起作用，因为启用翻译的顶部导航栏代码（`root.js`）仍在使用旧库。我们需要摆脱angular-translate（v1库）。有两个库做同样的工作并不是我们想要的，但是移除它也不是那么简单。
- en: Getting rid of angular-translate
  id: totrans-871
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摆脱angular-translate
- en: 'To get rid of angular-translate (v1) library we need to:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 为了摆脱angular-translate（v1）库，我们需要：
- en: Remove the angular-translate's directive/filter references from all Angular
    1 views.
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从所有Angular 1视图中删除angular-translate的指令/过滤器引用。
- en: Get rid of any code that uses this library.
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆脱任何使用这个库的代码。
- en: Getting rid of the v1 directive/filter altogether is a difficult task. We can
    neither add the v2 ng2-translate pipe in the Angular 1 view nor can we migrate
    every view using the v1 directive/filter to Angular 2 at one shot.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 摆脱v1指令/过滤器是一项艰巨的任务。我们既不能在Angular 1视图中添加v2 ng2-translate管道，也不能一次性将使用v1指令/过滤器的每个视图迁移到Angular
    2。
- en: Why not write a new Angular 1 filter that uses the ng2-translate's translation
    service (`TranslateService`) for translations and then use the new filter everywhere?
    Problems solved!
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不编写一个新的Angular 1过滤器，使用ng2-translate的翻译服务（`TranslateService`）进行翻译，然后在所有地方使用新的过滤器？问题解决！
- en: Let's call this filter `ng2Translate`. We replace all references to the `translate`
    filter in v1 view with `ng2Translate`. All v1 `translate` directive references
    should also be replaced with `ng2Translate` filter.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这个过滤器为`ng2Translate`。我们用`ng2Translate`替换v1视图中对`translate`过滤器的所有引用。所有v1 `translate`指令引用也应该被替换为`ng2Translate`过滤器。
- en: 'Here is how the filter implementation looks like:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是过滤器实现的样子：
- en: '[PRE98]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Create a file called `filters.ts` in the `shared` folder and add the preceding
    implementation. The filter uses `TranslateService` (registered in Angular 1 as
    `ng2TranslateService`) to map string tokens to localized content. To test this
    implementation, there are a few more steps needed:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shared`文件夹中创建一个名为`filters.ts`的文件，并添加上述实现。该过滤器使用`TranslateService`（在Angular
    1中注册为`ng2TranslateService`）将字符串标记映射到本地化内容。为了测试这个实现，还需要进行一些步骤：
- en: 'Replace all references to `translate` (directive and filter) across the Angular
    1 view with `ng2Translate`. There are references in these files: `description-panel.html`,
    `video-panel.html`, `workout.html` (in the folder `partials/workout`), and `index.html`.
    Replacing the filter in the interpolation is a simple exercise, and for the `translate`
    directive, replace it with interpolation. For example in `partials/workout/description-panel.html`,
    the line of code is as follows:'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular 1视图中，用`ng2Translate`替换所有对`translate`（指令和过滤器）的引用。这些文件中有引用：`description-panel.html`、`video-panel.html`、`workout.html`（在`partials/workout`文件夹中）和`index.html`。在插值中替换过滤器是一个简单的练习，对于`translate`指令，用插值替换它。例如，在`partials/workout/description-panel.html`中，代码行如下：
- en: '[PRE99]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'It then becomes the following:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 然后变成以下内容：
- en: '[PRE100]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Remember to quote the string token (`'RUNNER.STEPS'`) inside the interpolation.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在插值中引用字符串标记（`'RUNNER.STEPS'`）。
- en: 'Import the filter into `app.ts`:'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将过滤器导入到`app.ts`中：
- en: '[PRE101]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `ng2Translate` filter depends upon the `TranslateService`; hence needs
    to be registered with the Angular 1 injector using (in `app.ts` again):'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng2Translate`过滤器依赖于`TranslateService`；因此需要在Angular 1注入器中注册（在`app.ts`中）：'
- en: '[PRE102]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Angular 2's `TranslateService` is registered as `ng2TranslateService` in Angular
    1.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 1中，`TranslateService`被注册为`ng2TranslateService`。
- en: Finally copy the updated `root.js` from [http://bit.ly/ng2-migrate-root-no-trasnlate](http://bit.ly/ng2-migrate-root-no-trasnlate).
    We have replace all references to `$translate` service with `ng2TranslateService`,
    and refactored the code to use the new service. `root.js` contains the implementation
    for v1 `RootController`.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，从[http://bit.ly/ng2-migrate-root-no-trasnlate](http://bit.ly/ng2-migrate-root-no-trasnlate)复制更新的`root.js`。我们已经用`ng2TranslateService`替换了所有对`$translate`服务的引用，并重构了代码以使用新的服务。`root.js`包含了v1
    `RootController`的实现。
- en: We are good to go now. Try out the new implementation, the app should load translation
    with using ng2-translate library.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始了。尝试新的实现，应用程序应该使用ng2-translate库加载翻译。
- en: We can now delete all references to angular-translate. There are references
    in `index.html`, `app.module.ts` and `config.js`.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以删除所有对angular-translate的引用。在`index.html`、`app.module.ts`和`config.js`中都有引用。
- en: The migration of the start and finish pages is complete and it's time to look
    at some other targets.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和完成页面的迁移已经完成，现在是时候看看其他目标了。
- en: Note
  id: totrans-895
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Compare the branches `ng2-checkpoint8.4` and `ng2-checkpoint8.5` to understand
    the new changes in `ng2-checkpoint8.5` ([http://bit.ly/ng2be-compare-8-4-8-5](http://bit.ly/ng2be-compare-8-4-8-5)).
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 比较`ng2-checkpoint8.4`和`ng2-checkpoint8.5`分支，了解`ng2-checkpoint8.5`中的新变化（[http://bit.ly/ng2be-compare-8-4-8-5](http://bit.ly/ng2be-compare-8-4-8-5)）。
- en: The next few migrations that we detail in the coming sections will not be as
    descriptive as earlier migrations. We strongly recommend you look at the relevant
    commits on the `angular2-migrate-ts` branch to understand how things move forward.
    We will only highlight relevant details for the coming migrations.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个迁移中，我们将不像之前的迁移那样描述详细。我们强烈建议您查看`angular2-migrate-ts`分支上的相关提交，以了解事情是如何进行的。我们只会强调接下来的迁移的相关细节。
- en: Replacing the ui-bootstrap library
  id: totrans-898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换ui-bootstrap库
- en: One thing that we have learned while migrating the start and finish pages to
    Angular 2 is how cumbersome it is to migrate third-party dependencies. Migrating
    an Angular 1 view that uses external libraries without migrating those libraries
    themselves is a challenge. We have also learned that it is much easier to embed
    an Angular 2 component inside an Angular 1 view than the other way round.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 在将开始和完成页面迁移到Angular 2时，我们学到的一件事是迁移第三方依赖项是多么繁琐。迁移使用外部库的Angular 1视图而不迁移这些库本身是一个挑战。我们还学到，将Angular
    2组件嵌入到Angular 1视图中要比反过来容易得多。
- en: Given these observations, it becomes imperative that we migrate/replace third-party
    libraries first while migrating to Angular 2.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些观察结果，迁移到Angular 2时，首先迁移/替换第三方库变得至关重要。
- en: One such library that we want to get rid of is the **ui-bootstrap** ([http://bit.ly/ng1-ui-bootstrap](http://bit.ly/ng1-ui-bootstrap))
    library. While we only use the modal dialog service from ui-bootstrap, moving
    away from it is going to be a challenge.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要摆脱的一个这样的库是**ui-bootstrap**（[http://bit.ly/ng1-ui-bootstrap](http://bit.ly/ng1-ui-bootstrap)）库。虽然我们只从ui-bootstrap中使用模态对话框服务，但摆脱它将是一个挑战。
- en: Calling this modal dialog a service `($uibModal`) would be a misnomer. While
    it is injected like a service in Angular 1, it actually manipulates the DOM and
    therefore cannot be upgraded using the `upgradeNg1Provider` function.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 称这个模态对话框为服务`($uibModal)`将是一个误称。虽然它在Angular 1中像服务一样被注入，但它实际上操作DOM，因此无法使用`upgradeNg1Provider`函数进行升级。
- en: We again need an alternate implementation for modal dialogs in Angular 2\. The
    library we choose for this exercise is angular2-modal ([http://bit.ly/ng2-modal](http://bit.ly/ng2-modal)).
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次需要一个在Angular 2中模态对话框的替代实现。我们选择的库是angular2-modal（[http://bit.ly/ng2-modal](http://bit.ly/ng2-modal)）。
- en: Personal Trainer uses angular2-modal in two places, in the top nav to show the
    workout history and during workout execution to show the exercise-related video.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: Personal Trainer在两个地方使用angular2-modal，在顶部导航中显示锻炼历史记录，以及在锻炼执行过程中显示与锻炼相关的视频。
- en: As part of migrating to angular2-modal, we also migrate **top nav** (declared
    inside `index.html`) and the **video panel** (`partials/workout/video-panel.html`).
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 作为迁移到angular2-modal的一部分，我们还迁移了**顶部导航**（在`index.html`中声明）和**视频面板**（`partials/workout/video-panel.html`）。
- en: Note
  id: totrans-906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Look at the `ng2-checkpoint8.6` GitHub branch to understand what artefacts were
    changed during this migration. We will only *highlight* things that made the migration
    challenging.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`ng2-checkpoint8.6` GitHub分支，了解在此迁移期间更改了哪些工件。我们只会*突出*使迁移具有挑战性的事项。
- en: You can also compare this branch with the previous one (`ng2-checkpoint8.5`)
    on GitHub, at [http://bit.ly/ng2be-compare-8-5-8-6](http://bit.ly/ng2be-compare-8-5-8-6),
    to know what the changes are.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在GitHub上将此分支与之前的分支（`ng2-checkpoint8.5`）进行比较，网址为[http://bit.ly/ng2be-compare-8-5-8-6](http://bit.ly/ng2be-compare-8-5-8-6)，了解有哪些变化。
- en: '*This section will detail the code in the context of the* `ng2-checkpoint8.6` *GitHub
    branch.*'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节将详细介绍*`ng2-checkpoint8.6`*GitHub分支上的代码。*'
- en: The biggest challenge with migrating to our new modal dialog library, *angular2-modal*,
    was that it required access to the root component to properly render the dialog
    in the middle of the screen. While this is not a problem in a standard Angular
    2 app, for a hybrid app, the library failed to locate the root component as there
    was none.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到我们的新模态对话框库*angular2-modal*的最大挑战是，它需要访问根组件才能正确地在屏幕中间呈现对话框。虽然这在标准的Angular 2应用程序中不是问题，但对于混合应用程序，该库无法定位根组件，因为根本就没有。
- en: Note
  id: totrans-911
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Look at the *Using angular2-modal dialog library* section in [Chapter 3](part0039.xhtml#1565U2-edca168d36254bda8a21f611a95615c3
    "Chapter 3.  More Angular 2 – SPA, Routing, and Data Flows in Depth"), *More Angular
    2 –€“ SPA, Routing, and Data Flows in Depth*, to understand how to install and
    configure the library. You can also compare the branches `ng2-checkpoint8.5` and
    `ng2-checkpoint8.6` to determine changes specific to angular2-modal.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[第3章](part0039.xhtml#1565U2-edca168d36254bda8a21f611a95615c3 "第3章。更多Angular
    2 – SPA，路由和深入数据流")中的*使用angular2-modal对话框库*部分，*更多Angular 2 – SPA，路由和深入数据流*，以了解如何安装和配置该库。您还可以比较`ng2-checkpoint8.5`和`ng2-checkpoint8.6`分支，以确定与angular2-modal相关的更改。
- en: 'To get around these limitations, we first had to restructure the Angular 1
    app, such that we have an Angular 2 root component. Such a component then encompasses
    the complete Angular 1 view. The new rendered html structure now looks like this:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些限制，我们首先必须重构Angular 1应用程序，使得我们有一个Angular 2根组件。这样的组件然后包含完整的Angular 1视图。现在新的呈现的html结构看起来像这样：
- en: '![Replacing the ui-bootstrap library](../Images/image00420.jpeg)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![替换ui-bootstrap库](../Images/image00420.jpeg)'
- en: Open `index.html`, the `ng2-root` (`Ng2RootComponent`) tag is an Angular 2 component
    that wraps the complete Angular 1 view. The existing Angular 1 view html itself
    is now wrapped inside a directive (`ng1Root`) using the `component` API. Look
    at files `ng1-root-component.ts`, `ng1-root-component.tpl.html` and `ng2-root-component.ts`
    to understand how these components are structured now and to provide angular2-modal
    `ng2-root` container reference in the `Ng2RootComponent` 's constructor.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`index.html`，`ng2-root`（`Ng2RootComponent`）标签是一个Angular 2组件，它包装了完整的Angular
    1视图。现有的Angular 1视图html现在被包装在一个指令（`ng1Root`）中，使用`component` API。查看文件`ng1-root-component.ts`，`ng1-root-component.tpl.html`和`ng2-root-component.ts`，以了解这些组件现在是如何结构化的，并在`Ng2RootComponent`的构造函数中提供angular2-modal
    `ng2-root`容器引用。
- en: 'The restructuring of root elements also employs another migration pattern.
    The Angular 2 component (`Ng2RootComponent`) transcludes the Angular 1 element
    directive (`ng1Root`). Check the view template of `Ng2RootComponent`:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素的重组还采用了另一种迁移模式。Angular 2组件（`Ng2RootComponent`）转译了Angular 1元素指令（`ng1Root`）。查看`Ng2RootComponent`的视图模板：
- en: '[PRE103]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'And it''s use in `index.html`:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`index.html`中的使用：
- en: '[PRE104]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In such a setup, while the `ng1RootComponent` is embedded inside the Angular
    2 `Ng2RootComponent`, it derives its context from the parent Angular 1 view and
    hence can access the parent scope.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的设置中，`ng1RootComponent`嵌入在Angular 2 `Ng2RootComponent`中，它从父级Angular 1视图派生其上下文，因此可以访问父级作用域。
- en: There were numerous other small changes made to the app as part of this migration,
    and comparing this branch against `ng2-checkpoint8.5` with help you understand
    what has changed.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 在此迁移的过程中，还对应用程序进行了许多其他小的更改，将此分支与`ng2-checkpoint8.5`进行比较，可以帮助您了解发生了什么变化。
- en: We will stop here and direct you to the other GitHub branches pertaining to
    migration. All branches starting with `ng2-checkpoint*` are the migration branches.
    Try to migrate the pending views and compare them with the GitHub branch changes.
    Remember, a working version of the app has already been developed in Angular 2,
    and hence there is a good reference point. Look at the `README.md` file for each
    branch to know what part of the application was migrated to Angular 2.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里停下来，引导您前往与迁移相关的其他GitHub分支。所有以`ng2-checkpoint*`开头的分支都是迁移分支。尝试迁移未完成的视图，并将其与GitHub分支更改进行比较。请记住，Angular
    2已经开发了应用程序的工作版本，因此这是一个很好的参考点。查看每个分支的`README.md`文件，了解应用程序的哪个部分已迁移到Angular 2。
- en: Meanwhile, let's summarize our learnings from the migration that we did.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们总结一下我们从迁移中学到的东西。
- en: Learnings
  id: totrans-924
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习
- en: 'We hope this migration exercise has provided enough insight into the process.
    You can now gauge the complexity, the time, and the effort required to migrate
    elements from Angular 1 to Angular 2\. Let''s highlight our learning as part of
    this process:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这次迁移练习已经为您提供了足够的洞察力。现在您可以评估从Angular 1迁移到Angular 2需要的复杂性、时间和精力。让我们将我们在这个过程中学到的知识作为亮点：
- en: '**Migration is time-consuming**: Migration by no stretch of imagination is
    a trivial exercise. Each page/view presents its own challenges that we need to
    overcome. Some elements are easy to migrate and some are not. The best thing you
    can do today if you are developing in Angular 1 would be to follow the advices
    from the *Developing Angular 1 apps today for easy migration* section.'
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移是耗时的：毫无疑问，迁移绝非一项琐事。每个页面/视图都提出了自己的挑战，我们需要克服。一些元素易于迁移，而一些则不是。如果您目前正在使用Angular
    1进行开发，最好的做法是遵循“为轻松迁移今天开发的Angular 1应用程序”部分的建议。
- en: '**Migrate third-party libraries first**: Migrating third-party libraries can
    be quite challenging. The reasons are manifold:'
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先迁移第三方库：迁移第三方库可能非常具有挑战性。原因有多种：
- en: Such libraries are used across pages
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些库在各个页面上都被使用
- en: They may not be upgradable to Angular 2 (using `UpgradeAdapter`)
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能无法升级到Angular 2（使用`UpgradeAdapter`）
- en: Migrating each view that uses such a library may not be feasible when the library
    is extensively used
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当库被广泛使用时，迁移使用该库的每个视图可能是不可行的。
- en: Tip
  id: totrans-931
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's better to identify all third-party dependencies in your app and find a
    suitable alternative for them in the Angular 2 world. If possible, develop some
    proof of concept (POC) with the new library to understand how different the new
    library is from the existing implementation.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 最好识别应用程序中的所有第三方依赖项，并在Angular 2世界中找到合适的替代方案。如果可能的话，使用新库开发一些概念验证（POC），以了解新库与现有实现有多大的不同。
- en: '**Libraries with overlap may exist**: While migrating, there could be scenarios
    where both Angular 1 and Angular 2 versions of a library coexist. Minimize this
    time period and migrate to the newer version as soon as possible.'
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在重叠的库：在迁移过程中，可能会出现Angular 1和Angular 2版本的库共存的情况。尽量缩短这段时间，并尽快迁移到更新的版本。
- en: '**It is easier to integrate Angular 2 components into Angular 1 than the other
    way round**: While migrating, migrate the complete view to Angular 2\. Due to
    the restriction imposed by Angular 2, it becomes very difficult to have a parent
    Angular 2 component with embedded Angular 1 element directives.'
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Angular 2组件集成到Angular 1中比反过来容易得多：在迁移过程中，将完整视图迁移到Angular 2。由于Angular 2施加的限制，很难将具有嵌入式Angular
    1元素指令的父级Angular 2组件。
- en: With such limitations, a bottom-up approach to migrating works better than a
    top-down approach.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种限制下，自下而上的迁移方法比自上而下的方法更有效。
- en: '**Anything non-UI-related is easy to migrate**: For *Personal Trainer*, we
    migrate the services last as they can be easily migrated.'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何与UI无关的内容都很容易迁移：对于“个人健身教练”，我们最后迁移服务，因为它们可以很容易地迁移。
- en: '**Feature parity better Angular 1 and Angular 2**: Angular 2 may not have every
    feature that Angular 1 supports. In such a case, we need workarounds to achieve
    the desired behaviour.'
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 1和Angular 2之间的功能对等性更好：Angular 2可能没有Angular 1支持的每个功能。在这种情况下，我们需要解决方法来实现期望的行为。
- en: That completes our migration story. With this, it's time to conclude the chapter
    and summarize our learnings from it.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的迁移故事。有了这个，现在是时候结束这一章并总结我们从中学到的东西了。
- en: Summary
  id: totrans-939
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gained some useful insight into a number of practical issues
    surrounding Angular development. These tips/guidelines can be extremely handy
    when building real-life applications using the framework.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对围绕Angular开发的一些实际问题有了一些有用的见解。这些建议/指南在使用该框架构建真实应用程序时非常有用。
- en: We started the chapter by exploring the concept of *seed projects* and how these
    projects can get us up and running in no time. We looked at some popular seed
    projects that can serve as a base for any new Angular app development. We also
    touched upon *Yeoman* and *angular-cli*, a suite of tools that helps us kick-start
    new projects.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从探讨“种子项目”的概念开始，以及这些项目如何让我们迅速启动和运行。我们看了一些流行的种子项目，可以作为任何新的Angular应用程序开发的基础。我们还涉及了*Yeoman*和*angular-cli*，这是一套帮助我们快速启动新项目的工具。
- en: In spite of being a server-side concern, authentication and authorization do
    affect the client implementation. The section on authentication/authorization
    covered how to handle authentication in a cookie and token-based setup.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管身为服务器端问题，身份验证和授权确实会影响客户端的实现。关于身份验证/授权的部分涵盖了如何在基于cookie和令牌的设置中处理身份验证。
- en: We looked at the ever-so-important topic of performance, where you learned ways
    to optimize an Angular app's performance.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了性能这个非常重要的话题，您学会了优化Angular应用程序性能的方法。
- en: Finally, we migrated the v1 *Personal Trainer* to Angular 2\. The gradual migration
    process taught us the intricacies of migration, the challenges faced, and the
    workaround done.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将v1的*个人教练*迁移到Angular 2。逐步迁移的过程教会了我们迁移的复杂性，所面临的挑战以及所做的变通方法。
- en: The book is coming to a close, but for everyone reading it, the journey has
    just begun. It's time to put theories into practice, hone our newly acquired skills,
    build something useful with Angular, and share it with the world. The more you
    invest in Angular, the more rewarding the framework is. Let's get started!
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 书即将结束，但对于每个阅读它的人来说，旅程才刚刚开始。是时候将理论付诸实践，磨练我们新获得的技能，用Angular构建一些有用的东西，并与世界分享。您在Angular上投入的越多，这个框架就越有回报。让我们开始吧！
