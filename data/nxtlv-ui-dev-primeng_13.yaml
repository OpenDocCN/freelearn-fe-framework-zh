- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Testing PrimeNG Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 PrimeNG 组件
- en: In this chapter, we will dive into the critical aspects of testing Angular applications
    powered by PrimeNG components. Throughout the journey, you will learn how to effectively
    test your PrimeNG components, ensuring their reliability and functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨由 PrimeNG 组件驱动的 Angular 应用程序测试的关键方面。在整个过程中，你将学习如何有效地测试你的 PrimeNG
    组件，确保它们的可靠性和功能性。
- en: By understanding the principles, techniques, and tools of testing, you can enhance
    the quality, stability, and maintainability of your Angular applications. Throughout
    this chapter, you will acquire fundamental knowledge on setting up tests and efficiently
    testing your Angular components through various examples. Additionally, you will
    become acquainted with best practices and libraries that can enhance and support
    your testing endeavors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解测试的原则、技术和工具，你可以提高 Angular 应用程序的质量、稳定性和可维护性。在本章中，你将通过各种示例获得设置测试和高效测试 Angular
    组件的基本知识。此外，你还将熟悉可以增强和支持你的测试工作的最佳实践和库。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with basic Angular testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始基本的 Angular 测试
- en: Writing tests for PrimeNG components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 PrimeNG 组件的测试用例
- en: Utilizing testing tips and tricks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用测试技巧和窍门
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter contains various code samples for testing. You can find the related
    source code in the `chapter-13` folder of the following GitHub repository: [https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-13](https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-13)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种测试代码示例。你可以在以下 GitHub 仓库的 `chapter-13` 文件夹中找到相关源代码：[https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-13](https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-13)
- en: Getting started with basic Angular testing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始基本的 Angular 测试
- en: In this section, we will introduce you to the fundamentals of testing in Angular
    applications. Testing is an essential part of the development process that allows
    early bug detection, faster feedback cycles, and improved code stability. Moreover,
    when continuously making changes to your code over time, following testing best
    practices can effectively mitigate potential issues, preserve existing functionality,
    and ensure the delivery of high-quality software to your users.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍 Angular 应用程序测试的基础知识。测试是开发过程中的一个重要部分，它允许早期发现错误、加快反馈周期并提高代码稳定性。此外，随着时间的推移，当你持续对代码进行更改时，遵循测试最佳实践可以有效地减轻潜在问题，保留现有功能，并确保向用户交付高质量的软件。
- en: Introduction to Angular testing fundamentals
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 测试基础介绍
- en: Angular provides a robust testing framework that allows you to write tests for
    your components, services, and other parts of your application. Testing in Angular
    is based on the principles of unit testing, where individual units of code are
    tested in isolation. This approach helps ensure that each unit functions correctly
    and meets the expected requirements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一个强大的测试框架，允许你为你的组件、服务和应用程序的其他部分编写测试。Angular 中的测试基于单元测试的原则，其中单个代码单元在隔离状态下进行测试。这种方法有助于确保每个单元正确运行并满足预期要求。
- en: Testing in Angular involves writing test cases that simulate user interactions,
    verify component behavior, and assert expected outcomes. These tests help you
    identify and fix bugs, validate business logic, and ensure that your application
    works as intended.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中进行测试涉及编写模拟用户交互、验证组件行为和断言预期结果的测试用例。这些测试可以帮助你识别和修复错误、验证业务逻辑，并确保你的应用程序按预期工作。
- en: 'When you first install an Angular project, it comes with `package.json` and
    `angular.json` in the following code block:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次安装 Angular 项目时，它包含以下代码块中的 `package.json` 和 `angular.json`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code snippet is part of the configuration files for setting up testing
    in an Angular application. Let’s break this code block down:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段是设置 Angular 应用程序测试的配置文件的一部分。让我们分析这个代码块：
- en: '`devDependencies: {...}`: This contains the packages for running tests in Angular.
    For example, `karma-jasmine-html-reporter` generates a detailed HTML report after
    tests run.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies: {...}`: 这包含在 Angular 中运行测试的包。例如，`karma-jasmine-html-reporter`
    在测试运行后生成详细的 HTML 报告。'
- en: '`karma`: This is a popular test runner for JavaScript applications. It allows
    you to execute tests in multiple browsers, capture the results, and report them.
    When you run `ng test`, Karma launches a development server, opens specified browsers,
    and executes Jasmine tests in those browsers.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`karma`：这是一个流行的JavaScript应用程序测试运行器。它允许你在多个浏览器中执行测试，捕获结果并报告。当你运行`ng test`时，Karma启动开发服务器，打开指定的浏览器，并在这些浏览器中执行Jasmine测试。'
- en: '`jasmine`: This is a **behavior-driven development** (**BDD**) testing framework
    for JavaScript. In the context of Angular, Jasmine is often used as the testing
    framework for writing and running unit tests.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine`：这是一个**行为驱动开发**（**BDD**）的JavaScript测试框架。在Angular的上下文中，Jasmine通常用作编写和运行单元测试的测试框架。'
- en: '`"builder": "@angular-devkit/build-angular:karma"`: This is a builder provided
    by the Angular DevKit, and it’s used as a target for running Karma tests.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"builder": "@angular-devkit/build-angular:karma"`：这是一个由Angular DevKit提供的构建器，用作运行Karma测试的目标。'
- en: 'In order to run a test in Angular, you can run the `npm run test` command,
    which will generate the following result:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Angular中运行测试，你可以运行`npm run test`命令，这将生成以下结果：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result of the test will also appear in the terminal and the browser:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果也将出现在终端和浏览器中：
- en: '![Figure 13.1 – Karma test result](img/B18805_13_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – Karma测试结果](img/B18805_13_01.jpg)'
- en: Figure 13.1 – Karma test result
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – Karma测试结果
- en: As a result, when you run the command for testing, Karma will open the browser
    and successfully execute the tests from `AppComponent`. Additionally, you will
    be able to observe the executed tests and their outcomes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你运行测试命令时，Karma将打开浏览器并成功执行来自`AppComponent`的测试。此外，你还将能够观察执行测试及其结果。
- en: Angular testing with Jest
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jest进行Angular测试
- en: In Angular, Karma and Jasmine have been the default testing framework choices,
    but with the introduction of Angular v16, **Jest** has been included as an experimental
    alternative for writing unit tests. The decision to adopt Jest stems from the
    fact that Karma, while effective, relies on a real web browser, leading to slower
    and heavier tests. Additionally, the use of a real browser introduces complexities
    in **continuous integration** (**CI**). Another factor to consider is that Karma
    has been deprecated ([https://github.com/karma-runner/karma](https://github.com/karma-runner/karma)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，Karma和Jasmine一直是默认的测试框架选择，但随着Angular v16的推出，**Jest**已被包含作为一个实验性的替代方案用于编写单元测试。采用Jest的决定源于Karma虽然有效，但依赖于真实浏览器，导致测试速度较慢且较重。此外，使用真实浏览器在**持续集成**（**CI**）中引入了复杂性。另一个需要考虑的因素是Karma已被弃用([https://github.com/karma-runner/karma](https://github.com/karma-runner/karma))。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: CI is a development practice that involves automatically integrating code changes
    from multiple contributors into a shared repository. It includes automated processes
    such as building and testing to detect integration issues early in the development
    cycle. CI promotes collaboration, accelerates development, and ensures code quality
    by providing immediate feedback on the health of the code base. Popular CI tools
    include Jenkins, Travis CI, CircleCI, and GitHub Actions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是一种开发实践，涉及将多个贡献者的代码更改自动集成到一个共享仓库中。它包括构建和测试等自动化流程，以在开发周期的早期检测集成问题。持续集成促进协作，加速开发，并通过提供对代码库健康状况的即时反馈来确保代码质量。流行的CI工具有Jenkins、Travis
    CI、CircleCI和GitHub Actions。
- en: 'Here are some other benefits when running Jest:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Jest时，还有一些其他好处：
- en: '**Snapshot testing**: This simplifies the process of visually inspecting changes
    in the UI and helps prevent unintended regressions.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快照测试**：这简化了视觉检查UI变化的过程，并有助于防止意外的回归。'
- en: '**Fast and parallel test execution**: Jest is known for its speed and efficient
    test execution. It can run tests in parallel, providing quicker feedback during
    development.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速并行测试执行**：Jest以其速度和高效的测试执行而闻名。它可以在并行中运行测试，在开发过程中提供更快的反馈。'
- en: '**Easy to integrate**: Jest is easily set up with Angular projects without
    requiring complex configuration.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于集成**：Jest可以轻松地与Angular项目集成，无需复杂的配置。'
- en: '**Built-in code coverage reports**: Jest includes built-in support for generating
    code coverage reports. This allows developers to assess how much of their code
    is covered by tests, aiding in identifying areas that may need additional testing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置代码覆盖率报告**：Jest包括生成代码覆盖率报告的内置支持。这允许开发者评估他们的代码有多少被测试覆盖，有助于识别可能需要额外测试的区域。'
- en: '**Mocking and spying simplified**: Jest provides a convenient API for creating
    mocks and spies, making it easier to isolate components or services during testing.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化模拟和监视**：Jest 提供了一个方便的 API 来创建模拟和监视器，这使得在测试期间隔离组件或服务变得更加容易。'
- en: '**Watch mode with intelligent test re-runs**: Jest’s watch mode intelligently
    re-runs only the tests affected by code changes, significantly speeding up the
    feedback loop during development.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能测试重跑的监视模式**：Jest 的监视模式智能地只重新运行受代码更改影响的测试，显著加快了开发期间的反馈循环。'
- en: '**Ecosystem and community**: Jest has a vibrant and active community with a
    growing ecosystem of plugins and extensions. This can be advantageous when looking
    for solutions, support, or integrations within the broader JavaScript and testing
    ecosystem.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生态系统和社区**：Jest 拥有一个充满活力和活跃的社区，以及不断增长的插件和扩展生态系统。当在更广泛的 JavaScript 和测试生态系统中寻找解决方案、支持或集成时，这可能是有利的。'
- en: 'So, let’s change our testing framework to Jest instead. First, you need to
    install Jest packages by running the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将我们的测试框架更改为 Jest。首先，你需要通过运行以下命令来安装 Jest 包：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command will install `jest` and `jest-environment-jsdom`, which is an environment
    for Jest that simulates a browser-like environment using JSDOM.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装 `jest` 和 `jest-environment-jsdom`，这是一个使用 JSDOM 模拟浏览器环境的 Jest 环境。
- en: '`jest-environment-jsdom`, Jest tests can run in a simulated browser environment,
    allowing you to write and run tests that interact with the DOM, handle events,
    and perform other browser-related operations.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`jest-environment-jsdom`，Jest 测试可以在模拟的浏览器环境中运行，允许你编写和运行与 DOM 交互、处理事件和执行其他浏览器相关操作的测试。'
- en: 'After that, let’s update our testing target:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们更新我们的测试目标：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By changing the builder from `@angular-devkit/build-angular:karma` to `@angular-devkit/build-angular:jest`,
    we now can utilize Jest for running our unit tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将构建器从 `@angular-devkit/build-angular:karma` 更改为 `@angular-devkit/build-angular:jest`，我们现在可以利用
    Jest 来运行我们的单元测试。
- en: 'Let’s have a look at the test result by running `npm` `run test`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `npm run test` 来查看测试结果：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will notice that there is no difference in the process of writing unit tests
    and the execution speed of the tests is significantly faster.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到编写单元测试的过程和测试的执行速度没有差异。
- en: Step-by-step guide to writing your initial Angular tests
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你的初始 Angular 测试的逐步指南
- en: 'Now that we have covered the preparation part, let’s dive into writing your
    first set of tests. In unit testing, you can utilize the **Arrange, Act, and Assert**
    (**AAA**) pattern, a common methodology for structuring and organizing unit tests.
    Each part of AAA serves a distinct purpose:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经涵盖了准备部分，让我们深入编写你的第一套测试。在单元测试中，你可以利用 **安排、行动和断言**（**AAA**）模式，这是一种常见的结构化和组织单元测试的方法。AAA
    的每个部分都服务于一个独特的目的：
- en: '**Arrange**: In this step, you set up the test environment. This involves creating
    instances of the components or services you want to test, providing any necessary
    dependencies, and configuring the initial state of the test.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安排**：在这个步骤中，你设置测试环境。这包括创建你想要测试的组件或服务的实例，提供任何必要的依赖项，并配置测试的初始状态。'
- en: '**Act**: This is where you perform the action or trigger the behavior that
    you want to test. It might involve calling a method, interacting with a component,
    or simulating an event.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行动**：这是你执行动作或触发你想要测试的行为的地方。这可能涉及调用方法、与组件交互或模拟事件。'
- en: '**Assert**: In the final step, you check the results of the action to ensure
    that it matches the expected outcome. This is where you make assertions about
    the state of your application after the action has been performed.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断言**：在最后一步，你检查动作的结果以确保它与预期的结果相匹配。这是你根据动作执行后的应用程序状态进行断言的地方。'
- en: Using the AAA pattern helps to keep tests organized, readable, and focused on
    specific behaviors. It provides a clear structure for writing and understanding
    tests, making it easier to maintain and troubleshoot them as your code base evolves.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AAA 模式有助于保持测试的有序性、可读性和专注于特定的行为。它为编写和理解测试提供了一个清晰的架构，使得随着代码库的发展，维护和调试它们变得更加容易。
- en: In the next section, let’s have a look at a real Angular test.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看一个真实的 Angular 测试。
- en: Breaking down a simple unit test
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化简单的单元测试
- en: 'When we first create an Angular application, the CLI helps to generate a test
    file for your `AppComponent`. Let’s have a look at the sample test file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次创建一个 Angular 应用程序时，CLI 帮助生成一个用于您的 `AppComponent` 的测试文件。让我们看看这个示例测试文件：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The provided code snippet is an Angular test script for the `AppComponent`
    component. Let’s break this code block down in the following list so we can understand
    it more:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码片段是`AppComponent`组件的Angular测试脚本。让我们以下面的列表形式分解这段代码，以便我们更好地理解它：
- en: '`describe(''AppComponent'', ()...`: This is a test suite that groups related
    tests. In this case, it groups tests for `AppComponent`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe(''AppComponent'', ()...`: 这是一个测试套件，用于分组相关的测试。在这种情况下，它将`AppComponent`的测试分组在一起。'
- en: '`beforeEach(async () => ...)`: This function is a setup function that runs
    before each individual test case. It is an asynchronous function that configures
    the testing module using `TestBed.configureTestingModule`, which is a key part
    of Angular’s testing infrastructure provided by the `TestBed` utility. It allows
    you to configure the testing module by specifying the necessary dependencies,
    providers, and imports for the component undergoing testing. In this case, it
    imports `AppComponent`. This is also the Arrange step in the AAA pattern.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach(async () => ...)`: 这个函数是一个设置函数，在每次单独的测试用例之前运行。它是一个异步函数，使用`TestBed.configureTestingModule`配置测试模块，这是由`TestBed`实用程序提供的Angular测试基础设施的关键部分。它允许你通过指定测试组件所需的依赖项、提供者和导入来配置测试模块。在这种情况下，它导入了`AppComponent`。这也是AAA模式中的安排步骤。'
- en: '`it(''should render title''...`: This function is a test case that defines
    a specific behavior to be tested. In this case, the test case is named `should
    render title`. Let’s break this function down based on the AAA pattern:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it(''should render title''...`: 这个函数是一个测试用例，定义了要测试的特定行为。在这种情况下，测试用例被命名为`should
    render title`。让我们根据AAA模式来分解这个函数：'
- en: '`AppComponent` using `TestBed.createComponent`, and retrieved the compiled
    HTML element with `fixture.nativeElement`'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`TestBed.createComponent`创建`AppComponent`，并使用`fixture.nativeElement`检索编译后的HTML元素
- en: '`fixture.detectChanges()`'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixture.detectChanges()`'
- en: '`<h1>` element contains the string `Welcome` `to chapter-13`'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1>`元素包含字符串`Welcome` `to chapter-13`'
- en: Overall, this test verifies that `AppComponent` correctly renders a title with
    the expected text content. It sets up the component, triggers change detection,
    and asserts the expected outcome.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这个测试验证了`AppComponent`能够正确渲染带有预期文本内容的标题。它设置了组件，触发变更检测，并断言预期的结果。
- en: 'In short, by using basic testing techniques, we can set a solid foundation
    for ensuring the quality and reliability of our Angular applications. Now that
    we have a grasp of basic testing concepts, let’s dive into a specific use case:
    writing tests for PrimeNG components. We will also write our unit tests while
    utilizing Jest as our unit testing framework.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，通过使用基本的测试技术，我们可以为我们的Angular应用程序的质量和可靠性打下坚实的基础。现在我们已经掌握了基本的测试概念，让我们深入一个具体用例：编写PrimeNG组件的测试。我们还将利用Jest作为我们的单元测试框架来编写单元测试。
- en: Writing test for PrimeNG components
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为PrimeNG组件编写测试
- en: Testing PrimeNG components follows the same principles as testing regular Angular
    components. This similarity arises from the fact that PrimeNG components are essentially
    Angular components under the hood. In the following sections, we will explore
    a few of these tests to gain insights and knowledge in this area.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试PrimeNG组件遵循与测试常规Angular组件相同的原理。这种相似性源于PrimeNG组件本质上是在Angular组件的底层。在接下来的章节中，我们将探讨这些测试中的几个，以获得对这个领域的洞察和知识。
- en: How PrimeNG tests its components
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PrimeNG如何测试其组件
- en: 'First, let’s have a look at how PrimeNG tests its own components. Due to space
    limitations in this book, it is not possible to display the entire test file,
    as it is quite lengthy. However, we can focus on a specific section that illustrates
    how PrimeNG tests its components in its source code. Here is the example code
    of a PrimeNG `Button` component:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看PrimeNG是如何测试它自己的组件的。由于本书篇幅限制，无法展示整个测试文件，因为它相当长。然而，我们可以关注一个特定部分，该部分展示了PrimeNG如何在源代码中测试其组件。以下是PrimeNG
    `Button`组件的示例代码：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s break down the code in the following list so we can understand its different
    sections:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的列表形式分解代码，以便我们理解其不同部分：
- en: '`beforeEach(...)`: This function is used to set up the testing environment
    before each test case. In this case, it is used to configure the testing module
    by calling `TestBed.configureTestingModule`. The `imports` property specifies
    any required modules, and the `declarations` property specifies the component
    being tested. In this case, it imports `NoopAnimationsModule` and adds `Button`
    to the declarations array.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach(...)`: 此函数用于在每个测试用例之前设置测试环境。在这种情况下，它通过调用 `TestBed.configureTestingModule`
    配置测试模块。`imports` 属性指定任何所需的模块，而 `declarations` 属性指定正在测试的组件。在这种情况下，它导入 `NoopAnimationsModule`
    并将 `Button` 添加到声明数组中。'
- en: '`should disabled when disabled is true`: This test case sets the `disabled`
    property of the `Button` component to `true`, triggers change detection using
    `fixture.detectChanges()`, and then queries the DOM for the button element using
    `fixture.debugElement.query`. It asserts that the `disabled` property of the button
    element is `true` using `expect(...).toBeTruthy()`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`当 disabled 为 true 时应禁用`: 此测试用例将 `Button` 组件的 `disabled` 属性设置为 `true`，使用 `fixture.detectChanges()`
    触发变更检测，然后使用 `fixture.debugElement.query` 查询 DOM 中的按钮元素。它断言按钮元素的 `disabled` 属性为
    `true`，使用 `expect(...).toBeTruthy()`。'
- en: '`should display the label and have a text only class`: This test case sets
    the `label` property of the `Button` component to `PrimeNG`, triggers change detection,
    and queries the DOM for the `button` element. It asserts that the `button` element’s
    text content contains `PrimeNG` using `expect(...).toContain(...)`, and it verifies
    that the `button` element has only one child element using `expect(...).toEqual(1)`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`应显示标签并具有纯文本类`: 此测试用例将 `Button` 组件的 `label` 属性设置为 `PrimeNG`，触发变更检测，并查询 DOM
    中的 `button` 元素。它断言 `button` 元素的文本内容包含 `PrimeNG`，使用 `expect(...).toContain(...)`，并验证
    `button` 元素只有一个子元素，使用 `expect(...).toEqual(1)`。'
- en: The purpose of these tests is to verify the expected behavior of the `Button`
    component. By changing its properties and triggering change detection, the tests
    ensure that the component renders correctly and behaves as intended.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的目的是验证 `Button` 组件的预期行为。通过更改其属性并触发变更检测，测试确保组件正确渲染并按预期行为。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the PrimeNG source code ([https://github.com/primefaces/primeng/tree/master/src/app/components](https://github.com/primefaces/primeng/tree/master/src/app/components)),
    there are existing tests that you can study and use as references to enhance your
    understanding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PrimeNG 源代码 ([https://github.com/primefaces/primeng/tree/master/src/app/components](https://github.com/primefaces/primeng/tree/master/src/app/components))
    中，存在你可以学习和用作参考的现有测试，以增强你的理解。
- en: Creating and testing our own component
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和测试我们自己的组件
- en: 'Putting the previous examples and knowledge into practice, let’s create a test
    for the following card component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的示例和知识付诸实践，让我们为以下卡片组件创建一个测试：
- en: '![Figure 13.2 – Sample card component](img/B18805_13_02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 示例卡片组件](img/B18805_13_02.jpg)'
- en: Figure 13.2 – Sample card component
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 示例卡片组件
- en: 'By examining the screenshot, you can observe the visual representation of the
    card component we created. To ensure the proper functioning of this component,
    it is essential to write tests that validate the correct rendering of its title,
    subtitle, and buttons. The following code block is an example of the test code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查截图，你可以观察到我们创建的卡片组件的视觉表示。为了确保此组件的正常运行，编写验证其标题、副标题和按钮正确渲染的测试是至关重要的。以下代码块是测试代码的示例：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s break down the code in the following list so that we can understand its
    different sections:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下列表中的代码分解，以便我们可以理解其不同的部分：
- en: '`should create`: The test case checks whether the `component` instance is `Truthy`,
    meaning that it has been successfully created.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`应创建`: 测试用例检查 `component` 实例是否为 `Truthy`，这意味着它已被成功创建。'
- en: '`should display the product title and subtitle`: This test case triggers change
    detection and then queries the DOM for the `p-card` element using `fixture.debugElement.query`.
    It asserts that the content of the `p-card` element contains the expected product
    `title` value and `subtitle` value using `expect(...).toContain(...)`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`应显示产品标题和副标题`: 此测试用例触发变更检测，然后使用 `fixture.debugElement.query` 查询 DOM 中的 `p-card`
    元素。它断言 `p-card` 元素的内容包含预期的产品 `title` 值和 `subtitle` 值，使用 `expect(...).toContain(...)`。'
- en: '`should have a footer`: This test case triggers change detection, then queries
    the DOM for the footer element with the`.p-card-footer` class and all the buttons
    with the`.p-button` class. It asserts that both the footer element and the buttons
    are `Truthy` using `expect(...).toBeTruthy()`, and it also verifies that there
    are two buttons present by checking the length of the `ctaButtons` array using
    `expect(...).toEqual(2)`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`应该有一个页脚`：这个测试用例触发变更检测，然后查询DOM中具有`.p-card-footer`类的页脚元素以及所有具有`.p-button`类的按钮。它使用`expect(...).toBeTruthy()`断言页脚元素和按钮都是`Truthy`，并且还通过检查`ctaButtons`数组的长度来验证有两个按钮存在，使用`expect(...).toEqual(2)`。'
- en: 'After running the test, you can see that it passes successfully:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，你可以看到它成功通过：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In conclusion, writing tests for PrimeNG components equips you with the ability
    to ensure the functionality and reliability of these components within your Angular
    applications. Now that we have explored the process of writing tests for PrimeNG
    components, let’s further enhance our testing practices by utilizing helpful tips
    and tricks to improve the effectiveness and efficiency of our tests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，为PrimeNG组件编写测试使你能够在Angular应用程序中确保这些组件的功能性和可靠性。现在我们已经探讨了为PrimeNG组件编写测试的过程，让我们通过利用有用的技巧和窍门来进一步改进我们的测试实践，以提高测试的有效性和效率。
- en: Utilizing testing tips and tricks
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用测试技巧和窍门
- en: 'Even though testing enables us to ensure the correctness and stability of our
    code, writing effective tests can sometimes be challenging. In this section, we
    will explore various tips and tricks that can help you improve your testing practices,
    using the following editable table as an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试使我们能够确保代码的正确性和稳定性，但编写有效的测试有时可能具有挑战性。在本节中，我们将探讨各种可以帮助你改进测试实践的技巧和窍门，以下是一个可编辑表格的示例：
- en: '![Figure 13.3 – Sample editable table](img/B18805_13_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 样本可编辑表格](img/B18805_13_03.jpg)'
- en: Figure 13.3 – Sample editable table
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 样本可编辑表格
- en: The table presents a list of products that are editable and removable. Upon
    clicking the delete icon, a confirmation dialog appears to verify the deletion
    action.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表格列出了可编辑和可删除的产品列表。点击删除图标时，会出现一个确认对话框以验证删除操作。
- en: So, let’s now look at some testing tips.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们看看一些测试技巧。
- en: Isolate unit tests
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离单元测试
- en: When writing unit tests, it’s crucial to isolate the component or service undergoing
    testing from its dependencies. Angular’s **TestBed** provides a powerful toolset
    for creating and configuring testing modules. By leveraging TestBed, we can mock
    dependencies and provide fake implementations, enabling us to focus solely on
    the unit we want to test.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试时，将正在测试的组件或服务与其依赖项隔离至关重要。Angular的**TestBed**提供了一套强大的工具，用于创建和配置测试模块。通过利用TestBed，我们可以模拟依赖项并提供模拟实现，使我们能够专注于我们想要测试的单元。
- en: 'Consider the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we use `TestBed.configureTestingModule` to set up the testing
    module. By specifying `imports` and `providers`, we can mock dependencies and
    ensure they are correctly injected into the component or service being tested.
    In this case, instead of calling the `getProducts()` function from `ShopService`,
    we replace the result with the `productsStub` value, which makes it isolated and
    easier to test.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用`TestBed.configureTestingModule`来设置测试模块。通过指定`imports`和`providers`，我们可以模拟依赖项并确保它们被正确注入到正在测试的组件或服务中。在这种情况下，我们不是从`ShopService`调用`getProducts()`函数，而是用`productsStub`值替换结果，这使得测试更加独立且易于进行。
- en: Utilize NO_ERRORS_SCHEMA
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NO_ERRORS_SCHEMA
- en: When testing Angular components, we often encounter situations where we don’t
    need to assert the behavior or rendering of child components such as Angular Material
    components. In such cases, `NO_ERRORS_SCHEMA` can be a handy tool to simplify
    our test setup.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试Angular组件时，我们经常遇到不需要断言子组件（如Angular Material组件）的行为或渲染的情况。在这种情况下，`NO_ERRORS_SCHEMA`可以是一个方便的工具，用于简化我们的测试设置。
- en: '`NO_ERRORS_SCHEMA` tells Angular’s compiler to ignore unrecognized elements
    and attributes within the component template. This allows us to focus on testing
    the component’s logic without the need to provide detailed mock implementations
    of child components.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`NO_ERRORS_SCHEMA`告诉Angular的编译器忽略组件模板中未识别的元素和属性。这使我们能够专注于测试组件的逻辑，而无需提供子组件的详细模拟实现。'
- en: 'Here’s an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, we specify `schemas: [NO_ERRORS_SCHEMA]` in the testing module
    configuration. This allows us to test `AppComponent` without worrying about the
    presence or behavior of any child components.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '在本例中，我们在测试模块配置中指定了 `schemas: [NO_ERRORS_SCHEMA]`。这允许我们在测试 `AppComponent` 时无需担心任何子组件的存在或行为。'
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Avoid using `NO_ERRORS_SCHEMA` if you are writing integration tests. This is
    because the `NO_ERRORS_SCHEMA` option will ignore template errors for unknown
    elements and attributes. It allows Angular to run tests even if there are issues
    with child components’ templates. You can read more at [https://angular.io/guide/testing-components-scenarios#no_errors_schema](https://angular.io/guide/testing-components-scenarios#no_errors_schema).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写集成测试，请避免使用 `NO_ERRORS_SCHEMA`。这是因为 `NO_ERRORS_SCHEMA` 选项会忽略未知元素和属性的错误模板。它允许
    Angular 即使子组件模板存在问题也能运行测试。你可以在[https://angular.io/guide/testing-components-scenarios#no_errors_schema](https://angular.io/guide/testing-components-scenarios#no_errors_schema)了解更多信息。
- en: Utilize the spyOn method
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 `spyOn` 方法
- en: '`spyOn` function, along with the spy object, to facilitate method spying.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `spyOn` 函数以及间谍对象来促进方法监视。
- en: By using `spyOn`, we can replace a method with a spy function that records all
    invocations and provides additional capabilities, such as returning specific values
    or throwing exceptions. This enables us to verify whether a method was called,
    how many times it was called, and with which arguments.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `spyOn`，我们可以用一个记录所有调用的间谍函数替换一个方法，并提供额外的功能，例如返回特定值或抛出异常。这使得我们能够验证方法是否被调用，调用了多少次，以及使用了哪些参数。
- en: 'Consider the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s break down the code in the following list and learn what it does:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解以下列表中的代码，并了解它的作用：
- en: '`(''should show accept message on delete'', () => { ... })`: This is a test
    case description. In this case, it is checking whether a specific message is shown
    after deleting a row.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(''should show accept message on delete'', () => { ... })`：这是一个测试用例描述。在这种情况下，它是在检查删除行后是否显示了特定消息。'
- en: '`const messageSpy = jest.spyOn(messageService, ''add'')`: This line creates
    a spy using Jest’s `spyOn` function. It spies on the `add` method of the `messageService`
    object. This allows us to track whether and how this method is called during the
    test.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const messageSpy = jest.spyOn(messageService, ''add'')`：这一行使用 Jest 的 `spyOn`
    函数创建了一个间谍。它监视 `messageService` 对象的 `add` 方法。这使我们能够在测试期间跟踪此方法是否以及如何被调用。'
- en: '`component.onRowDelete(1)`: This line calls the `onRowDelete` method of the
    component under test and passes `1` as an argument. This simulates the deletion
    of a row with an index of `1`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component.onRowDelete(1)`：这一行调用正在测试的组件的 `onRowDelete` 方法，并将 `1` 作为参数传递。这模拟了删除索引为
    `1` 的行。'
- en: '`fixture.detectChanges()`: This line triggers change detection in the test
    fixture. It ensures that any changes in the component’s template are applied and
    updates are reflected in the test environment.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixture.detectChanges()`：这一行触发了测试组件的变化检测。它确保组件模板中的任何更改都得到应用，并在测试环境中反映更新。'
- en: '`confirmDialog.accept()`: This line simulates the user accepting a confirmation
    dialog. It assumes that the component has a `confirmDialog` object with an `accept`
    method, which is called to confirm the deletion.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`confirmDialog.accept()`：这一行模拟用户接受确认对话框。它假设组件有一个具有 `accept` 方法的 `confirmDialog`
    对象，该方法是用来确认删除的。'
- en: '`expect(messageSpy).toHaveBeenCalledWith({ ... })`: This line uses the `expect`
    function to make an assertion. It checks whether the `add` method of the `messageService`
    object was called with the expected argument. In this case, it expects that the
    method was called with an object containing specific properties such as `severity`,
    `summary`, and `detail`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect(messageSpy).toHaveBeenCalledWith({ ... })`：这一行使用了 `expect` 函数来进行断言。它检查
    `messageService` 对象的 `add` 方法是否以预期的参数被调用。在这种情况下，它期望该方法以包含特定属性（如 `severity`、`summary`
    和 `detail`）的对象被调用。'
- en: In conclusion, the spying method is a powerful tool for tracking and controlling
    function calls during testing, providing insights into the behavior of your application.
    As we transition to the next section, let’s explore how to handle asynchronous
    code and manage time-related operations in Angular testing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，间谍方法是在测试期间跟踪和控制函数调用的强大工具，它为你的应用程序的行为提供了洞察力。随着我们过渡到下一节，让我们探讨如何在 Angular 测试中处理异步代码和管理与时间相关的操作。
- en: Working with fakeAsync
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 `fakeAsync` 一起工作
- en: '`fakeAsync` is a utility in Angular testing that enables synchronous testing
    of asynchronous code. It runs the test in a special “fake” zone where asynchronous
    operations can be controlled using `tick()`. Here is a simple demonstration of
    `fakeAsync` and `tick`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakeAsync` 是 Angular 测试中的一个实用工具，它使得异步代码的同步测试成为可能。它在一个特殊的“模拟”区域内运行测试，在这个区域内可以使用
    `tick()` 来控制异步操作。以下是一个 `fakeAsync` 和 `tick` 的简单演示：'
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, `fakeAsync` is used to wrap the `test` function. `setTimeout`
    is used to simulate an asynchronous operation, and `tick` is used to simulate
    the passage of time. By calling `tick(500)`, you simulate the passing of 500 milliseconds,
    and then you can make assertions about the state of your application. This is
    useful for testing asynchronous behavior in a synchronous manner.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`fakeAsync` 用于包装 `test` 函数。`setTimeout` 用于模拟异步操作，而 `tick` 用于模拟时间的流逝。通过调用
    `tick(500)`，你模拟了 500 毫秒的流逝，然后你可以对应用程序的状态进行断言。这对于以同步方式测试异步行为非常有用。
- en: 'Now let’s have a look at some more example code that tests the behavior of
    PrimeNG `MessageService` in `TipsComponent`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些测试 PrimeNG `MessageService` 在 `TipsComponent` 中行为的更多示例代码：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This test verifies whether the message displays the correct value upon pressing
    the *Esc* button. The following bullet points outline the flow of the test:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试验证了在按下 *Esc* 按钮时消息是否显示正确的值。以下要点概述了测试的流程：
- en: First, we trigger the delete action through the `component.onRowDelete(1)` function,
    so the confirmation dialog shows up.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们通过 `component.onRowDelete(1)` 函数触发删除操作，因此确认对话框出现。
- en: After that, we use `tick` to advance the virtual clock by a specified amount
    of time. In this case, we use `tick(300)` to simulate a 300-millisecond delay.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们使用 `tick` 来根据指定的时间量推进虚拟时钟。在这个例子中，我们使用 `tick(300)` 来模拟 300 毫秒的延迟。
- en: After the `tick` function is used, we simulate the `Escape` keydown event by
    creating a `KeyboardEvent` object and dispatching it on the document.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用 `tick` 函数之后，我们通过创建一个 `KeyboardEvent` 对象并在文档上分发它来模拟 `Escape` 键盘按键事件。
- en: After the `Escape` event is dispatched, we can assert on the message service
    via `expect(messageSpy).toHaveBeenCalledWith({...})`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Escape` 事件被分发之后，我们可以通过 `expect(messageSpy).toHaveBeenCalledWith({...})` 来断言消息服务。
- en: Finally, we use `flush` to flush any pending asynchronous tasks, ensuring that
    all asynchronous operations have been completed before the `test` function exits.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `flush` 来清除任何挂起的异步任务，确保在 `test` 函数退出之前所有异步操作都已经完成。
- en: 'In this section, we’ve gained insights into managing asynchronous operations
    in Angular testing. In the next section, we will delve into a powerful testing
    utility that simplifies and enhances our testing capabilities: Spectator.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了如何在 Angular 测试中管理异步操作。在下一节中，我们将深入探讨一个强大的测试实用工具，它可以简化并增强我们的测试能力：Spectator。
- en: Utilizing third-party libraries – Spectator
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用第三方库 – Spectator
- en: '**Spectator** ([https://ngneat.github.io/spectator](https://ngneat.github.io/spectator))
    provides a set of utilities and techniques that facilitate writing concise and
    expressive tests for Angular components. It allows you to create component instances,
    mock dependencies, access the component’s DOM, and assert the component’s behavior
    with minimal boilerplate code. It also provides a clean and intuitive syntax that
    makes test cases more readable and maintainable.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spectator** ([https://ngneat.github.io/spectator](https://ngneat.github.io/spectator))
    提供了一套实用工具和技术，这些工具和技术有助于编写简洁且表达力强的 Angular 组件测试。它允许你创建组件实例，模拟依赖项，访问组件的 DOM，以及用最少的样板代码断言组件的行为。它还提供了一个干净且直观的语法，使得测试用例更加可读和维护。'
- en: 'To use it, first, we need to install the `spectator` package by running the
    following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，首先，我们需要通过运行以下命令来安装 `spectator` 包：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After that, let’s create an example test in which we use `Spectator` for testing
    an Angular component:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们创建一个示例测试，在这个测试中我们使用 `Spectator` 来测试一个 Angular 组件：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The given code utilizes Spectator to test the behavior of the `TipsComponent`
    instance. Let’s break down the code block in the following list so we can understand
    each part:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的代码利用 Spectator 来测试 `TipsComponent` 实例的行为。让我们以下面的列表形式分解代码块，以便我们理解每一部分：
- en: '`const createComponent = createComponentFactory({ ... })`: This defines a `createComponent`
    function using `createComponentFactory` from `Spectator`. This function is used
    to create an instance of `TipsComponent` for testing. It also provides a mock
    instance of `ShopService` through the `providers` array.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const createComponent = createComponentFactory({ ... })`: 这定义了一个使用 `createComponentFactory`
    从 `Spectator` 中创建的 `createComponent` 函数。此函数用于创建 `TipsComponent` 的实例以进行测试。它还通过
    `providers` 数组提供了一个 `ShopService` 的模拟实例。'
- en: '`beforeEach(() => (spectator = createComponent()))`: This is a setup step that
    runs before each test case. It creates a new instance of `TipsComponent` using
    the `createComponent` function and assigns it to the `spectator` variable.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach(() => (spectator = createComponent()))`: 这是一个在每次测试用例之前运行的设置步骤。它使用
    `createComponent` 函数创建一个新的 `TipsComponent` 实例，并将其分配给 `spectator` 变量。'
- en: '`it(''should show table content'', () => { ... })`: This line defines a test
    case with the description `should show table content`. This test case verifies
    that the table in `TipsComponent` contains the expected content. This is broken
    down in more detail as follows:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it(''should show table content'', () => { ... })`: 这行代码定义了一个带有描述 `should show
    table content` 的测试用例。此测试用例验证 `TipsComponent` 中的表格是否包含预期的内容。以下是对其更详细的分解：'
- en: '`const table = spectator.query(''p-table'')`: This uses the `query` method
    from the `spectator` object to find the `<p-table>` element in the component’s
    template.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const table = spectator.query(''p-table'')`: 这使用 `spectator` 对象中的 `query`
    方法在组件的模板中查找 `<p-table>` 元素。'
- en: '`expect(table?.textContent).toContain(...)`: This asserts that `textContent`
    of the `table` element (if it exists) contains the string `Product 1` or `Product
    2`.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect(table?.textContent).toContain(...)`: 这条语句断言，如果存在，`table` 元素的 `textContent`
    包含字符串 `Product 1` 或 `Product 2`。'
- en: 'As we conclude our exploration of `Spectator`, we’ve discovered its efficacy
    in simplifying and improving our testing workflow for Angular components. Now,
    let’s have a look at another helpful library to enhance our testing practices:
    `ng-mocks`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对 `Spectator` 的探索后，我们发现它在简化并改进我们的 Angular 组件测试工作流程方面非常有效。现在，让我们看看另一个有助于增强我们的测试实践的库：`ng-mocks`。
- en: Utilizing third-party libraries – ng-mocks
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用第三方库 – ng-mocks
- en: Another powerful third-party library for testing Angular applications is `ng-mocks`
    simplifies the testing process by providing flexible mocking and stubbing capabilities,
    making it easier to isolate components and services during testing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于测试 Angular 应用程序的有力第三方库是 `ng-mocks`，它通过提供灵活的模拟和存根功能简化了测试过程，使得在测试期间隔离组件和服务变得更加容易。
- en: With ng-mocks, we can create mock implementations of Angular components and
    services, define custom behavior for methods, and verify interactions. This allows
    us to focus on testing specific units without worrying about the complexities
    of real implementations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ng-mocks，我们可以创建 Angular 组件和服务的模拟实现，为方法定义自定义行为，并验证交互。这使我们能够专注于测试特定的单元，而无需担心真实实现的复杂性。
- en: 'To use it, first, we need to install the `ng-mocks` package by running the
    following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，首先，我们需要通过运行以下命令来安装 `ng-mocks` 包：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let’s have a look at how to use ng-mocks in Angular testing:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 Angular 测试中使用 ng-mocks：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s break down the code block in the following list so that we can understand
    what it does:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析以下列表中的代码块，以便我们了解它所执行的操作：
- en: '`providers: [MockProvider(ShopService)]`: This is used to create a mock version
    of `ShopService` and configure it as a provider in the test environment. This
    ensures that the test uses the mock version of `ShopService` instead of the actual
    implementation.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providers: [MockProvider(ShopService)]`: 这用于创建 `ShopService` 的模拟版本，并将其配置为测试环境中的提供者。这确保测试使用
    `ShopService` 的模拟版本而不是实际实现。'
- en: '`beforeAll(() => MockInstance(ShopService, () => ({ ... })))`: This `beforeAll`
    hook is executed once before all the test cases in the suite. It mocks the `ShopService`
    dependency by using the `MockInstance` function from `ng-mocks`. It replaces the
    original `getProducts` method with a mocked implementation that returns `productsStub`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeAll(() => MockInstance(ShopService, () => ({ ... })))`: 这个 `beforeAll`
    钩子在套件中的所有测试用例之前执行一次。它通过使用 `ng-mocks` 中的 `MockInstance` 函数来模拟 `ShopService` 依赖项。它用返回
    `productsStub` 的模拟实现替换了原始的 `getProducts` 方法。'
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ng-mocks` also works fine with `spectator`. You can read more at [https://ng-mocks.sudo.eu/extra/with-3rd-party](https://ng-mocks.sudo.eu/extra/with-3rd-party).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-mocks` 也可以与 `spectator` 一起很好地工作。您可以在 [https://ng-mocks.sudo.eu/extra/with-3rd-party](https://ng-mocks.sudo.eu/extra/with-3rd-party)
    上了解更多信息。'
- en: And with that, we’ve delved into the intricacies of Angular testing, uncovering
    practical tips and tricks that empower you to enhance the efficiency and resilience
    of your test suites.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们深入探讨了Angular测试的复杂性，揭示了实用的技巧和窍门，这些技巧和窍门能让你增强测试套件的效率和弹性。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to effectively test PrimeNG components in your
    Angular applications. By leveraging Jest, a powerful testing framework, you gained
    the ability to ensure the functionality and reliability of these components.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在Angular应用程序中有效地测试PrimeNG组件。通过利用Jest这个强大的测试框架，你获得了确保这些组件功能性和可靠性的能力。
- en: Throughout this chapter, you explored various concepts and techniques related
    to testing PrimeNG components. You started by understanding the importance of
    testing and the benefits it brings to your development workflow. Then, you delved
    into the specific steps involved in writing unit tests for PrimeNG components,
    including component setup, testing component behavior, and validating component
    appearance and interactions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你探索了与测试PrimeNG组件相关的各种概念和技术。你首先了解了测试的重要性以及它为你的开发工作流程带来的好处。然后，你深入了解了编写PrimeNG组件单元测试的具体步骤，包括组件设置、测试组件行为以及验证组件外观和交互。
- en: In addition, you also encountered practical examples, code snippets, and best
    practices that demonstrated how to effectively test PrimeNG components. By following
    along and implementing these testing strategies, you gained hands-on experience
    in verifying the correctness, reliability, and performance of your PrimeNG components.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还遇到了实际示例、代码片段和最佳实践，展示了如何有效地测试PrimeNG组件。通过跟随并实施这些测试策略，你在验证PrimeNG组件的正确性、可靠性和性能方面获得了实践经验。
- en: As we transition to the next chapter, we will shift our focus to the world of
    building a responsive web application utilizing PrimeNG components.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们过渡到下一章，我们将把重点转向利用PrimeNG组件构建响应式Web应用程序的世界。
- en: 'Part 4: Real-World Application'
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：真实世界应用
- en: In this final part, you will apply all the knowledge and skills you have acquired
    throughout the previous chapters to build a real-world responsive web application.
    This part will provide you with hands-on experience, allowing you to put your
    PrimeNG and Angular expertise to practical use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本最终部分，你将应用在前几章中学到的所有知识和技能来构建一个真实的响应式Web应用程序。本部分将为你提供实践经验，让你能够将PrimeNG和Angular的专业知识付诸实践。
- en: By the end of this part, you will have completed a fully functional responsive
    web application using PrimeNG and Angular.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到本部分结束时，你将完成一个使用PrimeNG和Angular的完全功能性的响应式Web应用程序。
- en: 'This part includes the following chapter:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 14*](B18805_14.xhtml#_idTextAnchor288), *Building a Responsive Web
    Application*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18805_14.xhtml#_idTextAnchor288), *构建响应式Web应用程序*'
