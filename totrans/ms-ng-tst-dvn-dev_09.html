<html><head></head><body>
		<div id="_idContainer190">
			<h1 id="_idParaDest-125" class="chapter-number"><a id="_idTextAnchor380"/><st c="0">9</st></h1>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor381"/><st c="2">Understanding Continuous Integration and Continuous Deployment (CI/CD)</st></h1>
			<p><st c="72">In software development, the combination of </st><strong class="bold"><st c="117">continuous integration and deployment</st></strong><st c="154"> (</st><strong class="bold"><st c="156">CI/CD</st></strong><st c="161">) practices with </st><strong class="bold"><st c="179">test-driven development</st></strong><st c="202"> (</st><strong class="bold"><st c="204">TDD</st></strong><st c="207">) has proven to be a powerful combination for delivering high-quality software at a rapid pace. </st><strong class="bold"><st c="304">Continuous integration</st></strong><st c="326"> (</st><strong class="bold"><st c="328">CI</st></strong><st c="330">) and TDD work in synergy to automate the software development cycle, promote a culture of testing, and enable teams to build and deploy code iteratively and </st><span class="No-Break"><st c="489">with confidence.</st></span></p>
			<p><st c="505">CI/CD covers a series of automated steps that streamline the software delivery pipeline, from code changes made by developers to the deployment of these changes in production. </st><st c="682">By implementing CI/CD practices, development teams can reduce manual errors, improve collaboration between team members, increase delivery speed, and improve overall </st><span class="No-Break"><st c="848">software quality.</st></span></p>
			<p><st c="865">In this chapter, we’ll explore the fundamental concepts of CI/CD, explore the benefits of adopting these practices, discuss the key components of a CI/CD pipeline, and provide an overview of how organizations can</st><a id="_idIndexMarker382"/><st c="1078"> successfully implement CI/CD processes to streamline their </st><strong class="bold"><st c="1138">software development life </st></strong><span class="No-Break"><strong class="bold"><st c="1164">cycle</st></strong></span><span class="No-Break"><st c="1169"> (</st></span><span class="No-Break"><strong class="bold"><st c="1171">SDLC</st></strong></span><span class="No-Break"><st c="1175">).</st></span></p>
			<p><st c="1178">In summary, here are the main topics that will be covered in </st><span class="No-Break"><st c="1240">this chapter:</st></span></p>
			<ul>
				<li><st c="1253">Understanding continuous integration and </st><span class="No-Break"><st c="1295">continuous deployment</st></span></li>
				<li><st c="1316">Setting up CI/CD pipelines for automating build with </st><span class="No-Break"><st c="1370">GitHub Actions</st></span></li>
				<li><st c="1384">Setting up CI/CD pipelines for automating tests with </st><span class="No-Break"><st c="1438">GitHub Actions</st></span></li>
				<li><st c="1452">Setting up CI/CD pipelines for automating deployment processes with </st><span class="No-Break"><st c="1521">GitHub Actions</st></span></li>
			</ul>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor382"/><st c="1535">Technical requirements</st></h1>
			<p><st c="1558">To follow along with the examples and exercises in this chapter, you will need to have a basic understanding of Angular and TypeScript, as well as the following </st><span class="No-Break"><st c="1720">technical requirements:</st></span></p>
			<ul>
				<li><st c="1743">Node.js and npm installed on </st><span class="No-Break"><st c="1773">your computer</st></span></li>
				<li><st c="1786">Angular CLI </st><span class="No-Break"><st c="1799">installed globally</st></span></li>
				<li><st c="1817">A code editor, such as Visual Studio Code, installed on </st><span class="No-Break"><st c="1874">your computer</st></span></li>
			</ul>
			<p><st c="1887">The code files required for this chapter can be found on GitHub </st><span class="No-Break"><st c="1952">at </st></span><a href="https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209"><span class="No-Break"><st c="1955">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209</st></span></a><span class="No-Break"><st c="2053">.</st></span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor383"/><st c="2054">Understanding CI and CD</st></h1>
			<p><st c="2078">CI and CD have become essential </st><a id="_idIndexMarker383"/><st c="2111">practices in modern software development, enabling teams to deliver high-quality code quickly and efficiently. </st><st c="2222">This comprehensive </st><a id="_idIndexMarker384"/><st c="2241">guide covers the fundamental concepts of CI/CD, explores their benefits, discusses best practices, and outlines successful implementation strategies. </st><st c="2391">From understanding the fundamentals to optimizing CI/CD pipelines, this chapter aims to equip readers with the knowledge and tools they need to harness the power of CI/CD and transform </st><span class="No-Break"><st c="2576">software delivery.</st></span></p>
			<p><st c="2594">But before we go ahead and use these practices, let’s </st><span class="No-Break"><st c="2649">understand them.</st></span></p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor384"/><st c="2665">What is CI?</st></h1>
			<p><st c="2677">CI is a DevOps software development practice in which developers regularly merge their code changes into a central repository. </st><st c="2805">After ea</st><a id="_idTextAnchor385"/><st c="2813">ch merge, automated builds and tests are run to ensure that the new code is error free and meets the project’s quality standards. </st><st c="2944">This process is essential for identifying </st><a id="_idIndexMarker385"/><st c="2986">and correcting bugs more quickly, improving software quality, and reducing the time needed to validate and release new software updates. </st><st c="3123">CI encourages frequent code integration, often several times a day, so that integration problems can be identified early in the development cycle and corrected more easily. </st><st c="3296">It also encourages a cultural shift towards more frequent code deliveries, which is essential if we are to reap the benefits of CI’s automation </st><span class="No-Break"><st c="3440">and efficiency.</st></span></p>
			<p><st c="3455">CI is the first phase of the CI/CD pipeline, part of the broader DevOps approach to software development. </st><st c="3562">It follows the agile software development methodology, where work is broken down into small, manageable tasks that can be completed and integrated frequently. </st><st c="3721">The use of CI tools, such as GitHub Actions, Jenkins, Buildbot, Go, Travis CI, and GitLab CI, facilitates the automation of build and test processes, making it easier for developers to integrate their changes with the rest of the project and identify issues early in the </st><span class="No-Break"><st c="3992">development process.</st></span></p>
			<p><st c="4012">The benefits of CI include</st><a id="_idIndexMarker386"/><st c="4039"> improved developer productivity, faster delivery of updates, and a more predictable delivery schedule. </st><st c="4143">It also improves cross-team collaboration and systems integration, reducing testing errors and improving the efficiency of the software development cycle. </st><st c="4298">However, the challenges of CI mainly concern team adoption and the initial technical installation of CI tools. </st><st c="4409">Overcoming these challenges and effectively implementing CI practices is essential to realizing the full potential of CI in improving software development processes </st><span class="No-Break"><st c="4574">and outcomes.</st></span></p>
			<p><st c="4587">In the next section, we’ll explore in more depth the benefits of CI for </st><span class="No-Break"><st c="4660">development teams.</st></span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor386"/><st c="4678">Benefits of CI for development teams</st></h2>
			<p><st c="4715">The benefits of CI for development</st><a id="_idIndexMarker387"/><st c="4750"> teams are manifold, encompassing efficiency, quality, and customer satisfaction. </st><st c="4832">Here’s a detailed overview of </st><span class="No-Break"><st c="4862">these benefits:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="4877">Faster iteration and problem resolution</st></strong><st c="4917">: CI enables teams to integrate code changes more frequently, speeding up iterations and facilitating problem resolution. </st><st c="5040">Small code changes are simpler to manage, reducing the complexity of problems that </st><span class="No-Break"><st c="5123">can arise.</st></span></li>
				<li><strong class="bold"><st c="5133">Improved code quality and fewer bugs</st></strong><st c="5170">: By frequently integrating and testing code, CI enables bugs to be identified and corrected early in the development cycle. </st><st c="5296">The result is higher-quality code with fewer defects, improving the user experience and </st><span class="No-Break"><st c="5384">reducing downtime.</st></span></li>
				<li><strong class="bold"><st c="5402">Increased efficiency and reduced costs</st></strong><st c="5441">: CI-driven automation reduces manual tasks, saving time for developers. </st><st c="5515">This not only increases efficiency but also reduces the costs associated with manual testing and error management. </st><st c="5630">As a result, engineers can devote more time to </st><span class="No-Break"><st c="5677">value-added activities.</st></span></li>
				<li><strong class="bold"><st c="5700">Improved transparency and collaboration</st></strong><st c="5740">: CI promotes transparency by providing continuous</st><a id="_idIndexMarker388"/><st c="5791"> feedback on code quality and integration issues. </st><st c="5841">It also promotes better team collaboration by ensuring that code changes are integrated and tested regularly, enabling better coordination between </st><span class="No-Break"><st c="5988">team members.</st></span></li>
				<li><strong class="bold"><st c="6001">Faster time to market</st></strong><st c="6023">: By automating the build, test, and deployment processes, CI enables teams to deliver new features and updates to end users more quickly. </st><st c="6163">This responsiveness keeps the development team competitive and ensures that customers benefit from the </st><span class="No-Break"><st c="6266">latest enhancements.</st></span></li>
				<li><strong class="bold"><st c="6286">Improved customer satisfaction</st></strong><st c="6317">: Fewer bugs and errors end up in production, improving the user experience. </st><st c="6395">CI also enables rapid response to customer feedback, enabling te</st><a id="_idTextAnchor387"/><st c="6459">ams to make adjustments and improvements </st><span class="No-Break"><st c="6501">more efficiently.</st></span></li>
				<li><strong class="bold"><st c="6518">Reduced mean time to resolution (MTTR)</st></strong><st c="6557">: CI enables problems to be detected and resolved more quickly, thus reducing the MTTR. </st><st c="6646">This ensures that the software remains stable and reliable, </st><span class="No-Break"><st c="6706">minimizing downtime.</st></span></li>
				<li><strong class="bold"><st c="6726">Increased test reliability</st></strong><st c="6753">: Continuous testing within the CI framework improves test reliability by enabling more precise tests to be carried out. </st><st c="6875">This ensures that the software is thoroughly tested and ready for production, boosting confidence in </st><span class="No-Break"><st c="6976">software quality.</st></span></li>
				<li><strong class="bold"><st c="6993">Competitive advantage</st></strong><st c="7015">: Organizations that adopt </st><strong class="bold"><st c="7043">business intelligence</st></strong><st c="7064"> (</st><strong class="bold"><st c="7066">BI</st></strong><st c="7068">) have a competitive advantage</st><a id="_idIndexMarker389"/><st c="7099"> because they can deploy functionality more quickly, which in turn saves them money. </st><st c="7184">This early feedback and aut</st><a id="_idTextAnchor388"/><st c="7211">omation helps to reduce lead times, deployment frequency, and change failure rates, which in turn improves </st><span class="No-Break"><st c="7319">business results.</st></span></li>
				<li><strong class="bold"><st c="7336">Increased transparency and accountability within the team</st></strong><st c="7394">: CI/CD practices increase transparency and accountability within the team, enabling problems to be identified and resolved quickly, including construction failures and architectural setbacks. </st><st c="7588">This continuous feedback loop improves overall </st><span class="No-Break"><st c="7635">product quality.</st></span></li>
			</ul>
			<p><st c="7651">In summary, CI offers development teams significant benefits in terms of efficiency, quality, and customer satisfaction. </st><st c="7773">It streamlines the development process, reduces costs, and enhances</st><a id="_idIndexMarker390"/><st c="7840"> collaboration, ultimately leading to the delivery of high-quality software products more quickly and reliably. </st><st c="7952">In the next section, we will explore the key principles of </st><span class="No-Break"><st c="8011">CI implementation.</st></span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor389"/><st c="8029">Key principles of CI implementation</st></h2>
			<p><st c="8065">The key principles of CI implementation aim to improve the efficiency, quality, and speed of software development. </st><st c="8181">Here are the</st><a id="_idIndexMarker391"/> <span class="No-Break"><st c="8193">key principles:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="8209">Automate everything</st></strong><st c="8229">: CI focuses on automating the build, test, and integration processes. </st><st c="8301">Automation reduces manual effort, minimizes errors, and accelerates the </st><span class="No-Break"><st c="8373">development cycle.</st></span></li>
				<li><strong class="bold"><st c="8391">Frequent integration</st></strong><st c="8412">: Frequently integrate code changes into a shared repository, ideally several times a day. </st><st c="8504">This practice enables integration problems to be identified and resolved early in the </st><span class="No-Break"><st c="8590">development cycle.</st></span></li>
				<li><strong class="bold"><st c="8608">Make the build process fast</st></strong><st c="8636">: The build process should be as fast as possible to ensure rapid feedback. </st><st c="8713">Rapid construction means that problems can be detected and resolved more quickly, facilitating </st><span class="No-Break"><st c="8808">continuous improvement.</st></span></li>
				<li><strong class="bold"><st c="8831">Immediate feedback</st></strong><st c="8850">: CI relies on immediate feedback from automated builds and tests. </st><st c="8918">This feedback is essential for identifying and resolving problems early in the </st><span class="No-Break"><st c="8997">development process.</st></span></li>
				<li><strong class="bold"><st c="9017">Start small and grow</st></strong><st c="9038">: Start with a simple CI configuration and gradually add other tools and practices as required. </st><st c="9135">This approach encourages flexibility and experimentation, allowing teams to find what works best in their </st><span class="No-Break"><st c="9241">specific context.</st></span></li>
				<li><strong class="bold"><st c="9258">Define success indicators</st></strong><st c="9284">: Clearly define success indicators for your CI process, such as accelerated code construction or reduced error and work rates. </st><st c="9413">Use these indicators to measure the effectiveness of your CI practices and to </st><span class="No-Break"><st c="9491">guide improvements.</st></span></li>
				<li><strong class="bold"><st c="9510">Documentation</st></strong><st c="9524">: Document the CI process and the tools used by all developers and stakeholders. </st><st c="9606">Good documentation ensures that everyone understands how to</st><a id="_idIndexMarker392"/><st c="9665"> contribute to the CI process and solve </st><span class="No-Break"><st c="9705">problems efficiently.</st></span></li>
				<li><strong class="bold"><st c="9726">Collaboration between operations and development</st></strong><st c="9775">: Encourage a culture in which operations and development work closely together. </st><st c="9857">This collaboration is essential for understanding software reliability and performance from both points </st><span class="No-Break"><st c="9961">of view.</st></span></li>
				<li><strong class="bold"><st c="9969">Scalability</st></strong><st c="9981">: CI breaks down barriers to growth by automating code integration and communication, allowing organizations to scale their development teams, code base, </st><span class="No-Break"><st c="10136">and infrastructure.</st></span></li>
				<li><strong class="bold"><st c="10155">Investment in the learning curve</st></strong><st c="10188">: Implementing CI successfully involves learning new skills in areas such as version control and automation. </st><st c="10298">However, these skills are readily available, and the benefits of CI outweigh the </st><span class="No-Break"><st c="10379">initial investment.</st></span></li>
			</ul>
			<p><st c="10398">These principles guide the implementation of CI, ensuring that it becomes an integral part of the software development process, improving productivity, quality, and speed. </st><st c="10571">In the next section, we will learn what </st><strong class="bold"><st c="10611">continuous deployment</st></strong><st c="10632"> (</st><span class="No-Break"><strong class="bold"><st c="10634">CD</st></strong></span><span class="No-Break"><st c="10636">) i</st><a id="_idTextAnchor390"/><st c="10640">s.</st></span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor391"/><st c="10643">What is CD?</st></h1>
			<p><st c="10655">CD is an automated software</st><a id="_idIndexMarker393"/><st c="10683"> release practice in which code changes are automatically deployed at different stages as they pass predefined tests. </st><st c="10801">The aim of CD is to accelerate production releases by using automation to minimize human intervention during the deployment process. </st><st c="10934">This approach is part of the wider DevOps practice, which aims to accelerate innovation and value creation by applying automation to every stage of </st><span class="No-Break"><st c="11082">the SDLC.</st></span></p>
			<p><st c="11091">Software design requires a mix of rigorous testing, close collaboration between teams, advanced tools, and workflow processes throughout the application design and development process. </st><st c="11277">When successfully implemented, CD enables organizations to respond quickly to customer requests and deliver software updates rapidly, often within minutes of validating code changes. </st><st c="11460">This process includes automating build, test, and deployment in a single </st><a id="_idIndexMarker394"/><st c="11533">workflow, with the aim of automating software deployment </st><span class="No-Break"><st c="11590">in production.</st></span></p>
			<p><st c="11604">The benefits of CD include fully automated deployment cycles, enabling organizations to spend more time on software creation than on release preparation. </st><st c="11759">It also leads to more regular, incremental deployments, facilitating faster product development and a continuous improvement model. </st><st c="11891">In addition, CD provides rapid feedback loops on new features, updates, and code changes, enabling organizations to quickly receive and integrate </st><span class="No-Break"><st c="12037">user feedback.</st></span></p>
			<p><st c="12051">CD goes further than CI, which automates everything right up to the deployment itself, requiring human intervention to set up the deployment. </st><st c="12194">CD automates the whole process, including the release of the software itself, making it a natural evolution of CD if the pipeline is properly set up and designed to test all elements of a software product </st><span class="No-Break"><st c="12399">before release.</st></span></p>
			<p><st c="12414"> A CD pipeline streamlines software delivery by automatically building, testing, and deploying code changes directly to production. </st><st c="12546">It involves automated testing and monitoring throughout the pipeline to detect potential errors, functional problems, and bugs, providing real-time alerts and preventing problems from reaching the main software branch or production. </st><st c="12779">This approach underlines the main objective of DevOps: the CD of value to </st><span class="No-Break"><st c="12853">end users.</st></span></p>
			<p><st c="12863">In practice, this means that a change made by a developer to a cloud application can be put into production within minutes of being written, provided it passes automated testing. </st><st c="13043">This makes it much easier to receive and integrate user feedback on an ongoing bas</st><a id="_idTextAnchor392"/><st c="13125">is. </st><st c="13130">However, delivering value depends heavily on well-designed test automation, which can require a significant </st><span class="No-Break"><st c="13238">initial investment.</st></span></p>
			<p><st c="13257">Overall, CD is an essential aspect of the DevOps approach, enabling organizations to release software updates </st><a id="_idIndexMarker395"/><st c="13368">quickly and efficiently, accelerating innovation and value creation </st><span class="No-Break"><st c="13436">for end-users.</st></span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor393"/><st c="13450">Benefits of CD for development teams</st></h2>
			<p><st c="13487">CD offers several key benefits to development teams, facilitating a more efficient, agile, and responsive software development process. </st><st c="13624">Here are the </st><span class="No-Break"><st c="13637">main benefits:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="13651">Fully automated deployment cycles</st></strong><st c="13685">: CD enables organizations to automate the entire</st><a id="_idIndexMarker396"/><st c="13735"> deployment process, reducing manual intervention and allowing development teams to focus more on coding and less on release preparation. </st><st c="13873">This automation speeds up the deployment of new features and updates, enabling teams to deliver software faster and </st><span class="No-Break"><st c="13989">more efficiently.</st></span></li>
				<li><strong class="bold"><st c="14006">More regular, incremental deployments</st></strong><st c="14044">: By automating deployments, CD enables small, incremental changes to be released more frequently. </st><st c="14144">This approach enables faster product development and facilitates a continuous improvement model, in which teams can rapidly iterate on their software based on user feedback and </st><span class="No-Break"><st c="14321">market demands.</st></span></li>
				<li><strong class="bold"><st c="14336">Rapid feedback loops on new features</st></strong><st c="14373">: CD provides real-time feedback on new features, updates, and code changes. </st><st c="14451">This immediate feedback loop is essential to enable teams to rapidly adapt and improve their software, ensuring that the final product meets users’ expectations </st><span class="No-Break"><st c="14612">and requirements.</st></span></li>
				<li><strong class="bold"><st c="14629">Event response</st></strong><st c="14644">: The CD enables teams to react quickly to system errors in production, security incidents or potential new features to be developed during web application development. </st><st c="14814">Immediate release of code to production enables organizations to address and resolve issues more quickly, with metrics such as MTTR enabling response times to be assessed and improved </st><span class="No-Break"><st c="14998">over time.</st></span></li>
				<li><strong class="bold"><st c="15008">Streamlined release cycles for faster time to market</st></strong><st c="15061">: By automating the deployment process, CD enables software development teams to quickly deliver new features and bug fixes to end users. </st><st c="15200">This automation reduces the risk of human error and enables small, frequent updates to be deployed quickly, speeding up time to market and giving companies a </st><span class="No-Break"><st c="15358">competitive edge.</st></span></li>
				<li><strong class="bold"><st c="15375">Early detection of problems thanks to automated testing</st></strong><st c="15431">: CD emphasizes the importance of automated testing throughout the software development process. </st><st c="15529">By carrying out continuous testing, developers can quickly identify and resolve any potential problems, thus guaranteeing the stability and reliability</st><a id="_idIndexMarker397"/><st c="15680"> of the software. </st><st c="15698">This early detection helps reduce the likelihood of costly errors in production and instills confidence in the </st><span class="No-Break"><st c="15809">development team.</st></span></li>
				<li><strong class="bold"><st c="15826">Continuous feedback loop for continuous improvement</st></strong><st c="15878">: CD fosters a culture of continuous improvement by establishing a feedback loop between developers and end users. </st><st c="15994">This iterative process enables organizations to adapt and respond to changing user needs, ensuring that their software remains relevant </st><span class="No-Break"><st c="16130">and competitive.</st></span></li>
				<li><strong class="bold"><st c="16146">Improved collaboration and communication</st></strong><st c="16187">: CD promotes collaboration and communication between team members, improving the overall efficiency of the development process. </st><st c="16317">By automating the deployment pipeline, developers can concentrate on their core tasks, facilitating seamless integration between different teams and resulting in faster, more efficient </st><span class="No-Break"><st c="16502">software releases.</st></span></li>
			</ul>
			<p><st c="16520">In short, CD offers development teams the ability to deliver software faster, ensure high quality through automated testing, and maintain a responsive and agile development process. </st><st c="16703">These benefits collectively contribute to a more efficient, innovative, and customer-centric software </st><span class="No-Break"><st c="16805">development cycle.</st></span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor394"/><st c="16823">Key principles of CD implementation</st></h2>
			<p><st c="16859">Overall, CD is an essential aspect of the</st><a id="_idIndexMarker398"/><st c="16901"> DevOps approach, enabling organizations to release software updates quickly and efficiently, accelerating innovation and value creation for end users. </st><st c="17053">The key principles of CD implementation are essential to creating a streamlined and automated software release process. </st><st c="17173">These principles derive from a combination of agile and organizational best practices aimed at delivering software to end users as quickly as possible, learning from their experience and incorporating their feedback into the next release. </st><st c="17412">Here are the </st><span class="No-Break"><st c="17425">fundamental principles:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="17448">Build quality</st></strong><st c="17462">: This principle emphasizes building quality into the product from the outset, rather than relying on</st><a id="_idIndexMarker399"/><st c="17564"> inspection to achieve it. </st><st c="17591">It involves creating and evolving feedback loops to detect problems at an early stage, ideally before they are recorded in the version control system. </st><st c="17742">Automated testing should be used to detect defects before they worsen </st><span class="No-Break"><st c="17812">over time.</st></span></li>
				<li><strong class="bold"><st c="17822">Work in small batches</st></strong><st c="17844">: CD encourages working with small, manageable changes rather than large, infrequent releases. </st><st c="17940">This approach reduces the time needed to obtain feedback, facilitates problem identification and resolution, and increases efficiency and motivation. </st><st c="18090">The aim is to change the economics of the software delivery process to make it viable to work in </st><span class="No-Break"><st c="18187">small batches.</st></span></li>
				<li><strong class="bold"><st c="18201">Computers do repetitive tasks, people solve problems</st></strong><st c="18254">: This principle emphasizes the importance of automating repetitive tasks, such as regression testing, so that humans can concentrate on solving problems. </st><st c="18410">The aim is to create a balance in which computers handle the simple, repe</st><a id="_idTextAnchor395"/><st c="18483">titive tasks, and humans the more complex, </st><span class="No-Break"><st c="18527">creative ones.</st></span></li>
				<li><strong class="bold"><st c="18541">Continuous improvement</st></strong><st c="18564">: CD promotes the idea of continuous improvement, or </st><em class="italic"><st c="18618">kaizen</st></em><st c="18624">, derived from the Lean movement. </st><st c="18658">It’s about seeing improvement work as an essential part of everyday work, and constantly striving to make things better. </st><st c="18779">It’s about not being satisfied with the status quo and always looking for opportunities </st><span class="No-Break"><st c="18867">to improve.</st></span></li>
				<li><strong class="bold"><st c="18878">Everyone is responsible</st></strong><st c="18902">: In successful organizations, everyone is responsible for the quality and stability of the software they build. </st><st c="19016">This principle encourages a collaborative approach in which developers, operational teams, and other stakeholders work together to achieve the organization’s goals, rather than optimizing the success of their own team. </st><st c="19235">It emphasizes the importance of rapid feedback loops based on customer feedback and </st><span class="No-Break"><st c="19319">organizational impact.</st></span></li>
			</ul>
			<p><st c="19341">Implementing these principles requires a cultural change within the organization, fostering a collaborative environment where everyone is encouraged to ensure that the product delivered to the end user is of the highest </st><a id="_idTextAnchor396"/><st c="19562">possible quality. </st><st c="19580">This means tackling tedious or error-prone tasks</st><a id="_idIndexMarker400"/><st c="19628"> early on in the process to avoid aggravating problems and optimize the use of resources. </st><st c="19718">In the next section, we will learn how to set up CI/CD pipelines for automating build with </st><span class="No-Break"><st c="19809">GitHub Actions.</st></span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor397"/><st c="19824">Setting up CI/CD pipelines for automating build with GitHub Actions</st></h1>
			<p><st c="19892">Setting up CI/CD pipelines with</st><a id="_idIndexMarker401"/><st c="19924"> GitHub Actions involves several steps, each of which is crucial to automating build processes. </st><st c="20020">Here’s a step-by-step guide to get </st><span class="No-Break"><st c="20055">you started.</st></span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor398"/><st c="20067">Step 1 – create or choose a repository and project</st></h2>
			<p><st c="20118">Start by selecting a repository in</st><a id="_idIndexMarker402"/><st c="20153"> which you wish to set up your CI/CD pipeline. </st><st c="20200">This can be an existing project or a new one you’re working on. </st><st c="20264">In our case, it will be this repository on </st><span class="No-Break"><st c="20307">GitHub: </st></span><a href="https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main"><span class="No-Break"><st c="20315">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main</st></span></a><span class="No-Break"><st c="20401">.</st></span></p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B21146_09_1.jpg" alt="Figure 9.1 – Calculator repository project"/><st c="20402"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="20935">Figure 9.1 – Calculator repository project</st></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor399"/><st c="20977">Step 2 – open GitHub Actions in your project repository</st></h2>
			<p><st c="21033">Now, go to the GitHub Actions tab</st><a id="_idIndexMarker403"/><st c="21067"> in the top navigation bar of your repository. </st><st c="21114">Here, you’ll find a variety of CI/CD automation templates and workflows tailored to your project’s technology stack. </st><st c="21231">GitHub Actions offers a wide range of predefined workflows and lets you create your own </st><span class="No-Break"><st c="21319">from scratch.</st></span></p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B21146_09_2.jpg" alt="Figure 9.2 – GitHub Actions pipeline templates"/><st c="21332"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21839">Figure 9.2 – GitHub Actions pipeline templates</st></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor400"/><st c="21885">Step 3 – define your CI/CD workflow</st></h2>
			<p><st c="21921">Our project is an Angular project, so it runs on Node.js. </st><st c="21980">We’ll therefore choose the GitHub Actions template</st><a id="_idIndexMarker404"/><st c="22030"> dedicated to Node.js, which we’ll modify as we go along so that it meets our needs. </st><st c="22115">You need to search using the </st><strong class="source-inline"><st c="22144">node</st></strong><st c="22148"> keyword in the GitHub Actions template search bar, filtering by the </st><strong class="bold"><st c="22217">Continuous </st></strong><span class="No-Break"><strong class="bold"><st c="22228">integration</st></strong></span><span class="No-Break"><st c="22239"> category:</st></span></p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B21146_09_3.jpg" alt="Figure 9.3 – GitHub Actions pipeline templates"/><st c="22249"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="22564">Figure 9.3 – GitHub Actions pipeline templates</st></p>
			<p><st c="22610">As we can see in </st><span class="No-Break"><em class="italic"><st c="22628">Figure 9</st></em></span><em class="italic"><st c="22636">.4</st></em><st c="22638">, Node.js is in </st><span class="No-Break"><st c="22654">the list:</st></span></p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B21146_09_4.jpg" alt="Figure 9.4 – Node.js by GitHub Actions"/><st c="22663"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="22758">Figure 9.4 – Node.js by GitHub Actions</st></p>
			<p><st c="22796">We can now click on the </st><strong class="bold"><st c="22821">Configure</st></strong><st c="22830"> button </st><a id="_idIndexMarker405"/><st c="22838">and we’ll be redirected to the interface shown in </st><span class="No-Break"><em class="italic"><st c="22888">Figure 9</st></em></span><span class="No-Break"><em class="italic"><st c="22896">.5</st></em></span><span class="No-Break"><st c="22898">:</st></span></p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B21146_09_5.jpg" alt="Figure 9.5 – Node.js basic pipeline template"/><st c="22900"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23629">Figure 9.5 – Node.js basic pipeline template</st></p>
			<p><st c="23673">We can now begin the modifications. </st><st c="23710">First, we’ll change the name of the file at the top to </st><strong class="source-inline"><st c="23765">angular-tdd.yml</st></strong><st c="23780">, as shown in </st><span class="No-Break"><em class="italic"><st c="23794">Figure 9</st></em></span><span class="No-Break"><em class="italic"><st c="23802">.6</st></em></span><span class="No-Break"><st c="23804">:</st></span></p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/B21146_09_6.jpg" alt="Figure 9.6 – Workflow name"/><st c="23806"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23897">Figure 9.6 – Workflow name</st></p>
			<p><st c="23923">Next, we can mo</st><a id="_idTextAnchor401"/><st c="23939">dify the value of </st><strong class="source-inline"><st c="23958">name</st></strong><st c="23962"> at the</st><a id="_idIndexMarker406"/><st c="23969"> beginning of our file. </st><st c="23993">Instead of </st><strong class="source-inline"><st c="24004">Node.js CI</st></strong><st c="24014">, we’ll call it </st><strong class="source-inline"><st c="24030">Angular </st></strong><span class="No-Break"><strong class="source-inline"><st c="24038">TDD CI/CD</st></strong></span><span class="No-Break"><st c="24047">:</st></span></p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/B21146_09_7.jpg" alt="Figure 9.7 – Pipeline name"/><st c="24049"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24076">Figure 9.7 – Pipeline name</st></p>
			<p><st c="24102">Next, we can change the </st><strong class="source-inline"><st c="24127">–version: [14.x, 16.x, 18.x]</st></strong><st c="24155"> array node to </st><span class="No-Break"><strong class="source-inline"><st c="24170">node-version: [18.x]</st></strong></span><span class="No-Break"><st c="24190">:</st></span></p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/B21146_09_8.jpg" alt="Figure 9.8 – Pipeline Node.js ﻿version"/><st c="24192"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24302">Figure 9.8 – Pipeline Node.js </st><a id="_idTextAnchor402"/><st c="24332">version</st></p>
			<p><st c="24339">Finally, we’ll delete the last line of our file (i.e., </st><strong class="source-inline"><st c="24395">- run: npm test</st></strong><st c="24410">) because we don’t have any tests at the moment. </st><st c="24460">This is the final content of </st><span class="No-Break"><st c="24489">our file:</st></span></p>
			<pre class="source-code"><st c="24498">
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https: //docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs
name: Angular TDD CI/CD
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https: //nodejs.org/en/about/releases/
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
    - run: npm ci
    - run: npm run build --if-present</st></pre>			<p><st c="25287">Now, we can save the file by clicking on the </st><strong class="bold"><st c="25333">Commit </st></strong><span class="No-Break"><strong class="bold"><st c="25340">changes</st></strong></span><span class="No-Break"><st c="25347"> button.</st></span></p>
			<p><st c="25355">This workflow is designed to automate the process of installing Node.js dependencies, caching them for faster future builds and building the Angular project. </st><st c="25514">The following is a decomposition of the key components</st><a id="_idIndexMarker407"/><st c="25568"> of our workflow and </st><span class="No-Break"><st c="25589">their functions:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="25605">Job definition</st></strong><st c="25620">: The workflow defines a single job named </st><strong class="source-inline"><st c="25663">build</st></strong><st c="25668">. This job runs on the latest Ubuntu virtual machine provided by </st><span class="No-Break"><st c="25733">GitHub Actions.</st></span></li>
				<li><strong class="bold"><st c="25748">Working directory</st></strong><st c="25766">: The </st><strong class="source-inline"><st c="25773">defaults</st></strong><st c="25781"> section sets the working directory for all stages of the build job to </st><strong class="source-inline"><st c="25852">./</st></strong><span class="No-Break"><strong class="source-inline"><st c="25854">Chapter 9</st></strong></span><strong class="source-inline"><st c="25864">/getting-started-angular-tdd/</st></strong><st c="25894">. This ensures that commands are executed in the correct location where your Angular project </st><span class="No-Break"><st c="25987">is located.</st></span></li>
				<li><strong class="bold"><st c="25998">Node.js matrix</st></strong><st c="26013">: The </st><strong class="source-inline"><st c="26020">strategy</st></strong><st c="26028"> section defines a matrix that runs the job multiple times, each time with a different Node.js version. </st><st c="26132">In this example, the matrix includes only one version: </st><strong class="source-inline"><st c="26187">18.x</st></strong><st c="26191">. You can expand this to include more versions for broader </st><span class="No-Break"><st c="26250">compatibility testing.</st></span></li>
				<li><strong class="bold"><st c="26272">Checkout</st></strong><st c="26281">: The first step (</st><strong class="source-inline"><st c="26300">uses: actions/checkout@v3</st></strong><st c="26326">) uses the official GitHub Actions </st><strong class="source-inline"><st c="26362">checkout</st></strong><st c="26370"> action to clone the repository’s code onto </st><span class="No-Break"><st c="26414">the runner.</st></span></li>
				<li><strong class="bold"><st c="26425">Set up Node.js</st></strong><st c="26440">: The second step (</st><strong class="source-inline"><st c="26460">uses: actions/setup-node@v3</st></strong><st c="26488">) uses the official GitHub Actions </st><strong class="source-inline"><st c="26524">setup-node</st></strong><st c="26534"> action to install and configure the specified Node.js version (</st><strong class="source-inline"><st c="26598">18.x</st></strong><st c="26603">) on </st><span class="No-Break"><st c="26609">the runner.</st></span></li>
				<li><st c="26620">The </st><strong class="source-inline"><st c="26625">cache</st></strong><st c="26630"> parameter is set to </st><strong class="source-inline"><st c="26651">npm</st></strong><st c="26654"> to enable caching of Node.js modules between workflow runs, potentially speeding up subsequent executions. </st><strong class="source-inline"><st c="26762">cache-dependency-path</st></strong><st c="26783"> is set to </st><strong class="source-inline"><st c="26794">**/package-lock.json</st></strong><st c="26814"> to ensure the cache is invalidated if the </st><strong class="source-inline"><st c="26857">package-lock.json</st></strong><st c="26874"> file changes (indicating a change </st><span class="No-Break"><st c="26909">in dependencies).</st></span></li>
				<li><strong class="bold"><st c="26926">Install dependencies</st></strong><st c="26947">: The third step (</st><strong class="source-inline"><st c="26966">run: npm ci</st></strong><st c="26978">) runs the </st><strong class="source-inline"><st c="26990">npm ci</st></strong><st c="26996"> command to install the project’s dependencies from the </st><strong class="source-inline"><st c="27052">package-lock.json</st></strong><st c="27069"> file. </st><st c="27076">This ensures a consistent dependency state across </st><span class="No-Break"><st c="27126">different environments.</st></span></li>
				<li><strong class="bold"><st c="27149">Build the application</st></strong><st c="27171">: The fourth step (</st><strong class="source-inline"><st c="27191">run: npm run build --if-present</st></strong><st c="27223">) conditionally runs the </st><strong class="source-inline"><st c="27249">npm run build</st></strong><st c="27262"> command if it exists in the project’s </st><strong class="source-inline"><st c="27301">package.json</st></strong><st c="27313"> file. </st><st c="27320">This allows for flexibility in different project setups, where not all projects might have a </st><strong class="source-inline"><st c="27413">build</st></strong> <span class="No-Break"><st c="27418">script defined.</st></span></li>
			</ul>
			<p><st c="27434">However, it is important to note</st><a id="_idIndexMarker408"/><st c="27467"> that if you clone the project from the course repository, you must add the following just after </st><span class="No-Break"><strong class="source-inline"><st c="27564">runs-on: ubuntu-latest</st></strong></span><span class="No-Break"><st c="27586">:</st></span></p>
			<pre class="source-code"><st c="27588">
defaults:
      run:
        working-directory: "./Chapter 9/getting-started-angular-tdd"</st></pre>			<p><st c="27664">This final rendering is obtained by cloning the project from the </st><span class="No-Break"><st c="27730">book repository:</st></span></p>
			<pre class="source-code"><st c="27746">
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https: //docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs
name: Angular TDD CI/CD
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: "./Chapter 9/getting-started-angular-tdd"
    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https: //nodejs.org/en/about/releases/
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
   cache-dependency-path: '**/package-lock.json'
    - run: npm ci
    - run: npm run build --if-present</st></pre>			<p><st c="28611">Finally, if the process goes well, here’s what you’ll get in the GitHub </st><span class="No-Break"><st c="28684">Actions interface:</st></span></p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B21146_09_9.jpg" alt="Figure 9.9 – Pipeline successfully completed"/><st c="28702"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="28804">Figure 9.9 – Pipeline successfully completed</st></p>
			<p><st c="28848">In the next section, we will learn</st><a id="_idIndexMarker409"/><st c="28883"> how to set up CI/CD pipelines for automating test with </st><span class="No-Break"><st c="28939">GitHub Actions.</st></span></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor403"/><st c="28954">Setting up CI/CD pipelines for automating tests with GitHub Actions</st></h1>
			<p><st c="29022">In this new section, we’ll update our </st><a id="_idIndexMarker410"/><st c="29061">previous workflow for running tests. </st><st c="29098">Logic dictates that tests should be run before the build. </st><st c="29156">Here’s the </st><span class="No-Break"><st c="29167">test workflow:</st></span></p>
			<pre class="source-code"><st c="29181">
test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: './Chapter 9/getting-started-angular-tdd/'
    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https: //nodejs.org/en/about/releases/
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
    - run: npm ci
    - run: npm run test</st></pre>			<p><st c="29659">Now, let’s combine the two </st><a id="_idIndexMarker411"/><st c="29687">workflows, test and build; here’s how it looks in </st><span class="No-Break"><st c="29737">basic terms:</st></span></p>
			<pre class="source-code"><st c="29749">
name: Angular TDD CI/CD
on:
push:
    branches: [ "main" ]
pull_request:
    branches: [ "main" ]
jobs:
test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: './Chapter 9/getting-started-angular-tdd/'
    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https: //nodejs.org/en/about/releases/
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
    - run: npm ci
    - run: npm run test
build:
    needs: test
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: './Chapter 9/getting-started-angular-tdd/'
    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https : //nodejs.org/en/about/releases/
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
    - run: npm ci
    - run: npm run build --if-present</st></pre>			<p><st c="30829">As mentioned in the preceding code</st><a id="_idIndexMarker412"/><st c="30864"> block, the test workflow comes well before the build workflow. </st><st c="30928">However, there is one aspect that immediately stands out. </st><st c="30986">It’s the repetition of many of the sequences found in the test and build. </st><st c="31060">Based on the principle of </st><strong class="bold"><st c="31086">don’t repeat yourself</st></strong><st c="31107"> (</st><strong class="bold"><st c="31109">DRY</st></strong><st c="31112">), we’re going</st><a id="_idIndexMarker413"/><st c="31127"> to merge all the sequences into a single job, which </st><a id="_idIndexMarker414"/><st c="31180">we’ll call </st><strong class="source-inline"><st c="31191">test-and-build</st></strong><st c="31205">, for example. </st><st c="31220">Here’s how </st><span class="No-Break"><st c="31231">it looks:</st></span></p>
			<pre class="source-code"><st c="31240">
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https: //docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs
name: Angular TDD CI/CD
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
jobs:
  test-and-build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: './Chapter 9/getting-started-angular-tdd/'
    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https: //nodejs.org/en/about/releases/
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
    - run: npm ci
    - run: npm run test --if-present
    - run: npm run build --if-present</st></pre>			<p><st c="32148">Now, when we run the pipeline, we </st><a id="_idIndexMarker415"/><st c="32183">notice that the </st><strong class="source-inline"><st c="32199">npm run test --if-present</st></strong><st c="32224"> task runs in a block </st><span class="No-Break"><st c="32246">like this:</st></span></p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B21146_09_10.jpg" alt="Figure 9.10 – Pipeline running"/><st c="32256"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="32400">Figure 9.10 – Pipeline running</st></p>
			<p><st c="32430">In fact, it’s quite normal for us to have this problem because the </st><strong class="source-inline"><st c="32498">npm run</st></strong><st c="32505"> test executes the </st><strong class="source-inline"><st c="32524">ng</st></strong><st c="32526"> test. </st><st c="32533">Since we’re in an Angular project, it tries to launch Chrome in the pipeline. </st><st c="32611">Unfortunately, it can’t find it</st><a id="_idIndexMarker416"/><st c="32642"> because we don’t have a </st><strong class="bold"><st c="32667">graphical user interface</st></strong><st c="32691"> (</st><strong class="bold"><st c="32693">GUI</st></strong><st c="32696">). </st><st c="32700">Hence, we get the </st><span class="No-Break"><st c="32718">following error:</st></span></p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B21146_09_11.jpg" alt="Figure 9.11 – Pipeline fails"/><st c="32734"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="34516">Figure 9.11 – Pipeline fails</st></p>
			<p><st c="34544">To fix this, we’re going to make </st><a id="_idIndexMarker417"/><st c="34578">a few changes to the project, in particular to the </st><strong class="source-inline"><st c="34629">angular.json</st></strong><st c="34641"> file, by adding a configuration to the test configuration </st><span class="No-Break"><st c="34700">like this:</st></span></p>
			<pre class="source-code"><st c="34710">
"configurations": {
          "ci": {
              "watch": false,
              "progress": false,
              "browsers": "ChromeHeadlessCI"
        }
}</st></pre>			<p><st c="34808">This is the complete </st><span class="No-Break"><st c="34830">test configuration:</st></span></p>
			<pre class="source-code"><st c="34849">
"test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": [
              "zone.js",
              "zone.js/testing"
            ],
            "tsConfig": "tsconfig.spec.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              "src/favicon.ico",
              "src/assets"
            ],
            "styles": [
              "src/styles.scss"
            ],
            "scripts": []
          },
          "configurations": {
            "ci": {
              "watch": false,
              "progress": false,
              "browsers": "ChromeHeadlessCI"
            }
          }
        }</st></pre>			<p><st c="35231">After that, we need to create a </st><strong class="source-inline"><st c="35264">karma.conf.js</st></strong><st c="35277"> file in the </st><strong class="source-inline"><st c="35290">src</st></strong><st c="35293"> folder of our Angular project, if the file </st><a id="_idIndexMarker418"/><st c="35337">doesn’t already exist. </st><st c="35360">In this file, we’ll put the source code </st><a id="_idIndexMarker419"/><st c="35400">related to </st><span class="No-Break"><st c="35411">Karma’s configuration:</st></span></p>
			<pre class="source-code"><st c="35433">
// Karma configuration file, see link for more information
// https: //karma-runner.github.io/1.0/config/configuration-file.html
process.env.CHROME_BIN = require("puppeteer").executablePath();
module.exports = function (config) {
  config.set({
    basePath: "",
    frameworks: ["jasmine", "@angular-devkit/build-angular"],
    plugins: [
      require("karma-jasmine"),
      require("karma-chrome-launcher"),
      require("karma-jasmine-html-reporter"),
      require("karma-coverage-istanbul-reporter"),
      require("@angular-devkit/build-angular/plugins/karma"),
    ],
    client: {
      clearContext: false, // leave Jasmine Spec Runner output visible in browser
    },
    coverageIstanbulReporter: {
      dir: require("path").join(__dirname, "../coverage"),
      reports: ["html", "lcovonly"],
      fixWebpackSourcePaths: true,
    },
    reporters: ["progress", "kjhtml"],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ["Chrome"],
    customLaunchers: {
      ChromeHeadlessCI: {
        base: "ChromeHeadless",
        flags: ["--no-sandbox", "--disable-gpu"],
      },
    },
    singleRun: false,
  });
};</st></pre>			<p><st c="36459">Next, we need to install two packages in</st><a id="_idIndexMarker420"/><st c="36500"> dev mode, namely </st><strong class="source-inline"><st c="36518">puppeteer</st></strong><st c="36527"> and </st><strong class="source-inline"><st c="36532">karma-coverage-istanbul-reporter</st></strong><st c="36564">, by doing </st><span class="No-Break"><st c="36575">the following:</st></span></p>
			<pre class="console"><st c="36589">
$ npm i --save-dev puppeteer karma-coverage-istanbul-reporter</st></pre>			<p><st c="36651">Finally, in our GitHub Actions pipeline, we replace </st><strong class="source-inline"><st c="36704">npm run test –if-present</st></strong><st c="36728"> with </st><strong class="source-inline"><st c="36734">npm run test -- --configuration=ci</st></strong><st c="36768">, and here’s </st><span class="No-Break"><st c="36781">the result:</st></span></p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B21146_09_12.jpg" alt="Figure 9.12 – Pipeline successfully completed"/><st c="36792"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="37019">Figure 9.12 – Pipeline successfully completed</st></p>
			<p><st c="37064">Well done! </st><st c="37076">In the following, you’ll</st><a id="_idIndexMarker421"/><st c="37100"> find a summary of the workflow with all the changes made to date, along with the associated </st><span class="No-Break"><st c="37193">source code:</st></span></p>
			<pre class="source-code"><st c="37205">
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https: //docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs
name: Angular TDD CI/CD
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
jobs:
  test-and-build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: './Chapter 9/getting-started-angular-tdd/'
    strategy:
      matrix:
        node-version: [18.x]
        # See supported Node.js release schedule at https: //nodejs.org/en/about/releases/
    steps:
    - uses: actions/checkout@v3
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
    - run: npm ci
    - run: npm run test -- --configuration=ci
    - run: npm run build --if-present</st></pre>			<p><st c="38122">In the next section, we will learn </st><a id="_idIndexMarker422"/><st c="38158">how to set up CI/CD pipelines for automating deployment processes with </st><span class="No-Break"><st c="38229">GitHub Actions.</st></span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor404"/><st c="38244">Setting up CI/CD pipelines for automating the deployment process with GitHub Actions</st></h1>
			<p><st c="38329">CD is the practice of automatically </st><a id="_idIndexMarker423"/><st c="38366">deploying changes to production as soon as they have passed through the production pipeline. </st><st c="38459">This includes the automated processes of testing, building, and deploying. </st><st c="38534">GitHub Actions supports CD, enabling you to automate these </st><span class="No-Break"><st c="38593">processes efficiently.</st></span></p>
			<p><st c="38615">We’re not going to do it on this project, but we’ll see how we can. </st><st c="38684">To begin with, this will be a test and build stage like the other two. </st><st c="38755">Deployment takes place naturally at the end of development, so the same will apply to the workflow. </st><st c="38855">At the end of our current workflow, just after the build, we’ll add the following to deploy on a </st><span class="No-Break"><st c="38952">remote server:</st></span></p>
			<pre class="source-code"><st c="38966">
      - name: Upload build files to remote server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SI_HOST }}
          username: ${{ secrets.SI_USERNAME }}
          password: ${{ secrets.SI_PASSWORD }}
          port: ${{ secrets.SI_PORT }}
          source: "[SORUCE_FOLDER]"
          target: "[DESTINATION_TARGET_ON_YOUR_SERVER]"</st></pre>			<p><st c="39253">The provided GitHub Actions workflow snippet is designed to automate the process of uploading build files to a remote server. </st><st c="39380">This is a common step in a CI/CD pipeline for deploying applications. </st><st c="39450">Here’s a breakdown of the </st><span class="No-Break"><st c="39476">workflow step:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="39490">appleboy/scp-action@master</st></strong><st c="39517">: This specifies that </st><a id="_idTextAnchor405"/><st c="39540">this step uses the </st><strong class="source-inline"><st c="39559">scp-action</st></strong><st c="39569"> action from the </st><strong class="source-inline"><st c="39586">appleboy</st></strong><st c="39594"> GitHub repository. </st><st c="39614">This action is designed to securely copy files from your GitHub Actions runner to a remote server using the </st><strong class="bold"><st c="39722">secure copy protocol</st></strong><st c="39742"> (</st><strong class="bold"><st c="39744">SCP</st></strong><st c="39747">). </st><st c="39751">The </st><strong class="source-inline"><st c="39755">@master</st></strong><st c="39762"> tag indicates that the action should use the code</st><a id="_idIndexMarker424"/><st c="39812"> from the master branch of </st><span class="No-Break"><st c="39839">the repository.</st></span></li>
				<li><strong class="source-inline"><st c="39854">host</st></strong><st c="39859">: The address </st><a id="_idIndexMarker425"/><st c="39874">of the remote server where the files will be uploaded. </st><st c="39929">This value is retrieved from a GitHub secret </st><span class="No-Break"><st c="39974">named </st></span><span class="No-Break"><strong class="source-inline"><st c="39980">SI_HOST</st></strong></span><span class="No-Break"><st c="39987">.</st></span></li>
				<li><strong class="source-inline"><st c="39988">username</st></strong><st c="39997">: The username for authenticating with the remote server. </st><st c="40056">This value is retrieved from a GitHub secret </st><span class="No-Break"><st c="40101">named </st></span><span class="No-Break"><strong class="source-inline"><st c="40107">SI_USERNAME</st></strong></span><span class="No-Break"><st c="40118">.</st></span></li>
				<li><strong class="source-inline"><st c="40119">password</st></strong><st c="40128">: The password for authenticating with the remote server. </st><st c="40187">This value is retrieved from a GitHub secret </st><span class="No-Break"><st c="40232">named </st></span><span class="No-Break"><strong class="source-inline"><st c="40238">SI_PASSWORD</st></strong></span><span class="No-Break"><st c="40249">.</st></span></li>
				<li><strong class="source-inline"><st c="40250">port</st></strong><st c="40255">: The port number for connecting to the remote server. </st><st c="40311">This value is retrieved from a GitHub secret </st><span class="No-Break"><st c="40356">named </st></span><span class="No-Break"><strong class="source-inline"><st c="40362">SI_PORT</st></strong></span><span class="No-Break"><st c="40369">.</st></span></li>
				<li><strong class="source-inline"><st c="40370">source</st></strong><st c="40377">: The path to the files that will be uploaded. </st><st c="40425">In this case, it’s set to upload all files in the source </st><span class="No-Break"><st c="40482">build directory.</st></span></li>
				<li><strong class="source-inline"><st c="40498">target</st></strong><st c="40505">: The destination path on the remote server where the files will </st><span class="No-Break"><st c="40571">be uploaded.</st></span></li>
			</ul>
			<p><st c="40583">For other cloud-oriented platforms, GitHub Actions makes the task easier by offering deployment templates for most of </st><span class="No-Break"><st c="40702">these platforms.</st></span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor406"/><st c="40718">Summary</st></h1>
			<p><st c="40726">In summary, this chapter covered the fundamental concepts of CI and CD practices within the SDLC, highlighting their importance and benefits. </st><st c="40869">We began by understanding that CI is a process that aims to automate the integration of code changes into a shared repository, facilitating automated builds and tests to quickly detect and correct problems. </st><st c="41076">This practice is crucial for the early detection of bugs and errors, promoting a faster feedback loop, encouraging collaboration, and improving </st><span class="No-Break"><st c="41220">code quality.</st></span></p>
			<p><st c="41233">CD is then introduced as an extension of CI, focusing on automating the deployment process while ensuring that the software is always in a releasable state. </st><st c="41391">This practice enables rapid and reliable releases of software in different environments, reducing the risk of deployment errors and enabling </st><span class="No-Break"><st c="41532">faster time-to-market.</st></span></p>
			<p><st c="41554">This chapter also looked at the practical aspects of setting up CI/CD pipelines using GitHub Actions, a popular workflow automation tool. </st><st c="41693">It explained how to automate the build process, including installing dependencies, compiling code, and running tests, as well as automating the </st><span class="No-Break"><st c="41837">deployment process.</st></span></p>
			<p><st c="41856">Key concepts and practices of continuous processes were examined, including the importance of making small, iterative changes, adopting trunk-based development, maintaining rapid build and test phases, and decoupling deployment from production release. </st><st c="42110">These practices are essential for establishing efficient, reliable continuous processes that accelerate development cycles, improve software quality, and deliver value to customers </st><span class="No-Break"><st c="42291">more quickly.</st></span></p>
			<p><st c="42304">In addition, the chapter discussed the role of testing in CI/CD processes, highlighting the importance of different types of testing, such as smoke tests, unit tests, integration tests, system tests, and acceptance tests. </st><st c="42527">These tests are essential to guarantee software quality and stability, providing rapid feedback on the state of the code base and helping to detect and correct problems early in the </st><span class="No-Break"><st c="42709">development process.</st></span></p>
			<p><st c="42729">In the next chapter, we’ll learn about the best practices and patterns for </st><span class="No-Break"><st c="42805">test-driven development.</st></span></p>
		</div>
	<div id="charCountTotal" value="42829"/></body></html>