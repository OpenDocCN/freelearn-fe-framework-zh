<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Making a Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Making a Game</h1></div></div></div><p>In this final chapter, we're going to create the most complex blueprint yet. We're going to create a game engine and a single screen action game. When you're finished with this chapter, you'll appreciate why developing with ReactJS is often compared to developing games. When we make games in HTML5, we use the canvas. Drawing on canvas is very similar to how we render the browser in ReactJS. We update the canvas continuously, discarding the previous content and render the new content immediately.</p><p>We'll be making an action game with a playable wizard character facing a horde of monsters while on a picnic. Armed with a fireball spell, the player must defeat all the enemies before he's able to relax and enjoy his lunch.</p><p>These are the topics we'll cover in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The optimal Webpack configuration with dynamic SCSS transpiling</li><li class="listitem" style="list-style-type: disc">Scripting with ShellJS</li><li class="listitem" style="list-style-type: disc">Static type checking with Flow</li><li class="listitem" style="list-style-type: disc">Creating an HTML5 canvas game engine</li><li class="listitem" style="list-style-type: disc">Responding to keyboard events</li><li class="listitem" style="list-style-type: disc">Creating and drawing image entities</li><li class="listitem" style="list-style-type: disc">Moving computer-controlled entities on the screen</li><li class="listitem" style="list-style-type: disc">Brute force collision detection</li><li class="listitem" style="list-style-type: disc">Setting up a game title and a game over scenario</li></ul></div><p>So let's get started!</p><div class="section" title="The optimal Webpack configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec54"/>The optimal Webpack configuration</h1></div></div></div><p>We're going to implement a few <a class="indexterm" id="id687"/>of the newer technologies, and once again, we're going to modify our Webpack configuration and build process. We're going to add type checking with Flow, a better solution for copying our assets and creating our production <code class="literal">index.html</code> file. Finally, we'll add support for inline import and instant transpiling of SCSS.</p><p>SCSS is an extension to CSS that allows you to write CSS with features that don't exist in regular CSS, such as<a class="indexterm" id="id688"/> nesting, mixins, inheritance, and variables. It's called a <span class="strong"><strong>preprocessor</strong></span>, which is like a transpiler where you write code in one language and convert it into another language<a class="indexterm" id="id689"/> before use. In this case, we will write code in SCSS and convert it into regular CSS before the browser parses it.</p><p>In order to do all of this, we'll need to add a few new packages from <code class="literal">npm</code> and make changes to our Webpack configuration. Note, we're going to start with the production Webpack scaffold we made in <a class="link" href="ch08.html" title="Chapter 8. Deploying Your App to the Cloud">Chapter 8</a>, <span class="emphasis"><em>Deploying Your App to the Cloud</em></span>. This scaffold has the following structure:</p><div class="informalexample"><pre class="programlisting">├── assets
│   ├── app.css
│   ├── favicon.ico
│   ├── index.html
│   └── index.prod.html
├── package.json
├── public
│   └── assets
│       └── bundle.js
├── server-development.js
├── server-production.js
├── source
│   └── index.jsx
├── Webpack-development.config.js
└── Webpack-production.config.js</pre></div><p>In both <code class="literal">Webpack-development.config.js</code> and <code class="literal">Webpack-production.config.js</code>, add this code inside the <code class="literal">loader</code> section (between the square brackets):</p><div class="informalexample"><pre class="programlisting">{
  test: /\.scss$/,
  loader: 'style!css!sass'
}</pre></div><p>Note that we're going to keep the Babel loader and then add another loader beneath, which will make sure Webpack understands the <code class="literal">scss</code> prefix.</p><p>In both the <code class="literal">configuration</code> files, add this import:</p><div class="informalexample"><pre class="programlisting">var HtmlWebpackPlugin = require('html-webpack-plugin');</pre></div><p>And, add this plugin code to the <code class="literal">plugins</code> section:</p><div class="informalexample"><pre class="programlisting">new HtmlWebpackPlugin({
  title: "A Wizard's Picnic",
  template: 'index.ejs',
  hash: true,
  inject: 'body'
})</pre></div><p>This plugin will take a template <code class="literal">index.ejs</code> file and copy it to the output path defined earlier in the configuration file as <code class="literal">index.html</code>. It will also insert the generated script files created with Webpack.</p><p>For <code class="literal">Webpack-development.config.js</code>, the output section should look like this:</p><div class="informalexample"><pre class="programlisting">output: {
  path: path.join(__dirname, 'assets'),
  filename: 'bundle.js'
},</pre></div><p>For <code class="literal">Webpack-production.config.js</code>, it should<a class="indexterm" id="id690"/> look like this:</p><div class="informalexample"><pre class="programlisting">output: {
  path: path.join(__dirname, 'public', 'assets'),
  filename: 'bundle.js'
},</pre></div><p>We also need to add the <code class="literal">index.ejs</code> file and its contents. Add them using this code:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta http-equiv="Content-type" content="text/html; charset=utf-8"/&gt;
    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Notice that we've skipped both the <span class="emphasis"><em>CSS</em></span> and the scripts and that we've added the page title by injecting <code class="literal">htmlWebpackPlugin</code>.</p><p>With these two changes, we can remove the <code class="literal">cpFile</code> plugin and the <code class="literal">cpFile</code> code in our <code class="literal">server-production.js</code> file. The <code class="literal">cpFile</code> plugin did two things: it copied<code class="literal"> assets/index.prod.html</code> to <code class="literal">public/assets/index.html</code> and <code class="literal">app.css</code> in <code class="literal">assets</code> to <code class="literal">public/assets</code>. We'll still need to copy the assets content, but since we'll be copying a lot of files, we'll need a smarter way to<a class="indexterm" id="id691"/> do this than simply copying file after file.</p><div class="section" title="Scripting with ShellJS"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec94"/>Scripting with ShellJS</h2></div></div></div><p>We're going to employ <span class="strong"><strong>ShellJS</strong></span> to copy our assets instead. This <code class="literal">npm</code> package is an alternative to ordinary bash <a class="indexterm" id="id692"/>scripts with the added <a class="indexterm" id="id693"/>benefit of support across environments. This means that the scripts we make will work for Windows users as well as for Mac/Linux users.</p><p>We'll need to add a script to copy our files, so add a new folder called <code class="literal">scripts</code> and add a file called <code class="literal">assets.js</code> to it. Then, add this code:</p><div class="informalexample"><pre class="programlisting">require('shelljs/global');
rm('-rf','public/assets');
mkdir('-p','public/assets');
cp('-R', 'assets/', 'public/assets');</pre></div><p>We also need to update our <code class="literal">package.json</code> file with a run script so that we can run ShellJS when packaging our app. Open the file and replace the <code class="literal">start</code> command with the following three lines:</p><div class="informalexample"><pre class="programlisting">"prestart": "shjs scripts/assets.js",
"start": "cross-env NODE_ENV=production npm run build",
"poststart": "cross-env NODE_ENV=production node server-production.js",</pre></div><p>We also need to update our <code class="literal">server</code> file, so open <code class="literal">server-production.js</code> and replace it with this content:</p><div class="informalexample"><pre class="programlisting">"use strict";
var express = require("express");
var app = express();
var port = process.env.PORT || 8080;
var host = process.env.HOST|| "0.0.0.0";
var path = require("path");
var compression = require("compression");
var http = require("http");
var errorHandler = require('express-error-handler');

app.use(compression());
app.get("*", function (req, res) {
  console.log(req.path);
  var file = path.join(__dirname, "public", "assets", req.path);
  res.sendFile(file);
});

server = http.createServer(app);
app.use(function (err, req, res, next) {
  console.log(err);
  next(err);
});
app.use( errorHandler({server: server}) );

app.listen(port, host, function() {
  console.log('Server started at http://'+host+':'+port);
});</pre></div><p>Next, we need to add all the packages<a class="indexterm" id="id694"/> we've been importing. Do this by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm i --save-dev shelljs@0.6.0 html-webpack-plugin@2.9.0 cross-env@1.0.8 sass-loader@3.1.2 node-sass@3.4.2 style-loader@0.13.0 css-loader@0.23.1</strong></span>
</pre></div><p>We can remove the two <a class="indexterm" id="id695"/>packages we don't need anymore using this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm remove --save-dev cp-file rimraf</strong></span>
</pre></div><p>You also need a <a class="indexterm" id="id696"/>complete set of assets for the game. You can clear out the current <code class="literal">assets</code> folder and use the contents available at <a class="ulink" href="http://reactjsblueprints-chapter10.herokuapp.com/assets.zip">http://reactjsblueprints-chapter10.herokuapp.com/assets.zip</a>. The graphics in our game contain a selection of tiles from a public domain roguelike tileset <a class="indexterm" id="id697"/>called <span class="strong"><strong>RLTiles</strong></span>. You can find the original tileset at <a class="ulink" href="http://rltiles.sf.net">http://rltiles.sf.net</a>.</p><p>Phew! That was a lot of changes, but we're finally ready to start programming the game. You should be able to run <code class="literal">npm run dev</code> to run the development server and <code class="literal">npm start</code> to build and run the production server.</p></div><div class="section" title="Static typechecking with Flow"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec95"/>Static typechecking with Flow</h2></div></div></div><p>We're going to type check our code <a class="indexterm" id="id698"/>with <span class="strong"><strong>Flow</strong></span>. This is not part of our code base, but you'll see the syntax everywhere in our engine and game code.</p><p>Flow is designed to find type<a class="indexterm" id="id699"/> errors in JavaScript programs. It has one major benefit when compared to a fully typed language, such as <span class="strong"><strong>TypeScript</strong></span>. You have<a class="indexterm" id="id700"/> the freedom to use it when you feel like. This means that you can mix typed code with non-typed code and keep on programming generally, as you've always done with the added benefit of being able to automatically spot type errors.</p><p>The downside is that the Flow binary is only available on Mac and Linux. There's an experimental Windows binary available, but it's not always up to date. The upside is that if you're on Windows, your code will still execute, but you won't be able to find any potential errors.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>Install Flow by visiting <a class="ulink" href="http://flowtype.org/docs/getting-started.html">http://flowtype.org/docs/getting-started.html</a> and following<a class="indexterm" id="id701"/> the instructions.</p></div></div><p>You need a special <a class="indexterm" id="id702"/>configuration file in<a class="indexterm" id="id703"/> the root of your project called <code class="literal">.flowconfig</code> (no name before the dot). Add the file with this content:</p><div class="informalexample"><pre class="programlisting">[include]
./source
[ignore]
.*/*.scss*
.*/node_modules/babel.*
.*/node_modules/babylon.*
.*/node_modules/redbox-react.*
.*/node_modules/invariant.*
.*/node_modules/fbjs.*
.*/node_modules/fsevents.*
.*/node_modules/is-my-json-valid.*
.*/node_modules/config-chain.*
.*/node_modules/json5.*
.*/node_modules/ua-parser-js.*
.*/node_modules/spdx.*
.*/node_modules/binary.*
.*/node_modules/resolve.*
.*/node_modules/npmconf.*
.*/node_modules/builtin.*
.*/node_modules/sha.*
[options]
module.name_mapper='.*\(.css\)' -&gt; 'empty/object'
module.name_mapper='.*\(.scss\)' -&gt; 'empty/object'</pre></div><p>This configuration tells <span class="emphasis"><em>Flow</em></span> to check the contents of the <code class="literal">source</code> folder while ignoring a few selected dependencies in <code class="literal">node_modules</code>, which it picks up through the reference in the <code class="literal">source</code> folder files.</p><p>When Flow is installed and the configuration file is added, you can start checking your code by executing <code class="literal">flow</code> from your command line. It will initialize a server on the first run and then report errors for every run after that.</p><p>A typical error looks like this:</p><div class="informalexample"><pre class="programlisting">source/engine/entity/randomMove.js:21
 21:     entity.direction = shuffle(direction)[0];
                            ^^^^^^^^^^^^^^^^^^ function call
 18:   let direction = ["x","y"];
                        ^^^ string. This type is incompatible with
  3:   array: Array&lt;Object&gt;
                    ^^^^^^ object type. See: source/engine/math/shuffle.js:3</pre></div><p>Here, Flow has figured out that the call to shuffle is called with an array, but the <code class="literal">shuffle</code> function is defined to expect <a class="indexterm" id="id704"/>an array with objects. The error is easy to fix because shuffle should expect an array with a collection of values and not an array with an object.</p><p>By using annotations, you<a class="indexterm" id="id705"/> code with intent, and Flow makes it easy to spot whether you're using functions the way you intended, as witnessed by the preceding error.</p></div></div></div>
<div class="section" title="Creating an HTML5 canvas engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec55"/>Creating an HTML5 canvas engine</h1></div></div></div><p>The game is divided into two parts: the engine and the game. For projects like these, it's worthwhile to have a plan for how the app is going to look at the final stage. It's natural to separate the pure game <a class="indexterm" id="id706"/>engine parts from the game parts because this makes it easier to repurpose them later and use them for other games.</p><p>Usually, when you make a game, you base it off a premade engine, but we're not going to do that. We're going to make an engine all by ourselves. We'll implement just the features that we need, but feel free to extend and add engine pieces of your own when we're done.</p><p>The engine should be placed as a subfolder inside <code class="literal">source</code>. This is the structure:</p><div class="informalexample"><pre class="programlisting">engine/
├── collision
│   └── bruteForce.js
├── entity
│   ├── createEntity.js
│   ├── drawEntity.js
│   ├── randomMove.js
│   └── targetEntity.js
├── index.js
├── input
│   ├── keyboard.js
├── math
│   ├── shuffle.js
│   ├── sign.js
└── video
    ├── clear.js
    └── loadImage.js</pre></div><p>The main file is <code class="literal">index.js</code>, which simply acts as a central import/export hub. Let's start by creating the <code class="literal">engine</code> folder and <code class="literal">index.js</code>. It should have this content:</p><div class="informalexample"><pre class="programlisting">const loadImage = require('./video/loadImage');
const clear = require('./video/clear');
const drawEntity = require('./entity/drawEntity');
const createEntity = require('./entity/createEntity');
const targetEntity = require('./entity/targetEntity');
const sign = require('./math/sign');
const bruteForce = require('./collision/bruteForce');
const keyboard = require('./input/keyboard');
const shuffle = require('./math/shuffle'); 
const randomMove= require('./entity/randomMove');

module.exports = {
  loadImage,
  clear,
  randomMove,
  createEntity,
  drawEntity,
  targetEntity,
  sign,
  shuffle,
  bruteForce,
  keyboard
}</pre></div><p>We'll be using all of these <a class="indexterm" id="id707"/>components in our game. Let's create each one and look at what they do.</p><p>Let's start with the <code class="literal">video</code> folder and <code class="literal">loadImage.js</code>. Add this code to the folder:</p><div class="informalexample"><pre class="programlisting">// @flow
const setImage = (ctx: Object, image: Image) =&gt; {
  ctx.drawImage(image, 0, 0);
}

const loadImage = (canvas: Object, image: string) =&gt; {
  let bgImage = new Image();
  bgImage.src = image;
  bgImage.onload = () =&gt; {
    setImage(canvas.getContext("2d"), bgImage)
  };
}
module.exports = loadImage;</pre></div><p>Adding a comment line with <code class="literal">@flow</code> tells <span class="emphasis"><em>Flow</em></span> to use its type-checking ability on this file. The <code class="literal">setImage</code> function is then defined with two arguments: <code class="literal">ctx</code> and <code class="literal">image</code>. The <code class="literal">ctx</code> argument is cast to an <a class="indexterm" id="id708"/>object and <code class="literal">image</code> to an image. If we had cast the image to a string, <span class="emphasis"><em>Flow</em></span> would immediately<a class="indexterm" id="id709"/> have told us that the type was incompatible with the <code class="literal">setImage</code> function call.</p><p>Enough with Flow; let's examine<a class="indexterm" id="id710"/> what this file does. It has two functions, but only one is exported. The <code class="literal">loadImage</code> function takes an image and fetches it to the <code class="literal">image</code> variable, namely <code class="literal">bgImage</code>. This is a network call so the module can't return the image immediately, but we tell the function to execute the <code class="literal">setImage</code> function as soon as the image is loaded. This function will then draw the image on to the canvas that we passed in.</p><p>The next file is <code class="literal">clear.js</code>, which needs to be added to the <code class="literal">source/engine/video</code> folder as well. Add this code:</p><div class="informalexample"><pre class="programlisting">const clear = (canvas: Object) =&gt; {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
};
module.exports = clear;</pre></div><p>When called, this completely clears the canvas.</p><p>The next file is <code class="literal">shuffle.js</code> in the <code class="literal">source/engine/math</code> folder. Add it with this code:</p><div class="informalexample"><pre class="programlisting">// @flow
const shuffle = (
  array: Array&lt;any&gt;
): Array&lt;any&gt; =&gt; {
  let count = array.length;
  let rnd, temp;

  while( count ) {
    rnd = Math.random() * count-- | 0;</pre></div><p>This line fetches a random number between <code class="literal">0</code> and the number of remaining items in the counter. The single pipe is a bitwise <code class="literal">or</code> operator, which in this case removes the fraction. It works much in the same way as <code class="literal">Math.floor()</code> but is faster because bitwise operators are primitive. It's arguably more convoluted and harder to understand, so wrapping the math operation with <code class="literal">Math.floor()</code> is a good idea if you want the code to be more readable. We'll then assign the item to the <code class="literal">temp</code> variable in sequence, and move the current item at the random number to the current counter in the array:</p><div class="informalexample"><pre class="programlisting">  temp = array[count];
  array[count] = array[rnd];
  array[rnd] = temp;</pre></div><p>Finally, we'll set the array at the random number to the item in sequence. This ensures that all items are accounted for:</p><div class="informalexample"><pre class="programlisting">  }
  return array;
}
module.exports = shuffle;</pre></div><p>As the name suggests, the <code class="literal">shuffle</code> function accepts an array collection and then shuffles it using a loop over all the items in the input array.</p><p>The second file in the <code class="literal">math</code> folder is <code class="literal">sign.js</code>. Add this code to it:</p><div class="informalexample"><pre class="programlisting">//@flow 
const sign = (n: number): number =&gt; {
  return Math.sign(n) || (n = +n) == 0 || n != n ? n : n &lt; 0 ? -1 : 1
};
module.exports = sign;</pre></div><p>Sign is a mathematical expression<a class="indexterm" id="id711"/> that returns an integer that indicates the sign of a number. We'll use the built-in <code class="literal">sign</code> function if available, or our own if not. We'll use this when setting up movement for enemy entities targeting the player.</p><p>Next is the <code class="literal">input</code> folder. Add <code class="literal">keyboard.js</code> with this code to it:</p><div class="informalexample"><pre class="programlisting">// @flow
const keyboard = (keys: Array&lt;bool&gt;) =&gt; {
  window.addEventListener("keydown", (e) =&gt; {
    keys[e.keyCode] = true;
  }, false);

  window.addEventListener("keyup", (e) =&gt; {
    delete keys[e.keyCode];
  }, false);
}
module.exports = keyboard;</pre></div><p>This file adds an event listener that registers keys when the player pushes any keys on the keyboard and deletes them from the key array when the event listener detects that the key is being released (the user is no longer pressing the key down).</p><p>Let's add the <code class="literal">entity</code> folder. Here we'll add five files. The first one is <code class="literal">targetEntity.js</code>. Add this code to it:</p><div class="informalexample"><pre class="programlisting">// @flow
import sign from '../math/sign';

const targetEntity = (
  entityA: Object,
  entityB: Object,
  speed: number = 1
) =&gt; {
  let posA = entityA.pos;
  let posB = entityB.pos;
  let velX = sign(posB.x - posA.x) * speed;
  let velY = sign(posB.y - posA.y) * speed;
  entityA.pos.x+=velX;
  entityA.pos.y+=velY;
};
module.exports = targetEntity;</pre></div><p>We'll use this file to set one entity on the path towards the position of another entity. In the game we're making, we will use this code to direct an enemy entity to the player or vice versa. The entity is an <a class="indexterm" id="id712"/>object that has a certain size, position, and velocity, and the code works by changing the <code class="literal">x</code> and <code class="literal">y</code> position of the <code class="literal">entityA</code> object.</p><p>We'll use the <code class="literal">sign</code> method to set the correct sign. If we don't do this, it will most likely move away from the entity instead of moving towards it.</p><p>Next up is <code class="literal">randomMove.js</code>. Add the file and this code:</p><div class="informalexample"><pre class="programlisting">// @flow
import shuffle from '../math/shuffle';
const randomMove = (
  entity: Object,
  speed: number = 1,
  Config: Object = {
    height: 512,
    width: 512,
    tileSize: 32
  }
) =&gt; {
  let {pos, vel} = entity;
  let speedX, speedY;

  entity.tick-=1;</pre></div><p>When <code class="literal">entity.tick</code> reaches zero, a new direction will be calculated. Now check this out:</p><div class="informalexample"><pre class="programlisting">  let direction = ["x","y"];

  if(entity.tick&lt;=0) {
    entity.direction = shuffle(direction)[0];
    entity.tick=Math.random()*50;
  }</pre></div><p>In order to make the direction recalculation a little more random, the new tick value is set between a value of <code class="literal">0</code> and <code class="literal">50</code>. Let's move on to another function:</p><div class="informalexample"><pre class="programlisting">  if(pos.x + vel.x &gt;Config.width - Config.tileSize *2) {
    vel.x=-speed;
  }
  if(pos.x + vel.x &lt; Config.tileSize/2) {
    vel.x=speed;
  }

  if(pos.y + vel.y &gt; Config.height- Config.tileSize * 2) {
    vel.y=-speed;
  }
  if(pos.y + vel.y &lt; Config.tileSize/2) {
    vel.y=speed;
  }

  entity.pos.x+= entity.direction==="x" ? vel.x: 0;
  entity.pos.y+= entity.direction==="y" ? vel.y: 0;
};
module.exports = randomMove;</pre></div><p>This function implements a <a class="indexterm" id="id713"/>random direction for computer-controlled entities.</p><p>The next file we'll create is <code class="literal">drawEntity.js</code>. Add this code:</p><div class="informalexample"><pre class="programlisting">// @flow
import createEntity from './createEntity';

module.exports = (
  canvas: Object,
  entity: Object
) =&gt; {
  if(entity._creating &amp;&amp; !entity._sprite){
    return 0;
  }
  else if(!entity._sprite) {
    createEntity(canvas, entity);
  }
  else {
    // draw the sprite as soon as the image
    // is ready
    var ctx = canvas.getContext("2d");
    ctx.drawImage(
      entity._sprite,
      entity.pos.x,
      entity.pos.y
    );
  }
}</pre></div><p>This file is similar to <code class="literal">loadImage</code>, except that we'll add a state to the entity by setting two variables: <code class="literal">_creating</code> and <code class="literal">_sprite</code>. We'll use this in the game later by only actually drawing entities that have a <a class="indexterm" id="id714"/>proper <code class="literal">ImageData</code> object (contained in <code class="literal">_sprite</code>).</p><p>The final file in the <code class="literal">entity</code> folder is <code class="literal">createEntity.js</code>. Add this code:</p><div class="informalexample"><pre class="programlisting">// @flow
import drawEntity from './drawEntity';

module.exports = (
  entity: Object
) =&gt; {
  entity.id=Math.random()*2;</pre></div><p>This provides the entity with an ID, take a look at the following:</p><div class="informalexample"><pre class="programlisting">  entity._creating=true;</pre></div><p>Flag it so we don't try to create the entity twice. Let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">  let entityImage = new Image();
  entityImage.src = entity.image;
  entityImage.onload = () =&gt; {
    entity._sprite = entityImage;
  };
}</pre></div><p>We're almost done with the engine. We'll need to add one more folder and file, <code class="literal">collision</code> and <code class="literal">bruteForce.js</code>, respectively. Add it with this code:</p><div class="informalexample"><pre class="programlisting">// @flow
module.exports = (
  entityA: Object = {pos: {x:0, y:0}},
  entityB: Object = {pos: {x:0, y:0}},
  size: number = 32
): bool =&gt; {
  return (
    entityA.pos.x &lt;=
      (entityB.pos.x + size)
    &amp;&amp; entityB.pos.x &lt;=
      (entityA.pos.x + size)
    &amp;&amp; entityA.pos.y &lt;=
      (entityB.pos.y + size)
    &amp;&amp; entityB.pos.y &lt;=
      (entityA.pos.y + size)
  )
}</pre></div><p>This function will compare the positions of two entities and determine whether they're occupying the same space. For small canvases and a limited number of entities on screen, it's the fastest collision<a class="indexterm" id="id715"/> detection you can conceivably implement.</p><p>You now have a small working game engine. Let's move on and start implementing the game.</p></div>
<div class="section" title="Creating the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Creating the game</h1></div></div></div><p>The game itself is going to<a class="indexterm" id="id716"/> be larger than the engine. This is not uncommon, especially for HTML5 games, but brace yourself because we're going to add a lot of files. Let's take a look at the following screenshot:</p><div class="mediaobject"><img alt="Creating the game" src="graphics/B04943_10_01.jpg"/></div><p>This is the file structure for the<a class="indexterm" id="id717"/> game (excluding the engine):</p><div class="informalexample"><pre class="programlisting">├── components
│   ├── addEntity.js
│   ├── addProjectile.js
│   ├── checkCollision.js
│   ├── debugBoard.js
│   ├── diceroll.js
│   ├── drawEntities.js
│   ├── drawGameOver.js
│   ├── drawGameWon.js
│   ├── drawHud.js
│   ├── clearCanvas.js
│   ├── keyInput.js
│   ├── keypress
│   │   ├── a.js
│   │   ├── d.js
│   │   ├── down.js
│   │   ├── index.js
│   │   ├── left.js
│   │   ├── right.js
│   │   ├── s.js
│   │   ├── space.js
│   │   ├── up.js
│   │   └── w.js
│   ├── outOfBounds.js
│   ├── removeEntity.js
│   └── setupGame.js
├── config
│   ├── beasts.js
│   ├── index.js
│   ├── players.js
│   └── spells.js
├── game.jsx
├── index.jsx
├── polyfills.js
├── style.scss
└── title.jsx</pre></div><p>Let's start with the<a class="indexterm" id="id718"/> <code class="literal">root</code> source files.</p><p>Add this to <code class="literal">index.jsx</code>:</p><div class="informalexample"><pre class="programlisting">import './style.scss';
import polyfill from './polyfills';
import Config from './config';</pre></div><p>The <code class="literal">Config</code> file is where we'll provide the game with all of the content, as follows:</p><div class="informalexample"><pre class="programlisting">import React, { Component, PropTypes } from 'react';
import MyGame from './game';
import Title from './title';
import {render} from 'react-dom';

class Index extends Component {
  constructor() {
    super();
    this.state={};
    this.state.scene="title";
  }

  callback(val: string) {
    this.setState({scene: val})
  }

  render() {
    switch(this.state.scene) {
      case "title":
        return &lt;Title cb={this.callback.bind(this)} /&gt;
      break;

      case "game":
        return &lt;MyGame cb={this.callback.bind(this)} /&gt;
      break;
    }
  }
}

render(
  &lt;Index /&gt;,
  document.getElementById('app')
);</pre></div><p>We display either the title <a class="indexterm" id="id719"/>or the game screen when the player starts the game. We implement the switch by providing the components with a <code class="literal">setState</code> callback, which means that anytime we want to switch to a scene, we can use <code class="literal">this.props.cb(scene)</code>.</p><p>Next, add <code class="literal">polyfills.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">// polyfill for requestAnimationFrame
var requestAnimFrame = (function() {
  return window.requestAnimationFrame  ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame    ||
    window.oRequestAnimationFrame      ||
    window.msRequestAnimationFrame     ||
    function(callback) {
      window.setTimeout(callback, 1000 / 60);
  };
})();</pre></div><p>This is a shim to provide support for <code class="literal">requestAnimationFrame</code> for the browsers that don't support it yet. As you can see in the code, it will implement <code class="literal">setTimeOut</code> if <code class="literal">requestAnimationFrame</code> is not supported. We want to use <code class="literal">requestAnimationFrame</code> because it's more efficient than <code class="literal">setTimeOut</code>, which is less accurate and also wastes a lot of cycles by rendering when it's not necessary.</p><p>Let's add <code class="literal">title.jsx</code>:</p><div class="informalexample"><pre class="programlisting">import './style.scss';
import polyfill from './polyfills';
import Config from './config';
import React, { Component, PropTypes } from 'react';
import Game from './engine';
import keyboard from './components/keypress/index';

class Title extends Component {
  constructor() {
    super();
    this.last = Date.now();
    this.keys={};
  }

  keyInput( keys ) {
    if (keyboard.space(keys)) {
      this.props.cb("game");
    }
  }</pre></div><p>Start the game if the <a class="indexterm" id="id720"/>player hits space on the keyboard. The next is as follows:</p><div class="informalexample"><pre class="programlisting">  updateGame(modifier) {
    if(typeof this.refs.canvas ==="undefined")
      return;</pre></div><p>This avoids updating the game if the canvas has not yet been initialized. The following code tells the game to listen for keyboard input:</p><div class="informalexample"><pre class="programlisting">    const { canvas } = this.refs;
    const ctx = canvas.getContext("2d");

    Game.loadImage(
      canvas,
      Config.backgrounds.title
    );

    // Keyboard
    this.keyInput(this.keys);
  }

  componentDidMount() {
    Game.keyboard(this.keys);</pre></div><p>This is the main game loop:</p><div class="informalexample"><pre class="programlisting">    const gameLoop = () =&gt; {
      var now = Date.now();
      var delta = now - this.last;
      this.updateGame(delta / 1000);
      this.last = now;
      window.requestAnimationFrame(gameLoop);
    }
    gameLoop();</pre></div><p>Even though this is a title <a class="indexterm" id="id721"/>scene, we treat it as a mini game and update it accordingly. This enables us to easily animate the title screen using entities and game logic and use the same input methods as in the game, let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">  }

  render() {
    return &lt;div&gt;&lt;canvas
      ref="canvas"
      id={ Config.id || "canvas" }
      height={ Config.height }
      width={ Config.width } &gt;
      Sorry, your browser doesn't
      support canvas
    &lt;/canvas&gt;
    &lt;br/&gt;
    &lt;div className="info"&gt;
      You're a wizard. You're on a picnic.
      &lt;br/&gt;
    You hear a noise...
    &lt;/div&gt;
  &lt;/div&gt;
  }
}
module.exports = Title;</pre></div><p>Next, add <code class="literal">style.scss</code> with this code:</p><div class="informalexample"><pre class="programlisting">canvas {
  margin: 0 auto;
  display: block;
}
body {
  background: black;
}
.info {
  color:white;
  text-align:center;
  margin: 0 auto;
  display: block;
  a {
    color:white;
  }
}</pre></div><p>And finally, we add the game itself. Add <code class="literal">game.jsx</code> with this code:</p><div class="informalexample"><pre class="programlisting">import './style.scss';
import polyfill from './polyfills';
import Config from './config/index';
import React, { Component, PropTypes } from 'react';
import Game from './engine';
import SetupGame from './components/setupGame';
import KeyInput from './components/keyInput';
import DrawHUD from './components/drawHud';
import DrawGameOver from './components/drawGameOver';
import DrawGameWon from './components/drawGameWon';
import DrawEntities from './components/drawEntities';
import ClearCanvas from './components/clearCanvas';
import CheckCollision from './components/checkCollision';
import OutOfBounds from './components/outOfBounds';
import AddProjectile from './components/addProjectile';
import AddEntity from './components/addEntity';
import RemoveEntity from './components/removeEntity';</pre></div><p>We'll need to create all of these components in order for the game to work. When developing a game, it's <a class="indexterm" id="id722"/>quite common to inline these components. When iterating the game, you'll get a feel for how to separate them into distinct components and how you can shape them for reuse, let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">class MyGame extends Component {
  constructor() {
    super();
    this.lastTime = Date.now();
    this.keys={};
    this.gameOver=false;
    this.gameWon=false;
    this.maxMonsters=3;
    this.level=0;
    this.beast=Config.beasts[0],
    this.state={};
    this.returnToTitleScreen=150;</pre></div><p>This is a countdown that will be used when the game is over and the player is returned to the title screen, take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">    this.score = 0;
    this.coolDown=0;</pre></div><p>This is another countdown. It's used whenever the player is shooting and prevents the player from spamming the board with projectiles, let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">    this.entities= Config.entities;
    this.current_player_no = 0;
    this.current_player = this.entities.players[0];
    this.state.player = this.current_player;
    this.current_player.health=100;
    this.current_player.pos= {x:8, y:8};</pre></div><p>The game board is 512 x 512 pixels and each individual entity is 32 x 32 pixels. It's easier to visualize the placement<a class="indexterm" id="id723"/> on the board by dividing the board size by the entity size. By looking at this value, it's easy to understand that the current player is placed in the middle of the board. It might be a little harder if we had used the precise pixel value, which is 256 x 256. Now, let's look at the next step:</p><div class="informalexample"><pre class="programlisting">  }

  updateGame(modifier) {
    if(typeof this.refs.canvas ==="undefined")
      return;

    const { canvas } = this.refs;
    const ctx = canvas.getContext("2d");

   if(this.gameOver) {
      ClearCanvas(canvas, this.gameOverImage);
      if(this.gameWon)
        DrawGameWon(canvas);
      else
        DrawGameOver(canvas);
      --this.returnToTitleScreen;
      if(this.returnToTitleScreen&lt;=0)
        this.props.cb('title');
      return;
    }</pre></div><p>Whenever the <code class="literal">gameOver</code> flag has been set to <code class="literal">true</code>, we tell the game to pause and start the counter that will return the player to the title screen when the counter hits zero, take a look at the following code:</p><div class="informalexample"><pre class="programlisting">    const player = this.entities.players[
      this.current_player_no
    ];</pre></div><p>This is a single player game, but you could add more players to the game by extending the <code class="literal">players</code> array in <code class="literal">config</code> and switch them by iterating the <code class="literal">current_player_no</code> variable. This function is responsible for drawing the player and any enemies and projectiles:</p><div class="informalexample"><pre class="programlisting">    DrawEntities(Config, canvas, this.entities);</pre></div><p>This function draws the score and the player health at the top of the screen:</p><div class="informalexample"><pre class="programlisting">    DrawHUD(canvas, this.score, player.health);</pre></div><p>This is a rather advanced<a class="indexterm" id="id724"/> function that handles all the key input in the game:</p><div class="informalexample"><pre class="programlisting">    this.coolDown-=0.1;

    KeyInput(
      Config,
      this.keys,
      player,
      1,
      AddProjectile.bind(this),
      (item) =&gt; this.entities.projectiles.push(item),
        this.coolDown,
      _ =&gt; this.coolDown = 1.5
    );</pre></div><p>It requires the <code class="literal">Config</code> object for calculating the position of the projectiles, the keys for handling the moving and shooting actions, the <code class="literal">player</code> object, and a modifier that can be used to speed up or down the movement. It also requires that you pass the function that creates a projectile and two callbacks: the first for adding the projectile to the <code class="literal">entities</code> array and the second a setter for the <code class="literal">coolDown</code> variable. The higher this last value is, the fewer projectiles the player can fire. For every iteration, the projectile moves according to its velocity:</p><div class="informalexample"><pre class="programlisting">    this.entities.projectiles.forEach((item)=&gt; {
      item.pos.x+= item.direction.xVel;
      item.pos.y+= item.direction.yVel;</pre></div><p>The following loop is necessary to check whether any of the projectiles collide with any of the monsters:</p><div class="informalexample"><pre class="programlisting">      this.entities.monsters.forEach((monster)=&gt; {</pre></div><p>It's a loop within a loop, which is something we generally should be careful with because it can be a major source of slowdown. Now check out the following code:</p><div class="informalexample"><pre class="programlisting">        if(Game.bruteForce(
          item, monster, Config.tileSize/2
        )) {
          monster.health-=20;

          this.entities.projectiles =
          RemoveEntity(
              this.entities.projectiles,
              item,
              _ =&gt; {}
          );</pre></div><p>As illustrated, if the projectile collides with an enemy, the enemy loses 20 health points and we remove the projectile<a class="indexterm" id="id725"/> from the entities array. This makes sure it's not drawn in the next run of the game loop. The next check removes the enemy if its health is less than zero:</p><div class="informalexample"><pre class="programlisting">          if(monster.health&lt;=0) {
            this.entities.monsters =
            RemoveEntity(
              this.entities.monsters,
              monster,
              _ =&gt; { this.score++}
            );
          }
        }
      })

      if(OutOfBounds(
        item,
      {h:Config.height,w:Config.width},
      Config.tileSize
      )) {
        this.entities.projectiles =
        RemoveEntity(
          this.entities.projectiles,
          item,
          _ =&gt; {}
        );
      }</pre></div><p>This function takes care of removing projectiles that have escaped the canvas. This is important because we don't want to keep the list of elements that we calculate as small as possible. We move on to the next loop:</p><div class="informalexample"><pre class="programlisting">    })

    this.entities.monsters.forEach((monster)=&gt; {</pre></div><p>This loop checks whether the enemies are close to or are colliding with the player. If they are close, it should head straight for the player. Try increasing the range to make the game more difficult.</p><p>If they collide, the player loses health.</p><p>If none of these occur, we provide a random direction for the entity:</p><div class="informalexample"><pre class="programlisting">      if(Game.bruteForce(monster, player, 32)) {
        Game.targetEntity(
          monster,
          player,
          monster.speed
        )
      }
      Game.randomMove(
        monster,
        monster.speed,
        Config
      )

      CheckCollision(
        canvas, player,
        monster,
        _ =&gt; {player.health-=1},
        _ =&gt; {}
      );
    })

    if(!this.gameOver &amp;&amp; this.level&lt;=14) {
      if(this.entities.monsters.length&lt;=0) {
        ++this.level;</pre></div><p>Any time a player clears out<a class="indexterm" id="id726"/> the current set of enemies, they advance to the next level:</p><div class="informalexample"><pre class="programlisting">        this.beast=Config.beasts[this.level-1];
        this.setState({
          level: this.level,
          beast: this.beast
        })
        this.maxMonsters=this.level+3;
      }

      if(this.beast &amp;&amp; this.maxMonsters&gt;0) {
        --this.maxMonsters;</pre></div><p>Each level comes with more enemies. This check makes sure that we add as many <code class="literal">enemy</code> entities as the current level dictates:</p><div class="informalexample"><pre class="programlisting">        AddEntity(
          this.beast,
          {
            x: Game.shuffle([64,256,480])[0],
            y: Game.shuffle([-32,520])[0]
          },
          20+this.score,
          1+Math.random()*this.score/10,
          (item) =&gt; this.entities.monsters.push(item)
        )
      }
    }

    if(this.level&gt;14) {
      this.gameWon=true;
      this.returnToTitleScreen = 400;
      this.gameOver=true;
    }

    if(player.health&lt;0 || this.gameWon) {</pre></div><p>If the player is out of health, we <a class="indexterm" id="id727"/>store the current canvas image and use that as the game over screen. We then clear out the entities and set the <code class="literal">gameOver</code> flag:</p><div class="informalexample"><pre class="programlisting">      this.gameOverImage = 
        ctx.getImageData(
          0, 0, canvas.width, canvas.height
      );
      this.entities.monsters=[];
      this.entities.projectiles=[];
      this.gameOver = true;
    }

  }

  componentDidMount() {
    const canvas = this.refs.canvas;
    const ctx = canvas.getContext("2d");

    this.level=0;
    this.setState({
      score: 0,
      level: 0,
      beast: Config.beasts[0]
    })</pre></div><p>When mounting the game, we<a class="indexterm" id="id728"/> reset the score, level, and current enemy. This lets us start fresh when the player has hit game over and presses space to play again:</p><div class="informalexample"><pre class="programlisting">    SetupGame(
      Config, this.keys, this.refs.canvas,
      this.entities, this.positions
    );

    const gameLoop = () =&gt; {
      var now = Date.now();
      var delta = (now - this.lastTime) / 1000.0;
      this.updateGame(delta);
      this.last = now;
      window.requestAnimationFrame(gameLoop);
    }

    gameLoop();

  }

  getCurrentplayer() {
    return this.current_player.name
  }

  render() {
    return &lt;div&gt;
      &lt;canvas
        ref="canvas"
        id={ Config.id || "canvas" }
        height={ Config.height }
        width={ Config.width } &gt;
        Sorry, your browser doesn't
        support canvas
      &lt;/canvas&gt;
      &lt;br/&gt;
      &lt;div className="info"&gt;
        Player: {this.getCurrentplayer()}
        &amp;nbsp;
        Level: {this.level}
      &lt;/div&gt;

    &lt;/div&gt;
  }
}

module.exports = MyGame;</pre></div><p>The following screenshot shows the game with the player visible, with enemy entities swarming the player and a<a class="indexterm" id="id729"/> score and a health bar in the title bar. At the bottom of the screen, you see the player name (randomly picked from the <code class="literal">name</code> array) and the current difficulty level:</p><div class="mediaobject"><img alt="Creating the game" src="graphics/B04943_10_02.jpg"/></div><p>That's it for the game file, but as you noticed, we have several more files to add. We'll need to add two new folders: <code class="literal">components</code> and <code class="literal">config</code>. Let's start with <code class="literal">config</code>. Add this folder and the <code class="literal">index.js</code> file. Then, add this content:</p><div class="informalexample"><pre class="programlisting">import { players, names } from './players';
import { beasts } from './beasts';
import Shuffle from '../engine/math/shuffle';

let config =  {
  tileSize: 32,
  height: 512,
  width: 512,
  debug: true,
  beasts: beasts,
  backgrounds: {
    title: '/title.png',
    game: '/board512_grass.png'
  },
  entities: {
    players : [],
    projectiles: [],
    monsters: [],
    pickups: [],
    enemies: []
  }</pre></div><p>We haven't added any<a class="indexterm" id="id730"/> pickups to the game, but it'd be a good idea to do this and add various items such as health, different weapons, and so on, let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">}

config.entities.players.push({</pre></div><p>We'll add a single player and give them a random name from the list of names and a random image from the list of players, let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">  name: Shuffle(names).pop(),
  image: Shuffle(players).pop(),
  health: 100,
  width: 32,
  height: 32,
  pos:{
    x: 8,
    y: 8
  },
  speed: 5
})

module.exports = config;</pre></div><p>Next, add <code class="literal">config/players.js</code> with this content:</p><div class="informalexample"><pre class="programlisting">let names = [
  "Striliyrin",
  "Xijigast",
  "Omonar",
  "Egeor",
  "Omakojamar",
  "Eblokephior",
  "Tegorim",
  "Ugniforn",
  "Igsior",
  "Imvius",
  "Pobabine",
  "Oecodali",
  "Baro",
  "Trexaryl",
  "Flahevys",
  "Ugyritaris",
  "Afafyne",
  "Stayora",
  "Ojgis",
  "Ikgrith"
];
let players = [
  '/deep_elf_knight.png',
  '/deep_elf_death_mage.png',
  '/deep_elf_demonologist.png',
  '/deep_elf_fighter.png',
  '/deep_elf_high_priest.png',
  '/deep_elf_mage.png',
  '/deep_elf_blademaster.png',
  '/deep_elf_conjurer.png',
  '/deep_elf_annihilator.png'
]
exports.players = players;
exports.names = names;</pre></div><p>This file adds variety to the<a class="indexterm" id="id731"/> game. It can also be useful if and when we add more players to the game.</p><p>Finally, add <code class="literal">config/beasts.js</code> with this content:</p><div class="informalexample"><pre class="programlisting">let beasts = [
  "/beasts/acid_blob",
  "/beasts/rat",
  "/beasts/boring_beetle",
  "/beasts/giant_mite",
  "/beasts/orc_warrior",
  "/beasts/demonspawn",
  "/beasts/hydra",
  "/beasts/ooze",
  "/beasts/hobgoblin",
  "/beasts/dragon",
  "/beasts/harpy",
  "/beasts/golden_dragon",
  "/beasts/griffon",
  "/beasts/hell_knight"
]
exports.beasts = beasts;</pre></div><p>We're done with the<a class="indexterm" id="id732"/> configuration, so let's add all the game components.</p><p>Add <code class="literal">components/addEntity.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import Game from '../engine';
let directions = [1, -1];

const addEntity = (
  item: string,
  pos: Object,
  health: number = 60,
  speed: number = 1,
  callback: Function
) =&gt; {
  let entity = {
    name: item,
    image: `${item}.png`,
    width: 32,
    height: 32,
    health: health,
    pos:{
      x: pos.x,
      y: pos.y
    },
    vel:{
      x: Game.shuffle(directions)[0],
      y: Game.shuffle(directions)[0]
    },
    tick: 50,
    direction: Game.shuffle(["x","y"])[0],
    speed: speed+(Math.random()*1)
  };
  Game.createEntity(entity);
  callback(entity);
}
module.exports = addEntity;</pre></div><p>We add variety with <code class="literal">shuffle</code> and <code class="literal">Math.random</code>. We want their movement to be erratic, and we want some to<a class="indexterm" id="id733"/> move faster than others.</p><p>Add <code class="literal">components/addProjectile.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import Game from '../engine';

const addProjectile = (
  item: string,
  player: Object,
  direction: Object,
  pushProjectile: Function
) =&gt; {
  let projectile = {
    name: item,
    image: `${item}.png`,
    width: 32,
    height: 32,
    pos:{
      x: player.pos.x,
      y: player.pos.y
    },
    direction: direction,
    speed: 10
  };
  Game.createEntity(projectile);
  pushProjectile(projectile);
}
module.exports = addProjectile;</pre></div><p>This code is quite similar to the previous one, so it's worth considering whether the two files can be joined. There's a popular acronym in computer science called <span class="strong"><strong>DRY</strong></span>, which stands for <span class="strong"><strong>Don't Repeat Yourself</strong></span>. The<a class="indexterm" id="id734"/> intention is to identify code that is conceptually repetitive, such as <code class="literal">addEntity</code> and <code class="literal">addProjectile</code>, and then make an effort to make one single function.</p><p>The next file we're going to add is <code class="literal">checkCollision.js</code>. Add it with this code:</p><div class="informalexample"><pre class="programlisting">import Game from '../engine';

const checkCollision = (
  canvas,
  player,
  monster,
  cb,
  score
) =&gt; {
  const collides = Game.bruteForce(
    player, monster, 32
  );
  if(collides) {
    score();

    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "rgb(250, 250, 250)";
    ctx.font = "12px Helvetica";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("Ouch", player.pos.x, player.pos.y-24);

    cb(monster, canvas);
  }
}

module.exports = checkCollision;</pre></div><p>We'll reuse the <code class="literal">bruteForce</code><a class="indexterm" id="id735"/> collision check and display a little <span class="strong"><strong>Ouch</strong></span> over the player's entity whenever it collides with something.</p><p>Next, add <code class="literal">components/drawEntities.js</code> and add this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import Game from '../engine';
const drawEntities = (
  Config: Object,
  canvas: Object,
  entities: Object
) =&gt; {
  // Draw all entities
  Game.loadImage(
    canvas,
    Config.backgrounds.game
  );

  entities.projectiles.forEach((item)=&gt; {
    Game.drawEntity(canvas, item);
  })

  entities.monsters.forEach((monster)=&gt; {
    Game.drawEntity(canvas, monster);
  })

  entities.players.forEach((player)=&gt; {
    Game.drawEntity(canvas, player);
  })

}
module.exports = drawEntities;</pre></div><p>This is used in the game loop to draw all the entities on the screen. The order is important because the entity that is <a class="indexterm" id="id736"/>drawn first will be overlapped by the next entity that is drawn. If you draw the player first, the projectiles and the enemies will appear on top of the player in collisions.</p><p>Next, add <code class="literal">components/drawGameOver.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import Game from '../engine';

const drawGameOver = (
  canvas: Object
) =&gt; {
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "rgb(255, 255, 255)";
  ctx.font = "24px Helvetica Neue";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("Game Over", canvas.width/2, canvas.height/2-25);
}

module.exports = drawGameOver;</pre></div><p>Then add <code class="literal">components/drawGameWon.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import Game from '../engine';

const drawGameWon = (
  canvas: Object
) =&gt; {
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "rgb(255, 255, 255)";
  ctx.font = "24px Helvetica Neue";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("You won!", canvas.width/2, canvas.height/2-25);
  ctx.font = "20px Helvetica Neue";
  ctx.fillText("You can finally enjoy your picnic!", canvas.width/2, canvas.height/2);
}

module.exports = drawGameWon;</pre></div><p>They're both similar and will display different text depending on whether it's a regular game over event or whether the player has completed the game. You can add colors and use different fonts and <a class="indexterm" id="id737"/>font sizes to make the text more appealing. It works much in the same way as CSS, by cascading downwards. Notice that the second line of text in the win condition has a smaller font size than the first one and how it's arranged to make this happen.</p><p>Next, add <code class="literal">components/drawHud.js</code> and add this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import Game from '../engine';

const drawHUD= (
  canvas: Object,
  score: number = 0,
  health: number = 100
) =&gt; {
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "rgb(250, 250, 250)";
  ctx.font = "20px Helvetica Neue";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText("SCORE: " + score, 25, 25);
  ctx.textAlign = "right";
  ctx.fillText("Health: " + health, canvas.width-35, 25);
}

module.exports = drawHUD;</pre></div><p>Note that the primary difference between this and the other text functions is the positioning of the text.</p><p>Add <code class="literal">components/clearCanvas.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import Game from '../engine';

const clearCanvas = (
  canvas: Object,
  gameOverImage: ImageData
) =&gt; {
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.putImageData(gameOverImage, 0, 0);
}

module.exports = clearCanvas;</pre></div><p>This component will<a class="indexterm" id="id738"/> replace the current canvas with the provided image. We'll use a snapshot from the game just after the <code class="literal">gameOver</code> flag is set for the game over screen.</p><p>Add <code class="literal">components/outOfBunds.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
const outOfBounds = (
  item: Object = {pos: {x: 160, y: 160}},
  bounds: Object = {height: 16, width: 16},
  tileSize: number = 32
): bool =&gt; {
  if( item.pos.y&lt; -tileSize ||
      item.pos.x&lt; -tileSize ||
      item.pos.y &gt; bounds.height+tileSize ||
      item.pos.x &gt; bounds.width+tileSize
    ) {
      return true;
  }
  return false;
}
module.exports = outOfBounds;</pre></div><p>This will return <code class="literal">true</code> if an entity is outside the canvas.</p><p>Add <code class="literal">components/removeEntity.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
const removeEntity = (
  entities: Array&lt;any&gt;,
  item: Object,
  callback: Function
): Array&lt;any&gt; =&gt; {
  callback();
  return entities =
    entities.filter((p)=&gt; {
    return p.id !== item.id
  })
}
module.exports = removeEntity;</pre></div><p>This file will execute the callback before returning a filtered <code class="literal">entity</code> array. In our code, the callback either contains an empty function or a function that updates the score.</p><p>Next, add <code class="literal">components/setupGame.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import Config from '../config/index';
import Game from '../engine';

const setupGame = (
  Config: Object,
  keys: Object,
  canvas: Object,
  entities: Object,
  positions: Object
) =&gt; {
  // setup keyboard
  Game.keyboard(keys);

  entities.players.forEach((player)=&gt; {</pre></div><p>Here we add the <a class="indexterm" id="id739"/>player entities. Note that we set the position by multiplying with the tile size to set the real position on the board:</p><div class="informalexample"><pre class="programlisting">    const tilePos = player.pos;
    player.pos.x = tilePos.x * Config.tileSize;
    player.pos.y = tilePos.y * Config.tileSize;
    Game.createEntity(player);
  })
}
module.exports = setupGame;</pre></div><p>We're almost done with the <code class="literal">components</code> folder. All we need to do now is add one more file and a subfolder with a few <code class="literal">keypress</code> files.</p><div class="section" title="Responding to keyboard events"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec96"/>Responding to keyboard events</h2></div></div></div><p>First, add <a class="indexterm" id="id740"/>
<code class="literal">components/keyInput.js</code> with this code:</p><div class="informalexample"><pre class="programlisting">//@flow
import keypress from './keypress;

const keyInput = (
  Config: Object,
  keys: Object,
  player: Object,
  modifier: number = 1,
  addProjectile: Function,
  pushProjectile: Function,
  coolDown: number,
  setCoolDown: Function
) =&gt; {
  const { pos, speed } = player;
  let direction;

  const Shoot = (coolDown, setCoolDown)=&gt; {
    if(coolDown&lt;=0) {
      addProjectile(
        'fire',
        player, 
        direction,
        pushProjectile
      )
      setCoolDown();
    }
  }</pre></div><p>This function will<a class="indexterm" id="id741"/> make sure a projectile is added, but it won't do anything until the <code class="literal">coolDown</code> variable is at or below zero:</p><div class="informalexample"><pre class="programlisting">  if (keypress.up(keys)) {
    direction = {
      xVel: 0,
      yVel: -20
    }
    Shoot(coolDown, setCoolDown);
  }

  if (keypress.down(keys)) {
    direction = {
      xVel: 0,
      yVel: 20
    }
    Shoot(coolDown, setCoolDown);

  }

  if (keypress.left(keys)) {
    direction = {
      xVel: -20,
      yVel: 0
    }
    Shoot(coolDown, setCoolDown);
  }

  if (keypress.right(keys)) {
    direction = {
      xVel: 20,
      yVel: 0
    }
    Shoot(coolDown, setCoolDown);
  }

  if (keypress.w(keys)) {
    if(pos.y&gt;0) pos.y -= speed *  modifier;
  }

  if (keypress.s(keys)) {
    if(pos.y &lt; Config.height-32) pos.y += speed * modifier;
  }

  if (keypress.a(keys)) {
    if(pos.x&gt;8) pos.x -= speed * modifier;
  }

  if (keypress.d(keys)) {
    if(pos.x &lt; Config.width-32)pos.x += speed * modifier;
  }

}

module.exports = keyInput;</pre></div><p>Next, add the <code class="literal">keypress</code> folder to the <code class="literal">components</code> folder.</p><p>For each file, add the<a class="indexterm" id="id742"/> corresponding code, as illustrated here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code for <code class="literal">a.js</code> is as follows:<div class="informalexample"><pre class="programlisting">//@flow
const s = (
  keys: Object
): bool =&gt; {
  return 65 in keys;
}
module.exports = s;</pre></div></li><li class="listitem" style="list-style-type: disc">For <code class="literal">d.js</code>, refer to the following:<div class="informalexample"><pre class="programlisting">//@flow
const d = (
  keys: Object
): bool =&gt; {
  return 68 in keys;
}
module.exports = d;</pre></div></li><li class="listitem" style="list-style-type: disc">Here's the code for <code class="literal">s.js</code>:<div class="informalexample"><pre class="programlisting">//@flow
const s = (
  keys: Object
): bool =&gt; {
  return 83 in keys;
}
module.exports = s;</pre></div></li><li class="listitem" style="list-style-type: disc">For <code class="literal">w.js</code>, refer to the following:<div class="informalexample"><pre class="programlisting">//@flow
const w = (
  keys: Object
): bool =&gt; {
  return 87 in keys;
}
module.exports = w;</pre></div></li><li class="listitem" style="list-style-type: disc">The code<a class="indexterm" id="id743"/> for <code class="literal">down.js</code>:<div class="informalexample"><pre class="programlisting">//@flow
const down = (
  keys: Object
): bool =&gt; {
  return 40 in keys;
}
module.exports = down;</pre></div></li><li class="listitem" style="list-style-type: disc">For the <code class="literal">up.js</code> file:<div class="informalexample"><pre class="programlisting">//@flow
const up = (
  keys: Object
): bool =&gt; {
  return 38 in keys;
}
module.exports = up;</pre></div></li><li class="listitem" style="list-style-type: disc">We move on to the <code class="literal">left.js</code> file:<div class="informalexample"><pre class="programlisting">//@flow
const left = (
  keys: Object
): bool =&gt; {
  return 37 in keys;
}
module.exports = left;</pre></div></li><li class="listitem" style="list-style-type: disc">Now, the <code class="literal">right.js</code> file:<div class="informalexample"><pre class="programlisting">//@flow
const right = (
  keys: Object
): bool =&gt; {
  return 39 in keys;
}
module.exports = right;</pre></div></li><li class="listitem" style="list-style-type: disc">For <code class="literal">space.js</code>, refer to the following:<div class="informalexample"><pre class="programlisting">//@flow
const s = (
  keys: Object
): bool =&gt; {
  return 32 in keys;
}
module.exports = s;</pre></div></li><li class="listitem" style="list-style-type: disc">And<a class="indexterm" id="id744"/> finally, the <code class="literal">index.js</code> file:<div class="informalexample"><pre class="programlisting">import w from './w';
import s from './s';
import a from './a';
import d from './d';
import up from './up';
import down from './down';
import left from './left';
import right from './right';
import space from './space';

module.exports = {
  w,
  s,
  a,
  d,
  up,
  down,
  left,
  right,
  space
}</pre></div></li></ul></div><p>Our game is now complete and ready to be played. At the current setting, the game is probably too difficult, but <a class="indexterm" id="id745"/>with a little bit of balancing, it should be possible to make it easier for the player to win. Let's take a look at the following screenshot:</p><div class="mediaobject"><img alt="Responding to keyboard events" src="graphics/B04943_10_03.jpg"/></div></div></div>
<div class="section" title="Further improvements"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Further improvements</h1></div></div></div><p>You can improve the<a class="indexterm" id="id746"/> game in a number of ways. Here's a list of things you can add:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add sound with WebAudio</li><li class="listitem" style="list-style-type: disc">Restrict the number of fireballs the player can fire at one time, or add a limit to how many fireballs the player has and add pickups to increase that limit</li><li class="listitem" style="list-style-type: disc">Utilize resource caching to preload all assets</li><li class="listitem" style="list-style-type: disc">Sprite animation</li><li class="listitem" style="list-style-type: disc">Bonus pickups for increased playability, for instance, hearts for increasing health or new weapons for wielding more damage</li><li class="listitem" style="list-style-type: disc">Have the enemies fire at the player</li><li class="listitem" style="list-style-type: disc">Provide the reader with alternate controls (moving with arrow keys and shoot with <code class="literal">wsad</code>)</li><li class="listitem" style="list-style-type: disc">Add more screens <a class="indexterm" id="id747"/>and a better progression between levels</li><li class="listitem" style="list-style-type: disc">Add a transition effect between the levels, rewarding the player with encouraging text saying that progress has been made, and then introduce the next enemy entity</li><li class="listitem" style="list-style-type: disc">Add a possibility to pause the game</li><li class="listitem" style="list-style-type: disc">Add a fullscreen option</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec58"/>Summary</h1></div></div></div><p>You've made a game engine and a game in ReactJS. That's quite an achievement. We started using Flowtype and we optimized the way we create <code class="literal">React.js</code> projects with Webpack.</p><p>If you want to check out what we just created, visit <a class="ulink" href="https://reactjsblueprints-chapter10.herokuapp.com/">https://reactjsblueprints-chapter10.herokuapp.com/</a>.</p><p>I sincerely hope you enjoyed this chapter and the book, and I hope that by completing all these projects, you now have a solid foundation for creating your own projects in ReactJS.</p></div></body></html>