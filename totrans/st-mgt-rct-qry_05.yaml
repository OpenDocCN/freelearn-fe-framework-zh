- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: More Data-Fetching Challenges
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多数据获取挑战
- en: By now, you must be familiar with how React Query enables you to fetch data
    with the help of `useQuery`. You even learned how to deal with some common challenges
    that the server state brings you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你必须熟悉 React Query 如何通过 `useQuery` 帮助你获取数据。你甚至学习了如何处理服务器状态带来的某些常见挑战。
- en: In this chapter, you will learn how to deal with some more server state challenges.
    You will understand how you can perform parallel queries and, in the process,
    get to know a variant of your `useQuery` hook that makes it easier, called `useQueries`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何处理一些更多的服务器状态挑战。你将了解你如何执行并行查询，在这个过程中，你将了解一个使 `useQuery` 钩子更容易使用的变体，称为
    `useQueries`。
- en: You will again leverage `QueryClient` to deal with data prefetching, query invalidation,
    and query cancelation. You will even learn how to customize the methods you use
    to do these things by using some filters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将再次利用 `QueryClient` 来处理数据预取、查询无效化和查询取消。你甚至将学习如何通过使用一些过滤器来自定义你用来做这些事情的方法。
- en: '`useQuery` and even meeting another variant called `useInfiniteQuery`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`useQuery` 以及甚至另一个名为 `useInfiniteQuery` 的变体。'
- en: By the end of this chapter, you will use the Devtools once again to look inside
    your queries and enhance your debugging of them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将再次使用 Devtools 来查看你的查询，并增强对其的调试。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building parallel queries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并行查询
- en: Leveraging `QueryClient`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `QueryClient`
- en: Creating paginated queries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建分页查询
- en: Creating infinite queries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建无限查询
- en: Debugging your queries with Devtools
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Devtools 调试你的查询
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_5](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_5).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_5](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_5)。
- en: Building parallel queries
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建并行查询
- en: A typical pattern that we often find the need to use is parallel queries. Parallel
    queries are queries that are executed at the same time to avoid having sequential
    network requests, often called network waterfalls.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常发现需要使用的一个典型模式是并行查询。并行查询是指同时执行的查询，以避免有顺序的网络请求，通常称为网络瀑布。
- en: Parallel queries help you avoid network waterfalls by firing all the requests
    simultaneously.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并行查询可以帮助你通过同时发送所有请求来避免网络瀑布。
- en: 'React Query allows us to perform parallel queries in two ways:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 允许我们以两种方式执行并行查询：
- en: Manually
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动
- en: Dynamically
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态地
- en: Manual parallel queries
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动并行查询
- en: This would probably be how you would do parallel queries if I asked you to do
    it right now. It involves just writing any number of `useQuery` hooks side by
    side.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我现在要求你正确地执行并行查询，这可能是你可能会这样做的方式。它只涉及并排编写任意数量的 `useQuery` 钩子。
- en: This pattern is great when you have a fixed number of parallel queries you want
    to execute. This means that the number of queries you will perform will always
    be the same and not change.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要执行固定数量的并行查询时，这种模式非常出色。这意味着你将执行查询的数量始终相同，不会改变。
- en: 'This is how you can write parallel queries following this method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以按照这种方法编写并行查询的方式：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding snippet, we create three different queries by adding different
    query keys to all of them. These queries will all be fetched in parallel, and
    once the query function is resolved, we will have access to their data. We then
    use this data to render their `hello` property inside `p` tags.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们通过向所有这些查询添加不同的查询键来创建三个不同的查询。这些查询将并行获取，一旦查询函数解决，我们将能够访问它们的数据。然后我们使用这些数据在
    `p` 标签内渲染它们的 `hello` 属性。
- en: Dynamic parallel queries
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态并行查询
- en: While manual parallel queries fit most scenarios, if your query number varies,
    you won’t be able to use it without breaking the rules of hooks. To deal with
    this issue, React Query created a custom hook called **useQueries**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动并行查询适用于大多数场景，但如果你的查询数量变化，你将无法在不违反钩子规则的情况下使用它。为了处理这个问题，React Query 创建了一个名为
    **useQueries** 的自定义钩子。
- en: '`useQueries` allows you to dynamically call as many queries as you want. Here
    is its syntax:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`useQueries` 允许你动态地调用你想要的任意数量的查询。以下是它的语法：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see from the preceding snippet, the `useQueries` hook receives an
    array of queries in its `queries` property. These queries can even receive options
    if you want, so the mental model you should have here is that these queries can
    be customized the same way as a `useQuery` hook.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码片段所示，`useQueries`钩子在它的`queries`属性中接收一个查询数组。这些查询甚至可以接收选项，所以你应该有这样的心理模型：这些查询可以像`useQuery`钩子一样进行定制。
- en: The `useQueries` hook will return an array with all your query results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`useQueries`钩子将返回一个包含所有查询结果的数组。'
- en: 'Now that you are aware of how `useQueries` works, let’s put it to practice
    in the following snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了`useQueries`的工作原理，让我们在下面的代码片段中将其付诸实践：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding snippet, we do the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们做了以下操作：
- en: We create a `usernameList` string array to help us create some dynamic queries.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`usernameList`字符串数组来帮助我们创建一些动态查询。
- en: Inside our `useQueries` hook, for each instance inside `usernameList`, we create
    a respective query with its query key and query function.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`useQueries`钩子内部，对于`usernameList`中的每个实例，我们创建一个相应的查询，包括其查询键和查询函数。
- en: We use the result of our `useQueries` hook; for each item inside of it, we leverage
    `isFetching` to display to the user that we are fetching data. If it is not fetching
    data, then we assume we already did our request, and we show the fetched data.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`useQueries`钩子的结果；对于它内部的每个项目，我们利用`isFetching`向用户显示我们正在获取数据。如果它没有获取数据，那么我们假设我们已经完成了我们的请求，并显示获取到的数据。
- en: Now that you know how to leverage `useQuery` and `useQueries` to perform parallel
    queries, let us see how you can leverage `QueryClient` to solve some more server-state
    challenges.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何利用`useQuery`和`useQueries`来执行并行查询，让我们看看你如何利用`QueryClient`来解决一些更多的服务器状态挑战。
- en: Leveraging QueryClient
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用QueryClient
- en: As you are aware, `QueryClient` allows you to interact with your cache.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，`QueryClient`允许你与你的缓存进行交互。
- en: In the previous chapter, we saw how `QueryClient` could be leveraged to trigger
    refetching a query. What we haven’t seen yet is how `QueryClient` can be used
    for much more things.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何利用`QueryClient`来触发查询的重新获取。我们还没有看到的是`QueryClient`可以用于更多的事情。
- en: To use `QueryClient` in your components, you can leverage the `useQueryClient`
    hook to access it. Then, all you have to do is call the method you need.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的组件中使用`QueryClient`，你可以利用`useQueryClient`钩子来访问它。然后，你所要做的就是调用你需要的那个方法。
- en: 'In this section, we’ll see how you can use `QueryClient` to solve more server
    state challenges such as the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用`QueryClient`来解决更多服务器状态挑战，例如以下内容：
- en: Query invalidation
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询无效化
- en: Prefetching
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预取
- en: Query cancelation
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询取消
- en: Before we start query invalidation, one thing to be aware of is that some of
    these methods, namely the ones we are going to see, can receive certain query
    filters to help you match with the right queries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查询无效化之前，有一件事需要注意，那就是其中一些方法，即我们即将看到的方法，可以接收某些查询过滤器来帮助你匹配正确的查询。
- en: 'In the previous chapter, we saw the following example for query refetching:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了查询重新获取的以下示例：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding snippet is an example of where we can provide a filter to the
    `refetchQueries` method. In this scenario, we are trying to refetch all the queries
    that either match or start with the query key, `["api"]`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个示例，说明我们可以在`refetchQueries`方法中提供一个过滤器。在这种情况下，我们正在尝试重新获取所有匹配或以查询键`["api"]`开头的查询。
- en: 'Now, you can use more filters other than the query key. The filters that are
    used in the `QueryClient` methods, typically called `QueryFilters`, support filtering
    by things such as the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用除了查询键之外的更多过滤器。在`QueryClient`方法中使用的过滤器，通常称为`QueryFilters`，支持以下类型的过滤：
- en: Query key
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询键
- en: Query type
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询类型
- en: Whether the query is stale or fresh
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询是否过时或新鲜
- en: '`fetchStatus`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchStatus`'
- en: A predicate function
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个谓词函数
- en: Here are some examples of using `QueryFilters`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用`QueryFilters`的示例。
- en: 'In the following example, we use the `type` filter with the `active` value
    to refetch all the queries that are currently active:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用`type`过滤器与`active`值一起重新获取所有当前处于活动状态的查询：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the following example, we use the `stale` filter with `true` as a value
    to refetch all the queries whose `staleTime` has elapsed and are now considered
    stale:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用`stale`过滤器与`true`值一起重新获取所有`staleTime`已过期的查询，现在被认为是过时的：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following example, we use the `fetchStatus` filter with `idle` as a
    value to refetch all the queries that are currently not fetching anything:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用`fetchStatus`过滤器与`idle`值一起重新获取所有当前未获取任何内容的查询：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the following example, we use the `predicate` property and pass an anonymous
    function to it. This function will receive the query being verified and access
    its current status; if this status is an error, then the function will return
    `true`. This means that all queries whose status is currently an error will refetch.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用`predicate`属性并向其传递一个匿名函数。此函数将接收正在验证的查询并访问其当前状态；如果此状态是错误，则函数将返回`true`。这意味着所有当前状态为错误的查询都将重新获取。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, you don’t need to pass only one filter. You can send a combination of
    filters as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您不需要只传递一个过滤器。您可以发送以下组合的过滤器：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, we refetch all stale queries whose query key begins
    with `["api"]`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们重新获取了所有以`["api"]`开头的过时查询。
- en: 'If you don’t want to pass any filter and want the method to apply to all queries,
    you can opt not to pass any filters like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想传递任何过滤器并希望方法应用于所有查询，您可以选择不传递任何过滤器，如下所示：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example will refetch all the queries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将重新获取所有查询。
- en: You are now familiar with `QueryFilters` and can see some of the server-state
    challenges involved. Let’s start with query invalidation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在熟悉了`QueryFilters`，并可以看到其中涉及的一些服务器状态挑战。让我们从查询无效化开始。
- en: Query invalidation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询无效化
- en: Sometimes, independent of your configured `staleTime`, your data will become
    stale. Why, you ask? Well, sometimes, it might be because of mutations you have
    performed; other times, it might be because another user somewhere interacted
    with your server state.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，独立于您配置的`staleTime`，您的数据可能会变得过时。为什么，您可能会问？好吧，有时可能是因为您执行的突变；有时可能是因为其他用户在某个地方与您的服务器状态进行了交互。
- en: When this happens, you can leverage your `QueryClient` **invalidateQueries**
    method to mark your queries as stale.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，您可以使用您的`QueryClient` **invalidateQueries**方法将查询标记为过时。
- en: 'Here is the `invalidateQueries` method syntax:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`invalidateQueries`方法的语法：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By calling `invalidateQueries`, every query that matches or starts with `["api"]`
    will be marked as `stale`, overriding its `staleTime` if configured. If your query
    is active because a `useQuery` hook rendered is using it, then React Query will
    take care of refetching that query.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`invalidateQueries`，所有匹配或以`["api"]`开头的查询都将被标记为`stale`，如果已配置，则覆盖其`staleTime`。如果您的查询是活动状态，因为`useQuery`钩子渲染正在使用它，那么React
    Query将负责重新获取该查询。
- en: 'Let us now put this into practice with the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过以下示例将其付诸实践：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding snippet, we have an example of invalidating a query. This
    is what we are doing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有一个无效化查询的示例。这就是我们正在做的事情：
- en: 'Creating a query identified by the `[{ queryIdentifier: "api", username: "userOne"
    }]` query key'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个由`[{ queryIdentifier: "api", username: "userOne" }]`查询键标识的查询'
- en: Getting access to `queryClient`
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`queryClient`访问权限
- en: 'Rendering our query data and button for which `onClick` will invalidate all
    queries that match or contain `[{ queryIdentifier: "api" }]` as part of its query
    key'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '渲染我们的查询数据和按钮，其中`onClick`将使所有匹配或包含查询键的一部分`[{ queryIdentifier: "api" }]`的查询无效'
- en: 'When the user clicks on the `[{ queryIdentifier: "api" }]` as part of its query
    key, that query data will be marked immediately as `stale`. Since this query is
    being rendered now, it will automatically be refetched in the background.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '当用户点击查询键的一部分`[{ queryIdentifier: "api" }]`时，该查询数据将立即被标记为`stale`。由于此查询正在渲染中，它将自动在后台重新获取。'
- en: Prefetching
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预取
- en: You want your user experience to be the best possible one. This sometimes involves
    understanding what the users want even before they do. This is where prefetching
    can help you.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望用户获得最佳的用户体验。这有时意味着在用户意识到之前就了解他们的需求。这正是预取可以帮助您的地方。
- en: When you can predict that your user might want to do something that inevitably
    triggers a query, you can leverage that knowledge and prefetch your query to save
    some future time for your users.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您可以预测用户可能想要执行的操作，这不可避免地触发查询时，您可以利用这些知识并预取查询以节省用户未来的时间。
- en: '`QueryClient` allows you to access a method called **prefetchQuery** to prefetch
    your data.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryClient`允许您访问一个名为**prefetchQuery**的方法来预取您的数据。'
- en: 'Here is the `prefetchQuery` method syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`prefetchQuery`方法的语法：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`prefetchQuery` requires a query key and query function. This method will try
    to fetch your data and cache it under the given query key. *This is an asynchronous
    method*; therefore, you will need to wait for it to complete.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefetchQuery`需要一个查询键和一个查询函数。这个方法将尝试获取你的数据并将其缓存到给定的查询键下。*这是一个异步方法*；因此，你需要等待它完成。'
- en: 'Let us now see a practical example of when we can prefetch our data with our
    `ExamplePrefetching` component:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个使用我们的`ExamplePrefetching`组件进行数据预取的实际例子：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding snippet, we create our `ExamplePrefetching` component. Here
    is what it does:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了我们的`ExamplePrefetching`组件。以下是它的作用：
- en: It creates a state variable that will be used to allow us to render `PrefetchedDataComponent`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个状态变量，我们将使用它来允许我们渲染`PrefetchedDataComponent`。
- en: It gets access to `queryClient`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以访问`queryClient`。
- en: 'It creates a function called `prefetchData` where we call the `prefetchQuery`
    method and cache the returned data under the `[{ queryIdentifier: "api", username:
    "userOne" }]` query key. We also give it a `staleTime` of 1 minute, so after calling
    this query, the data will be considered fresh for 1 minute.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它创建了一个名为`prefetchData`的函数，我们在其中调用`prefetchQuery`方法并将返回的数据缓存到`[{ queryIdentifier:
    "api", username: "userOne" }]`查询键下。我们还给它一个`staleTime`为1分钟，所以调用这个查询后，数据将被认为在1分钟内是新鲜的。'
- en: Create a button that, when clicked, will change our state variable to allow
    us to render `PrefetchedDataComponent`. This button also has an `onMouseEnter`
    event that will trigger our data prefetching.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按钮，当点击时，将改变我们的状态变量以允许我们渲染`PrefetchedDataComponent`。此按钮还有一个`onMouseEnter`事件，它将触发我们的数据预取。
- en: 'Let us now look at our `PrefetchedDataComponent` component:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下我们的`PrefetchedDataComponent`组件：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding snippet, we can see `PrefetchedDataComponent`. This component
    has a query that is identified by the `[{ queryIdentifier: "api", username: "userOne"
    }]` query key. When this data exists, it will be rendered inside `div`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码片段中，我们可以看到`PrefetchedDataComponent`。这个组件有一个由`[{ queryIdentifier: "api",
    username: "userOne" }]`查询键标识的查询。当这些数据存在时，它将被渲染在`div`内部。'
- en: 'So, let’s review the flow of these two components for a user:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾一下这两个组件的用户流程：
- en: '`ExamplePrefetching` is rendered.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExamplePrefetching`被渲染。'
- en: The user will see a button saying **Render Component**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将看到一个写着**渲染组件**的按钮。
- en: 'The user puts their mouse over the button to click on it. At this time, we
    predict that the user will click on the button, so we trigger the data prefetching.
    Once the data has been prefetched, it is cached under the `[{ queryIdentifier:
    "api", username: "userOne" }]` query key.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '用户将鼠标放在按钮上准备点击。此时，我们预测用户将点击按钮，因此我们触发数据预取。一旦数据被预取，它就会被缓存到`[{ queryIdentifier:
    "api", username: "userOne" }]`查询键下。'
- en: The user clicks on the button.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击按钮。
- en: '`PrefetchedDataComponent` is rendered.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PrefetchedDataComponent`被渲染。'
- en: 'The `useQuery` hook that is identified by the `[{ queryIdentifier: "api", username:
    "userOne" }]` query key will already have the data cached and marked as fresh
    for one minute, so it doesn’t need to trigger data-fetching.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '由`[{ queryIdentifier: "api", username: "userOne" }]`查询键标识的`useQuery`钩子已经将数据缓存并标记为在一分钟内是新鲜的，因此不需要触发数据获取。'
- en: The user sees the prefetched data rendered.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户看到预取的数据被渲染。
- en: Query cancelation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询取消
- en: There will be times when your `useQuery` hook will unmount while it is doing
    a query. By default, once your promise has been resolved, this query data will
    still be received and cached. But, for some reason, you might want to cancel your
    queries if your hook unmounts in the middle of data-fetching requests. React Query
    can take care of this by automatically canceling your query if you desire. You
    can even cancel your queries manually if you want.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你的`useQuery`钩子在查询过程中卸载时，你的查询可能会被卸载。默认情况下，一旦你的承诺被解决，这个查询数据仍然会被接收并缓存。但是，出于某种原因，你可能希望在数据获取请求进行到一半时取消你的查询。React
    Query可以通过自动取消你的查询来处理这个问题。你也可以手动取消你的查询。
- en: To allow you to cancel your queries, React Query uses a signal that can communicate
    with DOM requests and abort them. This signal is the **AbortSignal** object, which
    belongs to the **AbortController** Web API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许你取消你的查询，React Query使用一个可以与DOM请求通信并中止它们的信号。这个信号是**AbortSignal**对象，它属于**AbortController**
    Web API。
- en: The `AbortSignal` signal is injected into our query function by `QueryFunctionContext`,
    and then it should be consumed by our data-fetching client.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbortSignal`信号通过`QueryFunctionContext`注入到我们的查询函数中，然后它应该被我们的数据获取客户端消耗。'
- en: 'Here is how we can leverage `AbortSignal` with `axios`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以如何利用 `AbortSignal` 与 `axios`：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, we receive `signal` from `QueryFunctionContext` and
    pass it as an option in our `axios` client while doing a `get` request.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段中，我们从 `QueryFunctionContext` 接收 `signal` 并将其作为选项在我们的 `axios` 客户端进行 `get`
    请求时传递。
- en: If you use an alternative to `axios` such as `fetch` or `graphql-request` in
    a scenario in which you use GraphQL, you also need to pass `AbortSignal` to your
    client.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个使用 GraphQL 的场景中使用 `axios` 的替代品，例如 `fetch` 或 `graphql-request`，你也需要将 `AbortSignal`
    传递给你的客户端。
- en: 'This is how you can do it using `fetch`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以使用 `fetch` 来做到这一点的方式：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we receive `signal` from `QueryFunctionContext` and
    pass it as an option to our `fetch` call.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段中，我们从 `QueryFunctionContext` 接收 `signal` 并将其作为选项传递给我们的 `fetch` 调用。
- en: 'If you are using a GraphQL client such as `graphql-request`, this is how you
    can do it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `graphql-request` 这样的 GraphQL 客户端，这是你可以做到这一点的方式：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding snippet, we also receive `signal` from `QueryFunctionContext`
    and pass it as an option in our client request.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段中，我们也从 `QueryFunctionContext` 接收 `signal` 并将其作为选项传递给我们的客户端请求。
- en: Passing the signal to our clients is only the first step in allowing them to
    cancel queries. You need to trigger an automatic query cancelation or a manual
    one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将信号传递给我们的客户端只是允许他们取消查询的第一步。你需要触发自动查询取消或手动取消。
- en: Manual cancelation
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动取消
- en: For manually canceling a query, `QueryClient` gives you access to the **cancelQueries**
    method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于手动取消查询，`QueryClient` 提供了访问 `**cancelQueries**` 方法的权限。
- en: 'Here is the `cancelQueries` method syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `cancelQueries` 方法的语法：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By calling `cancelQueries`, every query that matches or starts with `["api"]`
    that is currently fetching and that has received `AbortSignal` will be aborted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `cancelQueries`，所有匹配或以 `["api"]` 开头的当前正在获取且已接收 `AbortSignal` 的查询都将被中止。
- en: Automatic cancelation
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动取消
- en: When a component using your hook unmounts and your query is currently fetching,
    if you pass `AbortSignal` to your client, React Query will abort your query by
    canceling the promise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用你的钩子的组件卸载且你的查询正在获取数据时，如果你向客户端传递 `AbortSignal`，React Query 将通过取消承诺来中止你的查询。
- en: 'Let us see how React Query leverages `AbortSignal` to cancel your query with
    the next examples. First, we start by configuring our query function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 React Query 如何通过以下示例利用 `AbortSignal` 来取消你的查询。首先，我们开始配置我们的查询函数：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding snippet, we create a `fetchData` function that will receive
    `QueryContextObject`. From it, we get access to `signal` and pass it to our `axios`
    client.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段中，我们创建了一个 `fetchData` 函数，该函数将接收 `QueryContextObject`。从中，我们获取对 `signal`
    的访问权限并将其传递给我们的 `axios` 客户端。
- en: 'Now, let us see our components:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的组件：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding snippet, we have a component called `ExampleQueryCancelation`.
    This component will render and unmount a component called `QueryCancelation` wherever
    a user clicks on a button.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段中，我们有一个名为 `ExampleQueryCancelation` 的组件。这个组件将在用户点击按钮的任何地方渲染和卸载一个名为 `QueryCancelation`
    的组件。
- en: 'Let’s now see the `QueryCancelation` component:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 `QueryCancelation` 组件：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The snippet shows us the `QueryCancelation` component. In this component, we
    are doing the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 段落显示了 `QueryCancelation` 组件。在这个组件中，我们做以下操作：
- en: 'We create a query identified by the `[{ queryIdentifier: "api", username: "userOne"
    }]` query key.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们创建了一个由 `[{ queryIdentifier: "api", username: "userOne" }]` 查询键标识的查询。'
- en: We get access to `QueryClient`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取对 `QueryClient` 的访问权限。
- en: We render our `data` from the query.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从查询中渲染我们的 `data`。
- en: 'We render a button that, when clicked, will use `QueryClient` to cancel all
    the queries that either match or include `[{ queryIdentifier: "api" }]` in their
    keys.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们渲染一个按钮，当点击时，将使用 `QueryClient` 取消所有匹配或包含其键中的 `[{"queryIdentifier": "api"}]`
    的查询。'
- en: 'Let us now review these components’ lifetimes and how the query cancelation
    can work out:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在回顾这些组件的生命周期以及查询取消如何运作：
- en: We render the `ExampleQueryCancelation` component.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们渲染 `ExampleQueryCancelation` 组件。
- en: We click the button to render the `QueryCancelation` component.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击按钮以渲染 `QueryCancelation` 组件。
- en: '`QueryCancelation` is rendered and its `useQuery` hook will trigger a request
    to fetch its data.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QueryCancelation` 被渲染，其 `useQuery` 钩子将触发一个请求以获取其数据。'
- en: During this request, we click right back on the button to render `QueryCancelation`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个请求期间，我们再次点击按钮以渲染 `QueryCancelation`。
- en: Since our request hasn’t been resolved yet and our component is unmounted, React
    Query will abort our signal, which will cancel our request.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的请求尚未解决且我们的组件已卸载，React Query 将中止我们的信号，这将取消我们的请求。
- en: We click the button to render the `QueryCancelation` component again.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击按钮再次渲染`QueryCancelation`组件。
- en: '`QueryCancelation` is rendered, and its `useQuery` hook will trigger a request
    to fetch its data.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QueryCancelation`被渲染，其`useQuery`钩子将触发一个请求来获取其数据。'
- en: During this request, we click on the button to cancel our query. This will force
    React Query to abort our signal and cancel our request once again.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这次请求过程中，我们点击按钮取消我们的查询。这将强制React Query终止我们的信号并再次取消我们的请求。
- en: We have thus seen how `QueryClient` and some of its methods can help us solve
    some of our common server state challenges.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了`QueryClient`及其一些方法如何帮助我们解决一些常见的服务器状态挑战。
- en: In the next section, we’ll see how React Query allows us to build a common UI
    pattern, that is, paginated queries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到React Query如何允许我们构建一个常见的UI模式，即分页查询。
- en: Creating paginated queries
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分页查询
- en: When building an API to deal with large datasets, to avoid having your frontend
    deal with everything at once, you don’t want to send all the available data in
    one request. A pattern often used to make this easier is API pagination.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个处理大量数据的API时，为了避免你的前端一次性处理所有内容，你不想在一个请求中发送所有可用的数据。一种常用的模式是API分页。
- en: If your API is paginated, you want to apply the same pattern to your application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的API是分页的，你希望将相同的模式应用到你的应用程序中。
- en: The good thing is that you only need to use `useQuery` and one of its options,
    `keepPreviousData`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于，你只需要使用`useQuery`及其一个选项，`keepPreviousData`。
- en: 'Let’s look at the next examples and then understand how pagination and React
    Query work. First, we start with our query function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看接下来的示例，然后了解分页和React Query是如何工作的。首先，我们从我们的查询函数开始：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding snippet, we create the function that will be used as our query
    function. Since this is a paginated API, we will need the `page` to fetch our
    data. As we established in the last chapter, if a variable is a dependency of
    our query, it needs to be added to the query key. We then destructure the `page`
    from our query key in our query function. Then, all we need to do is fetch our
    data and return it when the promise resolves.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个将用作查询函数的函数。由于这是一个分页API，我们需要`page`来获取我们的数据。正如我们在上一章中建立的，如果变量是查询的依赖项，则需要将其添加到查询键中。然后，我们在查询函数中从查询键中解构`page`。然后，我们只需要获取我们的数据，并在承诺解决时返回它。
- en: 'Let us now see how we can build a component for displaying and fetching paginated
    data:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何构建一个用于显示和获取分页数据的组件：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s recap in order what is happening in the preceding code block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面代码块中发生的事情：
- en: We create a state variable to hold our current selected `page`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个状态变量来保存我们当前选中的`page`。
- en: 'We create our query, which has the `[{ queryIdentifier: "api", page }]` query
    key, our `fetchData` function as the query function, and set `keepPreviousData`
    to `true`. We set this option as `true` because, by default, whenever our query
    key changes, so will the query data; now, because we have a paginated API, we
    want to keep showing our data even if we change pages.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们创建我们的查询，它具有`[{ queryIdentifier: "api", page }]`查询键，我们的`fetchData`函数作为查询函数，并将`keepPreviousData`设置为`true`。我们将此选项设置为`true`是因为，默认情况下，每当我们的查询键更改时，查询数据也会更改；现在，由于我们有一个分页API，我们希望即使在更改页面时也能继续显示我们的数据。'
- en: We then destructure `isLoading`, `isError`, `error`, `data`, `isFetching`, and
    `isPreviousData`. `isPreviousData` is used to indicate whether the data currently
    being shown is the previous version.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们解构`isLoading`、`isError`、`error`、`data`、`isFetching`和`isPreviousData`。`isPreviousData`用于指示当前显示的数据是否是上一个版本。
- en: We then have two `if` statements to show when our query is loading, or when
    there is an error.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有两个`if`语句来显示我们的查询何时正在加载，或者何时出现错误。
- en: If we have data, we display it and two buttons to move to the next and the previous
    page. The button to move to the next page leverages `isPreviousData` to make sure
    it is disabled after we click it and move to the following query. We also display
    a fetching indicator.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有数据，我们显示它，并有两个按钮用于移动到下一页和上一页。用于移动到下一页的按钮利用`isPreviousData`确保我们在点击并移动到后续查询后将其禁用。我们还显示一个获取指示器。
- en: 'Now that we have seen how the code is structured, let’s see how it behaves
    when interacted with:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了代码的结构，让我们看看当与之交互时的行为：
- en: Our component is rendered, and the first page starts to be fetched.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的组件被渲染，第一页开始被获取。
- en: The `isLoading` property is set as `true`, so we render `Loading` `initial data`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`isLoading`属性被设置为`true`，因此我们渲染`Loading`和`initial data`。'
- en: The data for the first page is resolved, so we display it.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一页的数据已解析，因此我们显示它。
- en: We click on the `page` value is incremented.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击 `page` 值会增加。
- en: The query key changes, so the following query starts fetching.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询键发生变化，因此接下来的查询开始获取。
- en: Since we have `keepPreviousData` as `true`, we will still display the old data.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将 `keepPreviousData` 设置为 `true`，我们仍然会显示旧数据。
- en: Since we are displaying old data, `isPreviousData` is set to `true`, and the
    `Loading`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在显示旧数据，`isPreviousData` 被设置为 `true`，并且显示 `Loading`。
- en: We get the new data and display it.*   We click on the `Loading`.*   The new
    data is received and displayed.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获取新数据并显示它。*   我们点击 `Loading`。*   新数据被接收并显示。
- en: As you can see, all you need is a new option and the same old `useQuery` hook
    to enable you to build an application using pagination.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您只需要一个新的选项和相同的旧 `useQuery` 钩子，就可以构建一个使用分页的应用程序。
- en: For the next section, let’s see now how we can build infinite queries.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看如何构建无限查询。
- en: Creating infinite queries
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建无限查询
- en: Another very common UI pattern is building an infinite scroll component. In
    this pattern, we are presented with a list that allows us to load more data as
    we scroll down.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的 UI 模式是构建无限滚动组件。在这个模式中，我们看到一个列表，允许我们在向下滚动时加载更多数据。
- en: To deal with these types of lists, React Query has an alternative to the `useQuery`
    hook, which is another custom hook called **useInfiniteQuery**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些类型的列表，React Query 提供了 `useQuery` 钩子的一个替代品，这是一个名为 **useInfiniteQuery**
    的自定义钩子。
- en: 'Using the `useInfiniteQuery` hook has many similarities to the `useQuery` one,
    but some things differ that we need to be aware of:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useInfiniteQuery` 钩子与 `useQuery` 钩子有很多相似之处，但也有一些不同之处，我们需要注意：
- en: 'Your data is now an object that contains the following:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的数据现在是一个包含以下内容的对象：
- en: The fetched pages
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取的页面
- en: The `page` parameters that were used to fetch the pages
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于获取页面的 `page` 参数
- en: A function called `fetchNextPage` to fetch the next page
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `fetchNextPage` 的函数，用来获取下一页
- en: A function called `fetchPreviousPage` to fetch the previous page
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `fetchPreviousPage` 的函数，用来获取上一页
- en: A Boolean state called `isFetchingNextPage` to indicate that the next page is
    being fetched
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `isFetchingNextPage` 的布尔状态，用来指示下一页正在被获取
- en: A Boolean state called `isFetchingPreviousPage` to indicate that the next page
    is being fetched
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `isFetchingPreviousPage` 的布尔状态，用来指示下一页正在被获取
- en: A Boolean state called `hasNextPage` to indicate whether the list has a next
    page
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `hasNextPage` 的布尔状态，用来指示列表是否有下一页
- en: A Boolean state called `hasPreviousPage` to indicate whether the list has a
    previous page
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `hasPreviousPage` 的布尔状态，用来指示列表是否有上一页
- en: These last two Boolean values depend on two options that can be passed to the
    hook. Respectively, they are `getNextPageParam` and `getPreviousPageParam`. The
    functions will be responsible for picking the last or first page in the cache
    and checking whether its data indicates the next or previous page to be fetched.
    If these values exist, then the respective Boolean values will be `true`. If they
    return undefined, then the Boolean values will be `false`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后两个布尔值取决于可以传递给钩子的两个选项。分别是 `getNextPageParam` 和 `getPreviousPageParam`。这些函数将负责选择缓存中的最后一页或第一页，并检查其数据是否指示要获取下一页或上一页。如果这些值存在，则相应的布尔值将为
    `true`。如果它们返回 `undefined`，则布尔值将为 `false`。
- en: 'To use the `useInfiniteQuery` hook, you need to import it this way:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `useInfiniteQuery` 钩子，您需要以这种方式导入它：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let us now see an example of how to use the `useInfiniteQuery` hook to build
    an infinite list:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用 `useInfiniteQuery` 钩子构建一个无限列表的示例：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding snippet, we set up the function to be used as the infinite
    query function. The hook will pass `pageParam` in `QueryFunctionContext` so that
    we can leverage it to fetch our data. Like the query function in the `useQuery`
    hook, this query function needs to either resolve the data or throw an error,
    so all the same principles learned previously apply.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们设置了用作无限查询函数的函数。钩子将传递 `pageParam` 到 `QueryFunctionContext`，这样我们就可以利用它来获取我们的数据。像
    `useQuery` 钩子中的查询函数一样，这个查询函数需要解决数据或抛出错误，因此所有之前学到的原则都适用。
- en: 'The next snippet will show us our `InfiniteScroll` component:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段将展示我们的 `InfiniteScroll` 组件：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding snippet, we have a component that renders an infinite list.
    This is what we are doing in the component:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有一个渲染无限列表的组件。这就是我们在组件中做的事情：
- en: We create `useInfiniteQuery`, which has `["api"]` as the query key and `fetchData`
    as the query function. It also receives an anonymous function in the `getNextPageParam`
    option to check whether there is still more data to be loaded on the next page.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建`useInfiniteQuery`，它以`["api"]`作为查询键和`fetchData`作为查询函数。它还接收一个匿名函数在`getNextPageParam`选项中，以检查下一页是否还有更多数据要加载。
- en: We also destructure from the hook some variables needed to build our application.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还从钩子中解构出构建我们的应用程序所需的某些变量。
- en: We then have two `if` statements to show when our query is loading, or when
    there is an error.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们有两个`if`语句来显示我们的查询正在加载或存在错误时的情况。
- en: When we have data, we map the content inside its `page` properties to render
    our list.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们有数据时，我们将其`page`属性内的内容映射以渲染我们的列表。
- en: 'We also render a button that will be disabled if we don’t have the next page
    or when we are currently fetching the next page. When clicked, this button will
    fetch more data. This button message will also depend on some constraints:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还渲染了一个按钮，如果我们没有下一页或我们正在获取下一页时，该按钮将被禁用。当点击时，此按钮将获取更多数据。此按钮消息也将取决于一些约束：
- en: If we are fetching, the next page will show a `Loading` message
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在获取数据，下一页将显示一个`加载`消息
- en: If we have the next page, it will show `Load more` so the user can click it
    to start fetching
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有下一页，它将显示`加载更多`，以便用户可以点击它开始获取
- en: If there is no more data to fetch, it will show a message letting the user know
    there is no more data
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有更多数据可以获取，它将显示一条消息，告知用户没有更多数据
- en: 'As we just reviewed how the component is built, let us see how it will work
    when interacting with it:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚回顾了组件的构建方式，让我们看看它与交互时的表现：
- en: 'Our component renders, and the first page of the list is automatically fetched:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的组件渲染，列表的第一页将自动获取：
- en: The `isLoading` property is set to `true`, so we render `Loading` `initial data`
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading`属性设置为`true`，所以我们渲染`加载` `初始数据`'
- en: The data for the first page of the list is resolved, so we display it.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表的第一页数据已解析，所以我们显示它。
- en: At the same time, the `getNextPageParam` function checks whether we have more
    data on the list.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，`getNextPageParam`函数检查列表中是否有更多数据。
- en: If there is no more data, the `hasNextPage` property is set to `false` and the
    button for fetching more data is disabled and displays **You have no** **more
    data**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有更多数据，`hasNextPage`属性设置为`false`，获取更多数据的按钮被禁用并显示**您没有** **更多数据**。
- en: If there is more data, the `hasNextPage` property is set to `true`, and the
    user can click the button to fetch more data.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有更多数据，`hasNextPage`属性设置为`true`，用户可以点击按钮来获取更多数据。
- en: 'If the user clicks the button, we see the following:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户点击按钮，我们将看到以下内容：
- en: The next page starts fetching.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一页开始获取。
- en: The `isFetchingNextPage` value becomes `true`.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isFetchingNextPage`的值变为`true`。'
- en: The button is disabled and displays the loading message.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮被禁用并显示加载消息。
- en: The data is resolved, and our data `pages` property length increases as it has
    the data for the new page. *Steps 3, 4,* and *5* are repeated.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据已解析，并且我们的数据`pages`属性长度增加，因为它包含了新页面的数据。*步骤3、4、*和*5*被重复。
- en: With this, we just saw how the `useQuery` variant called `useInfiniteQuery`
    allows us to build an infinite list straightforwardly.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们刚刚看到了`useQuery`变体`useInfiniteQuery`如何让我们直接构建无限列表。
- en: Before we wrap up this chapter, let’s finally see how we can use the React Query
    Devtools to help us debug our code and see how our queries behave.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，让我们最后看看我们如何使用React Query Devtools来帮助我们调试代码并查看我们的查询行为。
- en: Debugging your queries with Devtools
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Devtools调试查询
- en: In [*Chapter 3*](B18501_03.xhtml#_idTextAnchor062), you learned about React
    Query Devtools. At that point, you didn’t know how to use queries yet, so we could
    not see it working. Well, now we can.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18501_03.xhtml#_idTextAnchor062)中，你学习了关于React Query Devtools的内容。在那个阶段，你还不知道如何使用查询，所以我们无法看到它的工作情况。现在我们可以了。
- en: For the images you are going to see next, we are going to leverage the code
    we wrote when showing you the `useQueries` hook example in the *Dynamic parallel*
    *queries* section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你接下来要看到的图像，我们将利用我们在*动态并行* *查询*部分向你展示`useQueries`钩子示例时编写的代码。
- en: 'So that you remember, here is the code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您记住，这里是有代码：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When using that code and checking our page, this is what the Devtools will
    present us with:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用该代码并检查我们的页面时，Devtools将向我们展示以下内容：
- en: '![Figure 5.1 – React Query Devtools after parallel queries are executed](img/Figure_5.1_B18501.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 执行并行查询后的React Query Devtools](img/Figure_5.1_B18501.jpg)'
- en: Figure 5.1 – React Query Devtools after parallel queries are executed
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see the following things:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: We have three queries
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of the queries is identified by the respective query key
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the queries are currently stale
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have selected the query identified with the `[{ queryIdentifier: "api",
    username: "userThree" }]` query key'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we select a query, we can see the query details in our **Query** **Details**
    tab.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that this query is identified by its query
    key and its status.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrolling down on the **Query Details** tab, we are also able to see the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – React Query Devtools Query Details tab displaying Actions and
    Data Explorer](img/Figure_5.2_B18501.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – React Query Devtools Query Details tab displaying Actions and Data
    Explorer
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that we can perform several actions for
    the selected query, such as refetching, invalidating, resetting, and removing
    it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: We are also able to see the current data of this query.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrolling even further down our **Query Details** tab, we can also check **Query
    Explorer**:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – React Query Devtools Query Details tab displaying Query Explorer](img/Figure_5.3_B18501.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – React Query Devtools Query Details tab displaying Query Explorer
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see `cacheTime` of `300000`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: You are now aware of what you can see in the Devtools for each selected query.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Before wrapping up this section, let’s just see what happens when we click
    on one of the buttons available in the **Query** **Details** actions:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – React Query Devtools currently fetching a query](img/Figure_5.4_B18501.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – React Query Devtools currently fetching a query
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we clicked on the `[{ queryIdentifier: "api", username:
    "userTwo" }]` query key.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: As you remember from learning about query invalidation, when we invalidate a
    query, it is automatically marked as `stale`, and if the query is currently being
    rendered, it will automatically be refetched. As you can see from the figure,
    this is what happened. Our query was already stale, so there was no need to mark
    it as `stale` again, but as it was currently being rendered on our page, React
    Query took care of refetching it, and we can see that in the figure.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: As you saw from this section, the Devtools can save you a lot of time debugging
    your queries. By looking inside your queries, you can check what their data looks
    like if you have configured the right options, and even trigger some actions if
    you so desire.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned more about using the `useQuery` hook to solve some
    common challenges we are presented with when dealing with the server state. By
    now, you can handle all your data fetching needs and do it easily.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned about parallel queries and learned you could manually build these
    queries with `useQuery`. You were also introduced to one alternative of the `useQuery`
    hook: `useQueries`. With it, you learned how to build dynamic parallel queries.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了并行查询，并了解到你可以使用`useQuery`手动构建这些查询。你还被介绍到`useQuery`钩子的一种替代方案：`useQueries`。通过它，你学习了如何构建动态并行查询。
- en: You got to learn more about some methods of `QueryClient` that allow you to
    prefetch, cancel, and invalidate queries and also understood how you can leverage
    `QueryFilters` to customize the query matching used in these methods.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要更多地了解一些`QueryClient`的方法，这些方法允许你预取、取消和使查询无效，并且你也理解了如何利用`QueryFilters`来自定义这些方法中使用的查询匹配。
- en: Pagination is a typical UI pattern, and now you know that you can easily build
    a paginated component with the help of `useQuery` and one of its options.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是一个典型的UI模式，现在你知道你可以借助`useQuery`及其一个选项轻松构建分页组件。
- en: Another typical UI pattern is infinite scrolling. With the help of another `useQuery`
    variant called `useInfiniteQuery`, you learned how React Query enables you to
    build an application with an infinite list.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个典型的UI模式是无限滚动。借助另一个名为`useInfiniteQuery`的`useQuery`变体，你学习了React Query如何让你构建一个具有无限列表的应用程序。
- en: Finally, you looked inside your queries with the React Query Devtools and understood
    how it allows you to debug them and improve your development process.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用React Query Devtools检查了你的查询，并理解了它如何允许你调试它们并改进你的开发过程。
- en: In [*Chapter 6*](B18501_06.xhtml#_idTextAnchor159), *Performing Data Mutations
    with React Query*, we’ll leave data fetching behind and move on to mutations.
    You’ll understand how React Query enables you to perform mutations with the help
    of one of its custom hooks called `useMutation`. You will also leverage this hook
    to deal with more common server-state challenges you find in your applications
    and start building a better user experience in your apps by using optimistic updates.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18501_06.xhtml#_idTextAnchor159)，*使用React Query执行数据突变*中，我们将放下数据获取，转向突变。你将理解React
    Query如何通过其名为`useMutation`的自定义钩子帮助你执行突变。你还将利用这个钩子来处理你在应用程序中遇到的更常见的服务器状态挑战，并通过使用乐观更新来开始构建更好的用户体验。
