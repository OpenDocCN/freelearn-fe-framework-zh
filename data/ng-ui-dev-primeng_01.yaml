- en: Getting Started with Angular and PrimeNG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Angular和PrimeNG
- en: This book presupposes some basic knowledge of TypeScript and Angular 2\. Anyway,
    we would like to give the readers an overview of the most important TypeScript
    and Angular key concepts used in this book. We will summarize TypeScript and Angular
    features and present them in understandable, simple, but deeply explained portions.
    At the time of writing the book, the current TypeScript and Angular Versions are
    2.3.x and 4.2.x, respectively. Readers will also meet the PrimeNG UI library for
    the first time and gain experience with project setups in three various ways.
    At the end of this chapter, readers will be able to run the first Angular- and
    PrimeNG-based web application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假定读者具有一些TypeScript和Angular 2的基本知识。无论如何，我们希望向读者概述本书中使用的最重要的TypeScript和Angular关键概念。我们将总结TypeScript和Angular的特性，并以可理解、简单但深入解释的方式呈现它们。撰写本书时，当前的TypeScript和Angular版本分别为2.3.x和4.2.x。读者还将首次接触PrimeNG
    UI库，并通过三种不同的方式获得项目设置经验。在本章结束时，读者将能够运行第一个基于Angular和PrimeNG的Web应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: TypeScript fundamentals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript基础知识
- en: Advanced types, decorators, and compiler options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级类型、装饰器和编译器选项
- en: Angular cheat sheet - overview of key concepts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular速查表-关键概念概述
- en: Angular modularity and lifecycle hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的模块化和生命周期钩子
- en: Running PrimeNG with SystemJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SystemJS运行PrimeNG
- en: Setting up PrimeNG project with Webpack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webpack设置PrimeNG项目
- en: Setting up PrimeNG project with Angular CLI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CLI设置PrimeNG项目
- en: TypeScript fundamentals
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript基础知识
- en: Angular 2 and higher is built with features of ECMAScript 2015/2016 and TypeScript.
    The new ECMAScript standards target evergreen browsers and helps to write more
    powerful, clean, and concise code. You can also use these features in any other
    less modern browsers with Polyfills such as `core-js` ([https://github.com/zloirock/core-js](https://github.com/zloirock/core-js)).
    But, why do we need to use TypeScript?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2及更高版本使用了ECMAScript 2015/2016和TypeScript的功能。新的ECMAScript标准针对现代浏览器，并有助于编写更强大、干净和简洁的代码。您还可以在任何其他不太现代的浏览器中使用这些功能，例如`core-js`（[https://github.com/zloirock/core-js](https://github.com/zloirock/core-js)）等Polyfills。但是，为什么我们需要使用TypeScript呢？
- en: 'TypeScript ([http://www.typescriptlang.org](http://www.typescriptlang.org))
    is a typed language and a super set of JavaScript developed by Microsoft. One
    can say that TypeScript is an advanced JavaScript with optional static typing.
    TypeScript code is not processed by browsers, it has to be translated into JavaScript
    by means of a TypeScript compiler. This translation is called *compilation* or
    *transpilation*. The TypeScript compiler transpiles `.ts` files into `.js` files.
    The main advantages of TypeScript are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript（[http://www.typescriptlang.org](http://www.typescriptlang.org)）是由微软开发的一种带类型的语言，也是JavaScript的超集。可以说TypeScript是一种带有可选静态类型的高级JavaScript。TypeScript代码不会被浏览器处理，而是需要通过TypeScript编译器将其转换为JavaScript。这种转换被称为*编译*或*转译*。TypeScript编译器将`.ts`文件转译为`.js`文件。TypeScript的主要优点如下：
- en: Types help you find and fix a lot of errors during development time. That means,
    you have less errors at runtime.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型有助于在开发过程中找到并修复许多错误。这意味着在运行时会有更少的错误。
- en: Many modern ECMAScript features are supported out of the box. More features
    are expected according to the roadmap ([https://github.com/Microsoft/TypeScript/wiki/Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多现代ECMAScript功能都被原生支持。根据路线图，预计会有更多功能被支持（[https://github.com/Microsoft/TypeScript/wiki/Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)）。
- en: Great tooling and IDE support with IntelliSense makes the coding a pleasure.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出色的工具和IDE支持使编码成为一种愉悦。
- en: It is easier to maintain and refactor a TypeScript application than one written
    in untyped JavaScript.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护和重构TypeScript应用比使用无类型的JavaScript编写的应用更容易。
- en: Developers feel comfortable with TypeScript due to object-oriented programming
    patterns, such as interfaces, classes, enums, generics, and so on.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员喜欢TypeScript，因为它支持面向对象的编程模式，如接口、类、枚举、泛型等。
- en: Last but not least, Angular 2+ and PrimeNG are written in TypeScript.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，Angular 2+和PrimeNG都是用TypeScript编写的。
- en: 'It is also important to keep the following points in mind:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住以下几点很重要：
- en: The Typescript Language Specification says, *<q>every JavaScript program is
    also a TypeScript program</q>*. Hence, a migration from JavaScript to TypeScript
    code is easily done.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript语言规范表示，*<q>每个JavaScript程序也是一个TypeScript程序</q>*。因此，从JavaScript迁移到TypeScript代码很容易。
- en: TypeScript compiler emits output even when any errors are reported. In the next
    section, *Advanced types, decorators, and compiler options*, we will see how we
    can forbid emitting JavaScript on errors.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使报告了任何错误，TypeScript编译器也会生成输出。在下一节*高级类型、装饰器和编译器选项*中，我们将看到如何在出现错误时禁止生成JavaScript。
- en: 'What is the best way to learn the TypeScript language? There is an official
    handbook on the TypeScript''s homepage, which is aligned with the last released
    version. Hands-on learning is possible with the TypeScript playground ([http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)),
    which compiles on-the-fly TypeScript code entered in a browser and shows it side
    by side with the generated JavaScript code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 学习TypeScript语言的最佳方法是什么？TypeScript官方主页上有一本官方手册，与最新发布的版本保持一致。可以通过TypeScript playground（[http://www.typescriptlang.org/play](http://www.typescriptlang.org/play)）进行实践学习，该工具可以即时编译在浏览器中输入的TypeScript代码，并将其与生成的JavaScript代码并排显示：
- en: '![](assets/beff0870-ae1c-47bc-9a63-8c5e9b71e2e4.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/beff0870-ae1c-47bc-9a63-8c5e9b71e2e4.png)'
- en: 'Alternatively, you can install the TypeScript globally by typing the following
    command in the command line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在命令行中输入以下命令全局安装TypeScript。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Global installation means, the TypeScript compiler `tsc` can be reached and
    used in any of your projects. Installed Node.js and npm are presupposed. Node.js
    is the JavaScript runtime environment ([https://nodejs.org](https://nodejs.org)).
    npm is the package manager. It is shipped with Node.js, but can be installed separately
    as well. After that, you can transpile one or more `.ts` files into `.js` files
    by typing the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 全局安装意味着TypeScript编译器`tsc`可以在任何项目中被访问和使用。需要安装Node.js和npm。Node.js是JavaScript运行时环境（[https://nodejs.org](https://nodejs.org)）。npm是包管理器。它随Node.js一起发布，但也可以单独安装。之后，您可以通过输入以下命令将一个或多个`.ts`文件转译为`.js`文件：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will result in two files, `some.js` and `another.js`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个文件，`some.js`和`another.js`。
- en: Basic types
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: TypeScript exposes the basic types, as well as a couple of extra types. Let's
    explore the type system with these examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript公开了基本类型，以及一些额外的类型。让我们通过这些例子来探索类型系统。
- en: '`Boolean`: The type is a primitive JavaScript boolean:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`：该类型是原始的JavaScript布尔值：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Number`: The type is a primitive JavaScript number:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`：该类型是原始的JavaScript数字：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`String`: The type is a primitive JavaScript string:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`：该类型是原始的JavaScript字符串：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Array`: The type is an array of value. There are two equivalent notations:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array`：该类型是一个值的数组。有两种等价的表示法：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Tuple`: The type represents a heterogeneous array of values. `Tuple` enables
    storing multiple fields of different types:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tuple`：该类型表示值的异构数组。`Tuple`可以存储不同类型的多个字段：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Any`: The type is *anything*. It is useful when you need to describe the type
    of variables that you do not know at the time of writing your application. You
    can assign a value of arbitrary type to a variable of type `any`. A value of type
    `any` in turn can be assigned to a variable of arbitrary type:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any`：该类型是*任何*类型。在编写应用程序时需要描述不知道的变量类型时非常有用。您可以将任意类型的值赋给`any`类型的变量。反过来，`any`类型的值可以赋给任意类型的变量：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Void`: The type represents the absence of having an `any` type. This type
    is normally used as the return type of functions:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Void`：该类型表示没有`any`类型。这种类型通常用作函数的返回类型：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Nullable`: These types denote two specific types, `null` and `undefined` that
    are valid values of every type. That means, they can be assigned to any other
    type. It is not always desired. TypeScript offers a possibility to change this
    default behavior by setting the compiler options `strictNullChecks` to `true`.
    Now, you have to include the `Nullable` types explicitly using a union type (explained
    later on), otherwise, you will get an error:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nullable`：这些类型表示两种特定类型，`null`和`undefined`，它们是每种类型的有效值。这意味着它们可以分配给任何其他类型。这并不总是理想的。TypeScript提供了一种通过将编译器选项`strictNullChecks`设置为`true`来更改此默认行为的可能性。现在，您必须显式使用联合类型（稍后解释）包含`Nullable`类型，否则将会出错：'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sometimes, you would like to tell compiler that you know the type better than
    it does and it should trust you. For instance, imagine a situation where you receive
    data over HTTP and know exactly the structure of the received data. The compiler
    doesn't know such structure of course. In this case, you want to turn off the
    type checking when assigning the data to a variable. It is possible with so called
    **type assertions**. A type assertion is like a type cast in other languages,
    but without the checking of data. You can do that either with *angle bracket*
    or the `as` syntax.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望告诉编译器，您比它更了解类型，它应该信任您。例如，想象一种情况，您通过HTTP接收数据，并且确切地知道接收到的数据的结构。当然，编译器不知道这样的结构。在这种情况下，您希望在将数据分配给变量时关闭类型检查。这可以通过所谓的**类型断言**来实现。类型断言类似于其他语言中的类型转换，但不检查数据。您可以使用*尖括号*或`as`语法来实现。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Interfaces, classes, and enums
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口、类和枚举
- en: 'An *interface* is a way to take a particular structure/shape and give it a
    name so that we can reference it later as a type. It defines a contract within
    our code. Interfaces begin with the keyword `interface`. Let''s take an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口*是一种将特定结构/形状命名的方式，以便我们以后可以引用它作为一种类型。它在我们的代码中定义了一个合同。接口以关键字`interface`开头。让我们举个例子：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The specified interface `Person` has the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的接口`Person`具有以下内容：
- en: The `name` property of type `string`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`string`的`name`属性。
- en: The optional property `children` of type `number`. Optional properties are denoted
    by a question mark and can be omitted.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`number`的可选属性`children`。可选属性由问号表示，可以省略。
- en: The `isMarried` method that returns a `boolean` value.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`boolean`值的`isMarried`方法。
- en: Anonymous (unnamed) method that returns nothing.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回空值的匿名（未命名）方法。
- en: 'Typescript allows you to use the syntax `[index: type]` to specify a `string`
    or `number` type based collection of key/value pairs. Interfaces perfectly fit
    such data structures. For example, consider the following syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'Typescript允许您使用`[index: type]`语法来指定基于`string`或`number`类型的键/值对集合。接口非常适合这样的数据结构。例如，考虑以下语法：'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An interface is only used by TypeScript compiler at compile time, and is then
    removed. Interfaces don't end up in the final JavaScript output. General, no types
    appear in the output. You can see that in the TypeScript playground mentioned
    earlier.![](assets/5f81e48d-5e0e-447b-8782-272b7fb9a4aa.png)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接口仅在编译时由TypeScript编译器使用，然后被移除。接口不会出现在最终的JavaScript输出中。通常，在输出中不会出现类型。您可以在前面提到的TypeScript
    playground中看到这一点！[](assets/5f81e48d-5e0e-447b-8782-272b7fb9a4aa.png)
- en: 'Beside interfaces, there are *classes* that describe objects. A class acts
    as a template for instantiating specific objects. The syntax for TypeScript''s
    classes is almost identical to that of native classes in ECMAScript 2015 with
    some handy additions. In TypeScript, you can use `public`, `private`, `protected`,
    and `readonly` access modifiers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接口，还有描述对象的*类*。类充当实例化特定对象的模板。TypeScript类的语法几乎与ECMAScript 2015中的原生类完全相同，并带有一些方便的附加功能。在TypeScript中，您可以使用`public`、`private`、`protected`和`readonly`访问修饰符：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Members with omitted modifiers are `public` by default. If a property or method
    is declared with the `static` keyword, there is no need to create an instance
    to access them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 省略修饰符的成员默认为`public`。如果使用`static`关键字声明属性或方法，则无需创建实例即可访问它们。
- en: 'A class can be abstract, that means, it may not be instantiated directly. Abstract
    classes begin with the keyword `abstract`. A class can implement an interface
    as well as extend another class. We can achieve that using the `implements` and
    `extends` keywords, respectively. If a class implements some interface, it must
    adopt all properties from this interface; otherwise, you will get an error about
    missing properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以是抽象的，这意味着它可能不能直接实例化。抽象类以关键字`abstract`开头。类可以实现一个接口，也可以扩展另一个类。我们可以使用`implements`和`extends`关键字分别实现这一点。如果一个类实现了某个接口，它必须采用该接口的所有属性；否则，您将收到有关缺少属性的错误：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Derived classes that contain constructor functions must call `super()`. The
    `super()` call executes the constructor function on the base class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 包含构造函数的派生类必须调用`super()`。`super()`调用在基类上执行构造函数。
- en: 'It is possible to declare a `constructor` parameter with a modifier. As result,
    a member will be created and initialized in one place:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用修饰符声明`constructor`参数。结果，一个成员将在一个地方被创建和初始化：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This shortened syntax is often used in Angular when we inject services into
    components. Angular's services are normally declared in the component's constructor
    with the `private` modifier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，当我们将服务注入到组件中时，经常会使用这种简化的语法。Angular的服务通常在组件的构造函数中使用`private`修饰符声明。
- en: 'The last basic type to be mentioned here is *enum*. Enums allow us to define
    a set of named constants. Enum members have numeric values associated with them
    (started with 0):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要提到的最后一个基本类型是*枚举*。枚举允许我们定义一组命名常量。枚举成员与数字值相关联（从0开始）：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Parameters and return values in the function signature can be typed too. Types
    protects you against JavaScript errors during function execution because the compiler
    warns you punctually at build time when the wrong types are used:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名中的参数和返回值也可以进行类型化。类型保护您免受JavaScript错误的影响，因为编译器会在构建时及时警告您使用错误类型：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Function type* is a way to declare the type of a function. To explicitly declare
    a function type, you should use the keywords `var` or `let`, a variable name,
    a colon, a parameter list, a fat arrow `=>`, and the function''s return type:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数类型*是声明函数类型的一种方式。要显式声明函数类型，您应该使用关键字`var`或`let`，一个变量名，一个冒号，一个参数列表，一个fat箭头`=>`，和函数的返回类型：'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, you must provide an implementation of this declaration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您必须提供此声明的实现：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This technique is especially useful for callbacks. Imagine a filter function
    which filters arrays by some criterion. An exact criterion can be encapsulated
    in the passed in callback function that acts as predicate:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于回调特别有用。想象一个根据某些标准过滤数组的过滤函数。一个确切的标准可以封装在传入的回调函数中，作为谓词：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A possible function call with a specific callback could appear as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的函数调用与特定回调可以如下所示：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In TypeScript, every function parameter is assumed to be required. There are
    two ways to mark a parameter as optional (optional parameters can be omitted when
    calling the function).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，假定每个函数参数都是必需的。有两种方法可以将参数标记为可选的（可选参数在调用函数时可以省略）。
- en: 'Use a question mark after the parameter name:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在参数名称后使用问号：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the parameter''s default value (ECMAScript 2015 feature), which gets applied
    when no value is provided:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数的默认值（ECMAScript 2015功能），当没有提供值时会应用默认值：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, you are able to call this function with just one value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以只使用一个值调用此函数。
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generics
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 'In TypeScript, you can define generic functions, interfaces, and classes like
    in other programming languages. A generic function has type parameters listed
    in angle brackets:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，您可以像其他编程语言一样定义通用函数、接口和类。通用函数在尖括号中列出类型参数：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Such generic functions can be defined with generic interfaces as well. The
    function signature for `reverseAndMerge` is compatible with the following generic
    interface:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的通用函数也可以使用通用接口来定义。`reverseAndMerge`的函数签名与以下通用接口兼容：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that the generic type parameter list in angle brackets follows the name
    of the function and interface. This is also true for classes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尖括号中的通用类型参数列表跟随函数和接口的名称。对于类也是如此：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Modules
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: 'ECMAScript 2015 has introduced built-in modules. The features of modules are
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015引入了内置模块。模块的特性如下：
- en: Each module is defined in its own file.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块都在自己的文件中定义。
- en: Functions or variables defined in a module are not visible outside unless you
    explicitly export them.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块中定义的函数或变量在外部是不可见的，除非你明确导出它们。
- en: You can place the `export` keyword in front of any variable, function, or class
    declaration to export it from the module.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在任何变量、函数或类声明前放置`export`关键字来从模块中导出它。
- en: You can use the `import` keyword to consume the exported variable, function,
    or class declaration.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`import`关键字来使用导出的变量、函数或类声明。
- en: Modules are singletons. Only a single instance of a module exists, even if it
    was imported multiple times.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是单例的。即使多次导入，模块的实例也只有一个。
- en: 'Some exporting possibilities are listed here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了一些导出的可能性：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can declare a variable, function, or class and export it later. You can
    also use the `as` keyword to rename exports. A new name is the name used for importing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以声明一个变量、函数或类，并稍后导出它。您还可以使用`as`关键字来重命名导出。新名称是用于导入的名称：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once you have a module with exports, you can access its functionality in another
    module using the `import` keyword:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了带有导出的模块，您可以使用`import`关键字在另一个模块中访问其功能：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There is a special case that allows you to import the entire module as a single
    object. All exported variables, functions, and classes are available on that object
    as properties:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊情况允许您将整个模块作为单个对象导入。所有导出的变量、函数和类都作为该对象的属性可用：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Imports can be renamed with the `as` keyword and used under the new name:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 导入可以使用`as`关键字重命名，并在新名称下使用：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Advanced types, decorators, and compiler options
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级类型、装饰器和编译器选项
- en: TypeScript has more types and advanced constructs such as decorators and type
    definition files. This chapter gives an overview on advanced topics and shows
    how to customize the compiler configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript具有更多类型和高级构造，例如装饰器和类型定义文件。本章概述了高级主题，并展示了如何自定义编译器配置。
- en: Union types and type aliases
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型和类型别名
- en: 'A *union type* describes a value that can be one of many types. The vertical
    bar `|` is used as separator for each type the value can have. For instance, `number
    | string` is the type of a value that can be a number or string. For such values,
    we can only access members that are common to all types in the union. The following
    code works because the `length` property exists on both strings and arrays:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*联合类型*描述了可以是多种类型之一的值。竖线`|`用作值可以具有的每种类型的分隔符。例如，`number | string`是一个可以是数字或字符串的值的类型。对于这样的值，我们只能访问联合中所有类型的公共成员。以下代码有效，因为`length`属性存在于字符串和数组中：'
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next code snippet gives an error because the `model` property does not
    exist on the `Bike` type:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段出现错误，因为`model`属性在`Bike`类型上不存在：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Type alias* is used as alternative name for the existing type or combination
    of types. It doesn''t create a new type. A type alias begins with the `type` keyword.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型别名*用作现有类型或类型组合的替代名称。它不创建新类型。类型别名以`type`关键字开头。'
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Type aliases can be used for better code readability, for example, in the function
    parameter list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名可用于提高代码可读性，例如，在函数参数列表中。
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Type aliases can also be generic and make tricky types, which can not be made
    with interfaces.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名也可以是通用的，并创建棘手的类型，这些类型无法使用接口创建。
- en: Type inference
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: '*Type inference* is used when the type is not provided explicitly. For instance
    in the following statements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型推断*在类型没有明确提供时使用。例如在以下语句中：'
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These don''t have explicit type annotations. TypeScript can infer that `x`
    is a string and `y` is a number. As you see, the type can be omitted if the compiler
    is able to infer it. TypeScript improves the type inference continuously. It tries
    to guess a best common type when elements of several types are present in an array.
    The type of the following variable `animal`, where `Sheepdog extends Dog`, is
    `Dog[]`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些没有显式类型注释。TypeScript可以推断出`x`是一个字符串，`y`是一个数字。正如你所看到的，如果编译器能够推断出类型，那么类型可以被省略。TypeScript不断改进类型推断。当数组中存在多种类型的元素时，它会尝试猜测最佳公共类型。变量`animal`的类型是`Dog[]`，其中`Sheepdog
    extends Dog`：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The best common type of the next array is `(Dog | Fish)[]` because the class
    `Fish` doesn''t extend to any other class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个数组的最佳公共类型是`(Dog | Fish)[]`，因为类`Fish`没有扩展到任何其他类：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Type inference is also used for functions. In the next example, the compiler
    can figure out the types of the function''s parameter (`string`) and the return
    value (`boolean`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断也用于函数。在下一个示例中，编译器可以推断出函数的参数类型（`string`）和返回值类型（`boolean`）：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Decorators
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: '*Decorators* were proposed in ECMAScript 2016 ([https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)).
    They are similar to Java annotations--they also add metadata to class declaration,
    method, property, and the function''s parameter, but they are more powerful. They
    add new behaviors to their targets. With decorators, we can run arbitrary code
    before, after, or around the target execution, like in aspect-oriented programming,
    or even replace the target with a new definition. In TypeScript, you can decorate
    constructors, methods, properties, and parameters. Every decorator begins with
    the `@` character followed by the name of the decorator.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*在ECMAScript 2016中提出（[https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)）。它们类似于Java注解--它们还向类声明、方法、属性和函数的参数添加元数据，但它们更加强大。它们为它们的目标添加了新的行为。使用装饰器，我们可以在目标执行之前、之后或周围运行任意代码，就像面向方面的编程一样，甚至用新定义替换目标。在TypeScript中，您可以装饰构造函数、方法、属性和参数。每个装饰器都以`@`字符开头，后面跟着装饰器的名称。'
- en: 'How does it work under the hood that takes its target as argument? Let''s implement
    a classic example with a logging functionality. We would like to implement a method
    decorator `@log`. A method decorator accepts three arguments: an instance of the
    class on which the method is defined, a key for the property, and the property
    descriptor ([https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何在底层工作的，以其目标作为参数？让我们实现一个具有日志功能的经典示例。我们想要实现一个方法装饰器`@log`。方法装饰器接受三个参数：定义方法的类的实例，属性的键和属性描述符（[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)）。
- en: 'If the method decorator returns a value, it will be used as a new property
    descriptor for this method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法装饰器返回一个值，它将被用作此方法的新属性描述符：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This decorator logs received arguments and return values. Decorators can be
    composed and customized with parameters too. You can write the following, for
    instance:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器记录接收到的参数和返回值。装饰器也可以组合和定制参数。例如，您可以编写以下内容：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Angular offers different types of decorators that are used for dependency injection
    or adding metadata information at compilation time:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了不同类型的装饰器，用于依赖注入或在编译时添加元数据信息：
- en: Class decorators such as `@NgModule`, `@Component`, and `@Injectable`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类装饰器，如`@NgModule`，`@Component`和`@Injectable`
- en: Property decorators such as `@Input` and `@Output`
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性装饰器，如`@Input`和`@Output`
- en: Method decorators such as `@HostListener`
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法装饰器，如`@HostListener`
- en: Parameter decorators such as `@Inject`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数装饰器，如`@Inject`
- en: 'TypeScript compiler is able to emit some design-time type metadata for decorators.
    To access this information, we have to install a Polyfill called `reflect-metadata`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器能够为装饰器发出一些设计时类型元数据。要访问这些信息，我们必须安装一个名为`reflect-metadata`的Polyfill：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can access, for example, the type of the property (`key`) on the `target`
    object as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问，例如，在`target`对象上的属性（`key`）的类型如下：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Refer to the official TypeScript documentation to learn more about decorators
    and reflect metadata API ([http://www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html)).In
    TypeScript, Angular applications, decorators are enabled by setting the compiler
    options `emitDecoratorMetadata` and `experimentalDecorators` to `true` (compiler
    options are described later on).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方TypeScript文档，了解有关装饰器和反射元数据API的更多信息（[http://www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html)）。在TypeScript中，Angular应用程序，通过将编译器选项`emitDecoratorMetadata`和`experimentalDecorators`设置为`true`来启用装饰器（编译器选项稍后描述）。
- en: Type definition files
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型定义文件
- en: JavaScript programs written in native JavaScript don't have any type information.
    If you add a JavaScript library such as jQuery or Lodash to your TypeScript-based
    application and try to use it, the TypeScript compiler can find any type information
    and warn you with compilation errors. Compile-time safety, type checking, and
    context-aware code completion get lost. That is where *type definition files*
    come into play.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用原生JavaScript编写的JavaScript程序没有任何类型信息。如果您将JavaScript库（如jQuery或Lodash）添加到基于TypeScript的应用程序中并尝试使用它，TypeScript编译器可能找不到任何类型信息，并通过编译错误警告您。编译时安全性、类型检查和上下文感知的代码完成都会丢失。这就是*类型定义文件*发挥作用的地方。
- en: 'Type definition files provide type information for JavaScript code that is
    not statically typed. Type definition files ends with `.d.ts` and only contain
    definitions which are not emitted by TypeScript. The `declare` keyword is used
    to add types to JavaScript code that exists somewhere. Let''s take an example.
    TypeScript is shipped with the `lib.d.ts` library describing ECMAScript API. This
    type definition file is used automatically by the TypeScript compiler. The following
    declaration is defined in this file without implementation details:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 类型定义文件为静态类型的JavaScript代码提供类型信息。类型定义文件以`.d.ts`结尾，只包含TypeScript未发出的定义。`declare`关键字用于向JavaScript代码添加类型，该代码存在于某个地方。让我们举个例子。TypeScript附带了描述ECMAScript
    API的`lib.d.ts`库。这个类型定义文件会被TypeScript编译器自动使用。以下声明在此文件中定义，但没有实现细节：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, when you use the `parseInt` function in your code, the TypeScript compiler
    ensures that your code uses the correct types and IDEs show context-sensitive
    hints when you''re writing code. Type definition files can be installed as dependencies
    under the `node_modules/@types` directory by typing the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在代码中使用`parseInt`函数时，TypeScript编译器会确保您的代码使用正确的类型，并且在编写代码时，IDE会显示上下文敏感的提示。类型定义文件可以通过输入以下命令作为依赖项安装在`node_modules/@types`目录下：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A concrete example for jQuery library is:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery库的一个具体例子是：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In Angular, all type definition files are bundled with Angular npm packages
    and located under `node_modules/@angular`. There is no need to install such files
    separately like we did for jQuery. TypeScript finds them automatically.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，所有类型定义文件都与Angular npm包捆绑在一起，位于`node_modules/@angular`目录下。无需像我们为jQuery那样单独安装这些文件。TypeScript会自动找到它们。
- en: 'Most of the time, you have the compile target ES5 (generated JavaScript version,
    which is widely supported), but want to use some ES6 (ECMAScript 2015) features
    by adding Polyfills. In this case, you must tell the compiler that it should look
    for extended definitions in the `lib.es6.d.ts` or `lib.es2015.d.ts` file. This
    can be achieved in compiler options by setting the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您的编译目标是ES5（生成的JavaScript版本，得到广泛支持），但希望通过添加Polyfills来使用一些ES6（ECMAScript
    2015）功能。在这种情况下，您必须告诉编译器它应该在`lib.es6.d.ts`或`lib.es2015.d.ts`文件中查找扩展定义。这可以通过在编译器选项中设置以下内容来实现：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Compiler options
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器选项
- en: 'Typically, the first step in a new TypeScript project is to add in a `tsconfig.json`
    file. This file defines the project and compiler settings, for instance, files
    and libraries to be included in the compilation, output structure, module code
    generation, and so on. A typical configuration in `tsconfig.json` for Angular
    2+ projects looks like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在新的 TypeScript 项目中的第一步是添加一个 `tsconfig.json` 文件。该文件定义了项目和编译器的设置，例如要包含在编译中的文件和库，输出结构，模块代码生成等。`tsconfig.json`
    中用于 Angular 2+ 项目的典型配置如下：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The listed compiler settings are described as follows. A full list of all options
    is available at the TypeScript documentation page ([https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所列的编译器设置如下所述。所有选项的完整列表可在 TypeScript 文档页面上找到（[https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)）。
- en: '| **Option** | **Type** | **Default** | **Description** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **类型** | **默认** | **描述** |'
- en: '| `target` | `string` | `ES3` | This specifies ECMAScript target version: `ES3`,
    `ES5`, `ES2015`, `ES2016`, and `ES2017`. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `target` | `string` | `ES3` | 这指定了 ECMAScript 的目标版本：`ES3`, `ES5`, `ES2015`,
    `ES2016`, 和 `ES2017`。 |'
- en: '| `module` | `string` | `ES6` if target is "ES6" and `CommonJS` otherwise |
    This specifies the format of module code generation: `None`, `CommonJS`, `AMD`,
    `System`, `UMD`, `ES6`, or `ES2015`. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `module` | `string` | `ES6` if target is "ES6" and `CommonJS` otherwise |
    这指定了模块代码生成的格式：`None`, `CommonJS`, `AMD`, `System`, `UMD`, `ES6`, 或 `ES2015`。 |'
- en: '| `moduleResolution` | `string` | `Classic` if module is "AMD," `System`, `ES6`,
    and `Node` otherwise | This determines how modules get resolved. Either `Node`
    for Node.js style resolution or `Classic`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `moduleResolution` | `string` | `Classic` if module is "AMD," `System`, `ES6`,
    and `Node` otherwise | 这确定了模块的解析方式。要么是 `Node` 用于 Node.js 风格的解析，要么是 `Classic`。'
- en: '| `noImplicitAny` | `boolean` | `false` | This raises errors on expressions
    and declarations with an implied `any` type. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `noImplicitAny` | `boolean` | `false` | 这会在具有隐含的 `any` 类型的表达式和声明上引发错误。 |'
- en: '| `sourceMap` | `boolean` | `false` | This generates the corresponding `.map`
    file. This is useful if you want to debug original files. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `sourceMap` | `boolean` | `false` | 这会生成相应的 `.map` 文件。如果你想要调试原始文件，这是很有用的。'
- en: '| `emitDecoratorMetadata` | `boolean` | `false` | This emits design type metadata
    for decorated declarations in source. You have to set this value to `true` if
    you want to develop web applications with Angular. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `emitDecoratorMetadata` | `boolean` | `false` | 这会为源代码中装饰的声明发出设计类型元数据。如果你想要开发带有
    Angular 的 Web 应用程序，你必须将这个值设置为 `true`。'
- en: '| `experimentalDecorators` | `boolean` | `false` | This enables experimental
    support for ECMAScript decorators. You have to set this value to `true` if you
    want to develop web applications with Angular. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `experimentalDecorators` | `boolean` | `false` | 这启用了对 ECMAScript 装饰器的实验性支持。如果你想要开发带有
    Angular 的 Web 应用程序，你必须将这个值设置为 `true`。'
- en: '| `outDir` | `string` | - | This is the output directory for compiled files.
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `outDir` | `string` | - | 这是编译文件的输出目录。 |'
- en: '| `lib` | `string[]` | Refer to the documentation for more information. | This
    is the list of library files to be included in the compilation. Refer to the documentation
    for more information. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `lib` | `string[]` | 更多信息请参考文档。 | 这是要包含在编译中的库文件列表。更多信息请参考文档。 |'
- en: '| `types` | `string[]` | - | This is the list of names of type definitions
    to include. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `types` | `string[]` | - | 这是要包含的类型定义名称列表。 |'
- en: '| `exclude` | `string[]` | - | This is the list of (sub) directories excluded
    from the compilation. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `exclude` | `string[]` | - | 这是编译时排除的（子）目录列表。 |'
- en: You can stop the compiler from emitting JavaScript on errors by setting the
    `--noEmitOnError` option to `true`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `--noEmitOnError` 选项设置为 `true` 来阻止编译器在出错时发出 JavaScript。
- en: Angular cheat sheet - overview of key concepts
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 速查表 - 关键概念概述
- en: Angular 2 introduces completely new concepts for building web applications.
    The new Angular platform is complex. It is not possible to explain numerous Angular
    features in detail. Instead, we will concentrate on the most important key concepts
    such as dependency injection, components, and communication between them, built-in
    directives, services, template syntax, forms, and routing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 引入了完全新的概念来构建 Web 应用程序。新的 Angular 平台是复杂的。不可能详细解释众多的 Angular 特性。相反，我们将集中讨论最重要的关键概念，如依赖注入、组件及其之间的通信、内置指令、服务、模板语法、表单和路由。
- en: Components, services, and dependency injection
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件、服务和依赖注入
- en: 'Normally, you write Angular applications by composing HTML templates with the
    Angular-specific markup and component classes to manage those templates. A **component**
    is simply a TypeScript class annotated with `@Component`. The `@Component` decorator
    is used to define the associated metadata. It expects an object with the following
    most used properties:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您通过使用 Angular 特定的标记和组件类来组合 HTML 模板来编写 Angular 应用程序。**组件**只是一个使用 `@Component`
    注释的 TypeScript 类。`@Component` 装饰器用于定义相关的元数据。它期望一个具有以下最常用属性的对象：
- en: '`selector`: This is the name of the HTML tag representing this component'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`：这是表示该组件的 HTML 标签的名称'
- en: '`template`: This is an inline-defined template with HTML/Angular markup for
    the view'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：这是包含 HTML/Angular 标记的内联定义模板，用于视图'
- en: '`templateUrl`: This is the path to an external file where the template resides'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateUrl`：这是模板所在的外部文件的路径'
- en: '`styles`: An inline-defined styles to be applied to this component''s view'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styles`：内联定义的样式，应用于该组件的视图'
- en: '`styleUrls`: An array of paths to external files with styles to be applied
    to this component''s view'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styleUrls`：外部文件路径数组，其中包含要应用于该组件视图的样式'
- en: '`providers`: An array of providers available to this component and its children'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providers`：可用于该组件及其子级的提供者数组'
- en: '`exportAs`: This is the name under which the component instance is exported
    in a template'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exportAs`：这是组件实例在模板中导出的名称'
- en: '`changeDetection`: This is the change detection strategy used by this component'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changeDetection`：这是该组件使用的变更检测策略'
- en: '`encapsulation`: This is the style encapsulation strategy used by this component'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encapsulation`：这是该组件使用的样式封装策略'
- en: 'A component class interacts with the view through an API of properties and
    methods. Component classes should delegate complex tasks to services where the
    business logic resides. **Services** are just classes that Angular instantiates
    and then injects into components. If you register services at the root component
    level, they act as singletons and share data across multiple components. In the
    next section, *Angular modularity and lifecycle hooks*, we will see how to register
    services. The following example demonstrates how to use components and services.
    We will write a service class `ProductService` and then specify an argument of
    type `ProductService` in the constructor of `ProductComponent`. Angular will automatically
    inject that service into the component:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 组件类通过属性和方法的API与视图进行交互。组件类应该将复杂的任务委托给业务逻辑所在的服务。**服务**只是 Angular 实例化然后注入到组件中的类。如果在根组件级别注册服务，它们将作为单例并在多个组件之间共享数据。在下一节中，*Angular
    模块化和生命周期钩子*，我们将看到如何注册服务。以下示例演示了如何使用组件和服务。我们将编写一个名为 `ProductService` 的服务类，然后在 `ProductComponent`
    的构造函数中指定一个类型为 `ProductService` 的参数。Angular 将自动将该服务注入到组件中：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that we applied the `@Injectable()` decorator to the service class. This
    is necessary for emitting metadata that Angular needs to inject other dependencies
    into this service. Using `@Injectable` is a good programming style even if you
    don't inject other services into your service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`@Injectable()`装饰器应用到了服务类上。这对于发出Angular需要将其他依赖项注入到此服务中的元数据是必要的。即使您不将其他服务注入到您的服务中，使用`@Injectable`也是一种良好的编程风格。
- en: 'It is good to know what an item in the `providers` array looks like. An item
    is an object with the `provide` property (symbol used for dependency injection)
    and one of the three properties `useClass`, `useFactory`, or `useValue` that provide
    implementation details:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`providers`数组中的项是什么样子是很好的。一个项是一个带有`provide`属性（用于依赖注入的符号）和`useClass`、`useFactory`或`useValue`中的一个的对象，提供实现细节：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Templates and bindings
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板和绑定
- en: 'A template tells Angular how to render the component''s view. Templates are
    HTML snippets with the specific Angular''s template syntax, such as interpolation,
    property, attribute, and event bindings, built-in directives, and pipes to mention
    just a few. We will give you a quick overview of the template syntax starting
    with interpolation. **Interpolation** is used to evaluate expressions in double
    curly braces. The evaluated expression is then converted to a string. The expression
    can contain any mathematical calculations, component''s properties and methods,
    and many more:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 模板告诉Angular如何渲染组件的视图。模板是具有特定Angular模板语法的HTML片段，例如插值、属性、属性和事件绑定、内置指令和管道等。我们将为您快速概述模板语法，从插值开始。**插值**用于在双大括号中评估表达式。然后将评估的表达式转换为字符串。表达式可以包含任何数学计算、组件的属性和方法等：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Angular evaluates template expressions after every change detection cycle.
    Change detection cycles are triggered by many asynchronous activities such as
    HTTP responses, key and mouse events, and many more. The next fundamental template
    syntax is related to various bindings. *Property binding* sets an element property
    to a component property value. The element property is defined in square brackets:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在每次变更检测周期之后评估模板表达式。变更检测周期由许多异步活动触发，例如HTTP响应、键盘和鼠标事件等。下一个基本模板语法与各种绑定相关。*属性绑定*将元素属性设置为组件属性值。元素属性在方括号中定义：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, `imageUrl` and `formValid` are a component''s properties. Note that this
    is a *one-way* binding because the data flow occurs in one direction, from the
    component''s properties into target element properties. *Attribute binding* allows
    us to set an attribute. This kind of binding is used when there is no element
    property to bind. The attribute binding uses square brackets too. The attribute
    name itself is prefixed with `attr.`, for example, consider ARIA attributes for
    web accessibility:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`imageUrl`和`formValid`是组件的属性。请注意，这是*单向*绑定，因为数据流只在一个方向上，从组件的属性到目标元素属性。*属性绑定*允许我们设置属性。当没有元素属性可绑定时，使用这种绑定。属性绑定也使用方括号。属性名称本身以`attr.`为前缀，例如，考虑用于Web可访问性的ARIA属性：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'User interactions result in a data flow from an element to a component. In
    Angular, we can listen for certain key, mouse, and touch events by means of *event
    binding*. The event binding syntax consists of a target event name within parentheses
    on the left and a quoted template statement on the right. In particular, you can
    call a component''s method. In the next code snippet, the `onSave()` method is
    called on a click:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 用户交互导致元素到组件的数据流。在Angular中，我们可以通过*事件绑定*来监听特定的键盘、鼠标和触摸事件。事件绑定语法由左侧括号中的目标事件名称和右侧的带引号的模板语句组成。特别是，您可以调用组件的方法。在下一个代码片段中，`onSave()`方法在点击时被调用：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The method (generally template statement) gets a parameter--an event object
    named `$event`. For native HTML elements and events, `$event` is a DOM event object:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法（通常是模板语句）接收一个参数--一个名为`$event`的事件对象。对于本机HTML元素和事件，`$event`是一个DOM事件对象：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Two-way binding is possible as well. The `[(value)]` syntax combines the brackets
    of property binding with the parentheses of event binding. Angular''s directive
    `NgModel` is best suited for the two-way binding on native or custom input elements.
    Consider the following sample:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 双向绑定也是可能的。`[(value)]`语法将属性绑定的括号与事件绑定的括号结合在一起。Angular的指令`NgModel`最适合用于本机或自定义输入元素的双向绑定。考虑以下示例：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Is equivalent to:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Two-way binding in a nutshell: a property gets displayed and updated at the
    same time when the user makes changes. A *template reference variable* is another
    example of handy template syntax. You can declare a variable with the hash symbol
    (`#`) on any DOM element and reference this variable anywhere in the template.
    The next example shows the `username` variable declared on an `input` element.
    This reference variable is consumed on a button--it is used to get an input value
    for the `onclick` handler:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，双向绑定是指当用户进行更改时，属性同时显示和更新。*模板引用变量*是方便的模板语法的另一个例子。您可以在任何DOM元素上使用井号（`#`）声明一个变量，并在模板中的任何位置引用此变量。下一个示例显示了在`input`元素上声明的`username`变量。这个引用变量在按钮上被使用--它用于获取`onclick`处理程序的输入值：
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A template reference variable can also be set to a directive. A typical example
    is the `NgForm` directive which provides useful details about the `form` elements.
    You can, for example, disable the submit button if the form is not valid (required
    fields are not filled in and so on):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用变量也可以设置为指令。一个典型的例子是`NgForm`指令，它提供了关于`form`元素的有用细节。例如，如果表单无效（必填字段未填写等），您可以禁用提交按钮：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Last but not least, the *pipe* operator (`|`). It is used for the transformation
    of the expression''s result. The pipe operator passes the result of an expression
    on the left to a pipe function on the right. For example, the pipe `date` formats
    JavaScript `Date` object according to the specified format ([https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html](https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html)):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有*管道*运算符（`|`）。它用于转换表达式的结果。管道运算符将左侧表达式的结果传递给右侧的管道函数。例如，管道`date`根据指定的格式格式化JavaScript
    `Date`对象（[https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html](https://angular.io/docs/ts/latest/api/common/index/DatePipe-pipe.html)）：
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Multiple chained pipes can be applied as well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以应用多个链接的管道。
- en: Built-in directives
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置指令
- en: 'Angular has a lot of built-in directives: `ngIf`, `ngFor`, `ngSwitch`, `ngClass`,
    and `ngStyle`. The first three directives are so called *structural directives*,
    which are used to transform the DOM''s structure. Structural directives start
    with an asterisk (`*`). The last two directives manipulate the CSS classes and
    styles dynamically. Let''s explain the directives in the examples.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有很多内置指令：`ngIf`、`ngFor`、`ngSwitch`、`ngClass`和`ngStyle`。前三个指令被称为*结构指令*，用于转换DOM的结构。结构指令以星号（`*`）开头。最后两个指令动态地操作CSS类和样式。让我们在示例中解释这些指令。
- en: 'The `ngIf` directive adds and removes elements in the DOM, based on the Boolean
    result of an expression. In the next code snippet, `<h2>ngIf</h2>` is removed
    when the `show` property evaluates to `false` and gets recreated otherwise:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngIf`指令根据表达式的布尔结果在DOM中添加和删除元素。在下一个代码片段中，当`show`属性计算为`false`时，`<h2>ngIf</h2>`被移除，否则重新创建：'
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Angular 4 has introduced a new `else` clause with the reference name for a
    template defined by `ng-template`. The content within `ng-template` is shown when
    the `ngIf` condition evaluates to `false`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 4引入了一个新的`else`子句，其引用名称为`ng-template`定义的模板。当`ngIf`条件求值为`false`时，`ng-template`中的内容将显示出来：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`ngFor` outputs a list of elements by iterating over an array. In the next
    code snippet, we iterate over the `people` array and store each item in a template
    variable called `person`. This variable can be then accessed within the template:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`通过对数组进行迭代来输出元素列表。在下一个代码片段中，我们对`people`数组进行迭代，并将每个项目存储在名为`person`的模板变量中。然后可以在模板中访问此变量：'
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`ngSwitch` conditionally swaps the contents dependent on condition. In the
    next code snippet, `ngSwitch` is bound to the `choice` property. If `ngSwitchCase`
    matches the value of this property, the corresponding HTML element is displayed.
    If no matching exists, the element associated with `ngSwitchDefault` is displayed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngSwitch`根据条件有条件地交换内容。在下一个代码片段中，`ngSwitch`绑定到`choice`属性。如果`ngSwitchCase`匹配此属性的值，则显示相应的HTML元素。如果没有匹配项，则显示与`ngSwitchDefault`关联的元素：'
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`ngClass` adds and removes CSS classes on an element. The directive should
    receive an object with class names as keys and expressions as values that evaluate
    to `true` or `false`. If the value is `true`, the associated class is added to
    the element. Otherwise, if `false`, the class is removed from the element:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass`在元素上添加和删除CSS类。指令应接收一个带有类名作为键和表达式作为值的对象，这些表达式求值为`true`或`false`。如果值为`true`，则将关联的类添加到元素中。否则，如果为`false`，则从元素中删除类：'
- en: '[PRE66]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`ngStyle` adds and removes inline styles on an element. The directive should
    receive an object with style names as keys and expressions as values that evaluate
    to style values. A key can have an optional `.<unit>` suffix (for example, `top.px`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`在元素上添加和删除内联样式。指令应接收一个带有样式名称作为键和表达式作为值的对象，这些表达式求值为样式值。键可以有一个可选的`.<unit>`后缀（例如，`top.px`）：'
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In order to be able to use built-in directives in templates, you have to import
    `CommonModule` from `@angular/common` and add it to the root module of your application.
    Angular's modules are explained in the next chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在模板中使用内置指令，您必须从`@angular/common`导入`CommonModule`并将其添加到应用程序的根模块中。Angular的模块将在下一章中进行解释。
- en: Communication between components
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件之间的通信
- en: 'Components can communicate with each other in a loosely coupled manner. There
    are various ways Angular''s components can share data, including the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以以松散耦合的方式相互通信。Angular组件可以共享数据的各种方式，包括以下方式：
- en: Passing data from parent to child using `@Input()`
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Input()`从父组件向子组件传递数据
- en: Passing data from child to parent using `@Output()`
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Output()`从子组件向父组件传递数据
- en: Using services for data sharing
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务进行数据共享
- en: Calling `ViewChild`, `ViewChildren`, `ContentChild`, and `ContentChildren`
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`ViewChild`，`ViewChildren`，`ContentChild`和`ContentChildren`
- en: Interacting with the child component using a local variable
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地变量与子组件交互
- en: 'We will only describe the first three ways. A component can declare input and
    output properties. To pass the data from a parent to a child component, the parent
    binds the values to the input properties of the child. The child''s input property
    should be decorated with `@Input()`. Let''s create `TodoChildComponent`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只描述前三种方式。组件可以声明输入和输出属性。要将数据从父组件传递到子组件，父组件将值绑定到子组件的输入属性。子组件的输入属性应该用`@Input()`装饰。让我们创建`TodoChildComponent`：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, the parent component can use `todo-child` in its template and bind the
    parent''s `todo` object to the child''s `todo` property. The child''s property
    is exposed as usual in square brackets:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，父组件可以在其模板中使用`todo-child`并将父组件的`todo`对象绑定到子组件的`todo`属性。子组件的属性像往常一样用方括号暴露出来：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If a component needs to pass the data to its parent, it emits custom events
    via the output property. The parent can create a listener to a particular component''s
    event. Let''s see that in action. The child component `ConfirmationChildComponent`
    exposes an `EventEmitter` property decorated with `@Output()` to emit events when
    the user clicks on buttons:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件需要将数据传递给其父组件，它会通过输出属性发出自定义事件。父组件可以创建一个监听器来监听特定组件的事件。让我们看看它的实现。子组件`ConfirmationChildComponent`暴露了一个带有`@Output()`装饰的`EventEmitter`属性，以便在用户点击按钮时发出事件：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The parent subscribes an event handler to that event property and reacts to
    the emitted event:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件订阅事件处理程序到该事件属性，并对发出的事件做出反应：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A bi-directional communication is possible via services. Angular leverages RxJS
    library ([https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS))
    for asynchronous and event-based communication between several parts of an application
    as well as between an application and remote backend. The key concepts in the
    asynchronous and event-based communication are `Observer` and `Observable`. They
    provide a generalized mechanism for push-based notification, also known as the
    observer design pattern. `Observable` represents an object that sends notifications,
    and `Observer` represents an object that receives them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过服务可以实现双向通信。Angular利用RxJS库（[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)）在应用程序的各个部分之间以及应用程序与远程后端之间进行异步和基于事件的通信。异步和基于事件的通信中的关键概念是“观察者”和“可观察对象”。它们提供了一种推送式通知的通用机制，也称为观察者设计模式。“可观察对象”表示发送通知的对象，“观察者”表示接收通知的对象。
- en: 'Angular implements this design pattern everywhere. For example, Angular''s
    `Http` service returns an `Observable` object:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在各处实现了这种设计模式。例如，Angular的`Http`服务返回一个`Observable`对象：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In case of the inter-component communication, an instance of the `Subject`
    class can be used. This class inherits both `Observable` and `Observer`. That
    means it acts as a message bus. Let''s implement `TodoService` that allows us
    to emit and receive `Todo` objects:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件间通信的情况下，可以使用`Subject`类的一个实例。这个类同时继承了`Observable`和`Observer`。这意味着它充当了一个消息总线。让我们实现`TodoService`，它允许我们发出和接收`Todo`对象：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Components can use this service in the following way:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以以以下方式使用此服务：
- en: '[PRE74]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Forms
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: 'Forms are the main building blocks in every web application. Angular offers
    two approaches to build forms: *template-driven forms* and *reactive forms*. This
    section gives you a short overview of template-driven forms.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是每个Web应用程序中的主要构建块。Angular提供了两种构建表单的方法：*模板驱动表单*和*响应式表单*。本节为您提供了模板驱动表单的简要概述。
- en: Reactive forms are suitable when you need to create dynamic forms programmatically
    in the component's class. Refer to the official Angular documentation to learn
    reactive forms ([https://angular.io/docs/ts/latest/guide/reactive-forms.html](https://angular.io/docs/ts/latest/guide/reactive-forms.html)).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在组件类中以编程方式创建动态表单时，响应式表单是合适的。请参考官方的Angular文档来学习响应式表单（[https://angular.io/docs/ts/latest/guide/reactive-forms.html](https://angular.io/docs/ts/latest/guide/reactive-forms.html)）。
- en: 'We already mentioned two directives: `NgForm` and `NgModel`. The first directive
    creates a `FormGroup` instance and binds it to a form in order to track aggregate
    form value and validation status. The second one creates a `FormControl` instance
    and binds it to the corresponding `form` element. The `FormControl` instance tracks
    the value and the status of the `form` element. Each input element should have
    a `name` property that is required to register the `FormControl` by the `FormGroup`
    under the name you assigned to the `name` attribute. How to deal with this tracked
    data? You can export the `NgForm` and `NgModel` directives into local template
    variables such as `#f="ngForm"` and `#i="ngModel"`, respectively. Here, `f` and
    `i` are local template variables that give you access to the value and status
    of `FormGroup` and `FormControl`, respectively. This is possible because the properties
    from `FormGroup` and `FormControl` are duplicated on the directives themselves.
    With this knowledge in hand, you can now check if the whole form or a particular
    `form` element:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了两个指令：`NgForm`和`NgModel`。第一个指令创建一个`FormGroup`实例，并将其绑定到一个表单，以便跟踪聚合表单值和验证状态。第二个指令创建一个`FormControl`实例，并将其绑定到相应的`form`元素。`FormControl`实例跟踪`form`元素的值和状态。每个输入元素都应该有一个`name`属性，这是必需的，以便通过您分配给`name`属性的名称将`FormControl`注册到`FormGroup`下。如何处理这些跟踪的数据？您可以将`NgForm`和`NgModel`指令导出到本地模板变量，例如`#f="ngForm"`和`#i="ngModel"`。在这里，`f`和`i`是本地模板变量，让您访问`FormGroup`和`FormControl`的值和状态。这是可能的，因为`FormGroup`和`FormControl`的属性在指令本身上被复制。有了这些知识，您现在可以检查整个表单或特定的`form`元素：
- en: Is valid (`valid` and `invalid` properties)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有效（`valid`和`invalid`属性）
- en: Has been visited (`touched` and `untouched` properties)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已被访问（`touched`和`untouched`属性）
- en: Has some changed value (`dirty` and `pristine` properties)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些改变的值（`dirty`和`pristine`属性）
- en: 'The next example illustrates the basic concept:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子说明了基本概念：
- en: '[PRE75]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `NgModel` directive also updates the corresponding `form` element with
    specific CSS classes that reflect the element''s state. The following classes
    are added/removed dependent on the current state:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgModel`指令还会更新相应的`form`元素，使用特定的CSS类来反映元素的状态。根据当前状态，以下类将被添加/移除：'
- en: '| **State** | **Class if true** | **Class if false** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **状态** | **如果为真的类** | **如果为假的类** |'
- en: '| Element has been visited | `ng-touched` | `ng-untouched` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 元素已被访问 | `ng-touched` | `ng-untouched` |'
- en: '| Element''s value has changed | `ng-dirty` | `ng-pristine` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 元素的值已更改 | `ng-dirty` | `ng-pristine` |'
- en: '| Element''s value is valid | `ng-valid` | `ng-invalid` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: 元素的值是有效的 | `ng-valid` | `ng-invalid`
- en: 'This is handy for styling. For example, in case of validation errors, you can
    set red borders around input elements:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于样式很方便。例如，在验证错误的情况下，您可以在输入元素周围设置红色边框：
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Routing
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: 'Angular''s `router` module allows you to configure navigation in a single page
    application without a full page reload. The router can display different views
    (compiled component templates) within a special tag called `<router-outlet>`.
    During navigation, one view will be replaced by another one. A simple routing
    configuration looks as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的`router`模块允许您在单页应用程序中配置导航，而无需完整的页面重新加载。路由器可以在特殊标记`<router-outlet>`中显示不同的视图（已编译的组件模板）。在导航期间，一个视图将被另一个视图替换。简单的路由配置如下所示：
- en: '[PRE77]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When you navigate to the web context root, you will be redirected to `/home`.
    As a reaction to that, the view of the `HomeComponent` will be displayed in `<router-outlet>`.
    It is obvious that a direct navigation to `/home` displays the same view. A navigation
    to `/books` displays the view of `BooksComponent`. Such router configuration should
    be converted to an Angular''s module by `RouterModule.forRoot`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导航到Web上下文根时，您将被重定向到`/home`。作为对此的反应，`HomeComponent`的视图将显示在`<router-outlet>`中。显然，直接导航到`/home`会显示相同的视图。导航到`/books`会显示`BooksComponent`的视图。此类路由器配置应转换为Angular模块，使用`RouterModule.forRoot`：
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This is then imported in a root module class. In addition to the root module,
    an Angular application can consist of a lot of feature or lazy-loaded modules.
    Such separate modules can have their own router configurations which should be
    converted to Angular''s modules with `RouterModule.forChild(router)`. The next
    section, *Angular modularity and lifecycle hooks,* discusses modules in detail.
    Angular offers two strategies for implementing client-side navigation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其导入根模块类。除了根模块外，Angular应用程序还可以包括许多特性或延迟加载的模块。这些单独的模块可以具有自己的路由器配置，应将其转换为使用`RouterModule.forChild(router)`的Angular模块。下一节“Angular模块化和生命周期挂钩”将详细讨论模块。Angular提供了两种实现客户端导航的策略：
- en: '`HashLocationStrategy`: This strategy adds a hash sign (`#`) to the base URL.
    Everything after this sign represents a hash fragment of the browser''s URL. The
    hash fragment identifies the route. For example, `http://somehost.de:8080/#/books`.
    Changing the route doesn''t cause a server-side request. Instead, the Angular
    application navigates to a new route and view. This strategy works with all browsers.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashLocationStrategy`：此策略在基本URL后添加一个哈希标记（`#`）。此标记后的所有内容表示浏览器URL的哈希片段。哈希片段标识路由。例如，`http://somehost.de:8080/#/books`。更改路由不会导致服务器端请求。相反，Angular应用程序会导航到新的路由和视图。此策略适用于所有浏览器。'
- en: '`PathLocationStrategy`: This strategy is based on the **History API** and only
    works in browsers that support HTML5\. This is the default location strategy.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PathLocationStrategy`：此策略基于**History API**，仅在支持HTML5的浏览器中有效。这是默认的位置策略。'
- en: 'The details are to be mentioned here. If you want to use the `HashLocationStrategy`,
    you have to import two classes, `LocationStrategy` and `HashLocationStrategy`
    from `''@angular/common''` and configure providers as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息将在此处提及。如果要使用`HashLocationStrategy`，必须从`'@angular/common'`导入`LocationStrategy`和`HashLocationStrategy`两个类，并按以下方式配置提供者：
- en: '[PRE79]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Providers are described in the next section, *Angular modularity and lifecycle
    hooks.* The `PathLocationStrategy` class requires a configuration of the base
    URL for the entire application. The best practice is to import `APP_BASE_HREF`
    constant from `''@angular/common''` and use it as a provider in order to configure
    the base URL:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者在下一节“Angular模块化和生命周期挂钩”中进行了描述。`PathLocationStrategy`类需要对整个应用程序的基本URL进行配置。最佳做法是从`'@angular/common'`导入`APP_BASE_HREF`常量，并将其用作提供者以配置基本URL：
- en: '[PRE80]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'How to trigger a navigation? You can achieve that in two ways, either by a
    link with a `routerLink` property, which specifies an array consisting of route
    (path) and optional parameters:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如何触发导航？有两种方法可以实现，一种是使用具有`routerLink`属性的链接，该属性指定由路由（路径）和可选参数组成的数组：
- en: '[PRE81]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Or programmatically, by invoking the `navigate` method on Angular''s `Router`
    service:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过在Angular的`Router`服务上调用`navigate`方法来以编程方式实现：
- en: '[PRE82]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can also pass parameters to a route. Placeholders for parameters start
    with a colon (`:`):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以向路由传递参数。参数的占位符以冒号（`:`）开头：
- en: '[PRE83]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, when navigating to a book with real parameters, for example, programmatically
    as `this.router.navigate([''/books/2''])`, the real parameter can be accessed
    by `ActivatedRoute`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当以真实参数导航到一本书，例如以编程方式`this.router.navigate(['/books/2'])`，可以通过`ActivatedRoute`访问真实参数：
- en: '[PRE84]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The router outlet can be named as well:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 路由出口也可以被命名：
- en: '[PRE85]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The associated configuration should contain the `outlet` property with the
    name of the router outlet:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 相关配置应包含具有路由出口名称的`outlet`属性：
- en: '[PRE86]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Angular modularity and lifecycle hooks
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular模块化和生命周期钩子
- en: Angular modularity with NgModules provides a great way to organize the code
    in a web application. Many third-party libraries, such as PrimeNG, Angular Material,
    Ionic, are distributed as NgModules. *Lifecycle hooks* allow us to perform custom
    logic at component level at a well-defined time. This section covers these major
    concepts in detail.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模块化与NgModule提供了一种很好的方式来组织Web应用程序中的代码。许多第三方库，如PrimeNG、Angular Material、Ionic，都是作为NgModule分发的。*生命周期钩子*允许我们在组件级别在定义良好的时间执行自定义逻辑。本节详细介绍了这些主要概念。
- en: Modules and bootstrapping
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和引导
- en: 'Angular modules make it possible to consolidate components, directives, services,
    pipes, and many more into cohesive blocks of functionality. Angular''s code is
    modularized. Every module has its own functionality. There are `FormsModule`,
    `HttpModule`, `RouterModule`, and many other modules as well. What does a module
    look like? A module is a class annotated with the `@NgModule` decorator (imported
    from `@angular/core`). `@NgModule` takes a configuration object that tells Angular
    how to compile and run the module code. The most significant properties of the
    the configuration object are:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模块使得将组件、指令、服务、管道等等整合成功能块成为可能。Angular的代码是模块化的。每个模块都有自己的功能。有`FormsModule`、`HttpModule`、`RouterModule`以及许多其他模块。模块是什么样子？一个模块是一个用`@NgModule`装饰器注释的类（从`@angular/core`导入）。`@NgModule`接受一个配置对象，告诉Angular如何编译和运行模块代码。配置对象的最重要的属性是：
- en: '`declarations`: The array with components, directives, and pipes, which are
    implemented in that module and belong to that module.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarations`：组件、指令和管道的数组，这些组件、指令和管道在该模块中实现并属于该模块。'
- en: '`imports`: The array with dependencies in form of other modules which need
    to be made available to that module.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imports`：依赖项数组，以其他模块的形式需要在该模块中可用。'
- en: '`exports`: The array of components, directives, and pipes to be exported and
    permitted to be imported by another modules. The rest is private. This is the
    module''s public API and similar to how the `export` keyword works in ECMAScript
    modules.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`：要导出并允许被其他模块导入的组件、指令和管道的数组。其余部分是私有的。这是模块的公共API，类似于ECMAScript模块中`export`关键字的工作原理。'
- en: '`providers`: This is the array of services (service classes, factories, or
    values), which are available in that module. Providers are parts of the module
    and can be injected into components (inclusive sub-components), directives, and
    pipes defined within the module.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providers`：这是服务的数组（服务类、工厂或值），这些服务在该模块中可用。提供者是模块的一部分，可以被注入到组件（包括子组件）、指令和管道中。'
- en: '`bootstrap`: Every Angular application has at least one module--the root module.
    The `bootstrap` property is only used in the root module and contains the component
    which should be instantiated first when bootstrapping the application.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap`：每个Angular应用程序至少有一个模块--根模块。`bootstrap`属性仅在根模块中使用，并包含在启动应用程序时应首先实例化的组件。'
- en: '`entryComponents`: This is the array of components that Angular generates component
    factories for. Normally, you need to register a component as an entry component
    when it is intended to be created dynamically at runtime. Such components can
    not be figured out automatically by Angular at template compilation time.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entryComponents`：这是Angular为其生成组件工厂的组件数组。通常，当组件打算在运行时动态创建时，您需要将组件注册为入口组件。这样的组件无法在模板编译时由Angular自动确定。'
- en: 'A typical module configuration for any separate example in this book looks
    something like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中任何单独示例的典型模块配置看起来像这样：
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`BrowserModule` is needed to get access to the browser-specific renderers and
    Angular standard directives such as `ngIf` and `ngFor`. Don''t import `BrowserModule`
    in any other modules except the root module. Feature modules and lazy-loaded modules
    should import `CommonModule` instead.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`BrowserModule`才能访问特定于浏览器的渲染器和Angular标准指令，如`ngIf`和`ngFor`。除了根模块之外，不要在其他模块中导入`BrowserModule`。功能模块和延迟加载模块应该导入`CommonModule`。
- en: 'The following is an example of how to bootstrap an Angular application in the
    JIT mode (just in time compilation):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在JIT模式（即时编译）中引导Angular应用程序的示例：
- en: '[PRE88]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the **ahead-of-time** mode (**AOT** compilation), you need to provide a
    factory class. To generate the factory class, you must run the `ngc` compiler
    instead of the TypeScript `tsc` compiler. In the last two sections of this chapter,
    you will see how to use AOT with Webpack and Angular CLI. The bootstrapping code
    in the AOT mode looks like the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在**提前编译**模式（**AOT**编译）中，您需要提供一个工厂类。要生成工厂类，您必须运行`ngc`编译器，而不是TypeScript的`tsc`编译器。在本章的最后两节中，您将看到如何在Webpack和Angular
    CLI中使用AOT。AOT模式中的引导代码如下：
- en: '[PRE89]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Templates with bindings written in Angular need to be compiled. With AOT, the
    compiler runs once at build time. With JIT, it runs every time at runtime. Browsers
    load a pre-compiled version of the application much faster and there is no need
    to download the Angular compiler if the app is already compiled.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular编写的绑定模板需要进行编译。使用AOT，编译器在构建时只运行一次。使用JIT，它在运行时每次都会运行。浏览器加载应用程序的预编译版本速度更快，如果应用程序已经编译，则无需下载Angular编译器。
- en: 'Modules can also be lazy loaded when they get requested (on demand). This approach
    reduces the size of web resources loaded on initial page display. The page appears
    faster. If you want to enable lazy loading, you have to configure the router to
    load the module lazy. All you need is a `path` object with a `loadChildren` property,
    which points to the path and name of the lazy loaded module:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可以在请求时（按需）进行延迟加载。这种方法减少了初始页面显示时加载的Web资源的大小。页面显示更快。如果要启用延迟加载，您必须配置路由器以延迟加载模块。您只需要一个具有`loadChildren`属性的`path`对象，该属性指向延迟加载模块的路径和名称：
- en: '[PRE90]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note that the value of `loadChildren` property is a string. Furthermore, the
    module importing this router configuration should not declare the lazy loaded
    module as dependency in the `imports` property of the configuration object.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`loadChildren`属性的值是一个字符串。此外，导入此路由器配置的模块不应在配置对象的`imports`属性中声明延迟加载模块作为依赖项。
- en: Lifecycle hooks
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: 'Angular components come with lifecycle hooks, which get executed at specific
    times in the component''s life. For this purpose, Angular offers different interfaces.
    Each interface has a method of the same name as the interface name with the prefix
    `ng`. Each method is executed when the corresponding lifecycle event occurs. They
    are also called lifecycle hook methods. Angular calls the lifecycle hook methods
    in the following sequence after the constructor has been called:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件具有生命周期钩子，在组件的生命周期中的特定时间执行。为此，Angular提供了不同的接口。每个接口都有与接口名称相同的方法，前缀为`ng`。每个方法在对应的生命周期事件发生时执行。它们也被称为生命周期钩子方法。在构造函数被调用后，Angular按以下顺序调用生命周期钩子方法：
- en: '| **The lifecycle hook method** | **Purpose and timing** |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **生命周期钩子方法** | **目的和时机** |'
- en: '| `ngOnChanges` | This is called whenever one or more data-bound input properties
    change. This method is called on initial changes (before `ngOnInit`) and any other
    subsequent changes. This method has one parameter--an object with keys of type
    `string` and values of type `SimpleChange`. The keys are the component''s property
    names. The `SimpleChange` object contains current and previous values. A usage
    example is shown next. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnChanges` | 每当一个或多个数据绑定的输入属性发生变化时都会调用此方法。此方法在初始更改（在`ngOnInit`之前）和任何后续更改时都会被调用。此方法有一个参数--一个具有`string`类型键和`SimpleChange`类型值的对象。键是组件的属性名称。`SimpleChange`对象包含当前值和先前值。下面展示了一个用法示例。
    |'
- en: '| `ngOnInit` | This is called once, after the first `ngOnChanges`. Note that
    the constructor of a component should only be used for dependency injection because
    data-bound input values are not yet set in the constructor. Everything else should
    be moved to the `ngOnInit` hook. A usage example is shown next. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnInit` | 在第一次`ngOnChanges`之后调用一次。请注意，组件的构造函数应该只用于依赖注入，因为在构造函数中尚未设置数据绑定的输入值。其他所有内容应该移动到`ngOnInit`钩子中。下面展示了一个用法示例。
    |'
- en: '| `ngDoCheck` | This is called during every change detection run. It is a good
    place for custom logic, which allows us to do a fine-grained check of which property
    on our object changed. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `ngDoCheck` | 在每次变更检测运行时调用此方法。这是一个很好的地方进行自定义逻辑，允许我们对对象的哪个属性进行细粒度的检查。 |'
- en: '| `ngAfterContentInit` | This is called once, after Angular puts external content
    into the component''s view. A placeholder for any external content is marked with
    the `ngContent` directive (the `ng-content` tag). A usage example of the `ngContent`
    directive is demonstrated afterwards. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterContentInit` | 在Angular将外部内容放入组件视图之后调用一次。使用`ngContent`指令（`ng-content`标签）标记任何外部内容的占位符。之后演示了`ngContent`指令的用法示例。
    |'
- en: '| `ngAfterContentChecked` | This is called after Angular checks the content
    put into the component''s view. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterContentChecked` | 在Angular检查放入组件视图中的内容之后调用此方法。 |'
- en: '| `ngAfterViewInit` | This is called once, after Angular initializes the component''s
    and child''s views. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterViewInit` | 在Angular初始化组件和子视图之后调用一次。 |'
- en: '| `ngAfterViewChecked` | This is called after Angular checks the component''s
    views and child views. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `ngAfterViewChecked` | 在Angular检查组件的视图和子视图之后调用此方法。 |'
- en: '| `ngOnDestroy` | This is called just before Angular destroys the component''s
    instance. This happens when you remove the component with built-in structural
    directives such as `ngIf`, `ngFor`, `ngSwitch`, or when you navigate to another
    view. This is a good place for cleanup operations such as unsubscribing observables,
    detaching event handlers, canceling interval timers, and so on. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `ngOnDestroy` | 在Angular销毁组件实例之前调用此方法。当您使用内置结构指令（如`ngIf`、`ngFor`、`ngSwitch`）删除组件或导航到另一个视图时会发生这种情况。这是一个很好的地方进行清理操作，比如取消订阅可观察对象、分离事件处理程序、取消间隔定时器等。
    |'
- en: 'Let''s see an example of how to use `ngOnInit` and `ngOnChanges`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何使用`ngOnInit`和`ngOnChanges`的例子：
- en: '[PRE91]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Usage in HTML:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中的使用：
- en: '[PRE92]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let''s now see how to use the `ngContent` directive:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用`ngContent`指令：
- en: '[PRE93]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Usage in HTML:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中的使用：
- en: '[PRE94]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'After the component''s initialization, the following hook methods get always
    executed on every change detection run: `ngDoCheck` -> `ngAfterContentChecked`
    -> `ngAfterViewChecked` -> `ngOnChanges`.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件初始化之后，以下钩子方法始终在每次变更检测运行时执行：`ngDoCheck` -> `ngAfterContentChecked` -> `ngAfterViewChecked`
    -> `ngOnChanges`。
- en: Running PrimeNG with SystemJS
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SystemJS运行PrimeNG
- en: PrimeNG ([https://www.primefaces.org/primeng](https://www.primefaces.org/primeng))
    is an open source library of rich UI components for Angular 2+. PrimeNG is derived
    from PrimeFaces--the most popular **JavaServer Faces** (**JSF**) component suite.
    If you know PrimeFaces, you will feel at home with PrimeNG due to similar API.
    Currently, PrimeNG has 80+ visually stunning widgets that are easy to use. They
    are divided into several groups such as input and select components, buttons,
    data iteration components, panels, overlays, menus, charts, messages, multimedia,
    drag-and-drop, and miscellaneous. There are also 22+ free and premium themes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG（[https://www.primefaces.org/primeng](https://www.primefaces.org/primeng)）是一个丰富的Angular
    2+ UI组件的开源库。PrimeNG源自PrimeFaces，是最受欢迎的JavaServer Faces（JSF）组件套件。如果你了解PrimeFaces，你会因为API相似而觉得PrimeNG很熟悉。目前，PrimeNG拥有80多个外观华丽且易于使用的小部件。它们分为几个组，如输入和选择组件、按钮、数据迭代组件、面板、覆盖层、菜单、图表、消息、多媒体、拖放和其他。还有22个免费和高级主题。
- en: PrimeNG fits perfectly with the mobile and desktop development because it is
    a responsive and touch optimized framework. PrimeNG showcase is a good place to
    play with the components, try them in action, study documentation, and code snippets.
    Anyway, we need a systematic approach for getting started with PrimeNG. This is
    what this book tries to convey. In this chapter, we will set up and run PrimeNG
    with SystemJS ([https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs))--universal
    module loader supporting various module formats. SystemJS is a good choice for
    learning purposes if you want to try TypeScript, Angular, PrimeNG code snippets,
    or write small applications in Plunker ([https://plnkr.co](https://plnkr.co))
    because it can load your files, transpile them (if needed) and resolve module
    dependencies on-the-fly. In the real applications, you should choose Webpack or
    Angular CLI-based setups that have more power and advanced configurations. They
    also bundle your application in order to reduce the amount of HTTP requests. Those
    setups will be discussed in the next two sections.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG非常适合移动和桌面开发，因为它是一个响应式和触摸优化的框架。PrimeNG展示是一个很好的地方，可以在其中使用组件，尝试它们的功能，学习文档和代码片段。无论如何，我们需要一个系统化的方法来开始使用PrimeNG。这就是这本书试图传达的内容。在本章中，我们将使用SystemJS（[https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)）来设置和运行PrimeNG--这是一个支持各种模块格式的通用模块加载器。如果你想尝试TypeScript、Angular、PrimeNG代码片段或在Plunker（[https://plnkr.co](https://plnkr.co)）中编写小型应用程序，SystemJS是一个很好的选择，因为它可以动态加载你的文件，转译它们（如果需要）并解析模块依赖关系。在真实的应用程序中，你应该选择Webpack或基于Angular
    CLI的设置，它们具有更强大和高级的配置。它们还会打包你的应用程序，以减少HTTP请求的数量。这些设置将在接下来的两个部分中讨论。
- en: The SystemJS configuration for Angular
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的SystemJS配置
- en: 'First of all, you need to install Node.js and npm, which we already mentioned
    in the *TypeScript fundamentals you need to know* section. Why do we need npm?
    In HTML and SystemJS configuration, we could reference all dependencies from [https://unpkg.com](https://unpkg.com).
    But, we prefer to install all dependencies locally so that IDEs are fine with
    autocompletion. For instance, to install SystemJS, you have to run the following
    command in a console of your choice:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装 Node.js 和 npm，我们已经在 *你需要了解的 TypeScript 基础知识* 部分提到过。为什么我们需要 npm？在 HTML
    和 SystemJS 配置中，我们可以从 [https://unpkg.com](https://unpkg.com) 引用所有依赖项。但是，我们更喜欢本地安装所有依赖项，这样
    IDE 可以很好地支持自动完成。例如，要安装 SystemJS，你需要在你选择的控制台中运行以下命令：
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: For readers, we created a complete demo seed project where all dependencies
    are listed in the `package.json` file.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读者，我们创建了一个完整的演示种子项目，其中所有依赖项都在 `package.json` 文件中列出。
- en: The complete seed project with PrimeNG and SystemJS is available on GitHub at
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的带有 PrimeNG 和 SystemJS 的种子项目可以在 GitHub 上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-systemjs-setup)。'
- en: 'All dependencies in the seed project can be installed by running `npm install`
    in the project root. If you explore the `index.html` file, you can see that the
    SystemJS library is included in the `<head>` tag. After that, it becomes available
    as a global `System` object, which exposes two static methods: `System.import()`
    and `System.config()`. The first method is used to load a module. It accepts one
    argument--a module name, which can be either a file path or a logical name mapped
    to the file path. The second method is used for setting configuration. It accepts
    a configuration object as an argument. Normally, the configuration is placed within
    the `systemjs.config.js` file. Complete scripts to be included in `index.html`
    are TypeScript compiler, Polyfills, and SystemJS related files. The bootstrapping
    occurs by executing `System.import(''app'')`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在种子项目中，所有依赖项都可以通过在项目根目录运行 `npm install` 来安装。如果你探索 `index.html` 文件，你会发现 SystemJS
    库被包含在 `<head>` 标签中。之后，它作为全局 `System` 对象可用，它公开了两个静态方法：`System.import()` 和 `System.config()`。第一个方法用于加载模块。它接受一个参数--模块名称，可以是文件路径，也可以是逻辑名称映射到文件路径。第二个方法用于设置配置。它接受一个配置对象作为参数。通常，配置放在
    `systemjs.config.js` 文件中。要包含在 `index.html` 中的完整脚本包括 TypeScript 编译器、Polyfills 和
    SystemJS 相关文件。引导过程是通过执行 `System.import('app')` 完成的：
- en: '[PRE96]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'An excerpt from the configuration object for Angular projects is listed here:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Angular 项目的配置对象摘录：
- en: '[PRE97]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A brief explanation gives an overview of the most important configuration options:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 简要说明提供了最重要的配置选项概述：
- en: The `transpiler` option specifies a transpiler for TypeScript files. Possible
    values are `typescript`, `babel`, and `traceur`. The transpilation happens in
    browser on-the-fly.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transpiler` 选项指定了 TypeScript 文件的转译器。可能的值包括 `typescript`、`babel` 和 `traceur`。转译发生在浏览器中，实时进行。'
- en: The `typescriptOptions` option sets the TypeScript compiler options.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typescriptOptions` 选项设置了 TypeScript 编译器选项。'
- en: The `map` option creates aliases for module names. When you import a module,
    the module name is replaced by an associated value according to the mapping. In
    the configuration, all entry points for Angular files are in UMD format.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 选项为模块名称创建别名。当你导入一个模块时，根据映射，模块名称会被替换为关联的值。在配置中，所有 Angular 文件的入口点都以 UMD
    格式存在。'
- en: The `packages` option sets meta information for imported modules. For example,
    you can set the main entry point of the module. Furthermore, you can specify default
    file extensions to be able to omit them when importing.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages`选项为导入的模块设置了元信息。例如，您可以设置模块的主入口点。此外，您可以指定默认文件扩展名，以便在导入时能够省略它们。'
- en: Adding PrimeNG dependencies
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加PrimeNG依赖
- en: 'Every project using PrimeNG needs the locally installed library. You can achieve
    this by running the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用PrimeNG的项目都需要本地安装库。您可以通过运行以下命令来实现这一点：
- en: '[PRE98]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As a result, PrimeNG is installed in your project root under the `node_modules`
    folder as well as added in `package.json` as a dependency. Here again, you can
    skip this step if you use the seed project hosted on GitHub--just run `npm install`.
    The next step is to add two new entries to the SystemJS configuration file. For
    shorter `import` statements, it is recommended to map `primeng` to `node_modules/primeng`.
    PrimeNG components are distributed as CommonJS modules ending with `.js`. That
    means we should set the default extension too:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，PrimeNG被安装在项目根目录下的`node_modules`文件夹中，并在`package.json`中作为依赖项添加。在这里，如果您使用托管在GitHub上的种子项目，可以跳过这一步--只需运行`npm
    install`。下一步是向SystemJS配置文件添加两个新条目。为了更短的`import`语句，建议将`primeng`映射到`node_modules/primeng`。PrimeNG组件以`.js`结尾的CommonJS模块形式分发。这意味着我们也应该设置默认扩展名：
- en: '[PRE99]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, you are able to import PrimeNG modules from `primeng/primeng`. For instance,
    write this line to import `AccordionModule` and `MenuItem`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从`primeng/primeng`导入PrimeNG模块。例如，写入以下行以导入`AccordionModule`和`MenuItem`：
- en: '[PRE100]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This way of importing is not recommended in production because all other available
    components will be loaded as well. Instead of that, only import what you need
    using a specific component path:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中不推荐这种导入方式，因为所有其他可用的组件也将被加载。相反，只需使用特定的组件路径导入所需的内容：
- en: '[PRE101]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the demo application, we will only use `ButtonModule` and `InputTextModule`
    so that we need to import them as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示应用程序中，我们只会使用`ButtonModule`和`InputTextModule`，因此需要按照以下方式导入它们：
- en: '[PRE102]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The demo project we want to create consists of application code and assets.
    A detailed description of every file would go beyond the scope of this book. We
    will only show the project structure:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建的演示项目由应用程序代码和资产组成。对每个文件的详细描述将超出本书的范围。我们只会展示项目结构：
- en: '![](assets/4605bc24-7519-403c-a3fe-6c70f72f6293.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4605bc24-7519-403c-a3fe-6c70f72f6293.png)'
- en: 'A typically PrimeNG application needs a theme. We would like to take the B*ootstrap*
    theme. The file `index.html` must have three CSS dependencies included within
    the `<head>` tag--the theme, the PrimeNG file, and the FontAwesome file for SVG
    icons ([http://fontawesome.io](http://fontawesome.io)):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的PrimeNG应用程序需要一个主题。我们想要使用B*ootstrap*主题。文件`index.html`必须在`<head>`标签内包含三个CSS依赖项--主题、PrimeNG文件和用于SVG图标的FontAwesome文件（[http://fontawesome.io](http://fontawesome.io)）：
- en: '[PRE103]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'All FontAwesome files were placed under `src/assets/icons`. Mostly PrimeNG
    components are native, but there is a list of components with third-party dependencies.
    These are explained in the following table:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 所有FontAwesome文件都放在`src/assets/icons`下。大多数PrimeNG组件是原生的，但也有一些具有第三方依赖的组件。这些在下表中有解释：
- en: '| **Component** | **Dependency** |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **依赖** |'
- en: '| Schedule | FullCalendar and Moment.js |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 日程安排 | FullCalendar和Moment.js |'
- en: '| Editor | Quill editor |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 编辑器 | Quill编辑器 |'
- en: '| GMap | Google Maps |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| GMap | 谷歌地图 |'
- en: '| Charts | Charts.js |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 图表 | Charts.js |'
- en: '| Captcha | Google Recaptcha |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 验证码 | 谷歌验证码 |'
- en: Exact links to those dependencies will be shown later in concrete examples.
    For now, we have finished our setup. Let's start our first application by running
    `npm start` in the project root.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖的确切链接将在具体示例中显示。目前，我们已经完成了设置。让我们通过在项目根目录中运行`npm start`来启动我们的第一个应用程序。
- en: 'The application gets launched in browser with two PrimeNG components, as shown
    in the following screenshot. As you can see, a lot of single web resources (CSS
    and JS files) are being loaded in the browser:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在浏览器中启动，显示了两个PrimeNG组件，如下截图所示。正如您所看到的，浏览器中加载了许多单个网络资源（CSS和JS文件）：
- en: '![](assets/bb6b4b11-9524-4017-8463-5c0a98ca5e1b.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb6b4b11-9524-4017-8463-5c0a98ca5e1b.png)'
- en: Setting up PrimeNG project with Webpack
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Webpack设置PrimeNG项目
- en: Webpack ([https://webpack.js.org](https://webpack.js.org)) is a de facto standard
    bundler for single-page applications. It analyzes dependencies between JavaScript
    modules, assets (styles, icons, and images) as well as other files in your application
    and bundles everything together. In Webpack, everything is a module . You can,
    for example, import a CSS file like a JavaScript file using `require('./myfile.css')`
    or `import './myfile.css'`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack ([https://webpack.js.org](https://webpack.js.org))是单页应用程序的事实标准捆绑器。它分析JavaScript模块、资产（样式、图标和图像）以及应用程序中的其他文件之间的依赖关系，并将所有内容捆绑在一起。在Webpack中，一切都是一个模块。例如，您可以像使用`require('./myfile.css')`或`import
    './myfile.css'`一样导入CSS文件。
- en: Webpack can figure out the right processing strategy for imported files by means
    of the file extension and associated loader. It is not always reasonable to build
    one big bundle file. Webpack has various plugins to split your code and generate
    multiple bundle files. It can also load parts of your application asynchronously
    on demand (lazy loading). All these features make it a power tool. In this section,
    we will give a high-level overview of Webpack 2 core concepts and show essential
    steps for creating a Webpack-based Angular, PrimeNG application.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack可以通过文件扩展名和关联的加载程序找出导入文件的正确处理策略。构建一个大捆绑文件并不总是合理的。Webpack有各种插件来分割您的代码并生成多个捆绑文件。它还可以在需要时异步加载应用程序的部分内容（延迟加载）。所有这些功能使它成为一个强大的工具。在本节中，我们将对Webpack
    2的核心概念进行高级概述，并展示创建基于Webpack的Angular、PrimeNG应用程序的基本步骤。
- en: The complete seed project with PrimeNG and Webpack is available on GitHub at
    [https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG和Webpack的完整种子项目可在GitHub上找到[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-webpack-setup)。
- en: The project structure was kept the same as in the SystemJS-based setup.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构与基于SystemJS的设置保持一致。
- en: Entry point and output
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入口点和输出
- en: JavaScript and other files imported into each other are closely interwoven.
    Webpack creates a graph of all such dependencies. The starting point of this graph
    is called *entry point*. An entry point tells Webpack where to start to resolve
    all dependencies and creates a bundle. Entry points are created in the Webpack
    configuration file using the `entry` property. In the seed project on GitHub,
    we have two configuration files, one for the development mode (`webpack.dev.js`)
    and one for the production (`webpack.prod.js`) mode, each with two entry points.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript和其他文件相互导入，紧密交织在一起。Webpack创建了所有这些依赖关系的图形。这个图形的起点被称为*入口点*。入口点告诉Webpack从哪里开始解析所有依赖关系并创建一个捆绑包。入口点是在Webpack配置文件中使用`entry`属性创建的。在GitHub上的种子项目中，我们有两个配置文件，一个用于开发模式(`webpack.dev.js`)，一个用于生产(`webpack.prod.js`)模式，每个都有两个入口点。
- en: 'In the development mode, we use the main entry point for JIT compilation. The
    `main.jit.ts` file contains quite normally bootstrapping code. The second entry
    point combines files from `core-js` (Polyfills for modern ECMAScript features)
    and `zone.js` (the basis for Angular''s change detection):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式中，我们使用JIT编译的主入口点。`main.jit.ts`文件包含相当正常的引导代码。第二个入口点组合了来自`core-js`（现代ECMAScript功能的Polyfills）和`zone.js`（Angular变更检测的基础）的文件：
- en: '[PRE104]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In the production mode, we use the main entry point for AOT compilation. JIT
    and AOT were mentioned in the *Angular modularity and lifecycle hooks* section:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产模式中，我们使用AOT编译的主入口点。JIT和AOT在*Angular模块化和生命周期钩子*部分提到过：
- en: '[PRE105]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `output` property tells Webpack where to bundle your application. You can
    use placeholders such as `[name]` and `[chunkhash]` to define what the names of
    output files look like. The `[name]` placeholder will be replaced by the name
    defined in the `entry` property. The `[chunkhash]` placeholder will be replaced
    by the hash of the file content at project build time. The `chunkFilename` option
    determines the names of on-demand (lazy) loaded chunks--files loaded by `System.import()`.
    In the development mode, we don''t use `[chunkhash]` because of performance issues
    during hash generation:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`output`属性告诉Webpack在哪里捆绑您的应用程序。您可以使用诸如`[name]`和`[chunkhash]`之类的占位符来定义输出文件的名称。`[name]`占位符将被`entry`属性中定义的名称替换。`[chunkhash]`占位符将在项目构建时被文件内容的哈希值替换。`chunkFilename`选项确定按需（延迟）加载的块的名称
    - 由`System.import()`加载的文件。在开发模式中，我们不使用`[chunkhash]`，因为哈希生成期间会出现性能问题：'
- en: '[PRE106]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `[chunkhash]` placeholder is used in the production mode to achieve so
    called *long term caching*--every file gets cached in the browser and will be
    automatically invalidated and reloaded when the hash changes:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`[chunkhash]` 占位符在生产模式中用于实现所谓的“长期缓存” - 每个文件都会在浏览器中被缓存，并在哈希值更改时自动失效和重新加载：'
- en: '[PRE107]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: A hash in the filename changes every compilation when the file content is changed.
    That means, files with hashes in names can not be included manually in the HTML
    file (`index.html`). `HtmlWebpackPlugin` ([https://github.com/jantimon/html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin))
    helps us to include generated bundles with `<script>` or `<link>` tags in the
    HTML. The seed project makes use of this plugin.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名中的哈希值在文件内容更改时会在每次编译时更改。这意味着，具有哈希值的文件名不能手动包含在HTML文件（`index.html`）中。`HtmlWebpackPlugin`（[https://github.com/jantimon/html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)）帮助我们在HTML中包含使用`<script>`或`<link>`标签生成的捆绑包。种子项目利用了这个插件。
- en: Loaders and plugins
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载程序和插件
- en: 'Webpack only understands JavaScript files as modules. Every other file (`.css`,
    `.scss`, `.json`, `.jpg`, and many more) can be transformed into a module while
    importing. *Loaders* transform these files and add them to the dependency graph.
    Loader configuration should be done under `module.rules`. There are two main options
    in the loader configuration:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack只能将JavaScript文件视为模块。其他每个文件（`.css`、`.scss`、`.json`、`.jpg`等）在导入时都可以转换为模块。*加载程序*转换这些文件并将它们添加到依赖图中。加载程序配置应该在`module.rules`下完成。加载程序配置中有两个主要选项：
- en: The `test` property with a regular expression for testing files the loader should
    be applied to
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试加载程序应用于的文件的正则表达式的`test`属性
- en: '`loader` or `use` property with the concrete loader name'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体加载程序名称的`loader`或`use`属性
- en: '[PRE108]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Note that loaders should be registered in `package.json` so that they can be
    installed under `node_modules`. Webpack homepage has a good overview of some popular
    loaders ([https://webpack.js.org/loaders](https://webpack.js.org/loaders)). For
    TypeScript files, it is recommended to use the following sequence of loaders in
    the development mode:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，加载器应该在`package.json`中注册，以便它们可以在`node_modules`下安装。Webpack主页有一份关于一些流行加载器的很好的概述（[https://webpack.js.org/loaders](https://webpack.js.org/loaders)）。对于TypeScript文件，在开发模式下，建议使用以下加载器顺序：
- en: '[PRE109]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Multiple loaders are applied from right to left. The `angular2-template-loader`
    searches for `templateUrl` and `styleUrls` declarations and inlines HTML and styles
    inside of the `@Component` decorator. The `awesome-typescript-loader` is mostly
    for speeding up the compilation process. For AOT compilation (production mode),
    another configuration is required:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 多个加载器从右到左应用。`angular2-template-loader`搜索`templateUrl`和`styleUrls`声明，并将HTML和样式内联到`@Component`装饰器中。`awesome-typescript-loader`主要用于加快编译过程。对于AOT编译（生产模式），需要另一种配置：
- en: '[PRE110]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Webpack has not only loaders, but also *plugins* which take responsibility
    for custom tasks beyond loaders. Custom tasks could be the compression of assets,
    extraction of CSS into a separate file, generation of a source map, definition
    of constants configured at compile time, and so on. One of the helpful plugins
    used in the seed project is the `CommonsChunkPlugin`. It generates chunks of common
    modules shared between entry points and splits them into separate bundles. This
    results in page speed optimizations as the browser can quickly serve the shared
    code from cache. In the seed project, we moved Webpack''s runtime code to a separate
    `manifest` file in order to support long-term caching. This will avoid hash recreation
    for vendor files when only application files are changed:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack不仅有加载器，还有*插件*，负责加载器之外的自定义任务。自定义任务可能包括压缩资产、将CSS提取到单独的文件中、生成源映射、在编译时定义常量等等。种子项目中使用的一个有用的插件是`CommonsChunkPlugin`。它生成共享模块的块，并将它们拆分成单独的包。这样可以优化页面速度，因为浏览器可以快速地从缓存中提供共享的代码。在种子项目中，我们将Webpack的运行时代码移动到一个单独的`manifest`文件中，以支持长期缓存。这样当只有应用程序文件发生变化时，就可以避免对供应商文件进行哈希重建：
- en: '[PRE111]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'As you can see, configuration of plugins is done in the `plugins` option. There
    are two plugins for production configuration yet to be mentioned here. The `AotPlugin`
    enables AOT compilation. It needs to know the path of `tsconfig.json` and the
    path with module class used for bootstrapping:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，插件的配置是在`plugins`选项中完成的。还有两个生产配置中尚未提到的插件。`AotPlugin`启用AOT编译。它需要知道`tsconfig.json`的路径和用于引导的模块类的路径：
- en: '[PRE112]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '`UglifyJsPlugin` is used for code minification:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`UglifyJsPlugin`用于代码最小化：'
- en: '[PRE113]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Adding PrimeNG, CSS, and SASS
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加PrimeNG、CSS和SASS
- en: 'It''s time to finish the setup. First, make sure that you have PrimeNG and
    FontAwesome dependencies in the `package.json` file. For example:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候完成设置了。首先，确保`package.json`文件中有PrimeNG和FontAwesome的依赖项。例如：
- en: '[PRE114]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Second, bundle all CSS files into one file. This task is accomplished by `ExtractTextPlugin`,
    which is needed for loaders and plugin configuration:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，将所有CSS文件捆绑成一个文件。这个任务由`ExtractTextPlugin`完成，它需要加载器和插件配置：
- en: '[PRE115]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: For production, you should set the filename to `"[name].[chunkhash].css"`. The
    bundled CSS file gets automatically included into `index.html` by `HtmlWebpackPlugin`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，应将文件名设置为`"[name].[chunkhash].css"`。捆绑的CSS文件会被`HtmlWebpackPlugin`自动包含到`index.html`中。
- en: 'We prefer not to use `styleUrls` in the components. The seed project imports
    a CSS und SASS files in one place--inside of `main.scss` file located under `src/assets/css`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢在组件中不使用`styleUrls`。种子项目在一个地方导入了CSS和SASS文件——在`src/assets/css`目录下的`main.scss`文件中：
- en: '[PRE116]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Note that the tilde `~` points to the `node_modules`. More precisely the Sass
    preprocessor interprets it as the `node_modules` folder. Sass is explained in
    [Chapter 2](f3278626-cfa5-4c6f-8ff2-97df3a45778f.xhtml), *Theming Concepts and
    Layouts*. The `main.scss` file should be imported in the entry points `main.jit.ts`
    and `main.aot.ts`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，波浪号`~`指向`node_modules`。更准确地说，Sass预处理器将其解释为`node_modules`文件夹。Sass在[第2章](f3278626-cfa5-4c6f-8ff2-97df3a45778f.xhtml)中有解释，*主题概念和布局*。`main.scss`文件应该在入口点`main.jit.ts`和`main.aot.ts`中导入：
- en: '[PRE117]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Webpack takes care of the rest. There are more goodies from Webpack--a development
    server with live reloading `webpack-dev-server` ([https://webpack.js.org/configuration/dev-server](https://webpack.js.org/configuration/dev-server)).
    It detects changes made to files and recompiles automatically. You can start it
    with `npm start` or `npm run start:prod`. These commands represent npm scripts:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack会处理剩下的事情。Webpack还有更多好东西--一个带有实时重新加载的开发服务器`webpack-dev-server` ([https://webpack.js.org/configuration/dev-server](https://webpack.js.org/configuration/dev-server))。它会自动检测文件的更改并重新编译。您可以使用`npm
    start`或`npm run start:prod`来启动它。这些命令代表npm脚本：
- en: '[PRE118]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: When running `webpack-dev-server`, the compiled output is served from memory.
    This means, the application being served is not located on disk in the `dist`
    folder.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`webpack-dev-server`时，编译输出是从内存中提供的。这意味着提供的应用程序不位于`dist`文件夹中的磁盘上。
- en: That's all. More configuration options for unit and end-to-end testing will
    be added in [Chapter 10](b5fd2c81-a93b-4c32-a2a6-4978019f283a.xhtml), *Creating
    Robust Applications*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。更多关于单元测试和端到端测试的配置选项将在[第10章](b5fd2c81-a93b-4c32-a2a6-4978019f283a.xhtml)中添加，*创建健壮的应用程序*。
- en: Setting up PrimeNG project with Angular CLI
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular CLI设置PrimeNG项目
- en: 'Angular CLI ([https://cli.angular.io](https://cli.angular.io)) is a comfortable
    tool to create, run, and test Angular applications out of the box. It generates
    the code in no time. We will describe some useful commands and show you how to
    integrate PrimeNG with Angular CLI. First, the tool should be installed globally:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI ([https://cli.angular.io](https://cli.angular.io))是一个方便的工具，可以立即创建、运行和测试Angular应用程序。它可以在短时间内生成代码。我们将描述一些有用的命令，并向您展示如何将PrimeNG与Angular
    CLI集成。首先，应该全局安装该工具：
- en: '[PRE119]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'When it is installed, every command can be executed in the console with prepended
    `ng`. For instance, to create a new project, run `ng new [projectname] [options]`.
    Let''s create one. Navigate to a directory that will be the parent directory of
    your project and run the following command:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，每个命令都可以在控制台中使用`ng`前缀执行。例如，要创建一个新项目，请运行`ng new [projectname] [options]`。让我们创建一个。转到一个将成为项目父目录的目录，并运行以下命令：
- en: '[PRE120]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This command will create an Angular 4 project within the folder `primeng-angularcli-setup`.
    The option `--style` sets a CSS preprocessor. Here, we want to use SASS files
    and need a Sass preprocessor. The preprocessor compiles SASS files whenever we
    make changes. You don't need to set a preprocessor if you only have CSS files.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在`primeng-angularcli-setup`文件夹中创建一个Angular 4项目。选项`--style`设置了CSS预处理器。在这里，我们想要使用SASS文件并需要一个Sass预处理器。预处理器在我们进行更改时编译SASS文件。如果只有CSS文件，则不需要设置预处理器。
- en: The complete preconfigured seed project with PrimeNG and Angular CLI is available
    on GitHub at
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的预配置种子项目与PrimeNG和Angular CLI可在GitHub上找到
- en: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup).'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup](https://github.com/ova2/angular-development-with-primeng/tree/master/chapter1/primeng-angularcli-setup)。'
- en: 'The created project has the following top directories and files:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的项目具有以下顶级目录和文件：
- en: '| **Directory/file** | **Short description** |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| **目录/文件** | **简要描述** |'
- en: '| `e2e` | Folder with e2e tests (`.e2e-spec.ts` files) and page objects (`.po.ts`
    files). |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `e2e` | 包含e2e测试（`.e2e-spec.ts`文件）和页面对象（`.po.ts`文件）的文件夹。 |'
- en: '| `src` | Source code folder where the application code should be written.
    |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `src` | 应该编写应用程序代码的源代码文件夹。 |'
- en: '| `.angular-cli.json` | Set up configuration file. PrimeNG dependencies can
    be listed here. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `.angular-cli.json` | 设置配置文件。PrimeNG依赖项可以在此处列出。 |'
- en: '| `karma.conf.js` | Karma configuration file for unit testing. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `karma.conf.js` | 用于单元测试的Karma配置文件。 |'
- en: '| `protractor.conf.js` | Protractor configuration file for e2e testing. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `protractor.conf.js` | 用于端到端测试的Protractor配置文件。 |'
- en: '| `package.json` | Standard file for package management of npm-based projects.
    |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `package.json` | npm项目包管理的标准文件。 |'
- en: '| `tsconfig.json` | Settings for TypeScript compiler. |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `tsconfig.json` | TypeScript编译器的设置。 |'
- en: '| `tslint.json` | Settings for TSLint. |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `tslint.json` | TSLint的设置。 |'
- en: 'You can now start the application by typing the following:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过输入以下内容启动应用程序：
- en: '[PRE121]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This command will run a local server at `http://localhost:4200` by default.
    You will see the text app works! in the browser. The `ng serve` command uses `webpack-dev-server`
    internally. The server is running in the watch mode. It refreshes the page automatically
    when any changes occur. There are a lot of configuration options. You can, for
    example, set a custom port by the `--port` option. Refer to the official documentation
    for more details at [https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki).
    To compile the application into an output directory, run the following command:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将默认在`http://localhost:4200`上运行本地服务器。您将在浏览器中看到文本“app works!”。`ng serve`命令在内部使用`webpack-dev-server`。服务器以监视模式运行。当发生任何更改时，它会自动刷新页面。有很多配置选项。例如，您可以通过`--port`选项设置自定义端口。有关更多详细信息，请参阅官方文档[https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki)。要将应用程序编译到输出目录，请运行以下命令：
- en: '[PRE122]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The build artifacts will be stored in the `dist` directory.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 构建产物将存储在`dist`目录中。
- en: The `--prod` option in `ng build` or `ng serve` will minify the files and remove
    unused (dead) code. The `--aot` option will use AOT compilation and produce even
    more smaller and optimized artifacts.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ng build`或`ng serve`中使用`--prod`选项将对文件进行缩小，并删除未使用的（死）代码。`--aot`选项将使用AOT编译，并生成更小更优化的产物。
- en: To run unit and e2e tests, execute `ng test` and `ng e2e` commands, respectively.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行单元测试和端到端测试，请分别执行`ng test`和`ng e2e`命令。
- en: Generating scaffolding
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成脚手架
- en: 'Angular CLI allows us to generate components, services, directives, routes,
    pipes, and many more with `ng generate`. Here is how you would generate a component:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI允许我们使用`ng generate`生成组件、服务、指令、路由、管道等等。以下是如何生成一个组件：
- en: '[PRE123]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'For example, if we run the following command:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们运行以下命令：
- en: '[PRE124]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Four files will be generated and one updated. The produced output will be:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成四个文件并更新一个文件。生成的输出将是：
- en: '[PRE125]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The new component is registered in `app.module.ts` automatically. The generation
    of other scaffoldings is identical. For example, to generate a service, run this
    command:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 新组件将自动注册在`app.module.ts`中。其他脚手架的生成方式相同。例如，要生成一个服务，请运行以下命令：
- en: '[PRE126]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: There are plenty of useful options. You can set, for example, `--spec=false`
    to skip test file generation.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多有用的选项。例如，您可以设置`--spec=false`以跳过测试文件生成。
- en: Adding PrimeNG dependencies
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加PrimeNG依赖项
- en: 'Integrating PrimeNG with Angular CLI is straightforward. First, install and
    save the dependencies:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 将PrimeNG与Angular CLI集成非常简单。首先，安装并保存依赖项：
- en: '[PRE127]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Second, edit the `.angular-cli.json` file and add three more CSS files to the
    `styles` section. These are the same files as in the SystemJS- and Webpack-based
    setups:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，编辑`.angular-cli.json`文件，并将另外三个CSS文件添加到`styles`部分。这些文件与基于SystemJS和Webpack的设置相同：
- en: '[PRE128]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Now, you can import desired PrimeNG modules. Refer to the *Running PrimeNG with
    SystemJS* section to see how to import PrimeNG modules. In the seed project on
    GitHub, we have imported the `MessagesModule` and put some demo code into `message.component.html`
    and `message.component.ts`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以导入所需的PrimeNG模块。请参考*使用SystemJS运行PrimeNG*部分，了解如何导入PrimeNG模块。在GitHub上的种子项目中，我们已经导入了`MessagesModule`并将一些演示代码放入了`message.component.html`和`message.component.ts`中。
- en: '![](assets/030e2299-dbdf-4a52-a096-d608b39d0077.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/030e2299-dbdf-4a52-a096-d608b39d0077.png)'
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you got an overview of TypeScript and Angular concepts
    you need to understand for the upcoming chapters. TypeScript introduces types
    which help to recognize errors at development time. There are primitive types,
    types known from object-oriented programming languages, custom types, and so on.
    By default, TypeScript compiler always emits an JavaScript code, even in the presence
    of type errors. In this way, you can quickly migrate any existing JavaScript code
    to TypeScript just by renaming `.js` file to `.ts` without having to fix all compilation
    errors at once.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您对于即将到来的章节需要了解的TypeScript和Angular概念有了一个概述。TypeScript引入了类型，有助于在开发时识别错误。有原始类型，从面向对象编程语言中知道的类型，自定义类型等等。默认情况下，TypeScript编译器总是会在存在类型错误的情况下发出JavaScript代码。这样，您可以通过将`.js`文件重命名为`.ts`来快速将任何现有的JavaScript代码迁移到TypeScript，而无需一次性修复所有编译错误。
- en: A typically Angular application is written in TypeScript. Angular provides a
    component-based approach which decouples your UI logic from the application (business)
    logic. It implements a powerful dependency injection system that makes reusing
    services a breeze. Dependency injection also increases the code testability because
    you can easily mock your business logic. An Angular application consists of hierarchical
    components, which communicate with each other in various ways such as `@Input`,
    `@Output` properties, shared services, local variables, and so on.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Angular应用程序是用TypeScript编写的。Angular提供了基于组件的方法，将UI逻辑与应用程序（业务）逻辑解耦。它实现了一个强大的依赖注入系统，使得重用服务变得轻而易举。依赖注入还增加了代码的可测试性，因为您可以轻松地模拟您的业务逻辑。Angular应用程序由分层组件组成，它们以各种方式进行通信，如`@Input`，`@Output`属性，共享服务，本地变量等等。
- en: Angular is a modular framework. Module classes annotated with `@NgModule` provide
    a great way to keep the code clean and organized. Angular is flexible--lifecycle
    hooks allow us to perform custom logic at several stages in the in the component's
    life. Last but not least, it is fast due to smart change detection algorithm.
    Angular doesn't offer any rich UI components. It is just a platform for developing
    single page applications. You need a third-party library to create rich UI interfaces.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个模块化的框架。带有`@NgModule`注解的模块类提供了一个很好的方式来保持代码的清晰和有组织性。Angular是灵活的--生命周期钩子允许我们在组件的生命周期的几个阶段执行自定义逻辑。最重要的是，由于智能变更检测算法，它非常快速。Angular并不提供任何丰富的UI组件。它只是一个用于开发单页面应用的平台。您需要第三方库来创建丰富的UI界面。
- en: 'PrimeNG is a collection of such rich UI components for Angular 2+. In comparison
    with competitors, PrimeNG was created for enterprise applications and provides
    80+ components. Adding PrimeNG dependencies is easy done. You only need to add
    PrimeNG and FontAwesome dependencies to the `package.json` file, and three CSS
    files: `primeng.min.css`, `font-awesome.min.css`, and `theme.css` for any theme
    you like. The next chapter will cover the theming concept in detail.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: PrimeNG是Angular 2+的一组丰富UI组件。与竞争对手相比，PrimeNG是为企业应用程序创建的，并提供了80多个组件。添加PrimeNG依赖很容易。您只需要将PrimeNG和FontAwesome依赖添加到`package.json`文件中，以及三个CSS文件：`primeng.min.css`，`font-awesome.min.css`和您喜欢的任何主题的`theme.css`。下一章将详细介绍主题概念。
- en: An Angular and PrimeNG application consists of ES6 (ECMAScript 2015) modules.
    Modules can be exported and imported. All modules in an application build a dependency
    graph. Therefore, you need a specific tool to resolve such modules starting at
    some entry point(s) and to output a bundle. There are some tools doing this and
    other tasks such as loading modules on demand, and similar.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular和PrimeNG应用程序由ES6（ECMAScript 2015）模块组成。模块可以被导出和导入。应用程序中的所有模块构成一个依赖图。因此，您需要一个特定的工具来解析这些模块，从某些入口点开始，并输出一个捆绑包。有一些工具可以做到这一点，还有其他任务，比如按需加载模块等。
- en: In this chapter, SystemJS and Webpack loaders were discussed. SystemJS is only
    recommended for demo applications for the purpose of learning. Webpack-based builds
    are more sophisticated. Webpack has a combination of loaders for every file type
    and plugins. Plugins include useful behaviors into the Webpack build process,
    for example, creating common chunks, minification of web resources, copying files
    and directories, creating SVG sprites, and more. To quickly start the development
    in TypeScript and Angular, generate your projects with Angular CLI. This is a
    scaffolding tool, which makes it easy to create an application that works out
    of the box.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，讨论了SystemJS和Webpack加载器。SystemJS仅推荐用于演示应用程序以便学习目的。基于Webpack的构建更为复杂。Webpack具有针对每种文件类型的加载器和插件的组合。插件将有用的行为包含到Webpack构建过程中，例如创建公共块、网页资源的最小化、复制文件和目录、创建SVG精灵等等。要快速开始使用TypeScript和Angular进行开发，请使用Angular
    CLI生成项目。这是一个脚手架工具，可以轻松创建一个开箱即用的应用程序。
