- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Progressive Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will see the next evolutionary step for web applications:
    **progressive web applications** (**PWAs**). This term may not seem descriptive
    enough, but it refers to a group of technologies that create the general concept
    and can be implemented gradually or partially. The basic idea behind it is to
    bring a web application out of the context of the browser and implement it in
    any type of device, to act and behave as much as possible to a native application.
    This is done thanks to the implementation of new APIs in the browser engines,
    as well as integrations among the most popular operating systems for desktop and
    mobile devices. The starting point for a PWA is, of course, a **single-page**
    **application** (**SPA**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What makes a SPA a PWA, and which technologies are involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement manually a responsive SPA, manifest file, service workers,
    offline storage, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What *service* *workers* are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Vite plugins to automate the creation of PWAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test the readiness of your application using *Google Lighthouse*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the preceding list, we will concentrate on learning the scaffolding for
    several technologies, setting the foundation to use them later, implemented in
    detail in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173), *Data Flow Management*,
    and [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading with Web
    Workers*. By the end of these chapters, you will know how to create PWAs that
    make good use of today’s computing power, making them responsive, reliable, and
    performant.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this chapter, you will need the code examples
    found in the repository at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter06](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter06).
    The text code examples in this section may not be enough to create a working example,
    without the additional code from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://packt.link/SBZys](https://packt.link/SBZys)'
  prefs: []
  type: TYPE_NORMAL
- en: PWAs or installable SPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A PWA is not a single setting or technology, but a systematic enhancement of
    a web application to comply with certain conditions, be it either a **multi-page
    application** (**MPA**) or a SPA. However, they really shine and come to life
    when these technologies are applied to SPAs, giving us powerful applications that
    blend the line between online/offline and desktop or web. The term **progressive**
    used here has the same connotation as we have discussed previously when applied
    to the Vue framework—an incremental application of web technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'PWAs are then treated somehow specially by the browsers and the operating system.
    They can be installed alongside native or desktop applications and manage network
    communications (to send, receive, cache files, and even push notifications from
    the server). At this point, it is important to note that we are no longer referring
    only to desktop computers but also to mobile devices such as tablets and phones,
    and different operating systems. It is because of this multiplatform approach
    that special consideration needs to be taken if the intention is to cover a user
    base on different devices, such as the use of special and dedicated CSS rules
    to adapt the UI to different sizes (the so-called **responsive applications**),
    different icons, and colors to blend with local user customizations at the operating
    system level (for example, light and dark modes), and so on. Moreover, PWAs have
    the capacity (just as with SPAs) to store content for offline use and, hopefully,
    should also provide some functionality for offline use. To accomplish all of this,
    at the bare minimum, a PWA must comply with the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The web application must be served through a secure connection (HTTPS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application must provide a manifest file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must provide and install a service worker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When all these conditions are met, the browser or operating system may prompt
    the user to “install” the application. If the user accepts, the manifest file
    will be used to customize the appearance of the application to match the local
    operating system (icons, names, colors, and so on), and it will appear alongside
    all the other applications in the system. When run, it will open in its own window
    (if so selected) outside the confines of the web browser, just as with a regular
    native application. Internally, it will still run over the browser engine using
    web technologies, but the intent is that this will be transparent for the user,
    providing the best of both worlds. Chances are that a user may have been using
    PWAs instead of regular applications without knowing. Successful examples of this
    approach are Starbucks, Trivago, and Tinder ([https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0](https://medium.com/@addyosmani/a-tinder-progressive-web-app-performance-case-study-78919d98ece0)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a good number of advantages that overpower the complications of
    creating a web application to match the different installation scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: One single code base to install an application on multiple devices (desktop,
    mobile, …) and operating systems (Windows, Linux, macOS, Android, iOS, and so
    on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support push notifications from the server, manual handling of caching, offline
    use, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They integrate with the local operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates are transparent for the user and are much faster than a traditional
    application (for the most part)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a PWA incurs much fewer costs than the equivalent targeted individual
    applications for each platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One can use all available web technologies, frameworks, and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be indexed by search engines, and the distribution and installation do not
    depend on proprietary application stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are responsive, safe, and fast, and can be shared with just a link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access local devices using standard web APIs, such as the local filesystem
    and USB devices, use hardware accelerated graphics, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some proprietary application stores allow you to re-package your PWA and distribute
    it as a regular application (Microsoft Store, Amazon Store, Android Store, and
    so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are more advantages, but these may be enough to make our case for them.
    Also, it is easier to add the necessary elements to our SPA to make it a PWA.
    This may make PWAs look like the silver bullet of applications; however, there
    are a few caveats and drawbacks to consider as well:'
  prefs: []
  type: TYPE_NORMAL
- en: The performance of a PWA is good but will always fall behind a native application
    for certain specific scenarios. The same may happen in older hardware—they will
    run, but performance may suffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple devices fall a little behind in the adoption of some web technologies
    or limit them purposely for PWAs (for example, server push notifications).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a need to dedicate a bit more effort to cover different user experience
    scenarios on multiple devices (but slightly more than for a normal responsive
    web application).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some application stores will not allow PWAs (specifically at the time of this
    writing, the Apple App Store). Also, the application will not benefit from the
    exposure and *foot traffic* from an app store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the advantages outweigh considerably the disadvantages. As web technologies
    continue to advance, PWAs benefit more from them and become more ubiquitous. Now,
    with a better understanding of what a PWA is and what it can do, let’s upgrade
    our SPAs into PWAs.
  prefs: []
  type: TYPE_NORMAL
- en: Upscaling a SPA into a PWA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first requirement mentioned previously is to serve the application over
    a secure connection. We will see how to accomplish this by installing a free SSL
    certificate in our server using **Let’s Encrypt**, in [*Chapter 10*](B18602_10.xhtml#_idTextAnchor224),
    *Deploying Your Application*. With that in mind, let’s see how to fulfil the other
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The manifest file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a manifest file is the starting point to turn our application into a
    PWA. It is nothing less than a JSON file with well-known fields that instruct
    the browser or operating system on how the application should be installed on
    the desktop or mobile device. This file must appear linked in the `head` section
    of our `index.html` file, and while it could be arbitrarily named, the convention
    is to use the name `manifest.json` or `app.webmanifest`. The official specification
    suggests the `.webmanifest` extension, but at the same type clarifies that the
    name is not really important as long as the file is received properly with the
    `application/manifest+json -` `manifest.json` for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice from the previous code that the file is placed at the root of our application,
    and the `rel` attribute must be `manifest`. The field attributes in our manifest
    file can appear in any order, and all of them are considered *optional* by the
    aforementioned specification. However, some platforms do expect a minimum set
    of attributes that we will consider *necessary*. The common practice also demands
    other attributes that we will catalogue as *recommended*, and finally, some attributes
    in the specification are used often in app stores, social media, and so on to
    present or describe the application, so we will refer to these as *descriptive*
    fields. This classification is not part of the specifications but is useful to
    guide you in the implementation. Here is a list of the most common and useful
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Classification | Attribute |'
  prefs: []
  type: TYPE_TB
- en: '| Necessary |'
  prefs: []
  type: TYPE_TB
- en: '| `short_name` | A short name to be used when there is not enough space to
    display the entire name of the application. In mobile devices, it is often used
    for the icon name. |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | The full name of the application. |'
  prefs: []
  type: TYPE_TB
- en: '| `icons` | An array of objects, each one representing an individual icon to
    be used in different contexts. Each object has at least two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src`: The path to the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizes`: A string with the dimensions of the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `start_url` | The URL where the application should start, as set by the developer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `display` | A string that represents how the application is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fullscreen`: Fullscreen, but showing browser UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`standalone`: Like `fullscreen`, but without browser controls. On a desktop,
    windows controls will still display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minimal-ui`: Like `standalone`, but with basic navigation to move forward
    and backward, print, share, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browser`: The application is open in the default browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Recommended |'
  prefs: []
  type: TYPE_TB
- en: '| `theme_color` | A string representing a CSS color for the application. It
    is upon the OS to decide how to use this value (usually, applied in the window
    title bar). |'
  prefs: []
  type: TYPE_TB
- en: '| `background_color` | A string that represents the background color of the
    application when it is launched and before the actual styles from the application
    are applied. |'
  prefs: []
  type: TYPE_TB
- en: '| `orientation` | Mostly used in mobile devices, it defines the orientation
    that the application must use—for example, `landscape, portrait, any,` and so
    on. |'
  prefs: []
  type: TYPE_TB
- en: '| `lang` | A string that defines the main language of the application. |'
  prefs: []
  type: TYPE_TB
- en: '| Descriptive |'
  prefs: []
  type: TYPE_TB
- en: '| `shortcuts` | This is an array of objects that define direct menu options
    for tight integration with the operating system. Usually, these appear in the
    context menu, such as when a user right-clicks on the application icon. Each shortcut
    object must contain at least `name` and `URL`, and—optionally—a `description`
    and `icons` array. |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | A string with a short description of the application. |'
  prefs: []
  type: TYPE_TB
- en: '| `screenshots` | An array of objects, with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src`: URL for the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: MIME type of the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizes`: A string with the dimensions of the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1 – Manifest fields
  prefs: []
  type: TYPE_NORMAL
- en: In practice, I would recommend that the necessary and recommended fields are
    completed for each PWA, while the descriptive fields are used as needed based
    on the context of your application. Additionally, research your target platforms
    for additional supported fields that are not part of the standard specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the preceding table, here is an example of a `manifest.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, creating a manifest file is not much additional effort and is
    an easy addition to our SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your manifest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have created your manifest file and linked it to your `index.html`
    file, you can use the Developer Tools in a browser to check that it has been properly
    loaded. For example, when using Google Chrome, in the **Application** menu, we
    can see here that the example file has been properly loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Developer Tools on Google Chrome, showing the manifest file](img/Figure_6.01_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Developer Tools on Google Chrome, showing the manifest file
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one more topic related to the installation of the application
    that we must review: when and how does the user know that the web application
    can be installed? This is where the *Install prompt* comes into play, which we
    will see next.'
  prefs: []
  type: TYPE_NORMAL
- en: Install prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each platform (mobile or desktop) has its own method of determining when a PWA
    that meets the installation criteria can be installed. This could trigger a notification
    for the user to accept the installation after a certain amount of time, or only
    provide a UI to do so. On mobile devices, the installed PWA will be placed on
    the home screen alongside other native applications, while on a desktop, it may
    be placed inside the browser and/or also in the main menu. Also, in mobile operating
    systems such as Android, a splash screen will be automatically created with the
    theme and background colors and the application icon provided in the manifest.
    Independently of how and when the PWA can be installed, it is important to know
    that it can only be done with the user’s consent and initiative. We cannot trigger
    the installation automatically from the code without the user’s approval.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic installation flow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the platform detects that our application can be installed, it will trigger
    an event in the window object called `beforeinstallprompt`. We can cache this
    event to trigger the prompt later from our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user initiates the install either through the platform UI or through our
    PWA-provided method (such as a button).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The platform will prompt the user to accept or reject the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user accepts, it will install the PWA and trigger another event named
    `appinstalled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a rather simple workflow. However, the `beforeinstallprompt` event is
    triggered only once, so if the user rejects the installation, we need to wait
    until the browser triggers the event again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand how things will work, it is time to see this in code.
    Consider that in our Vue 3 component’s template, we have the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have two paragraphs that will show according to the value
    of the `_install_ready` and `_app_installed` reactive variables, both Boolean.
    The first will appear when the PWA is ready to be installed and will provide a
    button to trigger the installation through the `installPWA()` function. The second
    will show once it has been performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code in the script section is also rather straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we register two listeners when our component is mounted
    on the page, one to manage and cache the installation prompt, and another to detect
    when the application has been installed. Some parts have been omitted to keep
    the code simple, but the full component with styles can be found in the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the preceding example is rather simplistic, there are some well-known
    patterns to promote or introduce the installation option to the end user. They
    all rely on the same logic of capturing the event and prompting it later while
    showing the trigger element. The implementation is trivial and has more to do
    with design than a coding pattern, so we will only see the mock-ups here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple **Install** button (as in our example application):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Simple Install button](img/Figure_6.02_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Simple Install button
  prefs: []
  type: TYPE_NORMAL
- en: 'Menu **Install** button—placed in the main navigation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Main menu Install button](img/Figure_6.03_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Main menu Install button
  prefs: []
  type: TYPE_NORMAL
- en: 'An overlay notification:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Overlay notification](img/Figure_6.04_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Overlay notification
  prefs: []
  type: TYPE_NORMAL
- en: 'An on-top overlayed element, such as an installation banner (either before
    the header or at the bottom of the viewport):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Installation prompt banner](img/Figure_6.05_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Installation prompt banner
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the application has been installed, we want to prevent keeping prompting
    the user for an install. In this case, it is recommendable that we save the offline
    flag, in `localStorage`, a cookie, on `indexeDB,` or mark the start URL of our
    application to a specific location. We will see offline persistent storage options
    in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173), *Data Flow Management*. Now,
    it’s time to look at the last item to make our SPA a true PWA: service workers.'
  prefs: []
  type: TYPE_NORMAL
- en: Service workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A service worker is a JavaScript script that runs on a separate thread, as a
    background process to your application. It acts like a proxy for the network,
    intercepting all calls and behaving according to a programmed strategy to serve
    pages and data.
  prefs: []
  type: TYPE_NORMAL
- en: We can have multiple service workers as each one is responsible for their scope.
    The scope is defined as the directory (URL path) where the source file for the
    service worker is located. Thus, a service worker placed at the root of the application
    will handle the entire SPA/PWA.
  prefs: []
  type: TYPE_NORMAL
- en: Service workers are installed without user intervention, so they can be used
    even if the user does not install the PWA. They have a well-defined life cycle
    (see https://web.dev/service-worker-lifecycle/), triggering events for each accomplished
    state. To start, a service worker needs to be first *registered*, then it becomes
    *activated*, and eventually, we can also *unregister* it. Once the service worker
    is activated, it will not take control of the application communication until
    the next time the site is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common strategies to program a service worker are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Serve the cache only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve network only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to serve the cache first, fall back to the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to serve the network first, fall back to the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve the cache first, update the cache next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When considering the cache and offline strategies, we need to consider what
    are the files and assets that our application needs to run that will have little
    or no change, to cache them. We also need to identify routes that should never
    be cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a service worker, we register it in our `main.js` file with the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In these lines, we first test if the current browser has capabilities to use
    service workers, and if so, we register it. As we can see, we have placed the
    worker at the root. For this example, we will use a cache-first, network-fallback
    strategy manually for all network calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is based almost verbose on the example provided in the **Mozilla
    Developer Network** documentation at [https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers).
    The comments in the code will help you understand the logic for the implementation
    of the strategy. However, using the basic APIs available to the service worker
    can be cumbersome, if not verbose. Instead, it is more convenient to use a framework
    or library to handle them and implement more complex strategies. The standard
    today is to use **Workbox**, made by **Google** (https://developer.chrome.com/docs/workbox/).
    We will not use it directly, but through a Vite plugin that we will see in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the code seen thus far, our PWA is ready to work and be installed.
    If we run the example application in the development server, we will notice that
    it can be installed. Using either the browser UI or our **Install** button, we
    will receive the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – PWA install prompt from localhost](img/Figure_6.06_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – PWA install prompt from localhost
  prefs: []
  type: TYPE_NORMAL
- en: 'Adapting manually our SPA to turn it into a PWA is not complicated, but it
    does require some manual work. However, with the choice of tools we have, we can
    do better. There is an easier way to generate and inject both the manifest file
    and service worker as part of our workflow directly into our SPA: using a Vite
    plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: Vite-PWA plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Vite ecosystem of plugins, there is an excellent zero-configuration
    Vite-PWA plugin ([https://vite-pwa-org.netlify.app/](https://vite-pwa-org.netlify.app/)).
    Out of the box, it provides us with great functionality without much manual work.
    We install the plugin as a developer dependency with the following command in
    the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it has been installed, we must register it in the Vite configuration.
    Modify the `vite.config.js` file to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using this plugin, we unload the burden of generating the service worker and
    web manifest to the bundler. This is necessary since with each production build,
    Vite will generate different filenames for each script according to our strategy
    to lazy load components, as we discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we pass into the `VitePWA()` plugin an object with
    some sensible options for the automatic creation and injection of our manifest
    and worker. If we need finer control over the service worker strategy created,
    as well as with the web manifest, it is possible to use the plugin in “inject
    mode” and provide a base file for our service worker. In this case, the script
    will be injected with the generated files from the build process. Underneath,
    this plugin uses `workbox` field. Going further into the details of the different
    implementations and strategies goes beyond the scope of this book, but the reader
    should consult the documentation about the **Vite-PWA** plugin and **Workbox**
    for specific contexts and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your PWA score with Google Lighthouse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chrome-based browsers provide together with the developer tools a utility called
    Lighthouse, specifically designed to test and rate web pages, and the readiness
    of PWAs. To access this tool, after you have opened your application in the browser,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the developer tools (by pressing *F12* in Windows/Linux, *Fn* + *F12* in
    Mac, or through the browser menu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Lighthouse** menu toward the further right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Mobile** or **Desktop**, plus make sure the **Progressive Web App**
    category is checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Analyze page load** in the top-right corner of the tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The developer tools should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Lighthouse utility](img/Figure_6.07_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Lighthouse utility
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool will run a number of tests, and each different category will display
    a rating, as well as a detailed list of items that have either passed or failed.
    If our application does not qualify to be a PWA, the items marked in red will
    tell us why and how to fix them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Chapter 6 code example ratings in Lighthouse](img/Figure_6.08_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Chapter 6 code example ratings in Lighthouse
  prefs: []
  type: TYPE_NORMAL
- en: Our example code application fully qualifies as a PWA and passes all tests with
    flying colors. This is easier to accomplish with smaller applications, of course.
    In practice, every rating above 90 is great.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a simple SPA and learned how to upgrade it into
    a PWA, manually and through the use of a plugin in Vite. Users can install PWAs
    in their platforms alongside native applications and interact with them, even
    if they are not connected to the internet. PWAs offer many advantages over web-only
    applications. We also saw how we can measure and rate our application in several
    industry-standard categories using Lighthouse. With this chapter, we end the incremental
    building of applications using web technologies and henceforth will focus on patterns
    and models for internal performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you solidify the concepts learned in this chapter, answer the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a SPA and a PWA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages of a PWA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the basic three requirements that a web application must comply with
    to be considered a PWA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which tools we can use to incrementally prepare our application to be a PWA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a service worker, and what are some strategies to use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a web manifest and why is it necessary?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
