- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Using the State Hook
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用State Hook
- en: After learning about the principles of React and giving an introduction to Hooks,
    we are now going to learn about the State Hook in depth. We will start by learning
    how the State Hook works internally by reimplementing it ourselves. Doing so will
    teach us about the limitations of Hooks and why they exist. Then, we will learn
    about possible alternative Hook APIs and their associated problems. Finally, we
    will learn how to solve the common problems that result from the limitations of
    Hooks. By the end of this chapter, you will know how to use the State Hook to
    implement stateful function components in React.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了React的原则并对Hooks进行了介绍之后，我们现在将深入学习State Hook。我们将从通过自己重新实现State Hook来了解其内部工作方式开始。这样做将使我们了解Hooks的限制以及它们存在的原因。然后，我们将学习可能的替代Hook
    API及其相关问题。最后，我们将学习如何解决由Hooks限制引起的常见问题。到本章结束时，您将知道如何使用State Hook在React中实现有状态的函数组件。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Reimplementing the State Hook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新实现State Hook
- en: Potential alternative Hook APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的替代Hook API
- en: Solving common problems with Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks解决常见问题
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The **Node
    Package Manager** (`npm`) also needs to be installed (it should come with Node.js).
    For more information on how to install Node.js, please check out the official
    website: [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的相当新版本应该已经安装。**Node包管理器**（`npm`）也需要安装（它应该包含在Node.js中）。有关如何安装Node.js的更多信息，请查看官方网站：[https://nodejs.org/](https://nodejs.org/)。
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to the official website: [https://code.visualstudio.com](https://code.visualstudio.com).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的指南中，我们将使用**Visual Studio Code**（**VS Code**），但任何其他编辑器都应该以类似的方式工作。有关如何安装VS
    Code的更多信息，请参阅官方网站：[https://code.visualstudio.com](https://code.visualstudio.com)。
- en: 'In this book, we use the following versions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: '`npm` v10.9.2'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` v10.9.2'
- en: VS Code v1.97.2
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code v1.97.2
- en: While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然安装新版本不应该有问题，但请注意，某些步骤在新版本上可能会有不同的工作方式。如果您在这本书提供的代码和步骤中遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter02).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter02)。
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您自己编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Reimplementing the State Hook
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新实现State Hook
- en: In order to get a better understanding of how Hooks work internally in React,
    we are going to reimplement the `useState` function from scratch. However, we
    are not going to implement it as an actual React Hook but as a simple JavaScript
    function—just to get an idea of what Hooks are actually doing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Hooks在React内部的工作方式，我们将从头开始重新实现`useState`函数。然而，我们不会将其实现为一个实际的React Hook，而是一个简单的JavaScript函数——只是为了了解Hooks实际上在做什么。
- en: This reimplementation is not exactly how React Hooks work internally. The actual
    implementation is similar, and thus, has similar constraints. However, the real
    implementation is more extensive than what we will be implementing here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的重构实现并不完全等同于React Hooks在内部的工作方式。实际的实现方式相似，因此具有相似的约束。然而，实际的实现比我们在这里要实现的内容更为广泛。
- en: 'We are now going to start reimplementing the State Hook:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始重新实现State Hook：
- en: 'Copy the `Chapter01_3` folder to a new `Chapter02_1` folder by executing the
    following command:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将`Chapter01_3`文件夹复制到新的`Chapter02_1`文件夹：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the new `Chapter02_1` folder in VS Code.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开新的`Chapter02_1`文件夹。
- en: First, we need to define a function to (re)render the app, which we can use
    to simulate React rerendering when the Hook state changes. If we used actual React
    Hooks, this would be dealt with internally.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个函数来（重新）渲染应用，我们可以使用它来模拟当Hook状态变化时的React重新渲染。如果我们使用实际的React Hooks，这将在内部处理。
- en: 'Open `src/main.jsx` and *remove* the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/main.jsx`并*删除*以下代码：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Replace* it with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换*为以下内容：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, open the `src/App.jsx` file and *remove* the following line:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`src/App.jsx`文件并*删除*以下行：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Replace* it with the following line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为以下行：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we define our own `useState` function. As we already know, the `useState`
    function takes `initialState` as an argument:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义我们自己的`useState`函数。正如我们已经知道的，`useState`函数接受`initialState`作为参数：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we define a value, where we will store our state. At first, this value
    will be set to `initialState`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个值，我们将在这里存储我们的状态。最初，这个值将被设置为`initialState`：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we define the `setState` function, where we will set the new value, and
    force the rerendering of our app:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`setState`函数，我们将在这里设置新值，并强制重新渲染我们的应用：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we return the `value` and the `setState` function as an array:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`value`和`setState`函数作为一个数组返回：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Start the `dev` server (keep it running) and then open the link in your browser:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`dev`服务器（保持运行）然后在浏览器中打开链接：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you try to enter text into the input field now, you will notice that when
    the component rerenders, the state gets reset, so it is not possible to enter
    any text in the field. We are going to solve this problem in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试在输入字段中输入文本，你会注意到当组件重新渲染时，状态被重置，因此无法在字段中输入任何文本。我们将在下一节中解决这个问题。
- en: 'The reason that we use an array and not an object is that we usually want to
    rename the `value` and `setState` variables. Using an array makes it easy to rename
    the variables through destructuring. For example, if we want to have state for
    `username`, we could do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数组而不是对象的原因是我们通常想要重命名`value`和`setState`变量。使用数组可以通过解构轻松地重命名变量。例如，如果我们想要为`username`设置状态，我们可以这样做：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While renaming in destructuring is possible with objects too, it would be more
    verbose:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在对象中也可以通过解构进行重命名，但这会更冗长：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, Hooks are simple JavaScript functions that deal with side effects,
    such as setting a stateful value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Hooks是处理副作用（如设置有状态值）的简单JavaScript函数。
- en: Our Hook function uses a **closure** to store the current value. The closure
    is an environment where variables exist and are stored. In our case, the function
    provides the closure, and the `value` variable is stored within that closure.
    The `setState` function is also defined within the same closure, which is why
    we can access the `value` variable within that function. Outside of the `useState`
    function, we cannot directly access the `value` variable unless we return it from
    the function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Hook函数使用**闭包**来存储当前值。闭包是一个变量存在和存储的环境。在我们的情况下，函数提供了闭包，而`value`变量存储在这个闭包中。`setState`函数也是在同一个闭包中定义的，这就是为什么我们可以在该函数中访问`value`变量。在`useState`函数外部，除非我们从函数中返回它，否则我们无法直接访问`value`变量。
- en: Resolving issues with our simple Hook implementation
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决简单Hook实现中的问题
- en: The issue of not being able to enter any text into the input field is due to
    the reinitialization of the `value` variable every time the component gets rendered
    because we call `useState` each time we render the component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无法输入任何文本到输入字段的问题是由于每次组件渲染时都会重新初始化`value`变量，因为我们每次渲染组件时都会调用`useState`。
- en: In the following section, we are going to solve this problem by using a global
    variable and then turning the simple value into an array, allowing us to define
    multiple Hooks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将通过使用全局变量然后将简单值转换为数组来解决此问题，这样我们就可以定义多个Hook。
- en: Using a global variable
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用全局变量
- en: As we have learned, the `value` is stored within the closure that is defined
    by the `useState` function. Every time the component rerenders, the closure gets
    reinitialized, which means that the `value` variable will be set to the `initialState`
    again. To solve this, we need to store the `value` in a global variable, outside
    of the function. That way, the `value` variable will be in the closure outside
    of the function, which means that when the function gets called again, the `value`
    will not be reinitialized.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，`value`存储在由`useState`函数定义的闭包中。每当组件重新渲染时，闭包都会重新初始化，这意味着`value`变量将再次设置为`initialState`。为了解决这个问题，我们需要将`value`存储在函数之外的全局变量中。这样，`value`变量就会在函数的外部闭包中，这意味着当函数再次被调用时，`value`不会重新初始化。
- en: 'We can define the global variable as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义全局变量如下：
- en: 'First, edit `src/App.jsx` and add the following line above the `useState` function
    definition:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑`src/App.jsx`并在`useState`函数定义上方添加以下行：
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, *remove* the following first line in the function definition:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*删除*函数定义中的以下第一行：
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Replace* it with the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码片段替换它：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Try entering some text into the input field again; you will see that our Hook
    function works now!
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试在输入字段中输入一些文本；你会看到我们的Hook函数现在可以正常工作了！
- en: 'Now, our `useState` function uses the global `value` variable instead of defining
    the `value` variable within its closure, so it will not get reinitialized when
    the function gets called again. While our Hook function currently works fine,
    if we wanted to add another Hook, we would run into another problem: all Hooks
    write to the same global `value` variable! Let’s take a closer look at this problem
    by adding a second Hook to our component.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`useState`函数使用全局的`value`变量而不是在其闭包内定义`value`变量，因此当函数再次被调用时，它不会重新初始化。虽然我们的Hook函数目前运行良好，但如果我们要添加另一个Hook，我们会遇到另一个问题：所有Hook都写入同一个全局`value`变量！让我们通过向我们的组件添加第二个Hook来更详细地看看这个问题。
- en: Defining multiple Hooks
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义多个Hook
- en: 'Let’s say we want to create a second field for the last name of the user. We
    can achieve it by following these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为用户的姓氏创建第二个字段。我们可以通过以下步骤实现：
- en: 'Edit `src/App.jsx` and start by defining a new Hook at the beginning of the
    `App` component, after the current Hook:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并从在`App`组件开始，在当前Hook之后定义一个新的Hook：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, define a function to handle changing the last name:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个函数来处理姓氏的变化：
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, show the `lastName` value after the first name:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在第一个名字之后显示`lastName`值：
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, add another `input` field for the last name:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加另一个用于姓氏的`input`字段：
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Try entering the first name and last name now.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试输入第一个名字和姓氏。
- en: You will notice that our reimplemented Hook function uses the same value for
    both states, so we are always changing both fields at once. Let’s attempt to fix
    that now.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们重新实现的Hook函数使用相同的值来更新两个状态，所以我们总是同时更改两个字段。现在让我们尝试修复这个问题。
- en: Adding support for multiple Hooks
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加对多个Hook的支持
- en: 'To add support for multiple Hooks, we need to store an array of Hook values
    instead of a single global variable. We are now going to refactor the `value`
    variable to a `values` array with the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多个Hook，我们需要存储一个Hook值的数组而不是单个全局变量。我们现在将按照以下步骤重构`value`变量：
- en: 'Edit `src/App.jsx` and *remove* the following line of code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并*删除*以下代码行：
- en: '[PRE19]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Replace* it with the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码片段替换它：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, edit the first line of the `useState` function, where we now initialize
    the value at the `currentHook` index of the `values` array:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编辑`useState`函数的第一行，我们现在在`values`数组的`currentHook`索引处初始化值：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also need to update the setter function so that only the corresponding state
    value is updated. Here, we need to first store the `currentHook` value in a separate
    `hookIndex` variable, because the `currentHook` value will change later. This
    ensures that a copy of the `currentHook` variable is created within the closure
    of the `useState` function. Otherwise, the `useState` function would access the
    `currentHook` variable from the outer closure, which gets modified with each call
    to `useState`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更新setter函数，以便只更新相应的状态值。在这里，我们需要首先将`currentHook`值存储在一个单独的`hookIndex`变量中，因为`currentHook`值稍后会发生变化。这确保了在`useState`函数的闭包内创建了一个`currentHook`变量的副本。否则，`useState`函数将访问外层闭包中的`currentHook`变量，该变量会在每次调用`useState`时被修改：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Edit the `return` statement of the `useState` function as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式编辑 `useState` 函数的 `return` 语句：
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using `values[currentHook++]`, we pass the current value of `currentHook` as
    an index to the `values` array and then increase the `currentHook` value by one.
    This means that `currentHook` will be increased after returning from the function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `values[currentHook++]`，我们将 `currentHook` 的当前值作为索引传递给 `values` 数组，然后增加 `currentHook`
    的值。这意味着 `currentHook` 将在函数返回后增加。
- en: If we wanted to first increment a value and then use it, we could use the `arr[++indexToBeIncremented]`
    syntax, which first increments and then passes the result to the array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要首先增加一个值然后使用它，我们可以使用 `arr[++indexToBeIncremented]` 语法，它首先增加然后传递结果到数组。
- en: 'We still need to reset the `currentHook` counter when we start rendering our
    component. Add the following line right after the component definition:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们开始渲染我们的组件时，我们仍然需要重置 `currentHook` 计数器。在组件定义后立即添加以下行：
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Try entering the first name and last name again.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试输入第一个名字和最后一个名字。
- en: 'Finally, our simple reimplementation of the `useState` Hook works! The following
    screenshot highlights this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简单重新实现的 `useState` Hook 成功了！以下截图突出了这一点：
- en: '![Figure 2.1 – Our custom Hook reimplementation works!](img/B31327_02_01.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 我们自定义的 Hook 重新实现成功了](img/B31327_02_01.png)'
- en: Figure 2.1 – Our custom Hook reimplementation works!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 我们自定义的 Hook 重新实现成功了
- en: As we can see, using a global array to store our Hook values solved the problems
    that we had when defining multiple Hooks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用全局数组来存储我们的 Hook 值解决了我们在定义多个 Hook 时遇到的问题。
- en: '**Example code**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter02/Chapter02_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `Chapter02/Chapter02_1` 文件夹中找到。请检查文件夹内的 `README.md` 文件，以获取设置和运行示例的说明。
- en: After resolving the problems we had with our custom Hook implementation, let’s
    find out more about the limitations of Hooks in general.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决我们自定义 Hook 实现中遇到的问题之后，让我们更多地了解 Hooks 的一般限制。
- en: Can we define conditional Hooks?
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们能否定义条件 Hook？
- en: 'What if we wanted to add a checkbox that toggles the use of the first name
    field? Let’s find out by implementing such a checkbox:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加一个复选框来切换第一个名字字段的用法，让我们通过实现这样的复选框来找出答案：
- en: 'Copy the `Chapter02_1` folder to a new `Chapter02_2` folder, as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Chapter02_1` 文件夹复制到一个新的 `Chapter02_2` 文件夹中，如下所示：
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Open the new `Chapter02_2` folder in VS Code.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter02_2` 文件夹。
- en: 'Edit `src/App.jsx` and add a new Hook to the `App` component, which will store
    the state of the checkbox:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/App.jsx` 并向 `App` 组件添加一个新的 Hook，该 Hook 将存储复选框的状态：
- en: '[PRE26]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, adjust the Hook for the `name` state to only be used when the first name
    is enabled:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整 `name` 状态的 Hook，使其仅在第一个名字被启用时使用：
- en: '[PRE27]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We need to disable ESLint for this line; otherwise, it will yell at us, telling
    us that Hooks cannot be used conditionally. For the purposes of this demonstration,
    I want to show what happens when you ignore this warning, though.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要禁用 ESLint 这一行；否则，它会大声告诉我们不能有条件地使用 Hooks。出于演示目的，我想展示当你忽略这个警告时会发生什么。
- en: We also define a fallback to an empty string (`''`) and a function that does
    nothing (`() => {}`) when the Hook is not defined.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个回退到空字符串 (`''`) 和一个不执行任何操作的函数 (`() => {}`)，当 Hook 未定义时。
- en: 'Next, define a handler function for changing the checkbox state:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个用于更改复选框状态的处理器函数：
- en: '[PRE28]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, render the checkbox:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，渲染复选框：
- en: '[PRE29]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Start the `dev` server and then open the link in your browser:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `dev` 服务器，然后在浏览器中打开链接：
- en: '[PRE30]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we either use the Hook or, if the first name is disabled, we return the
    initial state and an empty setter function, so that editing the input field will
    not work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要么使用 Hook，要么如果第一个名字被禁用，则返回初始状态和一个空设置函数，这样编辑输入字段将不起作用。
- en: 'If we now try out this code, we are going to notice that editing the last name
    still works, but editing the first name does not work, which is what we wanted.
    As we can see in the following screenshot, only editing the last name works now:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试这段代码，我们会注意到编辑最后一个名字仍然可以工作，但编辑第一个名字则不行，这正是我们想要的。正如以下截图所示，现在只有编辑最后一个名字可以工作：
- en: '![Figure 2.2 – State of the app before checking the checkbox](img/B31327_02_02.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 在勾选复选框之前的应用程序状态](img/B31327_02_02.png)'
- en: Figure 2.2 – State of the app before checking the checkbox
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 在勾选复选框之前的应用程序状态
- en: 'When we click the checkbox, something strange happens:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击复选框时，会发生一些奇怪的事情：
- en: The checkbox gets checked
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框被勾选
- en: The first name input field gets enabled
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字输入字段被启用
- en: The value of the last name field is now the value of the first name field
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在姓氏字段的值是名字字段的值
- en: 'We can see the result of clicking the checkbox in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图看到点击复选框的结果：
- en: '![Figure 2.3 – State of the app after clicking the checkbox](img/B31327_02_03.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 点击复选框后应用的状态](img/B31327_02_03.png)'
- en: Figure 2.3 – State of the app after clicking the checkbox
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 点击复选框后应用的状态
- en: We can see that the last name state is now in the first name field. The value
    gets swapped because the order of Hooks matters. As we know from our implementation,
    we use the `currentHook` index to find out where the state of each Hook is stored.
    However, when we insert an additional Hook in between two existing Hooks, the
    order gets messed up.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，现在姓氏状态在名字字段中。值被交换，因为Hooks的顺序很重要。正如我们从我们的实现中知道的那样，我们使用`currentHook`索引来找出每个Hook的状态存储位置。然而，当我们插入一个额外的Hook在两个现有Hooks之间时，顺序就会混乱。
- en: 'Before checking the checkbox, the `values` array was as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在勾选复选框之前，`values`数组如下：
- en: '`[false, '''']`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[false, '''']`'
- en: 'Hook order: `enableFirstName`, `lastName`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook顺序：`enableFirstName`，`lastName`
- en: 'Then, we entered some text in the `lastName` field:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在姓氏字段中输入了一些文本：
- en: '`[false, ''Hook'']`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[false, ''Hook'']`'
- en: 'Hook order: `enableFirstName`, `lastName`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook顺序：`enableFirstName`，`lastName`
- en: 'Next, we clicked the checkbox, which activated another Hook:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们点击了复选框，这激活了另一个Hook：
- en: '`[true, ''Hook'', '''']`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[true, ''Hook'', '''']`'
- en: 'Hook order: `enableFirstName`, `name`, `lastName`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook顺序：`enableFirstName`，`name`，`lastName`
- en: As we can see, inserting a new Hook in between two existing Hooks makes the
    `name` Hook *steal* the state from the next Hook (`lastName`) because it now has
    the same index that the `lastName` Hook previously had. Now, the `lastName` Hook
    does not have a value, which causes it to set the initial value (an empty string).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在两个现有Hooks之间插入一个新的Hook会使`name` Hook从下一个Hook（`lastName`）中“窃取”状态，因为它现在具有`lastName`
    Hook之前拥有的相同索引。现在，`lastName` Hook没有值，这导致它设置初始值（一个空字符串）。
- en: As a result, toggling the checkbox puts the value of the `lastName` field into
    the `name` field and leaves the `lastName` field empty.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，切换复选框将姓氏字段的值放入名字字段，并使姓氏字段为空。
- en: '**Example code**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter02/Chapter02_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例代码位于`Chapter02/Chapter02_2`文件夹中。请检查文件夹内的`README.md`文件，以获取设置和运行示例的说明。
- en: After learning that Hooks always need to be called in the same order, let’s
    compare our custom Hook implementation to real React Hooks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解到Hooks总是需要以相同的顺序调用之后，让我们将我们的自定义Hook实现与真正的React Hooks进行比较。
- en: Comparing our reimplementation to real Hooks
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的重新实现与真正的Hooks进行比较
- en: Our simple Hook implementation already gives us an idea of how Hooks work internally.
    However, in reality, Hooks do not use global variables. Instead, they store state
    within the React component. They also deal with the Hook counter internally, so
    we do not need to manually reset the count in function components. Additionally,
    real Hooks automatically trigger rerenders of components when the state changes.
    To be able to do this, however, Hooks need to be called from a React function
    component. React Hooks cannot be called outside of React or inside React class
    components.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的Hook实现已经让我们对Hooks的内部工作方式有了了解。然而，在现实中，Hooks并不使用全局变量。相反，它们在React组件中存储状态。它们还内部处理Hook计数器，因此我们不需要在函数组件中手动重置计数。此外，真正的Hooks在状态变化时自动触发组件的重新渲染。然而，为了能够做到这一点，Hooks需要从React函数组件中调用。React
    Hooks不能在React外部或React类组件内部调用。
- en: 'By reimplementing the `useState` Hook, we have learned the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新实现`useState` Hook，我们学到了以下内容：
- en: Hooks are functions that access React features
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks是访问React功能的函数
- en: Hooks deal with side effects that persist across rerenders
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks处理跨渲染持续存在的副作用
- en: The order of Hook definitions matters
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hook定义的顺序很重要
- en: The final point is especially important because it means that we cannot conditionally
    define Hooks. We should always have all Hook definitions at the beginning of a
    function component and never nest them within `if` statements, ternaries, or similar
    constructs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点尤为重要，因为它意味着我们不能有条件地定义Hooks。我们应该始终在函数组件的开始处定义所有Hook，并且永远不要将它们嵌套在`if`语句、三元运算符或类似的结构中。
- en: 'So, we have also learned the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们也学到了以下内容：
- en: React Hooks need to be called inside React function components or other Hooks
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks必须在React函数组件或其他Hook内部调用
- en: React Hooks cannot be defined conditionally or in loops
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks不能在条件或循环中定义
- en: 'There are some additional limitations of React Hooks, resulting from the limitations
    we have learned about:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们学到了一些限制，React Hooks还有一些额外的限制：
- en: React Hooks cannot be defined after a conditional `return` statement
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks不能在条件`return`语句之后定义
- en: React Hooks cannot be defined in event handlers
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks不能在事件处理程序中定义
- en: React Hooks cannot be defined inside `try`/`catch`/`finally` blocks
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks不能在`try`/`catch`/`finally`块内定义
- en: React Hooks cannot be defined in the functions passed to `useMemo`, `useReducer`,
    and `useEffect` (we will learn more about these three Hooks throughout the book,
    but just keep this limitation in mind for now)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Hooks不能在传递给`useMemo`、`useReducer`和`useEffect`的函数中定义（我们将在本书中学习更多关于这三个Hook的内容，但请现在记住这个限制）
- en: We are now going to look at alternative Hook APIs that would allow conditional
    Hooks, but they come with their own downsides.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨一些替代的Hook API，它们将允许条件性Hook，但它们也有自己的缺点。
- en: Potential alternative Hook APIs
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 潜在的替代Hook API
- en: Sometimes, it would be nice to define Hooks conditionally or in loops, but why
    did the React team decide to implement Hooks like this? What are the alternatives?
    Let’s go through some of them to get a feeling for the trade-offs involved in
    making this decision.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，定义条件性Hook或在循环中定义Hook会很好，但为什么React团队决定以这种方式实现Hooks？有哪些替代方案？让我们通过探讨其中的一些方案来了解做出这一决策所涉及的权衡。
- en: Named Hooks
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名Hook
- en: 'We could give each Hook a name, and then store the Hooks in an object instead
    of an array. However, this would not make such a nice API, and we would also always
    have to think of unique names for Hooks:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给每个Hook起一个名字，然后将Hook存储在对象中而不是数组中。然而，这不会使API变得如此优雅，我们还需要始终为Hook考虑独特的名称：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Additionally, there are unresolved questions: What would happen when a conditional
    is set to `false` or an item is removed from a loop? Would we clear the Hook state?
    If we do not clear the Hook state, we might be causing memory leaks. If we do
    clear it, we might be unintentionally discarding user input.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些未解决的问题：当条件设置为`false`或从循环中移除一个项目时会发生什么？我们会清除Hook状态吗？如果我们不清除Hook状态，我们可能会造成内存泄漏。如果我们清除它，我们可能会无意中丢弃用户输入。
- en: Even if we solved these problems, there would still be the problem of name collisions.
    If we, for example, create a Hook and call it `nameHook`, then we cannot call
    any other Hook `nameHook` in our component anymore, or we will cause a name collision.
    This is even the case for Hook names from libraries, so we need to make sure to
    avoid name collisions with Hooks defined by libraries as well!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 即使解决了这些问题，仍然存在名称冲突的问题。例如，如果我们创建了一个名为`nameHook`的Hook，那么我们不能再在组件中调用任何其他名为`nameHook`的Hook，否则将导致名称冲突。这种情况也适用于库中的Hook名称，因此我们需要确保避免与库定义的Hook发生名称冲突！
- en: Hook factories
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hook工厂
- en: 'Alternatively, we could create a Hook factory function, which uses `Symbol`
    internally to give each Hook a unique key name:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以创建一个Hook工厂函数，它内部使用`Symbol`来为每个Hook提供一个独特的键名：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we could use the factory function as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样使用工厂函数：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, this means that we will need to instantiate each Hook twice: once
    outside of the component, and once inside the function component. This creates
    more room for error. For example, if we create two Hooks and copy and paste the
    boilerplate code, then we might make a mistake in the name of our Hook resulting
    from the factory function, or we might make a mistake when using the Hook inside
    the component.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着我们需要为每个Hook实例化两次：一次在组件外部，一次在函数组件内部。这增加了出错的可能性。例如，如果我们创建了两个Hook并复制粘贴样板代码，那么我们可能会在Hook的名称上犯错误，或者在使用组件内的Hook时犯错误。
- en: This approach also makes it much harder to create custom Hooks, forcing us to
    write wrapper functions. Additionally, it is harder to debug these wrapped functions
    than it is to debug a simple function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也使得创建自定义Hook变得更加困难，迫使我们编写包装函数。此外，与调试简单函数相比，调试这些包装函数更加困难。
- en: Other alternatives
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他替代方案
- en: 'There were many proposed alternative APIs for React Hooks, but each of them
    suffered from similar problems: either making the API harder to use, less flexible,
    harder to debug, or introducing the possibility of name collisions.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 React Hooks，提出了许多替代的 API，但每个都存在类似的问题：要么使 API 更难使用，灵活性降低，更难调试，或者引入名称冲突的可能性。
- en: In the end, the React team decided that the simplest API was to keep track of
    Hooks by counting the order in which they were called. This approach comes with
    its own downsides, such as not being able to call Hooks conditionally or in loops.
    However, this approach makes it very easy to create custom Hooks, and it is simple
    to use and debug. We also do not need to worry about naming Hooks, name collisions,
    or writing wrapper functions. The final approach for Hooks lets us use Hooks just
    like any other function!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，React 团队决定最简单的 API 是通过记录 Hook 被调用的顺序来跟踪 Hook。这种方法有其自身的缺点，例如无法有条件地调用 Hook
    或在循环中调用。然而，这种方法使得创建自定义 Hook 非常容易，并且使用和调试都很简单。我们也不必担心 Hook 的命名、名称冲突或编写包装函数。最终的
    Hook 方法让我们可以使用 Hook 就像使用任何其他函数一样！
- en: Now that we have learned about the various proposals and the final Hook implementation,
    let’s learn how to solve common problems resulting from the limitations of the
    chosen official API.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了各种提案和最终的 Hook 实现，让我们学习如何解决由于选择官方 API 的限制而导致的常见问题。
- en: Solving common problems with Hooks
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 Hook 的常见问题
- en: As we found out, implementing Hooks with the official API also has its own trade-offs
    and limitations. We are now going to learn how to overcome these common problems,
    which stem from the limitations of React Hooks.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所发现的，使用官方 API 实现 Hooks 也有其自身的权衡和限制。我们现在将学习如何克服这些常见问题，这些问题源于 React Hooks 的限制。
- en: 'We will take a look at solutions that can be used to overcome these two problems:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨可以用来克服这两个问题的解决方案：
- en: Solving conditional Hooks
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决条件 Hook
- en: Solving Hooks in loops
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中解决 Hook
- en: Solving conditional Hooks
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决条件 Hook
- en: So, how do we implement conditional Hooks? Instead of making the Hook conditional,
    we can just always define the Hook and use it whenever we need it. If this is
    not an option, we need to split up our components, which is usually better anyway!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现条件 Hook？我们不必使 Hook 有条件，我们只需总是定义 Hook 并在我们需要时使用它。如果这不是一个选项，我们需要拆分我们的组件，这通常总是更好的选择！
- en: Always defining the Hook
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总是定义 Hook
- en: 'For simple cases, such as the first and last name example that we had previously,
    we can just always keep the Hook defined, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的情况，例如我们之前遇到的第一个和最后一个名称示例，我们只需总是保持 Hook 定义，如下所示：
- en: 'Copy the `Chapter02_2` folder to a new `Chapter02_3` folder, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Chapter02_2` 文件夹复制到新的 `Chapter02_3` 文件夹中，如下所示：
- en: '[PRE34]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Open the new `Chapter02_3` folder in VS Code.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter02_3` 文件夹。
- en: 'Edit `src/App.jsx` and *remove* the following two lines:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/App.jsx` 并 *删除* 以下两行：
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Replace* them with the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 如下：'
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we need to move the conditional down to where the first name gets rendered
    instead:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将条件移动到第一个名称被渲染的地方：
- en: '[PRE37]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you want to re-add the feature that the first name field cannot even be
    edited when it is not enabled, just add the following attribute to the `<input>`
    field: `disabled={!enableFirstName}`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想重新添加第一个名称字段在未启用时甚至不能编辑的功能，只需向 `<input>` 字段添加以下属性：`disabled={!enableFirstName}`。
- en: 'Run the `dev` server and then open the link in your browser:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `dev` 服务器，然后在浏览器中打开链接：
- en: '[PRE38]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, our example works fine! Always defining the Hook is usually a good solution
    for simple cases. In more complex cases, it might not be feasible to always define
    the Hook. In that case, we would need to create a new component, define the Hook
    there, and then conditionally render the component.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的示例运行正常！总是定义 Hook 对于简单情况通常是一个好的解决方案。在更复杂的情况下，可能无法始终定义 Hook。在这种情况下，我们需要创建一个新的组件，在那里定义
    Hook，然后有条件地渲染组件。
- en: '**Example code**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter02/Chapter02_3`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `Chapter02/Chapter02_3` 文件夹中找到。请检查文件夹内的 `README.md` 文件，了解如何设置和运行示例。
- en: Splitting up components
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分离组件
- en: Another way to solve conditional Hooks is to split up one component into multiple
    components and then conditionally render the components. For example, let’s say
    we want to fetch user information from a database after the user logs in.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 解决条件 Hooks 的另一种方法是拆分一个组件成多个组件，然后有条件地渲染这些组件。例如，假设我们在用户登录后想要从数据库中获取用户信息。
- en: 'We cannot do the following, as using an `if` conditional could change the order
    of the Hooks:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能这样做，因为使用 `if` 条件可能会改变 Hooks 的顺序：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead, we have to create a separate component for when the user is logged
    in, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须为用户登录时创建一个单独的组件，如下所示：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using two separate components for the non-logged-in and logged-in state makes
    sense anyway because we want to stick to the principle of having one functionality
    per component. Usually, not being able to have conditional Hooks is not much of
    a limitation if we stick to best practices.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个独立的组件来处理非登录和登录状态是有意义的，因为我们想坚持一个组件一个功能的原理。通常，如果我们坚持最佳实践，不能有条件 Hooks 并不是很大的限制。
- en: Solving Hooks in loops
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决循环中的 Hooks
- en: Sometimes, you may have a case where you would want to define Hooks in loops
    – for example, if you have a way to dynamically add new input fields and you need
    a State Hook for each of them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要在循环中定义 Hooks – 例如，如果你有动态添加新输入字段的方法，并且需要为每个字段提供一个 State Hook。
- en: To solve problems where we would want to have Hooks in loops, we can either
    use a single State Hook containing an array or we can again split up our components.
    For example, let’s say we want to display all the users that are online.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决我们希望在循环中使用 Hooks 的问题，我们可以使用包含数组的单个 State Hook，或者再次拆分我们的组件。例如，假设我们想要显示所有在线的用户。
- en: Using an array
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组
- en: 'We could simply use an array that contains all users, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用包含所有用户的数组，如下所示：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, this might not always make sense. For example, we might not want to
    update the user state through the `OnlineUsers` component because we would have
    to select the correct user state from the array and then modify the array. This
    might work but it is quite tedious.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不总是有意义的。例如，我们可能不希望通过 `OnlineUsers` 组件来更新用户状态，因为我们必须从数组中选择正确的用户状态，然后修改数组。这可能可行，但相当繁琐。
- en: Splitting up components
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分组件
- en: 'A better solution would be to use the Hook in the `UserInfo` component instead.
    That way, we can keep the state for each user up to date, without having to deal
    with array logic:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用 `UserInfo` 组件中的 Hook。这样，我们可以保持每个用户状态的最新，而无需处理数组逻辑：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we can see, using one component for each functionality keeps our code simple
    and concise, and also avoids the limitations of React Hooks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用一个组件来处理每个功能使我们的代码简单且简洁，同时也避免了 React Hooks 的限制。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started out by reimplementing the `useState` function, making
    use of global state and closures. We then learned that in order to support multiple
    Hooks, we need to keep track of them using an array. By using a state array, however,
    we were forced to keep the order of Hooks consistent across function calls. This
    limitation made conditional Hooks and Hooks in loops impossible. We then learned
    about potential alternatives to the Hook API, their trade-offs, and why the final
    API was chosen. Finally, we learned how to solve the common problems that stem
    from the limitations of Hooks. We now have a solid understanding of the inner
    workings and limitations of Hooks. Along the way, we also learned about the State
    Hook in depth.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先重新实现了 `useState` 函数，利用全局状态和闭包。然后我们了解到，为了支持多个 Hooks，我们需要使用数组来跟踪它们。然而，通过使用状态数组，我们被迫在函数调用之间保持
    Hooks 的顺序一致。这种限制使得条件 Hooks 和循环中的 Hooks 变得不可能。然后我们学习了 Hook API 的潜在替代方案，它们的权衡以及为什么选择了最终的
    API。最后，我们学习了如何解决由 Hooks 的限制引起的常见问题。现在我们对 Hooks 的内部工作和限制有了坚实的理解。在这个过程中，我们还深入了解了
    State Hook。
- en: In the next chapter, we are going to create a blog application using the State
    Hook and learn how to combine multiple Hooks.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个使用 State Hook 的博客应用程序，并学习如何组合多个 Hooks。
- en: Questions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章所学的内容，尝试回答以下问题：
- en: Which problems did we run into while developing our own reimplementation of
    the `useState` Hook? How did we solve these problems?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发我们自己的 `useState` Hook 重新实现过程中，我们遇到了哪些问题？我们是如何解决这些问题的？
- en: Why are conditional Hooks not possible in the React implementation of Hooks?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在React的钩子实现中不能使用条件钩子？
- en: What do we need to watch out for when using Hooks?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用钩子时我们需要注意什么？
- en: What are the common problems of alternative API ideas for Hooks?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 钩子替代API想法的常见问题有哪些？
- en: How do we implement conditional Hooks?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何实现条件钩子？
- en: How do we implement Hooks in loops?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在循环中实现钩子？
- en: Further reading
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本章学到的概念感兴趣，想了解更多信息，请查看以下链接：
- en: 'More information on the flaws of alternative Hook APIs: [https://overreacted.io/why-do-hooks-rely-on-call-order/](https://overreacted.io/why-do-hooks-rely-on-call-order/)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于替代钩子API缺陷的更多信息：[https://overreacted.io/why-do-hooks-rely-on-call-order/](https://overreacted.io/why-do-hooks-rely-on-call-order/)
- en: 'Official comment on alternative Hook APIs: [https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884](https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对替代钩子API的官方评论：[https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884](https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884)
- en: 'Official documentation on the limitations and rules of Hooks: [https://react.dev/reference/rules/rules-of-hooks](https://react.dev/reference/rules/rules-of-hooks)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于钩子限制和规则的官方文档：[https://react.dev/reference/rules/rules-of-hooks](https://react.dev/reference/rules/rules-of-hooks)
- en: 'More information on how `Symbol` works: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`Symbol`如何工作的更多信息：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
- en: Learn more on Discord
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在那里你可以分享反馈，向作者提问，了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/wnXT0](Chapter_02.xhtml)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/wnXT0](Chapter_02.xhtml)'
- en: '![](img/image_%283%29.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_%283%29.png)'
