- en: Component-Based User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于组件的用户界面
- en: Although we'll cover a lot of Angular-related topics in this book, the focus
    will be mainly on creating component-based user interfaces. It's one thing to
    understand a framework like Angular, but it's a whole different thing to establish
    an effective workflow using a component-based architecture. In this book, I'll
    try to explain the core concepts behind Angular components and how we can leverage
    this architecture to create modern, efficient, and maintainable user interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书将涵盖许多与 Angular 相关的主题，但重点将主要放在创建基于组件的用户界面。理解像 Angular 这样的框架是一回事，但使用基于组件的架构建立有效的流程则是另一回事。在本书中，我将尝试解释
    Angular 组件背后的核心概念以及我们如何利用这种架构来创建现代、高效和可维护的用户界面。
- en: Besides learning all the necessary concepts behind Angular, together, we will
    create a task-management application from scratch. This will allow us to explore
    different approaches to solve common UI problems using the component system that
    is provided by Angular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了学习 Angular 背后的所有必要概念外，我们还将一起从头创建一个任务管理应用程序。这将使我们能够探索使用 Angular 提供的组件系统解决常见
    UI 问题的方法。
- en: In this chapter, we will take a look at how component-based user interfaces
    help us build greater applications. Over the course of this book, we will build
    an Angular application together, where we will use the component-based approach
    to its full potential. This chapter will also introduce you to the technologies
    that are used in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨基于组件的用户界面如何帮助我们构建更强大的应用程序。在本书的整个过程中，我们将一起构建一个 Angular 应用程序，我们将充分利用基于组件的方法。本章还将介绍本书中使用的各种技术。
- en: 'The topics that we will cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: An introduction to component-based user interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于组件的用户界面简介
- en: Encapsulation and composition using component-based user interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于组件的用户界面进行封装和组合
- en: Evolution of UI frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 框架的演变
- en: The standard web components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的 Web 组件
- en: An introduction to the Angular component system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 组件系统的简介
- en: Writing your first Angular component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个 Angular 组件
- en: Basics of `NgModule`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgModule` 的基础知识'
- en: An overview and history of ECMAScript and TypeScript
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 和 TypeScript 的概述及历史
- en: ECMAScript 7 decorators as meta annotations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 7 装饰器作为元注释
- en: An introduction to Node.js-based tooling using Angular CLI
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 的基于 Node.js 的工具简介
- en: Thinking in components
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以组件思维
- en: Today's user interfaces do not consist of just a bunch of form elements that
    are cobbled together onto a screen. Modern users experience designing innovative
    visual presentations of interactive content challenges technology more than ever.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的用户界面不仅仅是一堆拼凑到屏幕上的表单元素。现代用户在体验设计创新视觉展示的交互式内容时，对技术的挑战比以往任何时候都要大。
- en: Sadly, we almost always tend to think in pages when we flesh out concepts for
    web applications, such as the pages within a printed book. Thinking about a book,
    this is probably the most efficient way to convey information for this kind of
    content and medium. You can skim through the pages one by one without any real
    physical effort, read paragraph by paragraph, and just scan through the chapters
    that you don't find interesting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，当我们为网络应用程序构思概念时，我们几乎总是倾向于以页面为单位思考，比如印刷书籍中的页面。思考一本书，这可能是传达此类内容和中介信息最有效的方式。你可以逐页浏览，无需任何真正的体力劳动，逐段阅读，只需扫描那些你不感兴趣的部分即可。
- en: The problem with thinking in pages too much is that this concept, which is borrowed
    from books, does not really translate well to how things work in the real world.
    The world is created from components that form a system of components together.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 过度思考页面的问题在于，这个从书籍中借用的概念并没有很好地转化为现实世界中事物的工作方式。世界是由形成组件系统的组件构成的。
- en: Take our bodies as an example. We mostly consist of independent organs that
    interact with each other using electrical and chemical signals. Organs themselves
    consist of proteins that, on their own work, like machines to form a system. Down
    to the molecules, atoms, protons, and quarks, we can't really tell where one starts
    and where it ends. What we can tell for sure is that it's all about systems of
    components with inter-dependencies, and it is not about pages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的身体为例。我们主要由相互通过电和化学信号交互的独立器官组成。器官本身由蛋白质组成，这些蛋白质本身就像机器一样工作，形成一个系统。从分子、原子、质子到夸克，我们实际上无法确定哪里开始哪里结束。我们可以肯定的是，这全部都是关于具有相互依赖性的组件系统，而不是关于页面。
- en: Modern user interfaces are very much like the real world consisting of systems
    of components. If, where, and how they are distributed to pages is subordinate
    while designing them. Also, they should work independently, and they should interact
    with each other on an interdependent level.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现代用户界面非常类似于现实世界中的组件系统。在设计时，它们在哪里、如何分布到页面上是次要的。此外，它们应该能够独立工作，并且应该在相互依赖的水平上相互交互。
- en: Components – the organs of user interfaces
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件——用户界面的器官
- en: '"We''re not designing pages, we''re designing systems of components."'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “我们不是在设计页面，我们是在设计组件系统。”
- en: '- Stephen Hay'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '- 斯蒂芬·海'
- en: This quote by Stephen Hay from BDConf in Orlando 2012 brings it to the point.
    Interface design is really not about pages. To create efficient user interfaces
    for not only the users but also the developers who maintain them, we need to think
    in systems of components. Components are independent, but they can interact with
    each other and create larger components when they are arranged together. We need
    to look at user interfaces holistically, and using components enables us to do
    this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话来自斯蒂芬·海在2012年奥兰多的BDConf上的发言，它点明了关键。界面设计实际上并不是关于页面。为了创建既高效又便于维护的用户界面，不仅是为了用户，也是为了维护它们的开发者，我们需要从组件系统的角度思考。组件是独立的，但当它们组合在一起时，可以相互交互并形成更大的组件。我们需要从整体上看待用户界面，而使用组件使我们能够做到这一点。
- en: In the following topics, we're going to explore a few fundamental aspects of
    components. Some of these are already known from other concepts, such as **object-oriented
    programming** (**OOP**), but they appear in a slightly different light when thinking
    about components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的主题中，我们将探讨组件的一些基本方面。其中一些已经从其他概念中得知，例如**面向对象编程**（**OOP**），但在考虑组件时它们呈现出不同的光景。
- en: Encapsulation
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is a very important factor when thinking about maintenance in
    a system. Having a classical OOP background, I've learned that encapsulation means
    bundling logic and data together into an isolated container. This way, we can
    operate on the container from the outside and treat it like a closed system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是在考虑系统维护时一个非常重要的因素。拥有经典的OOP背景，我了解到封装意味着将逻辑和数据捆绑到一个隔离的容器中。这样，我们可以从外部操作容器，并把它当作一个封闭系统来对待。
- en: 'There are many positive aspects of this approach when it comes to maintainability
    and accessibility. Dealing with closed systems is important for the organization
    of our code. However, this is even more important because we can organize ourselves
    while working with code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在可维护性和可访问性方面，这种方法有许多积极方面。处理封闭系统对于我们的代码组织很重要。然而，这甚至更重要，因为我们可以在编写代码的同时组织自己：
- en: '![](img/5faf118a-5fef-44b0-ae30-f3be751a0378.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5faf118a-5fef-44b0-ae30-f3be751a0378.png)'
- en: Organizing a system in encapsulated components allows us to reason about it
    much more easily
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以封装的组件组织系统使我们能够更容易地对其进行分析
- en: I have a pretty bad memory, and it's very important for me to find the right
    focus level when working on code. Immediate memory research has tells us that
    the human brain can remember about seven items at once on average. Therefore,
    it's crucial for us to write code in such a way that it allows us to focus on
    fewer and smaller pieces at once.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我的记忆力相当差，因此在编写代码时找到合适的专注程度对我来说非常重要。即时记忆研究告诉我们，人类大脑平均一次可以记住大约七个项目。因此，我们编写代码的方式必须允许我们一次专注于更少、更小的部分。
- en: A clear encapsulation helps us in organizing our code. We can perhaps forget
    all the internals of the closed system and about the kind of logic and data that
    we've put into it. We should focus only on its surface, which allows us to work
    on a higher-abstraction level. Similar to the previous diagram, without using
    a hierarchy of encapsulated components, we'd have all our code cobbled together
    on the same level.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的封装帮助我们组织代码。我们可能忘记封闭系统的所有内部细节以及我们放入其中的逻辑和数据类型。我们应该只关注其表面，这使我们能够在更高的抽象级别上工作。类似于之前的图示，如果不使用封装组件的层次结构，我们的所有代码都会在同一级别上拼凑在一起。
- en: Encapsulation encourages us to isolate small and concise components and build
    a system of components. During development, we can focus on the internals of one
    component and only deal with the interface of other components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 封装鼓励我们将小型且简洁的组件隔离出来，构建一个组件系统。在开发过程中，我们可以专注于一个组件的内部，只需处理其他组件的接口。
- en: Sometimes, we forget that all the organization of the coding we actually perform
    is for ourselves and not for the computer that runs this code. If this was for
    the computer, then we would probably all start writing in machine language again.
    A strong encapsulation helps us access specific code easily, focus on one layer
    of the code, and trust the underlying implementations within capsules.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们会忘记我们实际进行的所有编码组织都是为了我们自己，而不是运行此代码的计算机。如果是为了计算机，那么我们可能都会重新开始用机器语言编写。强大的封装帮助我们轻松访问特定代码，专注于代码的一层，并信任胶囊中的底层实现。
- en: 'The following TypeScript example shows you how to use encapsulation to write
    maintainable applications. Let''s assume that we are in a T-shirt factory, and
    we need some code to produce T-shirts with a background and foreground color.
    This example uses some language features of TypeScript. If you''re not familiar
    with the language features of TypeScript, don''t worry too much at this point.
    We will learn about these later in this chapter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的TypeScript示例展示了如何使用封装来编写可维护的应用程序。让我们假设我们在一个T恤工厂，我们需要一些代码来生成具有背景和前景颜色的T恤。此示例使用了一些TypeScript的语言特性。如果您不熟悉TypeScript的语言特性，请不要过于担心这一点。我们将在本章的后面学习这些内容：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using a clean encapsulation, we can now work with the abstraction of color in
    our T-shirt. We don't need to worry about how to calculate the hexadecimal representation
    of colors at the T-shirt level because this is already done by the `Color` class.
    This makes your application maintainable and keeps it very open for change.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用干净的封装，我们现在可以处理T恤上的颜色抽象。我们不需要担心如何计算T恤级别的颜色十六进制表示，因为`Color`类已经完成了这项工作。这使得应用程序易于维护，并且非常开放，便于更改。
- en: I strongly recommend that you read about the SOLID principles if you haven't
    done so already. As the name already suggests, this assembly of principles is
    a solid power tool that can change the way you organize code tremendously. You
    can learn more about the SOLID principles in the book *Agile Principles, Patterns*,
    *and Practices,* by Robert C. Martin.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，我强烈建议您阅读有关SOLID原则的内容。正如其名称所暗示的，这个原则的集合是一个强大的工具，可以极大地改变您组织代码的方式。您可以在罗伯特·C·马丁的《敏捷原则、模式和实践》一书中了解更多关于SOLID原则的内容。
- en: Composability
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合性
- en: Composition is a special kind of reusability. You don't extend an existing component,
    but you create a new, larger component by composing many smaller components together
    into a system of components.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种特殊的可重用性。你不是扩展现有组件，而是通过将许多较小的组件组合在一起形成一个组件系统来创建一个新的、更大的组件。
- en: In OOP languages, composition is often used to get around the multiple inheritance
    issues that most OOP languages have. Subclass polymorphism is always great until
    you reach the point where your design does not match the latest requirements in
    your project. Let's look at a simple example that illustrates this problem.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程语言中，组合通常用于解决大多数面向对象编程语言都存在的多重继承问题。子类多态性总是很好的，直到你达到你的设计不再符合项目最新要求的地步。让我们看看一个简单的例子，说明这个问题。
- en: 'You have a `Fisher` class and a `Developer` class, both of which hold specific
    behaviors. Now, you''d want to create a `FishingDeveloper` class that inherits
    from both `Fisher` and `Developer`. Unless you''re using a language that supports
    multiple inheritance (such as C++, which does this to a certain extent), you will
    not be able to reuse this functionality using inheritance. There is no way to
    tell the language that your new class should inherit from both superclasses. Using
    composition, you can easily solve this problem. Instead of using inheritance,
    you''re composing a new `FishingDeveloper` class that delegates all behavior to
    an internal `Developer` and `Fisher` instance:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个`Fisher`类和一个`Developer`类，它们都持有特定的行为。现在，你想要创建一个继承自`Fisher`和`Developer`的`FishingDeveloper`类。除非你使用支持多重继承的语言（例如C++，它在一定程度上这样做），否则你将无法使用继承重用这个功能。没有办法告诉语言你的新类应该从两个超类继承。使用组合，你可以轻松解决这个问题。你不需要使用继承，而是组合一个新的`FishingDeveloper`类，将所有行为委托给内部的`Developer`和`Fisher`实例：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Experience has taught us that composition is probably the most efficient way
    to reuse code. In contrast to inheritance, decoration, and other approaches to
    gain reusability, composition is probably the least intrusive and the most flexible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 经验告诉我们，组合可能是重用代码最有效的方式。与继承、装饰和其他提高可重用性的方法相比，组合可能是最不侵入性和最灵活的。
- en: Recent versions of some languages also support a pattern called traits, that
    is, `mixins`. Traits allow you to reuse certain functionality and attributes from
    other classes in a way that is similar to multiple inheritance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言的最新版本也支持一种称为特质的模式，即混合。特质允许你以类似于多重继承的方式重用其他类中的某些功能性和属性。
- en: If we think about the concept of composition, it's nothing more than designing
    organisms. We have the two `Developer` and `Fisher` organisms, and we unify their
    behaviors into a single `FishingDeveloper` organism.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们思考组合的概念，它不过是设计生物体。我们有两个`Developer`和`Fisher`生物体，并将它们的行为统一到一个单一的`FishingDeveloper`生物体中。
- en: Components, invented by nature
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件，自然界发明
- en: Components, embracing encapsulation, and composition are an effective way to
    build maintainable applications. Composed from components, applications are very
    resistant to the negative implications of change, and change is a necessary thing
    that will happen to every application. It's only a matter of time until your design
    will be challenged by the effects of change; therefore, it's very important to
    write code that can handle change as smoothly as possible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 组件、拥抱封装和组合是构建可维护应用的有效方式。由组件组成的应用对变化的负面影响具有很强的抵抗力，而变化是每个应用都会发生的事情。你的设计最终将受到变化效应的挑战，这只是时间问题；因此，编写尽可能平滑地处理变化的代码非常重要。
- en: Nature is the best teacher. Almost all the achievements in technological developments
    have their origin in observations of how nature solves problems. If we look at
    evolution, it's an ongoing redesign of matter by adapting to outer forces and
    constraints. Nature solves this by constant change using mutation and natural
    selection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 自然是最好的老师。几乎所有技术发展的成就都源于对自然界解决问题方式的观察。如果我们看看进化，它就是通过适应外部力量和约束对物质进行持续重新设计。自然界通过突变和自然选择来通过不断变化解决这个问题。
- en: If we project the concept of evolution onto developing an application, we can
    say that nature does actually refactor its code in every single moment. This is
    actually the dream of every product manager—an application that can undergo constant
    change but does not lose any of its efficiency.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将进化的概念投射到应用开发中，我们可以说自然界实际上在每一刻都在重构其代码。这实际上是每个产品经理的梦想——一个可以经历持续变化但不会失去任何效率的应用。
- en: I believe that there are two key concepts that play a major role in nature that
    allows it to apply constant change in its design without losing much efficiency.
    This uses encapsulation and composition. Coming back to the example of our bodies,
    we can actually tell that our organs use a very clear encapsulation. They use
    membranes to create isolation, veins to transport nutrition, and synapses to send
    messages. Also, they have interdependencies, and they communicate using electrical
    and chemical messages. Most obviously, they form larger systems, which is the
    core concept of composition.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为有两个关键概念在自然界中起着重要作用，使得它能够在设计中不断变化而不会失去太多效率。这使用了封装和组合。回到我们身体的例子，我们实际上可以告诉我们的器官使用了一种非常清晰的封装。它们使用膜来创建隔离，使用静脉来输送营养，使用突触来发送信息。此外，它们有相互依赖性，并且通过电化学信息进行交流。最明显的是，它们形成了更大的系统，这是组合的核心概念。
- en: Of course, there are many other factors, and I'm not a professor in biology.
    However, I think it's a fascinating thing to see that we have learned to organize
    our code very similarly to how nature organizes matter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他因素，我并不是生物学的教授。然而，我认为看到我们学会了以与自然界组织物质相似的方式组织我们的代码，这是一件非常有趣的事情。
- en: 'The idea of creating reusable UI components is quite old, and it was implemented
    in various languages and frameworks. One of the earliest systems that used UI
    components was probably the Xerox Alto system back in the 1970s. It used reusable
    UI components that allowed developers to create an application by composing them
    on a screen where users could interact with them:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可重用UI组件的想法相当古老，并且在各种语言和框架中得到了实现。可能最早使用UI组件的系统是20世纪70年代的Xerox Alto系统。它使用了可重用的UI组件，允许开发者通过在用户可以与之交互的屏幕上组合它们来创建应用程序：
- en: '![](img/9d2bea33-8b29-4b01-b690-a4daddf9b714.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d2bea33-8b29-4b01-b690-a4daddf9b714.png)'
- en: The user interface of file manager on the Xerox Alto system from the 1970s
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪70年代的Xerox Alto系统上的文件管理器用户界面
- en: Early frontend UI frameworks, such as DHTMLX, Ext JS, or jQuery UI implemented
    components in a more limited fashion that didn't provide great flexibility or
    extensibility. Most of these frameworks just provided widget libraries. The problem
    with UI widgets is that they mostly don't embrace the pattern of composition enough.
    You can arrange widgets on a page and they provide encapsulation, but with most
    toolkits, you can't create larger components by nesting them inside each other.
    Some toolkits solve this by providing a special kind of widget which was mostly
    called a container. However, this is not the same as a full-fledged component
    tree that allows you to create systems within systems. Containers were actually
    meant to provide a visual layout container rather than a composite container to
    form a larger system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的前端UI框架，如DHTMLX、Ext JS或jQuery UI，以更有限的方式实现组件，这并没有提供很大的灵活性或可扩展性。这些框架中的大多数只是提供了小部件库。UI小部件的问题在于它们大多数并没有充分拥抱组合模式。你可以在页面上排列小部件，并且它们提供了封装，但大多数工具包中，你不能通过嵌套来创建更大的组件。一些工具包通过提供一种特殊类型的小部件来解决此问题，这通常被称为容器。然而，这并不等同于允许你创建系统内系统的完整组件树。实际上，容器是为了提供视觉布局容器而不是复合容器来形成更大的系统。
- en: Usually, when working with widgets on a page of our application, we'd have a
    large controller that controls all these widgets, user input, and states. However,
    we are left with two levels of composition, and there's no way that we can structure
    our code more granularly. There is the page and there are the widgets. Having
    a bunch of UI widgets is simply not enough, and we are almost back to the state
    where we create pages plastered with form elements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们在应用程序的页面上处理小部件时，我们会有一个大控制器来控制所有这些小部件、用户输入和状态。然而，我们只剩下两个层次的组合，我们无法以更细粒度的方式结构化我们的代码。这里有页面，这里有小部件。仅仅有一堆UI小部件是不够的，我们几乎回到了创建满是表单元素页面的状态。
- en: I've been a user of JavaServer Faces for years, and besides all its problems,
    the concept of having reusable custom elements was groundbreaking. Using XHTML,
    one could write so-called composite components that consisted of other composite
    components or native HTML elements. A developer could gain a fantastic level of
    reusability using composition. In my view, the big issue with this technology
    was that it did not address the concerns in the frontend enough to become really
    usable for complex user interactions. In fact, a framework like this should live
    completely within the frontend.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用JavaServer Faces多年了，尽管它存在许多问题，但拥有可重用自定义元素的概念是革命性的。使用XHTML，可以编写所谓的复合组件，这些组件由其他复合组件或原生HTML元素组成。开发者可以通过组合获得极高的可重用性。在我看来，这个技术的重大问题是它没有足够解决前端的问题，以至于无法真正用于复杂的用户交互。事实上，这样的框架应该完全存在于前端。
- en: My UI framework wishlist
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的UI框架愿望清单
- en: 'Usually, when UI frameworks get compared, they get measured against each other
    based on metrics, such as widget count, theming capabilities, and asynchronous
    data retrieval features. Each framework has its strengths and weaknesses, but
    leaving all the extra features aside and reducing it to the core concerns of a
    UI framework, I only have a few metrics left that I''d like to be assessed. These
    metrics are, of course, not the only ones that are important in today''s UI development,
    but they also are the main factors toward building a clean architecture that supports
    the principle of change:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当UI框架被比较时，它们会根据指标相互比较，例如小部件计数、主题功能和异步数据检索功能。每个框架都有其优点和缺点，但抛开所有额外功能，将其简化为UI框架的核心关注点，我只剩下几个指标想要评估。当然，这些指标并不是今天UI开发中唯一重要的指标，但它们也是构建支持变化原则的清晰架构的主要因素：
- en: I can create encapsulated components with clear interfaces
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以创建具有清晰接口的封装组件
- en: I can create larger components by using composition
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以通过组合来创建更大的组件
- en: I can make components interact with each other within their hierarchy
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以让组件在其层次结构内相互交互
- en: If you're looking for a framework which enables you to take full advantage of
    component-based UI development, you should look for these three key measures.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个能够让你充分利用基于组件的UI开发的框架，你应该寻找这三个关键指标。
- en: First of all, I think it's very important to understand the main purpose of
    the web and how it evolved. If we think of the web in its early days in the 1990s,
    it was probably only about hypertext. There were very basic semantics that could
    be used to structure information and display them to a user. HTML was created
    to hold structure and information. The need for custom visual presentation of
    information led to the development of CSS right after HTML started being widely
    used.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我认为了解网络的主要目的及其演变过程非常重要。如果我们回想一下20世纪90年代的早期网络，它可能只是关于超文本。有一些非常基本的语义可以用来结构化信息并将其显示给用户。HTML被创建来存储结构和信息。对信息定制视觉呈现的需求导致了CSS在HTML开始广泛使用后不久的发展。
- en: 'It was in the mid 1990s when Brendan Eich invented JavaScript, and it was first
    implemented in Netscape Navigator. By providing a way to implement behavior and
    state, JavaScript was the last missing piece for a full web customization:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 布兰登·艾奇在20世纪90年代中期发明了JavaScript，并且它最初是在Netscape Navigator中实现的。通过提供实现行为和状态的方法，JavaScript成为了实现完整网页定制的最后一块缺失的拼图：
- en: '| **Technology** | **Concern** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **技术** | **关注点** |'
- en: '| HTML | Structure and information |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| HTML | 结构和信息 |'
- en: '| CSS | Presentation |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| CSS | 布局 |'
- en: '| JavaScript | Behavior and state |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript | 行为和状态 |'
- en: We have learned to keep these concerns as separate as possible in order to maintain
    a clean architecture. Although there are different opinions on this and some recent
    technologies also move away from this principle, I believe that a clean separation
    of these concerns is very important to create a maintainable application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了尽可能地将这些关注点分开，以保持清晰的架构。尽管对此有不同的看法，并且一些最近的技术也开始偏离这一原则，但我认为这些关注点的清晰分离对于创建可维护的应用程序非常重要。
- en: Leaving this view aside, the standard definition of encapsulation from OOP is
    just concerned about coupling and isolation of logic and data. This probably applies
    well to classic software components. However, as soon as we consider a user interface
    as part of an architecture, there is a new dimension that is added.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个视图放在一边，面向对象编程中封装的标准定义只是关注逻辑和数据耦合与隔离。这可能很好地适用于经典软件组件。然而，一旦我们将用户界面视为架构的一部分，就会增加一个新的维度。
- en: Classical MVC frameworks are view centric, and developers organize their code
    based on pages. You'll probably go ahead and create a new view that represents
    a page. Of course, your view needs a controller and model, so you'll also create
    them. The problem with organization by pages is that there's little to no gain
    of reusability. Once you've created a page and you'd like to reuse only some parts
    of the page, you will need a way to encapsulate only a specific part of this model—the
    view and the controller.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的MVC框架以视图为中心，开发者根据页面组织代码。你可能会继续创建一个新的视图来表示一个页面。当然，你的视图需要一个控制器和模型，所以你也会创建它们。按页面组织的问题在于，几乎没有获得复用性的收益。一旦你创建了一个页面，你只想重用页面的一部分，你需要一种方法来封装这个模型的具体部分——视图和控制器。
- en: 'UI components solve this problem nicely. I like to see them as a modular approach
    to MVC. Although they still embrace the MVC pattern, they also establish encapsulation
    and composability. This way, a view is a component itself, but it also consists
    of components. By composing views of components, one can gain a maximum amount
    of reusability:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: UI组件很好地解决了这个问题。我喜欢把它们看作是MVC的模块化方法。尽管它们仍然遵循MVC模式，但它们也建立了封装和可组合性。这样，视图本身就是一个组件，但它也由组件组成。通过组合组件的视图，可以最大限度地提高复用性：
- en: '![](img/28b15560-c5f9-4cec-8700-316c64d26140.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28b15560-c5f9-4cec-8700-316c64d26140.png)'
- en: UI components embrace MVC, but they also support encapsulation and composition
    on a much lower level
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: UI组件拥抱MVC，但它们在更低的层面上也支持封装和组合。
- en: Technically, there are some challenges when implementing components with web
    technologies. JavaScript was always flexible enough to implement different patterns
    and paradigms. Working with encapsulation and composition isn't an issue at all,
    and the controlling part and the model of components can easily be implemented.
    Approaches, such as the revealing module pattern, namespaces, prototypes, or the
    recent ECMAScript 6 modules, provide all the tools that are needed from the JavaScript
    side.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，使用Web技术实现组件时存在一些挑战。JavaScript始终足够灵活，可以实施不同的模式和范式。与封装和组合一起工作根本不是问题，组件的控制部分和模型可以轻松实现。例如，揭示模块模式、命名空间、原型或最近的ECMAScript
    6模块等方法，都提供了从JavaScript方面需要的所有工具。
- en: However, for the view part of our components, we face some limitations. Although
    HTML supports great flexibility in terms of composability because the DOM tree
    is nothing else than a big composition, we have no way to reuse these compositions.
    We can only create one large composition, which is the page itself. HTML being
    only the final view that was delivered from the server, this was never really
    a real concern. Today's applications are much more demanding, and we need to have
    a fully-encapsulated component running in the browser, which also consists of
    a partial view.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于组件的视图部分，我们面临一些限制。尽管HTML在可组合性方面提供了很大的灵活性，因为DOM树本质上就是一个大型的组合，但我们无法重用这些组合。我们只能创建一个大的组合，即页面本身。HTML只是从服务器端交付的最终视图，这从来就不是真正的问题。今天的应用程序要求更高，我们需要在浏览器中运行一个完全封装的组件，它还包含部分视图。
- en: We face the same problem with CSS. There is no real modularization and encapsulation
    while writing CSS, and we need to use namespaces and prefixes in order to segregate
    our CSS styles. Still, the whole cascading nature of CSS can easily destroy all
    encapsulation that we try to bring in place using CSS structuring patterns.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在CSS上也面临着同样的问题。在编写CSS时，没有真正的模块化和封装，我们需要使用命名空间和前缀来隔离我们的CSS样式。尽管如此，CSS的整个级联特性很容易破坏我们试图通过CSS结构模式引入的任何封装。
- en: Time for new standards
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新标准的时间到了
- en: Web standards have been evolving immensely in the last couple of years. There
    are so many new standards, and the browser became such a big multimedia framework,
    that it's hard for other platforms to compete with this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，Web标准已经发生了巨大的变化。有如此多的新标准，浏览器已经成为一个如此庞大的多媒体框架，以至于其他平台很难与之竞争。
- en: I'd even go as far as to say that web technology will actually replace other
    frameworks in the future, and it probably will be renamed to multimedia technology
    or something similar. There's no reason why we need to use different native frameworks
    to create user interfaces and presentations. Web technologies embed so many features
    that it's hard to find a reason not to use them for any kind of application. Just
    look at the Firefox OS or the Chrome OS, which are designed to run with web technologies.
    I think it's only a matter of time until more operating systems and embedded devices
    make use of web technologies to implement their software. This is why I believe
    that at some point it will be questionable whether the term *web technologies*
    is still appropriate or whether we should replace it with a more general term.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至可以说，Web 技术实际上将在未来取代其他框架，并且它可能将被重新命名为多媒体技术或类似的东西。我们没有理由需要使用不同的原生框架来创建用户界面和演示。Web
    技术集成了许多功能，很难找到不使用它们的理由。只需看看 Firefox OS 或 Chrome OS，它们都是设计用来使用 Web 技术运行的。我认为这只是时间问题，直到更多操作系统和嵌入式设备开始利用
    Web 技术来实现它们的软件。这就是为什么我相信在某个时刻，*Web 技术* 这个术语是否仍然合适，或者我们应该用更通用的术语来替代它，将变得可疑。
- en: Although we usually just see new features appear in browsers, there is a very
    open and long-winded standardization process behind them. It's very important
    to standardize features, but this takes a lot of time, especially when people
    disagree about different approaches to solving problems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通常只看到浏览器中新功能的出现，但它们背后有一个非常开放且冗长的标准化过程。标准化功能非常重要，但这需要花费大量时间，尤其是在人们对于解决问题的不同方法存在分歧时。
- en: Coming back to the concept of components, this is something where we really
    need support from web standards to break the current limitations. Fortunately,
    the W3C (World Wide Web Consortium) thought the same, and a group of developers
    started to work on specifications under the hood of an umbrella specification
    called *web components*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回到组件的概念，这是我们真正需要 Web 标准支持以突破当前限制的地方。幸运的是，W3C（万维网联盟）也有同样的想法，一群开发者开始在名为 *Web 组件*
    的伞形规范下制定规范。
- en: The following topics will give you a brief overview over two specifications
    that also play a role in Angular components. One of Angular's core strengths is
    that it acts more like a superset of web standards rather than being a complete
    isolated framework.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下主题将为您简要概述两个在 Angular 组件中也起到作用的规范。Angular 的核心优势之一是它更像是一个 Web 标准的超集，而不是一个完全独立的框架。
- en: Template elements
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板元素
- en: Template elements allow you to define regions within your HTML, which will not
    be rendered by the browser. You can then instantiate these document fragments
    with JavaScript and then place the resulting DOM within your document.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元素允许您在 HTML 中定义不会由浏览器渲染的区域。然后，您可以使用 JavaScript 实例化这些文档片段，并将生成的 DOM 放置在文档中。
- en: 'While the browser is actually parsing the template content, it only does so
    in order to validate the HTML. Any immediate actions that the parser would usually
    execute will not be taken. Within the content of template elements, images will
    not be loaded and scripts won''t be executed. Only after a template is instantiated
    will the parser take the necessary actions, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器实际上正在解析模板内容时，它只是为了验证 HTML。解析器通常执行的所有即时操作都不会被执行。在模板元素的内容中，图像不会加载，脚本也不会执行。只有当模板被实例化后，解析器才会采取必要的行动，如下所示：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This simple HTML example of a template element won''t display the heading on
    your page. As the heading is inside a template element, we first need to instantiate
    the template and add the resulting DOM into our document:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的 HTML 模板元素示例不会在您的页面上显示标题。因为标题位于模板元素内部，我们首先需要实例化模板，并将生成的 DOM 添加到我们的文档中：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using these three lines of JavaScript, we can instantiate the template and append
    it into our document.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三行 JavaScript，我们可以实例化模板并将其附加到我们的文档中。
- en: Template elements are used by Angular in order to instantiate dynamic parts
    of your user interface. This will be the case while conditionally rendering parts
    of your template using the `ngIf` directive, or by repeating a template using
    the `ngFor` directive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用模板元素来实例化用户界面的动态部分。这将在使用 `ngIf` 指令有条件地渲染模板的部分时发生，或者通过使用 `ngFor` 指令重复模板时发生。
- en: Shadow DOM
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阴影 DOM
- en: This part of the web components specification was the missing piece to create
    proper DOM encapsulation and composition. With shadow DOM, we can create isolated
    parts of the DOM that are protected against regular DOM operations from the outside.
    Also, CSS will not reach into shadow DOM automatically, and we can create local
    CSS within our component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分Web组件规范是创建适当DOM封装和组合所缺失的部分。有了阴影DOM，我们可以创建隔离的DOM部分，这些部分可以防止外部常规DOM操作。此外，CSS不会自动进入阴影DOM，我们可以在我们的组件内创建局部CSS。
- en: If you add a `style` tag inside shadow DOM, the styles are scoped to the root
    within the shadow DOM, and they will not leak outside. This enables a very strong
    encapsulation for CSS.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`style`标签添加到阴影DOM内部，样式将限定在阴影DOM的根元素内，并且它们不会泄露到外部。这为CSS提供了非常强大的封装。
- en: Content insertion points make it easy to control content from the outside of
    a shadow DOM component, and they provide some kind of an interface to pass in
    content.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 内容插入点使得从阴影DOM组件的外部控制内容变得容易，并且它们提供了一种传递内容的接口。
- en: At the time of writing this book, shadow DOM is supported by most browsers,
    although it still needs to be enabled in Firefox.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，大多数浏览器都支持阴影DOM，尽管在Firefox中仍需要启用。
- en: Angular's component architecture
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的组件架构
- en: For me, the concept of directives from the first version of Angular changed
    the game in frontend UI frameworks. This was the first time that I felt that there
    was a simple yet powerful concept that allowed the creation of reusable UI components.
    Directives could communicate with DOM events or messaging services. They allowed
    you to follow the principle of composition, and you could nest directives and
    create larger directives that solely consisted of smaller directives arranged
    together. Actually, directives were a very nice implementation of components for
    the browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，Angular第一版中指令的概念改变了前端UI框架的游戏规则。这是我第一次感觉到有一个简单而强大的概念，允许创建可重用的UI组件。指令可以与DOM事件或消息服务进行通信。它们允许你遵循组合原则，你可以嵌套指令并创建由较小指令组合而成的较大指令。实际上，指令是浏览器中组件的一个非常好的实现。
- en: In this section, we'll look into the component-based architecture of Angular
    and how the things we've learned about components will fit into Angular.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Angular的组件化架构以及我们关于组件所学的知识如何融入Angular。
- en: Everything is a component
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都是组件
- en: 'As an early adopter of Angular and while talking to other people about it,
    I got frequently asked what the biggest difference is to the first version. My
    answer to this question was always the same. Everything is a component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Angular的早期采用者，在与其他人谈论它时，我经常被问及与第一版最大的区别是什么。我对这个问题的回答总是相同的。一切都是组件：
- en: '![](img/13215666-a7c2-4de6-a1f3-e79fe772858f.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13215666-a7c2-4de6-a1f3-e79fe772858f.png)'
- en: Within the Angular architecture, a component is a directive with an additional
    view
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular架构中，组件是一个具有附加视图的指令。
- en: For me, this paradigm shift was the most relevant change that both simplified
    and enriched the framework. Of course, there are a lot of other changes with Angular.
    However, as an advocate of component-based user interfaces, I've found that this
    change is the most interesting one. Of course, this change also came with a lot
    of architectural changes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这种范式转变是简化并丰富了框架的最相关变化。当然，Angular还有很多其他的变化。然而，作为一个基于组件的用户界面倡导者，我发现这个变化是最有趣的。当然，这个变化也伴随着许多架构上的变化。
- en: Angular supports the idea of looking at the user interface holistically and
    fosters composition with components. However, the biggest difference to its first
    version is that now, your pages are no longer global views; they are simply components
    that are assembled from other components. If you've been following this chapter,
    you'll notice that this is exactly what a holistic approach to user interfaces
    demands. No more pages, but systems of components.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持从整体上看待用户界面的想法，并鼓励使用组件进行组合。然而，与第一版最大的区别是，现在你的页面不再是全局视图；它们只是由其他组件组装而成的组件。如果你一直在跟随本章，你会注意到这正是整体方法对用户界面所要求的。不再有页面，而是组件系统。
- en: Angular still uses the concept of directives, although directives are now really
    what the name suggests. They are orders for the browser to attach a given behavior
    to an element. Components are a special kind of directive that come with a view.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular仍然使用指令的概念，尽管指令现在确实如其名称所暗示的那样。它们是浏览器附加给定行为的命令。组件是一种带有视图的特殊指令。
- en: Your first component
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个组件
- en: 'Keeping up the tradition, before we start building a real application together,
    we should write our first `hello world` component with Angular:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照传统，在我们开始一起构建真实的应用程序之前，我们应该使用Angular编写我们的第一个`hello world`组件：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is already a fully-working Angular component. We used ECMAScript 6 classes
    to create the necessary encapsulation required for a component. You can also see
    a meta-annotation that is used to declaratively configure our component. This
    statement, which looks like a function call that is prefixed with an *at* symbol,
    actually comes from the ECMAScript 7 decorator proposal. For the moment, you can
    think of decorators as a way to attach metadata to our component class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一个完全工作的Angular组件。我们使用了ECMAScript 6类来创建组件所需的封装。你还可以看到用于声明性配置我们的组件的元注解。这个看起来像是一个带有*at*符号前缀的函数调用的语句，实际上来自ECMAScript
    7装饰器提案。目前，你可以将装饰器视为将元数据附加到我们的组件类的一种方式。
- en: ECMAScript 7 decorators are still very experimental at the time of writing this
    book. We're using TypeScript in the examples of this book, which is already implementing
    the decorator proposal with a slight twist. The Angular core team has decided
    to go with this experimental technology, since it reduces the overall amount of
    code and introduces an aspect oriented flavor to the Angular API.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，ECMAScript 7装饰器仍然非常实验性。我们在本书的示例中使用了TypeScript，它已经通过轻微的修改实现了装饰器提案。Angular核心团队决定采用这种实验性技术，因为它减少了代码总量，并为Angular
    API引入了面向方面的风味。
- en: It's important to understand that an element can only be bound to one single
    component. As a component always comes with a view, there is no way that we can
    bind more than one component to an element. On the other hand, an element can
    be bound to many directives, as directives don't come with a view—they only attach
    behavior.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，一个元素只能绑定到一个单一组件。因为组件总是带有视图，所以我们无法将多个组件绑定到元素上。另一方面，一个元素可以绑定到多个指令，因为指令不带有视图——它们只附加行为。
- en: In the `Component` decorator, we need to configure everything that is relevant
    to describe our component for Angular. This, of course, also includes our template
    for the view. In the preceding example, we are specifying our template directly
    within JavaScript as a string. We can also use the `templateUrl` property to specify
    a URL where the template should be loaded from.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Component`装饰器中，我们需要配置与描述我们的组件相关的所有内容，以便Angular使用。这当然也包括我们的视图模板。在前面的示例中，我们直接在JavaScript中以字符串的形式指定了我们的模板。我们还可以使用`templateUrl`属性来指定模板应该从中加载的URL。
- en: The second configuration, applied using the `selector` property, allows us to
    specify a CSS selector, which is used by Angular to attach the component to certain
    elements within our view. Every time Angular encounters an element which matches
    the component's selector, it will render the given component into that element.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种配置，通过使用`selector`属性应用，允许我们指定一个CSS选择器，Angular使用这个选择器将组件附加到我们视图中的某些元素上。每次Angular遇到与组件选择器匹配的元素时，它都会将给定的组件渲染到该元素中。
- en: 'Now, let''s enhance our example a little bit so that we can see how we can
    compose our application from smaller components:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微增强我们的示例，以便我们可以看到我们如何从更小的组件中组合我们的应用程序：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that we have now created a small component that allows us to shout
    out words as we like. In our *Hello World* application, we make use of this component
    to shout out Hello, World!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们现在创建了一个小组件，允许我们像我们喜欢的那样大声喊出单词。在我们的*Hello World*应用程序中，我们使用这个组件来大声喊出Hello,
    World!
- en: Within the template of our hello world component, we are including the shouting
    component by placing an HTML element which matches the CSS element selector of
    the shouting component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的hello world组件的模板中，我们通过放置一个与喊话组件的CSS元素选择器匹配的HTML元素来包含喊话组件。
- en: Over the course of this book and while writing our task management application,
    we will learn a lot more about the configuration and implementation of components.
    However, before we start with this in the [Chapter 2](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml),
    *Ready, Set, Go!*, we should take a look at some tools and language features that
    we'll use during this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，以及编写我们的任务管理应用时，我们将学习更多关于组件配置和实现的知识。然而，在我们开始 [第 2 章](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml)
    “准备，设置，启动！”之前，我们应该看看本书中我们将使用的一些工具和语言特性。
- en: Angular NgModule
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular NgModule
- en: Organizing an application solely by composing components comes with some challenges.
    Angular supports the concept of application modules, which essentially are just
    containers around components that help structure your application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过组合组件来组织应用会带来一些挑战。Angular 支持应用模块的概念，本质上这些模块只是组件的容器，有助于结构化你的应用。
- en: 'The concept of `NgModule` was introduced to mainly solve the following issues:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgModule` 的概念引入主要是为了解决以下问题：'
- en: '**Explicit template parsing**:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式模板解析**：'
- en: With the use of modules and by declaring all components, directives, pipes,
    and providers which are used inside of your application module, Angular is able
    to parse HTML templates very explicitly. This is really helpful when it comes
    to debugging. Let's say you're including an element within one of your component
    templates which does not match any of the selectors specified by the components
    within your module. Angular can now assert an error because you explicitly told
    it what components are available within your module. Without telling Angular which
    components belong to your application module, it would not be able to know if
    you're including a non-existing component within your template.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用模块并声明应用模块内部使用的所有组件、指令、管道和提供者，Angular 能够非常明确地解析 HTML 模板。这在调试时非常有帮助。假设你在组件模板中包含了一个元素，而这个元素与模块内组件指定的任何选择器都不匹配。现在
    Angular 可以断言一个错误，因为你明确地告诉了它模块内可用的组件。如果不告诉 Angular 哪些组件属于你的应用模块，它将无法知道你是否在模板中包含了不存在的组件。
- en: '**Simpler dependency resolution**:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简单的依赖解析**：'
- en: Since Angular can now simply resolve your main application module to find out
    what components are present within your application, things get simplified a lot.
    Imagine you have a very complex application existing of hundreds of components.
    Without modules, Angular would need to follow each individual component to find
    out how they are dependent on each other. With modules, Angular can simply check
    what components are declared inside of the module to find all components.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Angular 现在可以简单地解析主应用模块以找出应用中存在哪些组件，因此事情变得简单多了。想象一下，你有一个由数百个组件组成的非常复杂的应用。没有模块，Angular
    需要逐个跟踪每个组件，以找出它们之间的依赖关系。有了模块，Angular 可以简单地检查模块内部声明的组件，以找到所有组件。
- en: '**Lazy loading with the Angular router**:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Angular 路由的懒加载**：'
- en: The router of Angular is able to load parts of your application lazily when
    required. This is a very powerful feature, but it requires that you declare a
    bundle of application artefacts like components or directives, to be loaded asynchronously
    after your main application has started. `NgModule` comes in very handy at this
    point. By creating a separate module using `NgModule`, you can now define a part
    of your application consisting of new components and other artefacts. Within the
    build of your application, this module is then built separately into its own JavaScript
    resource, which can be loaded asynchronously at runtime by the router.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Angular 的路由器能够在需要时懒加载应用的部分。这是一个非常强大的功能，但它要求你声明一个包含组件或指令等应用实体的包，以便在主应用启动后异步加载。在这个时候，`NgModule`
    非常有用。通过使用 `NgModule` 创建一个单独的模块，你现在可以定义应用的一部分，包括新的组件和其他实体。在应用的构建过程中，这个模块将单独构建成自己的
    JavaScript 资源，然后可以在运行时由路由器异步加载。
- en: 'Your application requires at least one main module, which is declaring all
    your application components. Let''s look at a very simple example and build the
    main module for our `HelloWorld` component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用至少需要一个主模块，该模块声明了所有应用组件。让我们来看一个非常简单的例子，并构建 `HelloWorld` 组件的主模块：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similar to a component definition, we''re using an ES6 class and a decorator
    to define an Angular module. The `NgModule` decorator of our main application
    module has three configuration properties:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件定义类似，我们使用ES6类和装饰器来定义Angular模块。我们主应用程序模块的`NgModule`装饰器有三个配置属性：
- en: '![](img/1b9f7f60-d99f-4a9e-81b0-0ddfa1636612.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b9f7f60-d99f-4a9e-81b0-0ddfa1636612.png)'
- en: 'A module dependency tree: Module A importing module B and C so that all components
    are available to module A'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 模块依赖树：模块A导入模块B和C，以便所有组件都对模块A可用
- en: The `declarations` property is used to tell Angular what components, directives,
    and pipes are present within this module. If our application consists of 30 components,
    we need to add them all to the declarations of the `NgModule`. Every time you
    create a new component, you will also need to add it to the declarations array
    within your application module.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`declarations`属性用于告诉Angular该模块中存在哪些组件、指令和管道。如果我们的应用程序由30个组件组成，我们需要将它们全部添加到`NgModule`的声明中。每次你创建一个新的组件时，你也需要将其添加到应用程序模块中的声明数组中。'
- en: Within the array of the `imports` property, we can tell Angular to import other
    `NgModule`. This way, you can compose your application modules from many smaller
    modules if you like. However, there's no real benefit of structuring your application
    into submodules, unless you're exporting a submodule as a library, or if you're
    using the lazy loading feature of the router, as discussed earlier. It's crucial
    that you always import the Angular `BrowserModule` within your main application
    module. The `BrowserModule` contains all the Angular core components, directives,
    and other dependencies which are required in order to run your application within
    a browser environment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`imports`属性的数组中，我们可以告诉Angular导入其他`NgModule`。这样，如果你喜欢，你可以从许多较小的模块中组合你的应用程序模块。然而，除非你将子模块作为库导出，或者你正在使用之前讨论过的路由器的懒加载功能，否则将应用程序结构化为子模块并没有真正的优势。在主应用程序模块中始终导入Angular的`BrowserModule`是至关重要的。`BrowserModule`包含所有在浏览器环境中运行应用程序所需的Angular核心组件、指令和其他依赖项。
- en: Finally, the `bootstrap` property is telling Angular which of your components
    should be rendered first. You should specify your main application component here,
    which is representing the root component of your application. In the second chapter
    of this book, we'll take a closer look at the bootstrapping mechanism of Angular.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`bootstrap`属性告诉Angular哪些组件应该首先渲染。你应该在这里指定你的主应用程序组件，它代表你应用程序的根组件。在这本书的第二章中，我们将更详细地探讨Angular的引导机制。
- en: JavaScript of the future
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来的JavaScript
- en: It was not so long ago that somebody asked me whether we should really use the
    bind function of ECMAScript 5.1, as then we'd probably run into browser compatibility
    issues. The web moves very fast, and we need to keep up the pace. We can't write
    code that does not use the latest features, even if this would cause issues in
    old browsers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，有人问我我们是否真的应该使用ECMAScript 5.1的bind函数，因为这样我们可能会遇到浏览器兼容性问题。网络发展非常快，我们需要跟上节奏。我们不能编写不使用最新特性的代码，即使这会在旧浏览器中引起问题。
- en: The fantastic people from TC39, the technical committee that is responsible
    for writing the ECMAScript specification, have done a great job progressively
    enhancing the JavaScript language. This, and the fact that JavaScript is so flexible,
    allows us to use so-called polyfills and shims to make our code run in older browsers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 负责编写ECMAScript规范的技术委员会TC39的杰出人士们已经出色地逐步增强了JavaScript语言。这一点，加上JavaScript的灵活性，使我们能够使用所谓的polyfills和shims来使我们的代码在旧浏览器中运行。
- en: ECMAScript 6 (also referred to as ECMAScript 2015) was published in June 2015,
    exactly four years after its predecessor. There is a massive amount of new API
    additions as well as a whole bunch of new language features. The language features
    are syntactic sugar, and ECMAScript 6 can be transpiled to its previous version
    where it runs perfectly in older browsers. At the time of writing this book, none
    of the current browser versions have fully implemented ECMAScript 6, but there's
    absolutely no reason not to use it for production applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6（也称为ECMAScript 2015）于2015年6月发布，正好是其前身四年后。它新增了大量API以及许多新的语言特性。这些语言特性是语法糖，ECMAScript
    6可以被转换为之前的版本，在旧浏览器中运行得很好。在撰写本书时，当前所有浏览器版本都没有完全实现ECMAScript 6，但完全没有理由不将其用于生产应用程序。
- en: Syntactic sugar is a design approach where we evolve a programming language
    without breaking backwards compatibility. This allows language designers to come
    up with new syntax, which enriches developer experience but does not break the
    web. Every new feature needs to be translatable to the old syntax. This way, so-called
    transpilers can be used to convert code to older versions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 语法糖是一种设计方法，我们在不破坏向后兼容性的情况下演进编程语言。这允许语言设计者提出新的语法，这丰富了开发者的体验，但不会破坏网络。每个新特性都需要转换成旧语法。这样，所谓的transpilers就可以用来将代码转换成旧版本。
- en: I speak JavaScript, translate, please!
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我说JavaScript，请翻译！
- en: While compilers compile from a higher-level language to a lower-level language,
    a transpiler or transcompiler acts more like a converter. It is a source-to-source
    compiler that translates code to run in a different interpreter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器将高级语言编译成低级语言时，transpiler或transcompiler更像是一个转换器。它是一种源到源的编译器，可以将代码转换成在另一个解释器中运行的代码。
- en: Recently, there's been a real battle among new languages that are transpiled
    to JavaScript and can run in the browser. I used Google Dart for quite some time,
    and I must admit, I really loved the language features. The problem with nonstandardized
    languages is that they depend heavily on community adoption and the hype. Also,
    it's almost certain that they will never run natively within the browser. This
    is also the reason why I prefer standard JavaScript, and the JavaScript of the
    future using transpilers and polyfills.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，在将新语言编译成JavaScript并在浏览器中运行的新语言之间，确实存在一场真正的战斗。我使用Google Dart有一段时间了，我必须承认，我真的很喜欢这个语言特性。非标准化语言的问题在于它们严重依赖于社区采用和炒作。此外，它们几乎肯定永远不会在浏览器中本地运行。这也是我为什么更喜欢标准JavaScript，以及使用transpilers和polyfills的未来的JavaScript的原因。
- en: Some people argue that transpilers introduce code that isn't very performant
    and, therefore, recommend that you do not use ECMAScript 6 and transpilers at
    all. I don't agree with this for many reasons. Usually, this is about performance
    in micro or even nanosecond areas where this often really does not matter for
    most applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为transpilers引入的代码性能不佳，因此建议您根本不要使用ECMAScript 6和transpilers。我不同意这种观点，原因有很多。通常，这关乎微秒甚至纳秒级别的性能，对于大多数应用来说这通常并不重要。
- en: I don't mean that performance doesn't matter, but performance always needs to
    be discussed within a context. If you're trying to optimize a loop within your
    application by reducing processing time from 10 microseconds to five microseconds
    where you'd never iterate over more than 100 items, then you're probably spending
    your time on the wrong things.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说性能不重要，但性能总是需要在特定语境下讨论。如果你试图通过将处理时间从10微秒减少到5微秒来优化应用程序中的循环，而你永远不会迭代超过100个项目，那么你可能正在浪费时间在错误的事情上。
- en: Also, a very important fact is that transpiled code is designed by people who
    understand micro performance optimization much better than I do, and I'm sure
    their code runs faster than mine. On top of this, a transpiler is probably also
    the right place where you'd want to do performance optimization because this code
    is automatically generated and you don't lose maintainability of your code through
    performance quirks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个非常重要的是事实是，transpiled代码是由那些比我更了解微性能优化的人设计的，我确信他们的代码运行速度比我快。在此基础上，transpiler可能也是你想要进行性能优化的正确地方，因为这段代码是自动生成的，你不会因为性能问题而失去代码的可维护性。
- en: I'd like to quote Donald Knuth here and say that premature optimization is the
    root of all evil. I really recommend that you read his paper on this topic (Donald
    Knuth, December 1974, *Structured Programming with go to Statements*). Just because
    the `goto` statements got banished from all modern programming languages, it doesn't
    mean this is less of a good read.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里引用唐纳德·克努特的话，说过早的优化是万恶之源。我强烈建议你阅读他关于这个主题的论文（唐纳德·克努特，1974年12月，*使用goto语句的结构化编程*）。仅仅因为goto语句被从所有现代编程语言中废除，并不意味着这不是一篇好读的文章。
- en: Later on in this chapter, you'll learn about tools that help you use transpilers
    easily within your project, and we'll take a look at the decisions and directions
    Angular went with regarding their source code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将了解一些工具，这些工具可以帮助你轻松地在项目中使用transpilers，我们还将看看Angular在源代码方面做出的决策和方向。
- en: Let's look at a few language features that come with ECMAScript 6 and make our
    life much easier.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ECMAScript 6带来的几个语言特性，这些特性让我们的生活变得更加容易。
- en: Classes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Classes were among one the most requested features in JavaScript, and I was
    one of the people voting for it. Well, coming from an OOP background and being
    used to organizing everything within classes, it was hard for me to let go. Although,
    after working with modern JavaScript for some time, you'll reduce their use to
    the bare minimum and to exactly what they are made for—inheritance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类是 JavaScript 中最受欢迎的功能之一，我也是投票支持它的人之一。嗯，由于我来自面向对象背景，并且习惯于在类中组织一切，所以很难让我放手。尽管如此，在一段时间内使用现代
    JavaScript 之后，你会将它们的使用减少到最低限度，并且只用于它们被制造的目的——继承。
- en: 'Classes in ECMAScript 6 provide you with syntactic sugar to deal with prototypes,
    constructor functions, super calls, and object property definitions in a way that
    you have the illusion that JavaScript could be a class-based OOP language:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6 中的类为你提供了语法糖，以处理原型、构造函数、super 调用和对象属性定义，让你产生一种错觉，认为 JavaScript 可以是一个基于类的面向对象语言：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we learned in the previous topic about transpilers, ECMAScript 6 can be
    de-sugared to ECMAScript 5\. Let''s take a look at what a transpiler will produce
    from this simple example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在关于转译器的上一个主题中学到的，ECMAScript 6 可以被去糖化为 ECMAScript 5。让我们看看转译器从这个简单例子中会产生什么：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This simple example can easily be built using ECMAScript 5\. However, once we
    use the more complex features of class-based object-oriented languages, the de-sugaring
    gets quite complicated.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子可以很容易地使用 ECMAScript 5 构建。然而，一旦我们使用基于类的面向对象语言的更复杂特性，去糖化过程就会变得相当复杂。
- en: ECMAScript 6 classes introduce simplified syntax to write class member functions
    (static functions), the use of the super keyword, and inheritance using the `extends`
    keyword.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6 类引入了简化的语法来编写类成员函数（静态函数），使用 super 关键字，以及使用 extends 关键字进行继承。
- en: If you would like to read more about the features in classes and ECMAScript
    6, I highly recommend that you read the articles of Dr. Axel Rauschmayer ([http://www.2ality.com/](http://www.2ality.com/)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于类和 ECMAScript 6 中功能的信息，我强烈推荐你阅读 Dr. Axel Rauschmayer 的文章（[http://www.2ality.com/](http://www.2ality.com/)）。
- en: Modules
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Modules provide a way to encapsulate your code and create privacy. In object-oriented
    languages, we usually use classes for this. However, I actually believe that this
    is an anti-pattern rather than a good practice. Classes should be used where inheritance
    is desired and not just to structure your code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 模块提供了一种封装你的代码和创建隐私的方法。在面向对象语言中，我们通常使用类来做这件事。然而，我实际上认为这与其说是一种好的实践，不如说是一种反模式。类应该用于需要继承的地方，而不仅仅是用来结构化你的代码。
- en: I'm sure that you've encountered a lot of different module patterns in JavaScript
    already. One of the most popular ones that creates privacy using a function closure
    of an **immediately invoked function expression** (**IIFE**) is probably the revealing
    module pattern. If you'd like to read more about this and maybe other great patterns,
    I recommend the book *Learning JavaScript Design Patterns,* by Addy Osmani.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经遇到了很多不同的 JavaScript 模块模式。其中最受欢迎的一种是使用立即执行函数表达式（**IIFE**）的函数闭包来创建隐私的揭示模块模式。如果你想了解更多关于这个以及其他一些优秀的模式，我推荐阅读
    Addy Osmani 的书籍《Learning JavaScript Design Patterns》。
- en: Within ECMAScript 6, we can now use modules to serve this purpose. We simply
    create one file per module, and then we use the import and export keywords to
    connect our modules together.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 6 中，我们现在可以使用模块来达到这个目的。我们只需为每个模块创建一个文件，然后我们使用导入和导出关键字将我们的模块连接起来。
- en: 'Within the ECMAScript 6 module specification, we can actually export as many
    things as we like from each module. We can then import these named exports from
    any other module. We can have one default export per module, which is especially
    easy to import. Default exports don''t need to be named, and we don''t need to
    know their name when importing them:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 6 模块规范中，我们可以从每个模块中导出我们喜欢的东西。然后我们可以从任何其他模块导入这些命名的导出。每个模块可以有一个默认导出，这特别容易导入。默认导出不需要命名，导入时也不需要知道它们的名称：
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are many combinations on how to use modules. We will discover some of
    these together while working on our task management application during the upcoming
    chapters. If you'd like to see more examples on how to use modules, I can recommend
    the Mozilla Developer Network documentation ([https://developer.mozilla.org](https://developer.mozilla.org))
    on the `import` and `export` keywords.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块的方式有很多种。在接下来的章节中，我们将一起在任务管理应用程序的开发过程中发现其中的一些。如果您想看到更多关于如何使用模块的示例，我可以推荐 Mozilla
    开发者网络文档（[https://developer.mozilla.org](https://developer.mozilla.org)）中关于 `import`
    和 `export` 关键字的说明。
- en: Template strings
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板字符串
- en: 'Template strings are very simple, but they are an extremely useful addition
    to the JavaScript syntax. They serve three main purposes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串非常简单，但它们是 JavaScript 语法中一个极其有用的补充。它们主要有三个用途：
- en: Writing multiline strings
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写多行字符串
- en: String interpolation
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串插值
- en: Tagged template strings
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签模板字符串
- en: 'Before template strings, it was quite verbose to write multiline strings. You
    needed to concatenate pieces of strings and append a new-line character yourself
    to the line endings:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板字符串出现之前，编写多行字符串相当繁琐。您需要手动拼接字符串片段，并在行尾添加换行符：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using template strings, we can simplify this example a lot. We can write multiline
    strings, and we can also use the string interpolation functionality for our title
    variable that we used to concatenate earlier:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板字符串，我们可以大大简化这个例子。我们可以编写多行字符串，还可以使用之前用于连接的字符串插值功能：
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the back ticks instead of the previous single quotes. Template strings
    are always written between back ticks, and the parser will interpret all characters
    in-between them as part of the resulting string. This way, the new-line characters
    present in our source file will also be part of the string automatically.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了反引号而不是之前的单引号。模板字符串始终用反引号书写，解析器将解释它们之间的所有字符作为结果字符串的一部分。这样，源文件中存在的换行符也会自动成为字符串的一部分。
- en: You can also see that we have used the dollar sign, followed by curly brackets
    to interpolate our strings. This allows us to write arbitrary JavaScript within
    strings and helps a lot while constructing HTML template strings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到，我们使用了美元符号后跟花括号来插值我们的字符串。这允许我们在字符串中写入任意 JavaScript 代码，并在构建 HTML 模板字符串时非常有帮助。
- en: You can read more about template strings on the Mozilla Developer Network.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Mozilla 开发者网络上了解更多关于模板字符串的信息。
- en: TypeScript
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript
- en: TypeScript was created in 2012 by Anders Hejlsberg with the intention to implement
    the future standard of ECMAScript 6 but also to provide a superset of syntax and
    features that were not part of the specification.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是由 Anders Hejlsberg 在 2012 年创建的，旨在实现 ECMAScript 6 的未来标准，同时也提供了一组超集的语法和特性，这些特性原本并不包含在规范中。
- en: 'There are many features in TypeScript that are a superset to the ECMAScript
    6 standard, including, but not limited to the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中有许多特性是 ECMAScript 6 标准的超集，包括但不限于以下内容：
- en: Optional static typing with type annotations
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有类型注解的可选静态类型
- en: Interfaces
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Enum types
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类型
- en: Generics
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: It's important to understand that all of the features that TypeScript provides
    as a superset are optional. You can write pure ECMAScript 6 and not take advantage
    of the additional features that TypeScript provides. The TypeScript compiler will
    still transcompile pure ECMAScript 6 code to ECMAScript 5 without any errors.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 TypeScript 提供的所有作为超集的特性都是可选的。您可以编写纯 ECMAScript 6 代码，而不必利用 TypeScript
    提供的附加特性。TypeScript 编译器仍然会将纯 ECMAScript 6 代码无错误地转换为 ECMAScript 5。
- en: Most of the features that are seen in TypeScript are actually already present
    in other languages, such as Java and C#. One goal of TypeScript was to provide
    language features that support workflows and better maintainability for large-scale
    applications.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中看到的大多数特性实际上在其他语言中已经存在，例如 Java 和 C#。TypeScript 的一个目标是为大型应用程序提供支持工作流程和更好的可维护性的语言特性。
- en: The problem with any nonstandard language is that nobody can tell how long the
    language will be maintained and how fast the momentum of the language will be
    in the future. In terms of support, the chances are high that TypeScript, with
    its sponsor, Microsoft, will actually have a long life. However, there's still
    no guarantee that the momentum and trend of the language will keep moving at a
    reasonable pace. This problem does obviously not exist for standard ECMAScript
    6 because it's what the web of the future is made of and what browsers will speak
    natively.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非标准语言的缺点在于，没有人能确定这种语言将维持多久，以及它在未来的势头将有多快。就支持而言，TypeScript，凭借其赞助商微软，实际上可能会拥有很长的一生。然而，仍然没有保证语言的势头和趋势会以合理的速度持续发展。显然，对于标准的ECMAScript
    6来说，这个问题并不存在，因为它是未来网络的构成部分，以及浏览器将原生支持的语言。
- en: 'Still, there are valid reasons to use the extended features of TypeScript if
    you''d want to address the following concerns that clearly outweigh the negative
    implications of an uncertain future in your project:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你想要解决以下明显超过项目未来不确定性的负面影响的问题，使用TypeScript的扩展功能是有充分理由的：
- en: Large applications that undergo a huge amount of changes and refactoring
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经历大量更改和重构的大型应用程序
- en: Large teams that require a strict governance while working on code
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编码时需要严格治理的大型团队
- en: Creation of type-based documentation which would otherwise be difficult to maintain
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于类型的文档，否则将难以维护
- en: Today's version of Angular is purely based on TypeScript and therefore it's
    your best option if you're starting to use Angular as your framework. There are
    also ways to use Angular with pure ECMAScript even without using a transpiler,
    however, you'll be missing some great language features and support.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的Angular版本完全是基于TypeScript的，因此如果你开始使用Angular作为你的框架，这是你的最佳选择。即使不使用编译器，也有方法使用Angular与纯ECMAScript，但你将错过一些出色的语言特性和支持。
- en: 'Within this book, we''re using TypeScript for all examples as well as to create
    our task management system. Most of the features we''re going to be using have
    already been or will be explained to you within this chapter. The typing system
    of TypeScript is pretty self-explanatory, however, if you''d like to know more
    about TypeScript and its features, I highly recommend that you visit the TypeScript
    documentation on their official website: [https://www.typescriptlang.org](https://www.typescriptlang.org).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用TypeScript来展示所有示例，以及创建我们的任务管理系统。我们将要使用的大多数功能已经在本章中或将要向你解释。TypeScript的类型系统相当直观，然而，如果你想了解更多关于TypeScript及其功能的信息，我强烈建议你访问他们官方网站上的TypeScript文档：[https://www.typescriptlang.org](https://www.typescriptlang.org)。
- en: History with TypeScript in Angular
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的TypeScript历史
- en: 'When the Angular project was developed, it was important for the core team
    to include the best language support they could get. While evaluating different
    languages, they have actually considered Google Dart and TypeScript as potential
    candidates to implement the framework. However, there was one major feature missing
    in the superset which TypeScript provided. Let''s look again at our first Angular
    component, which we wrote in a previous section:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular项目开发时，核心团队包括他们能得到的最佳语言支持是很重要的。在评估不同的语言时，他们实际上已经考虑了Google Dart和TypeScript作为实现框架的潜在候选人。然而，在TypeScript提供的超集中缺少了一个主要功能。让我们再次看看我们在上一节中编写的第一个Angular组件：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An Angular component always consists of an EMCAScript 6 class as well as the
    `@Component` decorator which is used to configure our component. At the time when
    Google started developing the Angular project, there was no such thing as the
    ECMAScript 7 decorator proposal and TypeScript did not support something similar.
    Still, the Angular team didn't want to miss out on such a great language feature
    which can simplify and ease the use of their framework API. This marked the birth
    of AtScript. AtScript was created by the Angular core team as a fork of TypeScript
    which added the possibility to write meta annotations using an at symbol. At the
    same time, the ECMAScript 7 decorator proposal was created to propose a similar
    feature to the JavaScript standard. It was only a few months later with TypeScript's
    Version 1.5 that Microsoft announced that they would include experimental support
    for decorators in the TypeScript transpiler.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular组件始终由一个ECMAScript 6类以及用于配置我们的组件的`@Component`装饰器组成。当Google开始开发Angular项目时，还没有ECMAScript
    7装饰器提案，TypeScript也不支持类似的功能。尽管如此，Angular团队不想错过这样一个可以简化并简化他们框架API使用的语言特性。这标志着AtScript的诞生。AtScript是由Angular核心团队创建的，它是TypeScript的一个分支，增加了使用at符号编写元注释的可能性。同时，ECMAScript
    7装饰器提案被创建，以向JavaScript标准提出类似的功能。仅在几个月后，随着TypeScript 1.5版本的发布，微软宣布他们将在TypeScript转换器中包含对装饰器的实验性支持。
- en: Today, Angular has switched completely to TypeScript and AtScript as well as
    Dart, which is no longer supported in the core project. They have changed their
    code to run with the experimental decorator support of TypeScript and no longer
    rely on a custom solution.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Angular已经完全切换到TypeScript、AtScript以及Dart，后者在核心项目中不再受支持。他们已经更改了代码，以便在TypeScript的实验性装饰器支持下运行，不再依赖于自定义解决方案。
- en: From this rather long-winded history, you can get that the Angular core team
    has fought hard to be able to use a decorator language feature. And they have
    succeeded. Given the importance of this feature, we'll talk a bit about the possibilities
    we have with ECMAScript 7 decorators within the next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段相当冗长的历史中，你可以了解到Angular核心团队为了能够使用装饰器语言特性而进行了艰苦的斗争。他们成功了。鉴于这个特性的重要性，我们将在下一节中简要讨论我们在ECMAScript
    7装饰器中拥有的可能性。
- en: Decorators
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators are not part of the ECMAScript 6 specification, but they were proposed
    to the ECMAScript 7 standard for 2016\. They provide us with a way to decorate
    classes and properties during design time. This allows a developer to use meta-annotations
    while writing classes, and declaratively attach functionality to the class and
    its properties.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器不是ECMAScript 6规范的一部分，但它们被提议在2016年的ECMAScript 7标准中。它们为我们提供了一种在设计时装饰类和属性的方法。这允许开发者在编写类时使用元注释，并声明性地将功能附加到类及其属性上。
- en: 'Decorators are named after the decorator pattern that was initially described
    in the book *Design Patterns: Elements of Reusable Object-Oriented Software*,
    by Erich Gamma and his colleagues, also known as the **Gang of Four** (**GoF**).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '装饰器是以最初在Erich Gamma及其同事所著的《设计模式：可复用面向对象软件元素》（Design Patterns: Elements of Reusable
    Object-Oriented Software）一书中描述的装饰器模式命名的，这本书也被称为**四人帮**（**GoF**）。'
- en: 'The principle of decoration is that an existing procedure is intercepted and
    the decorator has the chance to either delegate, provide an alternative procedure,
    or do a mix of both:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰的原则是拦截现有的过程，装饰器有机会委托、提供替代过程，或者两者兼而有之：
- en: '![](img/04b4e452-58be-4815-aea1-d30b53156d94.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04b4e452-58be-4815-aea1-d30b53156d94.png)'
- en: Visualization of decoration in a dynamic environment with the example of a simple
    access procedure
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以简单的访问过程为例，在动态环境中可视化装饰
- en: Decorators in ECMAScript 7 can be used to annotate classes and class properties.
    Note that this also includes class methods, as class methods are also properties
    of the class prototype object. Decorators get defined as regular functions, and
    they can be attached to classes or class properties with the *at* symbol. Our
    decorator function will then be called with contextual information about the location
    of inclusion every time that the decorator is placed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 7中的装饰器可以用来注释类和类属性。请注意，这还包括类方法，因为类方法也是类原型对象属性的一部分。装饰器被定义为常规函数，并且可以使用*at*符号附加到类或类属性上。每次装饰器被放置时，我们的装饰器函数都会使用关于包含位置的上下文信息被调用。
- en: 'Let''s take a look at a simple example that illustrates the use of a decorator:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，它说明了装饰器的使用：
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have created a `logAccess` decorator that will log all function calls that
    are tagged with the decorator. If we look at the `MoneySafe` class, you can see
    that we have decorated the `openSafe` method with our `logAccess` decorator.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `logAccess` 装饰器，它将记录所有带有装饰器的函数调用。如果我们查看 `MoneySafe` 类，我们可以看到我们已经用我们的
    `logAccess` 装饰器装饰了 `openSafe` 方法。
- en: The `logAccess` decorator function will be executed for each annotated property
    within our code. This enables us to intercept the property definition of the given
    property. Let's take a look at the signature of our decorator function. Decorator
    functions that are placed on class properties will be called with the target object
    of the property definition as a first parameter. The second parameter is the actual
    property name that is defined, followed by the last parameter, which is the descriptor
    object that is supposed to be applied to the object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`logAccess` 装饰器函数将在我们代码中的每个注解属性上执行。这使我们能够拦截给定属性的属性定义。让我们看看我们的装饰器函数的签名。放置在类属性上的装饰器函数将以属性定义的目标对象作为第一个参数被调用。第二个参数是实际定义的属性名，后面是最后一个参数，即应该应用于对象的描述符对象。'
- en: The decorator gives us the opportunity to intercept the property definition.
    In our case, we use this ability to exchange the descriptor value (which is the
    annotated function) with a proxy function that will log the function call before
    calling the origin function (delegation). For simplification purposes, we've implemented
    a very simple yet incomplete function proxy. For real-world scenarios, it would
    be advisable to use a better proxy implementation, such as the ECMAScript 6 proxy
    object.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器给了我们拦截属性定义的机会。在我们的情况下，我们使用这种能力来交换描述符值（即注解函数）与一个在调用原始函数之前记录函数调用的代理函数。为了简化起见，我们实现了一个非常简单但又不完整的函数代理。对于现实世界的场景，建议使用更好的代理实现，例如
    ECMAScript 6 代理对象。
- en: Decorators are a great feature to leverage aspect-oriented concepts and declaratively
    add behavior to our code at design time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是利用面向方面概念并声明式地在设计时向我们的代码添加行为的一个很好的特性。
- en: 'Let''s look at a second example where we use an alternative way to declare
    and use decorators. We can treat decorators like function expressions where our
    decorator function is rewritten as a factory function. This form of usage is especially
    useful when you need to pass along configuration to the decorator, which is made
    available in the decorator factory function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二个例子，其中我们使用了一种不同的方式来声明和使用装饰器。我们可以将装饰器视为函数表达式，其中我们的装饰器函数被重写为一个工厂函数。这种使用形式在需要将配置传递给装饰器时特别有用，该配置在装饰器工厂函数中可用：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have now learned how ECMAScript 7 decorators can help you write declarative
    code that has an aspect-oriented twist to it. This simplifies development a lot
    because we can now think of behavior that we add to our classes during design
    time when we actually think about the class as a whole and write the initial stub
    of the class.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用 ECMAScript 7 装饰器帮助你编写具有面向方面特性的声明式代码。这大大简化了开发过程，因为我们现在可以在设计时考虑添加到我们类中的行为，当我们实际上将类作为一个整体来思考并编写类的初始存根时。
- en: 'Decorators in TypeScript are slightly different than the decorators from ECMAScript
    7\. They are not limited to classes and class properties, but they can be placed
    on parameters within the class methods. This allows you to annotate function parameters,
    which can be useful in some cases:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的装饰器与 ECMAScript 7 中的装饰器略有不同。它们不仅限于类和类属性，还可以放置在类方法内的参数上。这允许你注解函数参数，这在某些情况下可能很有用：
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Angular uses this feature to simplify dependency injection on class constructors.
    As all directive, component, and service classes get instantiated from Angular
    dependency injection and not by us directly, these annotations help Angular find
    the correct dependencies. For this use case, function parameter decorators actually
    make a lot of sense.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用这个特性来简化类构造函数上的依赖注入。由于所有指令、组件和服务类都是由 Angular 依赖注入实例化，而不是直接由我们实例化，这些注解帮助
    Angular 找到正确的依赖。对于这个用例，函数参数装饰器实际上非常有意义。
- en: Currently, there are still issues with the implementation of decorators on class
    method parameters, which is also why ECMAScript 7 does not support it. The TypeScript
    compiler has worked around this issue but is currently not compliant to the ECMAScript
    7 proposal.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，类方法参数上装饰器的实现仍然存在问题，这也是为什么 ECMAScript 7 不支持它的原因。TypeScript 编译器已经解决了这个问题，但目前并不符合
    ECMAScript 7 的提案。
- en: Tools
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: In order to make use of all these future technologies, we need some tools to
    support us. We were already talking about ECMAScript 6 and decorators, where we
    actually prefer TypeScript decorators, as they support the constructor parameter
    decorators that are used by Angular. Although the ECMAScript 6 syntax supports
    modules, we still need some sort of module loader that will actually load the
    required modules in the browser or help us generate an executable bundle.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用所有这些未来的技术，我们需要一些工具来支持我们。我们之前已经讨论了 ECMAScript 6 和装饰器，我们实际上更喜欢 TypeScript
    装饰器，因为它们支持 Angular 使用的构造函数参数装饰器。尽管 ECMAScript 6 语法支持模块，我们仍然需要某种模块加载器，它实际上会在浏览器中加载所需的模块或帮助我们生成可执行的包。
- en: Node.js and npm
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 和 npm
- en: Node.js is JavaScript on steroids. Initially, a fork of the V8 JavaScript engine
    from the Google Chrome browser, Node.js was extended with more functionality,
    specifically to make JavaScript useful on the server-side. File handling, streams,
    system APIs, and a huge ecosystem of user-generated packages are just some of
    the facts that make this technology an outstanding partner for your web development.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是增强版的 JavaScript。最初，Node.js 是 Google Chrome 浏览器中的 V8 JavaScript 引擎的一个分支，后来扩展了更多功能，特别是为了使
    JavaScript 在服务器端变得有用。文件处理、流、系统 API 和庞大的用户生成包生态系统只是使这项技术成为你网络开发杰出伙伴的一些事实。
- en: The node package manager, NPM, is a door to over 200,000 packages and libraries
    that can help you build your own application or library. The Node.js philosophy
    is very similar to the UNIX philosophy, where packages should stay small and sharp,
    but they should use composition to achieve greater goals.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 节点包管理器，NPM，是通往超过20万个包和库的大门，这些包和库可以帮助你构建自己的应用程序或库。Node.js 的哲学与 UNIX 哲学非常相似，即包应该保持小巧而锋利，但它们应该通过组合来实现更大的目标。
- en: To build our application, we will rely on Node.js as the host for the tools
    that we're going to use. We should, therefore, make sure that we install Node.js
    on our machine so that we are prepared for the next chapter, where we will start
    to craft our task management application.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的应用程序，我们将依赖 Node.js 作为我们将要使用的工具的主机。因此，我们应该确保在我们的机器上安装 Node.js，以便为下一章做好准备，我们将开始构建我们的任务管理应用程序。
- en: The code within this book was written using Node.js 8.9.0\. Please make sure
    you're installing an equivalent Node.js version on your system. You can get Node.js
    from their website at [https://nodejs.org](https://nodejs.org), and it should
    be a breeze to install this on any kind of operating system by following the instructions
    on their website.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码使用 Node.js 8.9.0 编写。请确保你在系统上安装了一个等效的 Node.js 版本。你可以从他们的网站 [https://nodejs.org](https://nodejs.org)
    获取 Node.js，按照网站上的说明安装应该非常简单。
- en: 'Once you''ve installed Node.js, we can perform a simple test to check whether
    everything is up and running. Open a Terminal console and execute the following
    command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 Node.js，我们可以执行一个简单的测试来检查一切是否正常运行。打开终端控制台并执行以下命令：
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Angular CLI
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CLI
- en: There are many ways to start out with a new Angular project. The most convenient
    one is probably to use the Angular CLI. The CLI, as the name already suggests,
    is a command-line interface to create new projects as well as new artefacts within
    an existing project.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以开始一个新的 Angular 项目。最方便的方法可能是使用 Angular CLI。正如名称所暗示的，CLI 是一个命令行界面，用于创建新项目以及现有项目中的新工件。
- en: The following instructions are guiding you through the creation of your first
    Angular project using the Angular CLI tool.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明将指导你使用 Angular CLI 工具创建你的第一个 Angular 项目。
- en: 'Let''s start by installing the Angular CLI on your system. Execute the following
    command on your command line:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在你的系统上安装 Angular CLI 开始。在你的命令行中执行以下命令：
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After you''ve installed the Angular CLI tool, you can now use it to scaffold
    a new Angular project. You can access the tool executable by typing `ng` in your
    terminal. Let''s open another Terminal window and create a new Angular project
    using the Angular CLI tool:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装了Angular CLI工具之后，你现在可以使用它来搭建一个新的Angular项目。你可以在终端中输入 `ng` 来访问工具的可执行文件。让我们打开另一个终端窗口，使用Angular
    CLI工具创建一个新的Angular项目：
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The previous step will take a while since all dependencies of your project
    need to be installed first. After completion, we can now use the CLI tool to start
    a local development server:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一步需要一些时间，因为你的项目所有依赖项都需要先安装。完成后，我们现在可以使用CLI工具来启动本地开发服务器：
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can now launch your favourite browser and open up the address `http://localhost:4200`,
    where you should see the message welcome to mac.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以启动你喜欢的浏览器，并打开地址 `http://localhost:4200`，你应该会看到欢迎来到mac的消息。
- en: Congratulations! You've just created your first Angular application using the
    Angular CLI tool! As I already told you, the convenience level of starting an
    Angular project like this is really great.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚使用Angular CLI工具创建了你第一个Angular应用程序！正如我之前告诉你的，以这种方式启动Angular项目的便利性真的很棒。
- en: 'The CLI tool can be viewed as a scaffolding tool which helps you set up the
    necessary tooling as well as the structure of your project. Let''s take a look
    at the most important features you''ll get for free when you''re using the CLI
    to give birth to your project:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: CLI工具可以被视为一个脚手架工具，它帮助你设置必要的工具以及项目的结构。让我们看看当你使用CLI创建项目时，你会免费获得的最重要功能：
- en: '**TypeScript**: Maybe obvious, but in order to use a transpiler, there will
    be many manual steps involved for you to set up the necessary tooling.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**: 可能很明显，但为了使用转换器，你需要进行许多手动步骤来设置必要的工具。'
- en: '**Webpack**: This massive power tool is solving a lot of problems you probably
    haven''t even though about yet. Along with TypeScript transpilation, its main
    concern is to load ECMAScript modules and provides you with a development server
    to preview and work on your project. Finally, it''s also the tool which helps
    you to create an optimized bundled version of your project for production use.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Webpack**: 这款强大的工具正在解决你可能还没有考虑到的许多问题。除了TypeScript转换，它主要关注的是加载ECMAScript模块，并提供一个开发服务器来预览和编辑你的项目。最后，它也是帮助你为生产使用创建项目优化打包版本的工具。'
- en: '**Karma, Jasmine, and Protractor**: This trio is unbeatable when it comes to
    testing! While Karma runs your executable specifications, Jasmin helps you write
    your tests. Protractor, on the other hand, can be used to create full end-to-end,
    integrational tests.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Karma, Jasmine, and Protractor**: 这三个组合在测试方面是无敌的！当Karma运行你的可执行规范时，Jasmine帮助你编写测试。另一方面，Protractor可以用来创建完整的端到端、集成测试。'
- en: You could also use the ECMAScript 5 style of writing Angular applications, which
    would allow you to develop your application right away without additional tooling.
    However, if you want to leverage the full potential of Angular, you should write
    your application in TypeScript rather than JavaScript. The Angular API is optimized
    to use features from future JavaScript versions and TypeScript, in order to provide
    the best ease of development.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用ECMAScript 5风格编写Angular应用程序，这将允许你立即开发应用程序而无需额外的工具。然而，如果你想充分利用Angular的潜力，你应该用TypeScript而不是JavaScript来编写应用程序。Angular
    API针对使用未来JavaScript版本和TypeScript的功能进行了优化，以提供最佳的开发便利性。
- en: Please go ahead and explore the source code that has been generated using the
    Angular CLI. Over the course of the chapters in this book, we will gain more in-depth
    knowledge, which will help you understand and put all of those pieces together.
    For the moment, we were just concerned about the installation of the Angular CLI
    and gave it a quick dry run.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续探索使用Angular CLI生成的源代码。在本书的章节中，我们将获得更深入的知识，这将帮助你理解和将这些组件组合在一起。目前，我们只关注Angular
    CLI的安装，并进行了快速测试运行。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at a component-based approach to structure user interfaces.
    We talked about the necessary background to understand why we are moving in this
    direction with the web standard and frameworks, such as Angular. We also ensured
    that we are prepared with all the technology that we will use in the upcoming
    chapters in this book. You created your first simple Angular application using
    the Angular CLI tool. Now, we are ready to start building our task-management
    system using a component-based architecture to its full potential.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了基于组件的方法来构建用户界面。我们讨论了理解为什么我们要随着网络标准和框架，如 Angular，走向这个方向所必需的背景知识。我们还确保我们为本书后续章节中将要使用的所有技术做好了准备。您已使用
    Angular CLI 工具创建了您的第一个简单的 Angular 应用程序。现在，我们准备开始利用组件化架构的潜力来构建我们的任务管理系统。
- en: In the next chapter, we're going to start building our task management application
    using Angular components. We'll look at the initial steps that are required to
    create an Angular application from scratch and flesh out the first few components
    in order to build a task list.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始使用 Angular 组件构建我们的任务管理应用程序。我们将查看创建 Angular 应用程序所需的初始步骤，并完善前几个组件，以便构建任务列表。
