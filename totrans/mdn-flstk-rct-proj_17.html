<html><head></head><body>
<div id="_idContainer123" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-242"><a id="_idTextAnchor245" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-243" class="calibre5"><a id="_idTextAnchor246" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Building an Event-Based Backend Using Express and Socket.IO</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In this chapter, we will learn about event-based applications and the tradeoffs of using such an architecture versus a more traditional one. </span><span class="kobospan" id="kobo.3.2">Then, we are going to learn about WebSockets and how they work. </span><span class="kobospan" id="kobo.3.3">Afterward, we are going to implement a backend using Socket.IO and Express. </span><span class="kobospan" id="kobo.3.4">Finally, we are going to learn how to integrate authentication by using JWT </span><span><span class="kobospan" id="kobo.4.1">with Socket.IO.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.6.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">What are </span><span><span class="kobospan" id="kobo.8.1">event-based applications?</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Setting </span><span><span class="kobospan" id="kobo.10.1">up Socket.IO</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Creating a backend for a chat app </span><span><span class="kobospan" id="kobo.12.1">using Socket.IO</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Adding authentication by integrating JWT </span><span><span class="kobospan" id="kobo.14.1">with Socket.IO</span></span></li>
</ul>
<h1 id="_idParaDest-244" class="calibre5"><a id="_idTextAnchor247" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">Before we start, please install all the requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.17.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.18.1">, </span><em class="italic"><span class="kobospan" id="kobo.19.1">Preparing For Full-Stack Development</span></em><span class="kobospan" id="kobo.20.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.21.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.22.1">, </span><em class="italic"><span class="kobospan" id="kobo.23.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.24.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.25.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">The versions listed in those chapters are the ones used in this book. </span><span class="kobospan" id="kobo.26.2">While installing a newer version should not be an issue, please note that certain steps might work differently. </span><span class="kobospan" id="kobo.26.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.27.1">Chapters 1 </span></em><span><span class="kobospan" id="kobo.28.1">and</span></span><span><em class="italic"><span class="kobospan" id="kobo.29.1"> 2.</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.31.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch13" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.32.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch13</span></span></a><span><span class="kobospan" id="kobo.33.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">If you cloned the full repository for this book, Husky may not find the </span><strong class="source-inline"><span class="kobospan" id="kobo.35.1">.git</span></strong><span class="kobospan" id="kobo.36.1"> directory when running </span><strong class="source-inline"><span class="kobospan" id="kobo.37.1">npm install</span></strong><span class="kobospan" id="kobo.38.1">. </span><span class="kobospan" id="kobo.38.2">In that case, just run </span><strong class="source-inline"><span class="kobospan" id="kobo.39.1">git init</span></strong><span class="kobospan" id="kobo.40.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.41.1">chapter folder.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.43.1">at: </span></span><a href="https://youtu.be/kHGvkopIHf4" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.44.1">https://youtu.be/kHGvkopIHf4</span></span></a><span><span class="kobospan" id="kobo.45.1">.</span></span></p>
<h1 id="_idParaDest-245" class="calibre5"><a id="_idTextAnchor248" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.46.1">What are event-based applications?</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.47.1">In</span><a id="_idIndexMarker754" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.48.1"> contrast to traditional web applications, where we have a request-response pattern, in event-based applications, we are dealing with events. </span><span class="kobospan" id="kobo.48.2">The server and client stay connected and each side can send events, which the other side listens to and </span><span><span class="kobospan" id="kobo.49.1">reacts to.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.50.1">The following diagram shows the difference between implementing a chat app in a request-response pattern versus an </span><span><span class="kobospan" id="kobo.51.1">event-based pattern:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer114">
<span class="kobospan" id="kobo.52.1"><img alt="Figure 13.1 – A chat app implementation with request-response and event-based patterns" src="image/B19385_13_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.53.1">Figure 13.1 – A chat app implementation with request-response and event-based patterns</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">For </span><a id="_idIndexMarker755" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.55.1">example, to implement a chat application in a request-response pattern, we would need to regularly send a request to a </span><strong class="source-inline"><span class="kobospan" id="kobo.56.1">GET /chat/messages</span></strong><span class="kobospan" id="kobo.57.1"> endpoint to refresh the list of messages sent in a chat room. </span><span class="kobospan" id="kobo.57.2">This process of periodically sending requests is called short polling. </span><span class="kobospan" id="kobo.57.3">To send a chat message, we would make a request to </span><strong class="source-inline"><span class="kobospan" id="kobo.58.1">POST /chat/messages</span></strong><span class="kobospan" id="kobo.59.1">. </span><span class="kobospan" id="kobo.59.2">In an event-based pattern, we could instead send a </span><strong class="source-inline"><span class="kobospan" id="kobo.60.1">chat.message</span></strong><span class="kobospan" id="kobo.61.1"> event from the client to the server, which then sends a </span><strong class="source-inline"><span class="kobospan" id="kobo.62.1">chat.message</span></strong><span class="kobospan" id="kobo.63.1"> event to all connected users. </span><span class="kobospan" id="kobo.63.2">The clients then listen to </span><strong class="source-inline"><span class="kobospan" id="kobo.64.1">chat.message</span></strong><span class="kobospan" id="kobo.65.1"> events and display the messages as they come in; no periodic requests </span><span><span class="kobospan" id="kobo.66.1">are required!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.67.1">Of course, each pattern comes with its advantages </span><span><span class="kobospan" id="kobo.68.1">and disadvantages:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><span class="kobospan" id="kobo.69.1">REST/request-response:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.70.1">Good </span><a id="_idIndexMarker756" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.71.1">for when data does not </span><span><span class="kobospan" id="kobo.72.1">change frequently</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.73.1">Responses can be </span><span><span class="kobospan" id="kobo.74.1">cached easily</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.75.1">Requests are stateless, making it easy to </span><span><span class="kobospan" id="kobo.76.1">scale backends</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.77.1">Bad </span><a id="_idIndexMarker757" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.78.1">at real-time updates (requires </span><span><span class="kobospan" id="kobo.79.1">periodic polling)</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.80.1">More overhead per request (bad when sending many </span><span><span class="kobospan" id="kobo.81.1">short responses)</span></span></li></ul></li>
<li class="calibre11"><span><span class="kobospan" id="kobo.82.1">WebSockets/event-based:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.83.1">Good</span><a id="_idIndexMarker758" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.84.1"> for applications that require </span><span><span class="kobospan" id="kobo.85.1">frequent updates</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.86.1">More efficient because a persistent connection between the client and server is re-used for </span><span><span class="kobospan" id="kobo.87.1">multiple requests</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.88.1">Less overhead </span><span><span class="kobospan" id="kobo.89.1">per request</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.90.1">There </span><a id="_idIndexMarker759" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.91.1">might be connection issues with (</span><span><span class="kobospan" id="kobo.92.1">corporate) proxies</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.93.1">They are stateful, which can make it harder to scale </span><span><span class="kobospan" id="kobo.94.1">an app</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">As we can see, for fetching data that does not change so frequently (and can be cached), such as blog posts, a request-response pattern fits better. </span><span class="kobospan" id="kobo.95.2">For applications where data is frequently changing, such as a chat room, an event-based pattern </span><span><span class="kobospan" id="kobo.96.1">fits better.</span></span></p>
<h2 id="_idParaDest-246" class="calibre7"><a id="_idTextAnchor249" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.97.1">What are WebSockets?</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.98.1">The WebSocket API is a browser feature that allows web applications to create an open connection between the client and the server, similar to Unix-style sockets. </span><span class="kobospan" id="kobo.98.2">With WebSockets, communication</span><a id="_idIndexMarker760" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.99.1"> can happen in both directions at the same time. </span><span class="kobospan" id="kobo.99.2">This is in contrast to HTTP requests, where both parties can communicate, but </span><span><span class="kobospan" id="kobo.100.1">not simultaneously.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.101.1">WebSockets </span><a id="_idIndexMarker761" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.102.1">use HTTP to establish a connection between the client and the server, and then upgrade the protocol from HTTP to the WebSocket protocol. </span><span class="kobospan" id="kobo.102.2">While both HTTP and WebSockets </span><a id="_idIndexMarker762" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.103.1">depend on the </span><strong class="bold"><span class="kobospan" id="kobo.104.1">Transmission Control Protocol</span></strong><span class="kobospan" id="kobo.105.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.106.1">TCP</span></strong><span class="kobospan" id="kobo.107.1">), they are distinct protocols on the application layer (Layer 7) of </span><a id="_idIndexMarker763" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.108.1">the </span><strong class="bold"><span class="kobospan" id="kobo.109.1">Open Systems Interconnection</span></strong><span class="kobospan" id="kobo.110.1"> (</span><span><strong class="bold"><span class="kobospan" id="kobo.111.1">OSI</span></strong></span><span><span class="kobospan" id="kobo.112.1">) model.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.113.1">A connection to a WebSocket is established by sending an HTTP request with the </span><strong class="source-inline"><span class="kobospan" id="kobo.114.1">Upgrade: websocket</span></strong><span class="kobospan" id="kobo.115.1"> header and other parameters to establish a secure WebSocket connection. </span><span class="kobospan" id="kobo.115.2">The server then responds with an </span><strong class="source-inline"><span class="kobospan" id="kobo.116.1">HTTP 101 Switching Protocols</span></strong><span class="kobospan" id="kobo.117.1"> response code and information to establish the connection. </span><span class="kobospan" id="kobo.117.2">Then, the client and server continue talking on the </span><span><span class="kobospan" id="kobo.118.1">WebSocket protocol.</span></span></p>
<h2 id="_idParaDest-247" class="calibre7"><a id="_idTextAnchor250" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.119.1">What is Socket.IO?</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.120.1">Socket.IO is an </span><a id="_idIndexMarker764" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.121.1">implementation of an event-based server and client library. </span><span class="kobospan" id="kobo.121.2">In most cases, it establishes a connection to the server using a WebSocket. </span><span class="kobospan" id="kobo.121.3">If a WebSocket connection is not possible (due to lacking browser support or firewall settings), Socket.IO can also fall back to HTTP long-polling. </span><span class="kobospan" id="kobo.121.4">However, Socket.IO isn’t a pure WebSocket implementation as it adds additional metadata to each packet. </span><span class="kobospan" id="kobo.121.5">It only uses WebSockets internally to </span><span><span class="kobospan" id="kobo.122.1">transmit data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.123.1">In addition to providing a way to send events between the client and server, Socket.IO offers the following features</span><a id="_idIndexMarker765" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.124.1"> over </span><span><span class="kobospan" id="kobo.125.1">plain WebSockets:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.126.1">Fallback to HTTP long-polling</span></strong><span class="kobospan" id="kobo.127.1">: This occurs if the WebSocket connection cannot be established. </span><span class="kobospan" id="kobo.127.2">This can be especially useful for companies using proxies or firewalls that block </span><span><span class="kobospan" id="kobo.128.1">WebSocket connections.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.129.1">Automatic reconnection</span></strong><span class="kobospan" id="kobo.130.1">: If the WebSocket connection </span><span><span class="kobospan" id="kobo.131.1">is interrupted.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.132.1">Buffering packets</span></strong><span class="kobospan" id="kobo.133.1">: When the client gets disconnected, packets can be re-sent again automatically </span><span><span class="kobospan" id="kobo.134.1">upon reconnection.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.135.1">Acknowledgments</span></strong><span class="kobospan" id="kobo.136.1">: A convenient way to send events in a request-response pattern, which can sometimes be useful even in </span><span><span class="kobospan" id="kobo.137.1">event-based applications.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.138.1">Broadcasting</span></strong><span class="kobospan" id="kobo.139.1">: Sending an event to all (or a subset of all) </span><span><span class="kobospan" id="kobo.140.1">connected clients.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.141.1">Multiplexing</span></strong><span class="kobospan" id="kobo.142.1">: Socket.IO </span><a id="_idIndexMarker766" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.143.1">implements namespaces, which can be used to create “channels” that only certain users can send events to and receive events from, such as an “</span><span><span class="kobospan" id="kobo.144.1">admin-only channel.”</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.145.1">Now that we have learned the essentials of what Socket.IO is, let’s dive deeper into how the connection and emitting/receiving </span><span><span class="kobospan" id="kobo.146.1">events work.</span></span></p>
<h2 id="_idParaDest-248" class="calibre7"><a id="_idTextAnchor251" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.147.1">Connecting to Socket.IO</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.148.1">The following diagram shows how</span><a id="_idIndexMarker767" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.149.1"> a connection is established </span><span><span class="kobospan" id="kobo.150.1">with Socket.IO:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer115">
<span class="kobospan" id="kobo.151.1"><img alt="Figure 13.2 – Establishing a connection with Socket.IO" src="image/B19385_13_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.152.1">Figure 13.2 – Establishing a connection with Socket.IO</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.153.1">First, Socket.IO sends a handshake from the client (on the frontend) to the server (on the backend), which can contain information to authenticate with the server, or query parameters to provide additional information when establishing </span><span><span class="kobospan" id="kobo.154.1">the connection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.155.1">If a connection via WebSockets cannot be established, Socket.IO connects to the server via HTTP long polling, which means making a request to the server that is kept active until an event occurs, at which point the server sends a response to the request. </span><span class="kobospan" id="kobo.155.2">This allows waiting for events without having to periodically make a request to see if there are any new events. </span><span class="kobospan" id="kobo.155.3">Of course, this is not as performant as WebSockets, but it is a good fallback for when WebSockets </span><span><span class="kobospan" id="kobo.156.1">aren’t available.</span></span></p>
<h2 id="_idParaDest-249" class="calibre7"><a id="_idTextAnchor252" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.157.1">Emitting and receiving events</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.158.1">Once connected </span><a id="_idIndexMarker768" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.159.1">to Socket.IO, we can start </span><strong class="bold"><span class="kobospan" id="kobo.160.1">emitting</span></strong><span class="kobospan" id="kobo.161.1"> (sending) and receiving </span><a id="_idIndexMarker769" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.162.1">events. </span><span class="kobospan" id="kobo.162.2">Events are handled by registering event handler functions, which are called when a certain type of event is received by either the client or the server. </span><span class="kobospan" id="kobo.162.3">Both the client and the server can emit and receive events. </span><span class="kobospan" id="kobo.162.4">Additionally, events can be </span><strong class="bold"><span class="kobospan" id="kobo.163.1">broadcast</span></strong><span class="kobospan" id="kobo.164.1"> from the server to multiple clients. </span><span class="kobospan" id="kobo.164.2">The following diagram shows an example of how events are emitted and received in a </span><span><span class="kobospan" id="kobo.165.1">chat application:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer116">
<span class="kobospan" id="kobo.166.1"><img alt="Figure 13.3 – Emitting and receiving events with Socket.IO" src="image/B19385_13_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.167.1">Figure 13.3 – Emitting and receiving events with Socket.IO</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.168.1">As we can see, </span><strong class="bold"><span class="kobospan" id="kobo.169.1">User 1</span></strong><span class="kobospan" id="kobo.170.1"> sends a </span><strong class="bold"><span class="kobospan" id="kobo.171.1">Hello everyone</span></strong><span class="kobospan" id="kobo.172.1"> message, which the server (backend) then broadcasts to all other clients (frontend). </span><span class="kobospan" id="kobo.172.2">In this case, the message gets broadcast back to </span><strong class="bold"><span class="kobospan" id="kobo.173.1">User 1</span></strong><span class="kobospan" id="kobo.174.1">, as well as to </span><span><strong class="bold"><span class="kobospan" id="kobo.175.1">User 2</span></strong></span><span><span class="kobospan" id="kobo.176.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.177.1">If we want to </span><a id="_idIndexMarker770" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.178.1">restrict the clients that receive certain events, Socket.IO allows the </span><a id="_idIndexMarker771" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.179.1">creation of </span><strong class="bold"><span class="kobospan" id="kobo.180.1">rooms</span></strong><span class="kobospan" id="kobo.181.1">. </span><span class="kobospan" id="kobo.181.2">Clients can join a room, and on the server, we can also broadcast</span><a id="_idIndexMarker772" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.182.1"> events to only specific rooms. </span><span class="kobospan" id="kobo.182.2">This concept can be used for chat rooms, but also for collaborating on a specific project (such as editing a document together in </span><span><span class="kobospan" id="kobo.183.1">real time).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.184.1">In addition to emitting and receiving events asynchronously, Socket.IO offers a way to send an event that expects a response</span><a id="_idIndexMarker773" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.185.1"> via </span><strong class="bold"><span class="kobospan" id="kobo.186.1">acknowledgments</span></strong><span class="kobospan" id="kobo.187.1">. </span><span class="kobospan" id="kobo.187.2">These can be used to model request-response patterns in Socket.IO. </span><span class="kobospan" id="kobo.187.3">For example, we could request information about a certain user using a </span><strong class="source-inline"><span class="kobospan" id="kobo.188.1">user.info</span></strong><span class="kobospan" id="kobo.189.1"> event and synchronously wait for the server response (acknowledgment). </span><span class="kobospan" id="kobo.189.2">We can see this in the preceding diagram, where </span><strong class="bold"><span class="kobospan" id="kobo.190.1">User 2</span></strong><span class="kobospan" id="kobo.191.1"> requests information about a certain user, and then gets a response containing the </span><span><span class="kobospan" id="kobo.192.1">user’s information.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.193.1">Now that we’ve learned about event-based applications, WebSockets, and Socket.IO, let’s put this theory into practice and set </span><span><span class="kobospan" id="kobo.194.1">up Socket.IO.</span></span></p>
<h1 id="_idParaDest-250" class="calibre5"><a id="_idTextAnchor253" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.195.1">Setting up Socket.IO</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.196.1">To set up the Socket.IO server, we</span><a id="_idIndexMarker774" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.197.1"> are going to base our code on what we had in </span><a href="B19385_06.xhtml#_idTextAnchor119" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.198.1">Chapter 6</span></em></span></a><span class="kobospan" id="kobo.199.1">, </span><em class="italic"><span class="kobospan" id="kobo.200.1">Adding Authentication and Roles with JWT</span></em><span class="kobospan" id="kobo.201.1">, as it already includes some boilerplate for a backend and frontend with JWT authentication. </span><span class="kobospan" id="kobo.201.2">Later in this chapter, in the </span><em class="italic"><span class="kobospan" id="kobo.202.1">Adding authentication by integrating JWT with Socket.IO</span></em><span class="kobospan" id="kobo.203.1"> section, we are going to make use of JWT to add authentication </span><span><span class="kobospan" id="kobo.204.1">to Socket.IO:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.205.1">Copy the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.206.1">ch6</span></strong><span class="kobospan" id="kobo.207.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.208.1">ch13</span></strong><span class="kobospan" id="kobo.209.1"> folder, </span><span><span class="kobospan" id="kobo.210.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.211.1">$ cp -R ch6 ch13</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.212.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.213.1">ch13</span></strong><span class="kobospan" id="kobo.214.1"> folder in </span><span><span class="kobospan" id="kobo.215.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.216.1">Now, we can start setting up Socket.IO. </span><span class="kobospan" id="kobo.216.2">First, install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.217.1">socket.io</span></strong><span class="kobospan" id="kobo.218.1"> package in the backend folder by running the </span><span><span class="kobospan" id="kobo.219.1">following commands:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.220.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.221.1">$ npm install socket.io@4.7.2</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.222.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.223.1">backend/.env</span></strong><span class="kobospan" id="kobo.224.1"> and change </span><strong class="source-inline1"><span class="kobospan" id="kobo.225.1">DATABASE_URL</span></strong><span class="kobospan" id="kobo.226.1"> so that it points to a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.227.1">chat</span></strong></span><span><span class="kobospan" id="kobo.228.1"> database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.229.1">
DATABASE_URL=mongodb://localhost:27017/</span><strong class="bold1"><span class="kobospan1" id="kobo.230.1">chat</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.231.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.232.1">backend/src/app.js</span></strong><span class="kobospan" id="kobo.233.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.234.1">createServer</span></strong><span class="kobospan" id="kobo.235.1"> function from </span><strong class="source-inline1"><span class="kobospan" id="kobo.236.1">node:http</span></strong><span class="kobospan" id="kobo.237.1"> and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.238.1">Server</span></strong><span class="kobospan" id="kobo.239.1"> function </span><span><span class="kobospan" id="kobo.240.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.241.1">socket.io</span></strong></span><span><span class="kobospan" id="kobo.242.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.243.1">
import { createServer } from 'node:http'
import { Server } from 'socket.io'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.244.1">We are going to need to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.245.1">node:http</span></strong><span class="kobospan" id="kobo.246.1"> server as we cannot directly connect Socket.IO to Express. </span><span class="kobospan" id="kobo.246.2">Instead, Socket.IO attaches to a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">node:http</span></strong></span><span><span class="kobospan" id="kobo.248.1"> server.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.249.1">Thankfully, Express can also be easily attached to a </span><strong class="source-inline1"><span class="kobospan" id="kobo.250.1">node:http</span></strong><span class="kobospan" id="kobo.251.1"> server. </span><span class="kobospan" id="kobo.251.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.252.1">backend/src/app.js</span></strong><span class="kobospan" id="kobo.253.1"> and, before </span><strong class="source-inline1"><span class="kobospan" id="kobo.254.1">app</span></strong><span class="kobospan" id="kobo.255.1"> is exported, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.256.1">node:http</span></strong><span class="kobospan" id="kobo.257.1"> server from the Express app, </span><span><span class="kobospan" id="kobo.258.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.259.1">
const server = createServer(app)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.260.1">Now, create a</span><a id="_idIndexMarker775" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.261.1"> new Socket.IO server from the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.262.1">node:http</span></strong></span><span><span class="kobospan" id="kobo.263.1"> server:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.264.1">
const io = new Server(server, {
  cors: {
    origin: '*',
  },
})</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.265.1">Warning</span></p>
<p class="callout"><span class="kobospan" id="kobo.266.1">Setting the origin to </span><strong class="source-inline1"><span class="kobospan" id="kobo.267.1">*</span></strong><span class="kobospan" id="kobo.268.1"> makes it possible for phishing sites to imitate your website and send requests to your backend. </span><span class="kobospan" id="kobo.268.2">In production, the origin should be set to the deployed URL of </span><span><span class="kobospan" id="kobo.269.1">your frontend.</span></span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.270.1">We can use the Socket.IO server to listen to connections from clients and print </span><span><span class="kobospan" id="kobo.271.1">a message:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.272.1">
io.on('connection', (socket) =&gt; {
  console.log('user connected:', socket.id)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.273.1">The active client connection can be tracked by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.274.1">socket</span></strong><span class="kobospan" id="kobo.275.1"> object. </span><span class="kobospan" id="kobo.275.2">For example, we can listen to disconnect events from the client </span><span><span class="kobospan" id="kobo.276.1">like so:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.277.1">
  socket.on('disconnect', () =&gt; {
    console.log('user disconnected:', socket.id)
  })
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.278.1">Lastly, change the export so that it uses the </span><strong class="source-inline1"><span class="kobospan" id="kobo.279.1">node:http</span></strong><span class="kobospan" id="kobo.280.1"> server instead of the Express </span><span><span class="kobospan" id="kobo.281.1">app directly:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.282.1">
export { </span><strong class="bold1"><span class="kobospan1" id="kobo.283.1">server as app</span></strong><span class="kobospan1" id="kobo.284.1"> }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.285.1">Start the backend by running the </span><span><span class="kobospan" id="kobo.286.1">following commands:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.287.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.288.1">$ npm run dev</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.289.1">Don’t forget to get Docker and the database container up and running before starting the</span><a id="_idIndexMarker776" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.290.1"> backend. </span><span class="kobospan" id="kobo.290.2">Keep the backend running for the rest of </span><span><span class="kobospan" id="kobo.291.1">this chapter.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.292.1">Now that we have set up a simple Socket.IO server, let’s continue by setting up </span><span><span class="kobospan" id="kobo.293.1">the client.</span></span></p>
<h2 id="_idParaDest-251" class="calibre7"><a id="_idTextAnchor254" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.294.1">Setting up a simple Socket.IO client</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.295.1">We are going to use the </span><a id="_idIndexMarker777" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.296.1">existing frontend for now. </span><span class="kobospan" id="kobo.296.2">In the next chapter, </span><a href="B19385_14.xhtml#_idTextAnchor262" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.297.1">Chapter 14</span></em></span></a><span class="kobospan" id="kobo.298.1">, </span><em class="italic"><span class="kobospan" id="kobo.299.1">Creating a Frontend to Consume and Send Events</span></em><span class="kobospan" id="kobo.300.1">, we are going to remove the blog components and create a new React frontend for our chat app. </span><span class="kobospan" id="kobo.300.2">Let’s start setting up a simple </span><span><span class="kobospan" id="kobo.301.1">Socket.IO client:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.302.1">In the root of the project, install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.303.1">socket.io-client</span></strong><span class="kobospan" id="kobo.304.1"> package for the frontend by running the </span><span><span class="kobospan" id="kobo.305.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.306.1">$ npm install socket.io-client@4.7.2</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.307.1">Make sure that you aren’t in the </span><strong class="source-inline"><span class="kobospan" id="kobo.308.1">backend</span></strong> <span><span class="kobospan" id="kobo.309.1">folder anymore!</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.310.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.311.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.312.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.313.1">io</span></strong><span class="kobospan" id="kobo.314.1"> function </span><span><span class="kobospan" id="kobo.315.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.316.1">socket.io-client</span></strong></span><span><span class="kobospan" id="kobo.317.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.318.1">
import { io } from 'socket.io-client'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.319.1">Define a new instance of the Socket.IO client by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.320.1">io</span></strong><span class="kobospan" id="kobo.321.1"> function and passing a hostname </span><span><span class="kobospan" id="kobo.322.1">and port:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.323.1">
const socket = io(import.meta.env.VITE_SOCKET_HOST)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.324.1">Here, we will be passing </span><strong class="source-inline"><span class="kobospan" id="kobo.325.1">localhost:3001</span></strong><span class="kobospan" id="kobo.326.1"> through an environment variable. </span><span class="kobospan" id="kobo.326.2">We cannot pass the HTTP URL here as Socket.IO will try to connect to the hostname and port </span><span><span class="kobospan" id="kobo.327.1">using WebSockets.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.328.1">Listen to</span><a id="_idIndexMarker778" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.329.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.330.1">connect</span></strong><span class="kobospan" id="kobo.331.1"> event and print out a message if we successfully connected to the </span><span><span class="kobospan" id="kobo.332.1">Socket.IO server:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.333.1">
socket.on('connect', () =&gt; {
  console.log('connected to socket.io as', socket.id)
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.334.1">Additionally, listen to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.335.1">connect_error</span></strong><span class="kobospan" id="kobo.336.1"> event and log an error message in case connecting to the Socket.IO </span><span><span class="kobospan" id="kobo.337.1">server failed:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.338.1">
socket.on('connect_error', (err) =&gt; {
  console.error('socket.io connect error:', err)
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.339.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.340.1">.env</span></strong><span class="kobospan" id="kobo.341.1"> and add the following </span><span><span class="kobospan" id="kobo.342.1">environment variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.343.1">
VITE_SOCKET_HOST="localhost:3001"</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.344.1">Run the frontend, </span><span><span class="kobospan" id="kobo.345.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.346.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.347.1">Now, open the frontend in your browser by going to </span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">http://localhost:5173/</span></strong><span class="kobospan" id="kobo.349.1">. </span><span class="kobospan" id="kobo.349.2">Keep the frontend running for the rest of </span><span><span class="kobospan" id="kobo.350.1">this chapter.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.351.1">You will see a</span><a id="_idIndexMarker779" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.352.1"> message stating </span><strong class="bold"><span class="kobospan" id="kobo.353.1">connected to socket.io</span></strong><span class="kobospan" id="kobo.354.1"> in the browser console. </span><span class="kobospan" id="kobo.354.2">In the server output, you will see that the client connected successfully. </span><span class="kobospan" id="kobo.354.3">Try refreshing the page to see it disconnecting and connecting again (with a new </span><span><span class="kobospan" id="kobo.355.1">socket ID):</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer117">
<span class="kobospan" id="kobo.356.1"><img alt="Figure 13.4 – Seeing the Socket.IO client connect to and disconnect from our server" src="image/B19385_13_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.357.1">Figure 13.4 – Seeing the Socket.IO client connect to and disconnect from our server</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.358.1">Now that we have successfully set up a Socket.IO server, let’s continue by creating a backend for a chat app </span><span><span class="kobospan" id="kobo.359.1">using Socket.IO.</span></span></p>
<h1 id="_idParaDest-252" class="calibre5"><a id="_idTextAnchor255" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.360.1">Creating a backend for a chat app using Socket.IO</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.361.1">We can now start</span><a id="_idIndexMarker780" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.362.1"> implementing a chat app using Socket.IO. </span><span class="kobospan" id="kobo.362.2">We will be </span><a id="_idIndexMarker781" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.363.1">developing the following functionality for our </span><span><span class="kobospan" id="kobo.364.1">chat app:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.365.1">Emitting</span></strong><span class="kobospan" id="kobo.366.1"> events to send chat messages from the client to </span><span><span class="kobospan" id="kobo.367.1">the server</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.368.1">Broadcasting</span></strong><span class="kobospan" id="kobo.369.1"> chat messages from the server to </span><span><span class="kobospan" id="kobo.370.1">all clients</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.371.1">Joining </span><strong class="bold"><span class="kobospan" id="kobo.372.1">rooms</span></strong><span class="kobospan" id="kobo.373.1"> to send </span><span><span class="kobospan" id="kobo.374.1">messages in</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.375.1">Using </span><strong class="bold"><span class="kobospan" id="kobo.376.1">acknowledgments</span></strong><span class="kobospan" id="kobo.377.1"> to get information about </span><span><span class="kobospan" id="kobo.378.1">a user</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.379.1">Let’s </span><span><span class="kobospan" id="kobo.380.1">get started!</span></span></p>
<h2 id="_idParaDest-253" class="calibre7"><a id="_idTextAnchor256" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.381.1">Emitting events to send chat messages from the client to the server</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.382.1">We’ll start by </span><strong class="bold"><span class="kobospan" id="kobo.383.1">emitting</span></strong><span class="kobospan" id="kobo.384.1"> a </span><strong class="source-inline"><span class="kobospan" id="kobo.385.1">chat.message</span></strong><span class="kobospan" id="kobo.386.1"> event from the client to the server. </span><span class="kobospan" id="kobo.386.2">For now, we are going to </span><a id="_idIndexMarker782" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.387.1">emit this event right after connecting. </span><span class="kobospan" id="kobo.387.2">Later, we are going to integrate this into a frontend. </span><span class="kobospan" id="kobo.387.3">Follow these steps to send chat messages from the client and receive them on </span><span><span class="kobospan" id="kobo.388.1">the server:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.389.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.390.1">backend/src/app.js</span></strong><span class="kobospan" id="kobo.391.1"> and </span><em class="italic"><span class="kobospan" id="kobo.392.1">cut</span></em><span class="kobospan" id="kobo.393.1">/</span><em class="italic"><span class="kobospan" id="kobo.394.1">remove</span></em><span class="kobospan" id="kobo.395.1"> the </span><span><span class="kobospan" id="kobo.396.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.397.1">
io.on('connection', (socket) =&gt; {
  console.log('user connected:', socket.id)
  socket.on('disconnect', () =&gt; {
    console.log('user disconnected:', socket.id)
  })
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.398.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.399.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.400.1"> file, define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.401.1">handleSocket</span></strong><span class="kobospan" id="kobo.402.1"> function</span><a id="_idIndexMarker783" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.403.1"> there, and paste the following code </span><span><span class="kobospan" id="kobo.404.1">inside it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.405.1">
export function handleSocket(io) {
  io.on('connection', (socket) =&gt; {
    console.log('user connected:', socket.id)
    socket.on('disconnect', () =&gt; {
      console.log('user disconnected:', socket.id)
    })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.406.1">Now, add a new listener that listens to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.407.1">chat.message</span></strong><span class="kobospan" id="kobo.408.1"> event and logs the message sent from </span><span><span class="kobospan" id="kobo.409.1">the client:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.410.1">
    socket.on('chat.message', (message) =&gt; {
      console.log(`${socket.id}: ${message}`)
    })
  })
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.411.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.412.1">backend/src/app.js</span></strong><span class="kobospan" id="kobo.413.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.414.1">handleSocket</span></strong></span><span><span class="kobospan" id="kobo.415.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.416.1">
import { handleSocket } from './socket.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.417.1">Once the Socket.IO server has been created, call the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.418.1">handleSocket</span></strong></span><span><span class="kobospan" id="kobo.419.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.420.1">
const io = new Server(server, {
  cors: {
    origin: '*',
  },
})
</span><strong class="bold1"><span class="kobospan1" id="kobo.421.1">handleSocket(io)</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.422.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.423.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.424.1"> and emit a </span><strong class="source-inline1"><span class="kobospan" id="kobo.425.1">chat.message</span></strong><span class="kobospan" id="kobo.426.1"> event with some text, </span><span><span class="kobospan" id="kobo.427.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.428.1">
socket.on('connect', () =&gt; {
  console.log('connected to socket.io as', socket.id)
  </span><strong class="bold1"><span class="kobospan1" id="kobo.429.1">socket.emit('chat.message', 'hello from client')</span></strong><span class="kobospan1" id="kobo.430.1">
})</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.431.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.432.1">Socket.IO allows us to send any kind of serializable data structures in an event, not just strings! </span><span class="kobospan" id="kobo.432.2">For example, it is possible to send objects </span><span><span class="kobospan" id="kobo.433.1">and arrays.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.434.1">The backend</span><a id="_idIndexMarker784" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.435.1"> and frontend should automatically refresh and the server will log the </span><span><span class="kobospan" id="kobo.436.1">following message:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.437.1">
XXmWHjA_5zew70VIAAAM: hello from client</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.438.1">If not, make sure you (re-)start the backend and frontend and refresh the </span><span><span class="kobospan" id="kobo.439.1">page manually.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.440.1">As you can see, it is quite simple to send and receive events asynchronously in real time </span><span><span class="kobospan" id="kobo.441.1">using Socket.IO.</span></span></p>
<h2 id="_idParaDest-254" class="calibre7"><a id="_idTextAnchor257" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.442.1">Broadcasting chat messages from the server to all clients</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.443.1">Now that the backend </span><a id="_idIndexMarker785" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.444.1">server can receive messages from a client, we need to </span><strong class="bold"><span class="kobospan" id="kobo.445.1">broadcast</span></strong><span class="kobospan" id="kobo.446.1"> the messages to all other clients so that others can see the chat messages that were sent. </span><span class="kobospan" id="kobo.446.2">Let’s do </span><span><span class="kobospan" id="kobo.447.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.448.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.449.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.450.1"> and extend the </span><strong class="source-inline1"><span class="kobospan" id="kobo.451.1">chat.message</span></strong><span class="kobospan" id="kobo.452.1"> event listener so that it calls </span><strong class="source-inline1"><span class="kobospan" id="kobo.453.1">io.emit</span></strong><span class="kobospan" id="kobo.454.1"> and sends the chat message </span><span><span class="kobospan" id="kobo.455.1">to everyone:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.456.1">
    socket.on('chat.message', (message) =&gt; {
      console.log(`${socket.id}: ${message}`)
</span><strong class="bold1"><span class="kobospan1" id="kobo.457.1">      io.emit('chat.message', {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.458.1">        username: socket.id,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.459.1">        message,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.460.1">      })</span></strong><span class="kobospan1" id="kobo.461.1">
    })</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.462.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.463.1">Alternatively, you can use </span><strong class="source-inline1"><span class="kobospan" id="kobo.464.1">socket.broadcast.emit</span></strong><span class="kobospan" id="kobo.465.1"> to send an event to every client except the one that sent </span><span><span class="kobospan" id="kobo.466.1">the message.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.467.1">We also need to add a listener for chat messages on the client side. </span><span class="kobospan" id="kobo.467.2">This works the same way as on the server. </span><span class="kobospan" id="kobo.467.3">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.468.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.469.1"> and add the following </span><span><span class="kobospan" id="kobo.470.1">event listener:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.471.1">
socket.on('chat.message', (msg) =&gt; {
  console.log(`${msg.username}: ${msg.message}`)
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.472.1">Now, you should see the message being logged on the server and the client. </span><span class="kobospan" id="kobo.472.2">Try opening a second </span><a id="_idIndexMarker786" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.473.1">window; you will see messages from both clients in </span><span><span class="kobospan" id="kobo.474.1">your browser!</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer118">
<span class="kobospan" id="kobo.475.1"><img alt="Figure 13.5 – Receiving messages from another client" src="image/B19385_13_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.476.1">Figure 13.5 – Receiving messages from another client</span></p>
<h2 id="_idParaDest-255" class="calibre7"><a id="_idTextAnchor258" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.477.1"> Joining rooms to send messages in</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.478.1">While having a working </span><a id="_idIndexMarker787" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.479.1">chat where messages get relayed to everyone is nice, often, we don’t want to broadcast our messages to everyone. </span><span class="kobospan" id="kobo.479.2">Instead, we might want to only send messages to a certain group of people. </span><span class="kobospan" id="kobo.479.3">To facilitate</span><a id="_idIndexMarker788" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.480.1"> this, Socket.IO provides </span><strong class="bold"><span class="kobospan" id="kobo.481.1">rooms</span></strong><span class="kobospan" id="kobo.482.1">. </span><span class="kobospan" id="kobo.482.2">Rooms can be used to group clients together so that events are only sent to all other clients in the room. </span><span class="kobospan" id="kobo.482.3">This feature can be used to create chat rooms, but also for collaborating on a project together (by creating a new room for each project). </span><span class="kobospan" id="kobo.482.4">Let’s learn how rooms</span><a id="_idIndexMarker789" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.483.1"> can be used </span><span><span class="kobospan" id="kobo.484.1">in Socket.IO:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.485.1">Socket.IO allows us to pass a query string during the handshake. </span><span class="kobospan" id="kobo.485.2">We can access this query string to get the room that the client wants to join. </span><span class="kobospan" id="kobo.485.3">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.486.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.487.1"> and get the room from the </span><span><span class="kobospan" id="kobo.488.1">handshake query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.489.1">
  io.on('connection', (socket) =&gt; {
    console.log('user connected:', socket.id)
</span><strong class="bold1"><span class="kobospan1" id="kobo.490.1">    const room = socket.handshake.query?.room ?? </span><span class="kobospan1" id="kobo.490.2">'public'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.491.1">Now, use </span><strong class="source-inline1"><span class="kobospan" id="kobo.492.1">socket.join</span></strong><span class="kobospan" id="kobo.493.1"> to join the client into the </span><span><span class="kobospan" id="kobo.494.1">selected room:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.495.1">
    socket.join(room)
    console.log(socket.id, 'joined room:', room)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.496.1">Then, inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.497.1">chat.message</span></strong><span class="kobospan" id="kobo.498.1"> handler, use </span><strong class="source-inline1"><span class="kobospan" id="kobo.499.1">.to(room)</span></strong><span class="kobospan" id="kobo.500.1"> to make sure chat messages from that client are only sent to a </span><span><span class="kobospan" id="kobo.501.1">certain room:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.502.1">
      io</span><strong class="bold1"><span class="kobospan1" id="kobo.503.1">.to(room)</span></strong><span class="kobospan1" id="kobo.504.1">.emit('chat.message', {
        username: socket.id,
        message,
      })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.505.1">In the client, we need to pass a query string to tell the server which room we would like to join. </span><span class="kobospan" id="kobo.505.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.506.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.507.1">, </span><span><span class="kobospan" id="kobo.508.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.509.1">
const socket = io(import.meta.env.VITE_SOCKET_HOST</span><strong class="bold1"><span class="kobospan1" id="kobo.510.1">, {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.511.1">  query: window.location.search.substring(1),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.512.1">}</span></strong><span class="kobospan1" id="kobo.513.1">)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.514.1">The Socket.IO query string is a URL query string, so we can simply pass the query string of the current page to it (without </span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">?</span></strong><span class="kobospan" id="kobo.516.1"> at the beginning of </span><span><span class="kobospan" id="kobo.517.1">the string).</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.518.1">Open </span><strong class="source-inline1"><span class="kobospan" id="kobo.519.1">http://localhost:5173/</span></strong><span class="kobospan" id="kobo.520.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.521.1">http://localhost:5173/?room=test</span></strong><span class="kobospan" id="kobo.522.1"> in two separate browser windows and send messages from both. </span><span class="kobospan" id="kobo.522.2">You will see that the message from the second window doesn’t get sent to the first window. </span><span class="kobospan" id="kobo.522.3">However, if you open another window with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.523.1">?room=test</span></strong><span class="kobospan" id="kobo.524.1"> query string and send a message there, you will see the message being forwarded to the second </span><a id="_idIndexMarker790" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.525.1">window (but not </span><span><span class="kobospan" id="kobo.526.1">the first).</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.527.1">As we can see, we can use rooms to have more fine-grained control over which clients receive certain events. </span><span class="kobospan" id="kobo.527.2">As the server controls which rooms a client joins, we can also add permission checks before allowing a client to join </span><span><span class="kobospan" id="kobo.528.1">a room.</span></span></p>
<h2 id="_idParaDest-256" class="calibre7"><a id="_idTextAnchor259" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.529.1">Using acknowledgments to get information about a user</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.530.1">As we have seen, events</span><a id="_idIndexMarker791" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.531.1"> are a great way to send asynchronous messages. </span><span class="kobospan" id="kobo.531.2">Sometimes, however, we want a more traditional synchronous request-response API, like we had with REST. </span><span class="kobospan" id="kobo.531.3">In Socket.IO, we can</span><a id="_idIndexMarker792" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.532.1"> implement synchronous events by using </span><strong class="bold"><span class="kobospan" id="kobo.533.1">acknowledgments</span></strong><span class="kobospan" id="kobo.534.1">. </span><span class="kobospan" id="kobo.534.2">We can use acknowledgments to, for example, get more information about a user in the current chat room. </span><span class="kobospan" id="kobo.534.3">For now, we are only going to return the rooms that the user is in. </span><span class="kobospan" id="kobo.534.4">Later, when we add authentication, we are going to fetch the user object from the database here. </span><span class="kobospan" id="kobo.534.5">Let’s get started </span><span><span class="kobospan" id="kobo.535.1">implementing acknowledgments:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.536.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.537.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.538.1"> and define a new </span><span><span class="kobospan" id="kobo.539.1">event listener:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.540.1">
    socket.on('user.info', async (socketId, callback) =&gt; {</span></pre><p class="calibre3"><span class="kobospan" id="kobo.541.1">Note how we are passing a callback function as the last argument. </span><span class="kobospan" id="kobo.541.2">This is what makes the event </span><span><span class="kobospan" id="kobo.542.1">an acknowledgment.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.543.1">In this event listener, we are going to fetch all sockets in the room with the ID of </span><span><span class="kobospan" id="kobo.544.1">our socket:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.545.1">
      const sockets = await io.in(socketId).fetchSockets()</span></pre><p class="calibre3"><span class="kobospan" id="kobo.546.1">Internally, Socket.IO creates a room for each connected socket, to make it possible to send events to a </span><span><span class="kobospan" id="kobo.547.1">single socket.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.548.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.549.1">We could directly access the sockets of the current instance, but that wouldn’t work anymore when we scale our service to multiple instances in a cluster. </span><span class="kobospan" id="kobo.549.2">To make it work even in a cluster, we need to use the room functionality to get a socket </span><span><span class="kobospan" id="kobo.550.1">by ID.</span></span></p>
<ol class="calibre15">
<li value="3" class="calibre11"><span class="kobospan" id="kobo.551.1">Now, we </span><a id="_idIndexMarker793" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.552.1">must check if we found a socket with the given ID. </span><span class="kobospan" id="kobo.552.2">If not, we </span><span><span class="kobospan" id="kobo.553.1">return </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.554.1">null</span></strong></span><span><span class="kobospan" id="kobo.555.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.556.1">
      if (sockets.length === 0) return callback(null)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.557.1">Otherwise, we return the socket ID and a list of rooms that the user </span><span><span class="kobospan" id="kobo.558.1">is in:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.559.1">
      const socket = sockets[0]
      const userInfo = {
        socketId,
        rooms: Array.from(socket.rooms),
      }
      return callback(userInfo)
    })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.560.1">Now, we can emit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.561.1">user.info</span></strong><span class="kobospan" id="kobo.562.1"> event on the client. </span><span class="kobospan" id="kobo.562.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.563.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.564.1"> and start by making the </span><strong class="source-inline1"><span class="kobospan" id="kobo.565.1">connect</span></strong><span class="kobospan" id="kobo.566.1"> event listener an </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.567.1">async</span></strong></span><span><span class="kobospan" id="kobo.568.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.569.1">
socket.on('connect', </span><strong class="bold1"><span class="kobospan1" id="kobo.570.1">async</span></strong><span class="kobospan1" id="kobo.571.1"> () =&gt; {
  console.log('connected to socket.io as', socket.id)
  socket.emit('chat.message', 'hello from client')</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.572.1">To emit an</span><a id="_idIndexMarker794" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.573.1"> event with an acknowledgment, we can use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.574.1">emitWithAck</span></strong><span class="kobospan" id="kobo.575.1"> function, which returns a Promise that we </span><span><span class="kobospan" id="kobo.576.1">can </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.577.1">await</span></strong></span><span><span class="kobospan" id="kobo.578.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.579.1">
  const userInfo = await socket.emitWithAck('user.info', socket.id)
  console.log('user info', userInfo)
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.580.1">After saving the code, go to the browser window; you will see the user’s information being logged in </span><span><span class="kobospan" id="kobo.581.1">the console:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer119">
<span class="kobospan" id="kobo.582.1"><img alt="Figure 13.6 – Getting user information with an acknowledgment" src="image/B19385_13_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.583.1">Figure 13.6 – Getting user information with an acknowledgment</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.584.1">Now that we have learned how to send various kinds of events, let’s get into a more advanced topic: authentication </span><span><span class="kobospan" id="kobo.585.1">with Socket.IO.</span></span></p>
<h1 id="_idParaDest-257" class="calibre5"><a id="_idTextAnchor260" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.586.1">Adding authentication by integrating JWT with Socket.IO</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.587.1">So far, all </span><a id="_idIndexMarker795" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.588.1">chat messages have been sent with the socket ID as the “username.” </span><span class="kobospan" id="kobo.588.2">This is not a very good way to identify users in a chat room. </span><span class="kobospan" id="kobo.588.3">To fix this, we are going to introduce user accounts by authenticating sockets with JWT. </span><span class="kobospan" id="kobo.588.4">Follow these steps to implement JWT </span><span><span class="kobospan" id="kobo.589.1">with Socket.IO:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.590.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.591.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.592.1"> and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.593.1">jwt</span></strong><span class="kobospan" id="kobo.594.1"> from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.595.1">jsonwebtoken</span></strong><span class="kobospan" id="kobo.596.1"> package and </span><strong class="source-inline1"><span class="kobospan" id="kobo.597.1">getUserInfoById</span></strong><span class="kobospan" id="kobo.598.1"> from our </span><span><span class="kobospan" id="kobo.599.1">service functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.600.1">
import jwt from 'jsonwebtoken'
import { getUserInfoById } from './services/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.601.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.602.1">handleSocket</span></strong><span class="kobospan" id="kobo.603.1"> function, define a new Socket.IO middleware by using </span><strong class="source-inline1"><span class="kobospan" id="kobo.604.1">io.use()</span></strong><span class="kobospan" id="kobo.605.1">. </span><span class="kobospan" id="kobo.605.2">Middleware in Socket.IO works similarly to middleware in Express – we define a function that runs before requests are processed, </span><span><span class="kobospan" id="kobo.606.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.607.1">
export function handleSocket(io) {
</span><strong class="bold1"><span class="kobospan1" id="kobo.608.1">  io.use((socket, next) =&gt; {</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.609.1">Inside this function, we check if the token was sent via the </span><strong class="source-inline1"><span class="kobospan" id="kobo.610.1">auth</span></strong><span class="kobospan" id="kobo.611.1"> object (similar to how we passed </span><strong class="source-inline1"><span class="kobospan" id="kobo.612.1">room</span></strong><span class="kobospan" id="kobo.613.1"> earlier via the query string). </span><span class="kobospan" id="kobo.613.2">If no token was passed, we pass an </span><a id="_idIndexMarker796" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.614.1">error to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.615.1">next()</span></strong><span class="kobospan" id="kobo.616.1"> function and cause the connection </span><span><span class="kobospan" id="kobo.617.1">to fail:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.618.1">
    if (!socket.handshake.auth?.token) {
      return next(new Error('Authentication failed: no token provided'))
    }</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.619.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.620.1">It is important not to pass a JWT via the query string since this is part of the URL. </span><span class="kobospan" id="kobo.620.2">It is exposed in the browser address bar and thus potentially stored in the browser history, where it could be extracted by a potential attacker. </span><span class="kobospan" id="kobo.620.3">Instead, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.621.1">auth</span></strong><span class="kobospan" id="kobo.622.1"> object is sent via the request payload during the handshake, which is not exposed in the </span><span><span class="kobospan" id="kobo.623.1">address bar.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.624.1">Otherwise, we call </span><strong class="source-inline1"><span class="kobospan" id="kobo.625.1">jwt.verify</span></strong><span class="kobospan" id="kobo.626.1"> to verify the token by using the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.627.1">JWT_SECRET</span></strong> <span><span class="kobospan" id="kobo.628.1">environment variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.629.1">
    jwt.verify(
      socket.handshake.auth.token,
      process.env.JWT_SECRET,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.630.1">If the</span><a id="_idIndexMarker797" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.631.1"> token is invalid, we once again return an error in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.632.1">next()</span></strong></span><span><span class="kobospan" id="kobo.633.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.634.1">
      async (err, decodedToken) =&gt; {
        if (err) {
          return next(new Error('Authentication failed: invalid token'))
        }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.635.1">Otherwise, we save the decoded token </span><span><span class="kobospan" id="kobo.636.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.637.1">socket.auth</span></strong></span><span><span class="kobospan" id="kobo.638.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.639.1">
        socket.auth = decodedToken</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.640.1">Additionally, we fetch the user information from the database and, for convenience, store it </span><span><span class="kobospan" id="kobo.641.1">in </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.642.1">socket.user</span></strong></span><span><span class="kobospan" id="kobo.643.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.644.1">
        socket.user = await getUserInfoById(socket.auth.sub)
        return next()
      },
    )
  })</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.645.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.646.1">Make sure that </span><strong class="source-inline1"><span class="kobospan" id="kobo.647.1">next()</span></strong><span class="kobospan" id="kobo.648.1"> is always called in Socket.IO middleware. </span><span class="kobospan" id="kobo.648.2">Otherwise, Socket.IO will keep the connection open until it is closed after a </span><span><span class="kobospan" id="kobo.649.1">given timeout.</span></span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.650.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.651.1">user</span></strong><span class="kobospan" id="kobo.652.1"> object contains a </span><strong class="source-inline1"><span class="kobospan" id="kobo.653.1">username</span></strong><span class="kobospan" id="kobo.654.1"> value. </span><span class="kobospan" id="kobo.654.2">Now, we can </span><em class="italic"><span class="kobospan" id="kobo.655.1">replace</span></em><span class="kobospan" id="kobo.656.1"> the socket ID in the chat message with </span><span><span class="kobospan" id="kobo.657.1">the username:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.658.1">
         socket.on('chat.message', (message) =&gt; {
      console.log(`${socket.id}: ${message}`)
      io.to(room).emit('chat.message', {
        username: </span><strong class="bold1"><span class="kobospan1" id="kobo.659.1">socket.user.username</span></strong><span class="kobospan1" id="kobo.660.1">,
        message,
      })
    })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.661.1">We can also </span><a id="_idIndexMarker798" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.662.1">return the user information from the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.663.1">user.info</span></strong></span><span><span class="kobospan" id="kobo.664.1"> event:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.665.1">
      const userInfo = {
        socketId,
        rooms: Array.from(socket.rooms),
</span><strong class="bold1"><span class="kobospan1" id="kobo.666.1">        user: socket.user,</span></strong><span class="kobospan1" id="kobo.667.1">
      }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.668.1">We still need to send the auth object from the client side, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.669.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.670.1">, and get the token from </span><strong class="source-inline1"><span class="kobospan" id="kobo.671.1">localStorage</span></strong><span class="kobospan" id="kobo.672.1">, </span><span><span class="kobospan" id="kobo.673.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.674.1">
const socket = io(import.meta.env.VITE_SOCKET_HOST, {
  query: window.location.search.substring(1),
</span><strong class="bold1"><span class="kobospan1" id="kobo.675.1">  auth: {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.676.1">    token: window.localStorage.getItem('token'),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.677.1">  },</span></strong><span class="kobospan1" id="kobo.678.1">
})</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.679.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.680.1">For simplicity, we store and read the JWT in </span><strong class="source-inline1"><span class="kobospan" id="kobo.681.1">localStorage</span></strong><span class="kobospan" id="kobo.682.1"> for this example. </span><span class="kobospan" id="kobo.682.2">However, it is not a good idea to store a JWT like this in production as </span><strong class="source-inline1"><span class="kobospan" id="kobo.683.1">localStorage</span></strong><span class="kobospan" id="kobo.684.1"> could be read by an attacker if they find a way to inject JavaScript. </span><span class="kobospan" id="kobo.684.2">A better way to store a JWT would be by using a cookie with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.685.1">Secure</span></strong><span class="kobospan" id="kobo.686.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.687.1">HttpOnly</span></strong><span class="kobospan" id="kobo.688.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.689.1">SameSite="Strict"</span></strong></span><span><span class="kobospan" id="kobo.690.1"> attributes.</span></span></p>
<ol class="calibre15">
<li value="11" class="calibre11"><span class="kobospan" id="kobo.691.1">Now</span><a id="_idIndexMarker799" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.692.1"> that the server side is set up, we can try logging in on the client. </span><span class="kobospan" id="kobo.692.2">Initially, we are going to see an </span><span><span class="kobospan" id="kobo.693.1">error message:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer120">
<span class="kobospan" id="kobo.694.1"><img alt="Figure 13.7 – An error message from Socket.IO because no JWT was provided" src="image/B19385_13_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.695.1">Figure 13.7 – An error message from Socket.IO because no JWT was provided</span></p>
<ol class="calibre15">
<li value="12" class="calibre11"><span class="kobospan" id="kobo.696.1">To get a token, we can sign up and log in normally using the existing blog frontend. </span><span class="kobospan" id="kobo.696.2">Then, we can check the </span><strong class="bold"><span class="kobospan" id="kobo.697.1">Network</span></strong><span class="kobospan" id="kobo.698.1"> tab of the inspector to find the </span><strong class="source-inline1"><span class="kobospan" id="kobo.699.1">/login</span></strong><span class="kobospan" id="kobo.700.1"> request with a token inside </span><span><span class="kobospan" id="kobo.701.1">the response:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer121">
<span class="kobospan" id="kobo.702.1"><img alt="Figure 13.8 – Copying the JWT from the Network tab" src="image/B19385_13_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.703.1">Figure 13.8 – Copying the JWT from the Network tab</span></p>
<ol class="calibre15">
<li value="13" class="calibre11"><span class="kobospan" id="kobo.704.1">Copy this token and add it to </span><strong class="source-inline1"><span class="kobospan" id="kobo.705.1">localStorage</span></strong><span class="kobospan" id="kobo.706.1"> by running </span><strong class="source-inline1"><span class="kobospan" id="kobo.707.1">localStorage.setItem('token', '&lt;JWT&gt;')</span></strong><span class="kobospan" id="kobo.708.1"> in the browser console (replacing </span><strong class="source-inline1"><span class="kobospan" id="kobo.709.1">&lt;JWT&gt;</span></strong><span class="kobospan" id="kobo.710.1"> with the copied token). </span><span class="kobospan" id="kobo.710.2">Upon refreshing the page, it should work! </span><span class="kobospan" id="kobo.710.3">As we can see, when logged in with two different users, we can see their messages with their </span><span><span class="kobospan" id="kobo.711.1">respective usernames:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer122">
<span class="kobospan" id="kobo.712.1"><img alt="Figure 13.9 – Receiving messages from different users" src="image/B19385_13_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.713.1">Figure 13.9 – Receiving messages from different users</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.714.1">Our chat </span><a id="_idIndexMarker800" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.715.1">backend is now fully functional! </span><span class="kobospan" id="kobo.715.2">In the next chapter, we are going to create a frontend to complete our </span><span><span class="kobospan" id="kobo.716.1">chat app.</span></span></p>
<h1 id="_idParaDest-258" class="calibre5"><a id="_idTextAnchor261" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.717.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.718.1">In this chapter, we learned about event-based applications, WebSockets, and Socket.IO. </span><span class="kobospan" id="kobo.718.2">Then, we set up Socket.IO on the backend (server) and frontend (client). </span><span class="kobospan" id="kobo.718.3">Afterward, we learned how to send messages between the server and client, how to join rooms, and how to broadcast messages. </span><span class="kobospan" id="kobo.718.4">We also used acknowledgments to get information about a user in a request-response pattern with Socket.IO. </span><span class="kobospan" id="kobo.718.5">Finally, we implemented authentication using JWT in Socket.IO, finalizing our chat </span><span><span class="kobospan" id="kobo.719.1">app backend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.720.1">In the next chapter, </span><a href="B19385_14.xhtml#_idTextAnchor262" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.721.1">Chapter 14</span></em></span></a><span class="kobospan" id="kobo.722.1">, </span><em class="italic"><span class="kobospan" id="kobo.723.1">Creating a Frontend to Consume and Send Events</span></em><span class="kobospan" id="kobo.724.1">, we are going to create a frontend for our chat app, which is going to interact with the backend we created in </span><span><span class="kobospan" id="kobo.725.1">this chapter.</span></span></p>
</div>
</body></html>