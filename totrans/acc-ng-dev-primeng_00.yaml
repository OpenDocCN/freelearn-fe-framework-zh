- en: '*Chapter 4*: Exploring Angular Components Features'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16295_03_ePub_RK.xhtml#_idTextAnchor047), *Introducing CSS
    Custom Properties and New Provider Scopes,* we explored new platform and framework
    features in depth to prepare for *Part 2, Build a Real-World Application with
    the Angular Ivy Features You Learned*. Let's continue, but this time focus on
    brand new APIs introduced in the Angular component packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Angular Ivy, the two first official Angular packages for Google products
    were introduced: YouTube Player and embedded Google Maps. We will explore both
    of these packages in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will cover two new APIs introduced by the Angular CDK: the Clipboard
    API and component testing harnesses. The Angular CDK clipboard directive, service,
    and domain object interact with the operating system''s native clipboard. A component
    harness is a testing API wrapping one or more Angular components using the test-as-a-user
    approach. It is usable in the context of unit tests and end-to-end tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular YouTube Player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Google Maps components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Clipboard API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing as a user with component harnesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about these topics will enable you to use these powerful features for
    our existing application in *Part 2, Build a Real-World Application with the Angular
    Ivy Features You Learned*.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To proceed with this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular 9.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the complete code for the video and map examples in this book's
    companion GitHub repository at [https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter4](https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter4).
  prefs: []
  type: TYPE_NORMAL
- en: Angular YouTube Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of Angular Ivy, the Angular team published official Angular components
    for Google products. One of them is the Angular YouTube Player. As the name suggests,
    it is used to embed a YouTube video player in your Angular application while getting
    the convenience of Angular data binding as well as programmatic access to the
    YouTube Player API through a component reference.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through the setup needed to start using the Angular
    YouTube Player. We will then look at its entire API to get familiar with its capabilities
    and usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, make sure to install the `@angular/youtube-player` package by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add `YouTubePlayerModule` to the module that declares the component that
    is going to use the YouTube Player component, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before using the Angular YouTube Player component for the first time, we must
    load the YouTube IFrame API script. It is a 100 KB script, so depending on your
    priorities, there are several ways to load it. You could load it as part of the
    `scripts` option in your application project configuration in `angular.json`,
    but then the user would always pay the price upfront for loading, parsing, and
    executing this script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can load it in when the component using it is activated, as we
    will see in the following tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the Angular core and common APIs we need and declare component
    metadata and the component name, in this case, `VideoComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add a private property to keep a reference to the script we are going
    to dynamically load:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we inject the `Document` object of our platform, that is, the browser
    or the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create an `async` script element that points to the https://www.youtube.com/iframe_api
    URL. This is a loader script for the initialization script, which sets up the
    YouTube API needed to embed YouTube videos. The Angular YouTube Player component
    is a convenient wrapper around this API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When `VideoComponent` is initializing, add the YouTube IFrame API script element
    to the body element of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We remove the script element when `VideoComponent` is deactivated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do not worry about loading the script multiple times. The browser will cache
    it and the YouTube IFrame API script will detect that it has already been loaded.
    For an even more robust setup solution, we can listen for the `loaded` event on
    the script element, set a loaded flag in our code, and add a condition not to
    load the script the next time this component is activated.
  prefs: []
  type: TYPE_NORMAL
- en: This is all the setup we need to use the Angular YouTube Player component. The
    full example is available in this book's companion GitHub repository, as mentioned
    in the introduction of this chapter. Now, let's move on to usage instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest example of using the Angular YouTube Player is to put the following
    code snippet in a component template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We pass a YouTube video ID to the `videoId` input property and the Angular YouTube
    Player will take care of everything else. Of course, it also allows for more customization.
    Let's start by looking at the `YouTubePlayer` component's data binding API.
  prefs: []
  type: TYPE_NORMAL
- en: API reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of Angular version 12, the YouTube Player has no API reference. This is provided
    for you in this section so that you do not have to look up the source code and
    cross-reference it with the online YouTube JavaScript API reference to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The data binding API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the data binding API, we can declaratively configure the Angular YouTube
    Player component. The input properties are used to configure settings while the
    output properties emit events about user interactions and the video environment.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will look at the input properties.
  prefs: []
  type: TYPE_NORMAL
- en: Input properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input properties are used to configure the playback and visuals of the
    embedded player:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Input() endSeconds: number | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set a playback ending point of the YouTube video, pass the offset in the
    number of seconds from the beginning of the video.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Input() height: number | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of the YouTube Player is specified using the `height` input property,
    in the number of CSS pixels. It defaults to `390`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Input() playerVars: YT.PlayerVars | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many additional options can be passed to the `playerVars` input property, for
    example, we can pass `{ modestbranding: YT.ModestBranding.Modest }` to hide the
    YouTube logo. For a full reference, see [https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters](https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Input() showBeforeIframeApiLoads: boolean | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `showBeforeIframeApiLoads` input property defaults to `false` but can be
    set to `true` to make the YouTube Player component throw an error if it is loaded
    before the YouTube IFrame API is loaded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Input() startSeconds: number | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set a playback starting point for the YouTube video, pass the offset in the
    number of seconds from the beginning of the video.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Input() suggestedQuality: YT.SuggestedVideoQuality | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `suggestedQuality` input property accepts one of the following quality
    identifiers: `''default''`, `''small''`, `''medium''`, `''large''`, `''hd720''`,
    `''hd1080''`, `''highres''`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Input() videoId: string | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `videoId` input property accepts the YouTube video ID of the video to be
    played back.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Input() width: number | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The width of the YouTube Player is specified using the `width` input property,
    in the number of CSS pixels. It defaults to `640`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will look at the output properties, which emit events about the user
    interactions and video environment.
  prefs: []
  type: TYPE_NORMAL
- en: Output properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The output properties expose the events that are emitted by the YouTube IFrame
    API. For a full reference of the events, see https://developers.google.com/youtube/iframe_api_reference#Events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Output() apiChange: Observable<YT.PlayerEvent>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the closed captioning module is loaded or unloaded, an event is emitted
    by the `apiChange` output property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Output() error: Observable<YT.OnErrorEvent>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `error` output property emits an event when one of the following errors
    occurs, all of which are accessible through the `YT.PlayerError` enum: `EmbeddingNotAllowed`,
    `EmbeddingNotAllowed2`, `Html5Error`, `InvalidParam`, `VideoNotFound`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Output() playbackQualityChange: Observable<YT.OnPlaybackQualityChangeEvent>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the playback quality changes, one of the following quality identifiers
    is emitted through the `playbackQualityChange` output property: `''default''`,
    `''small''`, `''medium''`, `''large''`, `''hd720''`, `''hd1080''`, `''highres''`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Output() playbackRateChange:Observable<YT.OnPlaybackRateChangeEvent>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the video playback rate is changed, the `playbackRateChange` output property
    emits an event where its `data` property is a number such as `1.0` signifying
    the playback speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Output() ready: Observable<YT.PlayerEvent>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This event is emitted when the YouTube Player is fully loaded and ready to be
    controlled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@Output() stateChange: Observable<YT.OnStateChangeEvent>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An event is output every time the YouTube Player state changes to one of the
    following, which are all accessible through the `YT.PlayerState` enum: `BUFFERING`,
    `CUED`, `ENDED`, `PAUSED`, `PLAYING`, `UNSTARTED`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our components can send commands or read information from the YouTube Player
    using its components methods, which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Component methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `YouTubePlayer` component has several public methods that we can use to
    control the embedded video player:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAvailablePlaybackRates(): number[];`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the supported playback rate for the current active or queued video.
    For a video supporting only normal playback speed, `[1.0]` is returned. Something
    like `[0.25, 0.5, 1.0, 1.5, 2.0]` might be returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getCurrentTime(): number;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the number of seconds elapsed since the beginning of the video.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getDuration(): number;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the duration in seconds of the current active video. If the video's
    metadata has not been loaded, it will return `0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For live streams, it will return the number of seconds since the stream started,
    was reset, or interrupted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getPlaybackRate(): number;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the playback rate of the current active or queued video where `1.0`
    is the normal playback speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getPlayerState(): YT.PlayerState | undefined;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Determines the current player state between one of the following, which are
    all accessible through the `YT.PlayerState` enum: `BUFFERING`, `CUED`, `ENDED`,
    `PAUSED` , `PLAYING`, `UNSTARTED`. Returns the latest value represented by an
    event emitted by the `stateChange` output property.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVideoEmbedCode(): string;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Determines the HTML markup needed to embed the video in an HTML page, for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`getVideoLoadedFraction(): number;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the percentage of the video that has been buffered by the player
    where `0.0` is 0% and `1.0` is 100%.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVideoUrl(): string;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the video's full URL on [youtube.com](http://youtube.com).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getVolume(): number;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determines the volume level between `0` and `100`. Only returns integers. When
    muted, this method will return the level that was active when the audio was muted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`isMuted(): boolean;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks whether the audio is muted. `true` means muted, `false` means unmuted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mute(): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutes the audio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pauseVideo(): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pauses the video. An event is emitted through `stateChange`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`playVideo(): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts playing the video. Does not count towards the video's view count on YouTube.
    An event is emitted through `stateChange`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`seekTo(seconds: number, allowSeekAhead: boolean): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goes to the specified timestamp. The video will keep being paused if paused
    before seeking. Setting `allowSeekAhead` to `false` keeps the player from downloading
    unbuffered content from the server. This can be used in combination with a progress
    bar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`setPlaybackRate(playbackRate: number): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusts the playback speed. Only affects the current active or queued video.
    Passing `1.0` to `playbackRate` sets the playback speed to normal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We should first call `getAvailablePlaybackRates` to check which playback rates
    are supported for the video. Listen to events emitted by the `playbackRateChange`
    output property to verify that the playback speed was successfully adjusted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the passed `playbackRate` does not exactly match supported playback speeds,
    the nearest rate will be matched, rounding to `1.0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`setVolume(volume: number): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusts the volume to a level between `0` and `100`. Only accepts integers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`stopVideo(): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stops loading or playing the video. We can use this if we know that the user
    will not be watching additional videos in the YouTube Player. It's not necessary
    to call it before playing a different video. An event is emitted through `stateChange`,
    but the state could be any of `CUED`, `ENDED`, `PAUSED`, or `UNSTARTED`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unMute(): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmutes the audio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the knowledge of the full component API of the `YouTubePlayer` component,
    you can build your own controls on top of it, configure default settings across
    all YouTube Players in our application, control many YouTube Players at the same
    time or implement a YouTube video snippet widget using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed how to install and set up your application for the Angular
    YouTube Player. We have seen a simple example usage, listed its full API, and
    discussed its use cases. You are now ready to use the Angular YouTube Player in
    *Part 2, Build a Real-World Application with the Angular Ivy Features You Learned.*
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the official Angular components for Google Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Google Maps components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the official Google product component package
    called Angular Google Maps. The Google Maps API is large, so this package includes
    both a `GoogleMap` component and several other components used to configure and
    control its many features.
  prefs: []
  type: TYPE_NORMAL
- en: 'It consists of the following Angular components and directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GoogleMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapBicyclingLayer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapCircle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapGroundOverlay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapInfoWindow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapKmlLayer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapMarker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapMarkerClusterer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapPolygon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapRectangle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapTrafficLayer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapTransitLayer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore the necessary component, `GoogleMap`, and the commonly used
    components `MapInfoWindow`, `MapMarker`, and `MapMarkerClusterer`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the Angular Google Maps components, we first must load the Google Maps
    JavaScript API. This example wrapper component illustrates how to conditionally
    render the Google Maps component after the Google Maps JavaScript API has been
    initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `MapComponent` has an observable UI property called `isGoogleMapsApiLoaded$`,
    which loads the Google Maps JavaScript API with a pre-configured API key. We use
    this to conditionally render the `GoogleMap` component in the component template,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Until the Google Maps JavaScript API is loaded, an Angular Material Spinner
    component is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we created a view child query for `GoogleMap` and stored it in the
    `map` property. This can be used to programmatically control the map from the
    component model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, here is the Angular module that declares our example `MapComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the setup needed to work with the Angular Google Maps API,
    let's take a closer look at the most common components included in the `@angular/google-maps`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The GoogleMap component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GoogleMap` component is the primary entry point to the Angular Google Maps
    package. It is the top-level component that can contain other components from
    this package.
  prefs: []
  type: TYPE_NORMAL
- en: This component is a declarative, Angular-specific wrapper for the `google.maps.Map`
    class from the Google Maps JavaScript API. Refer to the API reference for more
    details on the `Map` class (https://developers.google.com/maps/documentation/javascript/reference/map).
  prefs: []
  type: TYPE_NORMAL
- en: The Google map component has the `center`, `height`, `mapTypeId`, `width`, and
    `zoom` input properties. It also accepts an `options` input of the `google.maps.MapOptions`
    type. It has 19 different output properties, all matching DOM events described
    in the Google Maps JavaScript API reference for the `Map` class. It also has a
    wide range of methods available for controlling the map.
  prefs: []
  type: TYPE_NORMAL
- en: The MapMarker component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MapMarker` component's element, `<map-marker>`, is either nested inside
    the `<google-map>` element or a `<map-marker-clusterer>` element.
  prefs: []
  type: TYPE_NORMAL
- en: This component represents a marker on a Google map. We can use a label, a marker
    icon, or a marker symbol to customize it.
  prefs: []
  type: TYPE_NORMAL
- en: '`MapMarker` is an Angular-specific wrapper for the `google.maps.Marker` class.
    It has the `clickable`, `label`, `position`, and `title` input properties. It
    also accepts an `options` input of the `google.maps.MarkerOptions` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass a custom icon through the marker options, for example, as follows
    where we use a beach flag icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the API reference for more details on the `Marker` class ([https://developers.google.com/maps/documentation/javascript/reference/marker](https://developers.google.com/maps/documentation/javascript/reference/marker)).
  prefs: []
  type: TYPE_NORMAL
- en: The MapMarkerClusterer component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MapMarkerClusterer` component is an Angular-specific wrapper around the
    `MarkerClusterer` class from the `@googlemaps/markerclustererplus` package. Its
    element, `<map-marker-clusterer>`, is nested inside of `<google-map>` and contains
    multiple `<map-marker>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: This component is used to group many map markers into clusters when zoomed out
    on a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use it, we must load it into a global variable by inserting the
    following script tag at an appropriate place, for simplicity''s sake in the template
    of the component using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `MapMarkerClusterer` component has 18 different input properties, such as
    `minimumClusterSize`, `maxZoom`, and `zoomOnClick`. The `imagePath` input property
    can be used to specify custom map marker cluster images where this path is automatically
    suffixed with `[1-5].png` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two output properties are available: `clusteringbegin` and `clusteringend`.
    They are emitted whenever markers first cluster and when they are split into individual
    markers, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the API reference for more details on the `MarkerClusterer` class (https://developers.google.com/maps/documentation/javascript/marker-clustering).
  prefs: []
  type: TYPE_NORMAL
- en: The MapInfoWindow component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MapInfoWindow` component is an Angular-specific wrapper for the `google.maps.InfoWindow`
    class. Its element, `<map-info-window>`, is nested inside of `<google-map>`.
  prefs: []
  type: TYPE_NORMAL
- en: It is an overlay used to display notifications or metadata on top of a map,
    usually near a map marker.
  prefs: []
  type: TYPE_NORMAL
- en: Its `position` input property declares where on the map it appears. Additionally,
    it accepts an `options` input of type `google.maps.InfoWindowOptions`. It has
    five different output properties – `closeClick`, `contentChanged`, `domready`,
    `positionChanged`, and `zindexChanged` – all matching DOM events described in
    the Google Maps JavaScript API reference for the `InfoWindow` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `MapInfoWindow` component uses content projection, which means that the
    content we put inside of its custom element tags is rendered in its overlay when
    opened.
  prefs: []
  type: TYPE_NORMAL
- en: To display a `MapInfoWindow` component, call its `open` method, which optionally
    accepts `MapMarker` that the info window will be attached to. The `close` method
    hides the `MapInfoWindow` component.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the API reference for more details on the `InfoWindow` class (https://developers.google.com/maps/documentation/javascript/reference/info-window).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an overview of the most used parts of the official Google
    Maps Angular components, you are prepared to use Google Maps in the Angular application
    in *Part 2, Build a Real-World Application with the Angular Ivy Features You Learned*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about the Angular CDK's Clipboard API.
  prefs: []
  type: TYPE_NORMAL
- en: The Clipboard API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular CDK's Clipboard API offers a directive and a service to interact
    with the operating system's clipboard through the browser. The `CdkCopyToClipboard`
    directive can be used declaratively while the `Clipboard` service is used for
    use cases where a programmatic API is a better fit. The Clipboard API additionally
    takes care of long texts through the `PendingCopy` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to use each of these classes from the Angular
    CDK package.
  prefs: []
  type: TYPE_NORMAL
- en: The CdkCopyToClipboard directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CdkCopyToClipboard` directive is exported by `ClipboardModule`, which is
    in the `@angular/cdk/clipboard` sub-package. Its directive selector is `[cdkCopyToClipboard]`.
    The directive has an input property of the same name as the directive, which accepts
    the text that is copied when the element it is attached to is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Because of browser security concerns, copying text to the clipboard must be
    done following a click event triggered by a user.
  prefs: []
  type: TYPE_NORMAL
- en: The copy to clipboard directive additionally has an input property named `cdkCopyToClipboardAttempts`.
    It accepts a number, which is the number of macrotask cycles the directive will
    attempt to copy the text for before giving up. This is relevant in the case of
    bigger text because of an implementation detail that ensures cross-browser compatibility
    until the upcoming Clipboard API is supported across all major browsers. We will
    discuss this caveat further when exploring the `PendingCopy` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy to clipboard directive and its retry parameter is demonstrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `CdkCopyToClipboard` directive has an output property named `cdkCopyToClipboardCopied`,
    which emits a Boolean value every time copying to the clipboard is attempted and
    indicates whether copying succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: The Clipboard service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Clipboard` service is useful when we want to perform other operations before
    or after copying text to the clipboard, if the text is not easily accessible from
    a component template, or if we want more fine-grained control when copying big
    texts.
  prefs: []
  type: TYPE_NORMAL
- en: The clipboard service has two methods. The `Clipboard#copy` method accepts the
    text to copy to the clipboard and returns a Boolean value indicating whether the
    copy operation was successful.
  prefs: []
  type: TYPE_NORMAL
- en: For some large texts, the `Clipboard#copy` method fails and we have to use the
    `Clipboard#beginCopy` method instead. This method also accepts the text that we
    want to copy to the clipboard but returns an instance of the `PendingCopy` class
    that we must interact further with to follow through on the copy to clipboard
    operation. This class is discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: The PendingCopy class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instance of the `PendingCopy` class is returned from the `Clipboard#beginCopy`
    method. As mentioned earlier in this section, this has to do with implementation
    details ensuring cross-browser compatibility for copying large texts.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we must learn about the `PendingCopy` class is that we must
    tear down all instances by calling the `PendingCopy#destroy` method once we have
    finished using them or our application will leak resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `PendingCopy#copy` method accepts no arguments and returns a Boolean value
    indicating whether the copy to clipboard operation succeeded. If `false` is returned,
    we should schedule another attempt for later.
  prefs: []
  type: TYPE_NORMAL
- en: As described earlier in this section, the `CdkCopyToClipboard` directive supports
    a retry strategy for copying large texts by passing a maximum number of attempts
    to its `cdkCopyToClipboardAttempts` input property.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed all parts of the Angular CDK's Clipboard API, we
    are ready to implement a feature for the hands-on application in *Part 2, Build
    a Real-World Application with the Angular Ivy Features You Learned.*
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about component testing harnesses, an innovative
    API for testing components, and authoring testing APIs for components exposed
    in library packages.
  prefs: []
  type: TYPE_NORMAL
- en: Testing as a user with component harnesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular CDK's API for authoring and using component testing harnesses is
    a fresh approach with the test-as-a-user philosophy in mind. Each component or
    related set of components can have a component harness for tests. A component
    harness is a testing API for interacting with those components that can be used
    in unit, integration, and end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: Component testing harnesses internally rely only on a single selector for the
    component they wrap. Library authors can publish component harnesses for their
    Angular components. In this way, their consumers' tests, which depend on the library's
    components, will not have dependencies on the DOM structure except for that one
    selector, which the library authors are able to change if needed.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what the Angular Components team do for Angular CDK and Angular
    Material. They release and maintain component harnesses for all their Angular
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Harness environments and harness loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A harness environment represents the context tests using component harnesses
    are run in. For unit and integration tests using test runners such as Karma, Jasmine,
    or Jest, we use `TestbedHarnessEnvironment`, which is bundled with the Angular
    CDK. For Protractor end-to-end tests, we use `ProtractorHarnessEnvironment`, which
    is also released as part of the Angular CDK.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Protractor support is either deprecated or removed, depending on your Angular
    version.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use component harnesses with other end-to-end testing frameworks,
    you will have to extend the `HarnessEnvironment` base class and implement the
    `TestElement` interface to work in a different testing environment. Of course,
    first make sure to look for existing solutions in the Angular ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Only one harness environment can be active at any time. We use the harness environment
    to create a harness loader. A harness loader has the context of a certain DOM
    element and is used to query for and create component harnesses based on selectors.
  prefs: []
  type: TYPE_NORMAL
- en: We will walk through simple code examples featuring harness environments and
    harness loaders after discussing the API of component harnesses that are distributed
    as part of Angular Material.
  prefs: []
  type: TYPE_NORMAL
- en: Component harnesses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A component harness can technically represent any DOM element and a set of user
    interactions and traits.
  prefs: []
  type: TYPE_NORMAL
- en: To get the feel for a component harness, let's first look at the testing harness
    for the Angular Material Button component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the API of `MatButtonHarness`, which is not inherited from
    the common component harness base classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blur(): Promise<void>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`click(relativeX: number, relativeY: number): Promise<void>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`click(''center''): Promise<void>;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`click(): Promise<void>;`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`focus(): Promise<void>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getText(): Promise<string>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isDisabled(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFocused(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a few other methods that it inherits from an Angular CDK base class,
    but we will not discuss those for now.
  prefs: []
  type: TYPE_NORMAL
- en: I trust that you can guess what the methods do, based on their names, parameters,
    and return values. Notice that they are all asynchronous, that is, they all return
    a `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: Every method except `getText` represents a user interaction. The `getText` method
    reads content from the DOM, which is displayed to the user, the text of the button
    to be precise.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's explore the API of the testing harness for the Angular Material
    Select component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the API that is specific to `MatSelectHarness`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blur(): Promise<void>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clickOptions(filter?: OptionFilters): Promise<void>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick the drop-down option(s) matching the specified filter. For multi-option
    selects, multiple options can be picked. For single-option selects, the first
    matching option is picked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`close(): Promise<void>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closes the drop-down panel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`focus(): Promise<void>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getOptionGroups(filter?: OptionGroupFilters): Promise<OptionGroup[]>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read drop-down option groups matching the specified filter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getOptions(filter?: OptionFilters): Promise<Option[]>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read drop-down options matching the specified filter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getValueText(): Promise<string>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the value of the chosen drop-down option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`isDisabled(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolves `false` if no value has been picked. Resolves `true` if a value has
    been picked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`isFocused(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isMultiple(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolves `true` if the harness wraps a multi-option select component. Resolves
    `false` if it wraps a single-option select component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`isOpen(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isRequired(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isValid(): Promise<boolean>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open(): Promise<void>;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods correspond to our expectations about the behavior and information
    represented by a drop-down picker such as the Angular Material **Select** component.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the most important concepts of a component harness
    and seen a few component harness APIs, it is time to look at a test case that
    combines these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a test for an online clothing store. You will
    have to imagine the implementation of the `ShirtComponent` and collaborating services.
    In fact, this is what the test-as-a-user approach is all about. It is component-
    and implementation-agnostic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the necessary Angular packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we import the `ShirtComponent` component, the collaborating `OrderService`,
    and the `OrderSpyService` class to replace it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we can implement test cases, we configure the Angular testing module
    by setting up the necessary declarables and replacing `OrderService` with a spy
    service for testing purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the component fixture from the previous step to create a harness loader
    for unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we store the order spy service in the shared `orderSpy` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we load the component harness for the shirt size picker, which is implemented
    using an Angular Material Select component as seen in this step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this test case, we also have to load a component harness for the **purchase**
    button, which is implemented using the Angular Material Button component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we perform a sale as the user by picking a `Large` shirt and clicking
    the **purchase** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we assert that the order service spy has been called as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that the test is relatively straightforward because of it using Angular
    Material's component harnesses. First, the *large* shirt size is picked, then
    the one-click **purchase** button is clicked, and we expect our order service
    spy to have been called with an order.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we start out by configuring the Angular testing module as usual in
    a component test. After creating the component fixture, we use it to create a
    harness loader. The harness loader is then used to query for component harnesses
    for Angular Material Select and Button components. A filter is passed to make
    sure we interact with the correct button.
  prefs: []
  type: TYPE_NORMAL
- en: We use the component harnesses instead of interacting with component instances
    or passing selectors to DOM queries. Our test is decoupled from structural DOM
    changes and implementation details of Angular Material's components.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the most important concepts of component harnesses,
    you are ready to implement your own and use them to test as a user in *Part 2,
    Build a Real-World Application with the Angular Ivy Features You Learned*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the APIs of the Angular YouTube Player, the
    Google Maps Angular components, the Angular CDK's Clipboard API, as well as the
    Angular CDK's component harnesses and how they are used by Angular Material, which
    we in turn can use in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: The YouTube Player component is an Angular-specific wrapper around the embedded
    YouTube Player. We learned how to initialize it and explored its API in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Many official Angular component wrappers are available to create and interact
    with the rich API of Google Maps. We learned about the `GoogleMap`, `MapMarker`,
    `MapMarkerClusterer`, and `MapInfoWindow` components, which are used for common
    **Geographic Information System** (**GIS**) use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular CDK's Clipboard API is a cross-browser and cross-platform compatible
    API for interacting with the native clipboard. We learned about the `CdkCopyToClipboard`
    directive, the `Clipboard` service, and the `PendingCopy` class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed the main concepts of Angular component harnesses introduced
    by the Angular CDK. We saw examples of component harness APIs exposed by Angular
    Material and how we can use them to test our own components without relying on
    implementation details or DOM structures, which might change in a future version
    of the package.
  prefs: []
  type: TYPE_NORMAL
- en: With all these exciting new features and APIs fresh in our minds, let's move
    on to *Part 2, Build a Real-World Application with the Angular Ivy Features You
    Learned*, in which we add new functionality to an existing Angular application.
    Surely, this knowledge will come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B16295_05_ePub_RK.xhtml#_idTextAnchor075), *Using CSS Custom
    Properties,* starts off *Part 2, Build a Real-World Application with the Angular
    Ivy Features You Learned* by combining CSS Custom Properties and Angular to add
    a theme picker to the Angular Academy application.'
  prefs: []
  type: TYPE_NORMAL
