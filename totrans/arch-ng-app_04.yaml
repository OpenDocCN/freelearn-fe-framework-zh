- en: Functional Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Wikipedia, **Functional Reactive Programming** (**FRP**) is a
    programming paradigm for reactive programming, which uses the building blocks
    of functional programming. OK, that sounds fancy, but what does it mean? To understand
    the whole sentence we need to break it apart a bit. Let''s try to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **programming paradigm** is an overarching theory, or way of working, centered
    around how a program should be organized and structured. Object-oriented programming
    and functional programming are examples of programming paradigms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive programming**, in short, is programming with asynchronous data streams.
    Asynchronous data streams are streams of data whose values can arrive at any point
    in time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional programming** is a programming paradigm that takes a more mathematical
    approach, in that it sees a functional call as a mathematical computation and
    thereby avoids changing states or dealing with mutable data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in short, our Wikipedia definition means we have a functional programming
    approach to values that might arrive at any point in time. That doesn't really
    mean much, but hopefully things will have been cleared up a bit by the end of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: The differences between declarative and imperative programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous data streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these streams can be manipulated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming versus imperative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will discuss and describe two different styles of programming, imperative
    programming and declarative programming. Functional programming is a subset of
    declarative programming. The easiest way to explain what declarative programming
    is to compare it to its opposite, imperative programming. Imperative programming
    focuses on *how* the program should achieve its result. Functional programming,
    on the other hand, is a declarative programming paradigm, which means its focus
    is on what the programming should accomplish, or the what. This is an important
    distinction.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative programming versus declarative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imperative programming is made up of statements that help change the program''s
    state. As mentioned before, it focuses on the *how* rather than the *what*. Let''s
    have a look at what this can look like in code to make it more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has the following effect: the variable `sum` is updated
    when we call `updateSum()`. We can also see that the function is very explicit
    about *how* the summation should happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarative programming is more focused on *what* to achieve. It''s easy to
    think of this as being more high-level, because you say *what* you want to achieve.
    Let''s look at some SQL code. SQL is a declarative programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are querying a table for a number of records while telling SQL what
    we want to summarize. We are clearly carrying out the same type of action, which
    is to summarize something. The difference is that with our declarative example
    we tell SQL what we want done; we trust SQL to know to summarize.
  prefs: []
  type: TYPE_NORMAL
- en: First-class higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term first class means that the language itself treats functions as values;
    they can be passed around as example arguments to other functions. A higher-order
    function is a function that takes other functions as parameters. Let''s look at
    an example to make this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see that the second argument in our `project()` function is a function.
    The function is being applied to the first argument. We can also see that, depending
    on what input argument we give the higher-order function as its second argument,
    the higher-order function will behave differently.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pure function is a function that does not have a side-effect. Nothing the
    function does will ever affect a variable outside of it. This means that the input
    argument, when used in a computation, should not cause a side-effect, such as
    talking to the filesystem or opening a network connection, for example. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, our function opens up a file, loops through its rows, and calculates
    a sum of all the row contents. Unfortunately, the function talks to the filesystem,
    which is considered a side-effect. It may look a little bit contrived, but in
    a longer function it is not an impossibility to see both calculations—logging
    and talking to a database—take place, or so has been my experience. Such code
    is far from ideal, and suffers from separation of concerns and a whole lot of
    other issues. When it comes to pure functions though, it is a good idea to isolate
    the pure parts into their own functions, which would result in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we now have two functions. We managed to isolate the pure parts
    into a function called `calculateSum()` and we ended up creating the `getRows()`
    function, which performs side-effects. Most programs have side-effects in some
    form, but your job as a programmer is to keep those functions away from pure functions
    as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In reality, we have described two things here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pure functions**: They are more like mathematical computations that do not
    have side-effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single responsibility principle** (**SRP**): Part of doing functional programming
    well is writing small and focused functions. Even though this is not a strict
    property of functional programming or pure functions, it is an important principle
    that will help you have the right mindset while adopting the functional programming
    lifestyle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing we didn't mention was why pure functions play an integral role in
    functional programming. They are predictable through their computational nature,
    which makes them easy to test. Building a system that mostly consists of many
    small predictable functions makes the whole system predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"To understand the word recursion see the word recursion."'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a standing joke at most engineering schools and it explains what it
    is in a very short way. Recursion is a mathematical concept. Let''s explain it
    a bit more. The official definition says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is the process a procedure goes through when one of the steps of the
    procedure involves invoking the procedure itself. A procedure that goes through
    recursion is said to be 'recursive'.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, what does that mean in human speak? It says that at some point in running
    our function, we will call ourselves. This means we have a function that looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the function `something()` at some point in its body calls
    itself. A recursive function should abide to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Should call itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should eventually meet an exit condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a recursive function doesn''t have an exit condition, we will run out of
    memory as the function will call itself for all eternity. There are certain types
    of problems that are more suitable than others to apply recursive programming
    to. Examples of these are:'
  prefs: []
  type: TYPE_NORMAL
- en: Traversing trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing algorithms for compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many more examples, but it''s important to remember that, although
    it''s a great tool, it shouldn''t be used everywhere. Let''s look at an example
    where recursion really shines. Our example is a linked list. A linked list consists
    of nodes that know about the node they are connected to. The code for the `Node`
    structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using such a structure as a `Node`, we can construct a linked list consisting
    of several linked nodes. We can connect a set of node instances in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A graphical representation of the preceding code would be the following diagram.
    Here, we can clearly see what our nodes consist of and how they are connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f74ea5ae-b028-4afc-af5d-66e95e2bb579.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have a linked list where we have three connected node instances. The
    head node is not connected to the node to the left. The second node however is
    connected to the first node and the first node is connected to the head node.
    The following type of operations on a list might be interesting to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the head node, given any node in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert a node at a given point in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a node from a given point in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at how we can solve the first bullet point. Firstly, we
    will use an imperative approach and thereafter we will use a recursive approach
    to see how they differ. More importantly, let''s discuss why the recursive approach
    might be preferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see here, we are using a `while` loop to traverse through the list
    until we find the node instance whose `left` property is null. Now, let''s show
    the recursive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we check whether `startNode.left` is null. If that is
    the case, we have reached our exit condition. If we haven't reached the exit condition
    yet, we keep on calling ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, so we have an imperative approach and a recursive approach. Why is the
    latter so much better? Well, with the recursive approach, we start off with a
    long list and we make the list shorter every time we call ourselves: a bit of
    a *divide and conquer* approach. One thing that clearly stands out with the recursive
    approach is that we defer execution by saying, no, our exit condition isn''t met
    yet, keep processing. Keep processing means we call ourselves as we do in our
    `if` clause. Is the point of recursive programming that we get fewer lines of
    code? Well, that could be the result, but more importantly: it changes our mindset
    toward how we go about solving problems. In imperative programming, we have a
    *let''s solve the problem from top to bottom mindset*, whereas in recursive programming,
    our mindset is more, define when we are done and slice down the problem to make
    it easier to deal with. In the preceding case, we discarded the part of our linked
    list that wasn''t interesting anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: No more loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the more significant changes when starting to code in a more functional
    way is that we get rid of `for` loops. Now that we know about recursion, we can
    just use that instead. Let''s have look at a simple imperative piece of code that
    prints an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding code using recursion looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our imperative code is still there in spirit. We still start
    at `0`. Moreover, we keep going until we come to the last position of our array.
    Once we hit our break condition, we exit the method.
  prefs: []
  type: TYPE_NORMAL
- en: Reoccurring pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We haven''t really sold recursion as a concept at this point. We kind of get
    it, but are probably not convinced why good old `while` or `for` loops can''t
    be used in its place. Recursion shines when it solves problems that look like
    a reoccurring pattern. An example of that is a tree. A tree has some similar concepts
    to it such as consisting of nodes. A node without children connected to it is
    called a leaf. A node with children but that has no connection to an upward node
    is called a root node. Let''s illustrate this with a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a027455b-81fd-4284-aebc-7615a806fde3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few interesting operations that we would want to carry out on a
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: Summarise the node values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Count the number of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To attempt to solve that, we need to think about how to store a tree as a data
    structure. The most common way of modeling it is by creating a representation
    of a node as having a value, and a `left` property and a `right` property, then
    both those properties point to nodes in turn. Therefore, the code for said Node
    class might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is thinking how to create the tree itself. This code shows how
    we can create a tree with a root node and two children, and how to bind these
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Worth highlighting is how the instances `left` and `right` do not have children.
    We can see that because we set their values to `null` on creation. Our root node,
    on the other hand, has the object instances `left` and `right` as children.
  prefs: []
  type: TYPE_NORMAL
- en: Summarise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thereafter, we need to think about how to summarise the nodes. Just looking
    at it, it looks like we should summarise the top node and its two children. So,
    a code implementation would start off like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if our tree grows and suddenly looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b191666-4c04-4430-92cd-1ce1cffaf73a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add to the preceding code so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is technically working code, but it can be improved. What we should see
    at this point, looking at the tree, are reoccurring patterns in the tree. We have
    the following triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4987cb37-bffd-4ea5-ac9a-70ceadf7a6ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One triangle is made up of **2,** **3**, **5**, another one is made up of **3**,
    **1**, **2**, and the last one is made up of **5**, **4**, **2**. Every triangle
    computes its sum by taking the node itself, plus its left child and its right
    child. Recursion is all about this: discovering a reoccurring pattern and codifying
    it. We can now implement our `summarise()` function with recursion, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is expressing our reoccurring pattern as *node + left
    node + right node*. When we call `summarise(node.left)` we simply run through
    `summarise()` again for that node. The preceding implementation is short and elegant,
    and is able to traverse the entire tree. Recursion is truly elegant once you find
    that your problem can be seen as a repeating pattern. The full code looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a function that counts all the nodes in the trees is quite trivial
    now that we are beginning to grasp the nature of recursion. We can reuse our summary
    function from before and simply count every non-null node as `1` and null as `0`.
    So, we simply take the existing summary function and modify it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code ensures we traverse each and every node successfully. Our
    exit condition happens when we reach null. That is, we are trying to go from a
    node to one of its non-existing children.
  prefs: []
  type: TYPE_NORMAL
- en: Width
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a width function, we first need to define what we mean by width.
    Let''s have a look at our tree again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f8a6fa-05a3-44c1-8cd6-4266c283f05d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This tree has a width of **4**. How is that? For every step down in the tree,
    our nodes expand one step to the left and one step to the right. This means that
    to calculate the width correctly, we need to traverse the edges of our tree. Every
    time we have to traverse a node to the left or to the right, we increment the
    width. What we are interested in doing from a calculation standpoint is to traverse
    the tree like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c0353df-bcff-4eb2-a7de-28fa7acd39fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code should therefore reflect this fact. We can implement this like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note especially how, in the `calcWidth()` function, we call `calc()` with `node.left`
    and `node.right`, respectively, as arguments. We also add a `left` and `right`
    argument which, in the method `calc()`, means that we will keep going in that
    direction. Our exit condition is when we eventually hit null.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous data streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An asynchronous data stream is a stream of data where values are emitted, one
    after another, with a delay between them. The word asynchronous means that the
    data emitted can appear anywhere in time, after one second or even after two minutes,
    for example. A way to model asynchronous streams is to place the emitted values
    on a time axis, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0ae8d59-f244-4005-bddf-967f0d6b328b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a lot of things that can be considered asynchronous. One such thing
    is fetching data through AJAX. When the data arrives depends on a number of factors,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The speed of your connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The responsiveness of the backend API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the data, and many more factors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The point is the data isn't arriving right at this very second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other things that can be considered asynchronous are user initiated events,
    such as scrolling or mouse clicks. These are events that can happen at any point
    in time, depending on the user''s interaction. As such, we can consider these
    UI events as a continuous stream of data on a time axis. The following diagram
    depicts a stream of data representing a user clicking several times. Each click
    leads to a click event, **c**, which we place on a time axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f09aaa3a-001b-4a51-8eeb-e7232beed9fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At first glance, our diagram depicts four click events. Taking a closer look,
    we see that the click events seem grouped. The preceding diagram contains two
    pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: That a number of click events have occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the click events have occurred with a certain delay in between events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we can see that the two first clicks seem to happen very close together
    in time; when two events happen very close in time, this will be interpreted as
    a double-click. Therefore, our image above thus tells us about the events that
    occurred; it also tells us when and how often they occurred. Looking at the previous
    diagram, it is quite easy to distinguish between a single-click and a double-click.
  prefs: []
  type: TYPE_NORMAL
- en: We can assign different actions to each click behavior. A double-click might
    mean that we want to zoom-in, whereas a single-click might mean we want to select
    something; exactly what is up to the application you are writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third example is that of input. What if we have a situation where the user
    is typing and stops typing after a while? After a certain amount of time has passed,
    the user expects the UI to react. This is the case with a search field. In that
    case, the user might enter something in a search field and press a search button
    when done. Another way to model that situation in a UI is to just provide a search
    field and wait for the user to stop typing as a sign of when to start searching
    for what the user wants. The final example is known as **autocomplete** behavior.
    It can be modeled in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e367157-1c65-4371-aebe-77f6912e6bb7.png)'
  prefs: []
  type: TYPE_IMG
- en: The first three characters entered seem to belong to the same search query,
    whereas the fourth character entered occurs a lot later and probably belongs to
    another query.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this section has been to highlight that different things lend themselves
    to being modeled as streams, and that the time axis and the placement of the emitted
    values on it can come to mean something.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing lists to async streams – preparing for RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed so far how we can model asynchronous events as a continuous
    stream of data on a time axis, or stream modeling. Events can be AJAX data, mouse
    clicks, or some other type of event. Modeling things this way makes for an interesting
    perspective on things but, looking at a double-click situation for example, doesn't
    mean much unless we are able to dig out the data. There might be another case
    where there is data that we need to filter out. What we are discussing here is
    how to manipulate streams. Without that ability, stream modeling itself has no
    practical value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to manipulate data: sometimes we want to change the
    data emitted to some other data and sometimes we might want to change how often
    the data is being emitted to a listener. Sometimes, we want our stream of data
    to become a totally different stream. We will try to model the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Projection**: Changing the data of the value being emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering**: Changing what gets emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining the functional programming paradigm with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered functional programming and asynchronous data streams.
    Working with RxJS doesn't require a deep understanding of functional programming,
    but you do need to understand what declarative means, in order to focus on the
    right things. Your focus should be on what you want done, not how you want it
    done. RxJS, as a library, will take care of the how. More on that in the upcoming
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: These might seem like two different topics. Combining the two, however, gives
    us the ability to manipulate streams. A stream can be seen as a list of data,
    where the data is available at a certain point in time. If we start treating our
    streams as lists, especially immutable lists, then there are operations that go
    with lists that manipulate lists by applying operators to them. The result of
    the manipulation is a new list, not a mutated list. So let's start applying our
    list philosophy and its operators to the following situations.
  prefs: []
  type: TYPE_NORMAL
- en: Projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](img/822b07eb-50f1-455e-981a-1dfa7b7481e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that our stream is emitting the values **1**, **2**, **3**,
    and **4**, and then a manipulation happens that changes every value by incrementing
    it by one. This is quite a simple situation. If we consider this as a list, we
    can see that what we do here is simply a projection, which we would code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There might be some items in a list, as well as in a stream, that you do not
    want. What you do to fix that is to create a filter that filters out the unwanted
    data. Modeling our initial array, the manipulation, and the resulting array, we
    get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ffa7b44-4784-472e-befd-585c97e2da97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In JavaScript, we can accomplish this by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Combining mindsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what are we trying to say with this section. Clearly, we have shown examples
    of how to manipulate lists. Well, what we have done is shown how we can display
    items on an axis. In that sense, we can see how it is easy to think of asynchronous
    events and lists of values in the same way, as we are graphically picturing them
    in the same way. The question is, why do we want to do that? The reason is that
    this is the mindset the RxJS library wants you to have when you start manipulating
    and crafting streams in the upcoming chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has established that we can model asynchronous events as values
    on a time axis. We introduced the idea of comparing these streams to lists and
    thereby applying functional methods to them that would not change the lists themselves
    but merely create a new list. The benefit of applying the functional paradigm
    is that we can focus on *what* to achieve rather than *how* to achieve it, thereby
    having a declarative approach. We realize it''s not easy to combine async and
    lists and create readable code from it. Fortunately, this is what the RxJS library
    does for us. It is this realization that prepares us for the coming chapter, [Chapter
    5](84bb33e0-d186-4abe-9b3f-10ba1ae911c8.xhtml), *RxJS Basics*, where we introduce
    RxJS as a library just that: create order in the async mess while modeling everything
    as a stream. With RxJS, we can truly focus on *what* rather than *how,* as it
    comes with a bunch of stream manipulation functions. After having read the next
    chapter, you will understand how RxJS works on a fundamental level, but also how
    it addresses the problems mentioned in this chapter.'
  prefs: []
  type: TYPE_NORMAL
