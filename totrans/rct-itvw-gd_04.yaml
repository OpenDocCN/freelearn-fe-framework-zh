- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Routing and Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating the vast world of software development doesn’t come without its difficulties.
    Our trip frequently necessitates expertly navigating various screens and language
    settings to ensure an excellent user experience. This chapter delves into the
    ideas of routing and internationalization, as well as the virtual environment
    and horizon of any modern React application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will take us on an in-depth investigation of screen navigation
    and introduce us to React Router. It is the most important tool in web application
    navigation since it refreshes the browser URL as users go across your application
    without refreshing the page. We’ll go over the many types of routes, such as basic
    and nested routes, learn how to add routes to our application, and even dive into
    the world of accessing URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: But our adventure does not end there. As we migrate into the realm of internationalization
    and localization, we will advance beyond the functional difficulties and chart
    our way throughout the globe. These aspects of development demonstrate our dedication
    to diversity, ensuring that our application speaks the language of its users,
    no matter where they are from.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll present a detailed approach for adding translations and formatted messages
    to our program, increasing its accessibility to a global audience. We’ll also
    learn how to utilize placeholders and give parameters to these messages, allowing
    for dynamic translations. Consider this chapter to be your roadmap to a more user-friendly
    and worldwide application. We will utilize this knowledge to guide us through
    the realm of software development, avoiding any stumbling blocks and delivering
    a flawless user experience. Prepare to go on this fascinating adventure in the
    next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming sections, we will cover the following topics as we aim to understand
    how to handle routing and how internationalization works:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating screens and an introduction to React Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes, types of routes, and links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing URL parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing internationalization and localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding translations and formatted messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments and placeholders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please ensure that you have the JavaScript build tool **Vite.js** set up and
    installed on your machine. You can find it here: [https://vitejs.dev/](https://vitejs.dev/).
    We will be using it for our upcoming React project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, familiarize yourself with the React Router library: [https://reactrouter.com/en/main](https://reactrouter.com/en/main).'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to begin. The next section will introduce us to React Router.
    Let’s go for it!
  prefs: []
  type: TYPE_NORMAL
- en: Navigating screens and an introduction to React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding navigation and the React Router library is critical for any coder.
    In this section, we will go through the fundamentals of traversing screens with
    React Router and why it is crucial. The aim of this section is to provide an overview
    of React Router along with simple descriptions of how navigation works via various
    web apps without becoming unduly technical. We are going to close the gap between
    what employers expect and your existing skill level in this part by offering useful
    recommendations on enhancing workflow efficiency while utilizing React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore why we should be using the React Router library in the first
    place and what it can help us with. It’s worth mentioning that Next.js already
    has the functionality for routing built in, but this is still knowledge worth
    learning. This is because routing is different in other React frameworks and the
    core principles of how it works are still valid and can be used anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the React Router library?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating routing logic can prove time-consuming and difficult, which is where
    React Router comes in handy. Because of the library’s extensive functionality,
    it can greatly ease our routing challenges. React Router is an open source web
    application routing module that allows you to move between different pages and
    components. It provides an easy-to-use interface for implementing dynamic routing
    in your web project. It supports numerous URLs and gives you complete control
    over your application’s routing, resulting in a seamless and engaging user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the purpose of using this library, we are going to learn
    how navigation works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How does navigating between screens work in React Router?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigating between screens can seem daunting at first, but using React Router
    makes it considerably easier and more practical. With React Router, you can efficiently
    manage all of your routes within your app, making it a breeze to switch between
    different screens. Plus, it allows you to keep your UI in sync with the URL. So,
    even if you’re not an expert, React Router means you can easily add the functionality
    you need to get your app running smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side routing is enabled by React Router, and this is basically how routing
    is initiated. Essentially, the computer’s browser requests a page from a website’s
    server, which gets and determines the CSS and JavaScript files, and renders the
    HTML supplied from the server itself on a website. When a user clicks a link on
    the website, the process is restarted for a brand-new page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next.js already has a routing solution built in, so we will use another popular
    JavaScript build tool, Vite.js, to see the code in this chapter. Here is the link
    for the tool: [https://vitejs.dev/](https://vitejs.dev/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to construct a `BrowserRouter` component and configure the
    primary route. This enables client-side routing for our web application. Our `main.jsx`
    file serves as the starting point, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code defines our initial route. So, in this case, it would be our root
    route. The root route is known as the first page that loads and is displayed on
    a website – commonly known as our home page.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into the next section, let’s get a quick look at `BrowserRouter`
    and some of the subtopics surrounding it. Firstly, `BrowserRouter` is a router
    solution that keeps your UI in sync with the URL by using the HTML5 History API.
    This API utilizes events such as `popstate`, `replacestate`, and `pushstate`.
    We can use `BrowserRouter` to store the current location in the address bar using
    clean URLs and history. We can also use it to track changes in the URL in the
    cases of iframes.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Router has many features that you can find in its documentation. Here’s
    an overview of what’s on offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Routers | Although your apps will only utilize one router, several of them
    can be accessed, depending on the setting it is operating in. Some of the ones
    that are included are `createBrowserRouter`, `createMemoryRouter`, `createHashRouter`,
    and `createStaticRouter`. |'
  prefs: []
  type: TYPE_TB
- en: '| Router components | The type of router component you will use for page routing
    in your app. |'
  prefs: []
  type: TYPE_TB
- en: '| Route | The methods that will be used for creating and managing routes. These
    can include actions, lazy loading, and loaders. |'
  prefs: []
  type: TYPE_TB
- en: '| Components | With this feature, we can use custom-made components to manage
    our data. For example, we can use the `Form` component, which emulates the browser
    for client-side routing and data mutations, or the `Await` component for automatic
    error handling. There’s also the important `Link` component for navigating to
    other pages. These are a few of the ones available to us. |'
  prefs: []
  type: TYPE_TB
- en: '| Hooks | These custom Hooks work just like any React Hook and give us new
    functionality. `useNavigation`, `useSearchParams`, `useOutlet`, and `useLocation`
    are all Hooks that have different purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| Fetch utilities | These are used for managing the data we receive from APIs.
    We can get the data and perform redirects. |'
  prefs: []
  type: TYPE_TB
- en: '| Utilities | We can use utilities to perform different actions. For example,
    `matchPath` can be used to match a route path pattern and compare it to a URL
    path name, and the information about the match is returned. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: React Router features'
  prefs: []
  type: TYPE_NORMAL
- en: 'This covers most of the main features of React Router. To learn more, read
    the official documentation: [https://reactrouter.com/en/main](https://reactrouter.com/en/main).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take this further and learn more about routing
    and links.
  prefs: []
  type: TYPE_NORMAL
- en: Routes, types of routes, and links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routes are the most critical components of a React Router app. They link URL
    segments to components, as well as perform data loading and data modifications.
    Sophisticated project layouts, as well as information dependencies, become straightforward
    thanks to route nesting and the process becomes easier because routes are objects
    that are provided to router construction operations.
  prefs: []
  type: TYPE_NORMAL
- en: What types of routes can we use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Router gives us access to various forms of routing. The following table
    explains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Route Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | The path pattern will be compared to the URL to see whether this
    route matches a URL, link href, or form action. |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | This determines whether or not the route is an index route. Index
    routes, such as default child routes, render into their parent’s `Outlet` at their
    parent’s URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `children` | Nested routes allow you to render many components on a single
    page while maintaining route integrity. |'
  prefs: []
  type: TYPE_TB
- en: '| `caseSensitive` | This specifies whether the route should match the case
    or not. |'
  prefs: []
  type: TYPE_TB
- en: '| `loader` | Before the route renders, the route loader is invoked and gives
    data for the element through `useLoaderData`. |'
  prefs: []
  type: TYPE_TB
- en: '| `action` | When a submission is submitted to the route from a form, fetcher,
    or submission, the route action is called. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.2: Types of routes'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about some different route types, it’s time to learn
    the code for creating a route and a link.
  prefs: []
  type: TYPE_NORMAL
- en: How do you create a route and a link?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create routes by using React `Element` and React `Component`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical syntax for using `element` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to use `Component` instead, then the code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Links work slightly differently. Client-side routing enables our app to adjust
    the URL after a link click, rather than requesting another document from the server.
    Instead, the application can swiftly display a fresh UI and use `fetch` to execute
    data calls to update the content of the page with freshly obtained data. Since
    the web browser does not need to request a completely new page or revisit CSS
    and JavaScript content for the next page, this results in speedier loading times.
    It also allows for enhanced user interactions, such as scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows us how to use links for page navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code block shows us how to create a home page that has a link that navigates
    us to an about us page.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about routes and links, let’s learn how to add routes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routes can be rendered throughout our application if we use the `<Routes>` component,
    which matches up with other child routes in our files. Routing searches through
    all of its child routes to find the best match, and if the location changes, then
    it renders that branch of the UI. To represent a nested UI, which also corresponds
    to nested URL pathways, `<Route>` components can also be nested. By rendering
    `<Outlet>`, parent routes render their child routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates how to add routes to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, there are four routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"/"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"/``messages"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"/``actions"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"/``about"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The routes for messages and actions are nested routes under the main route,
    which is `"/"`. The `"/about"` route is a top-level route because it is separate
    and not nested like the previous two. The component inside the property element
    will load when the page is on its defined route. Routes can also be declared with
    JSX and `createRoutesFromElements`.
  prefs: []
  type: TYPE_NORMAL
- en: Those are the basics out of the way. Now, let’s move on to the next topic, which
    is accessing URL parameters. This is where we will learn how to navigate to a
    page that is determined by its ID. This gives us more customization options when
    we’re doing our `GET` requests, which is the next step after we have learned how
    to navigate to a page using basic routing.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing URL parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `useParams` Hook in React, which provides a key/value object
    of the dynamic parameters from the current URL that matches the specified route.
    All of the parameters are inherited by child routes from their parent routes.
    A working example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, with this routing configuration, the application can render various components
    according to the URL’s structure. Firstly, the page route of `users`/`userId`
    renders the `ProfilePage` component and provides the component with the `userId`
    portion as `userId`. The route for `users`/`me` is the one that renders the component
    that’s supplied in the element attribute.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, URL parameters are powerful and give us another level of customization
    for our routes. In the next section, we will take a look at nesting routes, which
    is the natural progression now that we have learned how to create basic routes.
    With nested routes, we will be able to have multiple components rendered on the
    same page.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In React Router, nesting routes were influenced by Ember.js’s routing mechanism
    in 2014\. The Ember.js team discovered that parts of the URL usually determine
    the method to render a page layout and how the data is connected with the layouts
    that are rendered. One method of creating a page with nested elements can be seen
    in our example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code block is for a user-authenticated login flow. If the user is logged
    in, then the admin page loads. There is also a login and logout route. Now, let’s
    look at dynamic routing, which is another useful feature.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing apps with several pages or views that have a basic structure
    but differ in information or behavior, dynamic routing becomes convenient. Dynamic
    routing, as opposed to establishing a predetermined number of routes in your application,
    allows you to construct routes on the spot based on the present state of the app
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what that looks like here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `:id` property in the route structure indicates a dynamic value that can
    vary depending on the input provided by the user. React Router grabs the `id`
    parameter from the URL and provides it to the `Profile` component when the URL
    fits this pattern. Next, we’ll look at error pages since it’s a situation we need
    to be aware of when a user encounters a page that is broken.
  prefs: []
  type: TYPE_NORMAL
- en: Error pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To address scenarios where users go to non-existent routes or face difficulties
    while traversing our application, we can create error pages or *not-found* pages
    in React Router. When anything goes wrong, this helps provide a better user experience
    by stopping users from encountering a blank page or an inconsistent layout.
  prefs: []
  type: TYPE_NORMAL
- en: The following code example shows how to create error pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we must create the necessary components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code creates two components - one for `404` error pages and the other for
    general error pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s set up the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a component that contains all of the page routes for our app.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve considered error pages and learned how to set up some routes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover internationalization and localization. Knowing how to tailor
    your application to different regions is important because we all live in different
    countries. So, let’s get right to it.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization and localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internationalization and localization are basic practices in software development
    that enable you to design and deploy systems that can be tailored to multiple
    languages and areas. Let’s learn the difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: What is internationalization?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internationalization is the process of creating and preparing your application
    so that it can potentially be used in several languages. This frequently entails
    extracting all of your application’s strings into distinct files that can potentially
    be translated into multiple languages. It also requires structuring your software
    to ensure that it can correctly manage and show these translations.
  prefs: []
  type: TYPE_NORMAL
- en: What is localization?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This involves translating your locally optimized application into specific native
    languages. Translating an application’s text is only one aspect of localization.
    It might also include other regionally unique elements, such as text direction,
    number forms, and date and time formats, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: React Router allows you to build localized routes. To manage language choice,
    you might, for instance, have several routes for various languages (such as `"/en/about`”
    and `"/fr/about"`) or you can utilize a context or state.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned so much already and our knowledge has increased a lot. Next,
    we will move on to the penultimate section of this chapter, where we are going
    to learn all about adding translations and formatted messages in our React applications.
    We just learned about internationalization and localization, which is where we
    prepare our applications for different languages. Now, let’s learn how to implement
    different languages in the code we write.
  prefs: []
  type: TYPE_NORMAL
- en: Adding translations and formatted messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of translating text content in your application from one language
    into another and doing it in a style that follows regional customs and standards
    is referred to as translations and formatted messages. We can make use of a library
    such as **FormatJS** to add translations and formatted messages to a React application.
    React Router does not allow translations or localization by default; however,
    it can easily be used in tandem with FormatJS (or a comparable package) to build
    an internationalized routing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a code example of what this could look like if we were to use
    the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the application has been set up for English and French translations.
    The default language is hardcoded to be French; however, in a real-world application,
    it can be generated dynamically, depending on what language user settings someone
    has set up in their browser. The `en` and `fr` language codes are mapped to the
    translation files that are imported by the `messages` object.
  prefs: []
  type: TYPE_NORMAL
- en: Translations and formatted messages – what are they exactly? We are about to
    find out. So, keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: What are translations?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This often refers to translating text from one language into another within
    your program. In software, we often keep many language files that contain the
    translated texts for each supported language (commonly in JSON or a similar format).
    This enables the app to show the appropriate language, depending on the user’s
    preferences or locale, dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: What are formatted messages?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many applications require dynamic material to be shown within translated strings
    in addition to straightforward translations. Formatted communications have a role
    in this. With formatted messages, you can manage pluralization rules, add variables
    to your translated strings, format dates and numbers using regional standards,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: We can develop apps that are readily adaptable to various languages and locations
    by combining translations with formatted messages, thus improving accessibility
    and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Our progress has been fantastic – there’s just one more section to go and we
    will have completed this chapter. The last section will be about passing arguments
    and placeholders. So far, we’ve learned how to add data to one page; however,
    in real-world applications, we have multiple routes within our single-page applications.
    So, in the next section, we will learn how to pass arguments and placeholders
    so that we can have dynamic routing in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments and placeholders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React and JavaScript in general, as well as React Router specifically, support
    passing placeholders and arguments. However, for dynamic routing and data transmission
    between routes, these work well when combined with React Router.
  prefs: []
  type: TYPE_NORMAL
- en: How do we pass arguments?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the use of several techniques, such as URL parameters, query parameters,
    or the state object of the history prop, we can send data to components that are
    displayed by React Router. Usually, this is done to convey precise data from one
    route to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows us the process of passing arguments when we are using the
    state object of the history prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The receiving component reveals how we can access the data that we passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we shall learn how to use placeholders (URL parameters).
  prefs: []
  type: TYPE_NORMAL
- en: How do we use placeholders?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: URL parameters, which are parts of the URL that can change depending on the
    content you would like to display but still render the same core component, are
    supported by React Router. These are regularly used to develop dynamic routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to create a route and utilize a URL parameter in
    a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `i``d` placeholder can depend on any value. When you go
    to `"/post/123"`, the `MyComponent` component renders, and `useParams()` returns
    an object with `{ id: "123"}` in it.'
  prefs: []
  type: TYPE_NORMAL
- en: Building dynamic and responsive apps using React Router requires both arguments
    and placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we come to the end of this chapter, it’s evident that the journey through
    the environment of routing and internationalization in React apps has been both
    difficult and gratifying. We examined, probed, and unraveled the complexity of
    several critical themes, each of which contributed to the development of comprehensive,
    interactive, and internationally accessible apps.
  prefs: []
  type: TYPE_NORMAL
- en: We started by learning about React Router, our trusty navigator for the displays
    in our applications. We looked into routes, learned about their many types, and
    learned how to use them effectively in our applications. Our investigation of
    obtaining URL parameters and layering routes has broadened our expertise, allowing
    us to design sophisticated and complex pathways inside our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we shifted our focus to internationalization and localization, widening
    our horizons to ensure people all around the world can interact with our application.
    We recognized the significance of breaking down language barriers and the enormous
    impact this can have on user experience. Learning how to add translations and
    formatted messages has given us the ability to connect with users in their native
    language, allowing our application to become a worldwide entity. We also uncovered
    the power of creating dynamic and responsive translations by learning how to use
    placeholders and pass arguments to messages.
  prefs: []
  type: TYPE_NORMAL
- en: These abilities help us become efficient developers who are capable of creating
    programs that are not only useful but also ubiquitous. This path has given us
    the tools we need to design and build online apps that are not only responsive
    and resilient but also global and inclusive. As we finish this chapter, think
    about what you’ve learned, but keep in mind that this is just one stop on your
    larger trip. Continue to explore, learn, and, most importantly, continue your
    growth and follow the path that resonates with you most.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about more advanced ReactJS concepts, such
    as error borders, portals, higher-order components, concurrent rendering, and
    forwarding refs. So, let’s get ready for another adventure as we increase our
    knowledge.
  prefs: []
  type: TYPE_NORMAL
