["```js\ntitle: {\n    type: String,\n    required: 'title is required'\n}\n```", "```js\n description: String,\n genre: String,\n```", "```js\nviews: {\n    type: Number, \n    default: 0\n},\n```", "```js\n\n postedBy: {\n    type: mongoose.Schema.ObjectId, \n    ref: 'User'\n },\n```", "```js\nupdated: Date,\ncreated: { \n    type: Date, \n    default: Date.now \n},\n```", "```js\nimport mongoose from 'mongoose'\nlet gridfs = null\nmongoose.connection.on('connected', () => {\n  gridfs = new mongoose.mongo.GridFSBucket(mongoose.connection.db)\n})\n```", "```js\nrouter.route('/api/media/new/:userId')\n        .post(authCtrl.requireSignin, mediaCtrl.create)\nrouter.param('userId', userCtrl.userByID)\n```", "```js\napp.use('/', mediaRoutes)\n```", "```js\nyarn add formidable\n```", "```js\nconst create = (req, res) => {\n  let form = new formidable.IncomingForm()\n  form.keepExtensions = true\n  form.parse(req, async (err, fields, files) => {\n      if (err) {\n        return res.status(400).json({\n          error: \"Video could not be uploaded\"\n        })\n      }\n      let media = new Media(fields)\n      media.postedBy= req.profile\n      if(files.video){\n        let writestream = gridfs.openUploadStream(media._id, {\n contentType: files.video.type || 'binary/octet-stream'})\n fs.createReadStream(files.video.path).pipe(writestream)\n      }\n      try {\n        let result = await media.save()\n        res.status(200).json(result)\n      }\n      catch (err){\n          return res.status(400).json({\n            error: errorHandler.getErrorMessage(err)\n          })\n      }\n    })\n}\n```", "```js\nconst create = async (params, credentials, media) => {\n  try {\n    let response = await fetch('/api/media/new/'+ params.userId, {\n    method: 'POST',\n    headers: {\n      'Accept': 'application/json',\n      'Authorization': 'Bearer ' + credentials.t\n    },\n    body: media\n  }) \n    return await response.json()\n  } catch(err) {\n    console.log(err)\n  }\n}\n```", "```js\n<input accept=\"video/*\" \n       onChange={handleChange('video')} \n       id=\"icon-button-file\" \n       type=\"file\"\n       style={{display: none}}/>\n<label htmlFor=\"icon-button-file\">\n    <Button color=\"secondary\" variant=\"contained\" component=\"span\">\n       Upload <FileUpload/>\n    </Button>\n</label> \n<span>{values.video ? values.video.name : ''}</span>\n\n```", "```js\n<TextField id=\"title\" label=\"Title\" value={values.title} \n           onChange={handleChange('title')} margin=\"normal\"/><br/>\n<TextField id=\"multiline-flexible\" label=\"Description\"\n           multiline rows=\"2\"\n           value={values.description}\n           onChange={handleChange('description')}/><br/>\n<TextField id=\"genre\" label=\"Genre\" value={values.genre} \n           onChange={handleChange('genre')}/><br/>\n```", "```js\nconst handleChange = name => event => {\n    const value = name === 'video'\n      ? event.target.files[0]\n      : event.target.value\n    setValues({ ...values, [name]: value })\n}\n```", "```js\n  const clickSubmit = () => {\n    let mediaData = new FormData()\n    values.title && mediaData.append('title', values.title)\n    values.video && mediaData.append('video', values.video)\n    values.description && mediaData.append('description',\n       values.description)\n    values.genre && mediaData.append('genre', values.genre)\n    create({\n      userId: jwt.user._id\n    }, {\n      t: jwt.token\n    }, mediaData).then((data) => {\n      if (data.error) {\n        setValues({...values, error: data.error})\n      } else {\n        setValues({...values, error: '', mediaId: data._id, \n           redirect: true})\n      }\n    })\n  }\n```", "```js\nif (values.redirect) {\n    return (<Redirect to={'/media/' + values.mediaId}/>)\n}\n```", "```js\n<PrivateRoute path=\"/media/new\" component={NewMedia}/>\n```", "```js\nrouter.route('/api/medias/video/:mediaId')\n        .get(mediaCtrl.video)\nrouter.param('mediaId', mediaCtrl.mediaByID)\n```", "```js\nconst mediaByID = async (req, res, next, id) => {\n  try{\n  let media = await Media.findById(id).populate('postedBy', \n      '_id name').exec()\n    if (!media)\n      return res.status('400').json({\n        error: \"Media not found\"\n      })\n      req.media = media\n     let files = await gridfs.find({filename:media._id}).toArray()\n if (!files[0]) {\n return res.status(404).send({\n error: 'No video found'\n })\n } \n req.file = files[0]\n        next()\n    }catch(err) {\n      return res.status(404).send({\n        error: 'Could not retrieve media file'\n      })\n    }\n}\n```", "```js\nconst video = (req, res) => {\n  const range = req.headers[\"range\"]  \n    if (range && typeof range === \"string\") {\n      ...\n      ... consider range headers and send only relevant chunks in response ...\n      ...\n  } else {\n      res.header('Content-Length', req.file.length)\n      res.header('Content-Type', req.file.contentType)\n\n      let downloadStream = gridfs.openDownloadStream(req.file._id)\n      downloadStream.pipe(res)\n      downloadStream.on('error', () => {\n        res.sendStatus(404)\n      })\n      downloadStream.on('end', () => {\n        res.end()\n      })\n   }\n}\n```", "```js\n    const parts = range.replace(/bytes=/, \"\").split(\"-\")\n    const partialstart = parts[0]\n    const partialend = parts[1]\n\n    const start = parseInt(partialstart, 10)\n    const end = partialend ? parseInt(partialend, 10) : req.file.length - 1\n    const chunksize = (end - start) + 1\n\n    res.writeHead(206, {\n        'Accept-Ranges': 'bytes',\n 'Content-Length': chunksize,\n 'Content-Range': 'bytes ' + start + '-' + end + '/' + req.file.length,\n 'Content-Type': req.file.contentType\n    })\n\n    let downloadStream = gridfs.openDownloadStream(req.file._id, {start, end: end+1})\n    downloadStream.pipe(res)\n    downloadStream.on('error', () => {\n      res.sendStatus(404)\n    })\n    downloadStream.on('end', () => {\n      res.end()\n    })\n```", "```js\nyarn add react-player \n```", "```js\n<ReactPlayer url={'/api/media/video/'+media._id} controls/>\n```", "```js\n<GridList cols={3}>\n    {props.media.map((tile, i) => (\n        <GridListTile key={i}>\n          <Link to={\"/media/\"+tile._id}>\n            <ReactPlayer url={'/api/media/video/'+tile._id} \n               width='100%' height='inherit' style=\n                 {{maxHeight:   '100%'}}/>\n          </Link>\n          <GridListTileBar title={<Link \n              to={\"/media/\"+tile._id}> {tile.title} </Link>}\n            subtitle={<span>\n                        <span>{tile.views} views</span>\n                        <span className={classes.tileGenre}>\n                        <em>{tile.genre}</em>\n                        </span>\n                    </span>}\n          />\n        </GridListTile>\n    ))}\n</GridList>\n```", "```js\n router.route('/api/media/popular')\n          .get(mediaCtrl.listPopular)\n```", "```js\nconst listPopular = async (req, res) => {\n  try{\n    let media = await Media.find({})\n    .populate('postedBy', '_id name')\n    .sort('-views')\n    .limit(9)\n    .exec()\n    res.json(media)\n  } catch(err){\n    return res.status(400).json({\n      error: errorHandler.getErrorMessage(err)\n    })\n  }\n}\n```", "```js\n  useEffect(() => {\n    const abortController = new AbortController()\n    const signal = abortController.signal\n    listPopular(signal).then((data) => {\n      if (data.error) {\n        console.log(data.error)\n      } else {\n        setMedia(data)\n      }\n    })\n    return function cleanup(){\n      abortController.abort()\n    }\n  }, [])\n```", "```js\n<MediaList media={media}/>\n```", "```js\nrouter.route('/api/media/by/:userId')\n         .get(mediaCtrl.listByUser) \n```", "```js\nconst listByUser = async (req, res) => {\n  try{\n    let media = await Media.find({postedBy: req.profile._id})\n      .populate('postedBy', '_id name')\n      .sort('-created')\n      .exec()\n    res.json(media)\n  } catch(err){\n      return res.status(400).json({\n        error: errorHandler.getErrorMessage(err)\n      })\n  }\n}\n```", "```js\nrouter.route('/api/media/:mediaId')\n    .get( mediaCtrl.incrementViews, mediaCtrl.read)\n```", "```js\nconst incrementViews = async (req, res, next) => {\n  try {\n    await Media.findByIdAndUpdate(req.media._id, \n       {$inc: {\"views\": 1}}, {new: true}).exec()\n    next()\n  } catch(err){\n      return res.status(400).json({\n          error: errorHandler.getErrorMessage(err)\n      })\n  }\n}\n```", "```js\nconst read = (req, res) => {\n  return res.json(req.media)\n}\n```", "```js\nconst read = async (params, signal) => {\n  try {\n    let response = await fetch('/api/media/' + params.mediaId, {\n    method: 'GET',\n    signal: signal\n  })\n    return await response.json()\n  } catch(err) {\n    console.log(err)\n  }\n}\n```", "```js\n<Media media={media}/>\n```", "```js\n<CardHeader \n   title={props.media.title}\n   action={<span>\n                {props.media.views + ' views'}\n           </span>}\n   subheader={props.media.genre}\n/>\n```", "```js\nconst mediaUrl = props.media._id\n          ? `/api/media/video/${props.media._id}`\n          : null\n            â€¦ \n<ReactPlayer url={mediaUrl} \n             controls\n             width={'inherit'}\n             height={'inherit'}\n             style={{maxHeight: '500px'}}\n             config={{ attributes: \n                        { style: { height: '100%', width: '100%'} } \n}}/>\n```", "```js\n<ListItem>\n    <ListItemAvatar>\n      <Avatar>\n        {props.media.postedBy.name && \n                        props.media.postedBy.name[0]}\n      </Avatar>\n    </ListItemAvatar>\n    <ListItemText primary={props.media.postedBy.name} \n              secondary={\"Published on \" + \n                        (new Date(props.media.created))\n                        .toDateString()}/>\n</ListItem>\n<ListItem>\n    <ListItemText primary={props.media.description}/>\n</ListItem>\n```", "```js\n{(auth.isAuthenticated().user && auth.isAuthenticated().user._id) \n    == props.media.postedBy._id && (<ListItemSecondaryAction>\n        <Link to={\"/media/edit/\" + props.media._id}>\n          <IconButton aria-label=\"Edit\" color=\"secondary\">\n            <Edit/>\n          </IconButton>\n        </Link>\n        <DeleteMedia mediaId={props.media._id} mediaTitle=\n       {props.media.title}/>\n      </ListItemSecondaryAction>)}\n```", "```js\nrouter.route('/api/media/:mediaId')\n        .put(authCtrl.requireSignin, \n                mediaCtrl.isPoster, \n                    mediaCtrl.update)\n```", "```js\nconst isPoster = (req, res, next) => {\n let isPoster = req.media && req.auth \n    && req.media.postedBy._id == req.auth._id\n if(!isPoster){\n return res.status('403').json({\n error: \"User is not authorized\"\n })\n }\n next()\n}\n```", "```js\nconst update = async (req, res) => {\n  try {\n    let media = req.media\n    media = extend(media, req.body)\n    media.updated = Date.now()\n    await media.save()\n    res.json(media)\n  } catch(err){\n    return res.status(400).json({\n        error: errorHandler.getErrorMessage(err)\n    })\n  }\n}\n```", "```js\nconst update = async (params, credentials, media) => {\n  try {\n    let response = await fetch('/api/media/' + params.mediaId, {\n    method: 'PUT',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer ' + credentials.t\n    },\n    body: JSON.stringify(media)\n  }) \n    return await response.json()\n    } catch(err) {\n      console.log(err)\n    }\n}\n```", "```js\n  useEffect(() => {\n    const abortController = new AbortController()\n    const signal = abortController.signal\n\n    read({mediaId: match.params.mediaId}).then((data) => {\n      if (data.error) {\n        setError(data.error)\n      } else {\n        setMedia(data)\n      }\n    })\n    return function cleanup(){\n      abortController.abort()\n    }\n  }, [match.params.mediaId])\n```", "```js\n  const handleChange = name => event => {\n    let updatedMedia = {...media}\n    updatedMedia[name] = event.target.value\n    setMedia(updatedMedia)\n  }\n```", "```js\n  const clickSubmit = () => {\n    const jwt = auth.isAuthenticated()\n    update({\n      mediaId: media._id\n    }, {\n      t: jwt.token\n    }, media).then((data) => {\n      if (data.error) {\n        setError(data.error)\n      } else {\n        setRedirect(true)\n      }\n    })\n  }\n```", "```js\n<PrivateRoute path=\"/media/edit/:mediaId\" component={EditMedia}/>\n```", "```js\nrouter.route('/api/media/:mediaId')\n        .delete(authCtrl.requireSignin, \n                    mediaCtrl.isPoster, \n                        mediaCtrl.remove)\n```", "```js\nconst remove = async (req, res) => {\n  try {\n    let media = req.media\n    let deletedMedia = await media.remove()\n    gridfs.delete(req.file._id)\n    res.json(deletedMedia)\n  } catch(err) {\n    return res.status(400).json({\n      error: errorHandler.getErrorMessage(err)\n    })\n  }\n}\n```"]