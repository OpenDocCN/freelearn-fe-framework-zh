<html><head></head><body>
		<div id="_idContainer052">
			<h1 id="_idParaDest-118"><em class="italic"><a id="_idTextAnchor141"/>Chapter 6</em>: Authentication with Apollo and React</h1>
			<p>We have come a long way over the last few chapters. We have now reached the point where we are going to implement authentication for our React and GraphQL web applications. In this chapter, you are going to learn about some essential concepts for building an application with authentication using GraphQL.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>What is a JWT?</li>
				<li>Cookies versus localStorage</li>
				<li>Implementing authentication in Node.js and Apollo</li>
				<li>Signing up and logging in users</li>
				<li>Authenticating GraphQL queries and mutations</li>
				<li>Accessing the user from the request context</li>
			</ul>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor142"/>Technical requirements</h1>
			<p>The source code for this chapter is available in the following GitHub repository: </p>
			<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter06">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter06</a></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor143"/>What are JSON Web Tokens?</h1>
			<p><strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) are still a pretty new standard for carrying out authentication; not <a id="_idIndexMarker506"/>everyone knows about them, and even fewer people use them. This section does not provide a theoretical excursion through the mathematical or cryptographic basics of JWTs.</p>
			<p>In traditional web applications written using PHP, for example, you commonly have a session cookie. This cookie identifies the user session on the server. The session must be stored on the server to retrieve the initial user. The problem here is that the overhead of saving and querying all the sessions for all the users can be high. When using JWTs, however, there is no need for the server to preserve any kind of session ID.</p>
			<p>Generally speaking, a JWT consists of everything you need to identify a user. The most common approach is to store the creation time of the token, the username, the user ID, and maybe the role, such as an admin or a normal user. You should not include any personal or critical data for security reasons.</p>
			<p>The reason a JWT exists is not to encrypt or secure data in any way. Instead, to authorize yourself using a resource such as a server, you send a signed JWT that your server can verify. It can only verify the JWT if it was created by a service stated as authentic by your server. In most cases, your server will have used its public key to sign the token. Any person or service that can read the communication between you and the server can access the token and can extract the payload without further ado. They are not able to edit its content though, because the token is signed with a signature.</p>
			<p>The token needs <a id="_idIndexMarker507"/>to be transported and stored securely in the browser of the client. If the token gets into the wrong hands, that person can access the affected application with your identity, initiate actions in your name, or read personal data. It is also hard to invalidate a JWT. With a session cookie, you can delete the session on the server, and the user will no longer be authenticated through the cookie. With a JWT, however, we do not have any information on the server. It can only validate the signature of the token and find the user in your database. One common approach is to have a blacklist of all the disallowed tokens. Alternatively, you can keep the lifetime of a JWT low by specifying the expiration date. This solution, however, requires the user to frequently repeat the login process, which makes the experience less comfortable.</p>
			<p>JWTs do not require any server-side storage. The great thing about server-side sessions is that you can store specific application states for your user and, for example, remember the last actions a user performed. Without a server-side store, you either need to implement these features in <strong class="source-inline">localStorage</strong> or implement a session store, which is not required for using JWT authentication at all:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">JWTs are an important topic in developer communities. There is some excellent documentation available related to what JWTs are, how they can be used, and their technological background. Visit the following web page to learn more and to see a demonstration of the generation of a JWT: <a href="https://jwt.io/">https://jwt.io/</a>.</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_6.01_B17337.jpg" alt="Figure 6.1 – JWT structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – JWT structure</p>
			<p>As shown in the preceding diagram, a JWT consists of three parts:</p>
			<ul>
				<li><strong class="bold">HEADER</strong>: The header <a id="_idIndexMarker508"/>specifies the algorithm that was used to generate the JWT.</li>
				<li><strong class="bold">PAYLOAD</strong>: The payload <a id="_idIndexMarker509"/>consists of all the "session" data, which are called claims. The preceding is just a simple representation and does not show the full complexity of a JWT.</li>
				<li><strong class="bold">SIGNATURE</strong>: The signature is <a id="_idIndexMarker510"/>calculated from the header and payload. To verify if a JWT has not been tampered with, the signature is compared to the newly generated signature from the actual payload and header.</li>
			</ul>
			<p>In our example, we are going to use JWTs, since they are a modern and decentralized method of authentication. Still, you can choose to opt out of this at any point and use regular <a id="_idIndexMarker511"/>sessions instead, which can be quickly realized in Express.js and GraphQL.</p>
			<p>In the next section, we will look at the different ways of storing the JWT inside the browser and how to transmit between <strong class="source-inline">localStorage</strong> and cookies.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor144"/>localStorage versus cookies</h1>
			<p>Let's look at another critical question. It is crucial to understand at least the basics of how authentication works and how it is secured. You are responsible for any faulty implementation <a id="_idIndexMarker512"/>that allows data breaches to occur, so always keep this in mind. Where do we store the token we receive from the server?</p>
			<p>In whichever <a id="_idIndexMarker513"/>direction you send a token, you should always be sure that your communication is secure. For web applications like ours, be sure that HTTPS is enabled and used for all requests. Once the user has successfully authenticated, the client receives the JWT, according to the JWT authentication workflow. A JWT is not tied to any particular storage medium, so you are free to choose whichever you prefer. If we do not store the token when it is received, it will be only available in the memory. While the user is browsing our site, this is fine, but the moment they refresh the page, they will need to log in again because we haven't stored the token anywhere.</p>
			<p>There are two standard options: to store the JWT inside <strong class="source-inline">localStorage</strong> or to store it inside a cookie. Let's start by discussing the first option. <strong class="source-inline">localStorage</strong> is the option that's often suggested in tutorials. This is fine, assuming you are writing a single-page web application where the content changes dynamically, depending on the actions of the user and client-side routing. We do not follow any links and load new sites to see new content; instead, the old one is just replaced with the new page that you want to show.</p>
			<p>Storing the token in <strong class="source-inline">localStorage</strong> has <a id="_idIndexMarker514"/>the following disadvantages:</p>
			<ul>
				<li><strong class="source-inline">localStorage</strong> is not transmitted on every request. When the page is loaded initially, you are not able to send the token within your request, so resources that need authentication cannot be given back to you. Once your application has finished loading, you must make a second request to your server, including the token to access the secured content. This behavior has the consequence that it is not possible to build server-rendered applications.</li>
				<li>The client needs to implement the mechanics to attach the token to every request that's sent to the server.</li>
				<li>Due to the <a id="_idIndexMarker515"/>nature of <strong class="source-inline">localStorage</strong>, there is no built-in expiry date on the client. If, at some point, the token reaches its expiration date, it still exists on the client inside <strong class="source-inline">localStorage</strong>.</li>
				<li><strong class="source-inline">localStorage</strong> is accessed through pure JavaScript and is therefore open to XSS attacks. If someone manages to integrate custom JavaScript in your code or site through unsanitized inputs, they can read the token from <strong class="source-inline">localStorage</strong>.</li>
			</ul>
			<p>There are, however, many <a id="_idIndexMarker516"/>advantages of using <strong class="source-inline">localStorage</strong>:</p>
			<ul>
				<li>As <strong class="source-inline">localStorage</strong> is not sent automatically with every request, it is secure against any <strong class="bold">Cross-Site-Request-Forgery</strong> (<strong class="bold">CSRF</strong>) attacks attempting to run actions from <a id="_idIndexMarker517"/>external sites by making random requests.</li>
				<li><strong class="source-inline">localStorage</strong> is easy to read in JavaScript since it is stored as a key-value pair.</li>
				<li>It supports a bigger data size, which is great for storing an application state or data.</li>
			</ul>
			<p>The main problem with storing such critical tokens inside web storage is that you cannot guarantee that <a id="_idIndexMarker518"/>there is no unwanted access. Unless you can <a id="_idIndexMarker519"/>be sure that every single input is sanitized and you are not relying on any third-party tools that get bundled into your JavaScript code, there is <a id="_idIndexMarker520"/>always a potential risk. Just one package you did not build yourself could share your users' web storage with its creator, without you or the user ever noticing. Furthermore, when you are using a public <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>), the attack base and, consequently, the risk for your application is multiplied.</p>
			<p>Now, let's look at cookies. These are great, despite their bad press due to the cookie compliance law that was initiated by the EU. Putting aside the more negative things that cookies can enable the companies to do, such as tracking users, there are still many good things about them. One significant difference compared to <strong class="source-inline">localStorage</strong> is that cookies are sent with every request, including the initial request for the site your application is hosted on.</p>
			<p>Cookies <a id="_idIndexMarker521"/>come with the following advantages:</p>
			<ul>
				<li>Server-side rendering is no problem at all since cookies are sent with every request.</li>
				<li>No further logic needs to be implemented in the frontend to send the JWT.</li>
				<li>Cookies can be declared as <strong class="source-inline">httpOnly</strong>, which means JavaScript can't access them. It secures our token from XSS attacks.</li>
				<li>Cookies have a built-in expiration date, which can be set to invalidate the cookie in the client browser.</li>
				<li>Cookies can be configured to only be readable from specific domains or paths.</li>
				<li>All browsers support cookies.</li>
			</ul>
			<p>These advantages sound <a id="_idIndexMarker522"/>good so far, but let's consider the downsides:</p>
			<ul>
				<li>Cookies are generally open to CSRF attacks, which are situations in which an external website makes requests to your API. They expect you to be authenticated and hope that they can execute actions on your behalf. We can't stop the cookie from being sent with each request to your domain. A common prevention tactic is to implement a CSRF token. This special token is also transmitted by your server and saved as a cookie. The external website cannot access the cookie with JavaScript since it is stored under a different domain. Your server does not read a token from the cookies that are transmitted with each request, only from an HTTP header. This behavior guarantees that the token was sent by the JavaScript that was hosted on your application because only this can have access to the token. Setting up the XSRF token for verification, however, introduces a lot of work.</li>
				<li>Accessing and parsing cookies is not intuitive because they are stored as a big comma-separated string.</li>
				<li>They can only store a small amount of data.</li>
			</ul>
			<p>So, we can see that both approaches have their advantages and disadvantages.</p>
			<p>The most common method is to use <strong class="source-inline">localStorage</strong>, as this is the easiest method. In this book, we <a id="_idIndexMarker523"/>will start by using <strong class="source-inline">localStorage</strong>, but later switch over to cookies when using server-side rendering to give you experience with both. You may not need server-side rendering at all. If this is the case, you can skip this part and the cookie implementation too.</p>
			<p>In the next section, we are going to implement authentication with GraphQL.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor145"/>Authentication with GraphQL</h1>
			<p>The basics of authentication should now be clear to you. Now, our task is to implement a secure <a id="_idIndexMarker524"/>way for users to authenticate. If we have a look at our current database, we will see that we are missing the required fields. To do so, follow these steps:</p>
			<ol>
				<li>Let's prepare and add a <strong class="source-inline">password</strong> field and an <strong class="source-inline">email</strong> field. As we learned in <a href="B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Connecting to the Database</em>, we must create a migration to edit our user table. You can look up the commands in that chapter if you have forgotten them:<p class="source-code"><strong class="bold">sequelize migration:create --migrations-path src/server/migrations --name add-email-password-to-post</strong></p><p>The preceding command generates the new file for us. </p></li>
				<li>Replace the content of it and try writing the migration on your own, or you can check for the right commands in the following code snippet:<p class="source-code">'use strict';</p><p class="source-code">module.exports = {</p><p class="source-code">  up: (queryInterface, Sequelize) =&gt; {</p><p class="source-code">    return Promise.all([</p><p class="source-code">      queryInterface.addColumn('Users',</p><p class="source-code">        'email',</p><p class="source-code">        {</p><p class="source-code">          type: Sequelize.STRING,</p><p class="source-code">          unique : true,</p><p class="source-code">        }</p><p class="source-code">      ),</p><p class="source-code">      queryInterface.addColumn('Users',</p><p class="source-code">        'password',</p><p class="source-code">        {</p><p class="source-code">          type: Sequelize.STRING, </p><p class="source-code">        }</p><p class="source-code">      ),</p><p class="source-code">    ]);</p><p class="source-code">  },</p><p class="source-code">  down: (queryInterface, Sequelize) =&gt; {</p><p class="source-code">    return Promise.all([</p><p class="source-code">      queryInterface.removeColumn('Users', 'email'),</p><p class="source-code">      queryInterface.removeColumn('Users',</p><p class="source-code">       'password'),</p><p class="source-code">    ]);</p><p class="source-code">  }</p><p class="source-code">};</p></li>
				<li>All the fields are simple strings. Execute the migration, as stated in <a href="B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Connecting to the Database</em>. The email address needs to be unique. Our old seed file for the users needs to be updated now to represent the new fields that we have just added. Add the following fields to the first user:<p class="source-code">password: '$2a$10$bE3ovf9/Tiy/d68bwNUQ0.zCjwtNFq9ukg9h4rhKiHCb6x5ncKife',</p><p class="source-code">email: 'test1@example.com',</p><p>Do this for all the users and change the email address for each. Otherwise, it will not work. The password is in hashed format and represents the plain password 123456789. Since we have added new fields in a separate migration, we must add these to the model.</p></li>
				<li>Open <a id="_idIndexMarker525"/>and add the following new lines as fields to the <strong class="source-inline">user.js</strong> file in the <strong class="source-inline">model</strong> folder:<p class="source-code">email: DataTypes.STRING,</p><p class="source-code">password: DataTypes.STRING,</p></li>
				<li>Now clear the database, run all the migrations, and execute the seeders again.</li>
			</ol>
			<p>The first thing we must do is get the login process running. At the moment, we are just faking being logged in as the first user in our database.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor146"/>Apollo login mutation</h2>
			<p>In this <a id="_idIndexMarker526"/>section, we are going to edit our GraphQL <a id="_idIndexMarker527"/>schema and implement the matching resolver function. Follow these steps:</p>
			<ol>
				<li value="1">Let's start with the schema and add a new mutation to the <strong class="source-inline">RootMutation</strong> object of our <strong class="source-inline">schema.js</strong> file:<p class="source-code">login (</p><p class="source-code">  email: String!</p><p class="source-code">  password: String!</p><p class="source-code">): Auth</p><p>The preceding schema gives us a login mutation that accepts an email address and a password. Both are required to identify and authenticate the user. Then, we need to respond with something to the client. For now, the <strong class="source-inline">Auth</strong> type returns a token, which is a JWT in our case. You might want to add a different option according to your requirements:</p><p class="source-code">type Auth {</p><p class="source-code">  token: String</p><p class="source-code">}</p></li>
				<li>The schema <a id="_idIndexMarker528"/>is now ready. Head over <a id="_idIndexMarker529"/>to the <strong class="source-inline">resolvers</strong> file and add the login function inside the mutation object. Before we do this, install and import two new packages:<p class="source-code"><strong class="bold">npm install --save jsonwebtoken bcrypt</strong></p><p>The <strong class="source-inline">jsonwebtoken</strong> package handles everything that's required to sign, verify, and decode JWTs.</p><p>The important part is that all the passwords for our users are not saved as plain text but are first encrypted using hashing, including a random salt. This generated hash cannot be decoded or decrypted as a plain password, but the package can verify if the password that was sent with the login attempt matches the password hash that was saved on the user. </p></li>
				<li>Import these packages at the top of the <strong class="source-inline">resolvers</strong> file:<p class="source-code">import bcrypt from 'bcrypt';</p><p class="source-code">import JWT from 'jsonwebtoken';</p></li>
				<li>The <strong class="source-inline">login</strong> function receives <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong> as parameters. It should look as follows:<p class="source-code">login(root, { email, password }, context) {</p><p class="source-code">  return User.findAll({</p><p class="source-code">    where: {</p><p class="source-code">      email</p><p class="source-code">    },</p><p class="source-code">    raw: true</p><p class="source-code">  }).then(async (users) =&gt; {</p><p class="source-code">    if(users.length = 1) {</p><p class="source-code">      const user = users[0];</p><p class="source-code">      const passwordValid = await</p><p class="source-code">        bcrypt.compare(password, user.password);</p><p class="source-code">      if (!passwordValid) {</p><p class="source-code">        throw new Error('Password does not match');</p><p class="source-code">      }</p><p class="source-code">      const token = JWT.sign({ email, id: user.id },</p><p class="source-code">        JWT_SECRET, {</p><p class="source-code">        expiresIn: '1d'</p><p class="source-code">      });</p><p class="source-code">      return {</p><p class="source-code">        token</p><p class="source-code">      };</p><p class="source-code">    } else {</p><p class="source-code">      throw new Error("User not found");</p><p class="source-code">    }</p><p class="source-code">  });</p><p class="source-code">},</p><p>The preceding code goes through the following steps:</p><ol><li>We query all the users where the email address matches.</li><li>If a user is found, we can move on. It is not possible to have multiple users with the same address, as the MySQL unique constraint forbids this.</li><li>Next, we use the user's password and compare it with the submitted password, using the <strong class="source-inline">bcrypt</strong> package, as explained previously.</li><li>If the password was correct, we generate a JWT token for the <strong class="source-inline">jwt</strong> variable using the <strong class="source-inline">jwt.sign</strong> function. It takes three arguments: the payload, which is the user ID and their email address; the key that we sign the JWT with; and the amount of time in which the JWT is going to expire.</li><li>Finally, we return an object containing our JWT.</li></ol><p class="callout-heading">Note</p><p class="callout">Something that you might need to rethink is how much detail you give in an error message. For example, we might not want to distinguish between an incorrect password and a non-existent user. It allows possible attackers or data collectors to know which email address is in use.</p><p>The <strong class="source-inline">login</strong> function is not working yet because we are missing <strong class="source-inline">JWT_SECRET</strong>, which is <a id="_idIndexMarker530"/>used to sign the JWT. In production, we <a id="_idIndexMarker531"/>use the environment variables to pass the JWT secret key into our backend code so that we can use this approach in development too.</p></li>
				<li>For Linux or Mac, type the following command directly in the Terminal:<p class="source-code"><strong class="bold">export JWT_SECRET=</strong></p><p class="source-code"><strong class="bold">  awv4BcIzsRysXkhoSAb8t8lNENgXSqBruVlLwd45kGdYje</strong></p><p class="source-code"><strong class="bold">  JHLap9LUJ1t9DTdw36DvLcWs3qEkPyCY6vOyNljlh2Er952h2gDzYwG8</strong></p><p class="source-code"><strong class="bold">  2rs1qfTzdVIg89KTaQ4SWI1YGY</strong></p></li>
				<li>The <strong class="source-inline">export</strong> function sets the <strong class="source-inline">JWT_SECRET</strong> environment variable for you. Replace the JWT provided with a random one. You can use any password generator by setting the character count to 128 and excluding any special characters. Setting the environment variable allows us to read the secret in our application. You must replace it when going to production.</li>
				<li>Insert the following code at the top of the file:<p class="source-code">const { JWT_SECRET } = process.env;</p><p>This code reads the environment variable from the global Node.js <strong class="source-inline">process</strong> object. Be sure to replace the JWT once you publish your application <a id="_idIndexMarker532"/>and be sure to always <a id="_idIndexMarker533"/>store the secret securely. After letting the server reload, we can send the first login request. We are going to learn how to do this in React later, but the following code shows an example of using Postman:</p><p class="source-code">{</p><p class="source-code">  "operationName":null,</p><p class="source-code">  "query": "mutation login($email : String!, $password</p><p class="source-code">    : String!) { </p><p class="source-code">   login(email: $email, password : $password) { token </p><p class="source-code">     }}",</p><p class="source-code">  "variables":{</p><p class="source-code">    "email": "test1@example.com",</p><p class="source-code">    "password": "123456789"</p><p class="source-code">  }</p><p class="source-code">}</p><p>This request should return a token:</p><p class="source-code">{</p><p class="source-code">  "data": {</p><p class="source-code">    "login": {</p><p class="source-code">      "token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e</p><p class="source-code">        yJlbWFpbCI6InRlc3QxQGV4YW1wbGUuY29tIiwiaWQiOjE</p><p class="source-code">        sImlhdCI6MTUzNzIwNjI0MywiZXhwIjoxNTM3MjkyNjQzf</p><p class="source-code">        Q.HV4dPIBzvU1yn6REMv42N0DS0ZdgebFDXUj0MPHvlY"</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>As you can see, we have generated a signed JWT and returned it within the mutation's response. We can continue here and send the token with every request <a id="_idIndexMarker534"/>inside the HTTP authorization <a id="_idIndexMarker535"/>header. Then, we can get the authentication running for all the other GraphQL queries or mutations that we have implemented so far. </p></li>
			</ol>
			<p>Let's continue and learn how to set up React to work with our authentication on the backend.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor147"/>The React login form</h2>
			<p>We need <a id="_idIndexMarker536"/>to handle the different authentication states of <a id="_idIndexMarker537"/>our application:</p>
			<ul>
				<li>The first scenario is that the user is not logged in and cannot see any posts or chats. In this case, we need to show a login form to allow the user to authenticate themselves.</li>
				<li>The second scenario is that an email and password are sent through the login form. The response needs to be interpreted, and if the result is correct, we need to save the JWT inside <strong class="source-inline">localStorage</strong> of the browser for now.</li>
				<li>When changing <strong class="source-inline">localStorage</strong>, we also need to rerender our React application to show the logged-in state.</li>
				<li>Furthermore, the user should be able to log out again.</li>
				<li>We must also be able to handle if the JWT expires and the user is unable to access any functionalities.</li>
			</ul>
			<p>The login form will look as follows:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_6.02_B17337.jpg" alt="Figure 6.2 – Login form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Login form</p>
			<p>To get <a id="_idIndexMarker538"/>started with the login form, follow <a id="_idIndexMarker539"/>these steps:</p>
			<ol>
				<li value="1">Set up a separate login mutation file inside the <strong class="source-inline">apollo</strong> folder. It is likely that we only need this component in one place in our code, but it is a good idea to save GraphQL requests in separate files.</li>
				<li>Build the login form component, which uses the login mutation to send the form data.</li>
				<li>Create the <strong class="source-inline">CurrentUser</strong> query to retrieve the logged-in user object.</li>
				<li>Conditionally render the login form if the user is not authenticated or the real application, such as the newsfeed, if the user is logged in.</li>
				<li>We will begin by creating a new <strong class="source-inline">login.js</strong> file inside the <strong class="source-inline">mutations</strong> folder for the client components:<p class="source-code">import { gql, useMutation } from '@apollo/client';</p><p class="source-code">export const LOGIN = gql'</p><p class="source-code">  mutation login($email : String!, $password : </p><p class="source-code">    String!) {</p><p class="source-code">    login(email : $email, password : $password) {</p><p class="source-code">      token</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p><p class="source-code">export const useLoginMutation = () =&gt; useMutation(LOGIN);</p><p>As in the previous mutations, we parse the query string and export the <strong class="source-inline">login</strong> function from the <strong class="source-inline">useMutation</strong> Hook.</p></li>
				<li>Now, we must implement the actual login form that uses this mutation. To do this, we will <a id="_idIndexMarker540"/>create a <strong class="source-inline">loginregister.js</strong> file directly inside the <strong class="source-inline">components</strong> folder. As you may expect, we handle <a id="_idIndexMarker541"/>the login and registration of users in one component. Import the dependencies first:<p class="source-code">import React, { useState } from 'react';</p><p class="source-code">import { useLoginMutation } from '../apollo/mutations/login';</p><p class="source-code">import Loading from './loading';</p><p class="source-code">import Error from './error';</p></li>
				<li>The <strong class="source-inline">LoginForm</strong> component will store the form state, display an error message if something goes wrong, show a loading state, and send the login mutation, including the form data. Add the following code beneath the <strong class="source-inline">import</strong> statements:<p class="source-code">const LoginForm = ({ changeLoginState }) =&gt; {</p><p class="source-code">  const [email, setEmail] = useState('');</p><p class="source-code">  const [password, setPassword] = useState('');</p><p class="source-code">  const [login, { loading, error }] = </p><p class="source-code">    useLoginMutation();</p><p class="source-code">  const onSubmit = (event) =&gt; {</p><p class="source-code">    event.preventDefault();</p><p class="source-code">    login({</p><p class="source-code">      update(cache, { data: { login } }) {</p><p class="source-code">        if(login.token) {</p><p class="source-code">          localStorage.setItem('jwt', login.token);</p><p class="source-code">          changeLoginState(true);</p><p class="source-code">        }</p><p class="source-code">      }, variables: { email, password }</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="login"&gt;</p><p class="source-code">      {!loading &amp;&amp; (</p><p class="source-code">        &lt;form onSubmit={onSubmit}&gt;</p><p class="source-code">          &lt;label&gt;Email&lt;/label&gt;</p><p class="source-code">          &lt;input type="text" onChange={(event) =&gt; </p><p class="source-code">            setEmail(event.target.value)} /&gt;</p><p class="source-code">          &lt;label&gt;Password&lt;/label&gt;</p><p class="source-code">          &lt;input type="password" onChange={(event) =&gt;</p><p class="source-code">            setPassword(event.target.value)} /&gt;</p><p class="source-code">          &lt;input type="submit" value="Login" /&gt;</p><p class="source-code">        &lt;/form&gt;</p><p class="source-code">      )}</p><p class="source-code">      {loading &amp;&amp; (&lt;Loading /&gt;)}</p><p class="source-code">      {error &amp;&amp; (</p><p class="source-code">        &lt;Error&gt;&lt;p&gt;There was an error logging in!&lt;/p&gt;</p><p class="source-code">        &lt;/Error&gt;</p><p class="source-code">      )}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p>The overall React component is pretty straightforward. We just have one form and two inputs and we store their values in two state variables. The <strong class="source-inline">onSubmit</strong> function is called when the form is submitted, which will then trigger the login mutation. The <strong class="source-inline">update</strong> function of the mutation will be a bit different than the other mutations <a id="_idIndexMarker542"/>we have had so far. We don't <a id="_idIndexMarker543"/>write the return value in the Apollo cache; instead, we store the JWT inside <strong class="source-inline">localStorage</strong>. The syntax is pretty simple. You can directly use <strong class="source-inline">localStorage.get</strong> and <strong class="source-inline">localStorage.set</strong> to interact with the web storage.</p><p>After saving the JWT to <strong class="source-inline">localStorage</strong>, we call a <strong class="source-inline">changeLoginState</strong> function, which we will implement in the next step. The idea of this function is to have one global switch to change a user from logged in to logged out or vice versa.</p></li>
				<li>We now need to export a component that will be used by our application. The easiest thing to do is set up a wrapper component that handles the login and sign-up cases for us.<p>Insert the following code for the wrapper component:</p><p class="source-code">const LoginRegisterForm = ({ changeLoginState }) =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="authModal"&gt;</p><p class="source-code">      &lt;div&gt;</p><p class="source-code">        &lt;LoginForm changeLoginState={changeLoginState}</p><p class="source-code">        /&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p class="source-code">export default LoginRegisterForm</p><p>This component just renders the login form and passes the <strong class="source-inline">changeLoginState</strong> function.</p><p>All the basics for authenticating the user are now ready, but they have not been imported yet or displayed anywhere. Open the <strong class="source-inline">App.js</strong> file. There, we will directly display the feed, chats, and the top bar. The user should not be allowed to see everything if they are not logged in. Continue reading to change this.</p></li>
				<li>Import the <a id="_idIndexMarker544"/>new form that we have just <a id="_idIndexMarker545"/>created and import the <strong class="source-inline">useEffect</strong> Hook from React:<p class="source-code">import LoginRegisterForm from './components/loginregister';</p></li>
				<li>Now, we must store whether the user is logged in or not and, also on the first render of our application, check the login state based on <strong class="source-inline">localStorage</strong>. Add the following code to the <strong class="source-inline">App</strong> component:<p class="source-code">const [loggedIn, setLoggedIn] = useState(!!localStorage.getItem('jwt'));</p><p>When loading our page, we have the <strong class="source-inline">loggedIn</strong> state variable to store the current logged-in status inside. The default value is either <strong class="source-inline">true</strong> if the token exists or <strong class="source-inline">false</strong> if not.</p></li>
				<li>Then, in the <strong class="source-inline">return</strong> statement, we can use conditional rendering to show the login form when the <strong class="source-inline">loggedIn</strong> state variable is set to <strong class="source-inline">false</strong>, which means that there is no JWT inside our <strong class="source-inline">localStorage</strong>:<p class="source-code">{loggedIn &amp;&amp; (</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;Bar changeLoginState={setLoggedIn} /&gt;</p><p class="source-code">    &lt;Feed /&gt;</p><p class="source-code">    &lt;Chats /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">)}</p><p class="source-code">{!loggedIn &amp;&amp; &lt;LoginRegisterForm changeLoginState={setLoggedIn} /&gt;}</p><p>As you can see, we pass the <strong class="source-inline">setLoggedIn</strong> function to the login form, which is then able to trigger a logged-in state so that React can rerender and show the logged-in area. We call this property <strong class="source-inline">changeLoginState</strong> and use it inside the login form inside the <strong class="source-inline">update</strong> method in the login mutation.</p></li>
				<li>Add the <a id="_idIndexMarker546"/>CSS from the official GitHub <a id="_idIndexMarker547"/>repository:<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition</a></p></li>
			</ol>
			<p>Once we've logged in, our application will present us with the common posts feed, as it did previously. The authentication flow is now working, but there is one more open task. In the next section, we will allow new users to register at Graphbook.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor148"/>Apollo signup mutation</h2>
			<p>You should <a id="_idIndexMarker548"/>now be familiar with creating new mutations. To <a id="_idIndexMarker549"/>do so, follow these steps:</p>
			<ol>
				<li value="1">First, edit the schema to accept the new mutation:<p class="source-code">signup (</p><p class="source-code">  username: String!</p><p class="source-code">  email: String!</p><p class="source-code">  password: String!</p><p class="source-code">): Auth</p><p>We only need the <strong class="source-inline">username</strong>, <strong class="source-inline">email</strong>, and <strong class="source-inline">password</strong> properties, which were mentioned in the preceding code, to accept new users. If your application requires a gender or something else, you can add it here. When we're trying to sign up, we need to ensure that neither the email address nor the username has already been taken. </p></li>
				<li>Copy over the code to implement the resolver for signing up new users:<p class="source-code">signup(root, { email, password, username }, context) {</p><p class="source-code">  return User.findAll({</p><p class="source-code">    where: {</p><p class="source-code">      [Op.or]: [{email}, {username}]</p><p class="source-code">    },</p><p class="source-code">    raw: true,</p><p class="source-code">  }).then(async (users) =&gt; {</p><p class="source-code">    if(users.length) {</p><p class="source-code">      throw new Error('User already exists');</p><p class="source-code">    } else {</p><p class="source-code">      return bcrypt.hash(password, 10).then((hash) =&gt; {</p><p class="source-code">        return User.create({</p><p class="source-code">          email,</p><p class="source-code">          password: hash,</p><p class="source-code">          username,</p><p class="source-code">          activated: 1,</p><p class="source-code">        }).then((newUser) =&gt; {</p><p class="source-code">          const token = JWT.sign({ email, id:</p><p class="source-code">            newUser.id }, JWT_SECRET, </p><p class="source-code">          {</p><p class="source-code">            expiresIn: '1d'</p><p class="source-code">          });</p><p class="source-code">          return {</p><p class="source-code">            token</p><p class="source-code">          };</p><p class="source-code">        });</p><p class="source-code">      });</p><p class="source-code">    }</p><p class="source-code">  });</p><p class="source-code">},</p><p>Let's <a id="_idIndexMarker550"/>go through this code <a id="_idIndexMarker551"/>step by step:</p><ol><li>As we mentioned previously, first, we must check if a user with the same email or username exists. If this is the case, we throw an error. We use the <strong class="source-inline">Op.or</strong> Sequelize operator to implement the MySQL OR condition.</li><li>If the user does not exist, we can hash the password using <strong class="source-inline">bcrypt</strong>. You cannot save the plain password for security reasons. When running the <strong class="source-inline">bcrypt.hash</strong> function, a random salt is used to make sure nobody ever gets access to the original password. This command takes quite some computing time, so the <strong class="source-inline">bcrypt.hash</strong> function is asynchronous, and the promise must be resolved before we continue.</li><li>The encrypted password, including the other data the user has sent, is then inserted into our database as a new user.</li><li>After creating the user, we generate a JWT and return it to the client. The JWT allows us to log the user in directly once they've signed up. If you do not want this behavior, you can just return a message to indicate that the user has signed up successfully.</li></ol></li>
			</ol>
			<p>Now, you <a id="_idIndexMarker552"/>can test the <strong class="source-inline">signup</strong> mutation <a id="_idIndexMarker553"/>again with Postman while starting the backend using <strong class="source-inline">npm run server</strong>. With that, we have finished the backend implementation. So, let's start working on the frontend.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor149"/>React signup form</h2>
			<p>The registration <a id="_idIndexMarker554"/>form is nothing special. We will <a id="_idIndexMarker555"/>follow the same steps that we took with the login form: </p>
			<ol>
				<li value="1">Clone the <strong class="source-inline">LoginMutation</strong> component, replace the request at the top with the <strong class="source-inline">signup</strong> mutation, and hand over the <strong class="source-inline">signup</strong> method to the underlying children. </li>
				<li>At the top, import all the dependencies and then parse the new query:<p class="source-code">import { gql, useMutation } from '@apollo/client';</p><p class="source-code">export const SIGNUP = gql'</p><p class="source-code">  mutation signup($email : String!, $password :</p><p class="source-code">    String!, $username : String!) {</p><p class="source-code">    signup(email : $email, password : $password, </p><p class="source-code">      username : $username) {</p><p class="source-code">      token</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p><p class="source-code">export const useSignupMutation = () =&gt; useMutation(SIGNUP);</p><p>As you can see, the <strong class="source-inline">username</strong> field is new here, which we send with every <strong class="source-inline">signup</strong> request. The logic itself has not changed, so we still extract the JWT from the <strong class="source-inline">signup</strong> field when logging the user in after a successful request.</p></li>
			</ol>
			<p>It's good to <a id="_idIndexMarker556"/>see that the <strong class="source-inline">login</strong> and <strong class="source-inline">signup</strong> mutations are quite similar. The biggest <a id="_idIndexMarker557"/>change is that we conditionally render the login form or the registration form. Follow these steps:</p>
			<ol>
				<li value="1">Import the new mutation into the <strong class="source-inline">loginregister.js</strong> file:<p class="source-code">import { useSignupMutation } from '../apollo/mutations/signup';</p></li>
				<li>Then, replace the complete <strong class="source-inline">LoginRegisterForm</strong> component with the following new one:<p class="source-code">const LoginRegisterForm = ({ changeLoginState }) =&gt; {</p><p class="source-code">  const [showLogin, setShowLogin] = useState(true);</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="authModal"&gt;</p><p class="source-code">      {showLogin &amp;&amp; (</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          &lt;LoginForm </p><p class="source-code">             changeLoginState={changeLoginState} /&gt;</p><p class="source-code">          &lt;a onClick={() =&gt; setShowLogin(false)}&gt;</p><p class="source-code">            Want to sign up? Click here&lt;/a&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      )}</p><p class="source-code">      {!showLogin &amp;&amp; (</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          &lt;RegisterForm </p><p class="source-code">            changeLoginState={changeLoginState} /&gt;</p><p class="source-code">          &lt;a onClick={() =&gt; setShowLogin(true)}&gt;</p><p class="source-code">            Want to login? Click here&lt;/a&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      )}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p>You should <a id="_idIndexMarker558"/>notice that we are <a id="_idIndexMarker559"/>storing a <strong class="source-inline">showLogin</strong> variable in the component state. This decides if the login or register component is shown, which handles the actual business logic. </p></li>
				<li>Then, add a separate component for the register form before the export statement:<p class="source-code">const RegisterForm = ({ changeLoginState }) =&gt; {</p><p class="source-code">  const [email, setEmail] = useState('');</p><p class="source-code">  const [password, setPassword] = useState('');</p><p class="source-code">  const [username, setUsername] = useState('');</p><p class="source-code">  const [signup, { loading, error }] =</p><p class="source-code">    useSignupMutation();</p><p class="source-code">  const onSubmit = (event) =&gt; {</p><p class="source-code">    event.preventDefault();</p><p class="source-code">    signup({</p><p class="source-code">      update(cache, { data: { login } }) {</p><p class="source-code">        if(login.token) {</p><p class="source-code">          localStorage.setItem('jwt', login.token);</p><p class="source-code">          changeLoginState(true);</p><p class="source-code">        }</p><p class="source-code">      }, variables: { email, password, username }</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="login"&gt;</p><p class="source-code">      {!loading &amp;&amp; (</p><p class="source-code">        &lt;form onSubmit={onSubmit}&gt;</p><p class="source-code">          &lt;label&gt;Email&lt;/label&gt;</p><p class="source-code">          &lt;input type="text" onChange={(event) =&gt;</p><p class="source-code">            setEmail(event.target.value)} /&gt;</p><p class="source-code">          &lt;label&gt;Username&lt;/label&gt;</p><p class="source-code">          &lt;input type="text" onChange={(event) =&gt;</p><p class="source-code">            setUsername(event.target.value)} /&gt;</p><p class="source-code">          &lt;label&gt;Password&lt;/label&gt;</p><p class="source-code">          &lt;input type="password" onChange={(event) =&gt;</p><p class="source-code">            setPassword(event.target.value)} /&gt;</p><p class="source-code">          &lt;input type="submit" value="Sign up" /&gt;</p><p class="source-code">        &lt;/form&gt;</p><p class="source-code">      )}</p><p class="source-code">      {loading &amp;&amp; (&lt;Loading /&gt;)}</p><p class="source-code">      {error &amp;&amp; (</p><p class="source-code">        &lt;Error&gt;&lt;p&gt;There was an error logging in!&lt;/p&gt;</p><p class="source-code">        &lt;/Error&gt;</p><p class="source-code">      )}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p>In the <a id="_idIndexMarker560"/>preceding code, I added the <strong class="source-inline">username</strong> field, which must be given to the mutation. Everything is now <a id="_idIndexMarker561"/>set to invite new users to join our social network and log in as often as they want.</p></li>
			</ol>
			<p>In the next section, we will learn how to use authentication with our existing GraphQL requests.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor150"/>Authenticating GraphQL requests</h2>
			<p>The problem is that we are not using authentication everywhere at the moment. We are verifying that <a id="_idIndexMarker562"/>the user is who they say they are, but we are not rechecking this when the requests for chats or messages come in. To accomplish this, we must send the JWT token, which we generated specifically for this case, with every Apollo request. On the backend, we must specify which request requires authentication, read the JWT from the HTTP authorization header, and verify it. Follow these steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">index.js</strong> file from the <strong class="source-inline">apollo</strong> folder for the client-side code. Our <strong class="source-inline">ApolloClient</strong> is currently configured as explained in <a href="B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085"><em class="italic">Chapter 4</em></a>, <em class="italic">Hooking Apollo into React</em>. Before we send any requests, we must read the JWT from <strong class="source-inline">localStorage</strong> and add it as an HTTP authorization header. Inside the <strong class="source-inline">link</strong> property, we <a id="_idIndexMarker563"/>have specified the links for our <strong class="source-inline">ApolloClient</strong> processes. Before we configure the HTTP link, we must insert a third preprocessing Hook, as follows:<p class="source-code">const AuthLink = (operation, next) =&gt; {</p><p class="source-code">  const token = localStorage.getItem('jwt');</p><p class="source-code">  if(token) {</p><p class="source-code">    operation.setContext(context =&gt; ({</p><p class="source-code">      ...context,</p><p class="source-code">      headers: {</p><p class="source-code">        ...context.headers,</p><p class="source-code">        Authorization: 'Bearer ${token}',</p><p class="source-code">      },</p><p class="source-code">    }));</p><p class="source-code">  }</p><p class="source-code">  return next(operation);</p><p class="source-code">};</p><p>Here, we have called the new link <strong class="source-inline">AuthLink</strong> because it allows us to authenticate the client on the server. You can copy the <strong class="source-inline">AuthLink</strong> approach for other situations where you need to customize the header of your Apollo requests. Here, we just read the JWT from <strong class="source-inline">localStorage</strong> and, if it is found, we construct the header using the spread operator and add our token to the <strong class="source-inline">Authorization</strong> field as a Bearer Token. This is everything that needs to be done on the client side.</p></li>
				<li>To clarify things, take a look at the following <strong class="source-inline">link</strong> property to learn how to use this new preprocessor. No initialization is required; it is merely a function that is called every <a id="_idIndexMarker564"/>time a request is made. Copy the <strong class="source-inline">link</strong> configuration to our Apollo Client setup:<p class="source-code">link: from([</p><p class="source-code">  onError(({ graphQLErrors, networkError }) =&gt; {</p><p class="source-code">    if (graphQLErrors) {</p><p class="source-code">      graphQLErrors.map(({ message, locations, path })</p><p class="source-code">        =&gt; </p><p class="source-code">      console.log('[GraphQL error]: Message: </p><p class="source-code">        ${message}, Location: </p><p class="source-code">      ${locations}, Path: ${path}'));</p><p class="source-code">      if (networkError) {</p><p class="source-code">        console.log('[Network error]:</p><p class="source-code">          ${networkError}');</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }),</p><p class="source-code">  AuthLink,</p><p class="source-code">  new HttpLink({</p><p class="source-code">    uri: 'http://localhost:8000/graphql',</p><p class="source-code">    credentials: 'same-origin',</p><p class="source-code">  }),</p><p class="source-code">]),</p></li>
				<li>Let's install one dependency that we require:<p class="source-code">npm install --save @graphql-tools/utils</p></li>
				<li>For our backend, we need a pretty complex solution. Create a new file called <strong class="source-inline">auth.js</strong> inside the GraphQL <strong class="source-inline">services</strong> folder. We want to be able to mark specific GraphQL requests in our schema with a so-called directive. If we add this directive to <a id="_idIndexMarker565"/>our GraphQL schema, we can execute a function whenever the marked GraphQL action is requested. In this function, we can verify whether the user is logged in or not. Have a look at the following function and save it in the <strong class="source-inline">auth.js</strong> file:<p class="source-code">import { mapSchema, getDirective, MapperKind } from '@graphql-tools/utils';</p><p class="source-code">function authDirective(directiveName) {</p><p class="source-code">  const typeDirectiveArgumentMaps = {};</p><p class="source-code">  return {</p><p class="source-code">    authDirectiveTypeDefs: 'directive </p><p class="source-code">      @${directiveName} on QUERY | FIELD_DEFINITION |</p><p class="source-code">        FIELD',</p><p class="source-code">    authDirectiveTransformer: (schema) =&gt;</p><p class="source-code">      mapSchema(schema, {</p><p class="source-code">      [MapperKind.TYPE]: (type) =&gt; {</p><p class="source-code">        const authDirective = getDirective(schema,</p><p class="source-code">          type, directiveName)?.[0];</p><p class="source-code">        if (authDirective) {</p><p class="source-code">          typeDirectiveArgumentMaps[type.name] = </p><p class="source-code">            authDirective;</p><p class="source-code">        }</p><p class="source-code">        return undefined;</p><p class="source-code">      },</p><p class="source-code">      [MapperKind.OBJECT_FIELD]: (fieldConfig,</p><p class="source-code">        _fieldName, typeName) =&gt; {</p><p class="source-code">        const authDirective = getDirective(schema,</p><p class="source-code">          fieldConfig, directiveName)?.[0] ?? </p><p class="source-code">            typeDirectiveArgumentMaps[typeName];</p><p class="source-code">        if (authDirective) {</p><p class="source-code">          const { resolve = defaultFieldResolver } = </p><p class="source-code">            fieldConfig;</p><p class="source-code">          fieldConfig.resolve = function (source, </p><p class="source-code">            args, context, info) {</p><p class="source-code">            if (context.user) {</p><p class="source-code">              return resolve(source, args, context, </p><p class="source-code">                info);</p><p class="source-code">            }</p><p class="source-code">            throw new Error("You need to be logged  </p><p class="source-code">                             in.");</p><p class="source-code">          }</p><p class="source-code">          return fieldConfig;</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }),</p><p class="source-code">  };</p><p class="source-code">}</p><p class="source-code">export default authDirective;</p><p>Starting from the top, we import three things from the <strong class="source-inline">@graphql/utils</strong> package:</p><ol><li>The <strong class="source-inline">mapSchema</strong> function takes two arguments. The first is the actual GraphQL schema and then an object of functions that can transform the schema.</li><li>The <strong class="source-inline">getDirective</strong> function will read the schema and try to get the specified <strong class="source-inline">directiveName</strong>. Based on that, we can do anything that we want.</li><li><strong class="source-inline">MapperKind</strong> is just a set of types that we can use. We are using that to only run functions for specific types.</li></ol><p>This function or directive will read the user from the context and pass it to our resolvers where the directive is specified within our GraphQL schema.</p></li>
				<li>We must <a id="_idIndexMarker566"/>load the new <strong class="source-inline">authDirective</strong> function in the <strong class="source-inline">graphql</strong> <strong class="source-inline">index.js</strong> file, which sets up the whole Apollo Server:<p class="source-code">import authDirective from './auth';</p></li>
				<li>Before we create our executable schema, we must extract the new schema transformer from the <strong class="source-inline">authDirective</strong> function. After creating the executable schema, we must pass it to the transformer so that <strong class="source-inline">authDirective</strong> starts to work. Replace the current schema creation with the following code:<p class="source-code">const { authDirectiveTypeDefs, authDirectiveTransformer } = authDirective('auth');</p><p class="source-code">let executableSchema = makeExecutableSchema({</p><p class="source-code">    typeDefs: [authDirectiveTypeDefs, Schema],</p><p class="source-code">    resolvers: Resolvers.call(utils),</p><p class="source-code">});</p><p class="source-code">executableSchema = authDirectiveTransformer(executableSchema);</p></li>
				<li>To verify what we have just done, go to the GraphQL schema and edit <strong class="source-inline">postsFeed</strong> <strong class="source-inline">RootQuery</strong> by adding <strong class="source-inline">@auth</strong> to the end of the line, like this:<p class="source-code">postsFeed(page: Int, limit: Int): PostFeed @auth</p></li>
				<li>Because we are using a new directive, we also must define it in our GraphQL schema so that our server knows about it. Copy the following code directly to the top of the schema:<p class="source-code">directive @auth on QUERY | FIELD_DEFINITION | FIELD</p><p>This tiny snippet tells Apollo Server that the <strong class="source-inline">@auth</strong> directive can be used with queries, fields, and field definitions so that we can use it everywhere.</p></li>
			</ol>
			<p>If you reload <a id="_idIndexMarker567"/>the page and manually set the <strong class="source-inline">loggedIn</strong> state variable to true via React Developer Tools, you will see the following error message:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_6.03_B17337.jpg" alt="Figure 6.3 – GraphQL login error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – GraphQL login error</p>
			<p>Since we implemented the error component earlier, we are now correctly receiving an unauthenticated error for the <strong class="source-inline">postsFeed</strong> query if the user is not logged in. How can we use the JWT to identify the user and add it to the request context?</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Schema directives are a complex topic as there are many important things to bear in mind regarding Apollo and GraphQL. I recommend that you read up on directives in detail in the official Apollo documentation: <a href="https://www.graphql-tools.com/docs/introduction">https://www.graphql-tools.com/docs/introduction</a>.</p>
			<p>In <a href="B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up GraphQL with Express.js</em>, we set up Apollo Server by providing the <a id="_idIndexMarker568"/>executable schema and the context, which has been the request object until now. We must check if the JWT is inside the <a id="_idIndexMarker569"/>request. If this is the case, we need to verify it and query the user to see if the token is valid. Let's start by verifying the authorization header. Before doing so, import the new dependencies into the GraphQL <strong class="source-inline">index.js</strong> file:</p>
			<p class="source-code">import JWT from 'jsonwebtoken';</p>
			<p class="source-code">const { JWT_SECRET } = process.env;</p>
			<p>The <strong class="source-inline">context</strong> field of the <strong class="source-inline">ApolloServer</strong> initialization must look as follows:</p>
			<p class="source-code">context: async ({ req }) =&gt; {</p>
			<p class="source-code">  const authorization = req.headers.authorization;</p>
			<p class="source-code">  if(typeof authorization !== typeof undefined) {</p>
			<p class="source-code">      var search = "Bearer";</p>
			<p class="source-code">      var regEx = new RegExp(search, "ig");</p>
			<p class="source-code">      const token = authorization.replace(regEx,</p>
			<p class="source-code">        '').trim();</p>
			<p class="source-code">      return JWT.verify(token, JWT_SECRET, function(err,</p>
			<p class="source-code">        result) {</p>
			<p class="source-code">          if(err) {</p>
			<p class="source-code">              return req;</p>
			<p class="source-code">          } else {</p>
			<p class="source-code">              return utils.db.models.User.findByPk(</p>
			<p class="source-code">                result.id).then((user) =&gt; {</p>
			<p class="source-code">                  return Object.assign({}, req, { user });</p>
			<p class="source-code">              });</p>
			<p class="source-code">          }</p>
			<p class="source-code">      });</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">      return req;</p>
			<p class="source-code">  }</p>
			<p class="source-code">},</p>
			<p>Here, we have extended the <strong class="source-inline">context</strong> property of the <strong class="source-inline">ApolloServer</strong> class to a full-featured function. We read the <strong class="source-inline">auth</strong> token from the headers of the requests. If the <strong class="source-inline">auth</strong> token exists, we need to strip out the bearer string, because it is not part of the original token <a id="_idIndexMarker570"/>that was created by our backend. The Bearer Token is the best method of JWT authentication.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are other authentication methods available, such as basic authentication, but the bearer method <a id="_idIndexMarker571"/>is the best to follow. You can find a detailed explanation under RFC6750 by the IETF at <a href="https://tools.ietf.org/html/rfc6750">https://tools.ietf.org/html/rfc6750</a>.</p>
			<p>Afterward, we must use the <strong class="source-inline">JWT.verify</strong> function to check if the token matches the signature that's been generated by the secret from the environment variables. The next step is to retrieve the user once they've been verified successfully. Replace the content of the <strong class="source-inline">verify</strong> callback with the following code:</p>
			<p class="source-code">if(err) {</p>
			<p class="source-code">    return req;</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    return utils.db.models.User.findByPk(result.id).then((</p>
			<p class="source-code">      user) =&gt; {</p>
			<p class="source-code">        return Object.assign({}, req, { user });</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p>If the <strong class="source-inline">err</strong> object in the previous code has been filled, we can only return the ordinary request object, which triggers an error when it reaches the <strong class="source-inline">auth</strong> directive, since there is no user attached. If there are no errors, we can use the <strong class="source-inline">utils</strong> object we are already passing to the Apollo Server setup to access the database. If you need a reminder, take a look at <a href="B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up GraphQL with Express.js</em>. After querying the user, we must add them to the request object and return the merged user and request object as the context. This leads to a successful response from our authorizing directive.</p>
			<p>Now, let's test <a id="_idIndexMarker572"/>this behavior. Start the frontend with <strong class="source-inline">npm run client</strong> and the backend using <strong class="source-inline">npm run server</strong>. Don't forget that all Postman requests now have to include a valid JWT if the <strong class="source-inline">auth</strong> directive is used in the GraphQL query. You can run the login mutation and copy it over to the authorization header to run any query. We are now able to mark any query or mutation with the authorization flag and, as a result, require the user to be logged in.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor151"/>Accessing the user context from resolver functions</h2>
			<p>At the moment, all the API functions of our GraphQL server allow us to simulate the user by selecting <a id="_idIndexMarker573"/>the first that's available <a id="_idIndexMarker574"/>from the database. As we have just introduced a full-fledged authentication, we can now access the user from the request context. This section quickly explains how to do this for the chat and message entities. We will also implement a new query called <strong class="source-inline">currentUser</strong>, where we retrieve the logged-in user in our client.</p>
			<h3>Chats and messages</h3>
			<p>First of all, you must add the <strong class="source-inline">@auth</strong> directive to the chats inside GraphQL's <strong class="source-inline">RootQuery</strong> to ensure <a id="_idIndexMarker575"/>that users need to be logged in to access any chats or messages.</p>
			<p>Take a look at the resolver function for the chats. Currently, we are using the <strong class="source-inline">findAll</strong> method to get all users, take the first one, and query for all the user's chats. Replace this code with the following new resolver function:</p>
			<p class="source-code">chats(root, args, context) {</p>
			<p class="source-code">  return Chat.findAll({</p>
			<p class="source-code">    include: [{</p>
			<p class="source-code">      model: User,</p>
			<p class="source-code">      required: true,</p>
			<p class="source-code">      through: { where: { userId: context.user.id } },</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      model: Message,</p>
			<p class="source-code">    }],</p>
			<p class="source-code">  });</p>
			<p class="source-code">},</p>
			<p>Here, we don't retrieve the user; instead, we directly insert the user ID from the context, as shown in the preceding code. That's all we have to do: all the chats and messages that belong to the logged-in user are queried directly from the chats table.</p>
			<p>We would <a id="_idIndexMarker576"/>need to copy this for the mutations for chats and messages and all the other queries and mutations that we have at the moment.</p>
			<h3>CurrentUser GraphQL query</h3>
			<p>JWTs allow us to query for the currently logged-in user. Then, we can display the correct authenticated <a id="_idIndexMarker577"/>user in the top bar. To request the logged-in user, we <a id="_idIndexMarker578"/>require a new query called <strong class="source-inline">currentUser</strong> on our backend. In the schema, you simply have to add the following line to the <strong class="source-inline">RootQuery</strong> queries:</p>
			<p class="source-code">currentUser: User @auth</p>
			<p>Like the <strong class="source-inline">postsFeed</strong> and <strong class="source-inline">chats</strong> queries, we also need the <strong class="source-inline">@auth</strong> directive to extract the user from the request context.</p>
			<p>Similarly, in the resolver functions, you only need to insert the following three lines:</p>
			<p class="source-code">currentUser(root, args, context) {</p>
			<p class="source-code">  return context.user;</p>
			<p class="source-code">},</p>
			<p>We return the user from the context right away, because it is already a user model instance with all the appropriate data being returned by Sequelize. On the client side, we create this query in a separate component and file. Bear in mind that you don't need to pass the <a id="_idIndexMarker579"/>result to all the children because <a id="_idIndexMarker580"/>this is done automatically by <strong class="source-inline">ApolloConsumer</strong> later. You can follow the previous query component examples to see this. Just create a file called <strong class="source-inline">currentUserQuery.js</strong> in the <strong class="source-inline">queries</strong> folder with the following content:</p>
			<p class="source-code">import { gql, useQuery } from '@apollo/client';</p>
			<p class="source-code">export const GET_CURRENT_USER = gql'</p>
			<p class="source-code">  query currentUser {</p>
			<p class="source-code">    currentUser {</p>
			<p class="source-code">      id</p>
			<p class="source-code">      username</p>
			<p class="source-code">      avatar</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">';</p>
			<p class="source-code">export const useCurrentUserQuery = (options) =&gt; useQuery(GET_CURRENT_USER, options);</p>
			<p>Now, you can import the new query inside the <strong class="source-inline">App.js</strong> file and add the following line to the <strong class="source-inline">App</strong> component:</p>
			<p class="source-code">const { data, error, loading, refetch } = useCurrentUserQuery();</p>
			<p class="source-code">if(loading) {</p>
			<p class="source-code">    return &lt;Loading /&gt;;</p>
			<p class="source-code">}</p>
			<p>Here, we executed the <strong class="source-inline">useCurrentUserQuery</strong> Hook to ensure that the query has been executed at a global level for all the components. Also, we show a loading indicator until the request has finished to ensure that the user is loaded before we do anything else.</p>
			<p>Every time the <strong class="source-inline">loggedIn</strong> state variable is <strong class="source-inline">true</strong>, we render the components. To get access to the response, we must use <strong class="source-inline">ApolloConsumer</strong> in the bar component, which we implemented in the previous chapter. We run the <strong class="source-inline">currentUser</strong> query in the <strong class="source-inline">App.js</strong> file to ensure <a id="_idIndexMarker581"/>that all the child components can rely <a id="_idIndexMarker582"/>on the Apollo cache to access the user before being rendered.</p>
			<p>Instead of having a hardcoded fake user inside <strong class="source-inline">ApolloConsumer</strong>, we can use the the <strong class="source-inline">client.readQuery</strong> function to extract the data stored in the <strong class="source-inline">ApolloClient</strong> cache to give it to the underlying child component. Replace the current consumer with the following code:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import { ApolloConsumer } from '@apollo/client';</p>
			<p class="source-code">import { GET_CURRENT_USER } from '../../apollo/queries/currentUserQuery';</p>
			<p class="source-code">export const UserConsumer = ({ children }) =&gt; {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;ApolloConsumer&gt;</p>
			<p class="source-code">      {client =&gt; {</p>
			<p class="source-code">        const result = client.readQuery({ query:</p>
			<p class="source-code">          GET_CURRENT_USER });</p>
			<p class="source-code">        return React.Children.map(children,</p>
			<p class="source-code">          function(child){</p>
			<p class="source-code">          return React.cloneElement(child, { user:</p>
			<p class="source-code">            result?.currentUser ? result.currentUser : null </p>
			<p class="source-code">              });</p>
			<p class="source-code">        });</p>
			<p class="source-code">      }}</p>
			<p class="source-code">    &lt;/ApolloConsumer&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Here, we passed the extracted <strong class="source-inline">currentUser</strong> result from the <strong class="source-inline">client.readQuery</strong> method to all the wrapped children of the current component.</p>
			<p>The chats <a id="_idIndexMarker583"/>that are displayed from now on, as well <a id="_idIndexMarker584"/>as the user in the top bar, are no longer faked; instead, they are filled with the data related to the logged-in user.</p>
			<p>The mutations to create new posts or messages still use a static user ID. We can switch over to the real logged-in user in the same way as we did previously in this section by using the user ID from the <strong class="source-inline">context.user</strong> object. You should now be able to do this on your own.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor152"/>Logging out using React</h2>
			<p>To complete <a id="_idIndexMarker585"/>the circle, we still have to implement the functionality to log out. There are two cases when the user can be logged out:</p>
			<ul>
				<li>The user wants to log out and hits the logout button.</li>
				<li>The JWT has expired after 1 day as specified; the user is no longer authenticated, and we have to set the state to logged out.</li>
			</ul>
			<p>Follow these steps to accomplish this:</p>
			<ol>
				<li value="1">We will begin by adding a new logout button to the top bar of our application's frontend. To do this, create a new <strong class="source-inline">logout.js</strong> component inside the <strong class="source-inline">bar</strong> folder. It should look as follows:<p class="source-code">import React from 'react';</p><p class="source-code">import { withApollo } from '@apollo/client/react/hoc';</p><p class="source-code">const Logout = ({ changeLoginState, client }) =&gt; {</p><p class="source-code">  const logout = () =&gt; {</p><p class="source-code">    localStorage.removeItem('jwt');</p><p class="source-code">    changeLoginState(false);</p><p class="source-code">    client.stop();</p><p class="source-code">    client.resetStore();</p><p class="source-code">  }</p><p class="source-code">  return (</p><p class="source-code">    &lt;button className="logout" onClick={logout}&gt;Logout</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default withApollo(Logout);</p><p>As you can see, the logout button triggers the component's logout method when it is clicked. Inside the <strong class="source-inline">logout</strong> method, we remove the JWT from <strong class="source-inline">localStorage</strong> and execute the <strong class="source-inline">changeLoginState</strong> function that we receive from <a id="_idIndexMarker586"/>the parent component. Be aware that we do not send a request to our server to log out; instead, we remove the token from the client. This is because there is no black or white list that we are using to disallow or allow a certain JWT to authenticate on our server. The easiest way to log out a user is to remove the token on the client side so that neither the server nor the client has it.</p><p>We also reset the client cache. When a user logs out, we must remove all data. Otherwise, other users on the same browser will be able to extract all the data, which we must prevent. To gain access to the underlying Apollo Client, we must import the <strong class="source-inline">withApollo</strong> <strong class="bold">HOC</strong> (short for <strong class="bold">Higher-Order-Component</strong>)  and export the <strong class="source-inline">Logout</strong> component wrapped inside it. When logging out, we must execute the <strong class="source-inline">client.stop</strong> and <strong class="source-inline">client.resetStore</strong> functions so that all the data is deleted.</p></li>
				<li>To use our new <strong class="source-inline">Logout</strong> component, open the <strong class="source-inline">index.js</strong> file from the <strong class="source-inline">bar</strong> folder and import it at the top. We can render it within the <strong class="source-inline">div</strong> top bar, below the other inner <strong class="source-inline">div</strong> tag:<p class="source-code">&lt;div className="buttons"&gt;</p><p class="source-code">  &lt;Logout changeLoginState={changeLoginState}/&gt;</p><p class="source-code">&lt;/div&gt;</p><p>Here, we pass the <strong class="source-inline">changeLoginState</strong> function to the <strong class="source-inline">Logout</strong> component.</p></li>
				<li>Extract <a id="_idIndexMarker587"/>the <strong class="source-inline">changeLoginState</strong> function from the <strong class="source-inline">Bar</strong> component props, as follows:<p class="source-code">const Bar = ({ changeLoginState }) =&gt; {</p></li>
				<li>In the <strong class="source-inline">App.js</strong> file, you must implement one more function to handle the current user query correctly. If we are not logged in and then log in, we need to fetch the current user. And if we log out, we need to either set or be able to easily fetch the current user query again. Add the following function:<p class="source-code">const handleLogin = (status) =&gt; {</p><p class="source-code">    refetch().then(() =&gt; {</p><p class="source-code">        setLoggedIn(status);</p><p class="source-code">    }).catch(() =&gt; {</p><p class="source-code">        setLoggedIn(status);</p><p class="source-code">    });</p><p class="source-code">}</p></li>
				<li>Hand this function over not only to <strong class="source-inline">LoginRegisterForm</strong> but also to the <strong class="source-inline">Bar</strong> component, as follows:<p class="source-code">&lt;Bar changeLoginState={handleLogin} /&gt;</p></li>
				<li>If you copy the complete CSS from the official GitHub repository, you should see a new button at the top-right corner of the screen when you are logged in. Hitting it logs you out and requires you to sign in again since the JWT has been deleted. </li>
				<li>The other <a id="_idIndexMarker588"/>situation in which we implement logout functionality is when the JWT we are using expires. In this case, we log the user out automatically and require them to log in again. Go to the <strong class="source-inline">App</strong> component and add the following lines:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  const unsubscribe = client.onClearStore(</p><p class="source-code">    () =&gt; {</p><p class="source-code">      if(loggedIn){</p><p class="source-code">        setLoggedIn(false)</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  );</p><p class="source-code">  return () =&gt; {</p><p class="source-code">    unsubscribe();</p><p class="source-code">  }</p><p class="source-code">}, []);</p><p>Here, we are using the <strong class="source-inline">client.onClearStore</strong> event, which is caught through the <strong class="source-inline">client.onClearStore</strong> function once the client store is cleared.</p></li>
				<li>To get the preceding code to work, we must access the Apollo Client in our <strong class="source-inline">App</strong> component. The easiest way to do this is to use the <strong class="source-inline">withApollo</strong> HoC. Just import it from the <strong class="source-inline">@apollo/client</strong> package in the <strong class="source-inline">App.js</strong> file:<p class="source-code">import { withApollo } from '@apollo/client/react/hoc';</p></li>
				<li>Then, export the <strong class="source-inline">App</strong> component – not directly, but through the HoC – and extract the <strong class="source-inline">client</strong> property. The following code must go directly beneath the <strong class="source-inline">App</strong> component:<p class="source-code">export default withApollo(App);</p><p>Now, the <a id="_idIndexMarker589"/>component can access the client through its properties. The <strong class="source-inline">clearStore</strong> event is thrown whenever the client restore is reset, as its name suggests. You are going to see why we need this shortly. When listening to events in React, we have to stop listening when the component is unmounted. We handle this inside the <strong class="source-inline">useEffect</strong> Hook in the preceding code. Now, we must reset the client store to initiate the logout state. When the event is caught, we execute the <strong class="source-inline">changeLoginState</strong> function automatically. Consequently, we could remove the section that we passed <strong class="source-inline">changeLoginState</strong> to the logout button initially because it is no longer needed, but this is not what we want to do here.</p></li>
				<li>Extract the client from the <strong class="source-inline">App</strong> component props, like so:<p class="source-code">const App = ({ client }) =&gt; {</p></li>
				<li>Go to the <strong class="source-inline">index.js</strong> file in the <strong class="source-inline">apollo</strong> folder. There, we already caught and looped over all the errors that were returned from our GraphQL API. What we must do now is loop over all the errors but check each of them for an <strong class="source-inline">UNAUTHENTICATED</strong> error. Then, we must execute the <strong class="source-inline">client.clearStore</strong> function. Insert the following code into the Apollo Client setup:<p class="source-code">onError(({ graphQLErrors, networkError }) =&gt; {</p><p class="source-code">  if (graphQLErrors) {</p><p class="source-code">    graphQLErrors.map(({ message, locations, path,</p><p class="source-code">      extensions }) =&gt; {</p><p class="source-code">      if(extensions.code === 'UNAUTHENTICATED') {</p><p class="source-code">        localStorage.removeItem('jwt');</p><p class="source-code">        client.clearStore()</p><p class="source-code">      }</p><p class="source-code">      console.log('[GraphQL error]: Message: </p><p class="source-code">        ${message}, Location: </p><p class="source-code">      ${locations}, Path: ${path}');</p><p class="source-code">    });</p><p class="source-code">    if (networkError) {</p><p class="source-code">      console.log('[Network error]: ${networkError}');</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}),</p><p>As you can see, we access the <strong class="source-inline">extensions</strong> property of the error. The <strong class="source-inline">extensions.code</strong> field holds the specific error type that's returned. If we are not logged in, we remove the JWT and then reset the store. By doing this, we trigger the event in our <strong class="source-inline">App</strong> component, which sends the user back to the login form.</p></li>
			</ol>
			<p>A further extension <a id="_idIndexMarker590"/>would be to offer a refresh token API function. This feature could be run every time we successfully use the API. The problem with this is that the user would stay logged in forever, so long as they are using the application. Usually, this is not a problem, but if someone else is accessing the same computer, they will be authenticated as the original user. There are different ways to implement these kinds of functionalities to make the user experience more comfortable, but I am not a big fan of these for security reasons. </p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor153"/>Summary</h1>
			<p>Until now, one of the main issues we had with our application is that we didn't have any authentication. We can now tell who is logged in every time a user accesses our application. This allows us to secure the GraphQL API and insert new posts or messages into the name of the correct user. In this chapter, we discussed the fundamental aspects of JWTs, <strong class="source-inline">localStorage</strong>, and cookies. We also looked at how hashed password verification and signed tokens work. We then covered how to implement JWTs inside React and how to trigger the correct events to log in and log out.</p>
			<p>In the next chapter, we are going to implement image uploads with a reusable component that allows the user to upload new avatar images.</p>
		</div>
	</body></html>