<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Applying Modern CSS to Create React App Projects</h1>
                </header>
            
            <article>
                
<p class="mce-root">As we've been<span> </span>working on our project, we've been focusing very heavily on the functionality, but overall we have been perhaps slightly less focused on how everything actually looks! While this is fine for establishing functionality and making everything flow nicely at the start of the project, any designers working on the project will be ready to scream at this point!</p>
<p>Let's appease our design team, whether it's an actual team or just ourselves, by spending a little bit of time cleaning up the visual appeal of our project! In relation to our current design, while it's not necessarily hideous, it certainly leaves a lot to be desired!</p>
<p>So, how do we improve our application's design in a safe and sound way? Well, previously with Create React App, you actually didn't have a lot of options to be able to clean things up visually. You were frequently at the whims and mercy of random <strong><span>Cascading Style Sheets</span></strong> (<strong>CSS</strong>) project maintainers, and trying to get other libraries, frameworks, or preprocessors involved in the project compilation process was frequently a nightmare.</p>
<div class="packt_infobox">A <strong>preprocessor</strong> in the context of Create React App is basically one of the steps in the build process. In this case, we're talking about something that takes some of the style code (CSS or another format), compiles it down to basic CSS, and adds it to the output of the build process.</div>
<p>Over the span of this chapter, we'll be covering materials that span the gamut of style-related functionality and highlighting what is, in my mind, one of the best new features in Create React App: support for CSS Modules and SASS. Specifically, we'll be covering the following topics:</p>
<ul>
<li>The different ways to get CSS into our project</li>
<li>A brief history of CSS in Create React App projects</li>
<li>Introducing CSS Modules</li>
<li><span>Introducing SASS to our project</span></li>
<li>Mixing CSS Modules and SASS together</li>
<li>Integrating CSS Modules and SASS into our project</li>
<li>Integrating CSS frameworks into our project</li>
<li>Cleaning up our tests after modifying the design</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What tools are available?</h1>
                </header>
            
            <article>
                
<p>Create React App, by default, supports us getting CSS into our application in a number of different ways. </p>
<p>We can get CSS directly into our components by writing a <kbd>style</kbd> attribute and giving it some arbitrary CSS, as in the following code:</p>
<pre>const Example = () =&gt; {<br/>  return (<br/>    &lt;div className="Example" style="border: 1px solid red;"&gt;<br/>      Hello<br/>    &lt;/div&gt;<br/>  );<br/>};</pre>
<p>This will give us a little <kbd>div</kbd> with the word <kbd>Hello</kbd> in it, surrounded by a single-pixel red line for the border. While this is something you technically can do, generally speaking, you should avoid it. Using inline style statements like the preceding example makes it hard to keep your styles organized and track them down when formatting does go awry. Plus, if a designer or another non-developer needs to update the look and feel (for example, if the standard colors for things change), they will have to search to find where this one random little one-pixel red border is coming from!</p>
<p>We can also create<span> </span><kbd>.css</kbd><span> </span>files and then <kbd>import</kbd> them into our project via a statement like the following:</p>
<pre>import "./someStyle.css";</pre>
<p>This is a technique that you've seen used before and that we've used a great deal in our application. It's useful, of course, and allows us some small amount of separation of code and styles, but it doesn't give us everything that we need. In fact, it actually introduces a new problem that we now have to solve, and one that can make fixing your projects and cleaning up the visual display of your projects incredibly frustrating and difficult over time: CSS conflicts!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CSS conflicts can ruin your application</h1>
                </header>
            
            <article>
                
<p>What is a CSS conflict? Basically, when you import a CSS file into one of your components, it doesn't really limit it to one specific file; it gets added to the global CSS definitions instead. This means that if you define a particular style in one place, it might override or conflict with a totally different style in a different place. These style sheets get imported in some particular order, depending on how the code is loaded into your application overall, and everything ends up getting added to one big giant style sheet by the time your browser loads it all in.</p>
<p>As you can imagine, if everything is getting added to one gigantic file and there's no real differentiation between different files and how everything gets loaded, you will likely run into issues periodically where something that has been carelessly named ends up breaking everything!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A quick example of CSS conflicts</h1>
                </header>
            
            <article>
                
<p>The easiest way to understand this is to see it in action. For the most part, we were pretty smart and safe about how we named our CSS files, but we did run into one giant gotcha: our <kbd>Divider</kbd> component defines a global style for all <kbd>hr</kbd> tags, regardless of where they appear. Let's head back into <kbd>src/Todo.js</kbd>, and change our <kbd>render</kbd> function to place an <kbd>hr</kbd> tag in between the <kbd>description</kbd> and the <kbd>button</kbd>:</p>
<pre>  render() {<br/>    return (<br/>      &lt;div className={this.cssClasses()}&gt;<br/>        {this.state.description}<br/>        &lt;br /&gt;<br/>        &lt;hr /&gt;<br/>        &lt;button className="MarkDone" onClick={this.markAsDone}&gt;<br/>          Mark as Done<br/>        &lt;/button&gt;<br/>        &lt;button className="RemoveTodo" onClick={this.removeTodo}&gt;<br/>          Remove Me<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</pre>
<p>Note that we have not added any style at all to this yet! Save the file and reload it, and despite us having never defined a style for <kbd>hr</kbd> tags in the <kbd>Todo</kbd> component, we'll see that it has inherited the style of the <kbd>Divider</kbd> components! Refer to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-432 image-border" src="Images/bf59d40f-550b-4ba5-973d-c63e9e14e848.png" style="width:45.58em;height:38.83em;" width="724" height="616"/></p>
<p>But that's not what we wanted! While that's a pretty nice divider, maybe we want ours to have a different color! For the sake of comparison, we'll say that we want the dividers inside of the <kbd>Todo</kbd> component to be solid red lines but we want the other ones to stay the same. We'll add the following CSS to <kbd>src/Todo.css</kbd> to change our <kbd>hr</kbd> tag to red instead by changing the <kbd>border</kbd> color:</p>
<pre>hr {<br/>  border: 2px solid red;<br/>}</pre>
<p>Save and reload, and nothing happens? That's odd. The code is correct and it's definitely importing the CSS into our application correctly. Just as a sanity check, we'll change the <kbd>hr</kbd> tag to a <kbd>div</kbd> tag to make sure it adds a red border to our <kbd>Todo div</kbd> tags:</p>
<pre>div {<br/>  border: 2px solid red;<br/>}</pre>
<p>Save and reload, and you should now see this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2802b385-a015-45dd-a56c-db7730276c28.png" width="948" height="719"/></p>
<p>Yikes, that's not what we wanted! It's added borders to <em>every</em> <kbd>div</kbd> on the page instead of just the <kbd>div</kbd> tag in our <kbd>Todo</kbd> component! Well, at least we've figured out there's nothing weird with the code, it's just something with how the CSS is getting loaded. It's easy to fix; we'll just toss an <kbd>!important</kbd> flag on the end of our <kbd>src/Todo.css</kbd> file's <kbd>hr</kbd> definition and call it a day!</p>
<div class="packt_infobox">The <kbd>!important</kbd> flag is a way to force CSS to prioritize this directive over other directives. It's also a great way to make your application a living nightmare to maintain over time; avoid using this whenever you possibly can!</div>
<p>Back in <kbd>src/Todo.css</kbd>, we'll commit our CSS crime by tossing an <kbd>!important</kbd> flag at the end of the <kbd>hr</kbd> block:</p>
<pre>hr {<br/>  border: 2px solid red !important;<br/>}</pre>
<p>There we go! Save and reload, and we will see the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/265c16c5-e0be-4cba-9c41-73f10b60f2ba.png" width="1094" height="710"/></p>
<p>Now, we've ruined everything. Yikes! Hopefully our design team won't just completely disown us for this, right? They're really good at CSS, so they'll fix things! Well, they'll fix things after they're done yelling at us for botching the site's design inside of the code in a way that is incredibly difficult for a non-developer to track down.</p>
<p>The good news is that there is a different way to handle this situation in a way that works very well and prevents exactly this sort of scenario in the future! It is something that has been an absolute godsend to those of us that have been working on shared frontend development projects, which might have multiple different CSS files to have to search through to find the single CSS file that's causing a major design headache!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing CSS Modules</h1>
                </header>
            
            <article>
                
<p>The first of these are CSS Modules, and in Create React App 2 and higher, you don't need to do anything at all to start taking advantage of it immediately. CSS Modules give you the ability to modularize any CSS code that you import in a way that prevents introducing global, overlapping namespaces, despite the fact that the end result is still just one giant CSS file.</p>
<p>That being said, it's also not just going to immediately work in your project if you don't turn anything on or organize your code a little bit better. Right now, we've been placing all of our code directly into the <kbd>src/</kbd> directory, resulting in a scenario where the <kbd>root</kbd> folder is going to keep growing and growing over time until it gets so large and unwieldy that you'll never be able to find anything.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Better project organization</h1>
                </header>
            
            <article>
                
<p>Let's start off by cleaning up our directory structure in our project a little bit better. There are a million different ways to do this and, honestly, they all have their own merits and flaws. We're going to adopt a very simple structure right now since this project is not really going to be terribly large, so keeping things simple and building up is very easy to do with this structure. What we're going to do is just separate out each component that has CSS and JavaScript code into their own folders. We'll start off by creating <kbd>NewTodo</kbd>, <kbd>Todo</kbd>, <kbd>App</kbd>, <kbd>TodoList</kbd>, and <kbd>Divider</kbd> folders and placing all of their related code in each of those. We'll also need to create a new file in each of these directories called <kbd>index.js</kbd>, which will be responsible for only importing and exporting the appropriate component. For example, the <kbd>App</kbd> index file (<kbd>src/App/index.js</kbd>) will look like this:</p>
<pre>import App from "./App";<br/>export default App;</pre>
<p>The new index file of <kbd><span>Todo</span></kbd> (<kbd>src/Todo/index.js</kbd>) will look like this:</p>
<pre>import Todo from "./Todo";<br/>export default Todo;</pre>
<p>You can probably guess what the <span>index files</span> <kbd>NewTodo</kbd>, <kbd>TodoList</kbd>, and <kbd>Divider</kbd> will look like as well, based on this pattern!</p>
<p>Next, we'll need to change each place that these files are referenced to make it easier to import all of them. This will unfortunately be a little bit of grunt work, but we'll need to do it all the same to make sure we don't break anything in the process.</p>
<p>First, in <kbd>src/App/App.js</kbd>, change the <kbd>TodoList import</kbd> component to the following:</p>
<div>
<pre><span>import</span><span> </span><span>TodoList</span><span> </span><span>from</span><span> </span><span>"../TodoList"</span><span>;</span></pre></div>
<p>There's nothing we need to do for <kbd>Divider</kbd> since it is a component with no imports. <kbd>NewTodo</kbd> and <kbd>Todo</kbd> are of a similar type, so we can skip them as well. <kbd>src/TodoList/TodoList.js</kbd>, on the other hand, has a lot we need to deal with, since it's one of our highest-level components and imports a lot:</p>
<pre>import Todo from "../Todo";<br/>import NewTodo from "../NewTodo";<br/>import Divider from "../Divider";</pre>
<p>But that's not all. Our test file, <kbd>src/TodoList/TodoList.test.js</kbd>, also needs to be modified to include these new paths for our files or else our tests will fail! We'll need nearly the same list of imports as earlier:</p>
<pre>import TodoList from "./TodoList";<br/>import NewTodo from "../NewTodo";<br/>import Todo from "../Todo";</pre>
<p>Now, when you reload your application, your code should still be working just fine, your tests should all pass, and everything should be cleanly separated out! This makes our lives easier for a number of reasons, but when we're talking about working with other developers or designers, this makes things a godsend for them since they can figure out exactly what CSS to modify when they need to fix things up! Our full project structure should now look like this:</p>
<pre>src/<br/>  App/<br/>    App.css<br/>    App.js<br/>    App.test.js<br/>    index.js<br/>  Divider/<br/>    Divider.css<br/>    Divider.js<br/>    index.js<br/>  NewTodo/<br/>    NewTodo.css<br/>    NewTodo.js<br/>    NewTodo.test.js<br/>    index.js<br/>  Todo/<br/>    Todo.css<br/>    Todo.js<br/>    Todo.test.js<br/>    index.js<br/>  TodoList/<br/>    TodoList.css<br/>    TodoList.js<br/>    TodoList.test.js<br/>    index.js<br/>  index.css<br/>  index.js<br/>  setupTests.js<br/>  ... etc ...</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to use CSS Modules</h1>
                </header>
            
            <article>
                
<p class="mce-root">It's time for us to jump right into incorporating CSS Modules into our project. Right now, we haven't set up anything to start using CSS Modules, so we'll need to make a few changes to make this work. Think back to our <kbd>Todo</kbd> CSS conflict, where introducing some conflicting CSS namespaces and poor choices around the use of the <kbd>!important</kbd> flag introduced a nightmare situation. </p>
<p>Instead, let's start taking advantage of CSS Modules! We can actually mix the old way of doing things and the new way as well, but it'd be nice to take things a step further and use CSS Modules all the way. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing CSS Modules to our application</h1>
                </header>
            
            <article>
                
<p>If we want to use CSS Modules, there are a few simple guidelines that we need to follow. The first is that we need to name our files <kbd>[whatever].module.css</kbd>, instead of <kbd>[whatever].css</kbd>. The next thing we need to do is to make sure that our styles are named simply and are easy to reference. Let's start off by following these conventions and by renaming our CSS file for <kbd>Todo</kbd> as <kbd>src/Todo/Todo.module.css</kbd>, and then we'll change the contents a tiny bit:</p>
<pre>.todo {<br/>  border: 2px solid black;<br/>  text-align: center;<br/>  background: #f5f5f5;<br/>  color: #333;<br/>  margin: 20px;<br/>  padding: 20px;<br/>}<br/><br/>.done {<br/>  background: #f5a5a5;<br/>}</pre>
<div class="packt_infobox">CSS Module guidelines prefer that you use <strong>camelCase</strong> for naming conventions, so <kbd>Done</kbd> and <kbd>Todo</kbd> will become <kbd>done</kbd> and <kbd>todo</kbd>, respectively. Something like <kbd>NewTodo</kbd> will instead become <kbd>newTodo</kbd> as well!</div>
<p>Next, we'll open up <kbd>src/Todo/Todo.js</kbd> to take advantage of CSS Modules instead. We created a helper function in our <kbd>Todo</kbd> component called <kbd>cssClasses()</kbd>, which returns the styles we should be using in our component, and there's not much we need to change to make this all work exactly the same as earlier. We'll need to change our <kbd>import</kbd> statement at the top as well, since we renamed the file and are changing how our CSS is getting loaded into our code! Take a look at the following:</p>
<pre>import styles from "./Todo.module.css";</pre>
<p>This enables our code to take advantage of any class names defined in <kbd>Todo.module.css</kbd> by referencing them as <kbd>styles.[className]</kbd>. For example, in the previous file, we defined two CSS class names: <kbd>todo</kbd> and <kbd>done</kbd>, so we can now reference them in our component via <kbd>styles.Todo</kbd> and <kbd>styles.done</kbd>. We'll need to change the <kbd>cssClasses()</kbd> function to use this, so let's make those exact changes now. In <kbd>src/Todo/Todo.js</kbd>, our <kbd>cssClasses()</kbd> function should now read as follows:</p>
<pre>  cssClasses() {<br/>    let classes = [styles.todo];<br/>    if (this.state.done) {<br/>      classes = [...classes, styles.done];<br/>    }<br/>    return classes.join(' ');<br/>  }</pre>
<p>Save and reload, and our application should be back to normal! There's more we can do here, though, so let's return back to our conflict scenario. If you remember, the problem was that we needed to be able to change the <kbd>hr</kbd> tags inside of the <kbd>todo</kbd> components to have their own styles and effects, but not affect everything else and also not have to use the <kbd>!important</kbd> flag if we can avoid it. Head back into <kbd>src/Todo/Todo.module.css</kbd> and add the following block for our <kbd>hr</kbd> tag, which we'll give a new class of <kbd>redDivider</kbd>:</p>
<pre>.redDivider {<br/>  border: 2px solid red;<br/>}</pre>
<p>And finally, return back to our <kbd>render()</kbd> function in <kbd>src/Todo/Todo.js</kbd>, and change our <kbd>render()</kbd> function's <kbd>hr</kbd> tag inclusion to the following:</p>
<pre>&lt;hr className={styles.redDivider} /&gt;</pre>
<p>Save and reload, and now we should have fully compartmentalized CSS code without worrying about collisions and global namespaces! Refer to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6edde697-239e-44ab-9fda-3b568ca992f6.png" width="1061" height="621"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composability with CSS Modules</h1>
                </header>
            
            <article>
                
<p>That's not all that CSS Modules give us, although it's certainly one of the great parts of CSS Modules that we get immediately and with no fuss (seriously, we wrote zero configuration to make all of it happen; it was all just code). We also get CSS composability, which is the ability to inherit CSS classes off of other classes, whether they're in the main file or not! This can be incredibly useful when you're setting up more complicated nested components that all need to handle slightly different style sheets, but are not wildly different from each other. Let's say we want to have the ability to mark some components as <kbd>critical</kbd> instead of just regular Todos.</p>
<p>We don't want to change too much about the component; we want it to inherit the same basic rules as all of the other Todos. We'll need to set up some code to make this happen. Back in <kbd>src/Todo/Todo.js</kbd>, we're going to make some modifications to allow a new state property of <kbd>critical</kbd>. We'll start off in the <kbd>constructor</kbd> component, where we'll add our new <kbd>state</kbd> property and a <kbd>bind</kbd> tag for a function:</p>
<pre>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      done: false,<br/>      critical: false<br/>    };<br/><br/>    this.markAsDone = this.markAsDone.bind(this);<br/>    this.removeTodo = this.removeTodo.bind(this);<br/>    this.markCritical = this.markCritical.bind(this);<br/>  }</pre>
<p>We add a new <kbd>critical</kbd> property in our <kbd>state</kbd> property, set it to a default value of <kbd>false</kbd>, and then we also reference a function (which we haven't written yet) called <kbd>markCritical</kbd>, and we bind <kbd>this</kbd>, since we'll be using it in an event handler later. Next, we'll tackle the <kbd>markCritical()</kbd> function:</p>
<pre>  markCritical() {<br/>    this.setState({ critical: true });<br/>  }</pre>
<p>We'll also need to modify our <kbd>cssClasses()</kbd> function so that it can react to this new <kbd>state</kbd> property. To demonstrate the composability function of CSS Modules, we'll set it so that <kbd>classes</kbd> is originally an empty array, and then the first item either becomes <kbd>critical</kbd> or <kbd>todo</kbd>, depending on whether or not the item is marked as <kbd>critical</kbd>:</p>
<pre>  cssClasses() {<br/>    let classes = [];<br/>    if (this.state.critical) {<br/>      classes = [styles.critical];<br/>    } else {<br/>      classes = [styles.todo];<br/>    }<br/>    if (this.state.done) {<br/>      classes = [...classes, styles.done];<br/>    }<br/>    return classes.join(' ');<br/>  }</pre>
<p>And finally, in our <kbd>render</kbd> function, we'll create the <kbd>button</kbd> tag to mark items as <kbd>critical</kbd>:</p>
<pre>  render() {<br/>    return (<br/>      &lt;div className={this.cssClasses()}&gt;<br/>        {this.props.description}<br/>        &lt;br /&gt;<br/>        &lt;hr className={styles.hr} /&gt;<br/>        &lt;button className="MarkDone" onClick={this.markAsDone}&gt;<br/>          Mark as Done<br/>        &lt;/button&gt;<br/>        &lt;button className="RemoveTodo" onClick={this.removeTodo}&gt;<br/>          Remove Me<br/>        &lt;/button&gt;<br/>        &lt;button className="MarkCritical" onClick={this.markCritical}&gt;<br/>          Mark as Critical<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</pre>
<p>We're not quite done yet, although we're at least 90% of the way there. We'll also want to go back to <kbd>src/Todo/Todo.module.css</kbd> and add a new block for the <kbd>critical</kbd> class name, and we'll use our composable property as well:</p>
<pre>.critical {<br/>  composes: todo;<br/>  border: 4px dashed red;<br/>}</pre>
<p>To use composition, all you need to do is add a new CSS property called <kbd>composes</kbd> and give it a class name (or multiple class names) that you want it to compose. Compose, in this case, is a fancy way of saying that it inherits the behavior of the other class names and allows you to override others. In the previous case, we're saying <kbd>critical</kbd> is a CSS module class that is composed of a <kbd>todo</kbd> model as the base, and adds a <kbd>border</kbd> component of a big red dashed line since, well, we'll just say that this means it is <kbd>critical</kbd>. This previous code is the equivalent of us writing out the following:</p>
<pre>.critical {<br/>  text-align: center;<br/>  background: #f5f5f5;<br/>  color: #333;<br/>  margin: 20px;<br/>  padding: 20px;<br/>  border: 4px dashed red;<br/>}</pre>
<p>Save and reload, as always, and you should be able to mark items as <span class="packt_screen">Mark as Done</span>, <span class="packt_screen">Mark as Critical</span>, or both, or remove them by clicking <span class="packt_screen">Remove Me</span>, as in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4ab9c5a0-878d-4c4a-a005-513f59d21cec.png" width="1071" height="695"/></p>
<p>And that about covers it for our brief introduction to CSS Modules! There's certainly more that you could cover over time, but this is more intended to be a quickstart guide and we could probably fill up a second book just on CSS techniques and libraries!</p>
<p>Before you move on, you'll also want to quickly update your snapshots for your tests by hitting <em>U</em> in the <kbd>yarn test</kbd> screen!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing SASS to our project</h1>
                </header>
            
            <article>
                
<p>That's not all that the Create React App added support for as part of Create React App 2! By very popular demand, the Create React App team added in support for SASS pre-processing as well! Often, you'd pretty much be guaranteed that you'd need to eject your project as soon as you wanted to start working with any SASS in your project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is SASS?</h1>
                </header>
            
            <article>
                
<p>Let's talk a little bit about what SASS actually is, since it's a pretty important thing to cover. Otherwise, you'd have no connection to why this is worth the effort (even though, to be fair, it is very little effort to integrate into your Create React App projects). SASS is essentially CSS with extended feature support. When I say <em>extended feature support</em> here, though, I mean it! SASS supports the following <span>feature set, which is</span> missing in CSS, and which includes the following:</p>
<ul>
<li>Variables</li>
<li>Nesting</li>
<li>Partial CSS files</li>
<li>Import support</li>
<li>Mixins</li>
<li>Extensions and inheritance</li>
<li>Operators and calculations</li>
</ul>
<p>This feature set alone makes including SASS worth it on nearly any complicated frontend project that you might be working with, and honestly after using SASS for a long time and then not having it, it's hard to ever want to go back to vanilla CSS. So, let's start getting some SASS into our project!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing and configuring SASS</h1>
                </header>
            
            <article>
                
<p>The good news is that getting SASS support working in a Create React App project is incredibly simple! We first need to install it via <kbd>yarn</kbd>, or <kbd>npm</kbd> first. We've used <kbd>yarn</kbd> for everything else so we'll stick to it:</p>
<pre><strong>$ yarn add node-sass</strong></pre>
<p>We'll see a <em>ton</em> of output from it, but assuming there are no errors and everything goes well, we should be able to restart our development server and get started with some SASS. Let's create a more general utility SASS file that will be responsible for storing standardized colors that we'll want to use throughout our application, and something to store that neat gradient <kbd>hr</kbd> pattern in case we want to use it elsewhere.</p>
<p>We'll also change some of the colors that we're using so that there is some red, green, and blue, depending on whether the item is critical, done, or neither, respectively. In addition, we'll need to change up our project a little bit and add a new file to have a concept of some shared styles and colors. So, let's begin:</p>
<ol>
<li>Create a new file, <kbd>src/shared.scss</kbd>, in our project and give it the following body:</li>
</ol>
<pre style="padding-left: 60px">$todo-critical: #f5a5a5;<br/>$todo-normal: #a5a5f5;<br/>$todo-complete: #a5f5a5;<br/>$fancy-gradient: linear-gradient(<br/>  to right,<br/>  rgba(0, 0, 0, 0),<br/>  rgba(0, 0, 0, 0.8),<br/>  rgba(0, 0, 0, 0)<br/>);</pre>
<ol start="2">
<li>Next, hop over to <kbd>src/Divider/Divider.css</kbd> and rename the file to <kbd>src/Divider/Divider.scss</kbd>. Next, we'll change the reference to <kbd>Divider.css</kbd> in <kbd>src/Divider/Divider.js</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">import "./Divider.scss";</pre>
<ol start="3">
<li>Now we'll need to change up the code in <kbd>Divider.scss</kbd> to import in our shared variables file and use a variable as part of it:</li>
</ol>
<pre style="padding-left: 60px">@import "../shared";<br/><br/>hr {<br/>  border: 0;<br/>  height: 1px;<br/>  background-image: $fancy-gradient;<br/>}</pre>
<p style="padding-left: 60px">So, we import in our new shared SASS file in <kbd>src/</kbd>, and then the <kbd>background-image</kbd> value just references the <kbd>$fancy-gradient</kbd> variable that we created, which means we can now recreate that fancy gradient whenever we need to without having to rewrite it over and over!</p>
<ol start="4">
<li>Save and reload, and you should see that nothing major has changed!</li>
</ol>
<p>This is a pretty good example of introducing SASS where it just replaces our standard CSS, but what about when we start to introduce CSS Modules?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixing SASS and CSS Modules</h1>
                </header>
            
            <article>
                
<p>The good news is that it's basically no more complicated to introduce SASS to CSS Modules in Create React App. In fact, the steps are borderline identical! So, if we want to start mixing the two, all we need to do is rename some files and change how our imports are handled. Let's see this in action:</p>
<ol>
<li>First, head back to our <kbd>src/Todo/Todo.module.css</kbd> file and make a very minor modification. Specifically, let's rename it <kbd>src/Todo/Todo.module.scss</kbd>. Next, we need to change our <kbd>import</kbd> statement in <kbd>src/Todo/Todo.js</kbd>, otherwise the whole thing will fall apart:</li>
</ol>
<div>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>styles</span><span> </span><span>from</span><span> </span><span>"./Todo.module.scss"</span><span>;</span></pre></div>
<ol start="2">
<li>Now, we should have our SASS working for CSS Modules with the <kbd>Todo</kbd> component, so let's start taking advantage of it. Again, we'll need to <kbd>import</kbd> our <kbd>shared</kbd> file into this SASS file as well. Note the following back in <kbd>src/Todo/Todo.module.scss</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@import '../shared';</pre>
<ol start="3">
<li>Next, we'll need to start changing the references to our various background colors. We'll change the background for regular Todos to <kbd>$todo-normal</kbd>. Then, we'll change the finished <kbd>Todo</kbd> background to <kbd>$todo-complete</kbd>. Finally, we'll want to change the <kbd>critical</kbd> items to <kbd>$todo-critical</kbd>:</li>
</ol>
<pre style="padding-left: 60px">.todo {<br/>  border: 2px solid black;<br/>  text-align: center;<br/>  background: $todo-normal;<br/>  color: #333;<br/>  margin: 20px;<br/>  padding: 20px;<br/>}<br/><br/>.done {<br/>  background: $todo-complete;<br/>}<br/><br/>.hr {<br/>  border: 2px solid red;<br/>}<br/><br/>.critical {<br/>  composes: todo;<br/>  background: $todo-critical;<br/>}</pre>
<ol start="4">
<li>Save and reload our project, and let's make sure the new color scheme is being respected:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ffbf312e-50cd-4e47-bfb7-6cb0615af6ab.png" width="1050" height="684"/></p>
<p>Honestly, everything beyond this point is just diving deeper and deeper into SASS-specific syntax, and again, that falls pretty far outside of the scope of this book. As you can see from the preceding screenshot though, we were able to introduce SASS into our CSS Modules code with no real complications.</p>
<p>Even better, we've now introduced a new way to change themes and skins in our project without a ton of extra work, and if our designers ever want to run in and change, for example, the backgrounds of all of the Todos and change the general color scheme, they can do so by running into the <kbd>shared.scss</kbd> file quickly and making a few color changes, and not having to change much else!</p>
<p>We can keep the lovely code modularity and developer-centric features of CSS Modules and SASS, but also provide nice inlets into our code to allow designers and other non-developers to modify the design and style elements where necessary! Even better, our code gets easier to maintain with the addition of two new features instead of making our project exponentially more complicated!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding CSS frameworks</h1>
                </header>
            
            <article>
                
<p>A very common use case that you'll run into as part of working on a frontend project is integrating some sort of third-party CSS framework. This is something I've had to do on nearly every frontend development project I've ever touched, and there's pretty good odds that you'll need to run through this same process!</p>
<p>We'll stick to one of the most common ones, since it will give you a good introduction to using frameworks in general, so we'll start off by integrating bootstrap into our project! It won't take much for our project to go from sort of ugly to actually kind of decent! As with most other things we've run into as part of our development process with Create React App, this is equally simple for us to implement! We'll start off by adding both <kbd>bootstrap</kbd> to our project and <kbd>reactstrap</kbd>, which is a pre-made React component that takes full advantage of Twitter Bootstrap!</p>
<p>We'll start by adding <kbd>bootstrap</kbd>, and <kbd>reactstrap</kbd>, via <kbd>yarn</kbd>:</p>
<pre><strong>$ yarn add bootstrap@4 reactstrap@6.5.0</strong></pre>
<div class="packt_infobox">Right now, if you use <kbd>bootstrap</kbd> at version 4.x, you'll need to include <kbd>reactstrap</kbd>, but at 6.5.x to avoid error messages!</div>
<p>We should see a bunch of things get installed in our project folder, but hopefully no errors! After everything is successfully installed, we can then get the baseline <kbd>bootstrap</kbd> into our project by opening up <kbd>src/index.js</kbd> and adding a single <kbd>import</kbd> statement:</p>
<pre><span class="hljs-keyword">import</span><span> </span><span class="hljs-string">'bootstrap/dist/css/bootstrap.css'</span><span>;</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cleaning up our design, starting with the header</h1>
                </header>
            
            <article>
                
<p>Next, let's clean up our ugly header, which will also require us to remove some of the code we wrote earlier to experiment with JavaScript syntax! Currently, our <kbd>header</kbd> is our own pre-rolled thing but it's not very good-looking as it is right now. We'll want to take advantage of the <kbd>Navbar</kbd> and <kbd>NavbarBrand</kbd> components that <kbd>reactstrap</kbd> provides to us as part of its standard exports! Open up <kbd>src/App/App.js</kbd>, and we're going to start modifying the file pretty significantly:</p>
<ol>
<li>We'll start off by adding our <kbd>Navbar</kbd> and <kbd>NavbarBrand</kbd> imports at the top:</li>
</ol>
<pre style="padding-left: 60px">import { Navbar, NavbarBrand } from "reactstrap";</pre>
<ol start="2">
<li>Next, we can remove all of the <kbd>header</kbd> configuration objects, since we won't need any of them after we're done editing this file. Instead, we'll just replace it with a single <kbd>headerTitle</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">const headerTitle = "Todoifier";</pre>
<ol start="3">
<li>Next, we'll need to replace our <kbd>headerDisplay</kbd> function, since it is going to be using the new <kbd>reactstrap</kbd> component instead of the previous code we had in place:</li>
</ol>
<pre style="padding-left: 60px">const headerDisplay = (title) =&gt; (<br/>  &lt;Navbar color="dark" dark expand="md"&gt;<br/>    &lt;NavbarBrand href="/"&gt;{title}&lt;/NavbarBrand&gt;<br/>  &lt;/Navbar&gt;<br/>);</pre>
<p style="padding-left: 60px">Notice that, now, <kbd>header</kbd> only accepts a passed-in title instead of the huge configuration object we were using earlier. This simplifies our code pretty significantly! We'll also need to change the call in our <kbd>App</kbd> component to our <kbd>header</kbd> function:</p>
<pre style="padding-left: 60px">const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    {headerDisplay(headerTitle)}<br/>    &lt;br /&gt;<br/>    &lt;TodoList /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<ol start="4">
<li>Save it and we should have a significantly cleaner <kbd>header</kbd> in our project! Refer to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d479e17f-4bd0-49d6-b0ef-6de690a14d0d.png" width="988" height="152"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cleaning up the NewTodo component</h1>
                </header>
            
            <article>
                
<p>We'll also want to clean up our <kbd>NewTodo</kbd> component, since it is pretty bare bones right now! We'll basically want to update anywhere a <kbd>Button</kbd> or <kbd>Input</kbd> function appears in our code to make sure our app has a clean, consistent design all over the place!</p>
<ol>
<li>First, at the top of <kbd>src/NewTodo/NewTodo.js</kbd>, we'll want to add our <kbd>reactstrap</kbd> imports! We'll need <kbd>Button</kbd>, <kbd>Input</kbd>, and <kbd>InputGroup</kbd>, so let's add them as our named imports from <kbd>reactstrap</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import { Button, Input, InputGroup } from "reactstrap";</pre>
<ol start="2">
<li>Next, we'll need to clean up the text <kbd>Input</kbd> and <kbd>Button</kbd> display properly, so let's wrap our text field and <kbd>Button</kbd> inside of an <kbd>InputGroup</kbd> component to keep them together! We'll change the text <kbd>Input</kbd> to the <kbd>reactstrap Input</kbd> component and the <kbd>Button</kbd> tag to a <kbd>reactstrap Button</kbd> component as well, and we'll add a <kbd>placeholder</kbd> text for our input item. Also, note that we're setting a new property on our <kbd>Button</kbd> tag called <kbd>color,</kbd> which is set to <kbd>"primary"</kbd>. This gives us a blue button instead of the default ugly grey button! Our <kbd>render()</kbd> function should now look like this:</li>
</ol>
<pre style="padding-left: 60px">  render() {<br/>    return (<br/>      &lt;div className="NewTodo"&gt;<br/>        &lt;InputGroup&gt;<br/>          &lt;Input<br/>            type="text"<br/>            onChange={this.handleUpdate}<br/>            value={this.state.item}<br/>            placeholder="Input item name here..."<br/>          /&gt;<br/>          &lt;Button onClick={this.addTodo} <br/>          color="primary"&gt;Add&lt;/Button&gt;<br/>        &lt;/InputGroup&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</pre>
<ol start="3">
<li>Save and reload, and our input should look much nicer; something like the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1f9d00cf-2ca8-45e7-9be4-978f9f6c4131.png" width="981" height="288"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cleaning up our Todo component</h1>
                </header>
            
            <article>
                
<p>Our <kbd>Todo</kbd> components still look a little ugly, so let's also give them the same treatment. After this, we'll be in a good enough place to call it quits with making our project look a little nicer, but to get there we'll need some more imports:</p>
<ol>
<li>We'll need to <kbd>import</kbd>, <kbd>Button</kbd>, and <kbd>ButtonGroup</kbd> to our <kbd>Todo</kbd> components, since the only things we'll want to clean up are our buttons! To do so, use the following code, adding it to <kbd>src/Todo/Todo.js</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import { Button, ButtonGroup } from "reactstrap";</pre>
<ol start="2">
<li>Next, hop right on down to the <kbd>render()</kbd> function in <kbd>src/Todo/Todo.js</kbd>, where we'll wrap our buttons inside of a <kbd>ButtonGroup</kbd> component, and change each of the <kbd>button</kbd> tags to <kbd>Button</kbd> components:</li>
</ol>
<pre style="padding-left: 60px">  render() {<br/>    return (<br/>      &lt;div className={this.cssClasses()}&gt;<br/>        {this.props.description}<br/>        &lt;br /&gt;<br/>        &lt;hr className={styles.hr} /&gt;<br/>        &lt;ButtonGroup&gt;<br/>          &lt;Button className="MarkDone" onClick={this.markAsDone}<br/>          color="success"&gt;<br/>            Mark as Done<br/>          &lt;/Button&gt;<br/>          &lt;Button className="RemoveTodo" onClick={this.removeTodo}<br/>          color="warning"&gt;<br/>            Remove Me<br/>          &lt;/Button&gt;<br/>          &lt;Button className="MarkCritical" onClick={this.markCritical}  <br/>           color="danger"&gt;<br/>            Mark as Critical<br/>          &lt;/Button&gt;<br/>        &lt;/ButtonGroup&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</pre>
<ol start="3">
<li>Save and reload, and we should now see our project looking like this instead:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e4a94cf8-dba5-478b-9f82-2106e73be7bb.png" width="1105" height="809"/></p>
<p>One thing we haven't fixed yet are our tests! We should now see a large number of failing tests, so we'll need to go in and fix them specifically!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making our tests pass again</h1>
                </header>
            
            <article>
                
<p>Since we've changed a bunch of <kbd>input</kbd> and <kbd>button</kbd> tags and we have tests that are specifically looking for them, we'll need to hop into <kbd>src/NewTodo/NewTodo.test.js</kbd> first, and change every instance of <kbd>.find("input")</kbd> and <kbd>.find("button")</kbd> to <kbd>.find("Input")</kbd>, and <kbd>.find("Button")</kbd>. We'll start with our first test, which tests the form:</p>
<pre>  it("contains the form", () =&gt; {<br/>    expect(component.find("Input")).toHaveLength(1);<br/>    expect(component.find("Button")).toHaveLength(1);<br/>  });</pre>
<p>We'll also want to modify the next test that relies on simulating <kbd>button</kbd> clicks:</p>
<pre>  it("calls the passed in addTodo function when add button is clicked", () =&gt; {<br/>    component.find("Button").simulate("click");<br/>    expect(mockAddTodo).toBeCalled();<br/>  });</pre>
<p>We're almost done with this file! We have one more place where we're attempting to simulate a <kbd>button</kbd> click, so we'll need to clean up that test too! We can do this as follows:</p>
<pre>  it("blanks out the Todo Name when the button is clicked", () =&gt; {<br/>    const updateKey = "I should be empty";<br/>    component.instance().handleUpdate({ target: { value: updateKey } });<br/>    expect(component.state("item")).toEqual(updateKey);<br/>    component.find("Button").simulate("click");<br/>    expect(component.state("item")).toHaveLength(0);<br/>  });</pre>
<p>After saving and reloading, we should see fewer failed tests and can then move on to the next test suite that's failing! We can do this as follows:</p>
<pre><strong> FAIL src/Todo/Todo.test.js</strong><br/><strong>  - Todo › marks the Todo as done</strong><br/><br/><strong>    Method “simulate” is meant to be run on 1 node. 0 found instead.</strong><br/><br/><strong>      34 |</strong><br/><strong>      35 | it("marks the Todo as done", () =&gt; {</strong><br/><strong>    &gt; 36 | component.find("button.MarkDone").simulate("click");</strong><br/><strong>         | ^</strong><br/><strong>      37 | expect(component.state("done")).toEqual(true);</strong><br/><strong>      38 | });</strong><br/><strong>      39 |</strong><br/><br/><strong>      at ShallowWrapper.single (node_modules/enzyme/build/ShallowWrapper.js:1875:17)</strong><br/><strong>      at ShallowWrapper.simulate (node_modules/enzyme/build/ShallowWrapper.js:1080:21)</strong><br/><strong>      at Object.simulate (src/Todo/Todo.test.js:36:39)</strong><br/><br/><strong>  - Todo › calls the mock remove function</strong><br/><br/><strong>    Method “simulate” is meant to be run on 1 node. 0 found instead.</strong><br/><br/><strong>      39 |</strong><br/><strong>      40 | it("calls the mock remove function", () =&gt; {</strong><br/><strong>    &gt; 41 | component.find("button.RemoveTodo").simulate("click");</strong><br/><strong>         | ^</strong><br/><strong>      42 | expect(mockRemoveTodo).toHaveBeenCalled();</strong><br/><strong>      43 | });</strong><br/><strong>      44 | });</strong><br/><br/><strong>      at ShallowWrapper.single (node_modules/enzyme/build/ShallowWrapper.js:1875:17)</strong><br/><strong>      at ShallowWrapper.simulate (node_modules/enzyme/build/ShallowWrapper.js:1080:21)</strong><br/><strong>      at Object.simulate (src/Todo/Todo.test.js:41:41)</strong><br/><br/><strong> PASS src/TodoList/TodoList.test.js</strong><br/><strong> PASS src/App/App.test.js</strong><br/><br/><strong>Test Suites: 1 failed, 3 passed, 4 total</strong><br/><strong>Tests: 2 failed, 19 passed, 21 total</strong></pre>
<p>From the previous code snippet, we can see that the other failing test suite is in <kbd>src/Todo/Todo.test.js</kbd>, so let's fix that up too in the same way! Scroll to the very bottom of the file and change the two failing tests that are looking for <kbd>button</kbd> tags instead of <kbd>Button</kbd> components:</p>
<pre>  it("marks the Todo as done", () =&gt; {<br/>    component.find("Button.MarkDone").simulate("click");<br/>    expect(component.state("done")).toEqual(true);<br/>  });<br/><br/>  it("calls the mock remove function", () =&gt; {<br/>    component.find("Button.RemoveTodo").simulate("click");<br/>    expect(mockRemoveTodo).toHaveBeenCalled();<br/>  });</pre>
<p>Save the file, and when the tests come back up (you may have to hit <em>U</em> to update the <kbd>Snapshots</kbd> as well, don't forget), we should see a fully green test suite again, as follows:</p>
<pre><strong> PASS src/Todo/Todo.test.js</strong><br/><strong> PASS src/NewTodo/NewTodo.test.js</strong><br/><strong> PASS src/App/App.test.js</strong><br/><strong> PASS src/TodoList/TodoList.test.js</strong><br/><br/><strong>Test Suites: 4 passed, 4 total</strong><br/><strong>Tests: 21 passed, 21 total</strong><br/><strong>Snapshots: 3 passed, 3 total</strong><br/><strong>Time: 4.386s</strong><br/><strong>Ran all test suites.</strong><br/><br/><strong>Watch Usage: Press w to show more.</strong></pre>
<p>We're <em>almost</em> there, but remember the new functionality that we added to our project to mark certain <kbd>Todo</kbd> items as <kbd>critical</kbd>? We never added new tests for it! The good news is that there's only one more test we need to write for it!</p>
<p>This test should be almost identical to the test for seeing when <kbd>Todo</kbd> items are clicked and marked as done; except, this time, we're looking for the <kbd>Mark Critical</kbd> button, where we'll simulate a click on that button. After the button is clicked, we should expect to see the <kbd>critical</kbd> property on the <kbd>state</kbd> of the <kbd>component</kbd> change from <kbd>false</kbd> to <kbd>true</kbd>, which also means we'll start off with a sanity check in our test to make sure the <kbd>critical</kbd> property starts off <kbd>false</kbd> <em>before</em> we click on the button, and ends as <kbd>true</kbd> after the button click! This is as follows:</p>
<pre> it("marks the Todo as critical", () =&gt; {<br/> expect(component.state("critical")).toEqual(false);<br/> component.find("Button.MarkCritical").simulate("click");<br/> expect(component.state("critical")).toEqual(true);<br/> });</pre>
<div class="packt_tip">Get into the habit of writing these sanity checks in your tests, as they will help you avoid writing tests that mistakenly assume default states and lead to useless tests in the future!</div>
<p>That's it! Our design is clean, our test suite is green, and our project is moving forward at an awesome pace! We'll rerun our test suite again just to make sure that everything is still green, but if it is, then we can safely move on to the next challenge:</p>
<pre><strong> PASS src/NewTodo/NewTodo.test.js</strong><br/><strong> PASS src/TodoList/TodoList.test.js</strong><br/><strong> PASS src/Todo/Todo.test.js</strong><br/><strong> PASS src/App/App.test.js</strong><br/><br/><strong>Test Suites: 4 passed, 4 total</strong><br/><strong>Tests: 22 passed, 22 total</strong><br/><strong>Snapshots: 3 passed, 3 total</strong><br/><strong>Time: 4.969s</strong><br/><strong>Ran all test suites.</strong><br/><br/><strong>Watch Usage: Press w to show more.</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We've added some nice new functionality to our project but didn't really have to engage in a lot of the headache and setup (and heartache, I suppose) that comes with adding two new CSS processors to our project! We have CSS Modules and SASS playing nicely in our Create React App project and have had to install a single new dependency. We have them playing nicely <em>together</em> even, which is an even greater achievement!</p>
<p>We've cleaned up our code a little bit and started grouping things together, and introduced concepts such as shared SASS files to store variables for colors and values, which allows us to change a color, for example, in one place and have it affect everywhere the variable appears!</p>
<p>Our code is cleaner, our designer is happy, we're happy, and we can continue to push forward on our project without having to slow down. We've never had to dive into configuration files, or do anything much more complicated than installing a dependency! This is yet another massive win in favor of Create React App!</p>
<p>In the next chapter, we'll dive into how to build a simulated backend to your frontend project via Create React App's incredibly nice proxy API functionality!</p>


            </article>

            
        </section>
    </div>



  </body></html>