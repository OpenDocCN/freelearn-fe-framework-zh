- en: Chapter 6. Keeping Up with Activities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。跟上活动
- en: In this chapter, we'll build an activity log in our task management system using
    **Scalable Vector Graphics** (**SVG**) to build graphical components using Angular.
    SVG is the perfect candidate when it comes to complex graphical content, and using
    Angular components, we can build nicely encapsulated and reusable content.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**可缩放矢量图形**（**SVG**）和Angular构建图形组件，在我们的任务管理系统中构建活动日志。SVG是处理复杂图形内容的理想选择，通过使用Angular组件，我们可以构建封装良好且可重用的内容。
- en: Since we want to log all the activities within our application, such as adding
    comments or renaming tasks, we are going to create a central repository. We can
    then display these activities and render them as an activity timeline using SVG.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在应用程序中记录所有活动，例如添加评论或重命名任务，我们将创建一个中央存储库。然后我们可以显示这些活动，并使用SVG将它们渲染为活动时间线。
- en: To add an overview of all the activities and to provide a user input to narrow
    the range of displayed activities, we're going to create an interactive slider
    component. This component will use a projection to render timestamps, in the form
    of ticks and activities, directly onto the slider's background. We'll also use
    SVG to render the elements within the component.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加所有活动的概述并提供用户输入以缩小显示活动的范围，我们将创建一个交互式滑块组件。此组件将使用投影将时间戳以刻度和活动形式直接渲染到滑块的背景上。我们还将使用SVG在组件内部渲染元素。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: A basic introduction to SVG
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG的基本介绍
- en: Making SVG composable with Angular components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使SVG与Angular组件可组合
- en: Using namespaces in component templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件模板中使用命名空间
- en: Creating a simple pipe to format calendar times using Moment.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的管道，使用Moment.js格式化日历时间
- en: Using the `@HostListener` annotations to handle user input events to create
    an interactive slider element
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@HostListener`注解处理用户输入事件以创建交互式滑块元素
- en: Making use of Shadow DOM using `ViewEncapsulation.Native` in order to create
    native-style encapsulation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ViewEncapsulation.Native`来利用Shadow DOM创建原生风格的封装
- en: Creating a service for logging activities
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建活动日志服务
- en: The goal of this chapter is to provide a way to keep track of all user activities
    within the task management application. For this purpose, we'll need a system
    that will allow us to log activities within components and to access already logged
    activities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是提供一个方法来跟踪任务管理应用程序中的所有用户活动。为此，我们需要一个系统，允许我们在组件内记录活动并访问已记录的活动。
- en: 'Activities, as entities, should be quite generic and should have the following
    fields with their respective purposes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实体，活动应该是相当通用的，并应具有以下字段及其相应用途：
- en: '**Subject**: This field should be used to reference the subject of the activity.
    This can be any identifier that identifies a foreign entity. In the context of
    projects, we''ll store the project ID in this field. Services and components that
    use the activity service should use this field to filter specific activities further.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：此字段应用于引用活动的主题。这可以是任何标识符，用于识别外部实体。在项目上下文中，我们将在此字段中存储项目ID。使用活动服务的服务和组件应使用此字段进一步筛选特定活动。'
- en: '**Category**: This field provides an additional way of tagging the activity
    further. For projects, we will currently use two categories: *comments* and *tasks*.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：此字段提供了一种额外的标记活动的方法。对于项目，我们目前将使用两个类别：*评论*和*任务*。'
- en: '**Title**: This refers to the title of the activity that will provide a very
    brief summary of what the activity is about. This could be something like *New
    task was added* or *Comment was deleted*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：这指的是活动的标题，将提供关于活动内容的简要总结。这可能像*新任务已添加*或*评论已删除*这样的内容。'
- en: '**Message**: This is the field where the real beef of the activity goes into.
    It should contain enough information to provide good traceability of what happened
    during the activity.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：这是活动真正内容所在字段。它应包含足够的信息，以便在活动期间提供良好的可追溯性。'
- en: 'In order to develop our system, we''ll create a new file named `activity-service.js`
    under the `activities/activity-service` path in our `lib` folder. In this file,
    we will create our activity service class, which we''re enabling for dependency
    injection, by using the `@Injectable` annotation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发我们的系统，我们将在`lib`文件夹下的`activities/activity-service`路径下创建一个名为`activity-service.js`的新文件。在此文件中，我们将创建我们的活动服务类，通过使用`@Injectable`注解来启用依赖注入：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the constructor of our activity service, we've subscribed to changes to our
    data store and have filtered any incoming change by type so we will only receive
    activity updates.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们活动服务的构造函数中，我们订阅了数据存储的变化，并按类型过滤了任何传入的变化，这样我们只会收到活动更新。
- en: Since activities can't be edited or deleted, we only need to be concerned about
    newly added activities. We update the internal array of activities with any added
    activity in the subscription. This way, we'll not only receive all the initial
    activities, but also the activities that are subsequently added directly from
    the data store. Other services and components can then directly access the activity
    list of the system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于活动不能被编辑或删除，我们只需要关注新添加的活动。我们在订阅中更新活动的内部数组，以包含任何添加的活动。这样，我们不仅会收到所有初始活动，还会收到直接从数据存储中添加的活动。其他服务和组件可以随后直接访问系统的活动列表。
- en: In order for other application components to react to changes in the activity
    list, we've exposed a `ReplaySubject` observable on the `change` member field.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让其他应用程序组件对活动列表的变化做出反应，我们在`change`成员字段上公开了一个`ReplaySubject`可观察对象。
- en: In the `logActivity` method, we've simply added a new activity to the data store.
    `UserService` will provide us with information on the currently logged-in user,
    and we can use `DataProvider` to write to the data store.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`logActivity`方法中，我们只是简单地将一个新的活动添加到数据存储中。`UserService`将为我们提供有关当前登录用户的信息，我们可以使用`DataProvider`将数据写入数据存储。
- en: 'So, we have created a simple platform that will help us keep track of activities
    within our application. Since we want only one instance of `ActivityService` within
    our application, let''s add it to the `providers` list on our root `App` component.
    You''ll find this component in the `app.js` file, located within our `lib` folder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个简单的平台，将帮助我们跟踪应用程序中的活动。由于我们希望在应用程序中只有一个`ActivityService`实例，让我们将其添加到根`App`组件的`providers`列表中。你可以在`lib`文件夹中的`app.js`文件中找到这个组件：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because all dependency injectors will inherit the dependencies from our `App`
    component, we can inject it in any component of our application going forward.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有依赖注入器都将继承我们的`App`组件的依赖项，因此我们可以将其注入到我们应用程序的任何组件中。
- en: Logging activities
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录活动
- en: We have created a nice system to log activities. Now let's go ahead and use
    it within our components to keep an audit of all the activities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个很好的系统来记录活动。现在让我们继续在我们的组件中使用它，以记录所有活动。
- en: 'First, let''s use `ActivityService` to log activities within the `TaskList`
    component. The following code excerpt highlights the changes made to the `TaskList`
    component within the `task-list/task-list.js` file in our `lib` folder:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`ActivityService`在`TaskList`组件中记录活动。以下代码摘录突出了我们对`lib`文件夹中的`task-list/task-list.js`文件内`TaskList`组件所做的更改：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `logActivity` method of `ActivityService`, we can easily log any number
    of activities within the already existing `TaskList` methods to modify tasks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ActivityService`的`logActivity`方法，我们可以轻松地将任何数量的活动记录到现有的`TaskList`方法中，以修改任务。
- en: In the message body of our activities, we've used a new utility function, `limitWithEllipsis`,
    which we've imported from a new module, namely `string-utilities`. This function
    takes a string and a number as parameters. The returned string is a truncated
    version of the input string, which is cut off at the position specified with the
    second parameter. In addition, there's an ellipsis character (`...`) appended
    to the string. I won't bother you with the rather simple code within this helper.
    If you'd like to know how it's implemented, you can always check the implementation
    after downloading this chapter's code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们活动的消息体中，我们使用了一个新的实用函数，`limitWithEllipsis`，该函数是从一个新模块导入的，即`string-utilities`。这个函数接受一个字符串和一个数字作为参数。返回的字符串是输入字符串的截断版本，在第二个参数指定的位置被截断。此外，字符串后面还附加了一个省略号字符（`...`）。我不会在这个辅助函数的相对简单的代码上打扰你。如果你想知道它是如何实现的，你可以在下载本章代码后查看实现。
- en: If you go back to the specification of our activity logs, you will see that
    we always need to specify a subject in order to log activities. We've implemented
    this on our `TaskList` component by introducing a new input parameter called `activitySubject`.
    The assumption here is that each activity subject contains `LiveDocument` stored
    under the document member. From there, we can obtain the ID in the data store
    and use it for our activity message.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到我们活动日志的规范，你会看到我们总是需要指定一个主题才能记录活动。我们通过引入一个新的输入参数`activitySubject`在我们的`TaskList`组件上实现了这一点。这里的假设是每个活动主体都包含存储在文档成员下的`LiveDocument`。从那里，我们可以从数据存储中获取ID，并用于我们的活动消息。
- en: If we revisit our `Project` component, you will see that we're already following
    the prerequisites of being an activity subject. We've stored a reference to the
    underlying `LiveDocument` instance under the `document` member field.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾我们的`Project`组件，你会看到我们已经在遵循活动主体的先决条件。我们在`document`成员字段下存储了对底层`LiveDocument`实例的引用。
- en: 'All we need to do now is change the template of our `ProjectTaskList` wrapper
    component to pass the `activitySubject` project input of the `TaskList` component.
    Let''s look at the changes in the `lib/project/project-task-list/project-task-list.html`
    file quickly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的就是更改我们的`ProjectTaskList`包装组件的模板，以传递`TaskList`组件的`activitySubject`项目输入。让我们快速看一下`lib/project/project-task-list/project-task-list.html`文件中的更改：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might wonder why we care about this rather cumbersome way of dealing with
    our task list, if we could just pass in a hard reference to the project and use
    project tasks and the project ID directly. The beautiful aspect of our current
    solution is that we do not have any dependency on a project as such. We could
    also use our `TaskList` component without the context of a project. And we can
    still pass a list of tasks to the `tasks` input and use a different activity subject
    for the activity logs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果我们可以直接传递一个项目硬引用并直接使用项目任务和项目ID，为什么我们还要关心这种处理任务列表相当繁琐的方法。我们当前解决方案的美丽之处在于，我们没有任何对项目的依赖。我们也可以在不涉及项目上下文的情况下使用我们的`TaskList`组件。我们仍然可以向`tasks`输入传递任务列表，并为活动日志使用不同的活动主题。
- en: We're also going to use `ActivityService` within the `Comments` component to
    create logs for added, edited, and deleted comments. Since the steps involved
    are very similar to what we've just done for the `TaskList` component, we're going
    to skip this. You can always take a look at the final codebase for this chapter
    to add activity logs for the `Comments` component.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`Comments`组件中使用`ActivityService`来创建添加、编辑和删除评论的日志。由于涉及的步骤与我们刚刚为`TaskList`组件所做的工作非常相似，我们将跳过这一部分。你总是可以查看本章的最终代码库，为`Comments`组件添加活动日志。
- en: Leveraging the power of SVG
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用SVG的力量
- en: 'SVG has been a part of the Open Web Platform standards since 1999 and was first
    recommended in 2001 under the SVG 1.0 standard. SVG is a consolidation of two
    independent proposals for an XML-based vector image format. **Precision Graphics**
    **Markup Language** (**PGML**)—mainly developed by Adobe and Netscape—as well
    as **Vector Markup Language** (**VML**)—which was mainly represented by Microsoft
    and Macromedia—were both different XML formats that served the same purpose. The
    W3C consortium declined both the proposals in favor of the newly developed SVG
    standard that unified the best of both worlds into a single standard:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 自1999年以来一直是开放网络平台标准的一部分，并于2001年在SVG 1.0标准下首次推荐。SVG是两个独立XML矢量图像格式提案的整合。**精确图形标记语言**（**PGML**）——主要由Adobe和Netscape开发——以及**矢量标记语言**（**VML**）——主要由微软和Macromedia代表——都是服务于相同目的的不同XML格式。W3C联盟拒绝了这两个提案，转而支持新开发的SVG标准，该标准将两者的优点统一为一个单一标准：
- en: '![Leveraging the power of SVG](img/image00323.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![利用SVG的力量](img/image00323.jpeg)'
- en: Timeline showing the development of the SVG standard
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 展示SVG标准发展历程的时间线
- en: All three standards had a common goal, which was to provide a format for the
    Web to display vector graphics in the browser. SVG is a declarative language that
    specifies graphical objects using XML elements and attributes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三个标准都有一个共同的目标，即提供一个格式，让Web在浏览器中显示矢量图形。SVG是一种声明性语言，使用XML元素和属性指定图形对象。
- en: 'Let''s look at a simple example on how to create an SVG image with a black
    circle, using SVG:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用SVG创建一个黑色圆圈的SVG图像的简单示例：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This rather simple example represents an SVG image with a black circle, whose
    center is located at *x = 10 px* and *y = 10 px*. The radius of the circle is
    10 px, which makes this circle 20 px in width and height.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当简单的例子代表了一个SVG图像，其中有一个黑色圆圈，其中心位于*x = 10 px*和*y = 10 px*。圆圈的半径是10 px，这使得这个圆圈宽度和高度都是20
    px。
- en: 'The origin of the coordinate system in SVG sits on the top-left corner, where
    the *y* axis faces the south direction and the *x* axis eastward:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SVG的坐标系原点位于左上角，其中*y*轴朝南方向，*x*轴朝东：
- en: '![Leveraging the power of SVG](img/image00324.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![利用SVG的力量](img/image00324.jpeg)'
- en: The coordinate system within SVG
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SVG内的坐标系
- en: Using not only primitive shapes, such as circles, lines, and rectangles, but
    also complex polygons, the possibilities for creating graphical content are nearly
    unlimited.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅使用原始形状，如圆圈、线条和矩形，还使用复杂的多边形，创建图形内容的可能性几乎是无限的。
- en: SVG is not only used within the Web, but has also become a very important intermediate
    format for exchanging vector graphics between different applications. Almost any
    application that supports vector graphics also supports the import of SVG files.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SVG不仅用于Web，而且已成为不同应用程序之间交换矢量图形的重要中间格式。几乎任何支持矢量图形的应用程序都支持导入SVG文件。
- en: The real power of SVG comes to the surface when we do not include an SVG file
    as an HTML image, but rather include the SVG content directly within our DOM.
    Since HTML5 directly supports the SVG namespace within an HTML document and will
    render the graphics we define within our HTML, a whole bunch of new possibilities
    spring up. We can now style our SVG with CSS, manipulate the DOM with JavaScript,
    and easily make our SVG interactive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不将SVG文件作为HTML图像包含在内，而是直接在我们的DOM中包含SVG内容时，SVG的真正力量才显现出来。由于HTML5直接支持HTML文档中的SVG命名空间，并将渲染我们在HTML中定义的图形，因此出现了一系列新的可能性。现在，我们可以使用CSS来样式化SVG，使用JavaScript操作DOM，并轻松使SVG交互式。
- en: 'Taking the previous example of our circle image to the next level, we could
    make it interactive by changing the circle color by clicking it. First, let''s
    create a minimal HTML document and include our SVG elements directly within the
    DOM:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们之前的圆圈图像示例提升到下一个层次，我们可以通过点击来改变圆圈颜色，使其变得交互式。首先，让我们创建一个最小的HTML文档，并将我们的SVG元素直接包含在DOM中：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we can get rid of the version and the XML namespace declaration
    when we use SVG directly within the DOM of our HTML document. What's interesting
    here is that we can treat SVG very much like regular HTML. We can assign an ID
    and even classes to SVG elements and access them from JavaScript.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们直接在HTML文档的DOM中使用SVG时，我们可以去掉版本和XML命名空间声明。这里有趣的是，我们可以将SVG视为常规HTML。我们可以为SVG元素分配ID和类，并从JavaScript中访问它们。
- en: Within the `script` tag of our HTML document, we can directly access our `circle`
    element using the ID we've previously assigned to it. We can add event listeners,
    the way we already know, from regular HTML elements. In this example, we added
    a `click` event listener and changed the color of our circle to red.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们HTML文档的`script`标签内，我们可以直接通过之前分配给它的ID访问我们的`circle`元素。我们可以像处理常规HTML元素一样添加事件监听器。在这个例子中，我们添加了一个`click`事件监听器，并将我们的圆圈颜色改为红色。
- en: For the sake of simplicity, we used an inline `script` tag in this example.
    It would of course be much cleaner to have a separate JavaScript file to do the
    scripting.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们在本例中使用了内联`script`标签。当然，使用一个单独的JavaScript文件来做脚本会更干净利落。
- en: Styling SVG
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SVG的样式
- en: I'm a purist when it comes to the separation of concerns within the Web. I still
    strongly believe in the separation of structure (HTML), appearance (CSS), and
    behavior (JavaScript), as well as producing the most maintainable applications
    when following this practice.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web中关注点的分离方面，我是一个纯粹主义者。我仍然坚信结构（HTML）、外观（CSS）和行为（JavaScript）的分离，以及遵循此实践时产生最可维护的应用程序。
- en: 'First, it seems weird to have SVG in your HTML, and you might think that this
    breaks the contract of a clean separation. Why is this graphical content, consisting
    of only appearance-relevant data, sitting in my HTML that is supposed to only
    contain raw information? After dealing with a lot of SVGs within a DOM, I have
    come to the conclusion that we can establish a clean separation when using SVG
    by dividing our appearance responsibilities into the following two subgroups:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 HTML 中使用 SVG 似乎很奇怪，你可能会认为这打破了干净的分离契约。为什么只有外观相关的数据组成的图形内容，却坐在只应包含原始信息的 HTML
    中？在处理了大量的 DOM 中的 SVG 之后，我得出结论，我们可以通过将外观责任分为以下两个子组来使用 SVG 建立干净的分离：
- en: '**Graphical structure**: This subgroup deals with the process of defining the
    basic structure of your graphical content. This is about shapes and layout.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形结构**：这个子组处理的是定义你的图形内容基本结构的过程。这关乎形状和布局。'
- en: '**Visual appearance**: This subgroup deals with the process of defining the
    look and feel of our graphical structures, such as colors, line widths, line styles,
    and text alignment.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉外观**：这个子组处理的是定义我们的图形结构的外观和感觉的过程，例如颜色、线宽、线型和文本对齐。'
- en: If we separate the concerns of SVG into these groups, we can actually gain great
    maintainability. Graphical structure is defined by the SVG shapes themselves.
    They are directly written within our HTML but don't have a particular look and
    feel. We only store the basic structural information within HTML.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 SVG 的关注点分离成这些组，我们实际上可以获得很好的可维护性。图形结构由 SVG 形状本身定义。它们直接写入我们的 HTML 中，但没有特定的外观和感觉。我们只将基本的结构信息存储在
    HTML 中。
- en: Luckily, all the properties of visual appearance, such as colors, cannot only
    be expressed through the attributes in our SVG elements; however, there's a corresponding
    CSS property that allows us to offload all the look-and-feel-relevant aspects
    of the structure to CSS.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，所有视觉外观属性，如颜色，不仅可以通过我们的 SVG 元素的属性来表示；然而，有一个相应的 CSS 属性允许我们将结构的外观和感觉相关方面卸载到
    CSS 中。
- en: 'Go back to the example where we drew a black circle; we''ll tweak this a bit
    to fit our demands of separation of concerns so that we can distinguish graphical
    structure from graphical appearance:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们画黑色圆圈的例子；我们将对其进行一些调整以满足我们对关注点分离的需求，以便我们可以区分图形结构和图形外观：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Styling our graphical structures can now be achieved using CSS by including
    a stylesheet with the following content:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过包含以下内容的样式表来使用 CSS 来样式化我们的图形结构：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is fantastic, as we can now not only reuse some graphical structures, but
    also apply different visual appearance parameters using CSS, similar to those
    enlightening moments when we managed to reuse some semantic HTML by only changing
    some CSS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太棒了，因为我们现在不仅可以重用一些图形结构，还可以使用 CSS 应用不同的视觉外观参数，类似于我们通过只更改一些 CSS 就成功重用了一些语义
    HTML 的那些启发时刻。
- en: 'Let''s look at the most important CSS properties we can use to style SVG shapes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们可以用来样式化 SVG 形状的最重要的 CSS 属性：
- en: '`fill`: While working with solid SVG shapes, there''s always a shape fill and
    stroke option available; the `fill` property specifies the color of the shape
    fill.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`：在处理实心 SVG 形状时，始终有形状填充和描边选项可用；`fill` 属性指定了形状填充的颜色。'
- en: '`stroke`: This property specifies the color of the SVG shape''s outline.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke`：此属性指定了 SVG 形状轮廓的颜色。'
- en: '`stroke-width`: This property specifies the width of the SVG shape''s outline
    on solid shapes. For nonsolid shapes, such as lines, this can be thought of as
    line width.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-width`：此属性指定了 SVG 形状轮廓的宽度，对于实心形状。对于非实心形状，例如线条，这可以被认为是线宽。'
- en: '`stroke-dasharray`: This specifies a dash pattern for strokes. Dash patterns
    are space-separated values that define a pattern.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-dasharray`：这指定了描边的虚线模式。虚线模式是由空格分隔的值，定义了一个模式。'
- en: '`stroke-dashoffset`: This specifies an offset for the dash pattern, which is
    specified with the `stroke-dasharray` property.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-dashoffset`：这指定了虚线模式的偏移量，该偏移量由 `stroke-dasharray` 属性指定。'
- en: '`stroke-linecap`: This property defines how line caps should be rendered. They
    can be rendered as square, butt, or rounded caps.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-linecap`：此属性定义了线帽应该如何渲染。它们可以是方形、平头或圆角帽。'
- en: '`stroke-linejoin`: This property specifies how lines are joined together within
    a path.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke-linejoin`：此属性指定了路径内线条的连接方式。'
- en: '`shape-rendering`: Using this property, you can override the shape-rendering
    algorithm that, as the name suggests, is used to render shapes. This is particularly
    useful if you need crispy edges on your shapes.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape-rendering`：使用此属性，您可以覆盖形状渲染算法，正如其名，该算法用于渲染形状。如果您需要形状有清晰的边缘，这特别有用。'
- en: For a complete reference of the available appearance-relevant SVG attributes,
    visit the Mozilla Developer website at [https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的与外观相关的SVG属性的完整参考，请访问Mozilla开发者网站上的[https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute)。
- en: I hope this brief introduction gave you a better feeling about SVG and the great
    power it comes with. In this chapter, we're going to use some of that power to
    create nice, interactive graphical components. If you would like to learn more
    about SVG, I strongly recommend that you go through the great articles by *Sara
    Soueidan*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这篇简短的介绍让您对SVG及其带来的强大功能有了更好的认识。在本章中，我们将利用其中的一些功能来创建漂亮的、交互式的图形组件。如果您想了解更多关于SVG的信息，我强烈建议您阅读Sara
    Soueidan的精彩文章。
- en: Building SVG components
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建SVG组件
- en: When building Angular components with SVG templates, there are a couple of things
    we need to be aware of. The first and most obvious one, is XML namespaces. Modern
    browsers are very intelligent when parsing HTML. Besides being probably the most
    fault-tolerant parser in the history of computer science, DOM parsers are very
    smart in recognizing markup and then deciding how to treat it. They will automatically
    decide the correct namespaces for us, based on element names, so we don't need
    to deal with them when writing HTML.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用SVG模板构建Angular组件时，有一些事情我们需要注意。首先也是最明显的一点，是XML命名空间。现代浏览器在解析HTML时非常智能。除了可能是计算机科学历史上最容错的解析器之外，DOM解析器在识别标记并决定如何处理它方面也非常聪明。它们将根据元素名称自动为我们决定正确的命名空间，因此我们编写HTML时不需要处理它们。
- en: 'If you''ve messed around with the DOM API a bit, you would''ve probably recognized
    that there are two methods for creating new elements. In the document object,
    for example, there''s a `createElement` function, but there''s also `createElementNS`
    that accepts an additional namespace URI parameter. Also, every created element
    has a `namespaceURI` property that tells you the namespace of the specific element.
    This is important since HTML5 is a standard that consists of at least three namespaces:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对DOM API有过一些操作，您可能会认识到有两种方法用于创建新元素。例如，在文档对象中，有一个`createElement`函数，但还有一个`createElementNS`，它接受一个额外的命名空间URI参数。此外，每个创建的元素都有一个`namespaceURI`属性，它告诉您特定元素的命名空间。这很重要，因为HTML5是一个至少由三个命名空间组成的标准：
- en: '**HTML**: This is the standard HTML namespace with the [http://www.w3.org/1999/xhtml](http://www.w3.org/1999/xhtml)
    URI.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML**：这是具有[http://www.w3.org/1999/xhtml](http://www.w3.org/1999/xhtml) URI的标准HTML命名空间。'
- en: '**SVG**: This embraces all SVG elements and attributes and uses the [http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)
    URI. You can sometimes see this namespace URI in an `xmlns` attribute of the `svg`
    elements. In fact, this is not really required, as the browser is smart enough
    to decide on the correct namespace itself.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SVG**：这包括所有SVG元素和属性，并使用[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)
    URI。您有时可以在`svg`元素的`xmlns`属性中看到此命名空间URI。实际上，这并不是必需的，因为浏览器足够智能，可以自己决定正确的命名空间。'
- en: '**MathML**: This is an XML-based format to describe mathematical formulas and
    is supported in most modern browsers. It uses the [http://www.w3.org/1998/Math/MathML](http://www.w3.org/1998/Math/MathML)
    namespace URI.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MathML**：这是一个基于XML的格式，用于描述数学公式，并被大多数现代浏览器支持。它使用[http://www.w3.org/1998/Math/MathML](http://www.w3.org/1998/Math/MathML)命名空间URI。'
- en: We can mix all these elements from different standards and namespaces within
    a single document, and our browser will figure out the correct namespace itself
    when it creates elements within the DOM.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个文档中混合来自不同标准和命名空间的所有这些元素，当浏览器在DOM中创建元素时，它将自动确定正确的命名空间。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want more information on namespaces, I recommend that you go through
    the *Namespaces* *Crash Course* article on the Mozilla Developer Network at [https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course](https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于命名空间的信息，我建议您阅读Mozilla开发者网络上的*命名空间快速入门*文章[https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course](https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course)。
- en: As Angular will compile templates for us and render elements into the DOM using
    the DOM API, it needs to be aware of the namespaces when doing that. Similar to
    the browser, Angular provides some intelligence for deciding the correct namespace
    while creating elements. However, there are some situations where you need to
    help Angular recognize the correct namespace.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Angular 会为我们编译模板，并使用 DOM API 将元素渲染到 DOM 中，因此在进行这些操作时，它需要了解命名空间。类似于浏览器，Angular
    在创建元素时提供了一些智能来决定正确的命名空间。然而，在某些情况下，你需要帮助 Angular 识别正确的命名空间。
- en: 'To illustrate some of this behavior, let''s transform our circle example that
    we''ve been working on into an Angular component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一些这种行为，让我们将我们一直在工作的圆形示例转换成一个 Angular 组件：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've wrapped our circle SVG graphics into a simple Angular component. The `size`
    input parameter determines the actual width and height of the circle by controlling
    the SVG's `width` and `height` attributes and the circle's `cx`, `cy`, and `r`
    attributes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的圆形 SVG 图形包装在一个简单的 Angular 组件中。`size` 输入参数通过控制 SVG 的 `width` 和 `height`
    属性以及圆形的 `cx`、`cy` 和 `r` 属性来确定圆形的实际宽度和高度。
- en: 'To use our `Circle` component, simply use the following template within another
    component:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的 `Circle` 组件，只需在另一个组件中使用以下模板：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that we need to use attribute bindings on SVG elements,
    and we can't set DOM element properties directly. This is due to the nature of
    SVG elements that have special property types—for example, `SVGAnimatedLength`—that
    can be animated with **Synchronized Multimedia Integration** **Language** (**SMIL**).
    Instead of interfering with these rather complex element properties, we can simply
    use attribute bindings to set the attribute values of the DOM element.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们需要在 SVG 元素上使用属性绑定，而不能直接设置 DOM 元素的属性。这是由于 SVG 元素具有特殊的属性类型——例如，`SVGAnimatedLength`——可以使用**同步多媒体集成语言**（**SMIL**）进行动画。为了避免干扰这些相对复杂的元素属性，我们可以简单地使用属性绑定来设置
    DOM 元素的属性值。
- en: Let's go back to our namespace discussion. Angular would know that it needs
    to use the SVG namespace to create the elements within this template. It will
    function in this way simply because we're using the `svg` element as a root element
    within our component, and it could switch the namespace within the template parser
    for any child elements automatically.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的命名空间讨论。Angular 会知道它需要使用 SVG 命名空间来创建这个模板内的元素。它将以这种方式工作，仅仅因为我们在这个组件中使用
    `svg` 元素作为根元素，并且它可以在模板解析器中自动为任何子元素切换命名空间。
- en: 'However, there are certain situations where we need to help Angular determine
    the correct namespace for the elements we''d like to create. This strikes us if
    we''re creating nested SVG components that don''t contain a root `svg` element:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们需要帮助 Angular 确定我们想要创建的元素的正确命名空间。当我们创建不包含根 `svg` 元素的嵌套 SVG 组件时，我们会遇到这种情况：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we're nesting SVG components, and our `AwesomeCircle` component
    does not have an `svg` root element to tell Angular to switch the namespace. This
    is why we've created the `svg` element within our `App` component and then included
    the `AwesomeCircle` component in an SVG group.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们嵌套了 SVG 组件，我们的 `AwesomeCircle` 组件没有 `svg` 根元素来告诉 Angular 切换命名空间。这就是为什么我们在
    `App` 组件中创建了一个 `svg` 元素，然后在一个 SVG 组中包含了 `AwesomeCircle` 组件。
- en: We need to explicitly tell Angular to switch to the SVG namespace within our
    `Circle` component, and we can do this by including the namespace name as a prefix
    separated by a colon, as you can see in the highlighted section of the preceding
    code excerpt.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要明确告诉 Angular 在我们的 `Circle` 组件中切换到 SVG 命名空间，我们可以通过在代码片段中高亮显示的部分中看到的那样，将命名空间名称作为冒号分隔的前缀来做到这一点。
- en: If you have multiple elements that need to be created within the SVG namespace
    explicitly, you can rely on the fact that Angular does apply the namespace for
    child elements too and does group all your elements with an SVG group element.
    So, you only need to prefix the group element `<svg:g> ... </svg:g>`, but none
    of the contained SVG elements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要显式地在 SVG 命名空间中创建多个元素，你可以依赖 Angular 也会为子元素应用命名空间的事实，并且会使用 SVG 组元素将所有你的元素分组。所以，你只需要在组元素
    `<svg:g> ... </svg:g>` 前加前缀，但不要包含任何 SVG 元素。
- en: This is enough to know about Angular internals when dealing with SVG. Let's
    move on and create some real components!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 SVG 时，这已经足够了解 Angular 的内部机制了。让我们继续前进，创建一些真正的组件！
- en: Building an interactive activity slider component
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个交互式活动滑块组件
- en: In the previous topics, we've covered the basics of working with SVG and dealing
    with SVG in Angular components. Now it's time to apply our knowledge to the task
    management application and create some components using SVG.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的主题中，我们已经介绍了使用 SVG 以及在 Angular 组件中处理 SVG 的基础知识。现在，是时候将我们的知识应用到任务管理应用中，并使用
    SVG 创建一些组件了。
- en: 'The first component we''ll be creating in this context is an interactive slider
    that allows the user to select the time range of activities that he or she is
    interested to check out. Displaying a simple HTML5 range input could be a solution,
    but since we''ve gained some SVG superpower, we can do better! We''ll use SVG
    to render our own slider that will show existing activities as ticks on the slider.
    Let''s look at a mock-up of the slider component that we''re going to create:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我们将首先创建一个交互式滑块，允许用户选择他或她感兴趣检查的活动时间范围。显示一个简单的 HTML5 范围输入可能是一个解决方案，但既然我们已经获得了
    SVG 超能力，我们可以做得更好！我们将使用 SVG 来渲染我们自己的滑块，它将在滑块上显示现有活动作为刻度。让我们看看我们将要创建的滑块组件的预览图：
- en: '![Building an interactive activity slider component](img/image00325.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![构建交互式活动滑块组件](img/image00325.jpeg)'
- en: A mockup of the activity slider component
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 活动滑块组件的预览图
- en: Our slider component will actually serve two purposes. It should be a user control
    and should provide a way to select a time range for filtering activities. However,
    it should also provide an overview of all the activities so that a user can filter
    the range more intuitively. By drawing vertical bars that represent activities,
    we can already give the user a feeling of the range he or she is interested in.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的滑块组件实际上将有两个用途。它应该是一个用户控件，并提供一种选择时间范围以过滤活动的方法。然而，它还应该提供所有活动的概览，以便用户可以更直观地过滤范围。通过绘制代表活动的垂直条，我们已经在用户感兴趣的范围上给出了感觉。
- en: 'First of all, we''ll create a new file for our `ActivitySlider` component called
    `activity-slider.js` within the `activities/activity-slider` path and define our
    component class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 `activities/activity-slider` 路径下创建一个新的文件，名为 `activity-slider.js`，并定义我们的组件类：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing we should mention, and which differs from all the other components
    we've written so far, is that we're using `ViewEncapsulation.Native` for this
    component. As we learned from the *Creating our application component* section
    in [Chapter 2](part0020.xhtml#aid-J2B81 "Chapter 2. Ready, Set, Go!"), *Ready,
    Set, Go!*, when we use `ViewEncapsulation.Native` for our component encapsulation,
    Angular actually uses Shadow DOM to create the component. We briefly looked at
    this in the *Shadow DOM* section in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Component-Based
    User Interfaces"), *Component-Based User Interfaces* as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先提到的是，这与我们迄今为止编写的所有其他组件都不同，我们正在为这个组件使用 `ViewEncapsulation.Native`。正如我们在第
    2 章的 *创建我们的应用程序组件* 部分中学习的，当我们在组件封装中使用 `ViewEncapsulation.Native` 时，Angular 实际上使用
    Shadow DOM 来创建组件。我们在第 1 章的 *组件化用户界面* 部分的 *Shadow DOM* 部分中也简要地讨论了这一点。
- en: 'Using Shadow DOM for our component will give us this advantage: our component
    will be fully encapsulated from the CSS side of things. This not only means that
    none of the global CSSes will leak into our component, but it also means that
    we''ll need to create local styles in order to style our component.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Shadow DOM 为我们的组件将带来这个优势：我们的组件将从 CSS 方面完全封装。这不仅意味着没有任何全局 CSS 会泄漏到我们的组件中，而且这也意味着我们需要创建本地样式来为我们的组件进行样式设计。
- en: So far, we've used a CSS naming convention called BEM that provides us with
    some necessary prefixes to avoid name clashes within CSS and establish a clean
    and simple CSS specificity. However, when using Shadow DOM, we can forego prefixes
    to avoid name clashes, since we're only applying styles locally within the component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了一种名为 BEM 的 CSS 命名约定，它为我们提供了一些必要的前缀，以避免 CSS 中的名称冲突，并建立干净简单的 CSS 特异性。然而，当使用
    Shadow DOM 时，我们可以省略前缀以避免名称冲突，因为我们只在本组件内部应用样式。
- en: Because we're using Shadow DOM for this component, we need to have a way to
    define local styles. Angular provides us with an option to pass styles into the
    component using the `styles` property of the component annotation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个组件中使用 Shadow DOM，我们需要有一种方法来定义本地样式。Angular 通过组件注解的 `styles` 属性为我们提供了一个将样式传递到组件中的选项。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Chrome supports Shadow DOM natively since version 35\. Within Firefox, Shadow
    DOM can be enabled by visiting the `about:config` page and turning on the `dom.webcomponents.enabled`
    flag. IE, Edge, and Safari don't support this standard at all; however, we can
    set things up in a way that they could deal with Shadow DOM, by including a polyfill
    named `webcomponents.js`. You can find more information on this polyfill at [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome从版本35开始原生支持Shadow DOM。在Firefox中，可以通过访问`about:config`页面并打开`dom.webcomponents.enabled`标志来启用Shadow
    DOM。IE、Edge和Safari根本不支持这个标准；然而，我们可以通过包含一个名为`webcomponents.js`的polyfill来设置它们以处理Shadow
    DOM。你可以在[https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)上找到有关此polyfill的更多信息。
- en: Using the text plugin of SystemJS, we can import a stylesheet containing only
    the local styles of our component and then pass them to the `styles` property.
    By appending a `!text` postfix to the import of our CSS file, we tell SystemJS
    to load our CSS file as raw text. Note that the `styles` property is expecting
    an array, which is why we wrap our imported styles into an array literal.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SystemJS的文本插件，我们可以导入只包含我们组件本地样式的样式表，然后将它们传递给`styles`属性。通过在CSS文件的导入后添加一个`!text`后缀，我们告诉SystemJS将我们的CSS文件作为原始文本加载。请注意，`styles`属性期望一个数组，这就是为什么我们将导入的样式包装在一个数组字面量中。
- en: 'If you take a look at the stylesheet for the `ActivitySlider` component, you
    can immediately see that we''re no longer prefixing the classes with the component
    name:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`ActivitySlider`组件的样式表，你可以立即看到我们不再在类名前加上组件名称：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Usually, such short class names would probably lead to name clashes within our
    project, but since the styles will be local to the Shadow DOM of our component,
    we don't need to worry about name clashes any more.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这样的短类名可能会在我们的项目中导致名称冲突，但既然样式将仅限于我们组件的Shadow DOM中，我们就不需要担心名称冲突了。
- en: As an input parameter, we define the list of activities that will be used not
    only to determine the available range in the slider, but also to render activities
    on the background of the slider.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入参数，我们定义了将用于不仅确定滑动组件中的可用范围，还要在滑动组件的背景上渲染活动的活动列表。
- en: Once a selection is made by the user, our component will use the `selectionChange`
    event emitter to notify the outside world about the change.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户做出选择，我们的组件将使用`selectionChange`事件发射器来通知外部世界关于变化。
- en: 'Within the constructor, we''re setting aside the component DOM element for
    some measurement we need to make in order to draw later on:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们留出组件DOM元素，以便进行一些测量，以便稍后绘制：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By injecting the `ElementRef` instance to the constructor, we can easily access
    the native DOM element of our component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`ElementRef`实例注入构造函数，我们可以轻松访问我们组件的原生DOM元素。
- en: Projection of time
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间的投影
- en: 'Our slider component needs to be able to project timestamps into the coordinate
    system of SVG. Also, when a user clicks on the timeline to select a range, we''ll
    need to be able to project coordinates back into timestamps. For this purpose,
    we need to create two projection functions within our component that will use
    a few helper functions and states to calculate the values, from coordinates to
    time and vice-verse:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的滑动组件需要能够将时间戳投影到SVG的坐标系中。此外，当用户点击时间线选择范围时，我们需要能够将坐标投影回时间戳。为此，我们需要在我们的组件中创建两个投影函数，这些函数将使用一些辅助函数和状态来计算值，从坐标到时间和反过来：
- en: '![Projection of time](img/image00326.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![时间的投影](img/image00326.jpeg)'
- en: Visualization of important variables and functions for our calculations
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算中重要变量和函数的可视化
- en: While we will use percentage to position our SVG elements on the slider component,
    the padding on the sides will need to be specified in pixels. The `totalWidth`
    function will return the total width of the area in pixels; this is where we'll
    draw the activity indicators. The `timeFirst`, `timeLast`, and `timeSpan` variables
    will also be used by the calculations and are specified in milliseconds.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将使用百分比来定位滑动组件上的SVG元素，但两侧的填充需要以像素为单位指定。`totalWidth`函数将返回该区域的像素总宽度；这是我们将在其中绘制活动指示器的位置。`timeFirst`、`timeLast`和`timeSpan`变量也将被计算使用，并以毫秒为单位指定。
- en: 'Let''s add some code to our slider to deal with the projection of our activities
    on the slider in the `activity-slider.js` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`activity-slider.js`文件中添加一些代码来处理我们在滑动组件上的活动投影：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since we have put aside the reference to the root element as the `sliderElement`
    member variable, we can use its `clientWidth` property to get the full width of
    the component and subtract the padding. This will give us the full width of the
    area where we'd like to draw activity indicators, in pixels.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将根元素的引用作为`sliderElement`成员变量放置一旁，我们可以使用其`clientWidth`属性来获取组件的全宽并减去内边距。这将给我们想要绘制活动指示器的区域的全宽，以像素为单位。
- en: In the `projectTime` function, we will first transform the timestamp into a
    position by a simple rule of three. Because we have access to the timestamp of
    the first activity as well as the total time span, this will be quite a simple
    task. Once we do this, we can convert our position value, which is of unit pixels,
    into percentage, by dividing it by the total component width and then multiplying
    it by 100.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`projectTime`函数中，我们首先将时间戳通过一个简单的三段式规则转换为位置。因为我们可以访问第一个活动的时间戳以及总时间跨度，所以这将是一个非常简单的任务。一旦我们这样做，我们可以通过将其除以组件的总宽度然后乘以100，将我们的位置值（以像素为单位）转换为百分比。
- en: To project a pixel value back to a timestamp, we can do more or less the reverse
    of `projectTime`, except that we're not dealing with percentage here but assuming
    the length parameter of the `projectLength` function is in pixel unit.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要将像素值投影回时间戳，我们可以做`projectTime`的相反操作，只不过这里我们不是处理百分比，而是假设`projectLength`函数的长度参数是以像素为单位。
- en: 'We''ve used some member variables—`timeFirst`, `timeLast`, and `timeSpan`—within
    our projection code, but how do we set these member variables? Since we have an
    `activities` component input, which is expected to be a list of relevant activities,
    we can observe the input for changes and set the values based on the input. To
    observe component input for changes, we can use the `ngOnChanges` life cycle hook:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的投影代码中使用了一些成员变量——`timeFirst`、`timeLast`和`timeSpan`——但我们是如何设置这些成员变量的呢？因为我们有一个`activities`组件输入，它预期是一个相关活动的列表，我们可以观察输入以检测变化，并根据输入设置值。为了观察组件输入的变化，我们可以使用`ngOnChanges`生命周期钩子：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we need to check whether the changes include changes to the `activities`
    input and that the current value of the input is valid. After checking for the
    input value, we can determine our member variables, namely `timeFirst`, `timeLast`,
    and `timeSpan`. We limit the `timeSpan` variable to `1` at least, as our projection
    calculations would be messed up otherwise.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查更改是否包括对`activities`输入的更改，并且当前输入值是有效的。在检查输入值之后，我们可以确定我们的成员变量，即`timeFirst`、`timeLast`和`timeSpan`。我们将`timeSpan`变量限制至少为`1`，否则我们的投影计算将会出错。
- en: The preceding code will ensure that we will always recalculate our member variables
    when the `activities` input changes and that we'd be using the most recent data-rendering
    activities.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将确保当`activities`输入发生变化时，我们总是会重新计算我们的成员变量，并且我们会使用最新的数据渲染活动。
- en: Rendering activity indicators
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染活动指示器
- en: We've already implemented the basics of the component and laid the groundwork
    for drawing time information into the coordinate system of our component. It's
    time to use our projection functions and draw our activities as indicators on
    the slider using SVG.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了组件的基本功能，并为将时间信息引入组件的坐标系奠定了基础。现在是时候使用我们的投影函数，并使用SVG在滑块上绘制我们的活动指示器了。
- en: 'First, let''s take a look at the required template that we are going to create
    in a file called `activity-slider.html` within our `activity-slider` directory:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们将在`activity-slider`目录下的`activity-slider.html`文件中创建的所需模板：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we need to create an indicator for every activity within our activities
    list, we can simply use the `NgFor` directive to repeat the rectangle that represents
    our activity indicator.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要为活动列表中的每个活动创建一个指示器，我们可以简单地使用`NgFor`指令重复表示活动指示器的矩形。
- en: As we know from building our `ActivityService` class in a previous topic, activities
    always contain a `time` field with the timestamp of the activity. Within our component,
    we have already created a projection function that converts time into percentage,
    relative to our component width. We can simply use the `projectTime` function
    within our attribute binding for the `x` attribute of the `rect` element to position
    our activity indicators at the correct positions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一个主题中构建`ActivityService`类时所知，活动总是包含一个带有活动时间戳的`time`字段。在我们的组件中，我们已创建了一个将时间转换为相对于组件宽度的百分比的投影函数。我们只需在`rect`元素的`x`属性绑定中使用`projectTime`函数，就可以将活动指示器定位在正确的位置。
- en: By using only an SVG template and our backing function to project time, we have
    created a nice little chart that displays activity indicators on a timeline.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅使用SVG模板和我们的背景函数来投影时间，我们创建了一个小巧的图表，该图表在时间轴上显示活动指示器。
- en: You can imagine that if we have a lot of activities, our slider will actually
    look pretty stuffed, and it will be hard to get a feeling for when those activities
    may have occurred. We need to have some sort of a grid that will help us associate
    the chart with a timeline.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，如果我们有很多活动，我们的滑块实际上看起来会很拥挤，很难感觉到这些活动可能发生的时间。我们需要有一种网格，可以帮助我们将图表与时间轴关联起来。
- en: As already shown in the mock-up of our slider component, we're now going to
    introduce some ticks on the slider background that will divide the slider into
    sections. We'll also label each tick with a calendar time. This will give our
    users a rough sense for time when looking at the activity indicators on the slider.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在滑块组件的模拟中已展示的，我们现在将在滑块背景上引入一些刻度，将滑块分成几个部分。我们还将为每个刻度标注一个日历时间。这将使用户在查看滑块上的活动指示器时对时间有一个大致的感觉。
- en: 'Let''s look at the code changes within our `ActivitySlider` class that will
    enable the rendering of our ticks:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ActivitySlider`类中的代码更改，这将使我们能够渲染我们的刻度：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First of all, we need to create a function that computes some ticks for us that
    we can place onto the timeline. For this purpose, we need to create the `computeTicks`
    method that will divide the whole timeline into five equal segments and generate
    timestamps that represent the position in time for individual ticks. We store
    these ticks in a new `ticks` member variable. With the help of these timestamps,
    we can render the ticks within our view easily.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个函数来计算一些刻度，这样我们就可以将它们放置到时间轴上。为此，我们需要创建`computeTicks`方法，该方法将整个时间轴分成五个相等的部分，并生成代表各个刻度时间位置的戳记。我们将这些刻度存储在一个新的`ticks`成员变量中。借助这些时间戳，我们可以在视图中轻松渲染刻度。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We use the `Array.from` ES6 function to create a new array with the desired
    length, and use the functional array extra function `map` to generate tick model
    objects from this array. Using `Array.from` is a nice trick to create an initial
    array of a given length that can be used to establish functional style.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用ES6的`Array.from`函数创建一个具有所需长度的新数组，并使用函数式数组扩展函数`map`从该数组生成刻度模型对象。使用`Array.from`是一个创建给定长度的初始数组的不错技巧，这可以用来建立函数式风格。
- en: 'Let''s look at the template of our component and how we can use our array of
    timestamps to render ticks on our slider component. We''re going to modify our
    component template in `activity-slider.html`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们组件的模板以及我们如何使用我们的时间戳数组在滑块组件上渲染刻度。我们将修改`activity-slider.html`中的组件模板：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To render our ticks, we've used an SVG group element to place our `NgFor` directive
    that repeats the tick timestamps we've stored in the `ticks` member variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染我们的刻度，我们使用了一个SVG组元素来放置我们的`NgFor`指令，该指令重复我们在`ticks`成员变量中存储的刻度时间戳。
- en: For each tick, we need to place a label as well as a line that spans over the
    slider background. We can use the SVG text element to render our label with the
    timestamp on top of the slider. Within the attribute binding for the `x` attribute
    of our `text` element, we've used our `projectTime` projection function to receive
    the projected percentage value from our timestamp. The `y` coordinate of our `text`
    element is fixed at a position where the labels will just sit on top of our slider.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个刻度，我们需要放置一个标签以及一条跨越滑块背景的线。我们可以使用SVG文本元素来渲染带有时间戳的标签，并将其放置在滑块上方。在我们的`text`元素的`x`属性绑定中，我们使用了`projectTime`投影函数来接收从时间戳中得到的投影百分比值。我们的`text`元素的`y`坐标固定在一个位置，这样标签就会正好位于滑块上方。
- en: 'SVG lines consist of four coordinates: `x1`, `x2`, `y1`, and `y2`. Together
    they define two coordinate points where a line will be drawn from one point to
    the other.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: SVG线由四个坐标组成：`x1`、`x2`、`y1`和`y2`。它们共同定义了两个坐标点，一条线将从其中一个点绘制到另一个点。
- en: Now we are getting closer to the final slider that we specified in the mock-up
    at the beginning of this topic. The last missing piece of the puzzle is to make
    our slider interactive so a user can select a range of activities.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们越来越接近我们在本主题开头所指定的最终滑块。最后缺失的拼图碎片是使我们的滑块交互式，以便用户可以选择一系列活动。
- en: Bringing it to life
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其生动起来
- en: So far, we've covered the rendering of the slider background as well as the
    rendering of the activity indicators. We've also generated ticks and displayed
    them with a grid line and a label to display the calendar time of each tick.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了滑块背景的渲染以及活动指示器的渲染。我们还生成了刻度，并用网格线和标签显示它们，以显示每个刻度的日历时间。
- en: Well, that does not really make a slider, does it? Of course, we also need to
    handle user input and make the slider interactive so users can select a time range
    they want to display the activities for.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不真正是一个滑块，对吧？当然，我们还需要处理用户输入并使滑块交互式，以便用户可以选择他们想要显示活动的时间范围。
- en: 'To do this, add the following changes to the component class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请将以下更改添加到组件类中：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we detect a change in the `activities` input property within the `ngOnChanges`
    life cycle hook, we initialize a model for the user selection in our slider component.
    It consists of a `start` and `end` property, both containing timestamps that represent
    the selected range on our activity slider.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`ngOnChanges`生命周期钩子中检测到`activities`输入属性的变化时，我们在滑块组件中初始化用户选择模型。它包含一个`start`和`end`属性，两者都包含表示活动滑块上选择范围的时间戳。
- en: Once we've set our initial selection, we need to use the `selectionChange` output
    property to emit an event. This way, we can let our parent component know that
    the selection within the slider has changed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了初始选择，我们需要使用`selectionChange`输出属性来触发一个事件。这样，我们可以让父组件知道滑块内的选择已更改。
- en: 'To display the selected range, we use an overlay rectangle within our template
    that will be placed above the slider background. If you look at the mock-up image
    of the slider again, you''ll notice that this overlay is painted in gray:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示选择范围，我们在模板中使用一个覆盖矩形，该矩形将放置在滑块背景上方。如果你再次查看滑块的模拟图像，你会注意到这个覆盖层被涂成灰色：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This rectangle will be placed just above our slider background and will use
    our projection function to calculate the `x` and `width` attributes. As we need
    to wait for change detection to initialize our selection within the `ngOnChanges`
    life cycle hook, we'll just check for a valid selection object by making use of
    the `NgIf` directive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩形将放置在我们的滑块背景上方，并使用我们的投影函数来计算`x`和`width`属性。由于我们需要等待变化检测在`ngOnChanges`生命周期钩子中初始化我们的选择，我们将通过使用`NgIf`指令来检查一个有效的选择对象。
- en: 'Now we need to start tackling user input in our `ActivitySlider` component.
    The mechanics for storing the state and rendering our selection is already in
    place, so we can implement the required host listeners to handle user input:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要开始在`ActivitySlider`组件中处理用户输入。存储状态和渲染选择的机制已经就位，因此我们可以实现所需的主监听器来处理用户输入：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code excerpt, we handled a total of four events on the slider
    host element:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在滑块宿主元素上处理了总共四个事件：
- en: '`onMouseDown`: We set our selection model''s `start` and `end` properties with
    the same value. Since we''re using timestamps for these properties, we projected
    the mouse position into the timespace first. The mouse position comes in pixels
    relative to the slider component''s origin. Since we know the slider''s width
    and the total time duration displayed, we can convert this into timestamps easily.
    We''re using the `projectLength` method for this purpose. By passing a second
    argument to the `@HostListener` decorator, we specified that we''d like to pass
    the DOM event to our `onMouseDown` method. We also set a state flag, `modifySelection`,
    in our component to indicate that a selection is under progress.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseDown`：我们使用相同的值设置选择模型的`start`和`end`属性。由于我们使用时间戳作为这些属性，我们首先将鼠标位置投影到时间空间中。鼠标位置以像素为单位相对于滑块组件的起点。由于我们知道滑块的宽度和显示的总时间长度，我们可以轻松地将这转换为时间戳。我们使用`projectLength`方法来完成此目的。通过传递第二个参数到`@HostListener`装饰器，我们指定我们希望将DOM事件传递给我们的`onMouseDown`方法。我们还在组件中设置了一个状态标志`modifySelection`，以指示正在进行选择。'
- en: '`onMouseMove`: If the component is in selection mode (the `modifySelection`
    flag is `true`), you can adjust the end property of the `selection` object. Here,
    we also made sure that we ruled out the possibility of creating a negative selection
    by using `Math.max` and limiting the end of the selection to not be smaller than
    the start.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseMove`：如果组件处于选择模式（`modifySelection`标志为`true`），您可以调整`selection`对象的结束属性。在这里，我们还确保使用`Math.max`和限制选择的结束不小于开始，从而排除了创建负选择的可能性。'
- en: '`onMouseUp`: When the user releases the mouse button, the component exits the
    selection mode. This can be done by setting the `modifySelection` flag to `false`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseUp`：当用户释放鼠标按钮时，组件退出选择模式。这可以通过将`modifySelection`标志设置为`false`来完成。'
- en: '`onMouseLeave`: This is the same as the `onMouseUp` event; the difference is
    that here the component will just exit the selection mode.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMouseLeave`：这与`onMouseUp`事件相同；区别在于这里组件将仅退出选择模式。'
- en: Using the `@HostListener` decorator, we were able to handle all of the necessary
    user input to complete our component with the interactive elements that were still
    missing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@HostListener`装饰器，我们能够处理所有必要的用户输入，以完成我们的组件，并添加了交互元素。
- en: Recap
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this topic, we learned how to use SVG in order to create graphical and interactive
    components with Angular. By creating attribute bindings on our SVG elements and
    controlling the instantiation of graphical elements using the `NgFor` and `NgIf`
    directives, we built a custom slider component that provides a nice overview of
    our activities. At the same time, we also learned how to handle user input using
    the `@HostListener` decorator in order to make our component interactive:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们学习了如何使用SVG在Angular中创建图形和交互式组件。通过在SVG元素上创建属性绑定，并使用`NgFor`和`NgIf`指令控制图形元素的实例化，我们构建了一个自定义滑块组件，它为我们提供了活动的好概述。同时，我们还学习了如何使用`@HostListener`装饰器处理用户输入，以使我们的组件具有交互性：
- en: '![Recap](img/image00327.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![概述](img/image00327.jpeg)'
- en: A screenshot of the finished activity slider component
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成活动滑块组件的截图
- en: 'To sum things up, we learned about the following concepts:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们学习了以下概念：
- en: Encapsulating component views using `ViewEncapsulation.Native` and importing
    local styles
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ViewEncapsulation.Native`封装组件视图并导入本地样式
- en: Covering some basic projections of timestamps onto screen coordinates to be
    used with SVG elements
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将时间戳的基本投影到屏幕坐标上，以便与SVG元素一起使用
- en: Handling user input and creating a custom selection mechanism using the `@HostListener`
    decorator
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@HostListener`装饰器处理用户输入并创建自定义选择机制
- en: Building the activity timeline
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建活动时间线
- en: So far, we've built a service to log activities and a slider component to select
    a time range and provide an overview using activity indicators. Since we needed
    to perform a lot of drawing tasks within the slider component, SVG was a perfect
    fit for this use case. To complete our `Activities` component tree, we still need
    to render the activities that were selected using the `ActivitySlider` component.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个记录活动和服务滑块组件以选择时间范围并提供活动指标概述的服务。由于我们需要在滑块组件内执行许多绘图任务，SVG对于这种情况非常合适。为了完成我们的`Activities`组件树，我们仍然需要渲染使用`ActivitySlider`组件选择的各项活动。
- en: 'Let''s continue to work on our activities component tree. Well create a new
    component that will be responsible for rendering an individual activity within
    an activity timeline. Let''s start with the template of the `Activity` component,
    which we will create in a new `activities/activity/activity.html` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续工作在我们的活动组件树。我们将创建一个新的组件，该组件将负责在活动时间轴内渲染单个活动。让我们从 `Activity` 组件的模板开始，我们将在新的
    `activities/activity/activity.html` 文件中创建它：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each activity will consist of a user image as well as an information box that
    will contain the activity title, message, and authoring details.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动将包括一个用户图像以及一个包含活动标题、消息和作者详细信息的信息框。
- en: Our activity will use an input to determine its alignment. This allows us to
    align the activity from outside the component. The `isAlignedRight` method helps
    us set an additional CSS class, `activity__info--align-right`, on the activity
    information box.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的活动将使用一个输入来确定其对齐方式。这使我们能够从组件外部对活动进行对齐。`isAlignedRight` 方法帮助我们为活动信息框设置一个额外的
    CSS 类，`activity__info--align-right`。
- en: 'We also need to create a component class for our `Activity` component, which
    we will create under a new `activities/activity/activity.js` file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的 `Activity` 组件创建一个组件类，我们将在新的 `activities/activity/activity.js` 文件下创建它：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our `Activity` component expects four inputs:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Activity` 组件期望四个输入：
- en: '`activity`: This property takes the data model of the activity that needs to
    be rendered with the component. This is the activity that we created using `ActivityService`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activity`：这个属性接受需要用组件渲染的活动数据模型。这是我们使用 `ActivityService` 创建的活动。'
- en: '`alignment`: This input property should be set to a string containing the word
    `left` or `right`. We used this to determine whether we needed to add an additional
    CSS class to our template in order to align the activity information box to the
    right.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignment`：这个输入属性应该设置为包含单词 `left` 或 `right` 的字符串。我们使用这个来确定我们是否需要在模板中添加一个额外的
    CSS 类，以便将活动信息框对齐到右侧。'
- en: '`startMark`: This input property acts as an input and a host binding at the
    same time. If this input is set to `true`, the activity will get an additional
    CSS class, `activity--start-mark`, which will cause a small mark on top of the
    timeline to indicate the timeline termination.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startMark`：这个输入属性同时充当输入和主机绑定。如果这个输入设置为 `true`，活动将获得一个额外的 CSS 类，`activity--start-mark`，这将导致在时间轴顶部出现一个小标记，以指示时间轴的终止。'
- en: '`endMark`: In the same way as `startMark`, this input uses a host binding to
    set an additional CSS class, `activity--end-mark`, which will cause a small mark
    on the bottom of the timeline to indicate the timeline termination.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endMark`：与 `startMark` 相同，这个输入使用主机绑定来设置一个额外的 CSS 类，`activity--end-mark`，这将导致在时间轴底部出现一个小标记，以指示时间轴的终止。'
- en: The `isAlignedRight` method is used within the template to determine whether
    we need to add an additional CSS class to the information box in order to align
    it to the right.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`isAlignedRight` 方法在模板中使用，以确定我们是否需要添加一个额外的 CSS 类到信息框，以便将其对齐到右侧。'
- en: We formatted the timestamp of the activity using the `FromNow` pipe, which we
    created in [Chapter 4](part0036.xhtml#aid-12AK82 "Chapter 4. No Comments, Please!"),
    *No Comments, Please!*. In order to use the pipe in the template, we need to import
    it and add it to the `pipes` property of our component annotation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在 [第 4 章](part0036.xhtml#aid-12AK82 "第 4 章。请勿评论！") 中创建的 `FromNow` 管道格式化了活动的日期戳，即
    *请勿评论！*。为了在模板中使用管道，我们需要导入它并将其添加到组件注解的 `pipes` 属性中。
- en: 'We now have almost all the components to display our activities. But still,
    there''s something missing, which is the glue to combine `ActivitySlider` with
    our `Activity` components and also make our component subtree navigable. For this,
    we''ll create a new component called `Activities`. Let''s create an `activities/activities.js`
    file to write our component class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎拥有了显示我们活动的所有组件。但仍然缺少一些东西，那就是将 `ActivitySlider` 与我们的 `Activity` 组件结合起来的粘合剂，并使我们的组件子树可导航。为此，我们将创建一个新的组件，称为
    `Activities`。让我们创建一个 `activities/activities.js` 文件来编写我们的组件类：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First of all, we need to know which activities we want to display within our
    component. For this, we need to provide a component input, namely `activitySubject`.
    Once this is done, we can pass an activity subject from the parent component and
    use it to filter activities we're interested in.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道我们想在组件内显示哪些活动。为此，我们需要提供一个组件输入，即 `activitySubject`。一旦完成，我们就可以从父组件传递一个活动主题，并使用它来过滤我们感兴趣的活动。
- en: Since we've used activity subjects to log activities as well, we can use the
    same subjects to display activities. In the `ngOnChanges` life cycle hook, we
    set up a subscription on the `ActivityService` instance to react to newly created
    activities. Because the activity service will notify us with an updated list of
    activities, we can simply use the `Array.prototype.filter` function to filter
    only relevant items. We've made use of the `activitySubject` input to obtain the
    ID from the subject.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已使用活动主语来记录活动，因此我们可以使用相同的主题来显示活动。在 `ngOnChanges` 生命周期钩子中，我们在 `ActivityService`
    实例上设置了一个订阅来响应新创建的活动。因为活动服务会通过更新后的活动列表来通知我们，所以我们可以简单地使用 `Array.prototype.filter`
    函数来过滤出相关项。我们已经利用了 `activitySubject` 输入来获取主题的 ID。
- en: 'Next, we need to create a method to apply a date range filter to our activities.
    The `onSelectionChange` method will be called from our `activities` template,
    where we created a binding to our `ActivitySlider` component:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个方法来对我们的活动应用日期范围过滤器。`onSelectionChange` 方法将从我们的 `activities` 模板中调用，我们在其中创建了一个与
    `ActivitySlider` 组件的绑定：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whenever the time range is updated by the user within the slider, we'll override
    the `selectedActivities` member variable with a new filtered version of the activities,
    which we'd obtain from `ActivityService`. The filter will narrow down the activities
    by comparing the activity time against the selection range from the slider component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在滑块中更新时间范围时，我们将用从 `ActivityService` 获取的新过滤版本的活动覆盖 `selectedActivities` 成员变量。过滤器将通过将活动时间与滑块组件的选择范围进行比较来缩小活动范围。
- en: 'Now we will set up some helper functions to be used within our template:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置一些辅助函数，以便在模板中使用：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The three methods, namely `getAlignment`, `isFirst`, and `isLast`, are used
    within the template as input for the `Activity` component. If you take a look
    at the code of `ActivityComponent` again, you will see that we need to provide
    some input in order to set some CSS classes for appearance. The three methods
    we created here will be used for this purpose:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 三个方法，即 `getAlignment`、`isFirst` 和 `isLast`，在模板中用作 `Activity` 组件的输入。如果你再次查看 `ActivityComponent`
    的代码，你会看到我们需要提供一些输入来设置一些 CSS 类以设置外观。我们在这里创建的三个方法将用于此目的：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we added an `OnDestroy` life cycle hook that will unsubscribe us from
    the activity's change observable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个 `OnDestroy` 生命周期钩子，该钩子将取消订阅活动的更改可观察对象。
- en: 'The template for this component is rather simple. The only thing we need to
    do is render the `ActivitySlider` component, as well as iterate over the selected
    activities and wire in the `Activity` component for each iteration:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的模板相当简单。我们唯一需要做的是渲染 `ActivitySlider` 组件，以及遍历所选活动并连接每个迭代的 `Activity` 组件：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's not much we need to explain here. We've bound `activities` and our `onSelectionChange`
    method to the slider component and iterated over all the selected activities to
    render our `Activity` components. We've created a local view variable, `index`,
    which we will use for the appearance input of the `Activity` component.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多需要解释的。我们已经将 `activities` 和我们的 `onSelectionChange` 方法绑定到滑块组件上，并遍历所有选定的活动来渲染我们的
    `Activity` 组件。我们创建了一个局部视图变量 `index`，我们将使用它作为 `Activity` 组件的外观输入。
- en: 'That''s it for our activities page! We''ve created three components that are
    composed together and display an activity stream, which provides a slider to filter
    activities for dates:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的活动页面！我们创建了三个组件，它们组合在一起并显示活动流，该流提供了一个滑块来过滤按日期的活动：
- en: '![Building the activity timeline](img/image00328.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![构建活动时间线](img/image00328.jpeg)'
- en: A screenshot of the finished activities view
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 完成活动的截图
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created an interactive slider component using SVG. While
    doing this, we learned about some SVG basics and the power of SVG within the DOM.
    Using Angular, we were able to make SVG composable, which it isn't by nature.
    We learned about namespaces, how Angular handles them, and how we can tell Angular
    that we'd like to use namespaces explicitly.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 SVG 创建了一个交互式滑块组件。在这个过程中，我们了解了一些 SVG 基础知识和 SVG 在 DOM 中的强大功能。使用 Angular，我们能够使
    SVG 可组合，这是它固有的特性。我们了解了命名空间，Angular 如何处理它们，以及我们如何告诉 Angular 我们希望显式使用命名空间。
- en: Besides using SVG for our slider component, we also learned how to use Shadow
    DOM to create native view encapsulation. As a result of this, we were able to
    use local styles for our component. We don't need to worry about CSS name clashes,
    specificity, and global CSS side effects any more when using local styles.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在我们的滑块组件中使用 SVG，我们还学习了如何使用 Shadow DOM 来创建原生视图封装。因此，我们能够为我们的组件使用本地样式。当我们使用本地样式时，不再需要担心
    CSS 命名冲突、特异性和全局 CSS 的副作用。
- en: The whole code for this chapter can be found in the ZIP file of the book resources
    that you can download from the Packt Publishing website.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的全部代码可以在您从 Packt Publishing 网站下载的书籍资源 ZIP 文件中找到。
- en: In the next chapter, we're going to enhance what we've built throughout the
    chapters so far. We will create some components to enrich the user experience
    within our application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将增强到目前为止我们在各个章节中构建的内容。我们将创建一些组件来丰富我们应用程序内的用户体验。
