- en: '*Chapter 8*: Using a Custom Server'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：使用自定义服务器'
- en: Next.js is an incredibly powerful framework. In the first seven chapters of
    this book, we've been able to create some nice server-side rendered web applications
    without really caring about tweaking and customizing the web server. Of course,
    there are few chances for us to discuss implementing a Next.js application inside
    an Express.js or Fastify server in a real-life scenario, but knowing how to do
    so is likely to be handy on many occasions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 是一个非常强大的框架。在这本书的前七章中，我们已经能够创建一些不错的服务器端渲染 Web 应用程序，而无需真正关心调整和自定义 Web
    服务器。当然，在现实生活中，我们讨论在 Express.js 或 Fastify 服务器中实现 Next.js 应用程序的机会很少，但了解如何这样做在很多情况下可能很有用。
- en: Talking for myself, in the past years, I've created dozens of large-scale web
    applications using Next.js, and I rarely needed to use a custom server. However,
    in some cases, it is inevitable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以我自己的经验来说，在过去几年里，我使用 Next.js 创建了数十个大规模 Web 应用程序，我很少需要使用自定义服务器。然而，在某些情况下，这是不可避免的。
- en: 'We will look at the following topics in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨以下主题：
- en: What using a "custom server" means, when we might need to use it, and what are
    the options.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们可能需要使用“自定义服务器”时，它的含义是什么，以及有哪些选项。
- en: How to use Express.js and Next.js together
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何一起使用 Express.js 和 Next.js
- en: How to use Fastify and Next.js together
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何一起使用 Fastify 和 Next.js
- en: What are the requirements for deploying a custom server?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署自定义服务器有哪些要求？
- en: By the end of this chapter, you'll be able to determine when to use a custom
    server, what its advantages and downsides are, and what problems it can solve.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够确定何时使用自定义服务器，它的优缺点是什么，以及它可以解决什么问题。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    `npm` installed on your local machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，你需要在本地机器上安装 Node.js 和 `npm`。
- en: 'If you prefer, you can use an online IDE such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js,
    and you don''t need to install any dependency on your computer. As with the other
    chapters, you can find the codebase for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以使用在线 IDE，例如 [https://repl.it](https://repl.it) 或 [https://codesandbox.io](https://codesandbox.io)；它们都支持
    Next.js，你不需要在电脑上安装任何依赖。与其他章节一样，你可以在 GitHub 上找到本章的代码库：https://github.com/PacktPublishing/Real-World-Next.js。
- en: About using a custom server
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于使用自定义服务器
- en: 'As we''ve already seen, Next.js ships with its own server, so we don''t need
    to configure a custom one to get started with writing web applications with this
    framework. Still, there are some cases where we may want to serve a Next.js app
    from a custom web server, such as Express.js or Fastify, and the framework makes
    this possible by exposing some straightforward APIs that we''ll be looking into
    in just one moment. But before looking at the implementation, let''s answer an
    important question: *do we really need a custom server?*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，Next.js 随带自己的服务器，因此我们不需要配置自定义服务器就可以开始使用这个框架编写 Web 应用程序。然而，在某些情况下，我们可能希望从自定义
    Web 服务器（如 Express.js 或 Fastify）中提供服务 Next.js 应用程序，框架通过公开一些简单的 API 来实现这一点，我们将在下一刻探讨。但在查看实现之前，让我们回答一个重要的问题：*我们真的需要自定义服务器吗？*
- en: The short answer is, most of the time, *no*. Next.js is such a complete framework
    that we rarely need to customize the server-side logic via Express.js, Fastify,
    or any other server-side framework. But sometimes, it is just inevitable, as it
    can solve specific problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，大多数时候，*不需要*。Next.js 是一个如此完整的框架，我们很少需要通过 Express.js、Fastify 或其他任何服务器端框架来定制服务器端逻辑。但有时，这是不可避免的，因为它可以解决特定的问题。
- en: 'Some common use cases for a custom server are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义服务器的常见用例如下：
- en: '**Integrating Next.js into an existing server**: Suppose you''re refactoring
    an existing web application to adopt Next.js; you may want to maintain as much
    server-side logic as possible, your middlewares, and routes. In that case, you
    can progressively add Next.js by choosing which pages of your websites will be
    served from the framework and which ones will be rendered by something else.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 Next.js 集成到现有服务器中**：假设你正在重构一个现有的 Web 应用程序以采用 Next.js；你可能希望尽可能多地保留服务器端逻辑，包括你的中间件和路由。在这种情况下，你可以通过选择你的网站哪些页面将由框架提供服务，哪些页面将由其他方式渲染来逐步添加
    Next.js。'
- en: '**Multi-tenancy**: Even though Next.js supports multiple domains and conditional
    rendering depending on the current hostname (look at [https://github.com/leerob/nextjs-multiple-domains](https://github.com/leerob/nextjs-multiple-domains)
    if you''re interested in a native solution), there are cases where you may need
    more control and a simplified workflow for handling up to thousands of different
    domains. If you''re interested in an Express.js/Fastify multi-tenant middleware
    for Next.js, you can take a look at [https://github.com/micheleriva/krabs](https://github.com/micheleriva/krabs).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多租户模式**：尽管 Next.js 支持根据当前主机名支持多个域名和条件渲染（如果你对原生解决方案感兴趣，请查看 [https://github.com/leerob/nextjs-multiple-domains](https://github.com/leerob/nextjs-multiple-domains)），但在某些情况下，你可能需要更多的控制权以及一个简化的工作流程来处理多达数千个不同的域名。如果你对
    Next.js 的 Express.js/Fastify 多租户中间件感兴趣，可以查看 [https://github.com/micheleriva/krabs](https://github.com/micheleriva/krabs)。'
- en: '**You want more control**: Even though Next.js provides everything you need
    for creating a robust and complete user experience, there are cases where your
    app is growing in complexity and you want to organize the backend code using different
    approaches, such as adopting the MVC philosophy, where Next.js is just the "view"
    part of the process.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你想要更多的控制权**：尽管 Next.js 为创建强大和完整的用户体验提供了所需的一切，但在某些情况下，如果你的应用程序正在变得更加复杂，你想要使用不同的方法来组织后端代码，例如采用
    MVC 哲学，其中 Next.js 只是过程中的“视图”部分。'
- en: While a custom server could solve some problems, it also has some downsides.
    For instance, you cannot deploy a custom server to Vercel, the platform created
    by the Next.js authors, which is highly optimized for the framework. Also, you'll
    need to write and maintain more code, which can be a significant downside if you're
    working on a side project, in a small team, or for a small company.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自定义服务器可以解决一些问题，但它也有一些缺点。例如，你不能将自定义服务器部署到由 Next.js 作者创建的 Vercel 平台，该平台高度优化了框架。此外，你将需要编写和维护更多的代码，如果你在一个侧项目中工作，在一个小团队中，或者在一个小公司中，这可能会是一个重大的缺点。
- en: 'In the next section, we''ll see how to write a custom server for Next.js using
    one of the most popular web frameworks for Node.js: Express.js.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用 Node.js 最受欢迎的 Web 框架之一 Express.js 为 Next.js 编写自定义服务器。
- en: Using a custom Express.js server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义 Express.js 服务器
- en: 'Writing a custom Express.js server to render Next.js pages is easier than you
    might think. Let''s create a new project and install the following dependencies:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编写用于渲染 Next.js 页面的自定义 Express.js 服务器比你想象的要简单。让我们创建一个新的项目并安装以下依赖项：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we''ve installed these four packages, we can start writing a custom Express.js
    server. Let''s create an `index.js` file inside the project root and start by
    importing the required dependencies:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了这四个包，我们就可以开始编写自定义的 Express.js 服务器。让我们在项目根目录下创建一个 `index.js` 文件，并首先导入所需的依赖项：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We now need to instantiate the Next.js app, and we can do that by adding the
    following code right after the import statements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要实例化 Next.js 应用程序，我们可以在导入语句之后添加以下代码来完成此操作：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s complete our server by writing the `main` function, which takes every
    incoming `GET` request and passes it to Next.js for server-side rendering:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写 `main` 函数来完成我们的服务器，该函数将每个传入的 `GET` 请求传递给 Next.js 进行服务器端渲染：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's focus on the `main` function body and see what's going on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注 `main` 函数的主体，看看发生了什么。
- en: First of all, we wait for the Next.js app to be ready for rendering. Then, we
    instantiate a `handle` constant, which will handle the incoming requests on behalf
    of Next.js. We then create the Express.js server and ask it to handle all the
    `GET` requests using the Next.js request handler.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们等待 Next.js 应用程序准备好进行渲染。然后，我们创建一个 `handle` 常量，该常量将代表 Next.js 处理传入的请求。然后，我们创建
    Express.js 服务器，并要求它使用 Next.js 请求处理程序处理所有 `GET` 请求。
- en: 'We can now create a home page by creating a new `pages/` directory and a `pages/index.js`
    file with the following content:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过创建一个新的 `pages/` 目录和一个 `pages/index.js` 文件来创建一个主页，该文件包含以下内容：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we try to run `node index.js`, and then go to `http://localhost:3000`, we
    will see the **Homepage** text displayed on the screen. We did it!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行 `node index.js`，然后访问 `http://localhost:3000`，我们将在屏幕上看到 **主页** 文本。我们做到了！
- en: 'We can also test dynamic routes by creating a new `pages/greet/[user].js` file
    with the following content:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过创建一个包含以下内容的 `pages/greet/[user].js` 文件来测试动态路由：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Going to `http://localhost:3000/greet/Mitch`, we will see a friendly **Hello
    Mitch!** message printed on the screen. As you can see, implementing dynamic routes
    is incredibly easy!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:3000/greet/Mitch`，我们将在屏幕上看到一个友好的 **Hello Mitch!** 消息。正如你所见，实现动态路由非常简单！
- en: From this point, we can continue working on Next.js as we always did. There
    aren't many differences compared to what we did in the previous chapters, but
    what would be the point of having a custom server if we did not exploit its full
    potential?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，我们可以继续像以前一样工作在 Next.js 上。与上一章相比，没有太多区别，但如果我们没有充分利用自定义服务器的全部潜力，那么拥有一个自定义服务器有什么意义呢？
- en: We've seen that a custom server may be helpful when we have an existing web
    application that we wish to progressively migrate to Next.js.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当我们将现有的 Web 应用程序逐步迁移到 Next.js 时，自定义服务器可能非常有帮助。
- en: 'Start adding some more functionality by refactoring the server as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过如下重构服务器来添加一些更多功能：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can tell, we're not serving any page with Next.js right now. So instead,
    we just serve a home page, and a fake API at `/api/greet`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们现在并没有用 Next.js 服务任何页面。所以，我们只是提供了一个主页，并在 `/api/greet` 提供了一个假 API。
- en: 'We now want to create a new `/about` page and serve it using Next.js. But first,
    we need to create the Next.js-powered page under the `/pages/about` route:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要创建一个新的 `/about` 页面并使用 Next.js 来提供服务。但首先，我们需要在 `/pages/about` 路径下创建一个由
    Next.js 驱动的页面：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can go back to our `index.js` file and edit the `main` function, as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到我们的 `index.js` 文件并编辑 `main` 函数，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''re now using a different function for rendering a Next.js page: `app.render`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用一个不同的函数来渲染 Next.js 页面：`app.render`。
- en: 'This function takes the following arguments: Express.js'' `request` and `response`,
    the page to render, and the parsed query string.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受以下参数：Express.js 的 `request` 和 `response`、要渲染的页面以及解析后的查询字符串。
- en: 'But as soon as we start the server and head over to `http://localhost:3000/about`,
    we will notice a blank page. If we inspect the network call for this page, we
    will see the following situation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们启动服务器并访问 `http://localhost:3000/about` 时，我们会注意到一个空白页面。如果我们检查此页面的网络调用，我们会看到以下情况：
- en: '![Figure 8.1 – Next.js scripts are not found'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – Next.js 脚本未找到'
- en: '](img/Figure_8.01_B16985.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.01_B16985.jpg)'
- en: Figure 8.1 – Next.js scripts are not found
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Next.js 脚本未找到
- en: What's happening here? Next.js renders the page properly, as you can tell by
    inspecting the HTML output, but the page is entirely white!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？Next.js 正确渲染了页面，正如你可以通过检查 HTML 输出所知，但页面完全是白色的！
- en: We forgot to tell Express.js that every static asset whose path starts with
    `_next/` needs to be handled by Next.js itself. This is because all those static
    assets (typically JavaScript files) are responsible for importing React into the
    browser, handling hydration, and managing all the Next.js frontend-specific features.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忘记告诉 Express.js，每个以 `_next/` 开头的静态资源都需要由 Next.js 本身处理。这是因为所有这些静态资源（通常是 JavaScript
    文件）都负责将 React 导入浏览器，处理水合，以及管理所有 Next.js 前端特定功能。
- en: 'We can quickly fix that by adding the following route:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加以下路由来快速修复这个问题：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Given that we cannot predict Next.js static asset names, we will use a regular
    expression (`/_next\/.+/`) matching every file whose path starts with `_next/`.
    We then use the Next.js handle method for serving those files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法预测 Next.js 静态资源名称，我们将使用一个正则表达式 (`/_next\/.+/`) 匹配所有以 `_next/` 开头的文件。然后我们使用
    Next.js 的 handle 方法来服务这些文件。
- en: We can now start our server and see that it is working as expected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以启动我们的服务器并看到它按预期工作。
- en: As we've seen before, from now, the developer experience will remain the same
    while developing Next.js-powered pages. We still have access to both the `_app.js`
    and `_document.js` files, we can still use the built-in `Link` component, and
    so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，从现在开始，开发 Next.js 页面的开发者体验将保持不变。我们仍然可以访问 `_app.js` 和 `_document.js`
    文件，我们仍然可以使用内置的 `Link` 组件，等等。
- en: 'In the next section, we will see how to integrate Next.js with another incredibly
    popular Node.js web framework: Fastify.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何将 Next.js 与另一个非常流行的 Node.js 网络框架 Fastify 集成。
- en: Using a custom Fastify server
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义 Fastify 服务器
- en: 'Fastify is an incredible web framework for Node.js. As the name suggests, it
    can be attractive as it is really, really fast when compared to other web frameworks,
    such as Express.js, Koa, and Hapi. If you''re interested in learning more about
    its performance, you can find the official benchmarks in the following repository:
    [https://github.com/fastify/benchmarks](https://github.com/fastify/benchmarks).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Fastify 是一个出色的 Node.js 网络框架。正如其名称所暗示的，与其他网络框架（如 Express.js、Koa 和 Hapi）相比，它非常吸引人，因为它确实非常快。如果您想了解更多关于其性能的信息，您可以在以下存储库中找到官方基准测试：[https://github.com/fastify/benchmarks](https://github.com/fastify/benchmarks)。
- en: This web framework is developed and maintained by some of Node.js' core developers,
    such as Matteo Collina (Node.js technical steering committee member). So, as you
    can imagine, the people behind Fastify perfectly know how the runtime works and
    have made the framework as optimized as possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络框架是由一些 Node.js 的核心开发者开发和维护的，例如 Matteo Collina（Node.js 技术指导委员会成员）。因此，正如您所想象的，Fastify
    背后的团队完美地了解运行时的工作原理，并使框架尽可能优化。
- en: 'But Fastify is not just about the performance: it also enforces excellent best
    practices to keep the developer experience as good as possible. It also has a
    robust plugin system that allows everyone to write their own plugin or middleware
    with ease. If you haven''t already, I highly recommend checking it out at https://github.com/fastify/fastify.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Fastify 不仅仅关于性能：它还强制执行优秀的设计最佳实践，以尽可能保持开发者的体验。它还有一个强大的插件系统，允许每个人轻松编写自己的插件或中间件。如果您还没有这样做，我强烈建议您在
    https://github.com/fastify/fastify 上查看。
- en: 'Fastify provides an official plugin for managing Next.js-rendered routes: `fastify-nextjs`.
    You can find its source code here: https://github.com/fastify/fastify-nextjs.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Fastify 提供了一个官方插件来管理 Next.js 渲染的路由：`fastify-nextjs`。您可以在以下位置找到其源代码：https://github.com/fastify/fastify-nextjs。
- en: 'Let''s create a new empty project and install the following dependencies to
    see it in action:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的空项目，并安装以下依赖项以查看其效果：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can now create the same three pages we made in the past section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建与过去章节中相同的三个页面。
- en: 'A simple home page under `/pages/index.js` can be implemented as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/pages/index.js` 下实现一个简单的首页如下：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An "about" page under `/pages/about.js` can be implemented as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/pages/about.js` 下实现一个“关于”页面如下：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, a dynamic page used for greeting a user under `/pages/greet/[user].js`
    can be implemented as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个用于在 `/pages/greet/[user].js` 下问候用户的动态页面可以按以下方式实现：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can finally code our Fastify server, and it will be straightforward compared
    to the Express.js one. Let''s create an `index.js` file inside of the project''s
    root and add the following content:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写我们的 Fastify 服务器了，与 Express.js 相比，这将非常简单。让我们在项目的根目录下创建一个 `index.js` 文件，并添加以下内容：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Starting the server, we will be able to render all the pages we specified in
    our `index.js` file! As you can notice, this implementation is even easier than
    the Express.js one. We just invoke the `fastify.next` function to render a Next.js
    page, and we don't even need to worry about Next.js' static assets; Fastify will
    take care of them on our behalf.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器后，我们将能够渲染我们在 `index.js` 文件中指定的所有页面！如您所注意到的，这种实现甚至比 Express.js 更简单。我们只需调用
    `fastify.next` 函数来渲染一个 Next.js 页面，而且我们甚至不需要担心 Next.js 的静态资源；Fastify 会代表我们处理它们。
- en: 'From this point, we can start writing different routes serving different contents,
    such as JSON responses, HTML pages, and static files:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们可以开始编写不同的路由，提供不同的内容，例如 JSON 响应、HTML 页面和静态文件：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, integrating Next.js with Fastify is incredibly easy. From this
    point, just like with Express.js, we can do whatever we want, just like we're
    writing a common Next.js web application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将 Next.js 与 Fastify 集成非常简单。从这一点开始，就像与 Express.js 一样，我们可以做任何我们想做的事情，就像我们正在编写一个普通的
    Next.js 网络应用程序。
- en: We can create both `_app.js` and `_document.js` files to customize our Next.js
    pages' behavior, integrate any UI library, and do all the things we've already
    seen in the previous chapters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建 `_app.js` 和 `_document.js` 文件来定制 Next.js 页面的行为，集成任何 UI 库，并执行我们在前面章节中看到的所有事情。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we''ve seen how to integrate Next.js with two of the most
    popular web frameworks for Node.js: Express.js and Fastify. It is possible to
    integrate Next.js with other web frameworks, and the implementation won''t be
    different from what we''ve seen in the previous sections.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何将 Next.js 与 Node.js 最受欢迎的两个网络框架集成：Express.js 和 Fastify。Next.js 与其他网络框架集成也是可能的，其实现方式与前面章节中看到的不同。
- en: One thing to consider when using a custom server of any kind (be it Express.js,
    Fastify, or any other framework) is that we cannot deploy it to some providers,
    such as Vercel or Netlify.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用任何类型的自定义服务器时（无论是Express.js、Fastify还是任何其他框架），需要考虑的一点是我们不能将其部署到某些提供商，例如Vercel或Netlify。
- en: 'Technically speaking, many providers (Vercel, Netlify, Cloudflare, and so on)
    provide a great way to serve Node.js-powered applications: serverless functions.
    However, since this is quite an advanced topic, we will discuss it in depth in
    [*Chapter 11*](B16985_11_Final_SB_epub.xhtml#_idTextAnchor113), *Different Deployment
    Platforms*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，许多提供商（Vercel、Netlify、Cloudflare等等）提供了一种很好的方式来服务由Node.js驱动的应用程序：无服务器函数。然而，由于这是一个相当高级的话题，我们将在[*第11章*](B16985_11_Final_SB_epub.xhtml#_idTextAnchor113)，“不同的部署平台”中深入讨论它。
- en: As we'll see in [*Chapter 11*](B16985_11_Final_SB_epub.xhtml#_idTextAnchor113),
    *Different Deployment Platforms*, Next.js is a framework highly optimized to run
    on Vercel, the infrastructure provided by the company behind the creation (and
    maintenance) of the framework. Using a custom server, we lose the ability to deploy
    to this infrastructure, making things a bit less optimized and integrated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[*第11章*](B16985_11_Final_SB_epub.xhtml#_idTextAnchor113)，“不同的部署平台”中看到的那样，Next.js是一个高度优化以在Vercel上运行的框架，这是框架背后的公司提供的基础设施。使用自定义服务器，我们将失去部署到这个基础设施的能力，这使得事情变得稍微不那么优化和集成。
- en: Still, there are other awesome options out there, such as DigitalOcean, Heroku,
    AWS, and Azure. From this point, we can deploy our custom Next.js server on all
    of those services that support a Node.js environment.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然，还有其他一些很棒的选择，例如DigitalOcean、Heroku、AWS和Azure。从这一点来看，我们可以在所有支持Node.js环境的这些服务上部署我们的自定义Next.js服务器。
- en: Starting from [*Chapter 11*](B16985_11_Final_SB_epub.xhtml#_idTextAnchor113),
    *Different Deployment Platforms*, we will discuss Next.js deployments in more
    depth. But for now, we just want to concentrate on its features and integrations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第11章*](B16985_11_Final_SB_epub.xhtml#_idTextAnchor113)，“不同的部署平台”开始，我们将更深入地讨论Next.js的部署。但到目前为止，我们只想集中讨论其功能和集成。
- en: 'Talking about its integrations specifically, once we write a page, some middleware,
    or a component for our Next.js application, we want to test whether it works properly
    before deploying it to production. In the next chapter, we''ll discuss implementing
    unit and end-to-end tests using two of the most commonly used testing libraries
    out there: Jest and Cypress.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 具体谈到其集成，一旦我们为我们的Next.js应用程序编写了一个页面、一些中间件或一个组件，我们希望在将其部署到生产环境之前测试它是否正常工作。在下一章中，我们将讨论使用两个最常用的测试库来实现单元和端到端测试：Jest和Cypress。
