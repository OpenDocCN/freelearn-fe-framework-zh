<html><head></head><body>
<div id="_idContainer070">
<h1 class="chapter-number" id="_idParaDest-142"><a id="_idTextAnchor285"/><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-143"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.2.1">Micro Frontend with Angular Elements</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As your application grows and becomes more complex, one team alone is not enough to maintain the growth rate, and new people are needed to handle other parts of the application as they appear. </span><span class="koboSpan" id="kobo.3.2">At this point, the architecture of your project needs to evolve, and one possibility is to divide your application into several projects that are integrated as one. </span><span class="koboSpan" id="kobo.3.3">This practice was born in the world of backend services and appears in the frontend world under the name</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.4.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">micro frontends</span></strong><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">In this chapter, we will learn how to apply this principle in an </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Angular project.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Micro frontend – concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">and application</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Slicing your application in the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">micro frontend</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Creating a micro frontend application with </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">standalone components</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Preparing a page to be loaded by the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">base application</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Dynamically loading </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">micro frontends</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.20.1">By the end of this chapter, you will be able to assess when it is necessary to use a micro frontend, how to organize your Angular projects, and how to integrate it into a </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">cohesive application.</span></span><a id="_idTextAnchor288"/></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.25.1">Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Code (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.31.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.32.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Before you start reading this chapter, remember to run the backend of the application found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">gym-diary-backend</span></strong><span class="koboSpan" id="kobo.39.1"> folder with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.42.1"> command</span><a id="_idTextAnchor290"/><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.44.1">Micro frontend – concepts and application</span></h1>
<p><span class="koboSpan" id="kobo.45.1">In 2014, an </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.46.1">article by Martin Fowler and James Lewis (</span><a href="https://martinfowler.com/articles/microservices.html"><span class="koboSpan" id="kobo.47.1">https://martinfowler.com/articles/microservices.html</span></a><span class="koboSpan" id="kobo.48.1">) shook the world of development with the formalization of the concept of microservices. </span><span class="koboSpan" id="kobo.48.2">Focused on the development of backend services, the idea of dividing a large system (known as a monolith) into small, independent services focused on just one aspect of the business was undoubtedly a milestone for </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">system architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Not long after, this concept was applied to the frontend world, with one of the main articles written by Cam Jackson (</span><a href="https://martinfowler.com/articles/micro-frontends.html"><span class="koboSpan" id="kobo.51.1">https://martinfowler.com/articles/micro-frontends.html</span></a><span class="koboSpan" id="kobo.52.1">). </span><span class="koboSpan" id="kobo.52.2">The basic idea of the </span><em class="italic"><span class="koboSpan" id="kobo.53.1">micro frontend</span></em><span class="koboSpan" id="kobo.54.1"> is the same as its sibling, </span><em class="italic"><span class="koboSpan" id="kobo.55.1">microservices</span></em><span class="koboSpan" id="kobo.56.1">, which </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.57.1">consists of dividing a large frontend project (monolith) into small, independent projects focused on one aspect of the business. </span><span class="koboSpan" id="kobo.57.2">However, the concerns are different, of course. </span><span class="koboSpan" id="kobo.57.3">In microservices, we worry about databases and communication protocols, whereas on the frontend, we need to worry about packet size, accessibility, and </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Let’s start by analyzing whether you need to use this type of architecture for </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">your projec</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.61.1">t.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.62.1">When to use a micro frontend</span></h2>
<p><span class="koboSpan" id="kobo.63.1">A big but very true cliché in systems architecture is that there is no silver bullet – that is, there is no one-size-fits-all solution for all problems – and micro frontends cannot escape this cliché. </span><span class="koboSpan" id="kobo.63.2">The main advantage of this architecture, before any technical aspect, is its </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">organizational aspect.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">When we use the micro frontend, we are separating an independent part focused on one aspect of the business that will be handled by a team specializing in that aspect. </span><span class="koboSpan" id="kobo.65.2">With this, your project can scale across different teams dealing with specific subjects that will be integrated into an experience for your user. </span><span class="koboSpan" id="kobo.65.3">Each team has autonomy in the delivery cycle of this project, with independence from build, deployment, and testing. </span><span class="koboSpan" id="kobo.65.4">Independence can reach a level where teams can work with different versions of Angular and even different frameworks such as React and Vue, although this is not highly recommended, as we will discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">next sect</span><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.67.1">i</span><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.68.1">on.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.69.1">When not to use a micro frontend project</span></h2>
<p><span class="koboSpan" id="kobo.70.1">Another </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.71.1">software engineering cliché is that there is no free lunch, and choosing to use micro frontends has its costs </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">and challenges.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The first challenge is the performance issue of your frontend. </span><span class="koboSpan" id="kobo.73.2">As we saw in </span><a href="B19562_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.74.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.75.1">, </span><em class="italic"><span class="koboSpan" id="kobo.76.1">Starting Projects the Right Way</span></em><span class="koboSpan" id="kobo.77.1">, in a </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">single-page application</span></strong><span class="koboSpan" id="kobo.79.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.80.1">SPA</span></strong><span class="koboSpan" id="kobo.81.1">), the user’s browser downloads the application bundle </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.82.1">containing the Angular framework code, in addition to the code that your team produced. </span><span class="koboSpan" id="kobo.82.2">After this download, the browser interprets the bundle and renders the pages for the user. </span><span class="koboSpan" id="kobo.82.3">This entire process must be as quick and efficient as possible because, while it is occurring, the user cannot interact with the screen, </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">causing frustration.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">Now imagine this process happening in every part of your system because, to guarantee version and even framework independence, each micro frontend carries its framework engine in the specific version. </span><span class="koboSpan" id="kobo.84.2">There </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.85.1">are techniques and tools such as webpack’s module federation (</span><a href="https://webpack.js.org/concepts/module-federation/"><span class="koboSpan" id="kobo.86.1">https://webpack.js.org/concepts/module-federation/</span></a><span class="koboSpan" id="kobo.87.1">), but you and your team must evaluate </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">this challenge.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Another care we must take is concerning the user experience and the design of the components on screen because, for them, the components between interfaces must be fundamentally the same to guarantee cohesion in </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">their experience.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">This challenge can be overcome by implementing a design system – that is, a single design guide for your company’s components, preferably with a library that supports it. </span><span class="koboSpan" id="kobo.91.2">An example of a design system is Google’s </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">Material Design.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Now that we have a basic understanding of micro frontends, let’s move on to the next section, where we will explore how to split our application into </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">micro front</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.95.1">ends.</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.96.1">Slicing your application into micro frontends</span></h1>
<p><span class="koboSpan" id="kobo.97.1">To</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.98.1"> maximize gains from the micro frontend architecture</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.99.1"> and minimize the risks defined in the previous section, we need to create microservices that are as independent as possible and that make sense for your </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">team’s organization.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">The most common type of project organization is the verticalization of functionalities – that is, for one project you might have an entire user journey, such as a product purchase screen, another project for product registration, and another for the administration module of </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">the application.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.103.1"><img alt="Figure 11.1 – Micro frontend division" src="image/B19562_11_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.104.1">Figure 11.1 – Micro frontend division</span></p>
<p><span class="koboSpan" id="kobo.105.1">This diagram exemplifies the concept of division using an Angular application. </span><span class="koboSpan" id="kobo.105.2">In each project, we have all the components for the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">You may be wondering, “</span><em class="italic"><span class="koboSpan" id="kobo.108.1">Can I achieve this same separation using Angular modules?</span></em><span class="koboSpan" id="kobo.109.1">” and the answer is yes, you can. </span><span class="koboSpan" id="kobo.109.2">If a team takes care of all the modules for your company’s organization or the teams can organize themselves into just one project, you can (and even should) </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">We need to </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.112.1">keep in mind that the reason for dividing </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.113.1">your project into micro frontends is to meet an organizational requirement of your project, and teams want to have deployment and </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">development independence.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">With the basic concepts in mind, we will exemplify how to implement them in our gym </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">diary</span><a id="_idTextAnchor300"/> <a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.117.1">project.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.118.1">Creating a micro frontend application with standalone components</span></h1>
<p><span class="koboSpan" id="kobo.119.1">To </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.120.1">exemplify the</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.121.1"> use of the micro frontend architecture in our gym diary, we will create a form to define new exercises for our users. </span><span class="koboSpan" id="kobo.121.2">Let’s create another Angular project, simulating a new team that will specifically take care of this functionality. </span><span class="koboSpan" id="kobo.121.3">In your operating system’s command line, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.123.1">
ng new gym_exercises --skip-git --standalone --routing false --style css</span></pre> <p><span class="koboSpan" id="kobo.124.1">We learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">ng new</span></strong><span class="koboSpan" id="kobo.126.1"> command in </span><a href="B19562_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.127.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.128.1">, </span><em class="italic"><span class="koboSpan" id="kobo.129.1">Starting Projects the Right Way</span></em><span class="koboSpan" id="kobo.130.1">, but here we are using some parameters that we haven’t seen before. </span><span class="koboSpan" id="kobo.130.2">We are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">skip-git</span></strong><span class="koboSpan" id="kobo.132.1"> parameter because, in this example, we are creating it in the same Git project (which already has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">gym-diary</span></strong><span class="koboSpan" id="kobo.134.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">gym-backend</span></strong><span class="koboSpan" id="kobo.136.1"> projects). </span><span class="koboSpan" id="kobo.136.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">routing</span></strong><span class="koboSpan" id="kobo.138.1"> parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">false</span></strong><span class="koboSpan" id="kobo.140.1"> because our project will be loaded in the diary application route, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">style</span></strong><span class="koboSpan" id="kobo.142.1"> parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">CSS</span></strong><span class="koboSpan" id="kobo.144.1"> so the Angular CLI does not need to ask what type of styling our project </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">will have.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">The biggest difference in this command is </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">standalone</span></strong><span class="koboSpan" id="kobo.148.1">, which parameterized our project to create all components as standalone by default. </span><span class="koboSpan" id="kobo.148.2">But you might be wondering what a </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">standalone</span></strong><span class="koboSpan" id="kobo.150.1"> component is. </span><span class="koboSpan" id="kobo.150.2">Created from version 15 of Angular, this feature allows you to create a component without using Angular modules (</span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">NgModule</span></strong><span class="koboSpan" id="kobo.152.1">). </span><span class="koboSpan" id="kobo.152.2">Although modules are very important, as we saw in </span><a href="B19562_02.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.153.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.154.1">, </span><em class="italic"><span class="koboSpan" id="kobo.155.1">Organizing Your Application</span></em><span class="koboSpan" id="kobo.156.1">, there are cases in which they are not very useful and make the project unnecessarily complicated. </span><span class="koboSpan" id="kobo.156.2">A good example of this is in small projects with a limited scope, such as this micro frontend, where we will not have multiple routes or </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">lazy loading.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Before we start creating the exercise form, let’s add and configure the Tailwind CSS framework, as we want to have a style compatible with our main application. </span><span class="koboSpan" id="kobo.158.2">Inside the created project folder, run the following command from the command line of your </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">operating system:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.160.1">
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init</span></pre> <p><span class="koboSpan" id="kobo.161.1">This </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.162.1">command will add development dependencies to the project and create configuration files in the Tailwind </span><a id="_idIndexMarker510"/><span class="No-Break"><span class="koboSpan" id="kobo.163.1">CSS framework.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">tailwind.config.js</span></strong><span class="koboSpan" id="kobo.166.1"> file, make the </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">following changes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{html,ts}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}</span></pre> <p><span class="koboSpan" id="kobo.169.1">In this file, we are telling Angular that it will apply the Tailwind CSS framework to all HTML files in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">src</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Finally, add the following lines of code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">app.component.css</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
@tailwind base;
@tailwind components;
@tailwind utilities;</span></pre> <p><span class="koboSpan" id="kobo.176.1">With these CSS variables, the component will have access to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">tailwindcss</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">We will then create a service that will be responsible for interacting with our backend’s exercise API. </span><span class="koboSpan" id="kobo.179.2">On the command line, we will use </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.181.1">
ng g service service/Exercises
ng g interface exercise</span></pre> <p><span class="koboSpan" id="kobo.182.1">Note </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.183.1">a detail of our </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.184.1">architecture: we already have a service that queries the exercise API in our main project, but we cannot reuse it here because they are independent projects, and certain code duplication is a cost of </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">this architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Following the best practices, we will create our API </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
Export interface Exercise {
  id?: string;
  description: string;
}
export type ExerciseList = Array&lt;Exercise&gt;;
export interface ExerciseListAPI {
  hasNext: boolean;
  items: ExerciseList;
};</span></pre> <p><span class="koboSpan" id="kobo.189.1">Here, we are recreating the types that represent the API data. </span><span class="koboSpan" id="kobo.189.2">For more details about TypeScript interfaces, you can consult </span><a href="B19562_03.xhtml#_idTextAnchor112"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.190.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.191.1">, </span><em class="italic"><span class="koboSpan" id="kobo.192.1">TypeScript Patterns </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.193.1">for Angular</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">In the created service, we will add interaction with </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the backend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
@Injectable({
  providedIn: 'root',
})
export class ExercisesService {
  private httpClient = inject(HttpClient);
  private url = 'http://localhost:3000/exercises';
  getExercises(): Observable&lt;ExerciseList&gt; {
    return this.httpClient
      .get&lt;ExerciseListAPI&gt;(`${this.url}`)
      .pipe(map((api) =&gt; api?.items));
  }
  addExercises(exercises: Partial&lt;Exercise&gt;): Observable&lt;Exercise&gt; {
    return this.httpClient.post&lt;Exercise&gt;(this.url, exercises);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.198.1">In the </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.199.1">service, we are</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.200.1"> making HTTP requests to consult exercises and add new ones. </span><span class="koboSpan" id="kobo.200.2">For more details about Angular services, you can consult </span><a href="B19562_05.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.201.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.202.1">, </span><em class="italic"><span class="koboSpan" id="kobo.203.1">Angular Services and the Singleton Pattern</span></em><span class="koboSpan" id="kobo.204.1">, and </span><a href="B19562_09.xhtml#_idTextAnchor242"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.205.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.206.1">, </span><em class="italic"><span class="koboSpan" id="kobo.207.1">Exploring Reactivity </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.208.1">with RxJS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">However, we are experiencing an error because we are not importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">HttpClientModule</span></strong><span class="koboSpan" id="kobo.212.1"> module. </span><span class="koboSpan" id="kobo.212.2">But how can we import it if we don’t have a module in a </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">standalone component?</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">In a project without modules, the import happens in the component itself; for services, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">app.config.ts</span></strong><span class="koboSpan" id="kobo.216.1"> file, and we will add the import </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
import { ApplicationConfig } from '@angular/core';
import { provideHttpClient } from '@angular/common/http';
export const appConfig: ApplicationConfig = {
  providers: [provideHttpClient()],
};</span></pre> <p><span class="koboSpan" id="kobo.219.1">Note that</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.220.1"> we are importing</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.221.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">provideHttpClient</span></strong><span class="koboSpan" id="kobo.223.1"> provider and not the module. </span><span class="koboSpan" id="kobo.223.2">This happens because this provider was created by the Angular team to handle these standalone </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">application cases.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">In the main components of the application, we will code its behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  private formBuilder = inject(NonNullableFormBuilder);
  private exerciseService = inject(ExercisesService);
  exerciseList$ = this.exerciseService.getExercises();
  public entryForm = this.formBuilder.group({
    description: ['', Validators.required],
  });
  newExercise() {
    if (this.entryForm.valid) {
      const newExercise = { ...this.entryForm.value };
      this.exerciseService
        .addExercises(newExercise)
        .subscribe(
          (_) =&gt; (this.exerciseList$ = this.exerciseService.getExercises())
        );
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.228.1">Let’s first </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.229.1">highlight the</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.230.1"> component configuration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">@Component</span></strong><span class="koboSpan" id="kobo.232.1"> decorator metadata. </span><span class="koboSpan" id="kobo.232.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">standalone</span></strong><span class="koboSpan" id="kobo.234.1"> property means that this component can be used directly without being declared in any module. </span><span class="koboSpan" id="kobo.234.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">imports</span></strong><span class="koboSpan" id="kobo.236.1"> property, we declare its dependencies, which are </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">CommonModule</span></strong><span class="koboSpan" id="kobo.238.1">, the basis for any Angular component, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">ReactiveFormsModule</span></strong><span class="koboSpan" id="kobo.240.1">, as we will be developing a reactive form (for more details about the form, read </span><a href="B19562_06.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.241.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.242.1">, </span><em class="italic"><span class="koboSpan" id="kobo.243.1">Handling User Input: Forms</span></em><span class="koboSpan" id="kobo.244.1">). </span><span class="koboSpan" id="kobo.244.2">In the component, we are injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">NonNullableFormBuilder</span></strong><span class="koboSpan" id="kobo.246.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">ExercisesService</span></strong><span class="koboSpan" id="kobo.248.1"> and we take the initial list and assign it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">exerciseList$</span></strong><span class="koboSpan" id="kobo.250.1"> attribute. </span><span class="koboSpan" id="kobo.250.2">We create the form object with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">formBuilder</span></strong><span class="koboSpan" id="kobo.252.1"> service, and finally, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">newExercise</span></strong><span class="koboSpan" id="kobo.254.1"> method responsible for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.255.1">Submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1"> button.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">As we will have the list of exercises in the same form, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">subscribe</span></strong><span class="koboSpan" id="kobo.259.1"> method, we assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">exerciseList$</span></strong><span class="koboSpan" id="kobo.261.1"> attribute again to refresh </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">the list.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">To finish the component, let’s create its template </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
&lt;div class="bg-gray-100 flex justify-center items-center min-h-screen"&gt;
  &lt;div class="max-w-md w-full p-6 bg-white rounded-lg shadow-md"&gt;
    &lt;h1 class="text-2xl font-bold mb-4"&gt;Exercise List&lt;/h1&gt;
    &lt;div class="max-h-40 overflow-y-auto mb-4"&gt;
      &lt;ul&gt;
        &lt;li class="mb-2" *ngFor="let exercise of exerciseList$ | async"&gt;
          {{ exercise.description }}
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.266.1">In the first</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.267.1"> part, we have the</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.268.1"> list of exercises, and here we are using Angular’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">async</span></strong><span class="koboSpan" id="kobo.270.1"> pipe to subscribe and search the list (for more details, read </span><a href="B19562_09.xhtml#_idTextAnchor242"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.271.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.272.1">, </span><em class="italic"><span class="koboSpan" id="kobo.273.1">Exploring Reactivity </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.274.1">with RxJS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">In the same template file, we will add </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">the form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
&lt;h2 class="text-xl font-semibold mt-6 mb-2"&gt;Add Exercise&lt;/h2&gt;
  &lt;form [formGroup]="entryForm" (ngSubmit)="newExercise()" class="space-y-2"&gt;
    &lt;div class="mb-4"&gt;
      &lt;label for="description" class="mb-2 block font-bold text-gray-700"&gt;Description:&lt;/label&gt;
      &lt;input type="text" id="description" name="description" class="w-full appearance-none rounded border px-3 py-2 leading-tight text-gray-700 shadow" formControlName="description"/&gt;
      &lt;div *ngIf="entryForm.get('exercise')?.invalid &amp;&amp; entryForm.get('exercise')?.touched" class="mt-1 text-red-500"&gt;
        Exercise is required.
</span><span class="koboSpan" id="kobo.278.2">      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="flex items-center justify-center"&gt;
      &lt;button type="submit" [disabled]="entryForm.invalid" [class.opacity-50]="entryForm.invalid" class="rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700" &gt;
        Confirm
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/form&gt;</span></pre> <p><span class="koboSpan" id="kobo.279.1">We </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.280.1">created a reactive form</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.281.1"> with just the </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Description</span></strong><span class="koboSpan" id="kobo.283.1"> field and added </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">simple validation.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">By running our application with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">ng serve</span></strong><span class="koboSpan" id="kobo.287.1"> command, we will have the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">following interface:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.289.1"><img alt="Figure 11.2 – Exercise form" src="image/B19562_11_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.290.1">Figure 11.2 – Exercise form</span></p>
<p><span class="koboSpan" id="kobo.291.1">With our micro frontend project ready, we can prepare it to be consumed b</span><a id="_idTextAnchor303"/><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.292.1">y our </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">main application.</span></span></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.294.1">Preparing a page to be loaded by the base application</span></h1>
<p><span class="koboSpan" id="kobo.295.1">With</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.296.1"> our micro frontend project ready, we need to prepare it to be consumed by another application. </span><span class="koboSpan" id="kobo.296.2">There are several ways to share micro frontends, from the simplest (and obsolete), with the use of iframes, to more modern, but complex, solutions such as </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">module federation.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">In this </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.299.1">section, we will use an approach widely used in the market, which is the use of Web Components. </span><span class="koboSpan" id="kobo.299.2">Web Components is a specification that aims to standardize components created by different frameworks into a model that can be consumed between them. </span><span class="koboSpan" id="kobo.299.3">In other words, by creating an Angular component following this specification, an application created in React or Vue could consume this component. </span><span class="koboSpan" id="kobo.299.4">Although Web Components was not created with micro frontend projects in mind, we can see that its definition fits perfectly for what </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">we need.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Like almost everything in the Angular framework, to create this type of component, we don’t need to do it manually, as the Angular team created a tool for this: Angular elements. </span><span class="koboSpan" id="kobo.301.2">An Angular element component is a common component but </span><em class="italic"><span class="koboSpan" id="kobo.302.1">transpiled</span></em><span class="koboSpan" id="kobo.303.1"> to the Web Components standard, packaging not only our code but also the Angular rendering engine, making it </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">framework agnostic.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Let’s add it to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">gym_exercises</span></strong><span class="koboSpan" id="kobo.307.1"> project on the command line of our operating system with the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.309.1">
npm i @angular/elements</span></pre> <p><span class="koboSpan" id="kobo.310.1">With the preceding command, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">angular/elements</span></strong><span class="koboSpan" id="kobo.312.1"> dependency to our project, and to use it, we will make a change to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">angular.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.314.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.315.1">
{
  "type": "anyComponentStyle",
  "maximumWarning": "50kb",
  "maximumError": "50kb"
}</span></pre> <p><span class="koboSpan" id="kobo.316.1">The component generated by Angular elements will encapsulate the Tailwind CSS framework, so we need to increase the component size budget a little to avoid errors when building </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">The next change we must make is to the project’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">main.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.320.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.321.1">
import {
  bootstrapApplication,
  createApplication,
} from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';
import { createCustomElement } from '@angular/elements';
(async () =&gt; {
  const app = await createApplication(appConfig);
  const element = createCustomElement(AppComponent, {
    injector: app.injector,
  });
  customElements.define('exercise-form', element);
})();</span></pre> <p><span class="koboSpan" id="kobo.322.1">This file is responsible for configuring the initialization of an Angular project, and we normally do not change it as we want standard SPA build and execution behavior. </span><span class="koboSpan" id="kobo.322.2">However, here, we need to change it to inform Angular that the result of this project will be a web component generated by the Angular elements package. </span><span class="koboSpan" id="kobo.322.3">Here, we are configuring the project so that the application will generate a web component whose tag </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.323.1">name will </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">exercise-form</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">We now need to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">index.html</span></strong><span class="koboSpan" id="kobo.329.1"> file to understand this new tag so that we can render our micro frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">for testing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;GymExercises&lt;/title&gt;
    &lt;base href="/" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
    &lt;link rel="icon" type="image/x-icon" href="favicon.ico" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;exercise-form&gt;&lt;/exercise-form&gt;
  &lt;/body&gt;
&lt;/html&gt;</span></pre> <p><span class="koboSpan" id="kobo.332.1">Here, we</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.333.1"> change the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">&lt;app-root&gt;</span></strong><span class="koboSpan" id="kobo.335.1"> Angular component with the Web Components </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">&lt;exercise-form&gt; tag</span></strong><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">Our main application will be our micro frontend JavaScript, but the change to </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">index.html</span></strong><span class="koboSpan" id="kobo.339.1"> will allow you and your team to maintain the micro frontend without needing to load the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">main project.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">We now have a challenge in that, despite creating a web component, the project build is creating it in three files and with hashes, which is correct if our application is not a micro frontend, but in our case, we would like to have all the code in a single file and without the hash. </span><span class="koboSpan" id="kobo.341.2">We can do this manually, but the community has a package that automates this treatment: the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">ngx-build-plus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.343.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">Let’s add it to the command line with the help of the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">Angular CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.346.1">
ng add ngx-build-plus</span></pre> <p><span class="koboSpan" id="kobo.347.1">To </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.348.1">serve this micro frontend, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">http-server</span></strong><span class="koboSpan" id="kobo.350.1"> package, and add it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">npm</span></strong><span class="koboSpan" id="kobo.352.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">command line:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.354.1">
npm i http-server</span></pre> <p><span class="koboSpan" id="kobo.355.1">Finally, let’s create some </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">npm</span></strong><span class="koboSpan" id="kobo.357.1"> scripts to make running </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">mfe</span></strong><span class="koboSpan" id="kobo.359.1"> easier. </span><span class="koboSpan" id="kobo.359.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">package.json</span></strong><span class="koboSpan" id="kobo.361.1"> file, we will make the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">following change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.363.1">
"scripts": {
  "ng": "ng",
  "start": "ng serve",
  "build": "ng build --single-bundle  --bundle-styles  --keep-styles  --output-hashing=none",
  "serve-mfe": "http-server dist/gym_exercises",
}</span></pre> <p><span class="koboSpan" id="kobo.364.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">build</span></strong><span class="koboSpan" id="kobo.366.1"> script, we specify our intention to run it, resulting in a single generated file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">--single-bundle</span></strong><span class="koboSpan" id="kobo.368.1">). </span><span class="koboSpan" id="kobo.368.2">We also instruct it to retain and encapsulate the CSS (</span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">--bundle-styles --keep-styles</span></strong><span class="koboSpan" id="kobo.370.1">) while ensuring that the generated file’s name does not include any type of </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">hash (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">--output-hashing=none</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">serve-mfe</span></strong><span class="koboSpan" id="kobo.376.1"> script uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">http-server</span></strong><span class="koboSpan" id="kobo.378.1"> service to publish the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">dist</span></strong><span class="koboSpan" id="kobo.380.1"> folder that will contain the compiled </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">micro frontend.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1"> Let’s run our project with the following command and check the micro frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">we created:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.384.1">
npm run build
npm run serve-mfe</span></pre> <p><span class="koboSpan" id="kobo.385.1">By accessing </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">http://127.0.0.1:8080</span></strong><span class="koboSpan" id="kobo.387.1">, we can see that our micro frontend application</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.388.1"> is being </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">generated successfully.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">With our micro frontend ready to be consumed, in the next section, we will consum</span><a id="_idTextAnchor306"/><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.391.1">e it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">main application.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.393.1">Dynamically loading micro frontends</span></h1>
<p><span class="koboSpan" id="kobo.394.1">Let’s</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.395.1"> prepare our main application gym diary to consume the micro frontend that we prepared previously. </span><span class="koboSpan" id="kobo.395.2">To do this, let’s start by creating a new module in the application. </span><span class="koboSpan" id="kobo.395.3">On the command line, we will use the following Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">CLI commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.397.1">
ng g m exercise --routing
ng g c exercise/exercise</span></pre> <p><span class="koboSpan" id="kobo.398.1">With the preceding commands, we create the module with the generated route file and a component that will be responsible for </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">loading </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">mfe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">Let’s adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">exercise-routing.module.ts</span></strong><span class="koboSpan" id="kobo.404.1"> file to target </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">the component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { ExerciseComponent } from './exercise/exercise.component';
const routes: Routes = [
  {
    path: '',
    component: ExerciseComponent,
    title: 'Exercise Registry',
  },
];
@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class ExerciseRoutingModule {}</span></pre> <p><span class="koboSpan" id="kobo.407.1">In</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.408.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">routes</span></strong><span class="koboSpan" id="kobo.410.1"> array, we define a base route for the exercise registration component as it will be loaded via </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">lazy loading.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">Next, we will refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">home-routing.module.ts</span></strong><span class="koboSpan" id="kobo.414.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
. </span><span class="koboSpan" id="kobo.416.2">. </span><span class="koboSpan" id="kobo.416.3">.
</span><span class="koboSpan" id="kobo.416.4">const routes: Routes = [
  {
    path: '',
    component: HomeComponent,
    children: [
      {
        path: 'diary',
        loadChildren: () =&gt;
          import('../diary/diary.module').then((file) =&gt; file.DiaryModule),
      },
      {
        path: 'exercise',
        loadChildren: () =&gt;
          import('../exercise/exercise.module').then(
            (file) =&gt; file.ExerciseModule
          ),
      },
      {
        path: '',
        redirectTo: 'diary',
        pathMatch: 'full',
      },
    ],
  },
];
. </span><span class="koboSpan" id="kobo.416.5">. </span><span class="koboSpan" id="kobo.416.6">.</span></pre> <p><span class="koboSpan" id="kobo.417.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">HomePage</span></strong><span class="koboSpan" id="kobo.419.1"> module contains the menu, and in this section, we are adding the new module</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.420.1"> to be loaded in the correct area of </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">To finish adding this new module, let’s change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">home.component.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
. </span><span class="koboSpan" id="kobo.425.2">. </span><span class="koboSpan" id="kobo.425.3">.
</span><span class="koboSpan" id="kobo.425.4">  &lt;li&gt;
    &lt;a
      routerLink="./exercise"
      class="flex items-center space-x-2 text-white"
    &gt;
      &lt;span&gt;Exercise Registry&lt;/span&gt;
    &lt;/a&gt;
  &lt;/li&gt;
. </span><span class="koboSpan" id="kobo.425.5">. </span><span class="koboSpan" id="kobo.425.6">.</span></pre> <p><span class="koboSpan" id="kobo.426.1">With the new menu item added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">home</span></strong><span class="koboSpan" id="kobo.428.1"> template, we now have the task of including the micro frontend generated in the other project in </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">our interface.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">For this, we have a community package called </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">@angular-extensions</span></strong><span class="koboSpan" id="kobo.432.1"> that allows us to load our micro frontend simply using a directive, as we will see later. </span><span class="koboSpan" id="kobo.432.2">But first, let’s install this dependency in our project using the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.434.1">
npm i @angular-extensions/elements</span></pre> <p><span class="koboSpan" id="kobo.435.1">Once installed, we can change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ExerciseModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
import { CUSTOM_ELEMENTS_SCHEMA, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ExerciseRoutingModule } from './exercise-routing.module';
import { ExerciseComponent } from './exercise/exercise.component';
import { LazyElementsModule } from '@angular-extensions/elements';
@NgModule({
  declarations: [ExerciseComponent],
  imports: [CommonModule, LazyElementsModule, ExerciseRoutingModule],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class ExerciseModule {}</span></pre> <p><span class="koboSpan" id="kobo.439.1">In this file, we</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.440.1"> are first adding the library module called </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">LazyElementsModule</span></strong><span class="koboSpan" id="kobo.442.1"> to have access to the directive that we will use in the component. </span><span class="koboSpan" id="kobo.442.2">Furthermore, we have a new property in the metadata called </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">schemas</span></strong><span class="koboSpan" id="kobo.444.1">. </span><span class="koboSpan" id="kobo.444.2">In it, we are informing Angular with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">CUSTOM_ELEMENTS_SCHEMA</span></strong><span class="koboSpan" id="kobo.446.1"> token that this module will receive elements from outside the project. </span><span class="koboSpan" id="kobo.446.2">By default, Angular checks whether the tag used in the template exists in the project or in the HTML standard, such as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1"> tag.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">As we are going to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">exercise-form</span></strong><span class="koboSpan" id="kobo.451.1"> tag defined by our micro frontend here, this attribute will prevent Angular from carrying out this check at the project </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">compile time.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">exercise.component.ts</span></strong><span class="koboSpan" id="kobo.455.1"> file, we will add a </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">new attribute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.457.1">
import { Component } from '@angular/core';
@Component({
  selector: 'app-exercise',
  templateUrl: './exercise.component.html',
  styleUrls: ['./exercise.component.css'],
})
export class ExerciseComponent {
  elementUrl = 'http://localhost:8080/main.js';
}</span></pre> <p><span class="koboSpan" id="kobo.458.1">Here, we are defining the address where the micro frontend’s main files will </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">be served.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">Finally, let’s change the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">component template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
&lt;exercise-form *axLazyElement="elementUrl"&gt; &lt;/exercise-form &gt;</span></pre> <p><span class="koboSpan" id="kobo.463.1">Here, we are declaring</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.464.1"> the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">exercise-form</span></strong><span class="koboSpan" id="kobo.466.1"> element, and to load it, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">axLazyElement</span></strong><span class="koboSpan" id="kobo.468.1"> directive assigning the micro </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">frontend address.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">To run our project, make sure the micro frontend is being served with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">npm run serve-mfe</span></strong><span class="koboSpan" id="kobo.472.1"> command. </span><span class="koboSpan" id="kobo.472.2">With everything configured, we can see the result of </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">our work:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.474.1"><img alt="" role="presentation" src="image/B19562_11_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.475.1">Figure 11.3 – Exercise form dynamically</span><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.476.1"> loaded into the main application</span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.477.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.478.1">In this chapter, we explored the architecture of micro frontends and how to apply one to an </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">Angular project.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">We learned about the concept of the architecture, its advantages, and its trade-offs. </span><span class="koboSpan" id="kobo.480.2">We explored how the main reason for opting for this architecture is its flexibility in relation to the organizational structure of each team, as several teams can work on different parts of the frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">project independently.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">We also learned how we can ideally divide our application into </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">micro frontends.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">With all these concepts, we applied our project by creating a small application using Angular’s standalone components feature and preparing it to be loaded by another project using the Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">elements library.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">Finally, we performed dynamic loading in our main application with the help of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">angular-extensions/elements</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.489.1"> library.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">In the next chapter, we will explore the best practices for deploying an </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">Angular application.</span></span></p>
</div>
</body></html>