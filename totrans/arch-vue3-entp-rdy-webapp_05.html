<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-81"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-82"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.2.1">An Introduction to GraphQL, Queries, Mutations, and RESTful APIs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we explored different libraries and methods to develop large-scale enterprise applications using Vue 3. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will first understand what GraphQL is and how it is different from REST. </span><span class="koboSpan" id="kobo.3.3">Next, we will explore GraphQL, GraphQL Apollo Server 2, queries, and mutations, and how to integrate these technologies into your Vue.js 3 application. </span><span class="koboSpan" id="kobo.3.4">In addition, you will learn how to utilize GraphQL to deliver scalable and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">high-performing applications.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will cover the following key topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">An introduction </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">to GraphQL</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Understanding queries </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and mutations</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Integrating GraphQL Apollo Client with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Vue 3</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">Also, in this chapter, you will learn how to integrate GraphQL into Vue 3 and structure it properly following the law of predictability by implementing a login and register authentication system using the GraphQL Apollo client and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Vue 3.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">To get started with this chapter, we recommend you read through </span><a href="B17237_04.xhtml#_idTextAnchor112"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.18.1">,</span><em class="italic"><span class="koboSpan" id="kobo.19.1"> Architecture for Large-Scale Web Applications</span></em><span class="koboSpan" id="kobo.20.1">, where we explored building large-scale enterprise applications with different industry-standard structuring, architecture, </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">and standards.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">All the code files for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at: </span></span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.26.1">An introduction to GraphQL</span></h1>
<p><span class="koboSpan" id="kobo.27.1">GraphQL is the new buzzword in the API development industry. </span><span class="koboSpan" id="kobo.27.2">While REST remains the most popular way to </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.28.1">expose data from a server, it comes with many limitations that GraphQL tends </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">to solve.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">GraphQL is a query language created and maintained by Facebook. </span><span class="koboSpan" id="kobo.30.2">The purpose of creating GraphQL is to build client applications based on intuitive and flexible syntax for describing their data requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">and interactions.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">One of the benefits of GraphQL is that we have a single endpoint to access all data from the server instead </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.33.1">of having multiple endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">in REST.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">In this section, we will explore everything you need to know about GraphQL, the different unique features of GraphQL, and why you should consider GraphQL instead of the RESTful API design pattern. </span><span class="koboSpan" id="kobo.35.2">Lastly, we will work you through creating and setting up your first GraphQL server </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">with Express</span><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.38.1">What is GraphQL?</span></h2>
<p><span class="koboSpan" id="kobo.39.1">As per the </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.40.1">official </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">documentation (</span></span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://graphql.org/</span></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">),</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.44.1">GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. </span><span class="koboSpan" id="kobo.44.2">GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</span></p>
<p><span class="koboSpan" id="kobo.45.1">GraphQL is a server-side runtime for </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.46.1">executing queries using the type system you define for your data. </span><span class="koboSpan" id="kobo.46.2">Also, GraphQL is not tied to any specific database or storage engine but instead backed by your existing code </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">and data.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.48.1"><img alt="Figure 5.1 – A diagram explaining GraphQL (Source: https://www.wallarm.com/what/what-is-graphql-definition-with-example)" src="image/Figure_5.01_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.49.1">Figure 5.1 – A diagram explaining GraphQL (Source: https://www.wallarm.com/what/what-is-graphql-definition-with-example)</span></p>
<p><span class="koboSpan" id="kobo.50.1">The GraphQL type system defines various data types that can be used in a GraphQL application. </span><span class="koboSpan" id="kobo.50.2">This type system helps to define the schemas that will be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">GraphQL application.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">To create a GraphQL service, you </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.53.1">need to start by defining schema types and creating fields on those types, then providing functions to be executed on </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">each field.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">For example, we can define a new schema type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">Photo</span></strong><span class="koboSpan" id="kobo.57.1"> in the following code snippet to demonstrate how types work </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">in GraphQL:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.59.1">
type Photo {
 id: ID!
 </span><span class="koboSpan" id="kobo.59.2">name: String!
</span><span class="koboSpan" id="kobo.59.3">url: String!
</span><span class="koboSpan" id="kobo.59.4">description: String
}</span></pre>
<p><span class="koboSpan" id="kobo.60.1">Now we have an idea </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.61.1">of GraphQL and have seen how to define a GraphQL schema type. </span><span class="koboSpan" id="kobo.61.2">Next, let’s explore the features of GraphQL before we dive deeper into creating GraphQL queries </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">and resolv</span><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.63.1">ers.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.64.1">Features of GraphQL</span></h2>
<p><span class="koboSpan" id="kobo.65.1">GraphQL comes with </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.66.1">excellent features. </span><span class="koboSpan" id="kobo.66.2">We are going to explore a few of the features of GraphQL in the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">following subsect</span><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.68.1">ions.</span></span></p>
<h3><span class="koboSpan" id="kobo.69.1">Easy to get started</span></h3>
<p><span class="koboSpan" id="kobo.70.1">The learning curve of GraphQL is easy, especially for developers who are familiar with building APIs with RESTful </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">design patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Users can get started with GraphQL with small queries for fetching data right away and learn about the advanced features a </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">bit l</span><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.74.1">ater.</span></span></p>
<h3><span class="koboSpan" id="kobo.75.1">Built for interactive apps</span></h3>
<p><span class="koboSpan" id="kobo.76.1">GraphQL is built for real-time and interactive applications because changes between the client and the server happen almost immediately, giving a </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">swift resp</span><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.78.1">onse.</span></span></p>
<h3><span class="koboSpan" id="kobo.79.1">Small and flexible</span></h3>
<p><span class="koboSpan" id="kobo.80.1">GraphQL allows users to request and receive the exact data that was requested. </span><span class="koboSpan" id="kobo.80.2">This feature solves the problem of over- and under-fetching with </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">RESTful </span><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.82.1">APIs.</span></span></p>
<h3><span class="koboSpan" id="kobo.83.1">Universally compatible</span></h3>
<p><span class="koboSpan" id="kobo.84.1">GraphQL Apollo is built to be compatible with any build setup, any GraphQL server, and any </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">GraphQL sc</span><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.86.1">hema.</span></span></p>
<h3><span class="koboSpan" id="kobo.87.1">Incrementally adoptable</span></h3>
<p><span class="koboSpan" id="kobo.88.1">GraphQL is built to make </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.89.1">integrating into a new or existing project effortless without breaking any changes. </span><span class="koboSpan" id="kobo.89.2">It is </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">easily adap</span><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.91.1">table.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.92.1">Why use GraphQL instead of REST?</span></h2>
<p><span class="koboSpan" id="kobo.93.1">In this section, we will identify some properties of GraphQL and discuss why you should use GraphQL for your </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.94.1">subsequent API development instead of RESTful APIs. </span><span class="koboSpan" id="kobo.94.2">We will discuss a few of these properties. </span><span class="koboSpan" id="kobo.94.3">Additionally, we will get into a detailed comparison of these technologies with the GraphQL versus RESTful API guide in </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">The following subsections mention the top five reasons why you should use GraphQL instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">RESTf</span><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.98.1">ul API.</span></span></p>
<h3><span class="koboSpan" id="kobo.99.1">Strongly-typed schema</span></h3>
<p><span class="koboSpan" id="kobo.100.1">In GraphQL, </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">Schema Definition Language</span></strong><span class="koboSpan" id="kobo.102.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.103.1">SDL</span></strong><span class="koboSpan" id="kobo.104.1">) is used to define the contract between the client and the </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.105.1">server and to define how the client </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.106.1">accesses the data in the server. </span><span class="koboSpan" id="kobo.106.2">GraphQL uses a strong type system to define the capabilities of the API. </span><span class="koboSpan" id="kobo.106.3">All the APIs exposed to the client are written down in a schema called </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">the SDL.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Once these schemas are defined, both the frontend and the backend can communicate separately without any further changes or assistance since the frontend knows that the data in the schema is always going to be in sync or consistent across </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">This solves the data inconsistency problem in REST. </span><span class="koboSpan" id="kobo.110.2">The frontend expects a specific dataset but retrieves a different one due to changes since no consistent schema </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">is</span><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.112.1"> defined.</span></span></p>
<h3><span class="koboSpan" id="kobo.113.1">No over-fetching or under-fetching</span></h3>
<p><span class="koboSpan" id="kobo.114.1">The issue of over- or under-fetching is a known problem with RESTful APIs where clients download data by hitting endpoints that return fixed data structures or retrieve either excessive amounts of data or less than what </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">they expected.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">Over-fetching is the problem of fetching more data than what is required in the app. </span><span class="koboSpan" id="kobo.116.2">It can also mean fetching </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.117.1">more data than what is required to fulfill the request. </span><span class="koboSpan" id="kobo.117.2">With a RESTful API, you have to fetch all the user’s details or create a new endpoint that returns only the names of all the users of your application just to display only the name of the user on your frontend application. </span><span class="koboSpan" id="kobo.117.3">While in GraphQL, you can use just a single query to return only the name of all the users or any other details by creating a separate query </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">or endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Under-fetching is rare, but it happens when the specific endpoint does not provide all the required information. </span><span class="koboSpan" id="kobo.119.2">The client </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.120.1">must make additional requests to access the other information </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">GraphQL solves this </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.123.1">problem by providing a medium for the client to specify the information needed, and it returns exactly the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">required i</span><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.125.1">nformation.</span></span></p>
<h3><span class="koboSpan" id="kobo.126.1">Saving time and bandwidth</span></h3>
<p><span class="koboSpan" id="kobo.127.1">The problem of over-fetching can result in higher bandwidth consumption for clients, which may, in time, cause lagging in your application. </span><span class="koboSpan" id="kobo.127.2">Using RESTful API design patterns, it is more time-consuming to sort out the information needed from an </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">enormous payload.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">GraphQL allows you only to select what you need, thereby reducing the amount of payload transferred over </span><a id="_idTextAnchor169"/><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the network.</span></span></p>
<h3><span class="koboSpan" id="kobo.131.1">Multiple endpoints</span></h3>
<p><span class="koboSpan" id="kobo.132.1">One of the significant problems of RESTful APIs is having too many endpoints to access information. </span><span class="koboSpan" id="kobo.132.2">For instance, if a client wants to access a particular user by their ID, you will be presented with </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">/users/1</span></strong><span class="koboSpan" id="kobo.134.1">. </span><span class="koboSpan" id="kobo.134.2">Also, if you’re going to access that user’s photos, you will have to send a request to another </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">endpoint, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">/users/1/photos</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">In GraphQL, you have a single endpoint, and you don’t need to send multiple requests to retrieve different information about </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">With GraphQL, you can access all the user’s information in a single request, as </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
{
    me {
        name,
        photos {
            title,
url
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.143.1">The preceding script will only access </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">name</span></strong><span class="koboSpan" id="kobo.145.1"> of the user and </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">title</span></strong><span class="koboSpan" id="kobo.147.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">url</span></strong><span class="koboSpan" id="kobo.149.1"> of all the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">us</span><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.151.1">er’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">photos</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.154.1">Versioning is not required</span></h3>
<p><span class="koboSpan" id="kobo.155.1">Versioning is a feature of RESTful APIs where different versions are assigned to an API when changes </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.156.1">and updates are made to it. </span><span class="koboSpan" id="kobo.156.2">This is done to avoid breaking changes in production that might cause issues for </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">If we want users to use our new features in the latest version, we have to force them to update the application, which is not a good </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">In GraphQL, there is no need to worry about versioning and forcing users to update their application to use the </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.161.1">new changes since it happens automatically, and clients only implement the features avai</span><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.162.1">lable in </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">the SDL.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Here, we have discussed the different features and benefits of using GraphQL and why you should consider using GraphQL instead of RESTful APIs. </span><span class="koboSpan" id="kobo.164.2">In the next section, we will further discuss the difference between GraphQL and </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">RESTful APIs.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.166.1">The difference between GraphQL and RESTful APIs</span></h2>
<p><span class="koboSpan" id="kobo.167.1">The core difference </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.168.1">between GraphQL and REST is that GraphQL is a </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.169.1">specification and a query language, while REST APIs are an architectural concept for </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">network-based applications.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Both concepts play an important role in creating and maintaining scalable microservices and large-scale </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">enterprise applications.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Therefore, choosing a particular technology to go with will depend on your level of expatriation in each technology, which one your team is comfortable with, and which one makes your product development easier </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">and faster.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">The following points show you the other differences you might w</span><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.176.1">ant </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">to consider:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.178.1">GraphQL is a query language used to solve problems by integrating APIs, while REST API is an architectural style that describes the conventional standard for </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">designing APIs</span></span></li>
<li><span class="koboSpan" id="kobo.180.1">Additionally, with GraphQL, you can use a single endpoint to access all the data in your server without the need for multiple endpoints, while REST API allows multiple endpoints and a set of URLs that each exposes a single resource, which can be confusing </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">to understand</span></span></li>
<li><span class="koboSpan" id="kobo.182.1">GraphQL uses a client-driven architecture and lacks an in-built caching mechanism, while REST API uses a server-driven architecture and uses </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">caching automatically</span></span></li>
<li><span class="koboSpan" id="kobo.184.1">No API versioning is required in GraphQL, and its response is only in JSON format, while REST APIs support multiple API versioning and allow response output in XML, JSON, </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">or YAML</span></span></li>
<li><span class="koboSpan" id="kobo.186.1">GraphQL offers type safety and auto-generated documentation and it also allows schema stitching and remote data fetching, while REST API doesn’t offer type safety or auto-generated documentation, and simplifying work with multiple endpoints requires expensive </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">custom middleware</span></span></li>
<li><span class="koboSpan" id="kobo.188.1">GraphQL is also an application-layer server-side technology used for executing queries with existing data, while REST is a software architectural style used to define a set of constraints for creating </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">web services</span></span></li>
<li><span class="koboSpan" id="kobo.190.1">GraphQL can be organized in terms of a schema, while REST is not arranged or organized in schemas but is arranged in terms </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">of endpoints</span></span></li>
<li><span class="koboSpan" id="kobo.192.1">The development speed in GraphQL is faster when compared with </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">REST APIs</span></span></li>
<li><span class="koboSpan" id="kobo.194.1">The message </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.195.1">format for GraphQL mutations should </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.196.1">be a string, while the message format for REST APIs can </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">be anything</span></span></li>
<li><span class="koboSpan" id="kobo.198.1">GraphQL uses metadata for query validation, while REST does not have cacheable </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">machine</span><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.200.1">-readable metadata</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.201.1">We have explored the difference between GraphQL and REST API to give you an insight into which is better for your enterprise application. </span><span class="koboSpan" id="kobo.201.2">We will allow you to make a choice, but we will explore GraphQL in more depth in the following sections. </span><span class="koboSpan" id="kobo.201.3">In the next section, we will discuss queries and mutations, expanding more on how to create your first q</span><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.202.1">uery </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">and mutation.</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.204.1">Understanding queries and mutations in GraphQL</span></h1>
<p><span class="koboSpan" id="kobo.205.1">Queries and mutations are vital in GraphQL because they are the only way to access or send data to the GraphQL server f</span><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.206.1">rom </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">your frontend.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.208.1">Using queries</span></h2>
<p><span class="koboSpan" id="kobo.209.1">GraphQL queries define </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.210.1">all the queries that a client can run on the GraphQL API. </span><span class="koboSpan" id="kobo.210.2">If you’re familiar with REST APIs, it is </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.211.1">synonymous with the popular </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">GET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.213.1"> requests.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">You can define GraphQL queries in many ways, but defining a root query to wrap all your queries </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">is recommended.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">The following code snippet shows you how to define a root query </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">RootQuery</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.220.1">
type RootQuery {
  user(id: ID): User    # Corresponds to GET /api/users/:id
  users: [User]         # Corresponds to GET /api/users
  photo(id: ID!): Photo #Corresponds to GET/api/photos/:id
  photos: [Photo]        # Corresponds to GET /api/photos
}</span></pre>
<p><span class="koboSpan" id="kobo.221.1">You can also define individual queries for </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">User</span></strong><span class="koboSpan" id="kobo.223.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">Photo</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.225.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
type User {
id: ID!
</span><span class="koboSpan" id="kobo.226.2">name:String!
</span><span class="koboSpan" id="kobo.226.3">email: String!
</span><span class="koboSpan" id="kobo.226.4">}
type Photo {
id: ID!
</span><span class="koboSpan" id="kobo.226.5">title:String!
</span><span class="koboSpan" id="kobo.226.6">description: String
url: String!
</span><span class="koboSpan" id="kobo.226.7">user: User
}</span></pre>
<p><span class="koboSpan" id="kobo.227.1">With the preceding queries, we </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.228.1">have successfully defined endpoints to retrieve users </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.229.1">and photos corresponding to how it can be done with REST API using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">GET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Next, we will explore how to create or update data on our GraphQ</span><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.233.1">L API </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">using mutations.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.235.1">Using mutations</span></h2>
<p><span class="koboSpan" id="kobo.236.1">Mutations in GraphQL are </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.237.1">used to create, update, and delete data from </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.238.1">our GraphQL API, and are synonymous with REST API’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">POST</span></strong><span class="koboSpan" id="kobo.240.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">PUT</span></strong><span class="koboSpan" id="kobo.242.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">DELETE</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.244.1">methods, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Creating mutations in GraphQL is simple; take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
type RootMutation {
  createUser(input: UserInput!): User
  # Corresponds to POST /api/users
  updateUser(id: ID!, input: UserInput!): User
  # Corresponds to PATCH /api/users
  removeUser(id: ID!): User
  # Corresponds to DELETE /api/users
  createPhoto(input: PhotoInput!): Photo
  updatePhoto(id: ID!, input: PhotoInput!): Photo
  removePhoto(id: ID!): Photo
}</span></pre>
<p><span class="koboSpan" id="kobo.248.1">The preceding snippet shows </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.249.1">how to create mutations. </span><span class="koboSpan" id="kobo.249.2">Furthermore, we </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.250.1">have created </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">createUser</span></strong><span class="koboSpan" id="kobo.252.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">updateUser</span></strong><span class="koboSpan" id="kobo.254.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">removeUser</span></strong><span class="koboSpan" id="kobo.256.1"> to create, update, and delete users from the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">GraphQL API.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Most importantly, for GraphQL to connect to our database and carry out the operations in both queries and mutations, we need to define a resolver, which we will cov</span><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.259.1">er in the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">next subsection.</span></span></p>
<h3><span class="koboSpan" id="kobo.261.1">Resolvers</span></h3>
<p><span class="koboSpan" id="kobo.262.1">A GraphQL resolver connects our queries and mutations to the right methods for execution. </span><span class="koboSpan" id="kobo.262.2">It informs GraphQL what </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.263.1">to do when each of these queries/mutations is requested. </span><span class="koboSpan" id="kobo.263.2">It is a basic function that does the hard work of hitting the database layer to do the CRUD operations, hitting an internal REST endpoint, or calling a microservice to fulfill the </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">client’s request.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Let’s map the queries/mutations we have created in the preceding sections to a resolver that will be called when any of the queries/mutations </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">are requested:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
import sequelize from '../models';
export default function resolvers () {
  const models = sequelize.models;
  return {
// Resolvers for Queries
    RootQuery: {
      user (root, { id }, context) {
        return models.User.findById(id, context);
      },
      users (root, args, context) {
        return models.User.findAll({}, context);
      }
    },
// Resolvers for Mutations
RootMutation: {
  createUser (root, { input }, context) {
    return models.User.create(input, context);
  },
  updateUser (root, { id, input }, context) {
    return models.User.update(input, { ...context,
                                      where: { id } });
  },
  removeUser (root, { id }, context) {
    return models.User.destroy(input, { ...context,
                                       where: { id } });
  },
  // ... </span><span class="koboSpan" id="kobo.267.2">Resolvers for Photos
}
};
}</span></pre>
<p><span class="koboSpan" id="kobo.268.1">To foster </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.269.1">understanding, we imported our model from </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">sequelize</span></strong><span class="koboSpan" id="kobo.271.1">, which is a database </span><strong class="bold"><span class="koboSpan" id="kobo.272.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.273.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.274.1">ORM</span></strong><span class="koboSpan" id="kobo.275.1">) to manipulate database tables with </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">defined methods.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Next, we created and exported a </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">resolver</span></strong><span class="koboSpan" id="kobo.279.1"> function, which returns an object containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">RootQuery</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.281.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">RootMutation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Next, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">RootQuery</span></strong><span class="koboSpan" id="kobo.286.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">RootMutation</span></strong><span class="koboSpan" id="kobo.288.1"> objects, we resolve each of the methods with the appropriate business logic to </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">be executed.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">For example, when a client requests all users, the GraphQL frontend client will call the user’s queries </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.291.1">defined in the </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">Queries</span></strong><span class="koboSpan" id="kobo.293.1"> section, and the GraphQL engine will call the user’s resolver to retrieve all the users using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">sequelize</span></strong><span class="koboSpan" id="kobo.295.1"> ORM. </span><span class="koboSpan" id="kobo.295.2">The same logic applies to all </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">the mutations.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">In this section, we explained of how GraphQL works and how you can create your own GraphQL API to understand the best way to structure your GraphQL client in the frontend for </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">enterprise projects.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">In the next section, we are going to explore the best way to structure your enterprise Vue.js application with GraphQL for scalability and faster team adoption. </span><span class="koboSpan" id="kobo.299.2">Remember the law of predictability for your teams tha</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.300.1">t we discussed in </span><a href="B17237_03.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.301.1">Chapter 3</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.302.1">, Scaling Performance in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.303.1">Vue.js 3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.305.1">Integrating GraphQL Apollo Client with Vue 3</span></h1>
<p><span class="koboSpan" id="kobo.306.1">It is tempting to </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.307.1">ask what the best way to integrate GraphQL client </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.308.1">into Vue 3 is and how to structure it in an enterprise project to foster faster adoption by team members, including new </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">team members.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">In my career as a full-stack software engineer, I recently joined a fintech company using Vue 3 and GraphQL to disrupt the fintech industry in Germany, and I was so impressed at the arrangement of such a large code base and how easy it was for me to jump right into solving my </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">first task.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">There are many ways to structure your Vue 3 project with GraphQL, but I want to outline the best way I have seen that works for small- or large-scale enterprise projects, including the fintech one I </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">worked on.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">GraphQL Apollo Client is a JavaScript library used to connect to the GraphQL server to interchange data. </span><span class="koboSpan" id="kobo.314.2">With the </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.315.1">library, you can connect to the server, send requests, and receive responses from </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">First, we will start by listing and installing the necessary packages for GraphQL </span><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.318.1">and the GraphQL client in </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">Vue 3.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.320.1">Installation</span></h2>
<p><span class="koboSpan" id="kobo.321.1">Follow these </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.322.1">steps to install all the </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">necessary packages:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.324.1">Type in the following commands to install </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">graphql</span></strong><span class="koboSpan" id="kobo.326.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">graphql-tag</span></strong><span class="koboSpan" id="kobo.328.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">apollo-composable</span></strong><span class="koboSpan" id="kobo.330.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">apollo client</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">These are the recommended libraries from the official documentation used to communicate with the GraphQL server using </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">Vue 3:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.334.1">npm install --save graphql graphql-tag @apollo/client @vue/apollo-composable</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.335.1">After installation, we will create a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">apollo.config.js</span></strong><span class="koboSpan" id="kobo.337.1"> inside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">plugins</span></strong><span class="koboSpan" id="kobo.339.1"> folder from the folder structure we created in </span><a href="B17237_03.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.340.1">Chapter 3</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.341.1">, Scaling Performance in Vue.js 3</span></em><span class="koboSpan" id="kobo.342.1"> and add the following scripts to configure the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">graphql</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1"> client:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.345.1">
```js
import { ApolloClient, createHttpLink, InMemoryCache } from '@apollo/client/core'
// HTTP connection to the API
const httpLink = createHttpLink({
  // You should use an absolute URL here
  uri: 'http://localhost:3020/graphql',
})
// Cache implementation
const cache = new InMemoryCache()
// Create the apollo client
const apolloClient = new ApolloClient({
  link: httpLink,
  cache,
})
export default apolloClient
```</span></pre></li>
<li><span class="koboSpan" id="kobo.346.1">Lastly, inside </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.347.1">your Vue 3 </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">main.js</span></strong><span class="koboSpan" id="kobo.349.1"> file, add the following script to the </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">existing one:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.351.1">
```js
import { createApp, provide, h } from 'vue'
import apolloClient from "./plugins/apollo.config";
import { DefaultApolloClient } from '@vue/apollo-composable'
…
const app = createApp({
  setup () {
    provide(DefaultApolloClient, apolloClient)
  },
  render: () =&gt; h(App),
})
…
```</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.352.1">In the preceding steps, we demonstrated how to install the GraphQL client and completely set it up with </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.353.1">the other libraries in our Vue 3 enterprise application. </span><span class="koboSpan" id="kobo.353.2">In the next section, we will discuss the best practices for structuring </span><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.354.1">our Vue 3 application </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">with GraphQL.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.356.1">Structuring GraphQL</span></h2>
<p><span class="koboSpan" id="kobo.357.1">After successfully installing and configuring Apollo Client with Vue 3, let’s structure our queries and </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.358.1">mutations around the law of predictability to enable old and new team members to easily adapt to </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Create a new folder inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">src</span></strong><span class="koboSpan" id="kobo.362.1"> folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">graphql</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">This new folder will contain all our queries and mutations grouped in to different directories according to the features of </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Let’s take an example from the schema we developed in the previous section. </span><span class="koboSpan" id="kobo.366.2">From the schema, it is clear that our project has </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">User</span></strong><span class="koboSpan" id="kobo.368.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Photo</span></strong><span class="koboSpan" id="kobo.370.1"> features, so we will create different folders inside the general </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">graphql</span></strong><span class="koboSpan" id="kobo.372.1"> folder for these </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">specific features.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">Create new folders using the following command line or manually from your </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">code editor:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.376.1">
mkdir src/graphql
mkdir graphql/users graphql/photos</span></pre>
<p><span class="koboSpan" id="kobo.377.1">You should have a new folder structure, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.379.1"><img alt="Figure 5.2 – The folder structure after installing and setting up GraphQL" src="image/Figure_5.02_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.380.1">Figure 5.2 – The folder structure after installing and setting up GraphQL</span></p>
<p><span class="koboSpan" id="kobo.381.1">After installing and setting up GraphQL, your folder structure should look like the preceding screenshot, containing each feature with its corresponding queries and </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">mutations file.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Structuring your GraphQL API this way makes it easy for your team to automatically understand </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.384.1">where to find anything related to GraphQL queries or mutations and in which feature they are looking </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">for them.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">Now that we have our folder structure figured out for predictability, in the next section, we will demonstrate with a practical exercise using the structure we learned about in the previous sections to authenticate a user into our application using GraphQL Apollo Client and </span><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.387.1">JWT installed on our </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">GraphQL server.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.389.1">JWT authentication for sign in/sign up</span></h2>
<p><span class="koboSpan" id="kobo.390.1">With the </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.391.1">structure we have on the ground, it becomes easy to add new features and write our queries/mutations without scattering them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">Let’s demonstrate how to implement the login and register authentication process with GraphQL and Vue 3 by following </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">these steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.395.1">Firstly, create a new folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">auth</span></strong><span class="koboSpan" id="kobo.397.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">graphql</span></strong><span class="koboSpan" id="kobo.399.1"> folder and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">mutations.js</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.401.1">inside it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.402.1">
mkdir graphql/auth
touch graphql/auth/mutations.js</span></pre></li>
<li><span class="koboSpan" id="kobo.403.1">Inside the newly created mutation file, add the following script for registration and </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">login endpoints:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.405.1">
import { gql } from "graphql-tag";
export const LOGIN_USER = gql`
 mutation loginUser($input: LoginUserInput!) {
   loginUser(data: $input) {
     id
     name
     email
     token
   }
 }
`;
export const REGISTER = gql`
 mutation register($input: RegisterUserInput!) {
   register(data: $input) {
     id
     name
     email
   }
 }
`;</span></pre></li>
<li><span class="koboSpan" id="kobo.406.1">Next, export </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.407.1">the mutation inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">graphql/index.js</span></strong><span class="koboSpan" id="kobo.409.1"> file we created earlier to make it available throughout our </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">Vue application:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.411.1">
export * from "./auth/mutations";</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.412.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">export</span></strong><span class="koboSpan" id="kobo.414.1"> script makes importing our GraphQL queries and mutations a </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">lot easier.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Next, we will look at how to call the authentication mutation inside the Vue 3 component and retrieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">user’s information.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">vue-composable</span></strong><span class="koboSpan" id="kobo.420.1"> library we installed earlier, we can use different GraphQL </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.421.1">hooks, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">useMutation</span></strong><span class="koboSpan" id="kobo.423.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">useQuery</span></strong><span class="koboSpan" id="kobo.425.1">, to manipulate the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">GraphQL API.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.427.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">login</span></strong><span class="koboSpan" id="kobo.429.1"> component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">organisms</span></strong><span class="koboSpan" id="kobo.431.1"> folder and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.433.1">
&lt;template&gt;
 &lt;form @submit.prevent="login"&gt;
   &lt;TextField
     v-model="email"
     required
     type="email"
     class="mb-6"
     name="email"
     label="Email Address"
     placeholder="Enter your email address"
  /&gt;
   &lt;TextField
     v-model="password"
     required
     minlength="6"
     class="mb-6"
     type="password"
     maxlength="50"
     placeholder="Enter your full password"
     label="Password"
   &gt;&lt;/TextField&gt;
   &lt;div class="flex justify-between mb-6"&gt;
     &lt;CheckField id="remember" v-model="remember"&gt;
      Remember me&lt;/CheckField&gt;
   &lt;/div&gt;
   &lt;div class="flex justify-center my-9 w-full"&gt;
     &lt;Button&gt;Sign In&lt;/Button&gt;
   &lt;/div&gt;
 &lt;/form&gt;
&lt;/template&gt;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.434.1">The first code </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.435.1">snippet shows the template and the view part of the component; it has a form component with four child components, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">TextField</span></strong><span class="koboSpan" id="kobo.437.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">CheckField</span></strong><span class="koboSpan" id="kobo.439.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Button</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
&lt;script&gt;
import { LOGIN_USER } from "../../graphql";
export default {
 setup(props) {
   const email = ref("");
   const password = ref("");
   const remember = ref(false);
   const { mutate: loginUser } =
     useMutation(LOGIN_USER, () =&gt; ({
     variables: {
       email: email,
       password: password,
       remember,
     },
   }));
   const login = () =&gt; {
     const user = loginUser();
     if (!user) return
    // Save State and Redirect to Dashboard
   };
   return {
     login,
     email,
     password,
     remember,
   };
 },
};
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.444.1">The script </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.445.1">section of the component performs the business logic; it has many properties and a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">Login</span></strong><span class="koboSpan" id="kobo.447.1">, which performs the authentication process for </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">The preceding snippet shows how to implement the login functionality for our project. </span><span class="koboSpan" id="kobo.449.2">You can implement the registration component or take a look at the repository (</span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5"><span class="koboSpan" id="kobo.450.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5</span></a><span class="koboSpan" id="kobo.451.1">) for the complete code base for </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">this chapter.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.453.1"><img alt="Figure 5.3 – A screenshot sh﻿owing the implementation of a login form" src="image/Figure_5.03_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.454.1">Figure 5.3 – A screenshot sh</span><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.455.1">owing the implementation of a login form</span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.456.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.457.1">This chapter delved deeper into GraphQL, GraphQL Apollo Server 2, queries, mutations, and how to integrate these technologies into your Vue.js 3 application. </span><span class="koboSpan" id="kobo.457.2">In addition, we learned how to utilize GraphQL to deliver scalable and </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">high-performing applications.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">We also covered in detail how to integrate GraphQL into Vue 3 and properly structure it following the law </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">of predictability.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Lastly, we demonstrated how to implement a login and register authentication system using GraphQL Apollo Client and </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">Vue 3.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">In the next chapter, you will learn how to build a complete Pinterest clone with Vue 3 and GraphQL. </span><span class="koboSpan" id="kobo.463.2">You will utilize your knowledge of GraphQL to develop and deliver an enterprise application such as Pinterest using Vue 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">and GraphQL.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer039">
</div>
</div>
</body></html>