<html><head></head><body>
		<div id="_idContainer061">
			<h1 id="_idParaDest-170" class="chapter-number"><a id="_idTextAnchor376"/>11</h1>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor377"/>Creating and Automating Workflows</h1>
			<p><a id="_idTextAnchor378"/><a id="_idTextAnchor379"/>Automating workflows with modern workflow automation is an absolute must in large-scale projects. It will save you a lot of time, but even more importantly, it will guarantee that you don’t miss anything and your repetitive processes for steps such as checking for code styling and code quality, building your application, or releasing your application just work.</p>
			<p>Next, it gives you the confidence that the code you have just written doesn’t only work on your machine because it is cloned and started on a clean machine. Last, it ensure the project isn't dependent on individual people.</p>
			<p>In particular, steps such as building and releasing an application can become quite complex in larger-scale projects, so not every member of the project can do it. But with the correct automation setup, all it takes is the push of a button. </p>
			<p>When talking <a id="_idIndexMarker649"/>about workflow automation, you’ll also often hear <a id="_idIndexMarker650"/>the terms <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>). Both terms describe automated workflows. CI refers to the development phase of a project. This means that every developer integrates the code they create into a shared repository frequently, normally multiple times a day. In every integration, the code is checked automatically (TypeScript/Flow, ESLint, Prettier, and Tests) and the developer gets immediate feedback. DS refers to the deployment or delivery step. It describes the automation of building and delivering the application. </p>
			<p>Since CI is possible when building apps, you should use it. CD works for testing builds, but for public production builds, such as mobile apps, it doesn’t work well. Releasing to the public multiple times a day isn’t possible because every release has to be reviewed manually by Apple and Google to be available in the respective app store.</p>
			<p>And even if it were possible (which you could achieve using CodePush, as you’ll learn in <a href="B16694_13.xhtml#_idTextAnchor462"><em class="italic">Chapter 13</em></a>, <em class="italic">Tips and Outlook</em>) I wouldn’t recommend pushing updates too frequently as it will result in every user having to update the app version on every start.</p>
			<p>That’s why we will focus on CI for development and building automated workflows for the build and release step, which can either be triggered manually for public production builds or automatically for internal testing builds (CD).</p>
			<p>This enables you to deliver your application updates automatically to your test users and ship your app to the public with the push of a button while not annoying your real users with too frequent updates. </p>
			<p>Since the best automation tools are worth nothing when the workflows you automate are not good, we’ll also focus on creating an effective development workflow in this chapter. </p>
			<p>In this chapter, we will cover the following topics<a id="_idTextAnchor380"/>:<a id="_idTextAnchor381"/></p>
			<ul>
				<li>Understanding integration/delivery workflow automation</li>
				<li>Creating a collaborative development workflo<a id="_idTextAnchor382"/>w<a id="_idTextAnchor383"/></li>
				<li><a id="_idTextAnchor384"/>Creating useful CI pipelines for the development proces<a id="_idTextAnchor385"/>s<a id="_idTextAnchor386"/></li>
				<li>Understanding workflow automation and CD for build and release</li>
			</ul>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor387"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you must set up the following: </p>
			<ul>
				<li>A working React Native environment (<a href="http://bit.ly/prn-setup-rn">bit.ly/prn-setup-rn</a> – React Native CLI Quickstart) </li>
				<li>While most of this chapter should also work on Windows, I recommend working on a Mac</li>
				<li>An account with GitHub to run the CI pipelines</li>
				<li>An account with Bitrise to run the Bitrise delivery workflows</li>
			</ul>
			<h1 id="_idParaDest-173">Understandin<a id="_idTextAnchor388"/>g<a id="_idTextAnchor389"/> integration/delivery workflow automation</h1>
			<p>The process <a id="_idIndexMarker651"/>of integration and delivery workflow automation is pretty simple: you need a repository and an automation tool or build server that can connect to your repository. Then, you must define rules regarding which Git events should send information to the server to trigger certain scripts. The following diagram illustrates this process:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B16694_11_01.jpg" alt="Figure 11.1 – Basic CI setup&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Basic CI setup</p>
			<p>A Git event such as commit, pull request, or merge triggers the automation tool. The automation tool starts a clean server with a configuration defined in the automation tool settings. Then, it clones the code from your repository and starts running scripts on it. When it comes to React Native apps, these scripts normally start with installing all the project dependencies and running static type checkers (Flow/TypeScript).</p>
			<p>Next, you should run code quality tools such as ESLint and Prettier and check whether the code matches all the requirements. Most of the time, you would also run some tests here (more on this in <a href="B16694_12.xhtml#_idTextAnchor410"><em class="italic">Chapter 12</em></a><em class="italic">, Automated Testing of React Native Apps</em>). </p>
			<p>You can <a id="_idIndexMarker652"/>run every other script here, as well as integrating other cloud tools such as SonarQube (<a href="https://bit.ly/prn-sonarcube">https://bit.ly/prn-sonarcube</a>, an advanced code quality tool) or <a id="_idIndexMarker653"/>Snyk (<a href="https://bit.ly/prn-snyk">https://bit.ly/prn-snyk</a>, a cloud-based security intelligence tool). </p>
			<p>After the scripts have been executed, your automation tool creates a response and sends it back to your repository. This answer then gets shown in your repository and can be used to allow or deny further actions. </p>
			<p>Nowadays, basic automation tools are integrated into all popular Git-based source code repository services, including GitHub (GitHub Actions), Bitbucket (Bitbucket Pipelines), and GitLab (GitLab CI/CD). While these tools work fine for React Native CI requirements, building and deploying mobile apps is a very complex process with special requirements.</p>
			<p>For example, iOS apps can still only be built on macOS machines. While this step is technically also possible with most of these basic automation tools, I wouldn’t recommend using them for building and deploying.</p>
			<p>For this step, there is a special toolkit called fastlane that integrates into special workflow <a id="_idIndexMarker654"/>automation tools such as Bitrise, CircleCI, and Travis CI. I recommend using the toolkit as it will save you a lot of hours.</p>
			<p>Now that you’ve learned about the theory behind process automation, it’s time to think about what our development process should look like. We need a good process in place before we can automate anything.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor390"/>Creating a collaborative development workflow</h1>
			<p>In large-scale projects, one of the most important things is up-to-date information. Typically, in those projects, a lot of people have to be coordinated and multiple project parts <a id="_idIndexMarker655"/>have to work together to build a complex product. While information is important, it shouldn’t limit development speed.</p>
			<p>So, we have to create a workflow that can be supported with automation to fulfill both requirements. The following diagram shows the important parts of this workflow:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B16694_11_02.jpg" alt="Figure 11.2 – Workflow automation setup&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Workflow automation setup</p>
			<p>As you <a id="_idIndexMarker656"/>can see, four technical parts are needed for the workflow. These are as follows:</p>
			<ul>
				<li><strong class="bold">Single Point of Information</strong>: All information is centralized here. Normally, this <a id="_idIndexMarker657"/>is an issue tracker where every task, bug, or feature request is created as an issue. Examples include Jira, ClickUp, GitLab issues, and GitHub issues. </li>
				<li><strong class="bold">Code Management</strong>: This is where your source code is stored. It should be able <a id="_idIndexMarker658"/>to integrate with your <em class="italic">Single Point of Information</em> to transfer information about which issues have already been finished or worked on. Examples include Bitbucket, GitHub code, and GitLab repository.</li>
				<li><strong class="bold">Workflow Automation</strong>: This is where your application gets tested and built. This <a id="_idIndexMarker659"/>tool should also be able to communicate with your <em class="italic">Single Point of Information</em> to transfer information about the state of the issues. Examples include Bitbucket Pipelines, GitHub Actions, GitLab CI/CD, CircleCI, and Bitrise.</li>
				<li><strong class="bold">Stability Monitoring</strong>: After your app has been deployed to your users, you should <a id="_idIndexMarker660"/>track information about its stability. Crashes or other problems should be automatically reported to your <em class="italic">Single Point of Information</em>. Examples include Bugsnag, Sentry, Rollbar, and Crashlytics. You will learn more about these tools in <a href="B16694_13.xhtml#_idTextAnchor462"><em class="italic">Chapter 13</em></a>, <em class="italic">Tips and Outlook</em>.</li>
			</ul>
			<p>Now, we can <a id="_idIndexMarker661"/>start creating our development workflow. The following diagram shows the standard feature branch workflow that I recommend using:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B16694_11_03.jpg" alt="Figure 11.3 – Feature branch workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Feature branch workflow</p>
			<p>As the workflow’s name suggests, for every feature (which can also be a bug or improvement – here, every single issue is considered a feature) a new branch is created. Then, the following workflow starts:</p>
			<ol>
				<li value="1">When the branch is created, the single point of information must be updated so that it contains information regarding whether the issue has already been worked on and who is working on it.</li>
				<li>Next, the developer makes one or multiple commits to solve the issue.</li>
				<li>Every commit is checked by the workflow automation tool.</li>
				<li>If there are errors, the developer will be notified immediately. When the developer thinks they have solved the issue and finished their work, they create a pull request (sometimes called a <strong class="bold">merge request</strong>).</li>
				<li>This pull request is also checked by the workflow automation, but this time, not only with simple checks but with more extensive ones (for example, E2E tests).</li>
				<li>If everythin<a id="_idTextAnchor391"/>g passes, the single point of information must be updated. The issue gets assigned to another developer for review and the status is changed to reflect the review status.</li>
				<li>If changes are requested, the process falls back to <em class="italic">Step 1</em>. If the reviewer is satisfied with the result, they can merge the code to the master or main branc<a id="_idTextAnchor392"/>h.</li>
				<li>Again, the single point of information has to be updated, to reflect the correct status of the issue.</li>
			</ol>
			<p>I like this <a id="_idIndexMarker662"/>process a lot because it provides you with a lot of things you need. Some of these are as follows: </p>
			<ul>
				<li>You always know the exact state of the project.</li>
				<li>Most parts of the workflow can be automated to save time. Normally, the developers and reviewers only have to work in the code management tool; everything else is automated.</li>
				<li>It ensures that every code is double-checked by another developer, which increases code quality.</li>
				<li>The reviewer doesn’t have to do checks for basic code quality because that’s done automatically.</li>
			</ul>
			<p>Now that we know our process, let’s start writing the automation p<a id="_idTextAnchor393"/>i<a id="_idTextAnchor394"/>pelines. </p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor395"/>Creating useful CI pipelines for the development process</h1>
			<p>Again, we’ll use our example project here. First, we’ll set up a pipeline that can support us during <a id="_idIndexMarker663"/>the development process with very simple checks for <em class="italic">Step 3</em> of <em class="italic">Figure 11.3</em>. We’ll use GitHub Actions to execute this CI pipeline, but it works very similar with Bitbucket (<a href="https://bit.ly/prn-bitbucket-pipelines">https://bit.ly/prn-bitbucket-pipelines</a>) and GitLab CI/CD (<a href="https://bit.ly/prn-gitlab-cicd">https://bit.ly/prn-gitlab-cicd</a>).</p>
			<p>First, we have to create the scripts we want to use in our pipelines. In our example, we want to run type checking with the TypeScript compiler and static code analysis with ESLint and Prettier to ensure the correct code styling is in place.</p>
			<p>For this, we’ll provide the following scripts in the <strong class="source-inline">scripts</strong> section of our <strong class="source-inline">package.json</strong> file:</p>
			<pre class="source-code">
"typecheck": "tsc --noEmit",
"lint": "eslint ./src",
"<a id="_idTextAnchor396"/>prettier": "prettier ./src --check",</pre>
			<p>Next, we have to create a workflow file that can be interpreted by GitHub Actions. Since this is a fully integrated workflow automation, as soon as we push this file to our GitHub repository, GitHub Actions starts working. </p>
			<p>This is what our first workflow automation pipeline (or CI pipeline) looks like. You have to create it under <strong class="source-inline">.github/workflows/&lt;the github actions workflow name&gt;.yml</strong>:</p>
			<pre class="source-code">
name: Check files on push
on: push
jobs:
  run-checks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: install modules
        run: npm install
      - name: run typecheck
        run: npm run typecheck
      - name: run prettier check for code styling
        run: npm run prettier
      - name: run eslint check for code errors
        run: npm run lint</pre>
			<p>Let’s go <a id="_idIndexMarker664"/>through the code line by line. The first line defines the name of the workflow. The second line defines when the workflow should run. In this case, we want to run it on every push to the repository, no matter to which branch or from which author this push comes.</p>
			<p class="callout-heading">Hint</p>
			<p class="callout">You can run workflows on different trigger events. You can find the full list in the documentation (<a href="https://bit.ly/prn-github-actions-events">https://bit.ly/prn-github-actions-events</a> for the GitHub Actions event list).</p>
			<p class="callout">Some especially useful events for the development process described in the previous section are push and pull requests. You can also limit these triggers to specific branches. </p>
			<p>Next, you can see the <strong class="source-inline">jobs</strong> section. Here, you define the actual workflow, which contains one or multiple jobs that can run in sequence or parallel. In this case, we defined one job with multiple steps.</p>
			<p>The first thing we have to do for our job is define which machine it should run on. Every workflow automation tool has a lot of predefined machine images you can choose from, but you can always provide your own machines to run the automation pipelines. In our example, we’ll use the latest Ubuntu image that is provided by GitHub Actions. </p>
			<p>Next, we define the steps of our job. This can either be a predefined action that we <a id="_idTextAnchor397"/>use with the <strong class="source-inline">uses</strong> command or an action that we create by ourselves. In our example, we make use of both options. First, we use a predefined action to check out our code, then we use four self-created actions to install the modules and run <a id="_idTextAnchor398"/>o<a id="_idTextAnchor399"/>ur checks. </p>
			<p class="callout-heading">Hint</p>
			<p class="callout">When working with workflow automation tools, the time your workflows run for is the metric you will pay for. So, you should always think about how to structure your workflows so that you spend as little time as possible on the automation tool machines. </p>
			<p>As soon <a id="_idIndexMarker665"/>as we pushed this file to our GitHub repository, the first run of the automated workflow was triggered. In this case, the machine started, cloned the repository, installed the dependency modules, and ran our checks. You can watch the automation running in the <strong class="bold">GitHub Actions</strong> tab. </p>
			<p>In the preceding <em class="italic">Hint</em>, you learned that optimizing workflows to run as fast as possible is important. So, that’s what we’ll do next. The following diagram shows two ways to optimize our workflow so that we can complete it faster:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B16694_11_04.jpg" alt="Figure 11.4 – Parallelize workflows&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Parallelize workflows</p>
			<p>The easiest way to complete things faster is by running them in parallel. GitHub Actions doesn’t allow you to run steps in parallel, but you can run multiple jobs in parallel. You have to investigate your workflow in detail to find out which parts can be parallelized, and which steps are better to run in sequence.</p>
			<p>In our example, it wouldn’t make much sense to just create three jobs for the three tasks. This is because the step that takes the most time installs the dependencies and it would be necessary for all three jobs. Fortunately, it is possible to work with caches so that we don’t have to repeat cacheable tasks with any test run.</p>
			<p>On the left-hand side of the preceding diagram, you can see the pipeline setup for our example, which installs dependencies first and then runs our three jobs in parallel. All three jobs <a id="_idIndexMarker666"/>fetch the dependencies from the cache, which is populated in the install step. On the right-hand side, you can see another setup. In this setup, we have three parallel jobs, running completely independently from each other.</p>
			<p>All three jobs try to fetch the dependencies from the cache and install them only if they can’t find them there. Both options are faster in certain scenarios. If you have to install the dependencies, the second setup would take a little longer because the install step will be triggered three times (because the steps start in parallel, and at the time they start, the dependencies are either cached or not for all three jobs).</p>
			<p>The first setup only triggers t<a id="_idTextAnchor400"/>he dependency install once and ensures that it is cached for the other jobs. This first setup will take more time in most scenarios because it requires you to run two jobs in sequence (<em class="italic">install</em> + <em class="italic">typecheck/Prettier/ESLint</em>).</p>
			<p>This is why I recommend going with the second setup, as shown in the following code:</p>
			<pre class="source-code">
name: Check files on push alternative
on: push
jobs:
  typecheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - uses: actions/cache@v2
        id: npm-cache
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-node-${{
               hashFiles('**/pack<a id="_idTextAnchor401"/>age-lock.json') }}
      - name: Install depend<a id="_idTextAnchor402"/>encies if not cached
        if: steps.npm-cache.<a id="_idTextAnchor403"/>outputs.cache-hit != 'true'
        run: npm install
      - name: run typecheck
        run: npm run typecheck
  prettier:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - uses: actions/cache@v2
        id: npm-cache
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-node-${{
               hashFiles('**/package-lock.json') }}
      - name: Install depend<a id="_idTextAnchor404"/>encies if not cached
        if: steps.npm-cache.<a id="_idTextAnchor405"/>outputs.cache-hit != 'true'
        run: npm install
      - name: run prettier check for code styling
        run: npm run prettier
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - uses: actions/cache@v2
        id: npm-cache
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-node-${{
               hashFiles('**/pack<a id="_idTextAnchor406"/>age-lock.json') }}
      - name: Install depend<a id="_idTextAnchor407"/>encies if not cached
        if: steps.npm-cache.outputs.cache-hit != 'true'
        run: npm install
      - name: run eslint check for code errors
        run: npm run lint</pre>
			<p>As you can see, the three jobs are very similar. We check out the project, set the node environment with a specified node version, and check the cache. The key of the cache contains the OS version of the runtime and the hash value of the <strong class="source-inline">package-lock.json</strong> file, which changes when anything changes with the dependencies (version updates, new libraries, and so on).</p>
			<p>Next, we have a conditional install step, which only installs the dependencies when we didn’t hit <a id="_idIndexMarker667"/>the cache. This is the case when the name of our cache changes, as described previously, or if the cache expires (which it does after it hasn’t been used for at least 1 week).</p>
			<p>Finally, we execute our typecheck/Prettier/ESLint step. While this parallelization seems to be quite complex, it can save you a lot of time when using it at scale. So, you should take some time to set up your workflow automation so that it fits your needs. </p>
			<p>All modern code management solutions, such as GitHub, Bitbucket, and GitLab, have a very deep integration of workflow automation tools. This means that as soon as you have configured your workflow automation, you will see the results not only in the workflow automation tool or section but also in your repository. For example, it will show the result of every commit that was tested directly in the commit list. </p>
			<p>For more details, you have to visit the workflow automation tool or section – in our case, GitHub Actions – to see the results of the CI pipeline. If everything worked as expected, you will see a green checkmark. If the workflow detected that an error was thrown in any of our checks, we will see a red dot, which notifies us about our failed workflow execution.</p>
			<p>The following screenshot shows a list with multiple workflow runs:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B16694_11_05.jpg" alt="Figure 11.5 – Workflow runs inside GitHub Actions&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Workflow runs inside GitHub Actions</p>
			<p>In this <a id="_idIndexMarker668"/>example, two runs of our workflow succeeded, while one of them failed. The failed workflow run is always the interesting one because it provides a lot of information about what went wrong.</p>
			<p>By clicking on it, you will see information about the logs and execution times so that you can find and fix the error. This is how it looks inside <strong class="bold">GitHub Actions</strong>:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B16694_11_06.jpg" alt="Figure 11.6 – Failed workflow run in GitHub Actions&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Failed workflow run in GitHub Actions</p>
			<p>As you <a id="_idIndexMarker669"/>can see, we don’t only see which check fails, but also the detailed logs. In this case, we used the wrong type in the <strong class="source-inline">Genre.tsx</strong> file, which resulted in a bunch of errors. With this workflow, we didn’t only find the error – we also know the exact file and line number where we have to fix our error.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Working with CI pipelines is all about giving feedback as soon as possible. You should use tools <a id="_idIndexMarker670"/>such as Husky (<a href="https://bit.ly/prn-husky">https://bit.ly/prn-husky</a>) to run your pipelines before committing them to your local machine. This not only replaces your workflow automation tool, but it can also be useful to shorten the feedback cycle even more.</p>
			<p>Now that you know how to create CI pipelines to support and improve the development process, let’s have a look at building and releasing apps. </p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor408"/>Understanding workflow automation and CD for build and release</h1>
			<p>Before we start creating our pipeline, let’s look at building and releasing apps in general. Android <a id="_idIndexMarker671"/>uses Gradle as its build tool and a KeyStore file to verify ownership of an app. If you are not familiar with releasing Android apps, please read this guide first: <a href="https://bit.ly/prn-android-release">https://bit.ly/prn-android-release</a>.</p>
			<p>On iOS, you have to use Xcode to build, sign, and release your app. If you are not familiar with this process, please read this guide first: <a href="https://bit.ly/prn-ios-release">https://bit.ly/prn-ios-release</a>.</p>
			<p>Fortunately, for both platforms (Android and iOS), the build and deployment processes can be <a id="_idIndexMarker672"/>executed via command-line tools. Gradle works as a command-line tool itself and Xcode provides the Xcode command-line tools. This means we can write scripts for the complete process, which we can then invoke with our workflow automation tools. </p>
			<p>Unfortunately, these processes are quite complex, so we don’t want to write scripts by ourselves. This is where <a id="_idIndexMarker673"/>a toolset called <strong class="bold">Fastlane</strong> comes into play. Fastlane is a specialized automation tool for iOS and Android apps. It provides scripts for signing, building, and deploying code to the Apple App Store and Google Play. You can find more <a id="_idIndexMarker674"/>information about Fastlane here: <a href="https://bit.ly/prn-fastlane">https://bit.ly/prn-fastlane</a>.</p>
			<p>The reason why I do not recommend using Fastlane directly is that it has excellent integration with advanced workflow automation tools such as Bitrise and CircleCI. We’ll take a deeper look at Bitrise as an example, but other tools such as CircleCI and Travis CI work very similarly. </p>
			<p>Bitrise integrates into your code management solution the same way you saw with GitHub Actions. You can use certain events to trigger workflows. It provides an excellent UI to create these workflows. I like working with it because it is quite easy and saves a lot of time.</p>
			<p>You can choose from a huge variety of predefined actions, which mainly focus on iOS and Android apps. Bitrise even provides its own automatic setup for React Native apps. The following diagram shows a typical iOS build and deploy workflow:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B16694_11_07.jpg" alt="Figure 11.7 – Bitrise iOS build and deploy workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Bitrise iOS build and deploy workflow</p>
			<p>The steps are executed column after column. So, we start by activating an SSH key to be able to <a id="_idIndexMarker675"/>connect to the repository. Next, the repository gets cloned. After that, the <strong class="source-inline">npm</strong> dependency modules are installed, as well as the native module via CocoaPods.</p>
			<p>As an example, for every other script that can be integrated here, we’ll fetch the most recent <a id="_idIndexMarker676"/>translation files for our app UI to be integrated with the app bundle in the next step. Then, we’ll update the version number inside our <strong class="source-inline">Info.plist</strong> file. Next, the workflow handles the code signing, builds the application, and deploys it to App Store Connect. </p>
			<p>The workflow for an Android build looks pretty similar:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B16694_11_08.jpg" alt="Figure 11.8 – Bitrise Android build and deploy workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Bitrise Android build and deploy workflow</p>
			<p>Again, the actions are executed column after column. The first column is the same as in the iOS workflow. The SSH key gets activated, the repository gets cloned, and the <strong class="source-inline">npm</strong> dependency modules are installed. Next, we have to install all the missing Android SDK tools.</p>
			<p>Then, we must change the Android version code and – as we did in iOS – fetch the translations to be bundled with the application. Then, we must build the application and deploy it to Google Play. </p>
			<p>Under the hood, Bitrise and other CI tools with graphical workflow editors use the same logic you <a id="_idIndexMarker677"/>learned about while setting up the development CI pipeline. The <a id="_idIndexMarker678"/>following code is for the <strong class="source-inline">.yml</strong> file for the iOS workflow:</p>
			<pre class="source-code">
  ios-release-build:
    steps:
    - activate-ssh-key@4:
        run_if: '{{getenv "SSH_RSA_PRIVATE_KEY" | ne ""}}'
    - git-clone@4: {}
    - npm@1:
        inputs:
        - command: install
    - cocoapods-install@2: {}
    - script@1:
        inputs:
        - content: |-
            cd scripts
            bash getTranslationsCrowdin.sh
    - set-ios-info-plist-unified@1:
        inputs:
        - bundle_version: „$VERSION_NUMBER_IOS"
        - info_plist_file: "$BITRISE_SOURCE_DIR_PLIST"
    - manage-ios-code-signing@1:
    - xcode-archive@4.3:
        inputs:
        - project_path: "$BITRISE_PROJECT_PATH"
        - distribution_method: app-store
        - export_method: app-store
    - deploy-to-itunesconnect-deliver@2:</pre>
			<p>As you can see, it has the same structure. It contains multiple steps, which can get additional <a id="_idIndexMarker679"/>input as configuration. Like any other workflow automation tool, Bitrise works with environment variables. These variables are stored on the <a id="_idIndexMarker680"/>platform and replace the placeholders (here, they start with <strong class="source-inline">$</strong>) during the execution of the workflow. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You should never add private keys or signing information to your repository. If this happened, everyone who has access to the repository would get access to this private data and would be able to sign releases for your application. It’s much better to store this information in your workflow automation tool because there, nobody can obtain the keys and signing certificates, but all developers with access can still create new releases. </p>
			<p>This workflow can either be triggered manually, which I would recommend for public production builds, or automatically, which I would recommend for internal or public testing builds. </p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor409"/>Summary</h1>
			<p>Now, it’s time to wrap up this chapter. First, you learned what the terms workflow automation, continuous integration, and continuous delivery mean and which of them work for app development. Then, you considered a development process you can use in large-scale projects.</p>
			<p>Next, you learned how to support this process through workflow automation with simple workflow automation tools such as GitHub Actions. Finally, you learned about specialized workflow automation tools such as Bitrise so that you can build, sign, and deploy your iOS and Android apps. </p>
			<p>One topic that is especially important when it comes to workflow automation was left out in this chapter – <strong class="bold">testing</strong>. Automated testing is important during the development phase, as well as before shipping your releases. Therefore, we’ll have a detailed look at automated testing in the next chapter.</p>
		</div>
	</body></html>