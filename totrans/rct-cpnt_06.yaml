- en: Chapter 6. Changing Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered a bit about material design, and as a result,
    we split the login and page admin sections into different files. We stopped short
    of making the login redirect us to the page admin section.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to change sections without reloading the
    page. We'll use this knowledge to create public pages for the website our CMS
    is meant to control.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see how to work with the browser's address bar and location history. We'll
    also learn how to use popular libraries to abstract these things for us, so we
    can save time on writing boilerplate and concentrate on making our interfaces
    great!
  prefs: []
  type: TYPE_NORMAL
- en: Location, location, location!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can learn about alternatives to reloading pages, let's take a look
    at how the browser manages reloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve probably encountered the `window` object. It''s a global catch-all
    object for browser-based functionality and state. It''s also the default `this`
    scope in any HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Location, location, location!](img/5268_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've even accessed `window` earlier. When we rendered to `document.body` or
    used `document.querySelector`, these properties and methods were called on the
    `window` object. It's the same as calling `window.document.querySelector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, `document` is the only property we need. That doesn''t mean
    it''s the only property useful to us. Try the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were trying to work out which components to show based on the browser
    URL, this would be an excellent place to start. Not only can we read from this
    object, but we can also write to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Putting this in an HTML page or entering that line of JavaScript in the console
    will redirect the browser to [www.material-ui.com](http://www.material-ui.com).
    It's the same as clicking on a link to that website. And, if it's redirected to
    a different page (than the one the browser is pointing at), then it will cause
    a full page reload.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So how does this help us? We're trying to avoid full page reloads, after all.
    Let's experiment with this object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what happens when we add something like `#page-admin` to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![A bit of history](img/5268_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding `#page-admin` to the URL leads to the `window.location.hash` property
    being populated with the same. What's more, changing the hash value won't reload
    the page! It's the same as clicking on a link that had a hash in the `href` attribute.
    We can modify it without causing full page reloads, and each modification will
    store a new entry in the browser history.
  prefs: []
  type: TYPE_NORMAL
- en: Using this trick, we can step through a number of different states without reloading
    the page, and we will be able to backtrack each with the browser's back button.
  prefs: []
  type: TYPE_NORMAL
- en: Using browser history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s put this trick to use in our CMS. First, let''s add a couple of functions
    to our `Nav` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We add an `onClick` attribute to our navigation links. We created a special
    function that will change `window.location.hash` and prevent the default full
    page reload behavior the links would otherwise have caused.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a neat use of the arrow functions, but we're ultimately creating three
    new functions in each render call. Remember that this can be expensive, so it's
    best to move the function creation out of render. We'll replace this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: It's also interesting to see template strings in action. Instead of `"#" + section`,
    we can use `'#${section}'` to interpolate the section name. It's not as useful
    in small strings, but becomes increasingly useful in large ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the navigation links will now change the URL hash. We can add to
    this behavior by rendering different components when the navigation links are
    clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We've had to convert the `Nav` function to a `Nav` class. We want to create
    the redirect method outside of render (as that is more efficient) and also isolate
    the choice of which component to render.
  prefs: []
  type: TYPE_NORMAL
- en: Using a class also gives us a way to name and reference the `Nav` component,
    so we can create a new instance to overwrite it from within the `redirect` method.
    It's not ideal to package this kind of code within a component, so we'll clean
    that up in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: We can now switch between different sections without full page reloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one problem still to solve. When we use the browser''s back button,
    the components don''t change to reflect the component that should be shown for
    each hash. We can solve this in a couple of ways. The first approach we can try
    is checking the hash frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our `redirect` method has an extra parameter, to apply the new hash whenever
    we're not responding to a hash change. We also wrapped the call to `event.preventDefault`
    in case we don't have a click event to work with. Other than these changes, the
    `redirect` method is the same.
  prefs: []
  type: TYPE_NORMAL
- en: We also added a `componentDidMount` method in which we make a call to `setInterval`.
    We stored the initial `window.location.hash` property and checked 10 times a second
    to see whether it has changed. The hash value is `#login` or `#page-admin`, so
    we sliced the first character off and passed the rest to the `redirect` method.
  prefs: []
  type: TYPE_NORMAL
- en: Try clicking on the different navigation links and then using the browser's
    back button.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is to use the newish `pushState` and `popState` methods on
    the `window.history` object. They're not very well supported yet, so you need
    to be careful when you handle older browsers, or ensure that you don't need to
    handle them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about `pushState` and `popState` at [https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API).
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an easier way to respond to users clicking links: the `hashchange`
    event. Instead of adding the `onClick` events to each of the links (and calling
    the `redirect` function every time), we can listen for the `hashchange` events
    and change to the appropriate view. There''s a great tutorial on this at [https://medium.com/@tarkus/react-js-routing-from-scratch-246f962ededf](https://medium.com/@tarkus/react-js-routing-from-scratch-246f962ededf).'
  prefs: []
  type: TYPE_NORMAL
- en: Using a router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our hash code is functional but invasive. We shouldn't call the `render` method
    from inside a component (at least not the one we own). So, we will instead use
    a popular router to manage this stuff for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the router with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to put `login.html` and `page-admin.html` back into the same
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we''ve added the `ReactRouter` file to the import map? We''ll use
    that in `admin.js`. First, let''s define our `layout` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the page layout we''ve been using and allows a dynamic content
    component. Every React component has a `this.props.children` property (or `props.children`
    in the case of a `function` component), which is an array of nested components.
    For example, consider the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `App` component, `this.props.children` will contain a single item:
    an instance of the `Login`. Next, we''ll define handler components for the two
    sections we want to route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We don't really need to wrap `Login` in `LoginHandler`, but I chose to do it
    to be consistent with `PageAdminHandler`. `PageAdmin` expects an instance of `Backend`,
    so we have to wrap it, as we see in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can define routes for our CMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's a single root route for the path `/`. It creates an instance of `App`,
    so we always get the same layout. Then, we nest a `"login"` route and a `"page-admin"`
    route. These create instances of their respective components. We also define `IndexRoute`
    so that the login page will be displayed as a landing page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to remove our custom history code from `Nav`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Also, since we no longer need a separate `redirect` method, we can convert the
    class back into a statement component (`function`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we swapped anchor components for a new `Link` component. This interacts
    with the router to show the correct section when we click on the navigation links.
    We can also change the route paths without the need to update this component (unless
    we also change the route names).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding chapter, we split `index.html` into `login.html` and `page-admin.html`
    to see both sections just by changing the URL. In this chapter, we joined them
    back together, since we have a router to switch between them. You'll need to make
    the same changes or use the example code for this chapter in order for the examples
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating public pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can easily switch between CMS sections, we can use the same trick
    to show the public pages of our website. Let''s create a new HTML page just for
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a reduced form of `admin.html` without the material design resources.
    I think we can ignore the appearance of these pages for the moment while we focus
    on the navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The public pages are stateless, so we can use the `function` components for
    them. Let''s begin with the layout component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to the `App` admin component, but it also has a reference to
    `Backend`. We then define it when we render the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work, we also need to define `StaticPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This component is more interesting. We access the `params` property, which is
    a map of all the URL path parameters defined for this route. We have `:page` in
    the path (`pages/:page`), so when we go to `pages/1`, the `params` object is `{"page":1}`.
  prefs: []
  type: TYPE_NORMAL
- en: We also pass `Backend` to `Page`, so we can fetch all pages and filter them
    by `page.id`. If no `page.id` is provided, we default to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: After filtering, we check whether there are any pages. If not, we return a simple
    **Not found** message. Otherwise, we render the content of the first page in the
    array (since we expect the array to have a length of at least `1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a page for the public pages of the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating public pages](img/5268_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also add the `onEnter` and `onLeave` callbacks to each of our routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As the current route changes, the previous route will trigger `onLeave`, as
    will each parent component up the inheritance chain. Once all the `onLeave` callbacks
    are triggered, the router will begin to trigger the `onEnter` callbacks down the
    inheritance chain. We didn't really use inheritance much (owing to how simple
    our navigation is), but it's still important to remember that `onLeave` is triggered
    before `onEnter`.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful if we want to commit any unsaved data to our backend, log the
    progress of a user through the interface or anything else that might depend on
    the user navigating between pages on the site.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we want to animate different pages as they are rendered.
    We can combine them with `React.addons.CSSTransitionGroup`, which we saw in [Chapter
    4](ch04.html "Chapter 4. Styling and Animating Components"), *Styling and Animating
    Components*. As new components are rendered inside the `App` component, we will
    be able to animate them in exactly the same way. Just include `div.layout` in
    a `React.addons.CSSTransitionGroup` component and you should be all set!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about how the browser stores URL history, and how
    we can manipulate it to load different sections without full page reloads. It
    introduced a bit of complexity, but we also saw that there are other alternatives
    (for example, the `hashchange` event) that reduce the complexity while still reducing
    the number of full page reloads we need to perform.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about a popular React router and used it to abstract the manual
    location tracking or changing we had to do before.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about server-side rendering and application
    structure.
  prefs: []
  type: TYPE_NORMAL
