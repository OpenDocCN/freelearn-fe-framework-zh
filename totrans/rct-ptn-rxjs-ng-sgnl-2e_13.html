<html><head></head><body>
<div id="_idContainer086">
<h1 class="chapter-number" id="_idParaDest-184"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-185"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.2.1">Testing RxJS Observables</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Observables play a </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.4.1">central role in managing asynchronous data streams and event-driven interactions. </span><span class="koboSpan" id="kobo.4.2">By thoroughly testing Observables, developers can verify the correctness of their asynchronous code, anticipate and handle various edge cases, and ensure consistent behavior across different environments and </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">The comprehensive testing of Observables not only enhances the robustness of applications but also improves code quality, reduces the likelihood of bugs and regressions, and ultimately enhances the overall user experience. </span><span class="koboSpan" id="kobo.6.2">With rigorous testing practices in place, developers can confidently deploy reactive applications that meet high standards of reliability, performance, </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">and usability.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Many developers consider testing Observables a challenging task. </span><span class="koboSpan" id="kobo.8.2">This is true. </span><span class="koboSpan" id="kobo.8.3">However, if you learn the right techniques, you can implement maintainable and readable tests in a very </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">effective manner.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will walk you through three commonly used patterns for testing streams. </span><span class="koboSpan" id="kobo.10.2">We will start by explaining the subscribe and assert pattern, after which we will discuss the marble testing pattern. </span><span class="koboSpan" id="kobo.10.3">Finally, we will highlight a suitable pattern for testing streams that are returned from </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">HTTPClient</span></strong><span class="koboSpan" id="kobo.12.1"> by focusing on a concrete example in our </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">recipe app.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1">Learning about the subscribe and </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">assert pattern</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Learning about the marble </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">testing pattern</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Highlighting testing streams </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">HTTPClientTestingModule</span></strong></span></li>
</ul>
<h1 id="_idParaDest-186"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">This chapter assumes that you have a basic understanding of RxJS and unit testing in Angular using Jasmine. </span><span class="koboSpan" id="kobo.24.2">Follow this link for more </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">information: </span></span><a href="https://angular.dev/guide/testing#set-up-testing"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://angular.dev/guide/testing#set-up-testing</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.28.1">Note</span></p>
<p class="callout"><a href="http://angular.dev"><span class="koboSpan" id="kobo.29.1">angular.dev</span></a><span class="koboSpan" id="kobo.30.1"> will be the new documentation site for Angular developers; it offers updated features and documentation. </span><a href="http://angular.io"><span class="koboSpan" id="kobo.31.1">angular.io</span></a><span class="koboSpan" id="kobo.32.1"> will be deprecated in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">future releases.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">We will be testing Observables in an Angular context. </span><span class="koboSpan" id="kobo.34.2">The source code for this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap13"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap13</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">We will be completing a unit test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">saveRecipe</span></strong><span class="koboSpan" id="kobo.40.1"> method, which is available under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">RecipesService</span></strong><span class="koboSpan" id="kobo.42.1"> class. </span><span class="koboSpan" id="kobo.42.2">You can find the complete code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">recipes.service.spec</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.44.1"> file.</span></span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.45.1">Learning about the subscribe and assert pattern</span></h1>
<p><span class="koboSpan" id="kobo.46.1">As you will already know, Observables </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.47.1">are lazy, and we don’t obtain any value until we subscribe to them. </span><span class="koboSpan" id="kobo.47.2">In tests, it is the same thing; Observables will not emit any value until we subscribe to them. </span><span class="koboSpan" id="kobo.47.3">To solve this, programmers always tend to subscribe to the Observables manually inside the tests and then perform assertions on the emitted values. </span><span class="koboSpan" id="kobo.47.4">This is what we call the </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">subscribe and </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.49.1">assert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1"> pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">Let’s delve into testing using the subscribe and assert pattern across three distinct scenarios. </span><span class="koboSpan" id="kobo.51.2">We will demonstrate testing for methods returning a single value, methods returning multiple values, and methods returning timed values (values returned after a specified </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">time duration).</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.53.1">Testing single-value output methods</span></h2>
<p><span class="koboSpan" id="kobo.54.1">Let’s suppose</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.55.1"> we have to test a method that returns a single value. </span><span class="koboSpan" id="kobo.55.2">The method is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">getValue(value: boolean)</span></strong><span class="koboSpan" id="kobo.57.1"> and is available in an Angular service </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">SampleService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">The method</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.62.1"> itself is very simple, returning an Observable that will emit the Boolean input value </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.64.1">
import { Observable, of } from 'rxjs';
export class SampleService {
  getValue(value: boolean): Observable&lt;boolean&gt; {
    return of(value);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.65.1">The test of this method will look </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
describe('SampleService', () =&gt; {
  let service: SampleService;
  beforeEach(() =&gt; {
    service = TestBed.inject(SampleService);
  });
  it('should return true as a value', () =&gt; {
    service.getValue(true).subscribe(
      result=&gt;expect(result).toEqual(true))
  });
});</span></pre> <p><span class="koboSpan" id="kobo.68.1">Here, we start by defining our test suite using the Jasmine </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">describe()</span></strong><span class="koboSpan" id="kobo.70.1"> function. </span><span class="koboSpan" id="kobo.70.2">The function is used to define a test suite, which is a logical grouping of test cases to execute a single task </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.71.1">with different test scenarios. </span><span class="koboSpan" id="kobo.71.2">It serves as a way to organize and structure your tests, making them more readable </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">and maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">describe()</span></strong><span class="koboSpan" id="kobo.75.1"> function takes </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">two parameters:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.77.1">A string description of the test suite (in the previous code snippet, </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">SampleService</span></strong><span class="koboSpan" id="kobo.79.1">, which is the name of the service that we are going to test and refers to the description of our </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">test suite).</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">A function that contains the test cases for that suite (in testing frameworks, “test case” and “spec” typically refer to a single unit of testing within a test suite). </span><span class="koboSpan" id="kobo.81.2">Inside this function, we inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">SampleService</span></strong><span class="koboSpan" id="kobo.83.1"> into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">beforeEach</span></strong><span class="koboSpan" id="kobo.85.1"> statement to provide a shared instance of the service that we will be using in all the test cases. </span><span class="koboSpan" id="kobo.85.2">Finally, we define the test case of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">getValue(value: boolean)</span></strong><span class="koboSpan" id="kobo.87.1"> method by using the Jasmine function </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">it()</span></strong><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">it()</span></strong><span class="koboSpan" id="kobo.91.1"> function takes </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">two parameters:</span></span><ul><li><span class="koboSpan" id="kobo.93.1">A string description of the test case (in the previous code snippet, </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">should return true as a value</span></strong><span class="koboSpan" id="kobo.95.1"> refers to the description of our </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">test case).</span></span></li><li><span class="koboSpan" id="kobo.97.1">A function that contains the test logic. </span><span class="koboSpan" id="kobo.97.2">In this function, we subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">getValue(true)</span></strong><span class="koboSpan" id="kobo.99.1"> method and expect the result to be equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">true</span></strong><span class="koboSpan" id="kobo.101.1"> since we passed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">true</span></strong><span class="koboSpan" id="kobo.103.1"> value as input. </span><span class="koboSpan" id="kobo.103.2">Expectations are built using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">expect()</span></strong><span class="koboSpan" id="kobo.105.1"> Jasmine function and are used to assert or verify that certain conditions are met during the execution of </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">a test.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.107.1">Now, let’s run </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">ng test</span></strong><span class="koboSpan" id="kobo.109.1">; the test passes, and everything </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">is fine:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.111.1"><img alt="Figure 13.1 – ng test output" src="image/B21180_13_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.112.1">Figure 13.1 – ng test output</span></p>
<p><span class="koboSpan" id="kobo.113.1">Quite simple, right? </span><span class="koboSpan" id="kobo.113.2">This is the expected behavior when running a positive scenario. </span><span class="koboSpan" id="kobo.113.3">A positive scenario typically involves providing input or conditions that align with the expected behavior of the code being tested, resulting in successful execution without errors </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">or failures.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Now, let’s </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.116.1">handle a negative scenario by providing input or conditions that are intended to trigger failures in the code being tested. </span><span class="koboSpan" id="kobo.116.2">To do so, we will replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">true</span></strong><span class="koboSpan" id="kobo.118.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">false</span></strong><span class="koboSpan" id="kobo.120.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">following assertion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
  it('should return true as a value', () =&gt; {
  service.getValue(true).subscribe(
    result=&gt;expect(result).toEqual(false))
  });</span></pre> <p><span class="koboSpan" id="kobo.123.1">When you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">ng test</span></strong><span class="koboSpan" id="kobo.125.1"> again, our test </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">will fail.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">However, in some cases, the test will still pass. </span><span class="koboSpan" id="kobo.127.2">How is </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">this possible?</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">The thing with expectations in testing is that if you have an unmet assertion, it throws an error. </span><span class="koboSpan" id="kobo.129.2">Plus, if you have an unhandled error inside an RxJS subscription, it will be thrown on a separate call stack, meaning that it is asynchronously thrown. </span><span class="koboSpan" id="kobo.129.3">Therefore, tests that use the subscribe and assert pattern can sometimes be green even though, in reality, they </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">are failing.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">To overcome this, we should pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">done</span></strong><span class="koboSpan" id="kobo.133.1"> callback to the test function and call it manually after our expectations for when the test has been completed, </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.135.1">
   it('should return true as a value', (done) =&gt; {
    service.getValue(true).subscribe(
      result =&gt; {
        expect(result).toEqual(false);
        done();
      }
    );
  });</span></pre> <p><span class="koboSpan" id="kobo.136.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">done</span></strong><span class="koboSpan" id="kobo.138.1"> callback is a mechanism used in asynchronous testing to signal the completion of a test case to the testing framework. </span><span class="koboSpan" id="kobo.138.2">It is supported by many testing frameworks, such as Jasmine, Jest, and Mocha. </span><span class="koboSpan" id="kobo.138.3">Calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">done</span></strong><span class="koboSpan" id="kobo.140.1"> callback </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.141.1">ensures that the test doesn’t finish prematurely before all asynchronous tasks have been executed and assertions have been verified. </span><span class="koboSpan" id="kobo.141.2">Therefore, we prevent false positives and ensure that our tests accurately reflect the behavior of the code being tested, particularly in asynchronous scenarios. </span><span class="koboSpan" id="kobo.141.3">So, don’t forget to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">done</span></strong><span class="koboSpan" id="kobo.143.1"> callback in </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">asynchronous scenarios!</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Now, let’s consider a more complicated method that will return multiple values instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">one value.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.147.1">Testing multiple-value output methods</span></h2>
<p><span class="koboSpan" id="kobo.148.1">Let’s </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.149.1">consider a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">getValues</span></strong><span class="koboSpan" id="kobo.151.1">, which will return multiple values </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.153.1">
export class SampleService {
  getValues(): Observable&lt;String&gt; {
    return of('Hello', 'Packt', 'Readers');
  }
}</span></pre> <p><span class="koboSpan" id="kobo.154.1">The values will be emitted one by one in the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">aforementioned order.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">When using the assert and subscribe pattern, the test will look </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
it('should return values in the right order', (done) =&gt; {
  const expectedValues = ['Hello', 'Packt', 'Readers'];
  let index = 0;
  service.getValues().subscribe(result =&gt; {
    expect(result).toBe(expectedValues[index]);
    index++;
    if (index === expectedValues.length) {
      done();
    }
  });
});</span></pre> <p><span class="koboSpan" id="kobo.159.1">In the preceding code, we created an array that represents the </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.160.1">expected values in order; then, we subscribed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">getValues</span></strong><span class="koboSpan" id="kobo.162.1"> method and compared the emitted values with the expected value using a counter (</span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">expectedValues[index]</span></strong><span class="koboSpan" id="kobo.164.1">). </span><span class="koboSpan" id="kobo.164.2">After finishing, we called the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">done()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1"> callback.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">However, instead of the counter, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">toArray</span></strong><span class="koboSpan" id="kobo.169.1"> operator of RxJS, which will put the values that have been emitted in an array and then compare the resulting array with the expected array </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">we defined:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
it('should return values in the right order', (done) =&gt; {
  const expectedValues = ['Hello', 'Packt', 'Readers'];
  service.getValues().pipe(toArray()).subscribe(result =&gt; {
    expect(result).toEqual(expectedValues);
    done();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.172.1">Well, this is working fine, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">ng test</span></strong><span class="koboSpan" id="kobo.174.1"> will pass. </span><span class="koboSpan" id="kobo.174.2">However, in both cases, even though we are dealing with a simple stream, we were forced to add some logic; in the first example, we added a counter, while in the second example, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">toArray</span></strong><span class="koboSpan" id="kobo.176.1"> operator. </span><span class="koboSpan" id="kobo.176.2">This boils down the tests and adds some unnecessary testing logic; these are the most significant drawbacks of the subscribe and </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">assert pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">Now, let’s move on to a different example and explore testing methods that output </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">timed values.</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.180.1">Testing timed-value output methods</span></h2>
<p><span class="koboSpan" id="kobo.181.1">Let’s update </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.182.1">the method </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">getValues()</span></strong><span class="koboSpan" id="kobo.184.1"> and add a timer to return the values after a specific duration </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
  getValues(): Observable&lt;String&gt; {
    return timer(0, 5000).pipe(
      take(3),
      switchMap((result) =&gt; of('Hello', 'Packt',
                               'Readers'))
    )</span></pre> <p><span class="koboSpan" id="kobo.187.1">Here, we used the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">timer</span></strong><span class="koboSpan" id="kobo.189.1"> in this method to emit a value every 5 seconds. </span><span class="koboSpan" id="kobo.189.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">timer</span></strong><span class="koboSpan" id="kobo.191.1"> produces an endless stream, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">take</span></strong><span class="koboSpan" id="kobo.193.1"> operator to return the first three emissions and complete them. </span><span class="koboSpan" id="kobo.193.2">Then, for every emission, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">switchMap</span></strong><span class="koboSpan" id="kobo.195.1"> operator to return an Observable that emits three </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">values consecutively.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">This is tricky, right? </span><span class="koboSpan" id="kobo.197.2">If we </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.198.1">use the subscribe and assert pattern here, the tests would be very complicated and may take a lot of time, depending on the value that’s passed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">timer</span></strong><span class="koboSpan" id="kobo.200.1">. </span><span class="koboSpan" id="kobo.200.2">However, the unit tests should be fast </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">and reliable.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">In this case, having a virtual timer can be beneficial. </span><span class="koboSpan" id="kobo.202.2">A virtual timer refers to a simulated passage of time controlled by the testing framework. </span><span class="koboSpan" id="kobo.202.3">Instead of waiting for actual time to pass, which could lead to slow and unreliable tests, the virtual timer allows testers to control time programmatically. </span><span class="koboSpan" id="kobo.202.4">This means they can advance time forward or backward as needed to trigger certain events or test scenarios, making it easier to write reliable and deterministic tests for code that depends on time-based behavior. </span><span class="koboSpan" id="kobo.202.5">This approach ensures that tests are fast, predictable, and independent of </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">real-time conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">So, in a nutshell, the subscribe and assert pattern is a valid and easy technique that most developers adopt. </span><span class="koboSpan" id="kobo.204.2">However, it has </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.205.1">some drawbacks that I pointed out throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">this section:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.207.1">We need to remember to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">done</span></strong><span class="koboSpan" id="kobo.209.1"> callback in asynchronous tests; otherwise, the tests will return </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">invalid results.</span></span></li>
<li><span class="koboSpan" id="kobo.211.1">In some scenarios, we end up with boiled tests and unwanted </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">testing logic.</span></span></li>
<li><span class="koboSpan" id="kobo.213.1">Timed Observables are very complicated </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">to test.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.215.1">Now, let’s explore another approach for testing Observables: marble testing with RxJS </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">testing utilities.</span></span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.217.1">Learning about the marble testing pattern</span></h1>
<p><span class="koboSpan" id="kobo.218.1">Marble diagrams </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.219.1">are very useful for visualizing Observable execution. </span><span class="koboSpan" id="kobo.219.2">You will already know this, as we introduced marble diagrams back in </span><a href="B21180_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.220.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.221.1">, </span><em class="italic"><span class="koboSpan" id="kobo.222.1">Diving into the Reactive Paradigm</span></em><span class="koboSpan" id="kobo.223.1">, and we’ve used them in almost all the reactive patterns we’ve implemented in this book. </span><span class="koboSpan" id="kobo.223.2">They are simple to understand and delightful to read. </span><span class="koboSpan" id="kobo.223.3">So, why not also use them in code? </span><span class="koboSpan" id="kobo.223.4">What you will be surprised to know is that RxJS introduced marble testing as an intuitive and clean way to </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">test Observables.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Let’s discover what marble testing is about. </span><span class="koboSpan" id="kobo.225.2">We will start by explaining the syntax in the next section and then learn how we can write marble tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">our code.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.227.1">Understanding the syntax</span></h2>
<p><span class="koboSpan" id="kobo.228.1">To understand the syntax, we should</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.229.1"> know about the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">following semantics:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.231.1">Character</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.232.1">Meaning</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">' '</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.234.1">This represents a special character that will not be interpreted. </span><span class="koboSpan" id="kobo.234.2">It can be used to align your </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">marble string.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">'-'</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.237.1">This represents a frame of virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">time passing.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">'|'</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.240.1">This represents the completion of </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">an Observable.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">[</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">a-z]</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.244.1">This represents a value that is emitted by an Observable. </span><span class="koboSpan" id="kobo.244.2">It is an </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">alphanumeric character.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">'#'</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.247.1">This represents </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">an error.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">'()'</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.250.1">This represents a group of events that occur in the same frame. </span><span class="koboSpan" id="kobo.250.2">It can be used to group any values emitted, errors, </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">and completion.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">'^'</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.253.1">This represents the subscription point and will only be used when you’re dealing with </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">hot Observables.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">[</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">0-9]+[ms|s|m]</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.257.1">This represents time progression and allows you to progress virtual time by a specific amount. </span><span class="koboSpan" id="kobo.257.2">It’s a number, followed by a time unit in </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">milliseconds</span></strong><span class="koboSpan" id="kobo.259.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.260.1">ms</span></strong><span class="koboSpan" id="kobo.261.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.262.1">seconds</span></strong><span class="koboSpan" id="kobo.263.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.264.1">s</span></strong><span class="koboSpan" id="kobo.265.1">), or </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">minutes</span></strong><span class="koboSpan" id="kobo.267.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.268.1">m</span></strong><span class="koboSpan" id="kobo.269.1">) without any space </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">between them.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.271.1">Figure 13.2 – Marble testing syntax</span></p>
<p><span class="koboSpan" id="kobo.272.1">This is the basic syntax. </span><span class="koboSpan" id="kobo.272.2">Let’s look at </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.273.1">some examples to practice </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">the syntax:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">---</span></strong><span class="koboSpan" id="kobo.276.1">: This represents an Observable that </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">never emits.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">-x--y--z|</span></strong><span class="koboSpan" id="kobo.279.1">: This represents an Observable that emits </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">x</span></strong><span class="koboSpan" id="kobo.281.1"> on the first frame, </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">y</span></strong><span class="koboSpan" id="kobo.283.1"> on the fourth, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">z</span></strong><span class="koboSpan" id="kobo.285.1"> on the seventh. </span><span class="koboSpan" id="kobo.285.2">After emitting </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">z</span></strong><span class="koboSpan" id="kobo.287.1">, the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">Observable completes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">--xy--#</span></strong><span class="koboSpan" id="kobo.290.1">: This represents an Observable that emits </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">x</span></strong><span class="koboSpan" id="kobo.292.1"> on frame two, </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">y</span></strong><span class="koboSpan" id="kobo.294.1"> on frame three, and an error on </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">frame six.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">-x^(yz)--|</span></strong><span class="koboSpan" id="kobo.297.1">: This is a hot Observable that emits </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">x</span></strong><span class="koboSpan" id="kobo.299.1"> before </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">the subscription.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.301.1">You’ve got the idea, right? </span><span class="koboSpan" id="kobo.301.2">Now, let’s learn how to implement marble tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">our code.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.303.1">Introducing TestScheduler</span></h2>
<p><span class="koboSpan" id="kobo.304.1">There are different packages out there that can help you write marble</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.305.1"> tests, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">jasmine-marbles</span></strong><span class="koboSpan" id="kobo.307.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">jest-marbles</span></strong><span class="koboSpan" id="kobo.309.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">rxjs-marbles</span></strong><span class="koboSpan" id="kobo.311.1">. </span><span class="koboSpan" id="kobo.311.2">However, RxJS provides </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.312.1">testing utilities out of the box, and all the libraries are just wrappers around the RxJS testing utilities. </span><span class="koboSpan" id="kobo.312.2">I recommend working with the RxJS utilities for the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">following reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.314.1">You don’t have to include a </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">third-party dependency</span></span></li>
<li><span class="koboSpan" id="kobo.316.1">You stay up to date with the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">core implementation</span></span></li>
<li><span class="koboSpan" id="kobo.318.1">You stay up to date with the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">latest features</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.320.1">The RxJS API that’s provided for testing is based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">TestScheduler</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">This API allows you to test time-dependent RxJS code in a controlled and deterministic manner, which is crucial for writing reliable and predictable tests for Observables with </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">time-based operators.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">To define our test logic, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">TestScheduler</span></strong><span class="koboSpan" id="kobo.326.1"> API provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">run</span></strong><span class="koboSpan" id="kobo.328.1"> method that has the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">following signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
run&lt;T&gt;(callback: (helpers: RunHelpers) =&gt; T): T;</span></pre> <p><span class="koboSpan" id="kobo.331.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">run</span></strong><span class="koboSpan" id="kobo.333.1"> method takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">callback</span></strong><span class="koboSpan" id="kobo.335.1"> function as an argument. </span><span class="koboSpan" id="kobo.335.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">callback</span></strong><span class="koboSpan" id="kobo.337.1"> function is where you define your test logic, including setting up Observables, defining expectations, and making assertions. </span><span class="koboSpan" id="kobo.337.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">callback</span></strong><span class="koboSpan" id="kobo.339.1"> function takes one argument named </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">helpers</span></strong><span class="koboSpan" id="kobo.341.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">RunHelpers</span></strong><span class="koboSpan" id="kobo.343.1">, which provides various utility functions and properties to assist you in writing marble tests </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">for Observables.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">RunHelpers</span></strong><span class="koboSpan" id="kobo.347.1"> interface contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">following properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
    export interface RunHelpers {
    cold: typeof TestScheduler.prototype.
</span><span class="koboSpan" id="kobo.349.2">    createColdObservable;
    hot: typeof TestScheduler.prototype.
</span><span class="koboSpan" id="kobo.349.3">    createHotObservable;
    flush: typeof TestScheduler.prototype.flush;
    expectObservable: typeof TestScheduler.
</span><span class="koboSpan" id="kobo.349.4">    prototype.expectObservable;
    expectSubscriptions: typeof TestScheduler.
</span><span class="koboSpan" id="kobo.349.5">    prototype.expectSubscriptions;
}</span></pre> <p><span class="koboSpan" id="kobo.350.1">Let’s look at </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.351.1">these properties one </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">by one:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">cold</span></strong><span class="koboSpan" id="kobo.354.1">: This produces a cold Observable based on a given marble diagram. </span><span class="koboSpan" id="kobo.354.2">Here is the signature of </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">the method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
/**
    * @param marbles A diagram in the marble DSL.
</span><span class="koboSpan" id="kobo.356.2">      Letters map to keys in `values` if provided.
</span><span class="koboSpan" id="kobo.356.3">    * @param values Values to use for the letters in
      `marbles`. </span><span class="koboSpan" id="kobo.356.4">If ommitted, the letters themselves
      are used.
</span><span class="koboSpan" id="kobo.356.5">    * @param error The error to use for the `#`
      marble (if present).
</span><span class="koboSpan" id="kobo.356.6">    */
createColdObservable&lt;T = string&gt;(marbles: string,
values?: {
        [marble: string]: T;
    }, error?: any): ColdObservable&lt;T&gt;;</span></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">hot</span></strong><span class="koboSpan" id="kobo.358.1">: This produces a hot Observable based on a given marble diagram. </span><span class="koboSpan" id="kobo.358.2">Here is the signature of </span><a id="_idIndexMarker564"/><span class="No-Break"><span class="koboSpan" id="kobo.359.1">the method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
/**
    * @param marbles A diagram in the marble DSL.
</span><span class="koboSpan" id="kobo.360.2">      Letters map to keys in `values` if provided.
</span><span class="koboSpan" id="kobo.360.3">    * @param values Values to use for the letters in
      `marbles`. </span><span class="koboSpan" id="kobo.360.4">If ommitted, the letters themselves
      are used.
</span><span class="koboSpan" id="kobo.360.5">    * @param error The error to use for the `#`
      marble (if present).
</span><span class="koboSpan" id="kobo.360.6">    */
createHotObservable&lt;T = string&gt;(marbles: string,
values?: {
        [marble: string]: T;
    }, error?: any): HotObservable&lt;T&gt;;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.361.1">When you’re creating a hot Observable, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">^</span></strong><span class="koboSpan" id="kobo.363.1"> to point out the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">first frame:</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">flush</span></strong><span class="koboSpan" id="kobo.366.1">: This starts virtual time. </span><span class="koboSpan" id="kobo.366.2">It’s only needed if you use helpers outside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">run</span></strong><span class="koboSpan" id="kobo.368.1"> callback or if you want to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">flush</span></strong><span class="koboSpan" id="kobo.370.1"> more </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">than once.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">expectObservable</span></strong><span class="koboSpan" id="kobo.373.1">: This asserts that an Observable matches a </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">marble diagram.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">expectSubscriptions</span></strong><span class="koboSpan" id="kobo.376.1">: This asserts that an Observable matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">expected subscriptions.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.378.1">Now, let’s learn how we can implement marble testing using </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">TestScheduler</span></strong><span class="koboSpan" id="kobo.380.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">following section.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.382.1">Implementing marble tests</span></h2>
<p><span class="koboSpan" id="kobo.383.1">In this section, we will consider implementing marble tests for the</span><a id="_idIndexMarker565"/> <strong class="source-inline"><span class="koboSpan" id="kobo.384.1">getValues</span></strong><span class="koboSpan" id="kobo.385.1"> method previously mentioned in the subscribe and </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">assert pattern:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
export class SampleService {
  getValues(): Observable&lt;String&gt; {
    return of('Hello', 'Packt', 'Readers');
  }
}</span></pre> <p><span class="koboSpan" id="kobo.388.1">The steps for writing the marble testing implementation pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">are simple:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.390.1">Import </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">TestScheduler</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.392.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">rxjs/testing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.395.1">
import { TestScheduler } from 'rxjs/testing';</span></pre></li> <li><span class="koboSpan" id="kobo.396.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">beforeEach</span></strong><span class="koboSpan" id="kobo.398.1"> statement, inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">SampleService</span></strong><span class="koboSpan" id="kobo.400.1">. </span><span class="koboSpan" id="kobo.400.2">Then, instantiate </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">TestScheduler</span></strong><span class="koboSpan" id="kobo.402.1"> and pass an input function that compares the actual output with the expected output of </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the Observable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.404.1">
import { TestScheduler } from 'rxjs/testing';
describe('Service: SampleService', () =&gt; {
  let scheduler : TestScheduler;
  let service: SampleService;
  beforeEach(() =&gt; {
      service = TestBed.inject(SampleService);
      scheduler = new TestScheduler((actual, expected) =&gt; {
      expect(actual).toEqual(expected);
    });
  });
});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.405.1">If the expected output and actual output are not equal, it throws an error, failing </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">the test.</span></span></p></li> <li><span class="koboSpan" id="kobo.407.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">TestScheduler</span></strong><span class="koboSpan" id="kobo.409.1"> to test your stream by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">run</span></strong><span class="koboSpan" id="kobo.411.1"> method and passing a callback to it (remember that the callback needs to accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">RunHelpers</span></strong><span class="koboSpan" id="kobo.413.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">first parameter):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.415.1">
it('should return values in the right order', () =&gt; {
  scheduler.run((helpers) =&gt; {
  });
});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.416.1">It is also useful to destruct the helpers into variables and use them directly to implement the marble tests. </span><span class="koboSpan" id="kobo.416.2">We will be destructuring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">expectObservable</span></strong><span class="koboSpan" id="kobo.418.1"> variable, as we will use it to assert that the Observable matches the marble diagram, </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.420.1">it('should return values in the right order', () =&gt; {
  scheduler.run(({expectObservable}) =&gt; {
  });
});</span></pre></li> <li><span class="koboSpan" id="kobo.421.1">Finally, declare the expected marble and values and perform </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">the expectation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.423.1">
it('should return values in the right order', () =&gt; {
  scheduler.run(({expectObservable}) =&gt; {
  const expectedMarble = '(abc|)' ;
  const expectedValues = {a:'Hello', b:'Packt',
                          c:'Readers'};
  expectObservable(service.getValues()).toBe(
    expectedMarble, expectedValues)
  });
});</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.424.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">expectedMarble</span></strong><span class="koboSpan" id="kobo.426.1"> constant represents the marble diagram. </span><span class="koboSpan" id="kobo.426.2">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">getValues</span></strong><span class="koboSpan" id="kobo.428.1"> method returns three values consecutively, we used parentheses to group the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">a</span></strong><span class="koboSpan" id="kobo.430.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">b</span></strong><span class="koboSpan" id="kobo.432.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">c</span></strong><span class="koboSpan" id="kobo.434.1"> emissions. </span><span class="koboSpan" id="kobo.434.2">The stream then completes, so we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">|</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.436.1">character.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.437.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">expectedValues</span></strong><span class="koboSpan" id="kobo.439.1"> constant represents the values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">a</span></strong><span class="koboSpan" id="kobo.441.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">b</span></strong><span class="koboSpan" id="kobo.443.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">c</span></strong><span class="koboSpan" id="kobo.445.1"> characters that we put in </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">expectedMarble</span></strong><span class="koboSpan" id="kobo.447.1">. </span><span class="koboSpan" id="kobo.447.2">It represents </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">'Hello'</span></strong><span class="koboSpan" id="kobo.449.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">'Packt'</span></strong><span class="koboSpan" id="kobo.451.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">'Readers'</span></strong><span class="koboSpan" id="kobo.453.1">, consecutively, which are nothing but the values that are emitted by the Observable that we want </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">to test.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.455.1">The last instruction is the expectation; we should provide the expected result that our methods should return. </span><span class="koboSpan" id="kobo.455.2">Here, we must use </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">expectObservable</span></strong><span class="koboSpan" id="kobo.457.1">, which takes the Observable we want to test as a parameter and matches it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">expectedMarble</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.459.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">expectedValues</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.462.1">That’s it. </span><span class="koboSpan" id="kobo.462.2">Let’s have a look at the complete </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">test setup:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
describe('SampleService marble tests', () =&gt; {
let scheduler : TestScheduler ;
let service: SampleService;
beforeEach(() =&gt; {
  service = TestBed.inject(SampleService);
  scheduler = new TestScheduler((actual, expected) =&gt; {
  expect(actual).toEqual(expected);
});
});
it('should return values in the right order', () =&gt; {
  scheduler.run(({expectObservable}) =&gt; {
  const expectedMarble = '(abc|)' ;
  const expectedValues = {a:'Hello', b:'Packt',
                          c:'Readers'};
  expectObservable(service.getValues()).toBe(
    expectedMarble, expectedValues)
  });
});
});</span></pre> <p><span class="koboSpan" id="kobo.465.1">When you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">ng test</span></strong><span class="koboSpan" id="kobo.467.1">, this test will pass. </span><span class="koboSpan" id="kobo.467.2">If you enter wrong values in </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">expectedValues</span></strong><span class="koboSpan" id="kobo.469.1">, the test </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">will fail:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.471.1"><img alt="Figure 13.3 – ng test failing" src="image/B21180_13_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">Figure 13.3 – ng test failing</span></p>
<p><span class="koboSpan" id="kobo.473.1">Well, this is cleaner than the subscribe and assert </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">pattern implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">Now, let’s look at a more difficult example and see how we can implement it using </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">marble testing.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.477.1">Testing timed-value output methods</span></h2>
<p><span class="koboSpan" id="kobo.478.1">We will </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.479.1">consider the testing of a timed Observable that was complicated to implement using the subscribe and assert pattern. </span><span class="koboSpan" id="kobo.479.2">Let’s revisit the timer example that we explained earlier in the subscribe and assert </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">pattern section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
  getValues(): Observable&lt;String&gt; {
    return timer(0, 5000).pipe(
      take(3),
      switchMap((result) =&gt; of('Hello', 'Packt',
      'Readers'))
    )
  }</span></pre> <p><span class="koboSpan" id="kobo.482.1">The cool </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">TestScheduler</span></strong><span class="koboSpan" id="kobo.484.1"> feature that can help us </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.485.1">here is </span><strong class="bold"><span class="koboSpan" id="kobo.486.1">virtual time</span></strong><span class="koboSpan" id="kobo.487.1">; this allows us to test asynchronous streams synchronously by virtualizing time and ensuring that the correct items are emitted at the correct time. </span><span class="koboSpan" id="kobo.487.2">Thanks to the time progression syntax, we can advance virtual time by milliseconds (ms), seconds (s), or even minutes (m). </span><span class="koboSpan" id="kobo.487.3">This is extremely useful in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">timed Observables.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">Let’s consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">marble diagram:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
e 999ms (fg) 996ms h 999ms (i|)';</span></pre> <p><span class="koboSpan" id="kobo.492.1">Here, the diagram indicates that </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">e</span></strong><span class="koboSpan" id="kobo.494.1"> is emitted immediately. </span><span class="koboSpan" id="kobo.494.2">Then, after 1 second, </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">f</span></strong><span class="koboSpan" id="kobo.496.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">g</span></strong><span class="koboSpan" id="kobo.498.1"> are emitted. </span><span class="koboSpan" id="kobo.498.2">Then, 1 second later, </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">h</span></strong><span class="koboSpan" id="kobo.500.1"> is emitted, after which </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">I</span></strong><span class="koboSpan" id="kobo.502.1"> is emitted, and the stream </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">finally completes.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">Why use </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">999</span></strong><span class="koboSpan" id="kobo.506.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">996</span></strong><span class="koboSpan" id="kobo.508.1">? </span><span class="koboSpan" id="kobo.508.2">Well, we’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">999</span></strong><span class="koboSpan" id="kobo.510.1"> because </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">e</span></strong><span class="koboSpan" id="kobo.512.1"> takes 1 ms to emit and </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">996</span></strong><span class="koboSpan" id="kobo.514.1"> because the characters in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">(fg)</span></strong><span class="koboSpan" id="kobo.516.1"> group take 1 </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">ms each.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">With all this in mind, the marble tests of </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">getValues</span></strong><span class="koboSpan" id="kobo.520.1"> will look </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
  const expectedMarble ='(abc) 4995ms (abc) 4995ms
    (abc|)' ;</span></pre> <p><span class="koboSpan" id="kobo.523.1">The group of values </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">(abc)</span></strong><span class="koboSpan" id="kobo.525.1"> is emitted every 5 seconds or 5000 ms, and since the characters </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.526.1">are counted inside the group, we put </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">4995ms</span></strong><span class="koboSpan" id="kobo.528.1">. </span><span class="koboSpan" id="kobo.528.2">So, the whole test case will look </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
it('should return values in the right time', () =&gt; {
  scheduler.run(({expectObservable}) =&gt; {
  const expectedMarble ='(abc) 4995ms (abc) 4995ms (abc|)';
  const expectedValues = {a:'Hello', b:'Packt',
                          c:'Readers'};
  expectObservable(service.getValues()).toBe(
    expectedMarble, expectedValues)
  });
});</span></pre> <p><span class="koboSpan" id="kobo.531.1">That’s how we resolved the test of a timed Observable using </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">marble tests.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">Marble testing is extremely powerful </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.534.1">and helpful. </span><span class="koboSpan" id="kobo.534.2">It allows you to test a very high level of detail and complicated things such as concurrency and timed Observables. </span><span class="koboSpan" id="kobo.534.3">It also makes your tests cleaner. </span><span class="koboSpan" id="kobo.534.4">However, it requires you to learn a new syntax, and it is not recommended for testing business logic. </span><span class="koboSpan" id="kobo.534.5">Marble testing was designed for testing operators with </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">arbitrary time.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.536.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.537.1">For more details about </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.538.1">marble testing, you can check out the official docs </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">at </span></span><a href="https://rxjs.dev/guide/testing/marble-testing"><span class="No-Break"><span class="koboSpan" id="kobo.540.1">https://rxjs.dev/guide/testing/marble-testing</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.541.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">Now, let’s highlight a very common pattern for testing </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">business logic.</span></span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.544.1">Highlighting testing streams using HttpClientTestingModule</span></h1>
<p><span class="koboSpan" id="kobo.545.1">Observables</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.546.1"> that are returned from the HTTP client are frequently used in our Angular code, but how can we test those streams? </span><span class="koboSpan" id="kobo.546.2">Let’s look at the pattern we can use to test those Observables. </span><span class="koboSpan" id="kobo.546.3">We will </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.547.1">be shifting our focus away from general testing practices and narrowing our attention specifically to testing our </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">recipe app.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">Consider the following method </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">inside </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">RecipeService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
  saveRecipe(formValue: Recipe): Observable&lt;Recipe&gt; {
    return this.http.post&lt;Recipe&gt;(
      `${BASE_PATH}/recipes`, formValue);
  }</span></pre> <p><span class="koboSpan" id="kobo.554.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">saveRecipe</span></strong><span class="koboSpan" id="kobo.556.1"> method issues an HTTP request and returns an Observable of recipe. </span><span class="koboSpan" id="kobo.556.2">In order to test the output Observable, there is a very useful API that can be used: </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">HttpClientTestingModule</span></strong><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">This API allows us to test HTTP methods that use the HTTP client. </span><span class="koboSpan" id="kobo.558.3">It also allows us to easily mock HTTP requests by providing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">HttpTestingController</span></strong><span class="koboSpan" id="kobo.560.1"> service. </span><span class="koboSpan" id="kobo.560.2">In short, it enables us to mock requests instead of making real API requests to our API backend </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">when testing.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">Let’s see the steps required to</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.563.1"> test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">saveRecipe</span></strong><span class="koboSpan" id="kobo.565.1"> method using </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">HttpClientTestingModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.569.1">Before you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">HttpClientTestingModule</span></strong><span class="koboSpan" id="kobo.571.1">, import and inject it in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">TestBed</span></strong><span class="koboSpan" id="kobo.573.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">beforeEach</span></strong><span class="koboSpan" id="kobo.575.1"> statement, </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">as follows:</span></span><pre class="source-code">
<a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.577.1">import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule} from '@angular/common/http/testing';
describe('RecipesService', () =&gt; {
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
    });
  });
});</span></pre></li> <li><span class="koboSpan" id="kobo.578.1">Then, import and inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">HttpTestingController</span></strong><span class="koboSpan" id="kobo.580.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">RecipesService</span></strong><span class="koboSpan" id="kobo.582.1"> and </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.583.1">provide a </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.584.1">shared instance of each to use in </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">our tests:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.586.1">
import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { RecipesService } from './recipes.service';
describe('RecipesService', () =&gt; {
  let service: RecipesService;
  let httpTestingController: HttpTestingController;
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [RecipesService]
    });
    httpTestingController =
      TestBed.inject(HttpTestingController)
    service = TestBed.inject(RecipesService)
  });
});</span></pre></li> <li><span class="koboSpan" id="kobo.587.1">Next, implement </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.588.1">the</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.589.1"> test case of saving the recipe. </span><span class="koboSpan" id="kobo.589.2">We’ll mock </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">saveRecipe</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.591.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.592.1">
  it('should save recipe from API', () =&gt; {
    const recipeToSave : Recipe= {
      "id": 9,
      "title": "Lemon cake",
      "prepTime": 10,
      "cookingTime": 35,
      "rating": 3,
      "imageUrl": "lemon-cake.jpg"
    }
    const subscription =
    service.saveRecipe(recipeToSave)
      .subscribe(_recipe =&gt; {
        expect(recipeToSave).toEqual(_recipe, 'should
        check mock data')
      });
    const req = httpTestingController.expectOne(
      `/api/recipes`);
    req.flush(recipeToSave);
    subscription.unsubscribe();
  });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.593.1">Here, we </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.594.1">created a constant called </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">recipeToSave</span></strong><span class="koboSpan" id="kobo.596.1">, which represents a mocked recipe that we will post to the server to be saved. </span><span class="koboSpan" id="kobo.596.2">Then, we subscribed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">saveRecipe</span></strong><span class="koboSpan" id="kobo.598.1"> method and passed </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">recipeToSave</span></strong><span class="koboSpan" id="kobo.600.1"> to it as a parameter. </span><span class="koboSpan" id="kobo.600.2">Inside the subscription, we defined our expectations. </span><span class="koboSpan" id="kobo.600.3">Then, we called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">expectOne</span></strong><span class="koboSpan" id="kobo.602.1"> method, which expects a single request that’s been made to match a given URL (in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">/api/recipes</span></strong><span class="koboSpan" id="kobo.604.1">) and returns mock data using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">flush</span></strong><span class="koboSpan" id="kobo.606.1"> method, which resolves the request by returning a mocked body. </span><span class="koboSpan" id="kobo.606.2">Finally, we released </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">the subscription.</span></span></p></li> <li><span class="koboSpan" id="kobo.608.1">The</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.609.1"> last step is to add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">afterEach()</span></strong><span class="koboSpan" id="kobo.611.1"> block, in which we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">verify</span></strong><span class="koboSpan" id="kobo.613.1"> method of </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">our controller:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.615.1">
  afterEach(() =&gt; {
    httpTestingController.verify();
  });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.616.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">verify()</span></strong><span class="koboSpan" id="kobo.618.1"> method ensures that there are no outstanding HTTP requests that have not been handled or flushed. </span><span class="koboSpan" id="kobo.618.2">When you make HTTP requests in your tests using </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">HttpClientTestingModule</span></strong><span class="koboSpan" id="kobo.620.1">, they are intercepted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">httpTestingController</span></strong><span class="koboSpan" id="kobo.622.1"> instead of being sent over the network. </span><span class="koboSpan" id="kobo.622.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">verify()</span></strong><span class="koboSpan" id="kobo.624.1"> method ensures that all requests have been properly handled and allows your tests to pass only if there are no pending </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">requests remaining.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.626.1">In summary, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">afterEach()</span></strong><span class="koboSpan" id="kobo.628.1"> block with </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">httpTestingController.verify()</span></strong><span class="koboSpan" id="kobo.630.1"> is used in Angular tests to clean up and verify that there are no unhandled HTTP requests left over after each test case. </span><span class="koboSpan" id="kobo.630.2">This helps ensure that your tests are isolated and reliable, without unexpected </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">network interactions.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.632.1">And that’s it; the pattern for testing methods that issue HTTP requests is complete. </span><span class="koboSpan" id="kobo.632.2">Just run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">ng test</span></strong><span class="koboSpan" id="kobo.634.1"> command </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.635.1">and</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.636.1"> ensure everything </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">works fine.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.638.1">Note</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">HttpClientTestingModule</span></strong><span class="koboSpan" id="kobo.640.1"> is very </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.641.1">useful in this use case. </span><span class="koboSpan" id="kobo.641.2">For more details, please refer to </span><a href="https://angular.dev/guide/testing/services#httpclienttestingmodule"><span class="No-Break"><span class="koboSpan" id="kobo.642.1">https://angular.dev/guide/testing/services#httpclienttestingmodule</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.643.1">.</span></span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.644.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.645.1">In this chapter, I’ve elucidated three common approaches for testing Observables in RxJS and Angular. </span><span class="koboSpan" id="kobo.645.2">Each solution has its strengths and weaknesses, and there is no </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">one-size-fits-all answer.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">First, we learned about the subscribe and assert pattern, as well as its advantages and drawbacks. </span><span class="koboSpan" id="kobo.647.2">This pattern is straightforward to understand but may not cover all edge cases, especially when dealing with complex </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">asynchronous behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Then, we learned about the marble testing pattern and its syntax, features, advantages, and drawbacks. </span><span class="koboSpan" id="kobo.649.2">We studied a basic example and an example that uses virtual time to test timed Observables. </span><span class="koboSpan" id="kobo.649.3">Marble testing provides a visual representation of Observable behavior; it is suitable for testing complex asynchronous scenarios. </span><span class="koboSpan" id="kobo.649.4">However, it requires special syntax, meaning it may have a steep learning curve </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">for beginners.</span></span></p>
<p><span class="koboSpan" id="kobo.651.1">Finally, we learned about a pattern that we can use to test streams that are returned from the HTTP client. </span><span class="koboSpan" id="kobo.651.2">This pattern provides control over responses and doesn’t rely on external APIs. </span><span class="koboSpan" id="kobo.651.3">However, it can be tedious to set up and maintain and may not accurately simulate real-world network behavior in </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">some cases.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">In conclusion, each testing approach offers its advantages and trade-offs. </span><span class="koboSpan" id="kobo.653.2">Depending on your project requirements, you can choose the solution that aligns best with your testing needs and </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">project constraints.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">At this point, our journey into reactive patterns is coming to an end. </span><span class="koboSpan" id="kobo.655.2">In this book, I tried to highlight the most used reactive patterns that solve a lot of recurrent use cases in web applications. </span><span class="koboSpan" id="kobo.655.3">You can use them immediately in your current projects, adapt them to your needs, or get inspired to create your own </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">reactive pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">This book is not just about patterns, though; it is also about the reactive approach and how to switch your mindset from imperative to reactive thinking; in most chapters, this is why I’ve highlighted the classic pattern before the reactive one to provide you with a smooth transition between </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">the two.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">And with that, we reach the end of our journey together. </span><span class="koboSpan" id="kobo.659.2">Thank you for reading and embarking on this reactive adventure </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">with me!</span></span></p>
</div>
</body></html>