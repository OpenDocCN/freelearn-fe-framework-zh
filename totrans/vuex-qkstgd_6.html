<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using the Vuex Plugin System</h1>
                </header>
            
            <article>
                
<p class="mce-root">In previous chapters, I wrote about the possibility of persisting the <em>EveryNote</em> application state, using the Vuex plugin system. We also learned about a built-in logger plugin to log every mutation. But, what exactly is a Vuex plugin? And how can we write a custom plugin?</p>
<p>In the following pages, you will:</p>
<ul>
<li>Learn about the Vuex plugin system</li>
<li>Add two useful plugins to the <em>EveryNote</em> application</li>
<li>Write a Google Analytics plugin to track user interaction with your app</li>
<li>Develop an undo/redo plugin</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have Node.js installed on a system. <span>Finally, to use the Git repository of this book, the user needs to install Git. </span></p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6" target="_blank">https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6</a><br/>
<a href="https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6-promises" target="_blank">https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-6-promises</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/aZjE63" target="_blank">https://goo.gl/aZjE63</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the Vuex plugin system</h1>
                </header>
            
            <article>
                
<p>A Vuex plugin is a function that receives the application store as the only argument and can subscribe to mutations.</p>
<p>The following is an example of a plugin:</p>
<pre>const consolePlugin = (store) =&gt; {<br/>store.subscribe((mutation, state) =&gt; {<br/>    // called after every mutation.<br/>    // The mutation comes in the format of { type, payload }.<br/>    console.log(mutation, state);<br/>  });<br/>};</pre>
<p>You can add a plugin to the store as follows:</p>
<pre>const store = new Vuex.Store({<br/>  // ...<br/>  plugins: [consolePlugin]<br/>});</pre>
<p>Like components, plugins cannot <span>directly </span>alter the state; they have to commit a mutation.</p>
<p>For example, imagine that we want to show the last time a mutation has been committed. We could write a plugin as follows:</p>
<pre>// src/store/plugins.js<br/>// ...<br/>const lastEditDate = (store) =&gt; {<br/>  store.subscribe((mutation) =&gt; {<br/>    if (mutation.type !== types.UPDATE_LAST_EDIT_DATE) {<br/>      store.commit(types.UPDATE_LAST_EDIT_DATE);<br/>    }<br/>  });<br/>};</pre>
<p>Since we can subscribe to every mutation receiving the new state, we could persist the application state with <kbd>localStorage</kbd>. In fact, there is a plugin called <kbd>vuex-persistedstate</kbd> that does exactly that. You can read more about this plugin in the following pages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Empowering EveryNote with two plugins</h1>
                </header>
            
            <article>
                
<p>If you Google <em>Vuex plugins,</em> you may find various plugins for different purposes. I selected two that you will probably want to use in your next Vuex project. These plugins are:</p>
<ul>
<li>vuex-persistedstate</li>
<li>vuex-router-sync</li>
</ul>
<p>We are going to use the first one to save the EveryNote state with <kbd>localStorage,</kbd> so that we don't lose all the notes every time the browser page is reloaded.</p>
<p><span>It is strongly recommended that you use the s</span>econd one, vuex-router-sync, if you are creating a single-page web application. In this case, you are already using vue-router and vuex-router-sync will synchronize the current route, as part of Vuex store's state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving the app state with vuex-persistedstate</h1>
                </header>
            
            <article>
                
<p>The <em>EveryNote</em> application currently  shows two fake notes and loses newly created notes every time you reload the page. By adding<em> </em>the<em> </em><kbd>vuex-persistedstate</kbd> plugin, notes will be saved with <kbd>localStorage</kbd>.</p>
<p>To add the <kbd>vuex-persistedstate</kbd> type, enter the following<em>:</em></p>
<pre><strong>npm install --save vuex-persistedstate</strong></pre>
<p>After that, we need to add it to the plugins list:</p>
<pre>// src/store/index.js<br/>// ...<br/><strong>import createPersistedState from 'vuex-persistedstate';</strong><br/>// ...<br/><br/><strong>plugins.push(createPersistedState());</strong><br/>const store = new Vuex.Store({<br/>  state: {<br/>   // ...<br/>  },<br/>  mutations,<br/>  actions,<br/>  strict: debug,<br/>  <strong>plugins</strong>,<br/>});</pre>
<p>Finally, we need to remove the two fake notes from the mock API:</p>
<pre>// src/api/api-mock.js<br/>export default {<br/>  fetchAllNotes() {<br/>    <strong>return Promise.resolve([]);</strong><br/>  },<br/>};</pre>
<p>From now on, if you add a note and then reload the page, that note will still be there.</p>
<p><kbd>vuex-persistedstate</kbd><span> is highly configurable and can persist the application state to every synchronous storage. For example, you can configure it to use <kbd>sessionStorage,</kbd> instead of <kbd>localStorage,</kbd>if you want the state to be reset when the application page is closed.</span></p>
<p>You can find more information at: <a href="https://github.com/robinvdvleuten/vuex-persistedstate" target="_blank">https://github.com/robinvdvleuten/vuex-persistedstate</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Synchronizing router data with vuex-router-sync</h1>
                </header>
            
            <article>
                
<p><span>If you are using vue-router in your application, you may also want to use vuex-router-sync because, as it says on the plugin website, <em>it </em></span><em>syncs vue-router's current $route as part of vuex store's state.</em></p>
<p>To install this plugin, type:</p>
<pre><strong>npm install vuex-router-sync --save</strong></pre>
<p>To add it to the <em>EveryNote</em> app, you need to add vue-router to the project:</p>
<pre><strong>npm install vue-router --save</strong></pre>
<p>and modify <kbd>src/store/index.js</kbd> as follows:</p>
<pre>// src/store/index.js<br/><strong>import { sync } from 'vuex-router-sync';</strong><br/>// ...<br/><br/>const store = new Vuex.Store({<br/>  state: {<br/>   // ...<br/>  },<br/>  mutations,<br/>  actions,<br/>  strict: debug,<br/>  plugins,<br/>});<br/><br/><strong>sync(store, router);</strong><br/>// ...</pre>
<p>But how does it work? Each time the route changes, this plugin updates the <kbd>store.state.route</kbd> property. This property consists of:</p>
<pre>store.state.route.path // current path (string)<br/>store.state.route.params // current params (object)<br/>store.state.route.query // current query (object)</pre>
<p>To update the store property, it commits a <kbd><span>route.ROUTE_CHANGED</span></kbd> mutation, where <kbd>route</kbd> is the default name of the module of the vuex-router-sync<em> </em>plugin.</p>
<p>You can change the module name it uses as follows:</p>
<pre><span class="pl-en">sync</span>(store, router, { moduleName<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>CustomRouteSyncModule<span class="pl-pds">'</span></span> } );</pre>
<p>In order to programmatically change a route, use vue-router; do not modify <kbd>store.state.route</kbd>.</p>
<p>You can find more information at: <a href="https://github.com/vuejs/vuex-router-sync">https://github.com/vuejs/vuex-router-sync</a>.</p>
<p>In the following pages, we are going to develop a Google Analytics plugin that uses vuex-router-sync to send page-views to Google servers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a Google Analytics plugin</h1>
                </header>
            
            <article>
                
<p>In the following pages, I will assume that you are familiar with Google Analytics and that you have correctly configured Google Analytics tracking in your application. If not, you can Google it, understand how it works, and come back here. A basic understanding is more than enough to proceed with the following pages. </p>
<p>The first step is to add this Google Analytics tracking code snippet to the <kbd>index.html</kbd> file:</p>
<pre>&lt;!-- index.html --&gt;<br/><br/>&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;<br/>&lt;script async src="https://www.googletagmanager.com/gtag/js?id=GA_TRACKING_ID"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>  window.dataLayer = window.dataLayer || [];<br/>  function gtag(){dataLayer.push(arguments);}<br/>  gtag('js', new Date());<br/><br/>  gtag('config', 'GA_TRACKING_ID');<br/>&lt;/script&gt;</pre>
<p>After that, a global <kbd>gtag(...)</kbd> function will be available to send events to Google Analytics servers.</p>
<p>Typically, an application tracks page views and some events. To send an event to Google Analytics servers, it is enough to write:</p>
<pre>gtag('event', 'MUTATION_NAME');</pre>
<p>Using the preceding code, we can write a plugin that sends an Analytics event for each mutation, as follows:</p>
<pre>// src/store/plugins.js<br/>// ...<br/>export const <strong>googleAnalytics</strong> = (store) =&gt; {<br/>  store.subscribe((mutation) =&gt; {<br/>    <strong>gtag('event', mutation.type)</strong>;<br/>  });<br/>};</pre>
<p>In order to send page views, we can exploit the vuex-router-sync<em> </em><kbd>route.ROUTE_CHANGED</kbd> mutation committed every time the location changes.</p>
<p>We can update the Analytics plugin accordingly, as follows:</p>
<pre><span>// src/store/plugins.js<br/>import analytics from '../gtag';<br/>// ...<br/>export const </span><span>googleAnalytics </span>= (store) =&gt; {<br/>  store.<span>subscribe</span>((mutation<span>, </span>state) =&gt; {<br/>    <span>if </span>(<strong>mutation.type === 'route/ROUTE_CHANGED'</strong>) {<br/>      analytics.<span>sendPageView</span>(state.route.path)<span>;<br/></span><span>    </span>} <span>else </span>{<br/>      analytics.<span>sendEvent</span>(mutation.type)<span>;<br/></span><span>    </span>}<br/>  })<span>;<br/></span>}<span>;</span></pre>
<p>Where the <kbd>analytics</kbd> object is something like:</p>
<pre>// src/gtag/index.js<br/>const GA_TRACKING_ID = 'GA_TRACKING_ID';<br/><br/>class GtagAnalytics {<br/>  static sendEvent(action) {<br/>    gtag('event', action);<br/>  }<br/><br/>  static sendPageView(pagePath) {<br/>    gtag('config', GA_TRACKING_ID, { page_path: pagePath });<br/>  }<br/>}<br/><br/>export default GtagAnalytics;</pre>
<p>You probably do not want to send all mutations as analytics events; in that case, you can create a map of mutation types that you want to send, or a list of mutation types you don't want to be sent.</p>
<p>You can download the EveryNote code with the Google Analytics plugin by typing:</p>
<pre>git checkout chapter-5/step-7_google-analytics-plugin</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing an undo/redo plugin</h1>
                </header>
            
            <article>
                
<p>The Google Analytics plugin we just coded is a good and simple example of how the Vuex plugin system can be exploited to add features to your application, without touching the application core code. But what about a more complex plugin? Is the Vuex plugin also suited for more complex operations? Well, of course, it is! In the following pages, we will develop an undo/redo plugin, which is still a simple, but not trivial example.</p>
<p>We can exploit the fact that, in using the Vuex system, we have a single centralized state and this state can only be modified by mutations. The idea is to take a snapshot of the state each time it gets modified. Then, to go back in the mutation history, it is enough to set the current state to a snapshot, representing an older state before the mutation occurred.</p>
<p>Let's start by creating a plugin that registers a module called <kbd>undoRedo</kbd>:</p>
<pre>store.registerModule(moduleName, {<br/>  namespaced: true,<br/>  getters: {<br/>    canUndo() {}, // Tells if undo can be performed<br/>    canRedo() {}, // Tells if redo can be performed<br/>  },<br/>  state: {<br/>    <strong>currentPosition</strong>: 0, // Position in the history<br/>    <strong>snapshots</strong>: [], // Snapshots taken<br/>  },<br/>  mutations: {<br/>    [UNDO]() {}, // Mutation to undo last mutation<br/>    [REDO](state) {}, // Mutation to redo last mutation<br/>    [UPDATE_CURRENT_POSITION](){},//update currentPosition<br/>    [UPDATE_SNAPSHOTS](){}, //update snapshots <br/>  },<br/>});</pre>
<p>In the preceding code, we define two state properties:</p>
<ul>
<li><strong>currentPosition</strong>: This represents the index of the current snapshot. When an undo mutation is committed, we decrease the index; when a redo mutation or another one is committed, the index is increased.</li>
<li><strong>snapshots</strong>: This is an array containing state snapshots.</li>
</ul>
<p>After that, we need two corresponding mutations to update these properties, as well as an <kbd>UNDO</kbd> and a <kbd>REDO</kbd> mutation to actually let plugin clients undo or redo modifications.</p>
<p>Finally, we provide two getters, <kbd>canUndo()</kbd> and <kbd>canRedo(),</kbd> to expose the undoable/redoable state of the plugin.</p>
<p>We can now subscribe to mutations to take a snapshot each time the application state gets changed:</p>
<pre>const undoRedoPlugin = (store) =&gt; {<br/>  function takeStateSnapshot(state) {<br/>    // ...<br/>  }<br/><br/>  function restoreStateSnapshot(state, toRestore) {<br/>    // ...<br/>  }<br/><br/>  <strong>store.subscribe(({ type }, state) =&gt; {</strong><br/>    if (mutationsToExclude[type] === undefined) {<br/>      const index = state[moduleName].currentPosition + 1;<br/>      const snapshots = state[moduleName].snapshots.slice();<br/>      snapshots.length = index + 1;<br/>      snapshots[index] = takeStateSnapshot(state);<br/>      store.commit(currentPositionType, index);<br/>      store.commit(updateSnapshotType, snapshots);<br/>    }<br/>  });<br/><br/>  store.registerModule(moduleName, {<br/>    // ...<br/>  });<br/>};</pre>
<p>Of course, there are mutations that must be excluded, such as mutations of <kbd>snapshots</kbd> or <kbd>currentPosition</kbd> properties, and mutations that a user of this plugin may want to exclude, such as <kbd>route/ROUTE_CHANGED</kbd> if <span>vuex-router-sync is used </span><span>in the application.</span></p>
<p>We can now implement the undo/redo mutations as follows:</p>
<pre>store.registerModule(moduleName, {<br/>  namespaced: true,<br/>  getters: {<br/>    canUndo({ currentPosition }) {<br/>      return currentPosition &gt;= 1;<br/>    },<br/>    canRedo({ currentPosition, snapshots }) {<br/>      return currentPosition &lt; snapshots.length - 1;<br/>    },<br/>  },<br/>  state: {<br/>    currentPosition: 0,<br/>    snapshots: [takeStateSnapshot(store.state)],<br/>  },<br/>  mutations: {<br/>    [UNDO](state) {<br/>      if (store.getters[canUndoGetter]) {<br/>        state.currentPosition--;<br/>        const { snapshots } = state;<br/>        const snapShot = snapshots[state.currentPosition];<br/>        restoreStateSnapshot(store.state, snapShot);<br/>      }<br/>    },<br/>    [REDO](state) {<br/>      if (store.getters[canRedoGetter]) {<br/>        state.currentPosition++;<br/>        const { snapshots } = state;<br/>        const snapShot = snapshots[state.currentPosition];<br/>        restoreStateSnapshot(store.state, snapShot);<br/>      }<br/>    },<br/>    [UPDATE_CURRENT_POSITION](state, value) {<br/>      state.currentPosition = value;<br/>    },<br/>    [UPDATE_SNAPSHOTS](state, value) {<br/>      state.snapshots = value;<br/>    },<br/>  },<br/>});</pre>
<p>As you can see, the preceding code is just about restoring the right snapshot.</p>
<p>When taking a snapshot, not every state property should be considered and each snapshot must be a copy of the state. The following code shows these concepts:</p>
<pre>function <strong>takeStateSnapshot</strong>(state) {<br/>  const toClone = {};<br/>  Object.keys(state).forEach((key) =&gt; {<br/>    if (statePropsToExclude[key] === undefined) {<br/>      toClone[key] = state[key];<br/>    }<br/>  });<br/><br/>  return JSON.stringify(toClone);<br/>}<br/><br/>function <strong>restoreStateSnapshot</strong>(state, toRestore) {<br/>  const clone = JSON.parse(toRestore);<br/>  Object.keys(clone).forEach((key) =&gt; {<br/>    state[key] = clone[key];<br/>  });<br/>}</pre>
<p>Finally, we can provide a factory method to create and configure the undo/redo plugin. The following is the entire plugin code:</p>
<pre>// src/store/undo-redo-plugin.js<br/>export default (options) =&gt; {<br/>  const moduleName = 'undoRedo' || options.moduleName;<br/>  const UNDO = 'undo';<br/>  const REDO = 'redo';<br/>  const UPDATE_CURRENT_POSITION = 'UPDATE_CURRENT_POSITION';<br/>  const UPDATE_SNAPSHOTS = 'UPDATE_SNAPSHOTS';<br/>  const undoType = `${moduleName}/${UNDO}`;<br/>  const redoType = `${moduleName}/${REDO}`;<br/>  const currentPositionType =<br/>    `${moduleName}/${UPDATE_CURRENT_POSITION}`;<br/>  const updateSnapshotType =<br/>    `${moduleName}/${UPDATE_SNAPSHOTS}`;<br/>  const canUndoGetter = `${moduleName}/canUndo`;<br/>  const canRedoGetter = `${moduleName}/canRedo`;<br/><br/>  const statePropsToExclude = {<br/>    [moduleName]: '',<br/>  };<br/>  if (options.statePropsToExclude) {<br/>    options.statePropsToExclude.forEach((toExclude) =&gt; {<br/>      statePropsToExclude[toExclude] = '';<br/>    });<br/>  }<br/><br/>  const mutationsToExclude = {<br/>    [undoType]: '',<br/>    [redoType]: '',<br/>    [currentPositionType]: '',<br/>    [updateSnapshotType]: '',<br/>  };<br/>  if (options.mutationsToExclude) {<br/>    options.mutationsToExclude.forEach((toExclude) =&gt; {<br/>      mutationsToExclude[toExclude] = '';<br/>    });<br/>  }<br/><br/>  const undoRedoPlugin = (store) =&gt; {<br/>    function takeStateSnapshot(state) {<br/>      const toClone = {};<br/>      Object.keys(state).forEach((key) =&gt; {<br/>        if (statePropsToExclude[key] === undefined) {<br/>          toClone[key] = state[key];<br/>        }<br/>      });<br/><br/>      return JSON.stringify(toClone);<br/>    }<br/><br/>    function restoreStateSnapshot(state, toRestore) {<br/>      const clone = JSON.parse(toRestore);<br/>      Object.keys(clone).forEach((key) =&gt; {<br/>        state[key] = clone[key];<br/>      });<br/>    }<br/><br/>    store.subscribe(({ type }, state) =&gt; {<br/>      if (mutationsToExclude[type] === undefined) {<br/>        const index = state[moduleName].currentPosition + 1;<br/>        const snapshots = state[moduleName].snapshots.slice();<br/>        snapshots.length = index + 1;<br/>        snapshots[index] = takeStateSnapshot(state);<br/>        store.commit(currentPositionType, index);<br/>        store.commit(updateSnapshotType, snapshots);<br/>      }<br/>    });<br/><br/>    store.registerModule(moduleName, {<br/>      namespaced: true,<br/>      getters: {<br/>        canUndo({ currentPosition }) {<br/>          return currentPosition &gt;= 1;<br/>        },<br/>        canRedo({ currentPosition, snapshots }) {<br/>          return currentPosition &lt; snapshots.length - 1;<br/>        },<br/>      },<br/>      state: {<br/>        currentPosition: 0,<br/>        snapshots: [takeStateSnapshot(store.state)],<br/>      },<br/>      mutations: {<br/>        [UNDO](state) {<br/>          if (store.getters[canUndoGetter]) {<br/>            state.currentPosition--;<br/>            const { snapshots } = state;<br/>            const snapShot = snapshots[state.currentPosition];<br/>            restoreStateSnapshot(store.state, snapShot);<br/>          }<br/>        },<br/>        [REDO](state) {<br/>          if (store.getters[canRedoGetter]) {<br/>            state.currentPosition++;<br/>            const { snapshots } = state;<br/>            const snapShot = snapshots[state.currentPosition];<br/>            restoreStateSnapshot(store.state, snapShot);<br/>          }<br/>        },<br/>        [UPDATE_CURRENT_POSITION](state, value) {<br/>          state.currentPosition = value;<br/>        },<br/>        [UPDATE_SNAPSHOTS](state, value) {<br/>          state.snapshots = value;<br/>        },<br/>      },<br/>    });<br/>  };<br/><br/>  return undoRedoPlugin;<br/>};</pre>
<p>You can download the EveryNote code with the undo/redo plugin, by typing:</p>
<pre>git checkout chapter-5/step-8_undo-redo-plugin</pre>
<p>Undo/redo, implemented this way, works well with an application that does not synchronize its state with a server. Normally, it is not enough to restore the previous state, but you need also to perform an action to update the server data. For example, if you undo a delete note, you need to send the undeleted note data to the remote server. This means that a real undo/redo feature is application-dependent, and that the plugin we wrote needs to be extended to also handle synchronization with a remote server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with asynchronicity using promises</h1>
                </header>
            
            <article>
                
<p>In a real undo/redo plugin you will probably send data to a server, which is an asynchronous operation. We understood that asynchronicity must be dealt with inside Vuex actions. When you dispatch an action, <kbd><span>store</span><span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'anAction')</span></kbd><span class="token punctuation">, the <kbd>dispatch</kbd> method returns a <kbd>Promise</kbd>. In the following pages I will explain how you can handle asynchronous operations using <kbd>Promise</kbd>, a relatively new JavaScript feature.</span></p>
<p>Dealing with asynchronous operations in JavaScript can be tricky. I have seen incredibly messy pieces of code just because the programmer didn't know how to deal with asynchronous code.</p>
<p>The worst way of waiting for a piece of data that will be available later is polling.<span> </span><em>Never do something like this</em>:</p>
<pre>// Just don't use this way!<br/>let dataFromServer;<br/><br/>// ...<br/><br/>const waitForData = () =&gt; {<br/>    if(dataFromServer !== undefined) {<br/>        doSomethingWith(dataFromServer);<br/>    } else {<br/>        setTimeout(waitForData, 100);<br/>    }<br/>};<br/>setTimeout(waitForData, 100);</pre>
<p>The preceding example can be refactored using a callback:</p>
<pre>api.getDataFromServer((dataFromServer) =&gt; {<br/>    // do something with dataFromServer<br/>});</pre>
<p>Callbacks are good for simple operations, but become quickly unmanageable when you need to combine more than one callback. Have you ever heard of the phrase c<em>allback hell</em>?</p>
<p>Fortunately, JavaScript now provides<span> </span><kbd>Promise</kbd>, a simple way to deal with asynchronous operations. Using a<span> </span><kbd>Promise</kbd>, the preceding code can be rewritten as follows:</p>
<pre>api.getDataFromServer().then(function success(dataFromServer){<br/>    // do something with dataFromServer<br/>}, function fail(error) {<br/>    // Handle the error<br/>});</pre>
<p>If you are not familiar with promises, google and study them. The following sections will explain how promises can be chained or be executed in parallel, which, in my opinion, is still not well understood by programmers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chaining promises</h1>
                </header>
            
            <article>
                
<p>The <kbd>store.dispatch('action')</kbd><span> </span>function returns a promise. This allows the programmer to wait for an action to be completed before executing another one.</p>
<p>Let's see an example where an action is dispatched after another one is completed:</p>
<pre>store.dispatch('action 1').then(() =&gt; {<br/>    return store.dispatch('action 2');<br/>}).then(() =&gt; {<br/>    store.commit('mutation depending on action 1 and 2');<br/>});</pre>
<p>The<span> </span><kbd>then(callback)</kbd><span> </span>method of a<span> </span><kbd>Promise</kbd><span> </span>returns another<span> </span><kbd>Promise</kbd>, which will be resolved with the value returned by the callback. If the value returned by the callback is itself a<span> </span><kbd>Promise</kbd>, it will wait for this second<span> </span><kbd>Promise</kbd><span> </span>to be completed. OK, I knowâ€”the first time you hear it, this concept sounds a bit twisted. I will explain promise concatenation in the following examples:</p>
<pre>// Creates a resolved promise with a return value 'A'<br/>const p1 = Promise.resolve('A'); <br/><br/>console.log('start');<br/>// Chaining promises<br/>p1<br/>  .then(result =&gt; result + 'B')<br/>  .then(result =&gt; asyncEcho(result + 'C')) // wait 1000 ms<br/>  .then(result =&gt; console.log(result))<br/>console.log('end');<br/><br/>function asyncEcho(echoMsg) {<br/>    return new Promise(resolve =&gt; {<br/>        setTimeout(() =&gt; resolve(echoMsg), 1000);<br/>    });<br/>}</pre>
<p>The resulting output is as follows:</p>
<pre><strong>start<br/></strong><strong>end</strong><br/>// after 1000 ms<br/><strong>ABC</strong></pre>
<p>First, the synchronous code gets executed, printing<span> </span><kbd>start</kbd><span> </span>and<span> </span><kbd>end</kbd>, and then the promise chain gets executed. In the middle step of the chain, a promise that is resolved after 1000 ms is returned from the callback. This makes the last <kbd>then(...)</kbd> of the chain wait for the <kbd>asyncEcho(...)</kbd><span> </span>promise to be resolved before it can execute the last callback.</p>
<p>Until the chain promises get resolved, the code execution moves from one<span> </span><kbd>then()</kbd><span> </span>to the other. But what happens when a promise gets rejected? Let's see another example:</p>
<pre>// Creates a resolved promise<br/>const p1 = Promise.resolve(); <br/><br/>// Chaining promises<br/>p1<br/>  .then(() =&gt; {console.log(1); return asyncFail();})<br/>  .then(() =&gt; console.log(2), // success<br/>        () =&gt; console.log('Fail 2')) // fail<br/>  .then(() =&gt; {console.log(3); throw 'An error';}, // success<br/>        () =&gt; console.log('Fail 3')) // fail<br/>  .then(() =&gt; console.log(4), // success<br/>        () =&gt;{console.log('Fail 4');return Promise.reject()}) <br/>  .catch(()=&gt; console.log('Catch called'));<br/><br/>function asyncFail() {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        setTimeout(reject, 1000);<br/>    });<br/>}</pre>
<p>The resulting output is as follows:</p>
<pre><strong>1</strong><br/><strong>Fail 2</strong><br/><strong>3</strong><br/><strong>Fail 4</strong><br/><strong>Catch called</strong></pre>
<p>Did you get the right output? Or did you expect to see<span> </span><em>Fail 3</em><span> </span>after the <em>Fail 2</em><span> </span>line? That is a common mistake. Only if an error occurs inside a callback or a rejected promise is returned is the fail callback of the next step of the chain executed. In all other cases, it is the next success callback that gets executed, even if the fail callback of the previous step was executing.</p>
<p>The following figure explains this concept:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7c34ffc1-5a35-4086-84bd-adc5f6e264f1.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 2.1: Chaining promises</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parallel execution of promises</h1>
                </header>
            
            <article>
                
<p>Now that we know how to chain promises, we also know how to chain Vuex actions since the<span> </span><kbd>store.dispatch(...)</kbd><span> </span>method returns a promise. But what if we want to execute two or more actions in parallel and wait for all of the actions to be completed? The<span> </span><kbd>Promise</kbd><span> </span>object provides a<span> </span><kbd>Promise.all([p1, p2, ..., pn])</kbd><span>method</span><span> </span><span>that returns a promise that is either resolved after all the provided promises are resolved or that is rejected as soon as one of the provided promises is rejected. Let's see an example:</span></p>
<pre>const p1 = asyncEcho('A', 500);<br/>const p2 = asyncEcho('B', 1000);<br/>const e = asyncFail('E1', 100);<br/><br/>Promise.all([p1, p2]).then((values) =&gt; <br/>    console.log('OK', values));<br/><br/>Promise.all([p1, p2, e]).then(() =&gt; {<br/>  console.log('this gets not executed');<br/>}, (error) =&gt; {<br/>  console.log('Err', error);<br/>});<br/><br/>function asyncEcho(echoMsg, delay) {<br/>    return new Promise(resolve =&gt; {<br/>        setTimeout(() =&gt; resolve(echoMsg), delay);<br/>    });<br/>}<br/><br/>function asyncFail(error, delay) {<br/>     return new Promise((resolve, reject) =&gt; {<br/>        setTimeout(() =&gt; reject(error), delay);<br/>    });<br/>}</pre>
<p>The output is as follows:</p>
<pre><strong>Err E1 </strong>// After 100 ms<br/><strong>OK A, B </strong>// After 1000 ms</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common mistakes when using promises</h1>
                </header>
            
            <article>
                
<p>Finally, let's look at the two common mistakes made when using<span> </span><kbd>Promise</kbd>.</p>
<p>The following code shows what happens when a<span> </span><strong><kbd>Promise</kbd></strong><span> </span>constructor callback is misunderstood<strong>:</strong></p>
<pre>console.log(1);<br/>buggyExecuteLater(() =&gt; console.log(3));<br/>console.log(2);<br/><br/>function buggyExecuteLater(callback) {<br/>  new Promise(() =&gt; callback());<br/>}<br/><br/>// Output<br/>// 1<br/>// 3<br/>// 2</pre>
<p>The callback function provided to<span> </span><kbd>new Promise(callback)</kbd><span> </span>is executed synchronously. If you want to schedule something immediately after the current JavaScript execution is completed, use<span> </span><kbd>Promise.resolve().then(callback)</kbd><span> </span>or<span> </span><kbd>setTimeout(callback, 0)</kbd>.</p>
<p>The following code shows what happens when a programmer forgets to return a rejected promise:</p>
<pre>function iMayFail() {<br/>  const rand = Math.random();<br/>  const successP = Promise.resolve();<br/>  const failP = Promise.reject();<br/>  <br/>  return rand &lt; 0.5 ? successP : failP;<br/>}<br/><br/>function buggyToss() {<br/>  return iMayFail().then(<br/>    () =&gt; 'Success', // Success callback<br/>    <strong>() =&gt; 'Fail'</strong> // Fail callback<br/>  );<br/>}<br/><br/>buggyToss().then(<br/>  result =&gt; console.log('Resolved ' + result),<br/>  result =&gt; console.log('Rejected ' + result)<br/>);<br/><br/>// Output is always 'Resolved Fail' or 'Resolved Success'</pre>
<p>No matter what<span> </span><kbd>Math.random()</kbd><span> </span>returns, the output is always<span> </span><span class="packt_screen">Resolved Fail or Resolved Success</span><span> </span>because the<span> </span><kbd>fail</kbd><span> </span>callback of<span> </span><kbd>buggyToss()</kbd> does not throw any error or return a rejected promise. The following is the correct version of <kbd>buggyToss()</kbd>:</p>
<pre>function correctToss() {<br/>  return iMayFail().then(<br/>    () =&gt; 'Success', // Success callback<br/>    () =&gt; <strong>Promise.reject('Fail')</strong> // Fail callback<br/>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at how the Vuex plugin system works, we extended the <em>EveryNote</em> application with two useful plugins, and we developed two plugins from scratch: a Google Analytics plugin and an undo/redo plugin. Furthermore, generally, we saw how the Vuex plugin system can be exploited to add general features to our application without touching the application's core code. </p>
<p>Finally we understood how to deal with asynchronous operations using JavaScript <kbd>Promise</kbd> feature.</p>


            </article>

            
        </section>
    </body></html>