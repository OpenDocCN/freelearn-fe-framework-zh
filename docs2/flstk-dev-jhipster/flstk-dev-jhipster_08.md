# 微服务服务器端技术简介

使用 JHipster 开发一个生产就绪的单体应用不是很容易吗？到目前为止，我们已经从头开始创建了一个应用，使用 JDL Studio 添加了一些实体，然后将其与测试一起部署到生产环境中。我们还添加了持续集成和持续交付管道。这种体验不是更快、更简单、更好吗？

那么，接下来是什么？是的，你猜对了——**微服务**！

微服务现在是到处都在谈论的热门词汇。许多公司都在尝试用微服务来解决他们的问题。我们已经在第一章“现代 Web 应用开发简介”中看到了微服务的好处概述。

在本章中，我们将探讨以下内容：

+   微服务相对于单体应用的好处

+   我们需要构建完整的微服务架构的组件

在本章中，我们将看到我们之前创建的单体应用如何被转换成一个微服务应用。

之后，我们将看到使用 JHipster 提供的选项创建微服务架构是多么容易。

# 微服务应用与单体应用对比

通过与单体架构的比较，可以更好地理解微服务架构的好处。

当它们被正确设计和部署时，微服务相对于单体应用的好处是惊人的。

这并不像根据结构、组件或功能将单体应用拆分，然后作为独立服务部署那么简单。这行不通。将单体应用或甚至单体设计转换为微服务需要一个清晰的产品愿景。这包括了解项目的哪些部分会改变，哪些部分会保持一致。我们必须有低级别的细节，比如我们应该将哪些实体分组在一起，哪些可以分离。

这清楚地说明了需要一个不断发展的模型的需求。拆分应用中使用的技术比拆分相互依赖的模型或应用的业务逻辑要容易得多。因此，将项目的主要重点放在核心领域及其逻辑上至关重要。

微服务应该是独立的。当一个组件与另一个组件紧密耦合时，它们会失败。最棘手的部分是识别和隔离组件。

当我们完成这个任务后，它相对于单体应用有以下好处。

单体代码是一个单一单元。因此，应用的所有部分共享相同的内存。对于更大的系统，我们需要更大的基础设施。当应用增长时，我们需要根据需要扩展基础设施。对已经较大的基础设施进行扩展总是对运营来说既困难又昂贵的任务。

尽管它们在单个地方拥有处理产品中任何事物的所有必要代码（无需担心延迟或可用性），但处理其运行所消耗的资源却很困难，而且肯定不可扩展。如果应用程序的任何一部分失败，整个产品都会受到影响。当产品的任何线程或查询粘附在内存上时，影响将会被数百万客户看到。

相反，微服务由于我们将应用程序拆分为更小的组件，因此运行时所需的内存更少。这反过来又降低了基础设施的成本。例如，运行 10 个 2GB 实例（在 AWS 上的成本约为每月 170 美元）比运行单个 16GB 实例（在 AWS 上的成本约为每月 570 美元）更便宜。每个组件都在自己的环境中运行，这使得微服务对开发者和云原生更加友好。同样，微服务也增加了服务之间的吞吐量。一个服务上的内存密集型操作不会影响任何其他服务。

随着时间的推移，单体架构将消除团队的敏捷性，从而延迟应用程序的发布。这意味着当添加新功能或现有功能中的某些内容出现问题时，人们往往会花更多的时间来寻找解决方案以解决问题。单体架构将带来更多的低效，从而增加技术债务。

另一方面，微服务在架构方面减少了技术债务，因为一切都被简化为单个组件。团队往往更加敏捷，他们会发现处理变更更容易。

代码越少，错误越少，意味着痛苦更少，修复时间更短。

单体应用程序的工作量更大。想象一下有一个大型的单体应用程序，你需要在服务层中撤销一个*if 条件*。在更改代码后，通常需要几分钟来构建，然后你必须测试整个应用程序，这将降低团队的表现。

对于微服务架构，你可以几秒钟内重新启动或重新加载应用程序。当你需要撤销一个*if 条件*时，你不需要等待几分钟来构建和部署应用程序以进行测试，你可以在几秒钟内完成。这将减少执行日常任务所需的时间。

更快的迭代/发布和减少停机时间是提高用户参与度和用户保留率的关键，这反过来又会导致更好的收入。

人类大脑（除非你是超人）只能处理有限的信息量。因此，从认知角度来看，微服务帮助人们减少杂乱，专注于功能。这使生产力更高，部署更快。

采用微服务将：

+   最大化生产力

+   提升敏捷性

+   提升客户体验

+   加速开发/单元测试（如果设计得当）

+   提升收入

# 微服务架构的构建块

运行微服务架构需要许多组件/功能，并涉及许多高级概念。为了理解这些概念，想象我们有一个基于微服务的应用程序，用于我们的电子商务购物网站。这包括以下服务：

+   定价服务：负责根据需求给出产品的价格

+   需求服务：负责根据销售和剩余库存计算产品的需求

+   库存服务：负责跟踪库存中剩余的数量

+   许多其他服务

我们将在本节中看到的一些概念是：

+   服务注册表

+   服务发现

+   健康检查

+   动态路由和弹性

+   安全性（身份验证和授权）

+   容错和故障转移

# 服务注册表

微服务是独立的，但许多用例将需要它们相互依赖。这意味着某些服务要正常工作，需要从另一个服务获取数据，而该服务可能或可能不依赖于其他服务或来源。

例如，我们的定价服务将直接依赖于需求服务，而需求服务又依赖于库存服务。但这三个服务是完全独立的，也就是说，它们可以部署在任何主机、端口或位置，并且可以随意扩展。

如果定价服务想要与需求服务通信，它必须知道确切的位置，可以向其发送请求以获取所需信息。同样，需求服务也应该了解库存服务的详细信息，以便进行通信。

因此，我们需要一个服务注册表来注册所有其他服务和它们的位置。所有服务在服务启动时应自行注册到该注册表服务，当服务关闭时应自行注销。

服务注册表应充当服务数据库，记录所有可用的实例及其详细信息。

# 服务发现

服务注册表有服务的详细信息。但为了找出所需服务的位置以及要连接哪些服务，我们需要进行服务发现。

当定价服务想要与需求服务通信时，它需要知道需求服务的网络位置。在传统架构的情况下，这是一个固定的物理地址，但在微服务世界中，这是一个动态地址，它被动态分配和更新。

定价服务（客户端）必须在服务注册表中定位需求服务，确定位置，然后对可用的需求服务进行负载均衡。反过来，需求服务将响应请求客户端（定价服务）的请求。

服务发现用于发现客户端应连接的确切服务，以获取必要的详细信息。

服务发现帮助 API 网关发现请求的正确端点。

他们还将有一个负载均衡器，它调节流量并确保服务的高可用性。

根据负载均衡发生的地点，服务发现被分为：

+   **客户端端发现模式**

负载均衡将在客户端服务端发生。客户端服务将确定请求发送到何处，负载均衡的逻辑将位于客户端服务中。例如，Netflix Eureka ([`github.com/Netflix/eureka`](https://github.com/Netflix/eureka)) 是一个服务注册表。它提供注册和发现服务的端点。

当定价服务想要调用需求服务时，它将连接到服务注册表，然后找到可用的服务。然后，根据配置的负载均衡逻辑，定价服务（客户端）将确定请求哪个需求服务。

服务将进行智能和特定于应用的负载均衡。缺点是，这为每个服务添加了一个额外的负载均衡层，这增加了开销：

+   **服务器端发现模式**

定价服务将请求负载均衡器连接到需求服务。然后，负载均衡器将连接到服务注册表以确定可用的实例，然后根据配置的负载均衡路由请求。

例如，在 Kubernetes 中，每个 Pod 都有自己的服务器或代理。所有请求都通过这个代理（它有一个与之关联的专用 IP 和端口）发送。

负载均衡逻辑从服务中移除，并隔离到一个单独的服务中。缺点是，它需要一个额外的、高度可用的服务来处理请求。

# 健康检查

在微服务世界中，实例可以随机启动、更改、更新和停止。它们也可以根据流量和其他设置进行上下伸缩。这需要一个健康检查服务，它将不断监控服务的可用性。

服务可以定期向这个健康检查服务发送它们的状态，这有助于跟踪服务状态。当一个服务宕机时，健康检查服务将停止从该服务接收心跳。然后，健康检查服务将标记该服务为宕机，并将信息级联到服务注册表。同样，当服务恢复时，心跳将被发送到健康检查服务。在接收到几个积极的心跳后，服务将被标记为 UP，然后信息被发送到服务注册表。

健康检查服务可以通过两种方式检查健康：

+   **推送配置**：所有服务将定期向健康检查服务发送心跳。

+   **拉取配置**：单个健康检查服务实例将定期查询系统的可用性。

这也要求有一个**高可用性系统**。所有服务都应该连接到这个服务以共享它们的心跳，并且这个服务必须连接到服务注册表以告诉它们服务是否可用。

# 动态路由和弹性

健康检查服务将跟踪可用服务的健康状态，并将有关服务健康状态的详细信息发送到服务注册表。

基于此，服务应智能地将请求路由到健康实例，并关闭不健康实例的流量。

由于服务动态更改其位置（地址/端口），每次客户端想要连接到服务时，它都应该首先检查服务注册表中的服务可用性。每个客户端连接也需要添加一个超时时间，在此时间之后，请求必须被服务或重试（配置）到另一个实例。这样我们可以最小化*级联故障*。

# 安全性

当客户端调用可用服务时，我们需要验证请求。为了防止不想要的请求堆积，我们应该有一个额外的**安全层**。客户端的请求应该经过认证和授权才能调用其他服务，以防止对服务的未授权调用。服务反过来应该解密请求，了解它是否有效或无效，并完成剩余的操作。

为了提供安全的微服务，它应该具有以下特征：

+   机密性：仅允许授权客户端访问和消费信息。

+   完整性：可以保证从客户端接收到的信息的完整性，并确保它不会被第三方修改（例如，当网关和服务相互通信时，任何一方都不能篡改或更改它们之间发送的消息。这是一种经典的中间人攻击）。

+   可用性：安全的 API 服务应该具有高度的可用性。

+   可靠性：应该可靠地处理请求并处理它们。

关于中间人攻击（MITM）的更多信息，请查看以下链接：[`www.owasp.org/index.php/Man-in-the-middle_attack.`](https://www.owasp.org/index.php/Man-in-the-middle_attack)

# 容错和故障转移

在微服务架构中，可能有许多故障原因。优雅地处理故障或故障转移非常重要，如下所示：

+   当请求需要很长时间才能完成时，应设置一个预定的超时时间，而不是等待服务响应。

+   当请求失败时，识别服务器，通知服务注册表，并停止连接到该服务器。这样，我们可以防止其他请求发送到该服务器。

+   当服务没有响应时，关闭服务并启动一个新的服务以确保服务按预期工作。

这可以通过以下方式实现：

+   **容错**库，通过隔离不响应或响应时间超过服务等级协议（SLA）的远程实例和服务来防止级联故障。这防止其他服务调用失败的或不健康的实例。

+   **分布式跟踪系统**库有助于跟踪服务或系统的时序和延迟，并突出显示与协议 SLA 的任何差异。它们还帮助您了解性能瓶颈在哪里，以便您可以采取行动。

JHipster 提供了实现许多先前概念的选项。其中最重要的包括以下内容：

+   JHipster 注册表

+   HashiCorp Consul

+   JHipster 网关

+   JHipster 控制台

+   Prometheus

+   JHipster UAA 服务器

# JHipster 注册表

JHipster 提供了 JHipster Registry ([`www.jhipster.tech/jhipster-registry/`](http://www.jhipster.tech/jhipster-registry/)) 作为默认的**服务注册表**。JHipster Registry 是一个运行时应用程序，所有微服务应用程序都会注册并从中获取其配置。它还提供了监控和健康检查仪表板等附加功能。

JHipster 注册表由以下内容组成：

+   Netflix Eureka 服务器

+   Spring Cloud 配置服务器

# Netflix Eureka 服务器

Eureka ([`github.com/Netflix/eureka`](https://github.com/Netflix/eureka)) 包括以下内容：

+   Eureka 服务器

Eureka 是一个基于 REST 的服务。它用于定位用于负载均衡和故障转移中间层的服务。

Eureka 服务器帮助在实例之间进行负载均衡。它们在可用性间歇的云环境中更有用。另一方面，传统的负载均衡器有助于在已知和固定实例之间进行流量负载均衡。

+   Eureka 客户端

Eureka 提供了一个 Eureka 客户端，使得服务器之间的交互无缝。它是一个基于 Java 的客户端。

Eureka 充当一个**中间层**负载均衡器，帮助负载均衡中间层服务的宿主。它们默认提供基于轮询的简单负载均衡。可以根据需要使用包装器自定义负载均衡算法。

它们不能提供粘性会话。它们也非常适合基于客户端的负载均衡场景（如前所述）。

Eureka 对通信技术没有限制。我们可以使用任何东西，例如 Thrift、HTTP 或任何 RPC 机制进行通信。

假设我们的应用程序位于不同的 AWS 可用区。我们在每个区域注册一个 Eureka 集群，该集群只包含该区域可用的服务信息，并在每个区域启动 Eureka 服务器以处理区域故障。

所有服务都将注册到 Eureka 服务器并发送心跳。当客户端不再发送心跳时，服务将从注册表中移除，并且信息将在集群中的 Eureka 节点之间传递。然后，任何区域的任何客户端都可以查找注册信息以定位它，然后进行任何远程调用。此外，我们还需要确保区域之间的 Eureka 集群之间不相互通信。

Eureka 更倾向于可用性而不是一致性。这就是当服务连接到 Eureka 服务器并共享服务之间的完整配置时。这使得服务即使在 Eureka 服务器关闭的情况下也能运行。在生产中，我们必须在高度可用集群中运行 Eureka 以获得更好的一致性。

Eureka 还具有动态添加或删除服务器的能力。这使得它成为服务注册和服务发现的正确选择。

# Spring 云配置服务器

在微服务架构中，服务本质上是动态的。它们将根据流量或任何其他配置进行上下文切换。由于这种动态特性，应该有一个单独的、 *高度可用* 的服务器来保存所有服务器都需要知道的基本配置细节。

例如，我们的定价服务需要知道注册服务在哪里以及它如何与注册服务通信。另一方面，注册服务应该是高度可用的。如果出于任何原因服务器必须关闭，我们将启动一个新的服务器。定价服务需要与配置服务通信，以了解注册服务。另一方面，当注册服务发生变化时，它必须将更改通知给配置服务器，然后配置服务器将信息级联到所有必要的服务中。

Spring 云配置服务器 ([`github.com/spring-cloud/spring-cloud-config`](https://github.com/spring-cloud/spring-cloud-config)) 为外部配置提供了服务器和客户端支持。

使用云配置服务器，我们有一个中心位置来管理所有环境中的外部属性。这个概念类似于客户端和服务器上基于 Spring 的环境属性源抽象。它们适用于任何用任何语言运行的应用程序。

它们还有助于在各个（开发/测试/生产）环境之间传输配置数据，并有助于更容易地进行迁移。

Spring 配置服务器提供了一个基于 HTTP、资源型的 API 用于外部配置。它们将加密和解密属性值。它们绑定到配置服务器并使用远程属性源初始化 Spring 环境。配置可以存储在 Git 仓库或文件系统中。

# HashiCorp Consul

Consul ([`www.consul.io/`](https://www.consul.io/)) 主要是由 Hashicorp 提供的服务发现客户端。它侧重于一致性。Consul 完全是用 Go 编写的。

这意味着它将具有更小的内存占用。除此之外，我们还可以使用 Consul 与用任何编程语言编写的服务一起使用。

使用 Consul 的主要优势如下：

+   它具有更小的内存占用

+   它可以与用任何编程语言编写的服务一起使用

+   它侧重于一致性而非可用性

Consul 还提供服务发现、故障检测、多数据中心配置和存储。

这是 JHipster 注册的一个替代选项。在应用程序创建期间，可以选择使用 JHipster 注册或 Consul。

Eureka（JHipster 注册）要求每个应用程序使用其 API 进行注册和发现自身。它侧重于可用性而非一致性。它仅支持用 Spring Boot 编写的应用程序或服务。

另一方面，Consul 作为服务中的一个代理运行，检查健康信息和之前列出的其他一些额外操作。

# 服务发现

Consul 可以提供服务，其他客户端可以使用 Consul 来发现特定服务的提供者。通过 DNS 或 HTTP，应用程序可以轻松找到它们所依赖的服务。

# 健康发现

Consul 客户端可以提供任意数量的健康检查，这些检查可以与特定的服务相关联，也可以与本地节点相关联。这些信息可以被健康检查服务用来监控服务的健康状态，反过来，这些信息也被用来发现服务组件并将流量从不健康的节点路由到健康的节点。

# K/V 存储

Consul 提供了一个易于使用的 HTTP API，这使得应用程序能够简单地使用 Consul 的键/值存储来动态配置服务、在当前领导者宕机时选举领导者，以及根据功能隔离容器。

# 多数据中心

Consul 支持开箱即用的多数据中心。这意味着你不必担心构建额外的抽象层来扩展到多个区域。

Consul 应该是一个分布式且高度可用的服务。为 Consul 提供服务的每个节点都运行一个 consul 代理，主要负责健康检查。这些代理将与一个或多个 Consul 服务器通信，这些服务器收集并添加这些信息。这些服务器之间也会选举出一个领导者。

因此，Consul 充当服务注册、服务发现、健康检查和 K/V 存储。

# JHipster 网关

在微服务架构中，我们需要一个入口点来访问所有运行中的服务。因此，我们需要一个充当网关的服务。这将代理或路由客户端的请求到相应的服务。在 JHipster 中，我们为此提供了 JHipster 网关。

JHipster 网关是一个可以生成的微服务应用程序。它集成了 Netflix Zuul 和 Hystrix，以提供路由、过滤、安全、断路器等功能。

# Netflix Zuul

在微服务架构中，Zuul 是所有请求的前门（门卫）。它充当边缘服务应用。Zuul 是为了在服务之间实现动态路由、监控、弹性和安全性而构建的。它还具有根据需要动态路由请求的能力。

冷知识：在 *Ghostbusters* 中，Zuul 是门卫。

Zuul 的工作基于不同类型的过滤器，使我们能够快速灵活地将功能应用于我们的边缘服务。

这些过滤器帮助我们执行以下功能：

+   身份验证和安全：识别每个资源的身份验证要求，并拒绝不符合要求的请求

+   洞察和监控：在边缘跟踪数据和统计信息，并深入了解生产应用

+   动态路由：根据健康和其他因素，根据需要动态地将请求路由到不同的后端集群

+   多区域弹性（AWS）：为了多样化我们的弹性负载均衡器使用，并将我们的边缘更靠近我们的成员，跨 AWS 区域路由请求

如需更多关于 Zuul 的信息，请查看 [`github.com/Netflix/zuul/wiki.`](https://github.com/Netflix/zuul/wiki)

# Hystrix

Hystrix ([`github.com/Netflix/Hystrix`](https://github.com/Netflix/Hystrix)) 是一个用于隔离远程系统、服务和第三方库访问点的延迟和容错库，旨在停止级联故障；并在不可避免失败的复杂分布式系统中实现弹性。

Hystrix 设计来完成以下任务：

+   在复杂的分布式系统中停止故障级联

+   保护系统免受网络依赖项故障的影响

+   控制系统的延迟

+   快速恢复并快速失败以防止级联

+   在可能的情况下进行回退和优雅降级

+   启用近乎实时的监控、警报和操作控制

在复杂的分布式架构中，应用程序有许多依赖项，每个依赖项最终都会在某些时候失败。如果主机应用程序没有从这些外部故障中隔离，它可能会被它们拖垮。

# JHipster 控制台

JHipster 控制台 ([`github.com/jhipster/jhipster-console`](https://github.com/jhipster/jhipster-console)) 是一个用于微服务的监控解决方案，它使用 ELK Stack 构建。它附带预设的仪表板和配置。它以 Docker 镜像的形式提供作为运行时组件。

ELK Stack 由 Elasticsearch、Logstash 和 Kibana 组成。

Logstash 可以用来标准化数据（通常来自日志），然后使用 Elasticsearch 来更快地处理相同的数据。最后，使用 Kibana 来可视化数据。

# Elasticsearch

Elasticsearch 是数据分析中广泛使用的搜索引擎。它帮助您从数据堆中快速提取数据。它还帮助提供实时分析和数据提取。它具有高度可扩展性、可用性和多租户性。

它还提供了基于全文搜索的文档保存选项。这些文档将根据数据的任何更改进行更新和修改。这反过来将提供更快的搜索并分析数据。

# Logstash

Logstash ([`www.elastic.co/products/logstash`](https://www.elastic.co/products/logstash)) 会接收日志，处理它们，并将它们转换为输出。它们可以读取任何类型的日志，如系统日志、错误日志和应用程序日志。它们是这个堆栈的**重工作**组件，有助于存储、查询和分析日志。

它们作为事件处理的管道，能够通过过滤器处理大量数据，并与 Elasticsearch 一起快速交付结果。JHipster 确保日志以正确的格式存储，以便可以正确地分组和可视化。

# Kibana

Kibana ([`www.elastic.co/products/kibana`](https://www.elastic.co/products/kibana)) 构成了 ELK 堆栈的前端。它用于数据可视化。它仅仅是一个日志数据仪表板。它有助于可视化那些否则难以阅读和解释的数据趋势和模式。它还提供了一个分享/保存的选项，这使得数据可视化更有用。

# Zipkin

Zipkin ([`zipkin.io/`](https://zipkin.io/)) 是一个分布式跟踪系统。微服务架构总是存在延迟问题，需要一个系统来排查延迟问题。Zipkin 通过收集时间数据来帮助解决问题。Zipkin 还帮助搜索数据。

所有注册的服务都将报告时间数据到 Zipkin。Zipkin 根据接收到的跟踪请求为每个应用程序或服务创建一个依赖关系图。然后，它可以用来分析、找出处理时间较长的应用程序，并根据需要进行修复。

当发起请求时，跟踪度量将记录标签，将跟踪头添加到请求中，并最终记录时间戳。然后，请求被发送到原始目的地，响应被发送回跟踪度量，然后记录持续时间并与 Zipkin 收集器共享结果，Zipkin 负责存储信息。

默认情况下，JHipster 会生成一个禁用了 Zipkin 的应用程序，但可以在应用程序的 `<env>.yml` 文件中启用它。

# Prometheus

在微服务架构中，我们需要持续监控我们的服务，任何问题都应立即触发警报。我们需要一个独立的服务，它可以持续监控并在发生任何异常时立即通知我们。

Prometheus 由以下部分组成：

+   Prometheus 服务器，负责抓取和存储时间序列数据

+   用于对应用程序代码进行度量的库

+   一个用于支持短期作业的推送网关

+   一个用于在 Grafana 中可视化数据的导出器

+   一个警报管理器

+   其他支持工具

Prometheus 是 JHipster 控制台的替代品。它提供监控和警报支持。这需要单独运行 Prometheus 服务器以获取更多信息。要开始使用 Prometheus，请访问 [`prometheus.io/`](https://prometheus.io/)。

它提供多维数据模型，这些模型是时间序列的，由指标名称和键值对标识。它具有灵活的动态查询语言。它支持开箱即用的时间序列提取，并通过中介网关推送时间序列。它具有多种图表和仪表板支持模式。

当出现故障时，它有助于发现问题。由于它是自主的，不依赖于任何远程服务，因此数据足以找到基础设施损坏的位置。

它有助于记录时间序列数据并通过机器或高度动态的服务导向架构进行监控。

在选择 Prometheus 而不是 JHipster 控制台时，需要考虑以下事项：

+   Prometheus 非常擅长利用应用程序的指标，而不会监控日志或跟踪。另一方面，JHipster 控制台使用 ELK 堆栈，并监控应用程序的日志、跟踪和指标。

+   Prometheus 可以用于查询大量时间序列数据。在 JHipster 控制台上，ELK 在跟踪和搜索指标和日志方面更加灵活。

+   JHipster 控制台使用 Kibana 可视化数据，而 Prometheus 使用 Grafana ([`grafana.com/`](https://grafana.com/)) 可视化指标。

# JHipster UAA 服务器

JHipster 用户账户和授权（UAA）服务仅是一个 OAuth2 服务器，可用于**集中式身份管理**。为了访问受保护资源并避免对 API 的未授权访问，必须有一个授权服务器来授权请求并提供对资源的访问。

OAuth2 是一个授权框架，它根据令牌提供对请求的访问。客户端请求访问服务；如果用户被授权，应用程序将收到授权许可。在收到许可后，客户端从授权服务器请求令牌。一旦收到令牌，客户端将请求资源服务器获取必要的信息。

JHipster 支持标准 LDAP 协议，并通过 JSON API 调用。

JHipster UAA 是一个用户账户和授权服务，用于通过 OAuth2 授权协议确保 JHipster 微服务的安全性。

JHipster UAA 是一个由 JHipster 生成的应用程序，包括用户和角色管理。它还拥有一个完整的 OAuth2 授权服务器。这是灵活的，并且可以完全自定义。

在微服务架构中，安全性至关重要。以下是为确保微服务安全的基本要求。

它们应该在同一个地方进行身份验证。用户应该将整个体验视为一个单一单元。一旦最终用户登录到应用程序，他们应该能够访问他们有权访问的内容。他们应该在登录到系统的整个时间内持有会话相关信息。

安全服务应该是无状态的。无论服务如何，安全服务都应该能够为请求提供身份验证。

它们还需要有能力为机器和用户提供身份验证。它们应该能够区分它们并追踪它们。它们的功能应该是授权传入的请求，而不是识别最终用户。

由于底层服务是可扩展的，安全服务也应该有能力根据需求进行扩展和缩减。

当然，它们应该免受攻击。任何已知的漏洞都应该在需要时得到修复和更新。

之前的要求是通过使用 OAuth2 协议来满足的。

JHipster UAA 是一个集中式服务器，有助于对用户进行身份验证和授权。它们还有会话相关信息，以及系统内部可用的用户和角色管理帮助下的基于角色的访问控制。

OAuth2 协议通常提供基于提供的详细信息的令牌进行身份验证，这使得它们无状态并且能够从任何来源验证请求。

# 摘要

到目前为止，我们已经看到了微服务架构相对于单体应用程序的优势，以及我们需要运行微服务应用程序（如 JHipster Registry、Consul、Zuul、Zipkin、ELK 堆栈、Hystrix、Prometheus 和 JHipster UAA 服务器）所需的组件。在我们下一章中，我们将看到如何使用 JHipster 构建微服务。我们还将了解我们如何选择之前的组件，以及使用 JHipster 设置它们有多容易。
