["```js\nnpm install jasmine-core karma karma-jasmine karma-chrome-launcher --save-dev\nnpm install @types/jasmine karma-browserify browserify watchify --save-dev\n```", "```js\nnpm -g install karma\n```", "```js\nnpm -g install typescript\n```", "```js\nmodule.exports = function(config) {\n   config.set({\n     // Enable Jasmine (Testing)\n     frameworks: ['jasmine', 'browserify'],\n\n     plugins: [\n       require('karma-jasmine'),\n       require('karma-chrome-launcher'),\n       require('karma-browserify')\n    ], \n\n    files: [ 'app/**/*.spec.js' ],\n\n    preprocessors: {\n       'app/**/*.js': ['browserify']\n    },\n\n    reporters: ['progress'],\n\n    browsers: ['Chrome'], \n });\n};\n```", "```js\n// This disables a issue in TypeScript 2.2+ that affects testing\n// So this line is highly recommend to be added to all .spec.ts files\nexport = 0;\n\n// Import our model file (This is what we are going to test)\n// You can import ANY files you need\nimport {TrackModel} from './track.model';\n\n// We use describe to describe what this test set is going to be\n// You can have multiple describes in a testing file.\ndescribe('app/modules/shared/models/TrackModel', () => {\n  // Define whatever variables you need\n  let trackModel: TrackModel;\n\n  // This runs before each \"it\" function runs, so we can \n  // configure anything we need to for the actual test\n  // There is an afterEach for running code after each test\n  // If you need tear down code\n  beforeEach( () => {\n    // Create a new TrackModel class\n    trackModel = new TrackModel({id: 1,\n       filepath: 'Somewhere',\n       name: 'in Cyberspace',\n       order: 10,\n       volume: 5,\n       mute: false,\n       model: 'My Model'});\n  });\n\n  // Lets run the first test. It makes sure our model is allocated\n  // the beforeEach ran before this test, meaning it is defined.\n  // This is a good test to make sure everything is working properly.\n  it( \"Model is defined\", () => {\n    expect(trackModel).toBeDefined();\n  });\n\n  // Make sure that the values we get OUT of the model actually\n  // match what default values we put in to the model\n  it (\"Model to be configured correctly\", () => {\n    expect(trackModel.id).toBe(1);\n    expect(trackModel.filepath).toBe('Somewhere' );\n    expect(trackModel.name).toBe('in Cyberspace');\n    expect(trackModel.order).toBe(10);\n    expect(trackModel.model).toBe('My Model');\n  });\n\n  // Verify that the mute functionality actually works\n  it ('Verify mute', () => {\n    trackModel.mute = true;\n    expect(trackModel.mute).toBe(true);\n    expect(trackModel.volume).toBe(0);\n    trackModel.mute = false;\n    expect(trackModel.volume).toBe(5);\n  });\n\n  // Verify the volume functionality actually works\n  it ('Verify Volume', () => {\n    trackModel.mute = true;\n    expect(trackModel.volume).toBe(0);\n    trackModel.volume = 6;\n    expect(trackModel.volume).toBe(6);\n    expect(trackModel.mute).toBe(false);\n  });\n}); \n```", "```js\n karma start karma.ang.conf.js \n```", "```js\nexport class TrackModel implements ITrack { \n private _volume: number = 1;\n private _mute: boolean;\n private _origVolume: number;\n constructor(model?: ITrack) {\n   if (model) {\n    for (let key in model) {\n      this[key] = model[key];\n    }\n   }\n }\n\n public set mute(value: boolean) {\n   value = typeof value === 'undefined' ? false : value;\n   this._mute = value;\n   if (this._mute) {\n     this._origVolume = this._volume;\n     this.volume = 0;\n   } else {\n     this.volume = this._origVolume;\n   }\n }\n\n public set volume(value: number) {\n   value = typeof value === 'undefined' ? 1 : value;\n   this._volume = value;\n   if (this._volume > 0 && this._mute) {\n     this._origVolume = this._volume;\n     this._mute = false;\n   }\n }\n}\n```", "```js\n it ('Verify mute', () => {\n     expect(trackModel.volume).toBe(5);\n });\n```", "```js\ntns test init\n```", "```js\n// Import the reflect-metadata because angular needs it, even if we don't.\n// We could import the entire angular library; but for unit-testing; \n// smaller is better and faster.\nimport 'reflect-metadata';\n\n// Import our DatabaseService, we need at least something to test... ;-)\nimport { DatabaseService } from \"../modules/core/services/database.service\";\n\n// We do the exact same thing as we discussed earlier; \n// we describe what test group we are testing.\ndescribe(\"database.service.test\", function() {\n\n  // So that we can easily change the Testing key in case we find out later in our app\n  // we need \"TestingKey\" for some obscure reason.\n  const TestingKey = \"TestingKey\";\n\n  // As before, we define a \"it\" function to define a test group\n  it(\"Test Database service class\", function() {\n\n    // We are just going to create the DatabaseService class here, \n    // no need for a beforeEach.\n    const dbService = new DatabaseService();\n\n    // Lets attempt to write some data.\n    dbService.setItem(TestingKey, {key: \"alpha\", beta: \"cygnus\", delta: true});\n\n    // Lets get that data back out...\n    let valueOut = dbService.getItem(TestingKey);\n\n    // Does it match?\n    expect(valueOut).toBeDefined();\n    expect(valueOut.key).toBe(\"alpha\");\n    expect(valueOut.beta).toBe(\"cygnus\");\n    expect(valueOut.delta).toBe(true);\n\n    // Lets write some new data over the same key\n    dbService.setItem(TestingKey, {key: \"beta\", beta: true});\n\n    // Lets get the new data\n    valueOut = dbService.getItem(TestingKey);\n\n    // Does it match?\n    expect(valueOut).toBeDefined();\n    expect(valueOut.key).toBe(\"beta\");\n    expect(valueOut.beta).toBe(true);\n    expect(Object.keys(valueOut).length).toBe(2);\n\n    // Lets remove the key\n    dbService.removeItem(TestingKey);\n\n    // Lets make sure the key is gone\n    valueOut = dbService.getItem(TestingKey);\n    expect(valueOut).toBeFalsy();\n  });\n});\n```", "```js\ntns test android\n```", "```js\ntns test ios\n```"]