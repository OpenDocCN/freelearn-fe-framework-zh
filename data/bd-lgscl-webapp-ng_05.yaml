- en: 1.21 Gigawatt - Flux Pattern Explained
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.21吉瓦特 - Flux模式解释
- en: Your application has grown and in that process, you slowly feel you are losing
    track of what your application knows at a given point, what we call the state
    of the application. There might be other issues, such as parts of your application
    not being in agreement with what they know. An update that happened in one part
    may not have been applied to some other part and you scratch your head, thinking
    should it be this hard and is there a better answer?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序已经发展壮大，在这个过程中，你慢慢地感到你正在失去应用程序在某个时间点的知识，我们称之为应用程序的状态。可能还会出现其他问题，比如你的应用程序的某些部分与它们所知道的不一致。在一个部分发生的更新可能没有应用到其他部分，你想着这真的应该这么难吗，有没有更好的答案？
- en: It's entirely possible you are just picking up this book as you have heard about
    NgRx as the way to structure your application and you are curious and want to
    know more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能只是因为听说NgRx是构建应用程序结构的方式而拿起这本书，你很好奇想要了解更多。
- en: 'Let''s first explain our title. What do we mean by 1.21 Gigawatt? I''m going
    to quote the character Doc Brown from the movie *Back to the Future* ([http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu](http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu)):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解释一下我们的标题。我们说的1.21吉瓦特是什么意思？我要引用电影《回到未来》中的Doc Brown角色（[http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu](http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu)）：
- en: '"Marty, I''m sorry, but the only power source capable of generating 1.21 gigawatts
    of electricity is a bolt of lightning."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '"Marty, 对不起，但是产生1.21吉瓦特电力的唯一能源就是一道闪电。"'
- en: 'Why are we talking about the movie Back to the Future? This is where the name
    Flux comes from. It''s time for another quote from the same movie:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要谈论电影《回到未来》？这就是Flux这个名字的来源。现在是时候再引用同一部电影的台词了：
- en: '"Yes! Of course! November 5, 1955! That was the day I invented time-travel.
    I remember it vividly. I was standing on the edge of my toilet hanging a clock,
    the porcelain was wet, I slipped, hit my head on the sink, and when I came to
    I had a revelation! A vision! A picture in my head! A picture of this! This is
    what makes time travel possible: the **flux** capacitor!"'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的！当然！1955年11月5日！那天我发明了时间旅行。我还记得清楚。我站在马桶的边缘挂钟，瓷器是湿的，我滑倒了，撞到了水池，当我醒来时，我有了一个启示！一个幻觉！我脑海中有了一个画面！这个画面使时间旅行成为可能：**flux**电容器！"'
- en: So as you can see, there is an explanation for the name Flux. It obviously allows
    us to travel in time. At least for Redux, which we will write about later in this
    book, time travel is possible through something called time-travel debugging.
    Whether that needs a bolt of lightning is for you to find out dear reader.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到，对于名为Flux的名字有一个解释。很明显，它允许我们时间旅行。至少对于Redux来说，我们稍后会在这本书中写到，通过一种称为时间旅行调试的东西，时间旅行是可能的。是否需要一道闪电，那就由你这位亲爱的读者来掐腕验证。
- en: Flux is an architectural pattern created by Facebook. It came about as it was
    perceived that the MVC pattern simply did not scale. It did not scale for large
    code bases as they tended to become fragile, generally complicated as more and
    more features were added, and most of all, unpredictable. Now let's hang on that
    word for a second, unpredictable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Flux是Facebook创建的一种架构模式。它的产生是因为人们认为MVC模式根本无法扩展。随着越来越多的功能被添加，大型的代码库变得脆弱、复杂，最重要的是，不可预测。现在让我们停顿一下，想一想这个词，不可预测。
- en: 'Large systems were thought to become unpredictable due to their bidirectional
    data flow between models and views when the number of models and views really
    grew, as depicted in the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型和视图的数量真正增长时，大型系统被认为会变得不可预测，因为它们之间存在双向数据流，如下图所示：
- en: '![](img/cd476946-b1c8-428f-a290-4d626e5b0794.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd476946-b1c8-428f-a290-4d626e5b0794.png)'
- en: Here, we can see that the number of models and views is starting to grow. Everything
    is somewhat under control as long as one model talks to one view and vice versa.
    This is, however, seldom the case. In the preceding diagram, we see that suddenly
    a view can talk to more than one model and vice versa, which means we have a cascading
    effect on the system and we suddenly lose control. Sure, it doesn't look so bad
    with just one deviating arrow, but imagine that this one is suddenly ten arrows,
    then we have a real problem on our hands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到模型和视图的数量开始增长。只要一个模型与一个视图进行交流并且反之亦然，一切都还算控制在一定范围内。然而，这种情况很少发生。在上述图表中，我们看到突然之间一个视图可以与多个模型交流，反之亦然，这意味着系统产生了级联效应，我们突然失去了控制。当然，只有一个偏离的箭头看起来并不那么糟糕，但想象一下，如果这个箭头突然变成了十个箭头，我们就真的遇到了严重的问题。
- en: It is the very fact that we allow bidrectional data flows to happen that things
    get complicated and we lose predictability. The medicine or cure for that is thought
    to be a simpler type of data flow, a unidirectional flow. Now, there are some
    key players involved in enabling undirectional data flow, which brings us to what
    this chapter is meant to teach us.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为我们允许双向数据流发生，事情才变得复杂，我们失去了可预测性。对此的解药或治疗被认为是一种更简单类型的数据流，即单向流。现在，有一些关键角色参与了启用单向数据流，这就是这一章节要教我们的内容。
- en: 'In this chapter, we will learn:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学到：
- en: What an action and an action creator are
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作和动作创建者是什么
- en: How the dispatcher plays a central role in your application as a hub for messages
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发者在你的应用程序中扮演了一个中心角色，作为消息的中心
- en: State management with a store
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存储库进行状态管理
- en: How to put our knowledge of Flux into practice by coding up a Flux application
    flow
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过编码一个Flux应用程序流将我们对Flux的知识付诸实践
- en: Core concepts overview
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心概念概述
- en: At the core of the Flux pattern is a unidirectional data flow. It uses some
    core concepts to achieve this flow. The main idea is when an event is created
    on a UI, through the interaction of a user, an action is created. This action
    consists of an intent and a payload. The intent is what you are trying to achieve.
    Think of the intent as a verb. Add an item, remove an item, and so on. The payload
    is the data change that needs to happen to achieve our intent. If we are trying
    to add an item, then the payload is the newly created item. The action is then
    propagated in the flow with the help of a dispatcher. The action and its data
    eventually end up in a store.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Flux模式的核心是单向数据流。它使用一些核心概念来实现这种流。主要思想是当UI上创建了一个事件，通过用户的交互，会产生一个动作。这个动作包括一个意图和一个载荷。意图是你想要实现的目标。把意图想象成一个动词。添加一个项目，删除一个项目，等等。载荷是需要发生的数据变化，以实现我们的意图。如果我们试图添加一个项目，那么载荷就是新添加的项目。然后，动作通过分发者在流中传播。动作及其数据最终会进入存储库。
- en: 'The concepts that make up the Flux pattern are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 组成Flux模式的概念包括：
- en: Action and action creators, where we set up an intention and a payload of data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作和动作创建者，其中我们设定了一个意图和数据的载荷
- en: The dispatcher, our spider in the web that is able to send messages left and
    right
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发者，我们的网页蜘蛛，能够左右发送消息
- en: The store, our central place for state and state management
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库，我们的状态和状态管理的中心位置
- en: 'All these together form the Flux pattern and promote unidirectional data flow.
    Consider the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些构成了Flux模式，并促进了单向数据流。考虑下面的图表：
- en: '![](img/89837a9b-d48e-4a33-890c-c61bd5a326d6.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89837a9b-d48e-4a33-890c-c61bd5a326d6.png)'
- en: 'What is depicted here is an undirectional data flow. The data flows from **View**
    to **Action**, from **Action** to **Dispatcher**, from **Dispatcher** to **Store**.
    There are two possible ways that the flow is triggered:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描绘的是一个单向数据流。数据从**视图**到**动作**，从**动作**到**分发者**，从**分发者**到**存储库**。触发流的有两种可能的方式：
- en: The application is loaded a first time, in which the data is pulled from the
    **Store** to populate the view.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序第一次加载时，会从**存储库**中提取数据，以填充视图。
- en: A user interaction happens in the view that leads to an intent to change something.
    The intent is encapsulated in an **Action**, and thereafter sent to the **Store**,
    via the **Dispatcher**. At the **Store**, it may be persisted in a database, through
    an **API** or saved as an application state, or both.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在视图中发生交互，导致了改变的意图。意图被封装在一个**动作**中，并随后通过**分发者**发送到**存储库**。在**存储库**中，它可以被持久化到数据库中，通过**API**或保存为应用程序状态，或两者兼而有之。
- en: Let's dive into each concept in more detail, together with highlighting some code
    examples, in the upcoming sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节中深入探讨每个概念，并强调一些代码示例。
- en: A uniform data flow
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个统一的数据流
- en: 'Let''s introduce all parties involved in our uniform data flow by starting
    from the very top and slowly work our way down, concept by concept. We will build
    an application consisting of two views. In the first view, the user will select
    an item from a list. This should result in an action being created. This action
    will then be dispatched, by the dispatcher. The action and its payload will end
    up in a store. The other view meanwhile listens to changes from the store. When
    an item is selected, the second view will be made aware and can, therefore, indicate
    in its UI that a specific item has been selected. On a high level, our application
    and its flow will look like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最顶部开始介绍参与我们统一数据流中的所有方，概念概念地一步一步向下展开。我们将构建一个应用程序，由两个视图组成。在第一个视图中，用户将从列表中选择一个项目。这应该导致创建一个动作。然后，该动作将由调度器分派。该动作及其载荷最终将进入存储。与此同时，另一个视图将从存储中监听变化。当选定项目时，第二个视图将知道并因此可以在其UI中指示特定项目已被选定。在高层次上，我们的应用程序及其流程将如下所示：
- en: '![](img/13f7b397-8882-49b9-a11a-63fa225bc683.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13f7b397-8882-49b9-a11a-63fa225bc683.png)'
- en: Action – capture the intent
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作 - 捕捉意图
- en: An action is something as simple as an intent with accompanying data, that is,
    a message. How does an action come about though? An action comes about when a
    user interacts with a UI. The user may select a specific item in a list or a press
    a button with the intention of submitting a form. Submitting the form should,
    in turn, lead to a product being created.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动作就是一个简单的意图，伴随着数据，也就是一条消息。但是一个动作是如何产生的呢？一个动作是由用户与UI交互时产生的。用户可能会在列表中选择特定的项目，或者按下按钮意图提交表单。提交表单应该导致产品被创建。
- en: 'Let''s look at two different actions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两种不同的动作：
- en: Selecting an item in a list, here we are interested in saving the index of our
    selected item
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中选择项目，这里我们感兴趣的是保存所选项目的索引
- en: Saving a todo to a todo list
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将待办事项保存到待办事项列表中
- en: 'An action is represented by an object. The object has two properties of interest:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动作由一个对象表示。该对象具有两个感兴趣的属性：
- en: 'The type: This is a unique string that tells us the intention of the action,
    for example, `SELECT_ITEM`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：这是一个唯一的字符串，告诉我们动作的意图，例如，`选择项目`
- en: 'The data: This is the data we mean to persist, for example, the numerical index
    of a selected item'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据：这是我们打算持久保存的数据，例如所选项目的数值索引
- en: 'Given our first example action, a code representation of that action would
    look like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的第一个示例动作，该动作的代码表示看起来像下面这样：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: OK, so we have prepared our action, which we can also think of as a message.
    We want the message to be sent so that the selected item is highlighted in the
    UI. As this is a undirectional flow, we need to follow a charted course and pass
    our message over to the next party, which is the dispatcher.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经准备好我们的动作，我们也可以将其视为一条消息。我们希望发送消息以便在UI中突出显示所选项。由于这是一个单向流动，我们需要遵循一条既定的航线，并将消息传递给下一个方，也就是调度器。
- en: Dispatcher – the spider in the web
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器 - 网络中的蛛网
- en: 'Think of the dispatcher as the spider in the web that handles messages being
    passed to it.  You can also think of the dispatcher as a mailman who promises
    that your message will reach its target destination. A dispatcher lives, for one
    thing, to dispatch messages to anyone who will listen. There is usually just one
    `dispatcher` in a Flux architecture and a typical usage looks something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将调度器视为处理传递给它的消息的网络中的蜘蛛。你也可以将调度器视为一名邮差，承诺您的消息将到达目的地。调度器存在的一个作用就是将消息分派给任何愿意倾听的人。在Flux架构中通常只有一个`调度器`，典型的用法看起来像这样：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Listening to the dispatcher
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 听取调度器的消息
- en: 'We have established that the dispatcher dispatches a message to anyone who
    will listen. Now it is time to be that listener. The dispatcher needs a `register`
    or `subscribe` method so that you, who listens, have the ability to listen for
    incoming messages. The setup for that usually looks something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定调度器会将消息分派给任何愿意倾听的人。现在是时候成为那个倾听者了。调度器需要一个`注册`或`订阅`方法，以便你这个倾听者有能力倾听传入的消息。通常的设置看起来像这样：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, when you set up a listener this way, it will have the capability to listen
    to any message type being sent. You want to narrow this down; usually, a listener
    is specified to only handle a few message types around a certain theme. Your listener
    most likely looks something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你这样设置监听器时，它将有能力监听到发送的任何消息类型。你需要缩小范围；通常，监听器被指定为只处理围绕某一主题的几种消息类型。您的监听器大多看起来像这样：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'OK, so we are able to filter out only the message types we care about, but
    before actually filling in some code we need to think about who this listener
    is. The answer is simple: it is the store.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以筛选出我们关心的消息类型，但在填写实际代码之前，我们需要考虑一下这个监听器是谁。答案很简单：就是store。
- en: The store – managing state, data retrieval, and callbacks
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: store - 管理状态，数据检索和回调方法
- en: 'It''s easy to think of the store as the place where our data lives. That is,
    however, not all it is. What the store''s responsibilities are can be expressed
    by this list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容易认为store是数据存储的地方。然而，这并不是它的全部功能。下面的列表可以表达store的责任是什么：
- en: Holder of state
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态的持有者
- en: Manages the state, able to update it if need be
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理状态，可以根据需要进行更新
- en: Able to handle side effects such as fetching/persisting data through HTTP
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理通过HTTP获取/持久化数据等副作用
- en: Handles callbacks
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理回调方法
- en: 'As you can see, that is a bit more than just storing the state. Let''s now
    reconnect to what we were doing when we set up a listener with the `dispatcher`.
    Let''s move that code into our store file, `store.js`, and let''s persist our
    message content in our store:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这不只是存储状态。现在让我们重新连接到设置与`dispatcher`监听器相关的工作。让我们将该代码移动到我们的store文件`store.js`中，并将我们的消息内容保存在store中：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: OK, so now the store is being told about the new index, but an important piece
    is missing, how do we tell the UI? We need a way to tell the UI that something
    has changed. A change means that the UI should reread its data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在store已经知道了新索引的情况，但重要的一点被遗漏了，我们该如何告诉UI？我们需要一种方法告诉UI发生了变化。变化意味着UI应该重新读取它的数据。
- en: The view
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'To tell the view that something has happened and act on it, three things need
    to happen:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉视图发生了什么并对其进行操作，需要发生三件事：
- en: The view needs to register with the store as a listener
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图需要注册为store的监听器
- en: The store needs to send off an event conveying that a change has happened
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: store需要发送一个传达变化已发生的事件
- en: The view needs to reload its data
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图需要重新加载其数据
- en: 'Starting with the store, we need to build it out so that you can register as
    a listener to its events. We, therefore, add the `addListener()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从store开始，我们需要构建它，以便您可以注册为其事件的监听器。因此，我们添加`addListener()`方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we also add the ability to emit an event with the addition
    of the `emitChange()` method. You can easily switch out this implementation to
    use an `EventEmitter` or similar. So now is the time to hook up our view to the
    store. We do so by calling the `addListener()` method like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们还添加了使用`emitChange()`方法发出事件的能力。您可以很容易地切换该实现以使用`EventEmitter`或类似的东西。现在是将我们的视图与store连接的时候了。我们通过以下方式调用`addListener()`方法来实现：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we implement the `notifyChanged()` method, which when
    called invokes the `getSelectedItem()` method from the store and thereby receives
    the new value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们实现了`notifyChanged()`方法，当调用时会从store中调用`getSelectedItem()`方法，从而接收到新的值。
- en: 'At this point, we have described the whole chain: how one view receives a user
    interaction, turns that into an action, which is then dispatched to a store, which
    updates the store''s state. The store then emits an event that the other view
    is listening to. When the event is received, in the view the state from the store
    is reread and the view is then free to render this state, which it just read in,
    the way it sees fit.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经描述了整个链条：一个视图如何接收用户交互，将其转换为操作，然后发送到store，然后更新store的状态。然后store发出一个其他视图正在监听的事件。当事件被接收时，在视图中从store中重新读取状态，然后视图可以自由地渲染这个刚刚读取的状态，以它认为合适的方式。
- en: 'We have described two things here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述了两件事情：
- en: How to set up the flow
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置流程
- en: How the information flows in Flux
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux中的信息流
- en: 'Setting up the flow can be depicted with the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设置流程可以通过以下图示来描述：
- en: '![](img/3d1c5a2f-b842-474e-af21-201423bf19e4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d1c5a2f-b842-474e-af21-201423bf19e4.png)'
- en: 'As for the second scenario, how the information flows through the system, it
    can be depicted in the following way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第二种情况，信息流如何通过系统流动，可以用下面的方式来描述：
- en: '![](img/2f60552e-7c94-4269-b885-5005f7bab5fa.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f60552e-7c94-4269-b885-5005f7bab5fa.png)'
- en: Demoing a uniform data flow
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示统一数据流
- en: 'Ok, so we have described the parts our application consists of:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经描述了我们的应用程序包括的部分：
- en: A view where a user is able to select an index
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以选择索引的视图
- en: A dispatcher that allows us to send a message
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许我们发送消息的分发器
- en: A store that contains our selected index
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含我们选择的索引的存储器
- en: A second view where the selected index is read from the store
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从存储器中读取所选索引的第二个视图
- en: Let's build a real app from all of this. The following code is found in the
    code repository under `Chapter2/demo`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从所有这些中构建一个真正的应用程序。以下代码可以在`Chapter2/demo`目录下的代码库中找到。
- en: Creating a selection view
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建选择视图
- en: 'First off we need our view in which we will perform the selection:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '首先我们需要我们的视图，在其中我们将执行选择:'
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have bolded the   `selectIndex()`   method above that we intend to use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用粗体标出了上面我们打算使用的`selectIndex()`方法。
- en: Adding the dispatcher
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分发器
- en: 'Next off we need a dispatcher that is able to take our message, like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们需要一个分发器，能够接受我们的消息，如下所示:'
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding the store
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加存储器
- en: 'The store will act as the data source for our state but will also be able tell
    any listeners when a change to the store happens:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '存储器将作为我们状态的数据源，但也能够在存储器发生更改时告诉任何监听器:'
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding a selected view
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个选择视图
- en: 'This view will register itself with the store and ask for updates to its content.
    If there are any updates it will be notified and the data from the store will
    be read and this view will communicate what the store value now is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '此视图将向存储器注册自身，并要求更新其内容。如果有任何更新，它将收到通知，并且将从存储器中读取数据，此视图将传达存储器值的现在是什么:'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the demo
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行演示
- en: 'Before we can run our demo we need an application file, `app.js`. The `app.js` file
    should require in our views and also carry out the selection:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们运行演示之前，我们需要一个应用文件`app.js`。`app.js`文件应该要求我们的视图，并且执行选择:'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To run our demo we need to compile it. Above we are using ES2015 modules. To
    compile those we will use `webpack`. We need to install `webpack` by typing the
    following in our terminal:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的演示，我们需要编译它。上面我们使用了ES2015模块。为了编译这些模块，我们将使用`webpack`。我们需要在我们的终端中键入以下内容来安装`webpack`：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we have done so we need to create `webpack.config.js` file where we tell
    Webpack how to compile our files and where to place the resulting bundle. That
    file looks like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦我们这样做了，我们需要创建`webpack.config.js`文件，告诉Webpack如何编译我们的文件以及将生成的捆绑包放在哪里。该文件如下所示:'
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This tells Webpack that `app.js` is the entry point to our application and it
    should crawl all the dependencies when creating the output file, `bundle.js`.
    Webpack will by default place `bundle.js` in the `dist` directory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Webpack`app.js`是我们应用程序的入口点，并且在创建输出文件`bundle.js`时应该爬取所有的依赖项。Webpack默认会将`bundle.js`放在`dist`目录中。
- en: 'One more thing, we need an HTML file that we will name `index.html`. We will
    place under the `dist` folder. It should look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '还有一件事，我们需要一个名为`index.html`的HTML文件。我们将放在`dist`文件夹下。它应该是这样的:'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, to run our application, we need to compile it with Webpack and start
    a HTTP server and start up a browser. We will do all that with the following command
    from the `demo` directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了运行我们的应用程序，我们需要使用Webpack编译它，并启动一个HTTP服务器并打开浏览器。我们将在`demo`目录中使用以下命令完成所有操作：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, start a browser and navigate to `http://localhost:5000`. You should see
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开浏览器并导航到`http://localhost:5000`。您应该会看到以下内容：
- en: '![](img/999c31ff-43ad-4cc8-b1f2-9ce4d710869a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/999c31ff-43ad-4cc8-b1f2-9ce4d710869a.png)'
- en: All of this demonstrates how to views can be made to communicate using a dispatcher
    and a store.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些演示了如何使用分发器和存储器进行视图通信。
- en: Adding more actions to our flow
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的流程中添加更多操作
- en: Let's do a reality check here. We haven't built the Flux flow as prettily as
    we could make it. The overall picture is correct but it'd be nice if we can clean
    it up a bit to make room for more actions so we get a real sense of how the application
    should grow from here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做一个现实检查。我们还没有将Flux流组织得像我们可以使它美观。总体概览是正确的，但如果我们能稍微整理一下，为更多操作留出空间，那将��很好，这样我们就可以更好地了解应用程序应该如何从这里发展。
- en: Cleaning up the view
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理视图
- en: 'The first order of business is to have a look at our first view and how it
    reacts to user interactions. It looks like this currently:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是查看我们的第一个视图以及它如何对用户交互的反应。目前它看起来像这样：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Adding a few more actions into the mix means we would extend the view with
    a few methods like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的流程中添加更多操作意味着我们将向视图中添加一些方法，如下所示:'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OK, so now we get how we can add actions. It looks a little ugly though with
    all these calls to the `dispatcher` and magic strings, so we clean this up a bit
    by creating a file with constants, called `product.constants.js`, which consists
    of the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道如何添加动作了。但是看起来有点丑陋，因为有这么多调用`dispatcher`和魔术字符串，所以我们通过创建一个包含常量的文件`product.constants.js`稍微清理一下，其中包含以下代码：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s do one more thing. Let''s move the `dispatcher` into a `product.actions.js`;
    this is generally known as an action creator. This will contain the `dispatcher`
    and refer to our `product.constants.js` file. So let''s create said file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一件事。让我们把`dispatcher`移到`product.actions.js`中；这通常被称为动作创建者。它将包含`dispatcher`并引用我们的`product.constants.js`文件。所以让我们创建该文件：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these constructs, we can clean up our view considerably to look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些结构，我们可以大大简化视图，看起来像这样：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Cleaning up the store
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理商店
- en: There are improvements we can make to on the store. There is no need to write
    all the code we do currently. In fact, there are libraries out there that do a
    better job of handling certain functionality.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对商店做出改进。没有必要编写我们目前所做的所有代码。实际上，市面上有一些库能更好地处理某些功能。
- en: Before we apply all those changes we have in mind, let's recap what our store
    can do and what features still need to be in place after the cleanup work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们计划应用所有这些变化之前，让我们回顾一下我们的商店到底能做些什么，以及清理工作完成后仍需要具备哪些功能。
- en: 'Let''s remind ourselves, what our store is capable of so far:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一想，到目前为止我们的商店能做什么：
- en: 'Handles state changes: It handles the state changes; the store is able to change
    the state regardless of whether it is creating, updating, listing, or removing
    state.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理状态变化：它处理状态变化；无论是创建、更新、列出还是删除状态，商店都能改变状态。
- en: 'Subscribable: It lets you subscribe to it; it''s important for the store to
    have a subscription functionality so a view, for example, can listen to the store''s
    state when it changes. A suitable reaction by the view is, for example, rerendering
    based on new data.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可订阅的：它可以让您订阅它；商店具有订阅功能对于视图来说很重要，例如，当状态发生变化时，视图可以监听商店的状态。视图可能会根据新数据重新渲染。
- en: 'Can communicate a state change: It can send an event that its state has been
    changed; this goes together with being able to subscribe to the store, but this
    is the very act of actually notifying a listener that a state has changed.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以传达状态变化：它可以发送状态已更改的事件；这与能够订阅商店相搭配使用，但这实际上是通知监听器状态已更改的行为。
- en: Adding EventEmitter
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 EventEmitter
- en: The two last bullets can really be condensed into one theme, namely eventing,
    or the ability to register to and fire off events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点实际上可以归结为一个主题，即事件处理，或者能够注册并触发事件的功能。
- en: So what does a cleanup of the store look like, and why would we need to clean
    it up? The reason for cleaning it up is it makes for simpler code. There is a
    standard library that is often used when constructing a store, called `EventEmitter`.
    The library handles just what we mentioned previously, namely it is able to register
    and fire off events. It is a simple implementation of the pub-sub pattern. Basically, `EventEmitter`
    allows you to subscribe to certain events and also allows you to trigger events.
    For more information on the pattern itself, have a look at the following link: [https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么清理商店是什么样子的，为什么我们需要清理呢？清理的原因是使代码更简单。通常在构建商店时会使用一个标准库，称为`EventEmitter`。该库处理了我们之前提到的内容，即能够注册和触发事件。这是发布-订阅模式的简单实现。基本上，`EventEmitter`允许您订阅特定事件，并且也允许您触发事件。有关模式本身的更多信息，请参阅以下链接：[https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)。
- en: You could definitely write your own code for this, but it's nice to be able
    to use a dedicated library so you can focus on other things that matter, such
    as solving business problems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定能为此编写自己的代码，但能够使用专用库让您可以专注于其他重要事项，比如解决业务问题，这真的很好。
- en: 'We decided to use the `EventEmitter` library and we do so in the following
    way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用`EventEmitter`库，并且我们这样做：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This makes our code a little cleaner because we no longer need to hold an internal
    list of subscribers. There are more changes we can make though, so let us talk
    about that in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们的代码变得更清晰，因为我们不再需要保存内部订阅者列表。虽然我们可以做更多的改变，但让我们在下一节中讨论一下。
- en: Adding to and cleaning up the register method
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和清理注册方法
- en: 'One of the store''s jobs has been to handle eventing, especially when the store
    wants to convey to a view that a change has happened to its state. In the `store.js`
    file, other things were happening as well, things like registering ourselves with
    the `dispatcher` and being able to receive dispatched actions. We used these actions
    to alter the state of the store. Let''s remind ourselves what that looked like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的工作之一是处理事件，特别是当存储想要向视图传达其状态发生了变化时。在`store.js`文件中，还发生着其他一些事情，比如注册我们自己与`dispatcher`并能够接收分发的操作。我们使用这些操作来改变存储的状态。让我们提醒自己那是什么样子：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we are only supporting one action, namely `SELECT_INDEX`. There are two
    things we need to do here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只支持一个操作，即`SELECT_INDEX`。我们在这里需要做两件事：
- en: Add the other two actions, `CREATE_PRODUCT` and `REMOVE_PRODUCT`, and the accompanying
    functions `createProduct()` and `removeProduct()`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加另外两个操作，`CREATE_PRODUCT`和`REMOVE_PRODUCT`，以及相应的函数`createProduct()`和`removeProduct()`
- en: Stop using magic strings and start using our constants file
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止使用神秘字符串，开始使用我们的常量文件
- en: Use the store we created in the `store-event-emitter.js` file
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们在`store-event-emitter.js`文件中创建的存储
- en: 'Let''s implement the suggested changes from our preceding list:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现前面列表中建议的更改：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Further improvements
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的改进
- en: There are definitely more improvements we can make to this code. We did use
    ES2015 imports to import other files, but most of our code was written in ES5
    so why not use most of what ES2015 gives us? Another improvement we can make is
    introducing immutability and making sure our store is not mutated but transitions
    from one state to another.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码肯定还有更多的改进空间。我们使用了ES2015的导入来导入其他文件，但我们大部分的代码都是用ES5编写的，所以为什么不充分利用ES2015给我们的大多数功能呢？我们可以做的另一个改进是引入不可变性，并确保我们的存储不是被突变的，而是从一个状态过渡到另一个状态。
- en: 'Let''s have a look at the store file, primarily because that is where we can
    add the most ES2015 syntax. Our revealing module pattern looks like this currently:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下存储文件，因为那是我们可以添加最多ES2015语法的地方。我们目前的模块模式看起来是这样的：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It can be replaced with a simple class and instead of instantiating an `EventEmitter`,
    we can inherit from it. In all fairness, we could have used ES2015 inheritance
    or the merge library to not have to create a separate `EventEmitter` instance,
    but this shows how elegant ES2015 can make things:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用一个简单的类来替换，而不是实例化一个`EventEmitter`，我们可以继承它。公平地说，我们可以使用ES2015继承或合并库来避免创建一个单独的`EventEmitter`实例，但这展示了ES2015可以使事情多么简洁：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Adding immutability
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加不可变性
- en: 'The other thing we can undertake is adding immutability. The reasons for using
    immutability in the first place are to make your code more predictable, and some
    frameworks can use this for simpler change detection and can rely on reference
    checking over dirty checking. This was the case when AngularJS got its whole change
    detection mechanism changed when Angular was written. From a practical standpoint,
    this means that there are functions we can target in our store and apply immutable
    principles on. The first principle is to not mutate but create an entirely new
    state, instead of where the new state is *the old state + the state change*. A
    simple example of this is the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的另一件事是增加不可变性。首先使用不可变性的理由是使您的代码更可预测，一些框架可以使用这一点进行更简单的变化检测，并且可以依靠引用检查而不是脏检查。当AngularJS的整个变化检测机制在编写Angular时改变时，情况就是如此。从实际的角度来看，这意味着有一些函数我们可以在我们的存储中进行操作，并应用不可变性原则。第一个原则是不要改变，而是创建一个全新的状态，而不是新状态是*旧状态+状态变化*。一个简单的例子是：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we are creating a new variable, `newState`, rather than mutating our
    `oldState` variable. There are functions that will help us with this, called `Object.assign`
    and the function filter. We can use these for updating scenarios, as well as adding
    or removing things from a list. Let us use these and rewrite part of our store
    code. Let''s highlight the code we mean to change:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新变量`newState`，而不是突变我们的`oldState`变量。有一些函数可以帮助我们做到这一点，叫做`Object.assign`和函数filter。我们可以用它们来更新情况，以及从列表中添加或删除东西。让我们使用它们并重新编写我们的存储代码的一部分。让我们突出显示我们打算更改的代码：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s apply `Object.assign` and `filter()`, and remember to not mutate things.
    The end result should look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用`Object.assign`和 `filter()`，并记得不要改变东西。 最终结果应该是这样的：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that the `createProduct()` method uses an ES2015 construct, namely
    the spread parameter, `...`, which takes a list and turns its members into a comma-separated
    list of items. `Object.assign()` is used to copy over all the values from an object
    so we store the value of an object rather than its reference. The `removeProduct()`
    method becomes very simple when we use the filter method. We simply create a projection
    that does not include the product that we should remove; removing has never been
    this easy or elegant. We haven't mutated anything.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`createProduct()`方法使用了一个ES2015构造，即spread参数，`...`，它接受一个列表并将其成员转换为逗号分隔的项目列表。`Object.assign()`用于复制对象的所有值，因此我们存储的是对象的值而不是它的引用。
    使用filter方法时，`removeProduct()`方法变得非常简单。 我们只需创建一个投影，不包括应该删除的产品；删除从未如此简单或优雅。 我们没有改变任何东西。
- en: Summarizing
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our cleanup started with the view; we wanted to remove a direct connection to
    the dispatcher and also stop having to use magic strings as this is quite error
    prone, and it's easy to misspell. Instead, we can rely on constants. To remedy
    this, we created an action creator class that talked to the dispatcher instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的清理从视图开始；我们想要删除对dispatcher的直接连接，也不再需要使用魔术字符串，因为这非常容易出错，并且很容易拼错。 相反，我们可以依赖于常量。
    为了解决这个问题，我们创建了一个与dispatcher通信的action creator类。
- en: We also created a constants module to remove the magic strings.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个常量模块来删除魔术字符串。
- en: Furthermore, we improved the store by starting to use `EventEmitter`. Finally,
    we further improved the store by adding more actions to it and also started to
    refer to the constants.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过开始使用`EventEmitter`来改进存储。 最后，我们通过给它添加更多动作并开始引用常量来进一步改进存储。
- en: At this point, our solution is ready for more actions to be added to it and
    we should feel pretty clear on what files we need to add to, as we support more
    and more user interactions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的解决方案已经准备好接受更多的动作，并且我们应该非常清楚需要添加到哪些文件中，因为我们支持越来越多的用户交互。
- en: Lastly, we added improvements around ES2015 and immutability, which made our
    code look a lot cleaner. With this foundation, we are now ready to go from static
    data to involve working with side effects and Ajax in the upcoming section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们围绕ES2015和不可变性进行了改进，使得我们的代码看起来更加整洁。 有了这个基础，我们现在可以从静态数据转为涉及副作用和Ajax的工作。
- en: 'Let us summarize all our improvements in a diagram showing the constructs added
    to our flow:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在图表中总结我们所有的改进，显示添加到我们流程中的构造：
- en: '![](img/d3e6216d-ff51-4e48-bac1-369b8349deac.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3e6216d-ff51-4e48-bac1-369b8349deac.png)'
- en: It is clear that using an action creator isn't strictly necessary but it does
    clean up the code quite a bit, and the same goes for using an `EventEmitter` in
    the store; it's nice but not necessary.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，使用action creator并不是必须的，但它确实清理了代码，并且对存储使用 `EventEmitter`也是如此；很好但不是必需的。
- en: Adding AJAX calls
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 AJAX 调用
- en: 'So far, we have only been dealing with static data in our Flux flow. The time
    has now come to add real data connections to the flow and thereby real data. It
    is time to start talking to APIs through AJAX and HTTP. Fetching data is quite
    easy nowadays, thanks to the fetch API and libraries such as RxJS. What you need
    to think about when incorporating it in the flow is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在Flux流中只处理静态数据。 现在是时候向流程添加真实数据连接，因此添加真实数据。 是时候开始通过 AJAX 和 HTTP 与 API
    进行通信了。 获取数据现在相当容易，多亏了fetch API和RxJS等库。 在将其纳入流程时，你需要考虑以下事项：
- en: Where to place the HTTP call
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪里进行 HTTP 调用
- en: How to ensure that the store is updated and interested views are notified
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保存储得到更新并通知感兴趣的视图
- en: 'We have a point at which we register the store to the `dispatcher`, with this
    piece of code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册存储到`dispatcher`的代码如下：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we do this for real, that is, call an API to persist this product, `createProduct()`
    would be where we would do the API call, like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的这么做，即调用 API 来保存这个产品，`createProduct()`将是我们调用 API 的地方，如下所示：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling `fetch()` returns a `Promise`. Let''s use async/await however, as it
    makes the call much more readable. The difference in code can be seen in the following
    example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `fetch()` 返回一个 `Promise`。 然而，让我们使用async/await，因为它使调用变得更加可读。 代码上的差异可见以下示例：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replacing what happens in `createProduct()` with this adds code with a lot
    of noise so it is a good idea to wrap your HTTP interactions in an API construct
    like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 用这种方法替换`createProduct()`中发生的事情会添加大量噪音的代码，因此将您的HTTP交互封装在API结构中是一个好主意，如下所示：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now let us replace the `createProduct()` method content with the call to our
    API construct like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用调用我们的API结构来替换`createProduct()`方法的内容，如下所示：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s not really enough though. Because we created a product through an API
    call, we should dispatch an action that forces the product list to be reread.
    We don''t have such an action or supporting method in a store to handle it, so
    let''s add one:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这还不够。因为我们通过API调用创建了一个产品，所以我们应该发出一个强制产品列表重新读取的动作。我们没有这样的动作或支持方法在存储中处理它，所以让我们添加一个：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let''s add the required method in the store and the case to handle it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在存储中添加所需的方法，并处理它的情况：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that the `CREATE_PRODUCT` case will call the corresponding  API method
    `createProduct()`, which on completion will dispatch the `GET_PRODUCTS` action.
    The reason for doing so is that when we successfully manage to create a product,
    we need to read from the endpoint to get an updated version of the products list. We
    don't see that in detail, but it is being invoked through us calling `getProducts()`.
    Again, it is nice to have a wrapper on everything being dispatched, that wrapper
    being an action creator.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`CREATE_PRODUCT`情况将调用相应的API方法`createProduct()`，在完成时将分发`GET_PRODUCTS`动作。这样做的原因是，当我们成功创建产品时，我们需要从端点读取以获取产品列表的更新版本。我们不能详细看到这一点，但它是通过我们调用`getProducts()`来调用的。同样，封装每个被分发的东西是很好的，这个封装就是一个动作创建者。
- en: 'The full file looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件看起来像这样：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: An even bigger solution
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更大的解决方案
- en: 'So far, we have been describing a solution that consists of only a product''s
    topic and communication has only taken place from one view to another. In a more
    realistic application, we would have a lot of topics such as user management,
    orders, and so on; exactly what they are called is dependent on the domain of
    your application. As for views, it is quite possible that you will have a ton
    of views listening to another view, as in this example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在描述一个只包含产品主题的解决方案，通信只发生在一个视图到另一个视图。在一个更现实的应用程序中，我们将有许多主题，如用户管理、订单等；它们的确切名称取决于您应用程序的领域。至于视图，很可能你会有大量的视图监听另一个视图，就像这个例子中一样：
- en: '![](img/95cff40e-3af8-43de-904f-36ade57a8316.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95cff40e-3af8-43de-904f-36ade57a8316.png)'
- en: 'This describes an application that contains four different view components
    around their own topic. The **Customers view** contains a list of customers and
    it allows us to alter which customer we currently want to focus on. The other
    three supporting views show **Orders**, **Messages**, and **Friends** and their
    content depends on which customer is currently highlighted. From a Flux standpoint,
    the **Orders**, **Messages**, and **Friends** views can easily register with the
    store to know when things gets updated so they can fetch/refetch the data they
    need. However, imagine that the supporting views themselves want to support CRUD
    actions; then they would need their own set of constants, action creator, API,
    and store. So now your application would need to look something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了一个包含四个不同视图组件的应用程序，围绕它们自己的主题。**客户视图**包含客户列表，并且允许我们更改我们当前想要关注的客户。另外三个支持视图显示**订单**，**消息**和**朋友**，它们的内容取决于当前突出显示的客户。从Flux的角度来看，**订单**，**消息**和**朋友**视图可以轻松地向存储注册，以知道何时更新了，因此它们可以获取/重新获取它们需要的数据。然而，想象一下，支持视图自身想要支持CRUD操作；然后它们将需要自己的一组常量、动作创建者、API和存储。因此，现在您的应用程序需要看起来像这样：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Two interesting situations exist here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在两种有趣的情况：
- en: You have a self-contained view; all CRUD actions happen within it
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个独立的视图；所有CRUD操作都在它内部发生
- en: You have a view that needs to listen to other views
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个需要监听其他视图的视图
- en: For the first situation, a good rule of thumb is to create its own set of constants,
    action creator, API, and store.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，一个很好的经验法则是创建自己的一组常量、动作创建者、API和存储。
- en: For the second situation, ensure your view registers itself with the store of
    that topic. For example, if the friends view needs to listen to the customer view,
    then it needs to register itself with the customer store.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种情况，请确保您的视图向该主题的存储注册自己。例如，如果朋友视图需要监听客户视图，那么它需要向客户存储注册自己。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We set out trying only to explain the Flux architecture pattern. It would have
    been very easy to start mentioning how it fits with React and how there are nice
    libraries and tools that support Flux and React. That would, however, have taken our focus away
    from explaining the pattern from a more framework-agnostic viewpoint. Therefore,
    the rest of this chapter set out to explain core concepts such as actions, action
    creator, dispatcher, store, and uniform data flow. Little by little, we improved
    the code to start using constants, action creators, and a nice supporting library
    such as `EventEmitter`. We explained how HTTP fits into this and, lastly, we discussed
    how we could build out our application. There is a lot more that can be said about
    Flux, but we chose to limit the scope to understand the fundamentals so we can
    compare its approach as we dive into Redux and NgRx in later chapters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始只是想解释Flux架构模式。很容易就开始提及它如何与React配合，以及有哪些支持Flux和React的好用库和工具。然而，这样做会使我们的焦点偏离了从更加框架无关的角度解释这一模式的初衷。因此，本章的其他部分致力于解释核心概念，如动作、动作创建者、分发器、仓库和统一数据流。我们逐渐改进了代码，开始使用常量、动作创建者和一个很好的支持库，比如`EventEmitter`。我们解释了HTTP如何嵌入其中，最后，我们讨论了如何构建我们的应用程序。关于Flux还有很多可以说的，但我们选择限制范围，以便了解基本原理，这样我们就可以在后续章节中深入研究Redux和NgRx的方式进行比较。
- en: The next chapter will build on that foundation by introducing the concept of **Functional
    Reactive Programming** (**FRP**). It deals more with how to reason around the
    fact that data arrives seemingly when it wants to. As messy as that sounds, even
    that can be modeled to create a sense of structure and order if we think of our
    data as a stream. More on that in the next chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在此基础上介绍**函数响应式编程**（**FRP**）的概念。它更多地处理的是如何理解数据似乎随时到来的事实。尽管听起来很混乱，但甚至这也可以被建模为创建一种结构和秩序的感觉，只要我们把我们的数据看作是一种流。关于这一点，下一章会详细介绍。
