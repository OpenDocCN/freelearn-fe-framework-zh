- en: '*Chapter 9*: Debugging with the New Ivy Runtime APIs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular Ivy introduces a new API for inspecting and debugging our Angular applications
    at runtime. It replaces the previous `NgProbe` API and allows tree-shaking of
    `DebugElement`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore Angular''s most useful runtime debugging functions, including
    the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '`ng.applyChanges`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng.getComponent`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng.getContext`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng.getListeners`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having these debugging utilities at hand will allow you to verify your assumptions
    about active components, their templates, and their DOM bindings at runtime.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers these topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the new Ivy runtime API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting an active component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting event listeners
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting an embedded view context
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting familiar with these topics will improve your development workflow when
    implementing Angular Ivy applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support all the features used in the code examples of this chapter, your
    application requires at least the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Angular Ivy version 12.0
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript version 4.2
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, note that the runtime debugging API is only available when Angular runs
    in development mode.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: You can find complete code examples for the random number generator in this
    book's companion GitHub repository at [https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number](https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the new Ivy runtime API
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked with Angular versions before Angular Ivy, you might be familiar
    with the `NgProbe` API, which was available in the global scope at runtime as
    the `ng.probe` function. Angular Ivy replaces this API with a set of new runtime
    debugging functions, which are only available in Angular development mode.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'The new API contains the following functions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`ng.applyChanges(component: {}): void;`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark the specified component for dirty checking if it is using the `OnPush`
    change detection strategy. Afterward, trigger a change detection cycle.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getComponent<T>(element: Element): T | null;`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the Angular component that is attached to the specified DOM element.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getContext<T>(element: Element): T | null;`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When passed a DOM element generated by a structural directive such as `NgIf`
    or `NgFor`, resolve the view context of the embedded view. In other cases, resolve
    the parent component.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getDirectiveMetadata(directiveOrComponentInstance: any): ComponentDebugMetadata
    | DirectiveDebugMetadata | null;`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the metadata of the specified Angular component or directive instance.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getDirectives(element: Element): {}[];`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve Angular directives – but not components – attached to the specified
    DOM element.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getHostElement(componentOrDirective: {}): Element;`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the host element that the specified component or directive is attached
    to.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getInjector(elementOrDir: {} | Element): Injector;`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the injector associated with the specified element, directive, or component.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getListeners(element: Element): Listener[];`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve event listeners attached to the specified DOM element. This does not
    include host listeners created from directive or component metadata but includes
    event listeners not added by Angular.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getOwningComponent<T>(elementOrDir: {} | Element): T | null;`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the host component of the specified DOM element, directive, or component.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getRootComponents(elementOrDir: {} | Element): {}[];`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the root components associated with the specified DOM element, directive,
    or component, that is, the components bootstrapped by Angular.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Listener` data structures returned by `ng.getListeners` have the following
    interface:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data structures returned by `ng.getDirectiveMetadata` have the following
    interfaces:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `inputs` and `outputs` properties defined in the preceding debug metadata
    interfaces contain object maps from data binding property names to component property
    names.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: It is important to be aware that the `ComponentDebugMetadata#changeDetection`
    and `ComponentDebugMetadata#encapsulation` properties are number enumerations,
    so their values will be numbers at runtime, not strings. This makes them a bit
    harder to interpret when debugging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding overview, most of these runtime debugging utilities
    accept as a parameter a DOM element, a component instance, or a directive instance.
    From the specified object, they look up DOM elements, one or more component instances,
    one or more directive instances, an injector, or event listeners attached to the
    DOM.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The one that stands out is `ng.applyChanges`. We will discuss when and how to
    use it in the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting a component instance
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore our application programmatically at runtime, we often need a reference
    to an active component instance. Once we have a component reference, we can change
    bound properties and call event handlers or other methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: However, first, we need a reference to either a directive instance or a DOM
    element with an attached component. Using the `$0` variable. Alternatively, we
    can use `document.querySelector`, or any other DOM querying or traversing API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have a component that generates random numbers, as seen in the following
    figure:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A component for generating a random number'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16295.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – A component for generating a random number
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'It has a component model as seen in the following code block:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In its template, it is using Angular Material''s Button component as seen in
    the following code listing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Given that we have a reference to the `<button>` DOM element in the `$0` variable,
    we can do the following to resolve two different component instances:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is a subtle but important distinction between `ng.getComponent` and `ng.getOwningComponent`.
    The first invocation returns an instance of the `MatButton` component, which is
    attached to the `<button>` DOM element. The second invocation gives us a reference
    to the active instance of `RandomNumberComponent`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: We conclude that `ng.getComponent` returns the component attached to the specified
    DOM element, in this case `MatButton`. Now, `ng.getOwningComponent` returns the
    component instance that's associated with the component template used to generate
    the specified DOM element, in this case an instance of `RandomNumberComponent`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The `generatedNumber` UI property is bound to text in the DOM created for the
    random generator component by Angular. What if we wanted to change it to something
    specific, say `42`? With a reference to an active component instance, we can change
    UI properties directly as seen in the following browser console listing:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, when looking at the rendered application, we notice that the DOM has
    not been updated to reflect this new component state. When using the runtime debugging
    API, we must let Angular know when we have manually changed the state and want
    Angular to update the DOM it manages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'We notify Angular of the dirty state by passing the component instance to `ng.applyChanges`
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After Angular completes a change detection cycle, we notice that the new state
    is reflected in the DOM, as seen in the following figure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – A component displaying a manually specified number'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16295.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – A component displaying a manually specified number
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Great, now you are familiar with the most common runtime debugging functions,
    which put us in control of Angular components. In the following sections, we will
    look at debugging APIs that are instrumental to runtime debugging, yet not as
    commonly used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting event listeners
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll reuse the random number generator example from the *Inspecting a component
    instance* section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, the following is the random number directive used in the template
    of the random number component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When its `generateNumber` method is called, it outputs the randomly generated
    number through the `numberGenerated` output property. The random number component
    has bound its event handler `RandomNumberComponent#onNumberGenerated` to this
    custom component event.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: DOM event listeners
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We pick the `<button>` element in the `$0`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in the component template that the button component has a click event
    binding. We want to access it so that we can trigger it. To do that, pass the
    button DOM element to the `ng.getListeners` function, as seen in the following
    browser console listing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We unpack the first and only event listener that is returned by `ng.getListeners`
    when passed the button DOM element. This `Listener` data structure is stored in
    the `onButtonClick` variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the click event handler by invoking `onButtonClick.callback`. This
    triggers the same state update as clicking the **Generate** button. However, Angular
    is not aware of the dirty state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: DOM event listeners registered outside of Angular code are also returned by
    `ng.getListeners`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember from the *Inspecting a component instance* section that
    we must notify Angular of state changes we introduce through the runtime debugging
    APIs. We do this by passing the component instance to `ng.applyChanges` as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When Angular finishes a change detection cycle, the newly generated number is
    displayed in the DOM for the random number generator component, which is managed
    by Angular.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we did not pass any parameters to the `Listener#callback` method.
    In our use case, the event handler did not accept any parameters. If it did, we
    would most likely have to pass arguments of the expected type for it to work.
    For example, a click event listener might accept a `MouseEvent` event of type
    `click`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Custom component event bindings
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event handlers bound by Angular custom component event bindings are also registered
    as listeners. Our example component has an inline event handler bound for the
    custom `numberGenerated` event.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We pick the `<span>` element in the `$0`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the `span` element to `ng.getListeners`, and notice that it lists two
    listeners, one of type `"dom"` and another one of type `"output"`, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We simulate a random number generation by passing `7` to `outputListener.callback`
    and run change detection by passing the component to `ng.applyChanges`. This is
    shown in the following browser console listing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once a change detection cycle has finished, the random number generation that
    we simulated is displayed in the DOM, which is managed by Angular.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: That is all for inspecting native and custom event listeners using the Angular
    runtime debugging API. In the final section of this chapter, we'll learn what
    an embedded view context is, and how to inspect it using Angular Ivy's runtime
    debugging API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting an embedded view context
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A structural directive is used to add and remove elements to the DOM throughout
    the lifecycle of a component. They create an embedded view, which is bound to
    a view context. This is the case of the `NgIf` and `NgFor` directives that are
    part of the Angular framework.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Only one structural directive can be attached to an element. If you need to
    apply multiple structural directives, wrap the element in the special `<ng-container>`
    element, attach the outer structural directive to this element, and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'When we pass an element with a structural directive attached to `ng.getContext`,
    it returns the view context. For example, when we pass an element with an `NgIf`
    directive attached to it, `NgIfContext` is returned, which has the following shape:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The embedded view that is dynamically created by `NgIf` is bound to the `$implicit`
    property of `NgIfContext`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instead pass an element that has an `NgFor` directive attached to it,
    `NgForOfContext` is returned. It has the following shape:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递一个带有`NgFor`指令的元素，则返回`NgForOfContext`。它具有以下形状：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An embedded view is dynamically created by the `NgFor` directive for each item
    in `NgForOfContext#ngForOf`. Each embedded view is bound to the `$implicit` property
    of `NgForOfContext` specific to that item.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgFor`指令为`NgForOfContext#ngForOf`中的每个项目动态创建一个嵌入式视图。每个嵌入式视图都绑定到特定于该项目的`NgForOfContext`的`$implicit`属性。'
- en: 'However, each embedded view also has access to the other properties that are
    specified in `NgForOfContext`. For example, we can loop through a list of users
    and store a reference to the `index` and `first` context properties, like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个嵌入式视图也可以访问`NgForOfContext`中指定的其他属性。例如，我们可以遍历用户列表并存储对`index`和`first`上下文属性的引用，如下所示：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The embedded view created for each user has access to and uses the `index` and
    `first` properties, which are aliased as `i` and `isFirst`, respectively.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个用户创建的嵌入式视图可以访问并使用`index`和`first`属性，分别别名为`i`和`isFirst`。
- en: 'Passing a list item element from the previous code listing to `ng.getContext`
    results in an `NgForOfContext` value, such as the examples in the following code
    listing:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将前一个代码列表中的列表项元素传递给`ng.getContext`会导致返回一个`NgForOfContext`值，例如以下代码列表中的示例：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly, if we pass the `<span>` element to `ng.getContext`, we get an `NgIfContext`
    value, such as the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们把`<span>`元素传递给`ng.getContext`，我们得到一个`NgIfContext`值，如下所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Take special care to pass the element that has a structural directive attached,
    or you will instead receive the closest component instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意传递带有结构指令的元素，否则你将收到最近的组件实例。
- en: Now you know how to inspect the embedded view context of template elements with
    a structural directive attached.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何检查带有结构指令的模板元素的嵌入式视图上下文。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope you like the new shiny tools that we added to your toolbox in this chapter.
    We started with an overview of Angular Ivy's runtime debugging API, which is available
    only in development mode.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你喜欢我们在本章中添加到你的工具箱中的新工具。我们从一个概述开始，介绍了Angular Ivy的运行时调试API，该API仅在开发模式下可用。
- en: Next, we learned how to inspect a component instance using `ng.getComponent`
    and `ng.getOwningComponent`. We also changed the component state, then updated
    the DOM using `ng.applyChanges`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何使用`ng.getComponent`和`ng.getOwningComponent`检查组件实例。我们还更改了组件状态，然后使用`ng.applyChanges`更新DOM。
- en: In the *Inspecting event listeners* section, we used `ng.getListeners` to inspect
    both native DOM event listeners and custom component event listeners. We passed
    arguments to their callbacks and triggered change detection using `ng.applyChanges`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*检查事件监听器*部分，我们使用`ng.getListeners`来检查原生DOM事件监听器和自定义组件事件监听器。我们向它们的回调传递参数，并使用`ng.applyChanges`触发变更检测。
- en: Finally, you now know what an embedded view context is and how to inspect it,
    for example, how one is created and bound to each component or element managed
    by the `NgFor` directive. Similarly, we explored an example of an embedded view
    context for an element managed by an `NgIf` directive.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你现在知道什么是嵌入式视图上下文以及如何检查它，例如，它是如何创建并绑定到由`NgFor`指令管理的每个组件或元素。同样，我们探索了一个由`NgIf`指令管理的元素的嵌入式视图上下文示例。
- en: With all these newfound skills, you are ready to debug Angular applications
    by inspecting and updating state directly or through events, then reflecting the
    changes by triggering change detection.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得所有这些新技能后，你就可以通过直接检查和更新状态或通过事件来调试Angular应用程序，然后通过触发变更检测来反映这些更改。
- en: You are even able to inspect the ever-so-hard-to-locate embedded view contexts.
    Amazing!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至能够检查那些难以找到的嵌入式视图上下文。太棒了！
- en: In the next chapter, you will learn about the Angular Compatibility Compiler,
    and when and why it is needed. We will explore its configuration options and optimize
    it for a CI/CD workflow.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解Angular兼容性编译器以及何时以及为什么需要它。我们将探索其配置选项，并针对CI/CD工作流程进行优化。
