- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Interacting with RESTful APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 RESTful API 交互
- en: In this chapter, we will build a page that lists blog posts fetched from a REST
    API, as well as also a form to submit blog posts to the REST API. Through this,
    we will learn about various approaches to interacting with a REST API from a React
    component.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个页面，该页面列出从 REST API 获取的博客文章，以及一个表单，用于将博客文章提交到 REST API。通过这种方式，我们将了解从
    React 组件与 REST API 交互的各种方法。
- en: The first approach will be using React’s `useEffect` hook with the browser’s
    `fetch` function. As part of this process, we learn how to use a type assertion
    function to strongly type the data from a REST API. We will then use the data
    loading capability of **React Router** and experience its benefits. After that,
    we will move on to use a popular library called **React Query** and experience
    its benefits, before using React Query and React Router together to get the best
    of both these libraries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法将是使用 React 的 `useEffect` 钩子和浏览器的 `fetch` 函数。作为此过程的一部分，我们将学习如何使用类型断言函数来为来自
    REST API 的数据提供强类型。然后，我们将使用 **React Router** 的数据加载功能并体验其优势。之后，我们将转向使用一个流行的库，即 **React
    Query**，并体验其优势，最后我们将结合使用 React Query 和 React Router 以获得这两个库的最佳效果。
- en: 'So, in this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Getting set up
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Using the effect hook with fetch
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 effect 钩子与 fetch 结合使用
- en: Posting data with fetch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fetch 发送数据
- en: Using React Router
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Router
- en: Using React Query
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Query
- en: Using React Router with React Query
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Router 和 React Query 结合
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will use the following technologies in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用以下技术：
- en: '**Node.js** and **npm**: You can install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 和 **npm**：您可以从 [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    安装它们。'
- en: '**Visual Studio Code**: You can install it from [https://code.visualstudio.com/](https://code.visualstudio.com/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：您可以从 [https://code.visualstudio.com/](https://code.visualstudio.com/)
    安装它。'
- en: All the code snippets in this chapter can be found online at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter9](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter9).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码片段都可以在以下网址找到：[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter9](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter9).
- en: Creating the project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: In this section, we will start by creating the project for the app we will build.
    We will then create a REST API for the app to consume.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先创建我们将要构建的应用程序项目。然后，我们将为应用程序创建一个 REST API 以供其消费。
- en: Setting up the project
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: We will develop the app using Visual Studio Code and require a new Create React
    App-based project setup. We’ve previously covered this several times, so we will
    not cover the steps in this chapter – instead, see [*Chapter 3*](B19051_03.xhtml#_idTextAnchor072),
    *Setting Up React* *and TypeScript*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Visual Studio Code 开发应用程序，并需要一个基于 Create React App 的新项目设置。我们之前已经多次介绍过这一点，因此在本章中我们将不介绍这些步骤——相反，请参阅
    [*第 3 章*](B19051_03.xhtml#_idTextAnchor072)，*设置 React 和 TypeScript*。
- en: We will style the app with Tailwind CSS. We have previously covered how to install
    and configure Tailwind in Create React App in [*Chapter 5*](B19051_05.xhtml#_idTextAnchor127),
    *Approaches to Styling Frontends*. So, after you have created the React and TypeScript
    project, install and configure Tailwind.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Tailwind CSS 来设计应用程序的样式。我们之前在 [*第 5 章*](B19051_05.xhtml#_idTextAnchor127)，*前端样式方法*
    中介绍了如何安装和配置 Tailwind。因此，在您创建了 React 和 TypeScript 项目之后，请安装并配置 Tailwind。
- en: We will use React Router to load data, so see [*Chapter 6*](B19051_06.xhtml#_idTextAnchor151),
    *Routing with React Router,* for information on how to do this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 React Router 来加载数据，因此请参阅[*第 6 章*](B19051_06.xhtml#_idTextAnchor151)，*使用
    React Router 进行路由*，了解如何进行此操作。
- en: We will use `@tailwindcss/forms` plugin to style the form. See [*Chapter 7*](B19051_07.xhtml#_idTextAnchor188),
    *Working with Forms,* for a reminder of how to implement these.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `@tailwindcss/forms` 插件来设计表单。请参阅 [*第 7 章*](B19051_07.xhtml#_idTextAnchor188)，*与表单一起工作*，以回顾如何实现这些。
- en: Understanding the component structure
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解组件结构
- en: 'The app will be a single page containing a form for adding new posts above
    a list of all the existing posts. The app will be structured into the following
    components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将是一个单页应用程序，其中包含一个位于现有文章列表上方的添加新文章的表单。应用程序将分为以下组件：
- en: '![Figure 9.1 – App component structure](img/B19051_09_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 应用组件结构](img/B19051_09_01.jpg)'
- en: Figure 9.1 – App component structure
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 应用组件结构
- en: 'Here’s a description of these components:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这些组件的描述：
- en: '`PostsPage` will render the whole page by referencing the `NewPostForm` and
    `PostsLists` components. It will also interact with the REST API.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostsPage` 将通过引用 `NewPostForm` 和 `PostsLists` 组件来渲染整个页面。它还将与 REST API 交互。'
- en: '`NewPostForm` will render a form that allows a user to enter a new blog post.
    This will use the `ValidationError` component to render validation error messages.
    The `ValidationError` component will be the same as the one created in [*Chapter
    7*](B19051_07.xhtml#_idTextAnchor188).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewPostForm` 将渲染一个表单，允许用户输入新的博客文章。这将使用 `ValidationError` 组件来渲染验证错误消息。`ValidationError`
    组件将与在 [*第 7 章*](B19051_07.xhtml#_idTextAnchor188) 中创建的相同。'
- en: '`PostsList` will render the list of blog posts.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostsList` 将渲染博客文章列表。'
- en: Right, now we know the component structure, let’s create the REST API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道了组件结构，让我们创建 REST API。
- en: Creating a REST API
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 REST API
- en: 'We will create a REST API using a tool called **JSON Server**, which allows
    a REST API to be quickly created. Install JSON Server by running the following
    command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 **JSON Server** 的工具创建 REST API，它允许快速创建 REST API。通过运行以下命令安装 JSON Server：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then define the data behind the API in a JSON file. Create a file called
    `db.json` in the root of the project containing the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 JSON 文件中定义 API 后面的数据。在项目的根目录中创建一个名为 `db.json` 的文件，包含以下内容：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding JSON means that the data behind the API will initially contain
    two blog posts (this code snippet can be copied from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter9/useEffect-fetch/db.json](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter9/useEffect-fetch/db.json)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 JSON 表示 API 后面的数据最初将包含两篇博客文章（此代码片段可以从 [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter9/useEffect-fetch/db.json](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter9/useEffect-fetch/db.json)
    复制）。
- en: 'Now we need to define an npm script to start the JSON server and handle requests.
    Open `package.json` and add a script called `server` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义一个 npm 脚本来启动 JSON 服务器并处理请求。打开 `package.json` 并添加一个名为 `server` 的脚本，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The script starts the JSON server and watches the JSON file we just created.
    We have specified that the API runs on port `3001` so that it doesn’t clash with
    the app running on port `3000`. We have also slowed down the API responses by
    adding a 2-second delay, which will help us see when data is being fetched from
    the React app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本启动 JSON 服务器并监视我们刚刚创建的 JSON 文件。我们指定 API 在端口 `3001` 上运行，以免与在端口 `3000` 上运行的
    app 冲突。我们还通过添加 2 秒的延迟来减缓 API 响应，这将帮助我们看到数据何时从 React 应用程序中获取。
- en: 'In a terminal, start the API by running the script we just created, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，通过运行我们刚刚创建的脚本启动 API，如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After a few seconds, the API starts. To check that the API is working correctly,
    open a browser and enter the following address: `http://localhost:3001/posts`.
    The blog post data should appear in the browser as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，API 启动。为了检查 API 是否正常工作，打开浏览器并输入以下地址：`http://localhost:3001/posts`。博客文章数据应如下显示在浏览器中：
- en: '![Figure 9.2 – Blog posts REST API](img/B19051_09_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 博客文章 REST API](img/B19051_09_02.jpg)'
- en: Figure 9.2 – Blog posts REST API
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 博客文章 REST API
- en: 'For more information on JSON Server, see the following link: [https://github.com/typicode/json-server](https://github.com/typicode/json-server).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 JSON Server 的信息，请参阅以下链接：[https://github.com/typicode/json-server](https://github.com/typicode/json-server)。
- en: Now that the project is set up with a REST API, keeping the API running, next,
    we will learn how to interact with the REST API using `useEffect`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经设置好了 REST API，保持 API 运行，接下来，我们将学习如何使用 `useEffect` 与 REST API 交互。
- en: Using the effect hook with fetch
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 effect 钩子与 fetch 一起使用
- en: In this section, we will create a page that lists the blog posts returned from
    the REST API we just created. We will use the browser’s `fetch` function and React’s
    `useEffect` hook to interact with the REST API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个页面，列出我们从刚刚创建的 REST API 返回的博客文章。我们将使用浏览器的 `fetch` 函数和 React 的 `useEffect`
    钩子与 REST API 交互。
- en: Getting blog posts using fetch
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 fetch 获取博客文章
- en: 'We will start by creating a function that gets blog posts from the REST API
    using the browser’s `fetch` function; we will store the API URL in an environment
    variable. To do this, carry out the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个函数，使用浏览器的 `fetch` 函数从 REST API 获取博客文章；我们将 API URL 存储在一个环境变量中。为此，执行以下步骤：
- en: 'The same URL will be used to get, as well as save, new blog posts to the REST
    API. We will store this URL in an environment variable. So, create a file called
    `.env` in the root of the project containing this variable, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用相同的 URL 来获取以及保存新的博客文章到 REST API。我们将把这个 URL 存储在一个环境变量中。因此，在项目的根目录中创建一个名为 `.env`
    的文件，包含以下变量：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This environment variable is injected into the code at build time and can be
    accessed by code using `process.env.REACT_APP_API_URL`. Environment variables
    in Create React App projects must be prefixed with `React_APP_`. For more information
    on environment variables, see the following link: [https://create-react-app.dev/docs/adding-custom-environment-variables/](https://create-react-app.dev/docs/adding-custom-environment-variables/).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个环境变量在构建时注入到代码中，可以通过 `process.env.REACT_APP_API_URL` 被代码访问。Create React App
    项目的环境变量必须以 `React_APP_` 为前缀。有关环境变量的更多信息，请参阅以下链接：[https://create-react-app.dev/docs/adding-custom-environment-variables/](https://create-react-app.dev/docs/adding-custom-environment-variables/)。
- en: Now, create a folder called `posts` in the `src` folder for all the files for
    the blog post feature.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `src` 文件夹中创建一个名为 `posts` 的文件夹，用于存放所有博客文章功能的文件。
- en: 'Create a file called `getPosts.ts` in the `posts` folder. In this file, add
    the following function that gets the blog posts:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `posts` 文件夹中创建一个名为 `getPosts.ts` 的文件。在这个文件中，添加以下获取博客文章的函数：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `fetch` function has an argument for the URL to the REST API. We have used
    the `REACT_APP_API_URL` environment variable to specify this URL. Environment
    variable values can be `undefined`, but we know this isn’t the case, so we have
    added a `!`) after it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` 函数有一个用于 REST API URL 的参数。我们使用了 `REACT_APP_API_URL` 环境变量来指定这个 URL。环境变量值可以是
    `undefined`，但我们知道这不是情况，所以我们在其后添加了一个 `!`)。'
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A not null assertion operator is a special operator in TypeScript. It is used
    to inform the TypeScript compiler that the expression before it can’t be `null`
    or `undefined`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 非空断言操作符是 TypeScript 中的一个特殊操作符。它用于通知 TypeScript 编译器它前面的表达式不能是 `null` 或 `undefined`。
- en: '`fetch` returns a `Response` object and we call its `json` method to get the
    response body in JSON format. The `json` method is asynchronous, so we need to
    `await` it.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` 返回一个 `Response` 对象，我们调用它的 `json` 方法来获取以 JSON 格式的响应体。`json` 方法是异步的，因此我们需要
    `await` 它。'
- en: 'For more information on `fetch`, see the following link: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `fetch` 的更多信息，请参阅以下链接：[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。
- en: That completes an initial version of `getPosts`. However, the return value type
    from `getPosts` is currently `any`, which means no type checking will occur on
    it. We will improve this next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `getPosts` 的初始版本。然而，`getPosts` 的返回值类型目前是 `any`，这意味着不会对其进行类型检查。我们将在下一步改进这一点。
- en: Strongly typing response data
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强类型响应数据
- en: 'In [*Chapter 2*](B19051_02.xhtml#_idTextAnchor044), *Introducing TypeScript*,
    we learned how to make unknown data strongly typed using the `unknown` type and
    type predicates. We will use the `unknown` type with a slightly different TypeScript
    feature called a `getPosts` function. Carry out the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B19051_02.xhtml#_idTextAnchor044) *介绍 TypeScript* 中，我们学习了如何使用 `unknown`
    类型和使用类型谓词来对未知数据进行强类型化。我们将使用 `unknown` 类型与一个名为 `getPosts` 的 TypeScript 特性一起使用。执行以下步骤：
- en: 'Add a type assertion to the JSON response so that the `body` variable has a
    type of `unknown`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 JSON 响应添加类型断言，以便 `body` 变量具有 `unknown` 类型：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add the following type assertion function beneath `getPosts`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `getPosts` 下方添加以下类型断言函数：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice the return type annotation: `asserts postsData is PostData[]`. This
    is called an `postsData` parameter is of the `PostData[]` type if no error occurs
    in the function execution.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回类型注解：`asserts postsData is PostData[]`。如果没有错误发生，这意味着 `postsData` 参数是 `PostData[]`
    类型。
- en: Don’t worry about the compile error where `PostData` is referenced – we will
    create the `PostData` type in *s**tep 8*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心 `PostData` 被引用时的编译错误 - 我们将在第 8 步创建 `PostData` 类型。
- en: 'Let’s carry on with the implementation of `assertIsPosts`. It will be a series
    of checks on the `postsData` parameter and it will throw an exception if a check
    fails. Start the implementation by checking that `postsData` is an array:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续实现 `assertIsPosts`。它将对 `postsData` 参数进行一系列检查，如果检查失败，它将抛出异常。通过检查 `postsData`
    是否为数组来开始实现：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let’s do a check on the array items to see whether they have an `id` property:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查数组项是否具有 `id` 属性：
- en: '[PRE31]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We loop around all the posts using the array’s `forEach` method. Inside the
    loop, we check that the `id` property exists using the `in` operator. We also
    check that the `id` value is of the `number` type using the `typeof` operator.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数组的 `forEach` 方法遍历所有文章。在循环内部，我们使用 `in` 操作符检查 `id` 属性是否存在。我们还使用 `typeof`
    操作符检查 `id` 值是否为 `number` 类型。
- en: 'We can do similar checks for the `title` and `description` properties:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以对 `title` 和 `description` 属性执行类似的检查：
- en: '[PRE44]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That completes the implementation of the type assertion function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了类型断言函数的实现。
- en: 'Moving back to `getPosts`, add a call to the `assert` function:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `getPosts`，添加对 `assert` 函数的调用：
- en: '[PRE64]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `body` variable will now be of the `PostData[]` type after a successful
    call to `assertIsPosts`. You can hover over the `body` variable in the return
    statement to confirm this.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功调用 `assertIsPosts` 之后，`body` 变量现在将是 `PostData[]` 类型。您可以在返回语句中悬停在 `body` 变量上以确认这一点。
- en: 'The final steps are to add the `PostData` type. Add an import statement at
    the top of `getPosts.ts` as follows to import `PostData`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终步骤是添加 `PostData` 类型。在 `getPosts.ts` 的顶部添加以下导入语句以导入 `PostData`：
- en: '[PRE70]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The file will still have compile errors because the `types` file doesn’t exist
    yet – we’ll do this in the next step.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `types` 文件尚不存在，文件仍将存在编译错误 - 我们将在下一步中完成此操作。
- en: 'Add a file called `types.ts` in the `posts` folder with the following definition
    for the `PostData` type:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `posts` 文件夹中添加一个名为 `types.ts` 的文件，并包含以下 `PostData` 类型的定义：
- en: '[PRE71]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This type represents a blog post from the REST API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型表示来自 REST API 的博客文章。
- en: Now, we have a strongly typed function that gets blog posts from the REST API.
    Next, we will create a React component that lists the blog posts.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个强类型函数，可以从 REST API 获取博客文章。接下来，我们将创建一个 React 组件来列出博客文章。
- en: Creating a blog posts list component
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建博客文章列表组件
- en: 'We will create a React component that takes in the blog post data and renders
    it in a list. Carry out the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 React 组件，它接受博客文章数据并将其以列表形式渲染。执行以下步骤：
- en: 'Create a file called `PostsList.tsx` in the `posts` folder with the following
    import statement:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `posts` 文件夹中创建一个名为 `PostsList.tsx` 的文件，并包含以下导入语句：
- en: '[PRE76]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, start to implement the component as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，开始实现组件，如下所示：
- en: '[PRE77]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The component has a prop called `posts` that will contain the blog posts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有一个名为 `posts` 的属性，它将包含博客文章。
- en: 'Now, render the blog posts in an unordered list, as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式在无序列表中渲染博客文章：
- en: '[PRE82]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The Tailwind CSS classes add gray lines between the blog posts with bold titles.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 类在具有粗体标题的博客文章之间添加灰色线条。
- en: That completes the `PostsList` component. Next, we will create a page component
    that references the `PostsList` component.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `PostsList` 组件。接下来，我们将创建一个引用 `PostsList` 组件的页面组件。
- en: Creating a blog posts page component
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建博客文章页面组件
- en: 'We will create a blog posts page component that gets blog post data using the
    `getPosts` function and renders it using the `PostsList` component we just created.
    Carry out the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个博客文章页面组件，该组件使用 `getPosts` 函数获取博客文章数据，并使用我们刚刚创建的 `PostsList` 组件进行渲染。执行以下步骤：
- en: 'Create a file called `PostsPage.tsx` in the `posts` folder components with
    the following import statements:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `posts` 文件夹的组件中创建一个名为 `PostsPage.tsx` 的文件，并包含以下导入语句：
- en: '[PRE96]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We have imported the `getPosts` function, the `PostList` component, and the
    `PostData` type we created in the last section. We have also imported the `useState`
    and `useEffect` hooks from React. We will use React state to store the blog posts
    and use `useEffect` to call `getPosts` when the page component is mounted.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已导入 `getPosts` 函数、`PostList` 组件以及我们在上一节中创建的 `PostData` 类型。我们还导入了来自 React 的
    `useState` 和 `useEffect` 钩子。我们将使用 React 状态来存储博客文章，并使用 `useEffect` 在页面组件挂载时调用 `getPosts`。
- en: 'Start the implementation of the page component by defining the state for the
    blog posts and whether they are being fetched:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义博客文章的状态以及它们是否正在被获取来开始实现页面组件。
- en: '[PRE100]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, call the `getPosts` function using the `useEffect` hook as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `useEffect` 钩子调用 `getPosts` 函数，如下所示：
- en: '[PRE104]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We use the older promise syntax when calling `getPosts` because the newer `async`/`await`
    syntax can’t be directly used within `useEffect`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调用 `getPosts` 时使用较旧的 promise 语法，因为较新的 `async`/`await` 语法不能直接在 `useEffect`
    中使用。
- en: If the `PostsPage` component is unmounted while the call to `getPosts` is still
    in progress, the setting of the `data` and `isLoading` state variables will result
    in an error. For this reason, we have used a `cancel` flag to ensure that the
    component is still mounted when the `data` and `isLoading` state variables are
    set.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `getPosts` 调用仍在进行时卸载 `PostsPage` 组件，设置 `data` 和 `isLoading` 状态变量将导致错误。因此，我们使用了一个
    `cancel` 标志来确保在设置 `data` 和 `isLoading` 状态变量时组件仍然挂载。
- en: We have also specified an empty array as the effect dependencies so that the
    effect only runs when the component is mounted.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了一个空数组作为效果依赖项，以便效果仅在组件挂载时运行。
- en: 'Add a loading indicator while the data is being fetched after the call to `useEffect`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `useEffect` 调用之后，在数据获取期间添加一个加载指示器：
- en: '[PRE119]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The Tailwind CSS classes position the loading indicator horizontally in the
    center of the page with a bit of margin above it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 类将加载指示器水平放置在页面中心，并在其上方留有一点边距。
- en: 'Finally, render a page title and the posts list after the conditional loading
    indicator:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在条件加载指示器之后渲染页面标题和帖子列表：
- en: '[PRE130]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The Tailwind CSS classes position the list in the center of the page with a
    bit of margin above. A large **Posts** title is also rendered above the list in
    a dark gray color.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 类将列表放置在页面中心，并在其上方留有一点边距。一个大的 **帖子** 标题也以深灰色渲染在列表上方。
- en: 'Now, open `App.tsx` and replace its contents with the following so that it
    renders the page component we just created:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `App.tsx` 并将其内容替换为以下内容，以便渲染我们刚刚创建的页面组件：
- en: '[PRE146]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Run the app by running `npm start` in a new terminal separate from the one
    running the REST API. The loading indicator will appear briefly as the data is
    being fetched:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在新的终端中运行 `npm start` 来运行应用程序，该终端与运行 REST API 的终端分开。在数据被获取时，加载指示器将短暂出现：
- en: '![Figure 9.3 – Loading indicator](img/B19051_09_03.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 加载指示器](img/B19051_09_03.jpg)'
- en: Figure 9.3 – Loading indicator
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 加载指示器
- en: 'The blog post list will then appear as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 博客帖子列表将如下显示：
- en: '![Figure 9.4 – Blog posts list](img/B19051_09_04.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 博客帖子列表](img/B19051_09_04.jpg)'
- en: Figure 9.4 – Blog posts list
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 博客帖子列表
- en: That completes this version of the `PostsPage` component.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `PostsPage` 组件的这个版本。
- en: 'Here are the key points we learned in this section on interacting with HTTP
    `GET` requests in a REST API using `fetch` and `useEffect`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 `fetch` 和 `useEffect` 在 REST API 中与 HTTP `GET` 请求交互的关键点：
- en: '`fetch` will make the actual HTTP request that has the REST API’s URL as a
    parameter'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch` 将执行实际的 HTTP 请求，该请求将 REST API 的 URL 作为参数'
- en: A type assertion function can be used to strongly type response data
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用类型断言函数来为响应数据添加强类型
- en: '`useEffect` can trigger the `fetch` call when the component that holds the
    data in state is mounted'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect` 可以在包含状态数据的组件挂载时触发 `fetch` 调用'
- en: A flag can be used inside `useEffect` to check that the component hasn’t been
    unmounted during the HTTP request before the data state is set
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在 `useEffect` 内部使用一个标志来检查在设置数据状态之前组件是否在 HTTP 请求期间被卸载
- en: Still keeping the app and REST API running, in the next section, we will learn
    how to post data to a REST API using `fetch`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持应用程序和 REST API 运行的情况下，在下一节中，我们将学习如何使用 `fetch` 将数据发布到 REST API。
- en: Posting data with fetch
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fetch 发送数据
- en: In this section, we will create a form that submits a new blog post to our REST
    API. We will create a function that uses `fetch` to post to the REST API. That
    function will be called in the form’s submit handler.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个表单，该表单将新的博客帖子提交到我们的 REST API。我们将创建一个使用 `fetch` 向 REST API 发送数据的函数。该函数将在表单的提交处理程序中被调用。
- en: Creating new blog posts using fetch
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 fetch 创建新的博客帖子
- en: 'We will start by creating the function that sends a new blog post to the REST
    API. This will use the browser’s `fetch` function, but this time, using an HTTP
    `POST` request. Carry out the following steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个函数，该函数将新的博客帖子发送到 REST API。这将使用浏览器的 `fetch` 函数，但这次使用 HTTP `POST` 请求。执行以下步骤：
- en: 'We will start by opening `types.ts` in the `posts` folder and adding the following
    two types:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在“posts”文件夹中的 `types.ts` 文件中打开，并添加以下两个类型：
- en: '[PRE151]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The first type represents a new blog post, and the second type represents the
    data from the API when the blog post is successfully saved.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类型代表一个新的博客帖子，第二个类型代表当博客帖子成功保存时从 API 获取的数据。
- en: 'Create a new file called `savePost.ts` in the `posts` folder and add the following
    import statement:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `posts` 文件夹中创建一个名为 `savePost.ts` 的新文件，并添加以下导入语句：
- en: '[PRE158]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: We have also imported the types we just created.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了我们刚刚创建的类型。
- en: 'Start to implement the `savePost` function as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始实现`savePost`函数如下：
- en: '[PRE159]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The `savePost` function has a parameter, `newPostData`, containing the title
    and description for the new blog post, and sends it to the REST API using `fetch`.
    A second argument has been specified in the `fetch` call to specify that an HTTP
    `POST` request should be used and that the new blog post data should be included
    in the request body. The request body has also been declared as being in JSON
    format.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`savePost`函数有一个参数`newPostData`，包含新博客帖子的标题和描述，并使用`fetch`将其发送到REST API。在`fetch`调用中已指定第二个参数，指定应使用HTTP
    `POST`请求，并将新博客帖子数据包含在请求体中。请求体还声明为JSON格式。'
- en: 'Next, strongly type the response body as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将响应体强类型化如下：
- en: '[PRE173]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: We set the response body as having the `unknown` type and then use a type assertion
    function to give it a specific type. This will raise a compile error until we
    implement `assertIsSavedPost` in *step 6*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将响应体设置为具有`unknown`类型，然后使用类型断言函数给它一个特定的类型。这将引发编译错误，直到我们在*第6步*中实现`assertIsSavedPost`。
- en: 'Finish the implementation of `savePost` by merging the blog post ID from the
    response with the blog post title and description supplied to the function:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过合并响应中的博客帖子ID与函数提供的博客帖子标题和描述来完成`savePost`的实现：
- en: '[PRE178]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: So, the object returned from the function will be a new blog post with the ID
    from the REST API.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该函数返回的对象将是一个带有REST API ID的新博客帖子。
- en: 'The last step is to implement the type assertion function:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是实现类型断言函数：
- en: '[PRE182]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: The function checks whether the response data contains a numeric `id` property,
    and if it does, it asserts that the data is of the `SavedPostData` type.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数检查响应数据是否包含一个数字`id`属性，如果包含，则断言数据是`SavedPostData`类型。
- en: That completes the implementation of the `savePost` function. Next, we will
    add a form component that allows the user to enter new blog posts.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了`savePost`函数的实现。接下来，我们将添加一个表单组件，允许用户输入新的博客帖子。
- en: Creating a blog post form component
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建博客帖子表单组件
- en: We will create a component that contains a form that captures a new blog post.
    When the form is submitted, it will call the `savePost` function we just created.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含表单的组件，该表单用于捕获新的博客帖子。当表单提交时，它将调用我们刚刚创建的`savePost`函数。
- en: We will use React Hook Form to implement the form along with a `ValidationError`
    component. We covered React Hook Form and the `ValidationError` component in detail
    in [*Chapter 7*](B19051_07.xhtml#_idTextAnchor188), so the implementation steps
    won’t be covered in much detail.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用React Hook Form实现表单，以及一个`ValidationError`组件。我们在[*第7章*](B19051_07.xhtml#_idTextAnchor188)中详细介绍了React
    Hook Form和`ValidationError`组件，因此实现步骤不会详细说明。
- en: 'Carry out the following steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We will start by creating a `ValidationError` component that will render form
    validation errors. Create a file called `ValidationError.tsx` in the `posts` folder
    with the following content:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`ValidationError`组件，该组件将渲染表单验证错误。在`posts`文件夹中创建一个名为`ValidationError.tsx`的文件，内容如下：
- en: '[PRE192]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Create a new file in the `posts` folder called `NewPostForm.tsx`. This will
    contain a form to capture the title and description for a new blog post. Add the
    following import statements to the file:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`posts`文件夹中创建一个名为`NewPostForm.tsx`的新文件。这个文件将包含一个用于捕获新博客帖子标题和描述的表单。将该文件中的以下导入语句添加到文件中：
- en: '[PRE206]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Start to implement the form component as follows:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始实现表单组件如下：
- en: '[PRE209]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: The component has a prop for saving a new blog post so that the interaction
    with the REST API can be handled outside of this form component.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件有一个用于保存新博客帖子的prop，以便可以在表单组件之外处理与REST API的交互。
- en: 'Now, destructure the `register` and `handleSubmit` functions and useful state
    variables from React Hook Form’s `useForm` hook:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从React Hook Form的`useForm`钩子中解构`register`和`handleSubmit`函数以及有用的状态变量：
- en: '[PRE214]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: We pass the type for the new post data into the `useForm` hook so it knows the
    shape of the data to capture.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新帖数据的类型传递给`useForm`钩子，以便它知道要捕获的数据的形状。
- en: 'Create a variable for the field container style and a function for the editor
    style:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为字段容器样式创建一个变量，为编辑器样式创建一个函数：
- en: '[PRE224]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Render `title` and `description` fields in a `form` element as follows:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`form`元素中按如下方式渲染`title`和`description`字段：
- en: '[PRE233]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'Lastly, render a `Save` button and the success message:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，渲染一个`保存`按钮和成功消息：
- en: '[PRE267]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: That completes the implementation of the `NewPostForm` component.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了`NewPostForm`组件的实现。
- en: 'Now open `PostPage.tsx` and import the `NewPostForm` component and the `savePost`
    function we created earlier. Also, import the `NewPostData` type:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `PostPage.tsx` 文件并导入我们之前创建的 `NewPostForm` 组件和 `savePost` 函数。同时，导入 `NewPostData`
    类型：
- en: '[PRE292]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'In the `PostPage` JSX, add the `NewPostForm` form above the `PostsList`:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PostPage` JSX 中，将 `NewPostForm` 表单添加到 `PostsList` 之上：
- en: '[PRE298]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Add the save handler function just below the effect that gets blog posts:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取博客文章的效果下方添加保存处理函数：
- en: '[PRE303]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE309]'
- en: The hander calls `savePost` with the data from the form. After the post has
    been saved, it is added to the start of the `posts` array.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理函数调用 `savePost` 并传入表单中的数据。文章保存后，它将被添加到 `posts` 数组的开头。
- en: 'In the running app, the new blog post form will appear above the blog post
    list, as follows:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行的应用程序中，新的博客文章表单将出现在博客文章列表上方，如下所示：
- en: '![Figure 9.5 – New blog post form above the posts list](img/B19051_09_05.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 新博客文章表单位于文章列表上方](img/B19051_09_05.jpg)'
- en: Figure 9.5 – New blog post form above the posts list
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 新博客文章表单位于文章列表上方
- en: Fill in the form with a new blog post and press the **Save** button. The new
    post should appear at the top of the list after a couple of seconds.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一篇新的博客文章填写表单并按下 **保存** 按钮。几秒钟后，新文章应该出现在列表的顶部。
- en: '![Figure 9.6 – New blog post added to posts list](img/B19051_09_06.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 新博客文章添加到文章列表中](img/B19051_09_06.jpg)'
- en: Figure 9.6 – New blog post added to posts list
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 新博客文章添加到文章列表中
- en: That completes the implementation of the form and its integration into the blog
    posts page.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了表单的实现及其与博客文章页面的集成。
- en: 'Here are a couple of key points we learned in this section on posting data
    with `fetch`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节关于使用 `fetch` 发送数据的几个关键点如下：
- en: The second parameter in the `fetch` function allows the HTTP method to be specified.
    In this section, we used this parameter to make an HTTP `POST` request.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch` 函数的第二个参数允许指定 HTTP 方法。在本节中，我们使用此参数进行 HTTP `POST` 请求。'
- en: The second parameter in `fetch` also allows the request body to be supplied.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch` 函数的第二个参数还允许提供请求体。'
- en: Once again, keeping the app and REST API running, in the next section, we will
    use React Router’s data-fetching capabilities to simplify our data-fetching code.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 再次保持应用程序和 REST API 运行，在下一节中，我们将使用 React Router 的数据获取功能来简化我们的数据获取代码。
- en: Using React Router
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Router
- en: In this section, we will learn about how React Router can integrate with the
    data-fetching process. We will use this knowledge to simplify the code that fetches
    blog posts in our app.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解 React Router 如何与数据获取过程集成。我们将使用这些知识来简化我们应用程序中获取博客文章的代码。
- en: Understanding React Router data loading
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 React Router 数据加载
- en: 'React Router data loading is similar to React Router forms, which we learned
    about in [*Chapter 7*](B19051_07.xhtml#_idTextAnchor188). Instead of defining
    an action that handles form submission, we define a `some-page` route:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 的数据加载与 React Router 表单类似，我们在 [*第7章*](B19051_07.xhtml#_idTextAnchor188)
    中学习过。我们不是定义一个处理表单提交的动作，而是定义一个 `some-page` 路由：
- en: '[PRE310]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'React Router calls the loader to get the data before it renders the component
    defined on the route. The data is then available in the component via a `useLoaderData`
    hook:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 在渲染路由上定义的组件之前调用加载器以获取数据。然后，数据通过 `useLoaderData` 钩子可用在组件中：
- en: '[PRE311]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: This approach is efficient as the route component is only rendered once because
    the data is available on the first render.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法效率很高，因为路由组件只渲染一次，因为数据在第一次渲染时就已经可用。
- en: 'For more information on React Router loaders, see the following link: [https://reactrouter.com/en/main/route/loader](https://reactrouter.com/en/main/route/loader).
    For more information on the `useLoaderData` hook, see the following link: [https://reactrouter.com/en/main/hooks/use-loader-data](https://reactrouter.com/en/main/hooks/use-loader-data).'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 React Router 加载器的信息，请参阅以下链接：[https://reactrouter.com/en/main/route/loader](https://reactrouter.com/en/main/route/loader)。更多关于
    `useLoaderData` 钩子的信息，请参阅以下链接：[https://reactrouter.com/en/main/hooks/use-loader-data](https://reactrouter.com/en/main/hooks/use-loader-data)。
- en: Now that we are starting to understand data loading in React Router, we will
    use this in our app.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始理解 React Router 中的数据加载，我们将在我们的应用程序中使用它。
- en: Using React Router for data loading
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React Router 进行数据加载
- en: 'Carry out the following steps to use a React Router data loader in our app:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在我们的应用程序中使用 React Router 数据加载器：
- en: 'Open `App.tsx` and add the following import statement:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.tsx` 文件并添加以下导入语句：
- en: '[PRE312]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'Also, import the `getPosts` function:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，导入 `getPosts` 函数：
- en: '[PRE316]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '`getPosts` will be the loader function.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPosts` 将是加载函数。'
- en: 'Add the following router definition above the `App` component:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App` 组件上方添加以下路由定义：
- en: '[PRE317]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'In the `App` component, replace `PostsPage` with `RouterProvider`:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App` 组件中，将 `PostsPage` 替换为 `RouterProvider`：
- en: '[PRE324]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE326]'
- en: Open `PostsPage.tsx` and remove the React import statement, as this is no longer
    required in this component.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PostsPage.tsx` 并移除 React 导入语句，因为在这个组件中不再需要它。
- en: 'Also, add `assertIsPosts` to the `getPosts` import statement and remove `getPosts`:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将 `assertIsPosts` 添加到 `getPosts` 导入语句中，并移除 `getPosts`：
- en: '[PRE327]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE327]'
- en: We will eventually need `assertIsPosts` to type the data.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终需要 `assertIsPosts` 来类型化数据。
- en: 'Still in `PostsPage.tsx`, add the following import statement for a hook in
    React Router that allows us to access the loader data:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `PostsPage.tsx` 中，添加以下导入语句，以便使用 React Router 中的一个钩子，该钩子允许我们访问加载器数据：
- en: '[PRE328]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE328]'
- en: Inside the `PostsPage` component, remove the `isLoading` and `posts` state definitions.
    These won’t be needed because we will get the data from React Router without having
    to do any waiting.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PostsPage` 组件内部，移除 `isLoading` 和 `posts` 状态定义。这些将不再需要，因为我们将从 React Router
    获取数据，而无需等待。
- en: Remove the call to `useEffect` that currently gets the data.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除当前获取数据的 `useEffect` 调用。
- en: 'Remove the second line of the `handleSave` function that sets the `posts` state.
    `handleSave` should now read as follows:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `handleSave` 函数的第二行，该行设置 `posts` 状态。`handleSave` 现在应如下所示：
- en: '[PRE329]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE331]'
- en: Remove the loading indicator as well.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时移除加载指示器。
- en: 'Now at the top of the `PostsPage` component, make a call to `useLoaderData`
    and assign the result to a `posts` variable:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `PostsPage` 组件的顶部，调用 `useLoaderData` 并将结果分配给 `posts` 变量：
- en: '[PRE332]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'Unfortunately, `posts` is of the `unknown` type, so there is a type error where
    it is passed to the `PostsLists` component. Use the `assertsIsPosts` function
    to type the data with `PostData[]`:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很不幸，`posts` 是 `unknown` 类型，因此在传递给 `PostsLists` 组件时存在类型错误。使用 `assertsIsPosts`
    函数将数据类型化为 `PostData[]`：
- en: '[PRE336]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE337]'
- en: The type errors are now resolved.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误现在已解决。
- en: Note that `PostData` from the `types` import statement is unused. Leave it intact
    because we will use this again in the next section.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从 `types` 导入语句中导入的 `PostData` 未使用。保持其完整性，因为我们将在下一节再次使用它。
- en: The running app should look and behave similarly to how it previously did. One
    thing you may notice is that when a new blog post is added using the form, it
    doesn’t appear in the list – you have to manually refresh the page for it to appear.
    This will be resolved when we use React Query later in this chapter.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行的应用程序应该看起来和表现与之前相似。你可能注意到的一点是，当使用表单添加新的博客文章时，它不会出现在列表中——你必须手动刷新页面才能看到它。当我们在本章后面使用
    React Query 时，这将被解决。
- en: Notice how much code we just removed – this indicates that the code is much
    simpler now. Another benefit of using React Router to load the data is that `PostsPage`
    isn’t re-rendered after the data is fetched – the data is fetched before `PostsPage`
    is rendered.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们刚刚移除了多少代码——这表明代码现在变得更加简单。使用 React Router 加载数据的另一个好处是，在数据获取后，`PostsPage`
    不会重新渲染——数据是在 `PostsPage` 渲染之前获取的。
- en: Next, we will improve the user experience of the data-fetching process.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将改进数据获取过程的用户体验。
- en: Deferred React Router data fetching
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟 React Router 数据获取
- en: 'If the data-fetching process is slow, there will be a noticeable delay before
    a component is rendered by React Router. Fortunately, there is a solution to this
    using React Router’s `defer` function and `Await` component, along with React’s
    `Suspense` component. Carry out the following steps to add these to our app:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据获取过程缓慢，React Router 渲染组件之前会有明显的延迟。幸运的是，我们可以通过使用 React Router 的 `defer` 函数和
    `Await` 组件，以及 React 的 `Suspense` 组件来解决这个问题。执行以下步骤将它们添加到我们的应用程序中：
- en: 'Start by opening `App.tsx` and add the `defer` function to the React Router
    import statement:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开 `App.tsx` 并将 `defer` 函数添加到 React Router 导入语句中：
- en: '[PRE338]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'Update the `loader` function as follows in the route definition:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由定义中按照以下方式更新 `loader` 函数：
- en: '[PRE343]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE349]'
- en: React Router’s `defer` function takes in an object of promised data. The property
    name in the object is a unique key for the data, which is `posts` in our case.
    The value is the function that fetches the data, which is `getPosts` in our case.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 的 `defer` 函数接收一个包含承诺数据的对象。对象中的属性名是数据的唯一键，在我们的例子中是 `posts`。值是获取数据的函数，在我们的例子中是
    `getPosts`。
- en: Notice that we don’t await `getPosts` because we want the loader to complete
    and `PostsPage` to immediately render.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有等待 `getPosts`，因为我们希望加载器完成，并且 `PostsPage` 立即渲染。
- en: 'Open `PostsPage.tsx` and add an import statement for React’s `Suspense` component:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE350]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'Add the `Await` component to the React Router import statement:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE351]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'In the component, update the call to `useLoaderData` to assign the result to
    a `data` variable instead of `posts`:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE352]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE352]'
- en: The shape of the loader data is a little different now – it will be an object
    containing a `posts` property containing the blog posts. The blog posts also won’t
    immediately be there as they previously were – the `data.posts` property will
    contain a promise for the blog posts instead.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Also, remove the call to `assertIsPosts` – we will use this later in *step 9*.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `data` variable is of the `unknown` type, so add a type assertion function
    beneath the component that can be used to strongly type it:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE353]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE368]'
- en: The type assertion function checks that the `data` parameter is an object containing
    a `posts` property.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the assertion function to type the `data` variable in the component:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE369]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'In the JSX, wrap `Suspense` and `Await` around `PostsList` as follows:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE371]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '`Suspense` and `Await` work together to only render `PostsLists` when the data
    has been fetched. We use `Suspense` to render a `assertIsPosts` to ensure that
    `posts` is typed correctly.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'In the running app, you will now notice the **Fetching…** message when the
    page loads:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Fetching message during data fetching](img/B19051_09_07.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Fetching message during data fetching
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Stop the app from running by pressing *Ctrl* + *C* in the terminal that is running
    the app but keep the API running.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The great thing about this solution is that a re-render still doesn’t occur
    when `PostsPage` is rendered because of the use of `Suspense` and `Await`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now quickly recap what we have learned with React Router’s data-fetching
    capabilities:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: React Router’s `loader` allows us to efficiently load fetched data into a route
    component
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Router’s `defer` allows the route component not to be blocked from rendering
    the component while data is being fetched
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Router’s `useLoaderData` hook allows a component to access a route’s loader
    data
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React’s `Suspense` and React Router’s `Await` allow a component to render while
    data is still being fetched
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on deferred data in React Router, see the following link:
    [https://reactrouter.com/en/main/guides/deferred](https://reactrouter.com/en/main/guides/deferred).'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use another popular library for managing server
    data to further improve the user experience.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Using React Query
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Query is a popular library for interacting with REST APIs. The key thing
    it does is manage the state surrounding REST API calls. One thing that it does
    that React Router doesn’t is that it maintains a cache of the fetched data, which
    improves the perceived performance of an app.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will refactor the app to use React Query rather than React
    Router’s loader capability. We will then refactor the app again to use both React
    Query and React Router’s loader to get the best of both these worlds.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: Installing React Query
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first job is to install React Query, which we can do by running the following
    command in a terminal:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: This library includes TypeScript types, so no additional package is required
    to be installed.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: Adding the React Query provider
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Query requires a provider component in the component tree above the components
    that need access to the data it manages. Eventually, React Query will hold the
    blog post data in our app. Carry out the following steps to add the React Query
    provider component to the `App` component:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `App.tsx` and add the following import statement:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE380]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '`QueryClient` provides access to the data. `QueryClientProvider` is the provider
    component we need to place in the component tree.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap `QueryClientProvider` around `RouterProvider` as follows:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE384]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '`QueryClientProvider` requires an instance of `QueryClient` to be passed into
    it, so we create this instance outside of the `App` component. We place the `queryClient`
    variable above the router definition because we will eventually use it in the
    router definition.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: The `PostsPage` component now has access to React Query. Next, we will use React
    Query in `PostsPage`.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Getting data using React Query
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Query refers to a request to fetch data as a `useQuery` hook to carry
    out this. We will use React Query’s `useQuery` hook in the `PostsPage` component
    to call the `getPosts` function and store the data it returns. This will temporarily
    replace the use of React Router’s loader. Carry out the following steps:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `useQuery` from React Query:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE393]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE393]'
- en: 'Add `getPosts` to the `getPosts` import statement:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE394]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE394]'
- en: We will eventually use `getPosts` to fetch data and store it within React Query.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PostPage` component, comment out the `data` variable:'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE395]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE396]'
- en: We are commenting these lines out rather than removing them because we will
    use them again in the next section when we use React Router and React Query together.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a call to `useQuery` as follows:'
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE397]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE406]'
- en: The first argument passed to `useQuery` is a unique key for the data. This is
    because React Query can store many datasets and uses the key to identify each
    one. The key is an array containing the name given to the data in our case. However,
    the key array could include things like the ID of a particular record we want
    to fetch or a page number if we want to only fetch a page of records.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: The second argument passed to `useQuery` is the fetching function, which is
    our existing `getPosts` function.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'We have destructured the following state variables:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '`isLoading` – Whether the component is being loaded for the first time.'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFetching` – Whether the fetching function is being called. React Query will
    refetch data when it thinks it is stale. We will experience refetching later when
    we play with the app.'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data` – The data that has been fetched. We have aliased this `posts` variable
    to match the previous `posts` state value. Keeping the same name minimizes the
    changes required in the rest of the component.'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` – 已获取的数据。我们将此 `posts` 变量别名为 `posts` 以匹配之前的 `posts` 状态值。保持相同的名称可以最小化对组件其余部分的更改。'
- en: Note
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are other useful state variables that can be destructured from `useQuery`.
    An example is `isError`, which indicates whether the `fetch` function errored.
    See the following link for more information: [https://tanstack.com/query/v4/docs/reference/useQuery](https://tanstack.com/query/v4/docs/reference/useQuery).'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `useQuery` 中可以解构出其他有用的状态变量。一个例子是 `isError`，它表示 `fetch` 函数是否出错。有关更多信息，请参阅以下链接：[https://tanstack.com/query/v4/docs/reference/useQuery](https://tanstack.com/query/v4/docs/reference/useQuery)。
- en: 'Add a loading indicator above the return statement:'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在返回语句上方添加一个加载指示器：
- en: '[PRE407]'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE414]'
- en: The check for the `posts` state being `undefined` means that the TypeScript
    compiler knows that `posts` isn’t `undefined` when referenced in the JSX.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `posts` 状态是否为 `undefined` 表示 TypeScript 编译器知道在 JSX 中引用 `posts` 时它不是 `undefined`。
- en: 'In the JSX, comment out `Suspense` and its children:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JSX 中，注释掉 `Suspense` 及其子元素：
- en: '[PRE415]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE428]'
- en: We have commented this block out rather than removing it because we will revert
    to it in the next section when we use React Router and React Query together.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此代码块注释掉而不是删除它，因为我们将在下一节中使用 React Router 和 React Query 一起使用时恢复它。
- en: 'When data is being fetched, display a fetching indicator and render the blog
    posts when the data has been fetched:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数据正在获取时，显示一个获取指示器，并在数据获取后渲染博客文章：
- en: '[PRE429]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE438]'
- en: Run the app by running `npm start` in the terminal. The blog post page will
    appear the same as it did before. A technical difference is that the `PostsPage`
    is re-rendered after the data has been fetched.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行 `npm start` 来运行应用。博客文章页面将显示与之前相同。一个技术差异是 `PostsPage` 在数据获取后会被重新渲染。
- en: 'Leave the browser window and set the focus to a different window, such as your
    code editor. Now, set your focus back on the browser window and notice that the
    fetching indicator appears for a split second:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 离开浏览器窗口并将焦点设置到不同的窗口，例如您的代码编辑器。现在，将焦点重新设置到浏览器窗口，注意获取指示器会短暂出现：
- en: '![Figure 9.8 – Fetching indicator when data is refetched](img/B19051_09_08.jpg)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 数据重新获取时的获取指示器](img/B19051_09_08.jpg)'
- en: Figure 9.8 – Fetching indicator when data is refetched
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 数据重新获取时的获取指示器
- en: 'This is because React Query, by default, assumes that data is stale when the
    browser regains focus. For more information on this behavior, see the following
    link in the React Query documentation: [https://tanstack.com/query/v4/docs/guides/window-focus-refetching](https://tanstack.com/query/v4/docs/guides/window-focus-refetching).'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 React Query 默认假设当浏览器恢复焦点时数据已过时。有关此行为的更多信息，请参阅 React Query 文档中的以下链接：[https://tanstack.com/query/v4/docs/guides/window-focus-refetching](https://tanstack.com/query/v4/docs/guides/window-focus-refetching)。
- en: 'A great feature of React Query is that it maintains a cache of the data. This
    allows us to render components with data from the cache while fresh data is being
    fetched. To experience this, in the `PostsPage` JSX, remove the `isFetching` condition
    for when `PostsList` is rendered:'
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React Query 的一个伟大特性是它维护数据缓存。这允许我们在获取新鲜数据的同时渲染带有缓存数据的组件。为了体验这一点，在 `PostsPage`
    JSX 中，移除 `PostsList` 渲染时的 `isFetching` 条件：
- en: '[PRE439]'
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE439]'
- en: So, `PostsList` will now render even if the data is stale.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使数据已过时，`PostsList` 也会渲染。
- en: In the running app, press *F5* to refresh the page. Then, leave the browser
    window and set the focus to a different window. Set your focus back on the browser
    window and notice that no fetching indicator appears and the blog posts list remains
    intact.
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行的应用中，按 *F5* 刷新页面。然后，离开浏览器窗口并将焦点设置到不同的窗口。将焦点重新设置到浏览器窗口并注意没有获取指示器出现，博客文章列表保持完整。
- en: 'Repeat the previous step but this time, observe the **Network** tab in the
    browser’s DevTools. Notice that a second network request is made when the app
    is refocused:'
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤，但这次，观察浏览器 DevTools 中的 **网络** 选项卡。注意当应用重新聚焦时，会发起第二个网络请求：
- en: '![Figure 9.9 – Two API requests for blog posts](img/B19051_09_09.jpg)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 两个博客文章的 API 请求](img/B19051_09_09.jpg)'
- en: Figure 9.9 – Two API requests for blog posts
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 两个博客文章的 API 请求
- en: So, React Query seamlessly allows the component to render the old data and re-renders
    it with the new data after it has been fetched.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，React Query 无缝地允许组件渲染旧数据，并在数据被获取后用新数据重新渲染。
- en: Next, we will continue to refactor the posts page to use React Query when a
    new blog post is sent to the API.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Updating data using React Query
  id: totrans-702
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Query can update data using a feature called `useMutation` hook. Carry
    out the following steps in `PostsPage.tsx` to change the saving of a new blog
    post to use a React Query mutation:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the React Query import as follows:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE440]'
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE444]'
- en: The `useMutation` hook allows us to carry out a mutation. The `useQueryClient`
    hook will enable us to get the instance of `queryClient` that the component is
    using and access and update the cached data.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to `useMutation` after the call to `useQuery` as follows:'
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE445]'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-713
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE450]'
- en: We pass `useMutation` the function that performs the REST API HTTP `POST` request.
    We destructure the `mutate` function from the return value of `useMutation`, which
    we will use in *step 4* to trigger the mutation.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other useful state variables that can be destructured from `useMutation`.
    An example is `isError`, which indicates whether the `fetch` function errored.
    See the following link for more information: [https://tanstack.com/query/v4/docs/reference/useMutation](https://tanstack.com/query/v4/docs/reference/useMutation).'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: 'When the mutation has successfully been completed, we want to update the `posts`
    cache to contain the new blog post. Make the following highlighted changes to
    implement this:'
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE451]'
  id: totrans-722
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-725
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-733
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE465]'
- en: The second argument on `useMutation` allows the mutation to be configured. The
    `onSuccess` configuration option is a function called when the mutation has been
    successfully completed.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '`useQueryClient` returns the query client that the component is using. This
    query client has a method called `setQueryData`, which allows the cached data
    to be updated. `setQueryData` has arguments for the key of the cached data and
    the new copy of data to be cached.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'We can trigger the mutation when the new post is saved by calling the destructured
    `mutate` function in the `onSave` prop on the `NewPostForm` JSX element:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE466]'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE466]'
- en: Now, we can remove the `handleSave` function because this is now redundant.
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The imported `NewPostData` type can be removed as well. This type’s import
    statement should now be as follows:'
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE467]'
  id: totrans-743
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'In the running app, if you enter and save a new blog post, it will appear in
    the list as in the previous implementation:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – New blog post added to posts list](img/B19051_09_10.jpg)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – New blog post added to posts list
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the refactoring of saving new blog posts to use a React Query
    mutation. That also completes this section on React Query – here’s a recap of
    the key points:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: React Query is a popular library that manages data from a backend API in a cache,
    helping to improve performance
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Query doesn’t actually make the HTTP requests – the browser’s `fetch`
    function can be used to do this
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Query’s `QueryClientProvider` component needs to be placed high in the
    component tree above where backend data is needed
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Query’s `useQuery` hook allows data to be fetched and cached in state
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Query’s `useMutation` hook allows data to be updated
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Query的`useMutation`钩子允许更新数据
- en: 'For more information on React Query, visit the library’s documentation site:
    [https://tanstack.com/query](https://tanstack.com/query).'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于React Query的信息，请访问库的文档网站：[https://tanstack.com/query](https://tanstack.com/query)。
- en: Next, we will learn how to integrate React Query into React Router’s data-fetching
    capabilities.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将React Query集成到React Router的数据获取能力中。
- en: Using React Router with React Query
  id: totrans-755
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Router与React Query
- en: So far, we have experienced the benefits of both React Router and React Query
    data fetching. React Router reduces the number of re-renders, while React Query
    provides a client-side cache of the data. In this section, we will use these libraries
    together in our app so that it has both these benefits.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经体验到了React Router和React Query数据获取的好处。React Router减少了重新渲染的次数，而React
    Query提供了数据的客户端缓存。在本节中，我们将将这些库结合到我们的应用程序中，以便它具有这两个好处。
- en: 'Carry out the following steps:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Start by opening `App.tsx` and change the loader function on the route definition
    to the following:'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`App.tsx`并将路由定义上的loader函数更改为以下内容：
- en: '[PRE468]'
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-762
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-769
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-770
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-771
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-772
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-773
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-774
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-775
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-776
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-777
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE487]'
- en: Inside the loader, we use React Query’s `getQueryData` function on the query
    client to get the existing data from its cache. If there is cached data, it is
    returned; otherwise, the data is fetched, deferred, and added to the cache.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在loader内部，我们使用查询客户端上的React Query的`getQueryData`函数从其缓存中获取现有数据。如果有缓存数据，则返回；否则，数据将被检索、延迟并添加到缓存中。
- en: Open `PostsPage.tsx` and remove the use of React Query’s `useQuery` because
    the React Router loader manages the data loading process now.
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PostsPage.tsx`并移除React Query的`useQuery`的使用，因为现在React Router的loader管理数据加载过程。
- en: Remove the `getPosts` function from the `getPosts` import statement because
    this is used in the React Router loader now.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`getPosts`导入语句中移除`getPosts`函数，因为现在这个函数在React Router的loader中使用了。
- en: Also, remove the loading indicator because we will revert to using React Suspense
    in *step 6*.
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，移除加载指示器，因为我们将在*第6步*中恢复使用React Suspense。
- en: 'The data will be retrieved using React Router’s `useLoaderData` hook again,
    so uncomment those two lines of code:'
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据将再次使用React Router的`useLoaderData`钩子检索，因此取消注释这两行代码：
- en: '[PRE488]'
  id: totrans-784
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-785
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-786
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-787
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-788
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-789
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-790
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE494]'
- en: 'Also, reinstate the use of `Suspense` and `Await` in the JSX. The JSX should
    be as follows now:'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，恢复在JSX中使用`Suspense`和`Await`。JSX现在应该是这样的：
- en: '[PRE495]'
  id: totrans-792
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-793
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-794
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-795
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-796
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-798
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-800
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-802
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-803
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-804
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-805
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE508]'
- en: The running app will appear and display the blog posts just as before, but a
    second render of `PostsPage` will no longer occur when the app is first loaded.
    However, after adding a new blog post using the form, it doesn’t appear in the
    list. We will resolve this in the next step.
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行中的应用程序将像以前一样显示博客文章，但首次加载应用程序时，`PostsPage`将不再发生第二次渲染。然而，在通过表单添加新的博客文章后，它不会出现在列表中。我们将在下一步中解决这个问题。
- en: 'After the new blog post has been saved, we need to cause the route component
    to re-render in order to get the latest data. We can do this by causing the router
    to navigate to the page we are already on, as follows:'
  id: totrans-807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存新的博客文章后，我们需要使路由组件重新渲染以获取最新数据。我们可以通过使路由导航到我们当前所在的页面来实现，如下所示：
- en: '[PRE509]'
  id: totrans-808
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-809
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-810
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-811
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-812
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-813
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-814
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-815
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-816
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-817
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-818
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-819
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-820
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-821
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-822
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-823
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-824
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-825
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-826
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-827
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-828
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-829
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-830
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-831
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-832
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-833
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE534]'
- en: We perform the navigation after the blog post has been saved and added to the
    cache. This means the route’s loader will execute and populate its data from the
    cache. `PostsPage` will then be rendered with `useLoaderData` returning the up-to-date
    data.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 在博客文章保存并添加到缓存后执行导航。这意味着路由的loader将执行并从缓存中填充其数据。然后`PostsPage`将使用`useLoaderData`返回的最新数据渲染。
- en: 'That completes this final revision of the app and this section on using React
    Router with React Query. By integrating these two libraries, we get the following
    key benefits of each library:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了应用程序的最终修订和本节关于使用React Router与React Query的内容。通过集成这两个库，我们获得了每个库的关键好处：
- en: React Router’s data loader prevents an unnecessary re-render when data is loaded
    onto a page
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router的数据加载器防止在页面加载数据时发生不必要的重新渲染
- en: React Query’s cache prevents unnecessary calls to the REST API
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Query的缓存防止了对REST API的不必要调用
- en: The way these two libraries integrate is to get and set data in the React Query
    cache, in the React Router loader.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库的集成方式是在React Router的loader中获取和设置数据，在React Query缓存中。
- en: Summary
  id: totrans-839
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used the browser’s `fetch` function to make HTTP `GET` and
    `POST` requests. The request’s URL is the first argument on the `fetch` function.
    The second argument on `fetch` allows the request options to be specified, such
    as the HTTP method and body.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了浏览器的`fetch`函数来发起HTTP `GET`和`POST`请求。请求的URL是`fetch`函数的第一个参数。`fetch`函数的第二个参数允许指定请求选项，例如HTTP方法和正文。
- en: A type assertion function can be used to strongly type the data in the response
    body of an HTTP request. The function takes in the data having an `unknown` type.
    The function then carries out checks to validate the type of data and throws an
    error if it is invalid. If no errors occur, the asserted type for the data is
    specified in the functions assertion signature.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类型断言函数来为HTTP请求响应体中的数据强类型。该函数接收具有`unknown`类型的数据。然后，该函数执行检查以验证数据的类型，如果数据无效，则抛出错误。如果没有错误发生，则在函数的类型断言签名中指定数据断言的类型。
- en: React’s `useEffect` hook can be used to execute a call to fetch data from a
    backend API and store the data in the state when the component is mounted. A flag
    can be used inside `useEffect` to ensure the component is still mounted after
    the HTTP request before the data state is set.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: React的`useEffect`钩子可以用来在组件挂载时执行从后端API获取数据并存储到状态的调用。可以在`useEffect`内部使用一个标志来确保在设置数据状态之前，组件在HTTP请求后仍然挂载。
- en: React Query and React Router replace the use of `useEffect` and `useState` in
    the data-fetching process and simplify our code. React Router’s loader function
    allows data to be fetched and passed into the component route removing an unnecessary
    re-render. React Query contains a cache that can be used in components to render
    data optimistically while up-to-date data is being fetched. React Query also contains
    a `useMutation` hook to enable data to be updated.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: React Query和React Router替换了数据获取过程中的`useEffect`和`useState`的使用，并简化了我们的代码。React
    Router的loader函数允许数据被获取并传递到组件路由中，从而消除了不必要的重新渲染。React Query包含一个可以在组件中使用的缓存，可以在获取最新数据的同时乐观地渲染数据。React
    Query还包含一个`useMutation`钩子，用于启用数据的更新。
- en: In the next chapter, we will cover how to interact with GraphQL APIs.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何与GraphQL API交互。
- en: Questions
  id: totrans-845
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to check what you have learned in this chapter:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以检查你在本章中学到了什么：
- en: 'The following effect attempts to fetch data from a REST API and store it in
    the state:'
  id: totrans-847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下效果尝试从REST API获取数据并将其存储在状态中：
- en: '[PRE535]'
  id: totrans-848
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-849
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-850
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-851
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-852
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE539]'
- en: What are the problems with this implementation?
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现有什么问题？
- en: 'The following fetching function returns an array of first names:'
  id: totrans-854
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下获取函数返回一个包含首字母的数组：
- en: '[PRE540]'
  id: totrans-855
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-856
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-857
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-858
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-859
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE544]'
- en: However, the return type of the function is `any`. So, how can we improve the
    implementation to have a return type of `string[]`?
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该函数的返回类型是`any`。那么，我们如何改进实现，使其返回类型为`string[]`？
- en: In the `fetch` function argument, what should be specified in the `method` option
    for it to make an HTTP `PUT` request?
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`fetch`函数参数中，应该指定什么`method`选项才能使其发起HTTP `PUT`请求？
- en: '[PRE545]'
  id: totrans-862
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-863
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-864
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-865
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE548]'
- en: How do you specify a bearer token in an HTTP `Authorization` header when making
    an HTTP request to a protected resource using `fetch`?
  id: totrans-866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`fetch`向受保护的资源发起HTTP请求时，如何在HTTP `Authorization`头中指定bearer令牌？
- en: 'A component uses React Query’s `useQuery` to fetch data but the component errors
    with the following error:'
  id: totrans-867
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个组件使用React Query的`useQuery`来获取数据，但组件出现以下错误：
- en: '**Uncaught Error: No QueryClient set, use QueryClientProvider to** **set one**'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '**未捕获错误：未设置QueryClient，请使用QueryClientProvider设置一个**'
- en: What do you think the problem is?
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为问题是什么？
- en: What state variable can be destructured from React Query’s `useMutation` to
    determine whether the HTTP request has returned an error?
  id: totrans-870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以从React Query的`useMutation`中解构哪个状态变量来确定HTTP请求是否返回了错误？
- en: Answers
  id: totrans-871
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'There are two problems with the implementation:'
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现有两个问题：
- en: '`useEffect` doesn’t support top-level `async`/`await`'
  id: totrans-873
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect`不支持顶层`async`/`await`'
- en: If the component is umounted during the HTTP request, an error will occur when
    the `data` state is set
  id: totrans-874
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在HTTP请求期间组件卸载，则在设置`data`状态时将发生错误
- en: 'Here is an implementation with those issues resolved:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个解决了这些问题的实现：
- en: '[PRE549]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: 'An `assert` function can be used on the response body object as follows:'
  id: totrans-877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在响应体对象上使用`assert`函数如下：
- en: '[PRE550]'
  id: totrans-878
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-879
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-880
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-881
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-882
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-883
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-884
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-885
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-886
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-887
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-888
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-889
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-890
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-891
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-892
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-893
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-894
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-895
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-896
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-897
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-898
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE570]'
- en: 'The method option should be `''PUT''`:'
  id: totrans-899
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法选项应该是`'PUT'`：
- en: '[PRE571]'
  id: totrans-900
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-901
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-902
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-903
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE574]'
- en: 'The `headers.Authorization` option can be used to specify a bearer token when
    making an HTTP request to a protected resource using `fetch`:'
  id: totrans-904
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`fetch`向受保护的资源发起HTTP请求时，可以使用`headers.Authorization`选项来指定bearer令牌：
- en: '[PRE575]'
  id: totrans-905
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-906
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-907
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-908
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-909
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-910
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE580]'
- en: The problem is that React Query’s `QueryClientProvider` hasn’t been placed above
    the component using `useQuery` in the component tree.
  id: totrans-911
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于 React Query 的 `QueryClientProvider` 没有放置在 `useQuery` 所使用的组件之上，即在组件树中。
- en: The `isError` state variable can be destructured from React Query’s `useMutation`
    to determine whether the HTTP request has returned an error. Alternatively, the
    `status` state variable can be checked for a value of `'error'`.
  id: totrans-912
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以从 React Query 的 `useMutation` 中解构出 `isError` 状态变量，以确定 HTTP 请求是否返回了错误。或者，可以检查
    `status` 状态变量是否为 `'error'` 值。
