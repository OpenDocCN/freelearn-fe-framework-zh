<html><head></head><body>
<div id="_idContainer099">
<p><a id="_idTextAnchor279"/><a id="_idTextAnchor280"/></p>
<h1 class="chapter-number" id="_idParaDest-167"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-168"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.2.1">Experimental Object Recognition with TensorFlow</span></h1>
<p><span class="koboSpan" id="kobo.3.1">It’s time for something a bit more experimental. </span><span class="koboSpan" id="kobo.3.2">As we’ve seen, </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">artificial intelligence</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">AI</span></strong><span class="koboSpan" id="kobo.7.1">) offers lots of new opportunities to explore when writing code assisted by AI as well as building solutions that are powered by AI. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we’ll take a look at </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">TensorFlow</span></strong><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">Google developed and published TensorFlow under an open source license. </span><span class="koboSpan" id="kobo.9.3">It enables developers to use and train machine learning models for different sorts of applications. </span><span class="koboSpan" id="kobo.9.4">You can find a curated list of demos on the TensorFlow website:  </span><a href="https://www.tensorflow.org/js/demos"><span class="No-Break"><span class="koboSpan" id="kobo.10.1">https://www.tensorflow.org/js/demos</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.11.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">We’re going to apply a small part of the libraries that Google has published by leveraging the default published model for </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">object recognition.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">First, we’ll build a small example prototype to discover some of the capabilities. </span><span class="koboSpan" id="kobo.14.2">Then, we’ll apply our newly acquired knowledge to build something experimental and fun. </span><span class="koboSpan" id="kobo.14.3">It’s another game, where you have to track down real-life objects using the camera in </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">your browser!</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Prototyping a concept to identify capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">and limitations</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Leveraging multiple external APIs to build a </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">multimedia app</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Using the browser’s native </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">Camera</span></strong><span class="koboSpan" id="kobo.24.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">Text to Speech</span></strong><span class="koboSpan" id="kobo.26.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Media </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.28.1">Stream</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.29.1"> APIs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.30.1">The example we’ll be building has touch points with previous chapters and offers some potential opportunities for you to customize the application for your personal use case. </span><span class="koboSpan" id="kobo.30.2">I challenge you to create something unique here, based on the final code solution – maybe even a native app using what you learned about Quasar in </span><a href="B19563_07.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.31.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.32.1">!</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.33.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.34.1">We’ll build the main app on the </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Vuetify</span></strong><span class="koboSpan" id="kobo.36.1"> framework (</span><a href="https://vuetifyjs.com/en/"><span class="koboSpan" id="kobo.37.1">https://vuetifyjs.com/en/</span></a><span class="koboSpan" id="kobo.38.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Pinia</span></strong><span class="koboSpan" id="kobo.40.1"> (</span><a href="https://pinia.vuejs.org/"><span class="koboSpan" id="kobo.41.1">https://pinia.vuejs.org/</span></a><span class="koboSpan" id="kobo.42.1">) to manage the state. </span><span class="koboSpan" id="kobo.42.2">As stated previously, we’ll leverage various </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">TensorFlow</span></strong><span class="koboSpan" id="kobo.44.1"> libraries (</span><a href="https://www.tensorflow.org/js/"><span class="koboSpan" id="kobo.45.1">https://www.tensorflow.org/js/</span></a><span class="koboSpan" id="kobo.46.1">) to incorporate some intelligence into </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">our app.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">You can find the complete code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">here: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/09.tensorflow "><span class="No-Break"><span class="koboSpan" id="kobo.50.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/09.tensorflow</span></span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">.</span></span></a></p>
<p><span class="koboSpan" id="kobo.52.1">Let’s get started with a </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">prototype app!</span></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.54.1">Introduction to TensorFlow</span></h1>
<p><span class="koboSpan" id="kobo.55.1">When I need to research a new framework or technique, I find it very helpful to create a small application for it so that I can test it in complete isolation. </span><span class="koboSpan" id="kobo.55.2">We’re going to apply the same approach </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.56.1">with TensorFlow. </span><span class="koboSpan" id="kobo.56.2">The original idea is that we create an app using the object recognition library (</span><a href="https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd"><span class="koboSpan" id="kobo.57.1">https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd</span></a><span class="koboSpan" id="kobo.58.1">) and apply the model to images from the camera on </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">our device.</span></span><a id="_idTextAnchor285"/></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.60.1">Setting up the project</span></h2>
<p><span class="koboSpan" id="kobo.61.1">Let’s use a familiar framework to</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.62.1"> quickly build some boilerplate for our new project. </span><span class="koboSpan" id="kobo.62.2">We’ll use the Vuetify CLI to create a new project </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">for us:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.64.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">npm create vuetify@3.0.0</span></strong><span class="koboSpan" id="kobo.66.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">command-line interface.</span></span></li>
<li><span class="koboSpan" id="kobo.68.1">Choose </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">vue-tensorflow</span></strong><span class="koboSpan" id="kobo.70.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">project’s name.</span></span></li>
<li><span class="koboSpan" id="kobo.72.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">Essentials (Vuetify, VueRouter, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">Pinia)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1"> installation.</span></span></li>
<li><span class="koboSpan" id="kobo.76.1">Select </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">TypeScript</span></strong><span class="koboSpan" id="kobo.78.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">arrow keys.</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">Select </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">npm</span></strong><span class="koboSpan" id="kobo.82.1"> to install </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">the dependencies.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.84.1">If you navigate to the new project folder, you can run the local development server with </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">npm run dev</span></strong><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">The result should look very familiar to us since we’ve done this a few times now (see </span><a href="B19563_05.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.87.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.88.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.89.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Next, we’ll install the dependencies for using TensorFlow. </span><span class="koboSpan" id="kobo.92.2">The first two dependencies we’ll install will help us in sourcing the CPU and WebGL to help with calculations in the algorithm. </span><span class="koboSpan" id="kobo.92.3">From </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.93.1">the terminal, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.95.1">
npm install @tensorflow/tfjs-backend-cpu @tensorflow/tfjs-backend-webgl</span></pre> <p><span class="koboSpan" id="kobo.96.1">We’ll use a pretrained model to help us with object </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.97.1">recognition. </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">Coco SSD</span></strong><span class="koboSpan" id="kobo.99.1"> (</span><a href="https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd"><span class="koboSpan" id="kobo.100.1">https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd</span></a><span class="koboSpan" id="kobo.101.1">) can be used to identify multiple objects in a single image. </span><span class="koboSpan" id="kobo.101.2">We can install the model as a dependency of our project by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.103.1">
npm install @tensorflow-models/coco-ssd</span></pre> <p><span class="koboSpan" id="kobo.104.1">That’s all we need </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">for now!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.106.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.107.1">One of the limitations we’ll be running into is that a pretrained model is trained to recognize a limited set of classes (classes refer to a classification of an object in a category). </span><span class="koboSpan" id="kobo.107.2">We only have access to some 80 different classes. </span><span class="koboSpan" id="kobo.107.3">We’re going to have to work with </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">this limitation.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">To prepare the object recognition for future developments, we’ll create a store to wrap the features. </span><span class="koboSpan" id="kobo.109.2">Since we selected Pinia during installation, an empty store has been initialized on the project. </span><span class="koboSpan" id="kobo.109.3">We’ll create a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">objects.ts</span></strong><span class="koboSpan" id="kobo.111.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">./store</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.113.1">folder: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.1-object.ts"><span class="No-Break"><span class="koboSpan" id="kobo.114.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.1-object.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.115.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">We set some properties to track the status of the model. </span><span class="koboSpan" id="kobo.116.2">Bear in mind that it can take some time for a model to load, so we have to make sure that we inform the user so that they have a decent user experience. </span><span class="koboSpan" id="kobo.116.3">On store initialization, we must immediately call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">loadModel()</span></strong><span class="koboSpan" id="kobo.118.1"> function, which loads the model on the store (</span><em class="italic"><span class="koboSpan" id="kobo.119.1">lines 14, 32–39</span></em><span class="koboSpan" id="kobo.120.1">), for easy access throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">We’ve also added and exposed a </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">detect</span></strong><span class="koboSpan" id="kobo.124.1"> function (</span><em class="italic"><span class="koboSpan" id="kobo.125.1">lines 22–30</span></em><span class="koboSpan" id="kobo.126.1">). </span><span class="koboSpan" id="kobo.126.2">The function takes in an image and runs the image through the model. </span><span class="koboSpan" id="kobo.126.3">The result is an array of detected items with a certainty </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">per item.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">For now, this is enough for </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.129.1">us to start working on an implementation. </span><span class="koboSpan" id="kobo.129.2">Now, let’s build an interface for </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">our protot</span><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.131.1">ype.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.132.1">Performing and displaying a status check</span></h2>
<p><span class="koboSpan" id="kobo.133.1">It would be very valuable to see what the app is doing, especially since the first load of the model can take some time. </span><span class="koboSpan" id="kobo.133.2">We’ll </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.134.1">build a nice visual component to list the status of loading the model. </span><span class="koboSpan" id="kobo.134.2">Let’s create a component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">StatusCheck.vue</span></strong><span class="koboSpan" id="kobo.136.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">./</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">components</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
&lt;template&gt;  &lt;v-list&gt;
    &lt;v-list-subheader&gt;Status&lt;/v-list-subheader&gt;
    &lt;v-list-item&gt;
      &lt;v-list-item-title
        &gt;AI Model
        &lt;span v-if="isModelLoading"&gt;Loading...
</span><span class="koboSpan" id="kobo.140.2">          &lt;v-progress-circular indeterminate :size="16" color="primary" /&gt;
        &lt;/span&gt;
      &lt;/v-list-item-title&gt;
      &lt;v-list-item-subtitle v-if="isModelLoaded"&gt;Loaded!&lt;/v-list-item-subtitle&gt;
      &lt;template v-slot:append v-if="isModelLoaded"&gt;
        &lt;v-icon icon="mdi-check" color="success"&gt;&lt;/v-icon&gt;
      &lt;/template&gt;
    &lt;/v-list-item&gt;
  &lt;/v-list&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import { watch } from "vue";
import { useObjectStore } from "@/store/object";
import { storeToRefs } from "pinia";
const objectStore = useObjectStore();
const { isModelLoading, isModelLoaded } = storeToRefs(objectStore);
const emit = defineEmits(["model-loaded"]);
watch(isModelLoaded, () =&gt; {
  if (isModelLoaded.value) emit("model-loaded");
});
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.141.1">This component is simply listing the status from the store in a nicely formatted way. </span><span class="koboSpan" id="kobo.141.2">It also emits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">model-loaded</span></strong><span class="koboSpan" id="kobo.143.1"> event</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.144.1"> when the model is loaded so that we can pick up on the event. </span><span class="koboSpan" id="kobo.144.2">Let’s have the model loading status show up in our app. </span><span class="koboSpan" id="kobo.144.3">We can delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">HelloWorld.vue</span></strong><span class="koboSpan" id="kobo.146.1"> file from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">./components</span></strong><span class="koboSpan" id="kobo.148.1"> folder and replace the contents of </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">./view/Home.vue</span></strong><span class="koboSpan" id="kobo.150.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
&lt;template&gt;  &lt;v-container&gt;
    &lt;StatusCheck /&gt;
  &lt;/v-container&gt;
&lt;/template&gt;
&lt;script lang="ts" setup&gt;
import StatusCheck from "@/components/StatusCheck.vue";
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.153.1">Now, we can run our app for the </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.154.1">first time. </span><span class="koboSpan" id="kobo.154.2">You will notice that it takes a while to load at first, but after some time, you should see something similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.156.1"><img alt="Figure 9.1 – Visualizing the status of the model" src="image/B19563_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.157.1">Figure 9.1 – Visualizing the status of the model</span></p>
<p><span class="koboSpan" id="kobo.158.1">Now that our model has </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.159.1">been loaded, we can use it! </span><span class="koboSpan" id="kobo.159.2">We’ll build an image upload field and have the model analyze the contents of </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">the</span><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.161.1"> image.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.162.1">Selecting an image</span></h2>
<p><span class="koboSpan" id="kobo.163.1">We’ll begin by creating a new </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.164.1">component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">components</span></strong><span class="koboSpan" id="kobo.166.1"> folder. </span><span class="koboSpan" id="kobo.166.2">We’ll call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">ImageDetect.vue</span></strong><span class="koboSpan" id="kobo.168.1"> and start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">following contents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
&lt;template&gt;  &lt;v-container&gt;
    &lt;StatusCheckSimple @model-loaded="modelLoaded = true" /&gt;
    &lt;v-file-input @change="inputFromFile" v-model="image" accept="image/png, image/jpeg" :disabled="!modelLoaded" /&gt;
    &lt;v-img :src="url" height="100"&gt;&lt;/v-img&gt;
  &lt;/v-container&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import { ref } from "vue";
import type { Ref } from "vue";
import StatusCheckSimple from "./StatusCheck.vue";
const image: Ref&lt;File | any | undefined&gt; = ref(undefined);
const imageToDetect: Ref&lt;HTMLImageElement | undefined&gt; = ref(undefined);
const url: Ref&lt;string | undefined&gt; = ref(undefined);
import { useObjectStore } from "@/store/object";
import { storeToRefs } from "pinia";
const objectStore = useObjectStore();
const { detected } = storeToRefs(objectStore);
const modelLoaded: Ref&lt;boolean&gt; = ref(false);
const inputFromFile = (event: any): void =&gt; {
  const file = event.target.files[0];
  image.value = [file];
  imageToDetect.value = dataToImageData(file);
};
const dataToImageData = (dataBlob: Blob | MediaSource): HTMLImageElement =&gt; {
  const objUrl = URL.createObjectURL(dataBlob);
  const img = new Image();
  img.onload = () =&gt; {
    URL.revokeObjectURL(img.src);
  };
  img.src = objUrl;
  url.value = objUrl;
  return img;
};
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.171.1">As shown in the template, we’re moving some template logic to this file. </span><span class="koboSpan" id="kobo.171.2">We’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">&lt;StatusCheck /&gt;</span></strong><span class="koboSpan" id="kobo.173.1"> component with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">@model-loaded</span></strong><span class="koboSpan" id="kobo.175.1"> event to determine whether the image detection controls should be visible </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">or active.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">In the scripts, we first set</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.178.1"> some of the variables we need to track the images that are being selected in the browser. </span><span class="koboSpan" id="kobo.178.2">Once the user changes the contents of the file, we can load the image in the browser’s memory so that we can display it in </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">the placeholder.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">We’ll go to </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">./views/Home.vue</span></strong><span class="koboSpan" id="kobo.182.1"> and replace its contents to load this </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">new component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
&lt;template&gt;  &lt;v-container&gt;
    &lt;ImageDetect /&gt;
  &lt;/v-container&gt;
&lt;/template&gt;
&lt;script lang="ts" setup&gt;
import ImageDetect from "@/components/ImageDetect.vue";
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.185.1">Now, we have a feature that provides images and we have a store that should be able to detect objects on images. </span><span class="koboSpan" id="kobo.185.2">Let’s start to connect those by adding the store references to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">script</span></strong><span class="koboSpan" id="kobo.187.1"> tag and adding a button to trigger the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">detection: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.2-ImageDetect.vue"><span class="No-Break"><span class="koboSpan" id="kobo.189.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.2-ImageDetect.vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.190.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">As shown on </span><em class="italic"><span class="koboSpan" id="kobo.192.1">line 7</span></em><span class="koboSpan" id="kobo.193.1">, we’re ready to display </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">detected objects.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.195.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.196.1">In terms of limitations, I mentioned that the model is capable of identifying several objects. </span><span class="koboSpan" id="kobo.196.2">The list can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">here: </span></span><a href="https://github.com/tensorflow/tfjs-models/blob/master/coco-ssd/src/classes.ts"><span class="No-Break"><span class="koboSpan" id="kobo.198.1">https://github.com/tensorflow/tfjs-models/blob/master/coco-ssd/src/classes.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.199.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.200.1">I recommend trying this feature out with images of a person, or one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">listed classes.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">After applying the</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.203.1"> detection, you should end up with something </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.205.1"><img alt="Figure 9.2 – Object recognition based on an uploaded image" src="image/B19563_09_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.206.1">Figure 9.2 – Object recognition based on an uploaded image</span></p>
<p><span class="koboSpan" id="kobo.207.1">This is already pretty interesting, but let’s see if we can apply some more features. </span><span class="koboSpan" id="kobo.207.2">First, we’ll look into formatting the results </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">nicely: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.3-ImageDetect.vue"><span class="No-Break"><span class="koboSpan" id="kobo.209.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.3-ImageDetect.vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.210.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">As shown on </span><em class="italic"><span class="koboSpan" id="kobo.212.1">lines 12–22</span></em><span class="koboSpan" id="kobo.213.1">, we’ve added a nicely formatted list of detected items. </span><span class="koboSpan" id="kobo.213.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">roundNumber</span></strong><span class="koboSpan" id="kobo.215.1"> function (</span><em class="italic"><span class="koboSpan" id="kobo.216.1">lines 18, 65–67</span></em><span class="koboSpan" id="kobo.217.1">) to round </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the percentages.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Let’s explore adding an</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.220.1"> additional feature and see if we can give our application a voice by exploring the Speech </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">Synt</span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.222.1">hesis API.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.223.1">Adding a voice to the app</span></h2>
<p><span class="koboSpan" id="kobo.224.1">Since we’re looking at non-traditional </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.225.1">input for our app (using images rather than a mouse and keyboard), it’s interesting to explore different ways of presenting information as well. </span><span class="koboSpan" id="kobo.225.2">Modern </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.226.1">browsers have a built-in feature for converting </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">Text To Speech</span></strong><span class="koboSpan" id="kobo.228.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.229.1">TTS</span></strong><span class="koboSpan" id="kobo.230.1">) called </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">SpeechSynthesisUtterance</span></strong><span class="koboSpan" id="kobo.232.1"> (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance"><span class="koboSpan" id="kobo.233.1">https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance</span></a><span class="koboSpan" id="kobo.234.1">). </span><span class="koboSpan" id="kobo.234.2">Let’s work on an addition for our prototype where we</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.235.1"> can </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">explore this.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">This API is pretty straightforward to set up. </span><span class="koboSpan" id="kobo.237.2">We will start by creating a new component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">TextToSpeech.vue</span></strong><span class="koboSpan" id="kobo.239.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">./components</span></strong><span class="koboSpan" id="kobo.241.1"> folder that will accept the text as </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">a prop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
&lt;template&gt;  &lt;v-btn @click="tts" prepend-icon="mdi-microphone" :disabled="isSpeaking"&gt;Speak&lt;/v-btn&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import { ref } from "vue";
import type { Ref } from "vue";
const props = defineProps&lt;{
  message: string;
}&gt;();
const isSpeaking: Ref&lt;boolean&gt; = ref(false);
const tts = async () =&gt; {
  const { message } = props;
  const msg = new SpeechSynthesisUtterance();
  msg.text = message;
  msg.rate = 0.8;
  msg.pitch = 0.2;
  await window.speechSynthesis.speak(msg);
  msg.onstart = () =&gt; isSpeaking.value = true;
  msg.onend = () =&gt; isSpeaking.value = false;
};
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.244.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">tts</span></strong><span class="koboSpan" id="kobo.246.1"> function, we can see how we can access the API and send a message to speak. </span><span class="koboSpan" id="kobo.246.2">Since we want to disable the </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.247.1">button while speech is active, we’re keeping track of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">onstart</span></strong><span class="koboSpan" id="kobo.249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">onend</span></strong><span class="koboSpan" id="kobo.251.1"> callback functions and updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">isSpeaking</span></strong><span class="koboSpan" id="kobo.253.1"> variable accordingly. </span><span class="koboSpan" id="kobo.253.2">We’re playing around a bit with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">rate</span></strong><span class="koboSpan" id="kobo.255.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">pitch</span></strong><span class="koboSpan" id="kobo.257.1"> settings </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">There are some more options we have when configuring </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">SpeechSynthesisUtterance</span></strong><span class="koboSpan" id="kobo.261.1"> as we can read in the documentation. </span><span class="koboSpan" id="kobo.261.2">However, unfortunately, I’ve found that there are some limits. </span><span class="koboSpan" id="kobo.261.3">There are some mismatches between browsers and the support of certain languages is not very stable or usable. </span><span class="koboSpan" id="kobo.261.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">TextToSpeech.vue</span></strong><span class="koboSpan" id="kobo.263.1"> component, however, should work in our application, so let’s add speech to </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">our app!</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">With the component stored, we’ll add it to the template of </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">ImageDetect.vue</span></strong><span class="koboSpan" id="kobo.267.1"> (don’t forget to import </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">the component!):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
&lt;template&gt;  &lt;v-container&gt;
    &lt;!-- abbreviated –-&gt;
    &lt;div v-if="detected"&gt;
      &lt;v-list&gt;
        &lt;v-list-item v-for="(item, index) in detected" :key="index"&gt;
          &lt;!-- abbreviated –-&gt;
        &lt;/v-list-item&gt;
      &lt;/v-list&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.270.1">      &lt;TextToSpeech :message="speech" v-if="speech"&gt;&lt;/TextToSpeech&gt;</span></strong><span class="koboSpan" id="kobo.271.1">
    &lt;/div&gt;
  &lt;/v-container&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import { ref } from "vue";
import type { Ref } from "vue";
import StatusCheckSimple from "./StatusCheckSimple.vue";
</span><strong class="bold"><span class="koboSpan" id="kobo.272.1">import TextToSpeech from "./TextToSpeech.vue";</span></strong><span class="koboSpan" id="kobo.273.1">
// ...abbreviated
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.274.1">As you can see from the </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.275.1">template, we need to provide the component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">speech</span></strong><span class="koboSpan" id="kobo.277.1">. </span><span class="koboSpan" id="kobo.277.2">Let’s have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">code: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.4-ImageDetect.vue"><span class="No-Break"><span class="koboSpan" id="kobo.279.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.4-ImageDetect.vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.280.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">We’ve added a couple of helpers here. </span><span class="koboSpan" id="kobo.281.2">We want the speech to only name unique classes, so we’re adding a computed variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">uniqueObjects</span></strong><span class="koboSpan" id="kobo.283.1"> that filters all duplicate entries (</span><em class="italic"><span class="koboSpan" id="kobo.284.1">lines 71–75</span></em><span class="koboSpan" id="kobo.285.1">). </span><span class="koboSpan" id="kobo.285.2">The computed </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">speech</span></strong><span class="koboSpan" id="kobo.287.1"> value (</span><em class="italic"><span class="koboSpan" id="kobo.288.1">lines 77–85</span></em><span class="koboSpan" id="kobo.289.1">) takes in that list and joins them using the Intl API, which we also used in </span><a href="B19563_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.290.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.291.1">! </span><span class="koboSpan" id="kobo.291.2">The output is what we can send safely to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">&lt;TextToSpeech /&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.293.1">component.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">Try it out if you want! </span><span class="koboSpan" id="kobo.294.2">Our</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.295.1"> prototype is functional, which is all we need to be able t</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.296.1">o learn </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">from it.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.298.1">Learning from the prototype</span></h2>
<p><span class="koboSpan" id="kobo.299.1">So, with this micro app in place, we </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.300.1">can experiment a bit. </span><span class="koboSpan" id="kobo.300.2">I was running into two </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">major problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.302.1">Object recognition works, but it is very limited to the classes from the pretrained model. </span><span class="koboSpan" id="kobo.302.2">Providing a self-trained model should be possible, but it is a bit too complex to handle in the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">this topic.</span></span></li>
<li><span class="koboSpan" id="kobo.304.1">The TTS capabilities between browsers are not very stable or reliable, especially </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">between languages.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.306.1">My initial idea was to create an app that would use the camera feed to point out objects that we could then learn to translate. </span><span class="koboSpan" id="kobo.306.2">With those two limitations, it’s not going to be feasible to build. </span><span class="koboSpan" id="kobo.306.3">Luckily, we can still have some fun with the reliable features, without needing to modify </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">the model.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Let’s build a little game where we need to collect objects. </span><span class="koboSpan" id="kobo.308.2">We can have the existing classes list and prune it a bit so that it fits our use case. </span><span class="koboSpan" id="kobo.308.3">Let’s go on </span><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.309.1">a </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">scavenger hunt!</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.311.1">Scavenge Hunter</span></h1>
<p><span class="koboSpan" id="kobo.312.1">In this section, we’ll build a small app that can run on a web browser, preferably on a mobile phone. </span><span class="koboSpan" id="kobo.312.2">With </span><em class="italic"><span class="koboSpan" id="kobo.313.1">Scavenge Hunter</span></em><span class="koboSpan" id="kobo.314.1">, the goal is to collect certain items from a list. </span><span class="koboSpan" id="kobo.314.2">We can use parts of the classes list to control the items our user needs to collect and in that case, we’re sure to be</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.315.1"> able to detect </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">those objects!</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Once an object has been detected, we’re going to add a score based on the find and certainty of the model. </span><span class="koboSpan" id="kobo.317.2">Since we can’t guarantee that objects are being recognized properly, we should also be able to skip an assignment. </span><span class="koboSpan" id="kobo.317.3">Instead of uploading an image, we’re going to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">camera stream!</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.319.1">Setting up the project</span></h2>
<p><span class="koboSpan" id="kobo.320.1">We can continue using the prototype we built or create a new project if we’d like. </span><span class="koboSpan" id="kobo.320.2">In the case of the latter, the </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.321.1">dependencies and store are required, so we’d need to repeat the relevant steps provided in the </span><em class="italic"><span class="koboSpan" id="kobo.322.1">Setting up the project</span></em><span class="koboSpan" id="kobo.323.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.324.1">Performing and displaying a status </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.325.1">check</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.326.1"> sections.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Let’s see how we can turn the foundation of our prototype into a lit</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.328.1">tle game, </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">shall we?</span></span></p>
<h3><span class="koboSpan" id="kobo.330.1">Generic changes</span></h3>
<p><span class="koboSpan" id="kobo.331.1">We’re going to start with a configuration </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.332.1">file. </span><span class="koboSpan" id="kobo.332.2">We need to create this file in the root of the project </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">config.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
export default Object.freeze({    MOTIVATIONAL_QUOTES: [
        "Believe in yourself and keep coding!",
        "Every Vue project you complete gets you closer to victory!",
        "You're on the right track, keep it up!",
        "Stay focused and never give up!"
</span><span class="koboSpan" id="kobo.336.2">    ],
    DETECTION_ACCURACY_THRESHOLD: 0.70,
    SCORE_ACCURACY_MULTIPLIER: 1.10, // input scores are between DETECTION_ACCURACY_THRESHOLD and 1
    MAX_ROUNDS: 10,
    SCORE_FOUND: 100,
    SCORE_SKIP: -150,
})</span></pre>
<p><span class="koboSpan" id="kobo.337.1">It can be very helpful to have this sort of configuration files in a central place so that we don’t have to spend time hunting settings down in individual files. </span><span class="koboSpan" id="kobo.337.2">Feel free to modify the game configuration values in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">config.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1"> file!</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">Let’s also open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">./index.html</span></strong><span class="koboSpan" id="kobo.342.1"> template so that we can update the title tag to the new project’s name – that is, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.343.1">Scavenge Hunter</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">We’ll also create two new view files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">./views</span></strong><span class="koboSpan" id="kobo.347.1"> folder. </span><span class="koboSpan" id="kobo.347.2">It’s okay to just paste some placeholder </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.348.1">content here, </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
&lt;template&gt;  &lt;div&gt;NAME OF THE VIEW&lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.351.1">We need a view for the finding state, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Find.vue</span></strong><span class="koboSpan" id="kobo.353.1">, and one for the end of a game, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">End.vue</span></strong><span class="koboSpan" id="kobo.355.1">. </span><span class="koboSpan" id="kobo.355.2">We’ll add the contents later, in the </span><em class="italic"><span class="koboSpan" id="kobo.356.1">Building the finish screen</span></em><span class="koboSpan" id="kobo.357.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.358.1">Skipping to the end</span></em><span class="koboSpan" id="kobo.359.1"> sections. </span><span class="koboSpan" id="kobo.359.2">With the views in place, we can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">./router/index.ts</span></strong><span class="koboSpan" id="kobo.361.1"> file with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">contents: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.5-index.ts"><span class="No-Break"><span class="koboSpan" id="kobo.363.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.5-index.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.364.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">We’re also going to simplify the interface a bit more. </span><span class="koboSpan" id="kobo.365.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">./layouts/default</span></strong><span class="koboSpan" id="kobo.367.1"> folder, delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">AppBar.vue</span></strong><span class="koboSpan" id="kobo.369.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">View.vue</span></strong><span class="koboSpan" id="kobo.371.1"> files. </span><span class="koboSpan" id="kobo.371.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Default.vue</span></strong><span class="koboSpan" id="kobo.373.1"> file, replace its contents with </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
&lt;template&gt;  &lt;v-app&gt;
    &lt;v-main&gt;
      &lt;router-view /&gt;
    &lt;/v-main&gt;
  &lt;/v-app&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.376.1">Now, we should be able to run the app, but there’s not much new to do at the moment. </span><span class="koboSpan" id="kobo.376.2">Let’s add some </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.377.1">core feat</span><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.378.1">ures via </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">Pinia stores.</span></span></p>
<h3><span class="koboSpan" id="kobo.380.1">Additional stores</span></h3>
<p><span class="koboSpan" id="kobo.381.1">I usually start by designing and</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.382.1"> setting up the stores since they usually act as a central source of information and methods. </span><span class="koboSpan" id="kobo.382.2">First, we’re going to replace the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">./store/app.ts</span></strong><span class="koboSpan" id="kobo.384.1"> file with contents that are very similar to those from </span><a href="B19563_06.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.385.1">Chapter </span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.386.1">6</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.387.1">: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.6-app.ts"><span class="No-Break"><span class="koboSpan" id="kobo.388.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.6-app.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.389.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">It’s a trimmed-down version of the app store we used to build our fitness tracker, but we’ve removed all the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">unnecessary features.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">Since we’re dealing with a predefined list of classes, we’re going to add those to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">object.ts</span></strong><span class="koboSpan" id="kobo.394.1"> store as an </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">additional value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
// ...abbreviatedexport const useObjectStore = defineStore('object', () =&gt; {
    // ...abbreviated
    const loadModel = async () =&gt; {
        // ...abbreviated
    }
    loadModel();
</span><strong class="bold"><span class="koboSpan" id="kobo.397.1">    // Full list of available classes listed as displayName on the following link:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.398.1">    // https://raw.githubusercontent.com/tensorflow/tfjs-models/master/coco-ssd/src/classes.ts</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.399.1">    const objects: string[] = ["person", "backpack", "umbrella", "handbag", "tie", "suitcase", "sports ball", "bottle", "wine glass", "cup", "fork", "knife", "spoon", "bowl", "banana", "apple", "orange", "broccoli", "carrot", "chair", "couch", "potted plant", "bed", "dining table", "toilet", "tv", "laptop", "remote", "cell phone", "microwave", "oven", "sink", "refrigerator", "book", "clock", "vase", "scissors", "teddy bear", "hair drier", "toothbrush"];</span></strong><span class="koboSpan" id="kobo.400.1">
    return { loadModel, isModelLoading, isModelLoaded, detected, detect, objects }
})</span></pre>
<p><span class="koboSpan" id="kobo.401.1">I’ve not added all of the categories and instead selected the classes that we could find in someone’s home. </span><span class="koboSpan" id="kobo.401.2">You can change this to what you think is reasonable to have on hand (especially for </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">testing purposes).</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Let’s also introduce some</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.404.1"> game mechanics by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">./store/game.ts</span></strong><span class="koboSpan" id="kobo.406.1"> store </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">file: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.7-game.ts"><span class="No-Break"><span class="koboSpan" id="kobo.408.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.7-game.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">This store contains references to the rounds that are being played and which are being skipped (</span><em class="italic"><span class="koboSpan" id="kobo.411.1">lines 19–23</span></em><span class="koboSpan" id="kobo.412.1">), keeps track of the score (</span><em class="italic"><span class="koboSpan" id="kobo.413.1">line 23</span></em><span class="koboSpan" id="kobo.414.1">), and helps in selecting a category from the list of objects we’ve defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">object</span></strong><span class="koboSpan" id="kobo.416.1"> store. </span><span class="koboSpan" id="kobo.416.2">In particular, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">getNewCategory</span></strong><span class="koboSpan" id="kobo.418.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.419.1">lines 28–45</span></em><span class="koboSpan" id="kobo.420.1">) is interesting since it pulls a randomized category from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">objects</span></strong><span class="koboSpan" id="kobo.422.1"> collection while making sure it’s always a unique </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">new category.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">As a final step in this section, we’ll replace the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">./App.vue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.426.1">file: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.8-App.vue"><span class="No-Break"><span class="koboSpan" id="kobo.427.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.8-App.vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.428.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">This connects the app store’s capabilities to the interface. </span><span class="koboSpan" id="kobo.429.2">Now, we can continue buil</span><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.430.1">ding up our </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">little game!</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.432.1">Starting a new game</span></h2>
<p><span class="koboSpan" id="kobo.433.1">We’ll start by creating a</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.434.1"> button that triggers the conditions for a new game. </span><span class="koboSpan" id="kobo.434.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">components</span></strong><span class="koboSpan" id="kobo.436.1"> folder, we’ll create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">StartGame.vue</span></strong><span class="koboSpan" id="kobo.438.1"> component, which is nothing more than a button with some actions </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">on it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
&lt;template&gt;  &lt;v-btn
    :disabled="!canStart"
    @click="newGame"
    prepend-icon="mdi-trophy"
    append-icon="mdi-trophy"
    size="x-large"
    color="primary"
    &gt;&lt;slot&gt;Start game!&lt;/slot&gt;&lt;/v-btn
  &gt;
&lt;/template&gt;
&lt;script lang="ts" setup&gt;
import { useAppStore } from "@/store/app";
import { useGameStore } from "@/store/game";
import { storeToRefs } from "pinia";
const gameStore = useGameStore();
const appStore = useAppStore();
const { canStart } = storeToRefs(gameStore);
const { reset } = gameStore;
const newGame = () =&gt; {
  reset();
  appStore.navigateToPage("/find");
};
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.441.1">As you can see, we’re relying on the store to tell the button whether the button should be disabled. </span><span class="koboSpan" id="kobo.441.2">We</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.442.1"> trigger a new game by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">reset()</span></strong><span class="koboSpan" id="kobo.444.1"> function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">gameStore</span></strong><span class="koboSpan" id="kobo.446.1"> and calling a </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">navigateToPage</span></strong><span class="koboSpan" id="kobo.448.1"> function on </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">appStore</span></strong><span class="koboSpan" id="kobo.450.1">. </span><span class="koboSpan" id="kobo.450.2">Now, we should be able to place this button component on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">Home.vue</span></strong><span class="koboSpan" id="kobo.452.1"> view. </span><span class="koboSpan" id="kobo.452.2">Let’s update that view completely with the </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">following contents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
&lt;template&gt;  &lt;v-card class="pa-4"&gt;
    &lt;v-card-title&gt;
      &lt;h1 class="text-h3 text-md-h2 text-wrap"&gt;z Scavenge Hunter&lt;/h1&gt;
    &lt;/v-card-title&gt;
    &lt;v-card-text&gt;
      &lt;p&gt;Welcome to "Scavenge Hunter"! </span><span class="koboSpan" id="kobo.454.2">The game where you find things!&lt;/p&gt;
    &lt;/v-card-text&gt;
    &lt;StatusCheck /&gt;
    &lt;v-card-actions class="justify-center"&gt;
      &lt;StartGame /&gt;
    &lt;/v-card-actions&gt;
  &lt;/v-card&gt;
&lt;/template&gt;
&lt;script lang="ts" setup&gt;
import StartGame from "@/components/StartGame.vue";
import StatusCheck from "@/components/StatusCheck.vue";
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.455.1">If you’re running the app </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.456.1">now, you’ll notice that it’s impossible to start the game. </span><span class="koboSpan" id="kobo.456.2">Since we want to use the user’s camera feed, we need to request access. </span><span class="koboSpan" id="kobo.456.3">We’re going to expand the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">StatusCheck.vue</span></strong><span class="koboSpan" id="kobo.458.1"> file to also make sure we have access to a camera. </span><span class="koboSpan" id="kobo.458.2">We can use a composable from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">VueUse</span></strong><span class="koboSpan" id="kobo.460.1"> library for this. </span><span class="koboSpan" id="kobo.460.2">So, from the terminal, let’s install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">VueUse</span></strong><span class="koboSpan" id="kobo.462.1"> package with the </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.464.1">
npm i @vueuse/core</span></pre> <p><span class="koboSpan" id="kobo.465.1">With this dependency, we can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">StatusCheck.vue</span></strong><span class="koboSpan" id="kobo.467.1"> file. </span><span class="koboSpan" id="kobo.467.2">The changes to that component are quite extensive, so use the source </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">from </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.9-StatusCheck.vue"><span class="No-Break"><span class="koboSpan" id="kobo.469.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.9-StatusCheck.vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.470.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">Apart from some additional formatting on our model loading status and some template changes that show the actual status, most changes take place in the script. </span><span class="koboSpan" id="kobo.471.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">usePermission</span></strong><span class="koboSpan" id="kobo.473.1"> composable returns a reactive property that lets us know if the user has granted access to use the camera. </span><span class="koboSpan" id="kobo.473.2">If both the model is loaded and the user has granted camera access, the game can start (</span><em class="italic"><span class="koboSpan" id="kobo.474.1">lines 61–65</span></em><span class="koboSpan" id="kobo.475.1">). </span><span class="koboSpan" id="kobo.475.2">As you can see, we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">watch</span></strong><span class="koboSpan" id="kobo.477.1"> function on multiple values by providing them as arrays (line 61) to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">watch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.479.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">onMounted</span></strong><span class="koboSpan" id="kobo.482.1"> hook (</span><em class="italic"><span class="koboSpan" id="kobo.483.1">lines 67–81</span></em><span class="koboSpan" id="kobo.484.1">), we manually attempt to request a video stream. </span><span class="koboSpan" id="kobo.484.2">Once the stream starts, we immediately close it down since we don’t need the stream, just the permission. </span><span class="koboSpan" id="kobo.484.3">The permission is persis</span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.485.1">tent throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">our visit.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.487.1">Building the finish screen</span></h2>
<p><span class="koboSpan" id="kobo.488.1">Before we dive into the</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.489.1"> image streams and object-hunting aspects, we’ll build the final screen. </span><span class="koboSpan" id="kobo.489.2">We’ll create a component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">./components</span></strong><span class="koboSpan" id="kobo.491.1"> folder to display the result of a game called </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">ScoreCard.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.10-ScoreCard.vue"><span class="No-Break"><span class="koboSpan" id="kobo.494.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.10-ScoreCard.vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.495.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">In the component, we’re just displaying some of the metrics that were being collected on playthrough. </span><span class="koboSpan" id="kobo.496.2">They are all properties that are part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">gameStore</span></strong><span class="koboSpan" id="kobo.498.1">, so we have easy access </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">to them.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">End.vue</span></strong><span class="koboSpan" id="kobo.502.1">, we’ll import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">ScoreCard.vue</span></strong><span class="koboSpan" id="kobo.504.1"> file and make some additions to </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
&lt;template&gt;  &lt;v-card class="pa-4"&gt;
    &lt;v-card-title&gt;
      &lt;h1 class="text-h3 text-md-h2 text-wrap"&gt;It's over!&lt;/h1&gt;
    &lt;/v-card-title&gt;
    &lt;v-card-text&gt;
      &lt;p&gt;Let's see how you did!&lt;/p&gt;
    &lt;/v-card-text&gt;
    &lt;ScoreCard /&gt;
    &lt;v-card-actions class="justify-center"&gt;
      &lt;StartGame&gt;Play Again?&lt;/StartGame&gt;
    &lt;/v-card-actions&gt;
  &lt;/v-card&gt;
&lt;/template&gt;
&lt;script lang="ts" setup&gt;
import ScoreCard from "@/components/ScoreCard.vue";
import StartGame from "@/components/StartGame.vue";
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.507.1">There’s not much going on here apart from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">&lt;StartGame /&gt;</span></strong><span class="koboSpan" id="kobo.509.1"> component, which we have reused to simply</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.510.1"> trigger a new game. </span><span class="koboSpan" id="kobo.510.2">That’s how you use slots! </span><span class="koboSpan" id="kobo.510.3">Now, we can</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.511.1"> work on the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">middle section!</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.513.1">Skipping to the end</span></h2>
<p><span class="koboSpan" id="kobo.514.1">First, let’s make sure we can </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.515.1">complete a (very limited) flow by skipping all assignments. </span><span class="koboSpan" id="kobo.515.2">We’re going to implement the basic game flow in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">./views/Find.vue</span></strong><span class="koboSpan" id="kobo.517.1"> file. </span><span class="koboSpan" id="kobo.517.2">Let’s take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">script</span></strong><span class="koboSpan" id="kobo.519.1"> tag since we have a lot going on in this </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">file: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.11-Find(script).vue"><span class="No-Break"><span class="koboSpan" id="kobo.521.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.11-Find(script).vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.522.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">At the top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">script</span></strong><span class="koboSpan" id="kobo.525.1"> tag, we’re loading the properties and methods from the stores (</span><em class="italic"><span class="koboSpan" id="kobo.526.1">lines 3–15</span></em><span class="koboSpan" id="kobo.527.1">). </span><span class="koboSpan" id="kobo.527.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">appStore</span></strong><span class="koboSpan" id="kobo.529.1"> to navigate to different pages and </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">gameStore</span></strong><span class="koboSpan" id="kobo.531.1"> because that contains information about the progress of the </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">current game.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">We have some computed values that help in presenting and formatting data nicely. </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">currentRound</span></strong><span class="koboSpan" id="kobo.535.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.536.1">lines 17–19</span></em><span class="koboSpan" id="kobo.537.1">) displays the progress of the game. </span><span class="koboSpan" id="kobo.537.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">isPlaying</span></strong><span class="koboSpan" id="kobo.539.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.540.1">lines 21–23</span></em><span class="koboSpan" id="kobo.541.1">) to determine the boundaries of the rounds versus the maximum set of rounds. </span><span class="koboSpan" id="kobo.541.2">Lastly, we have some fun randomized motivational quotes (</span><em class="italic"><span class="koboSpan" id="kobo.542.1">lines 25–29</span></em><span class="koboSpan" id="kobo.543.1">) that we’ve loaded from our </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">configuration file.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">There are two methods in this component. </span><span class="koboSpan" id="kobo.545.2">One is to </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">skip</span></strong><span class="koboSpan" id="kobo.547.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.548.1">lines 31–39</span></em><span class="koboSpan" id="kobo.549.1">) a round. </span><span class="koboSpan" id="kobo.549.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">skip</span></strong><span class="koboSpan" id="kobo.551.1"> function tracks the number of rounds skipped (</span><em class="italic"><span class="koboSpan" id="kobo.552.1">line 32</span></em><span class="koboSpan" id="kobo.553.1">) and modifies the player’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">score</span></strong><span class="koboSpan" id="kobo.555.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.556.1">lines 33–37</span></em><span class="koboSpan" id="kobo.557.1">). </span><span class="koboSpan" id="kobo.557.2">We must make sure the score doesn’t fall below </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">0</span></strong><span class="koboSpan" id="kobo.559.1">. </span><span class="koboSpan" id="kobo.559.2">After skipping, we call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">newRound</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">newRound</span></strong><span class="koboSpan" id="kobo.564.1"> function (</span><em class="italic"><span class="koboSpan" id="kobo.565.1">lines 41–47</span></em><span class="koboSpan" id="kobo.566.1">) tracks what should happen: either the number of rounds has reached the maximum and we should navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">End</span></strong><span class="koboSpan" id="kobo.568.1"> state, or we should load a new category using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">getCategory</span></strong><span class="koboSpan" id="kobo.570.1"> function from the store. </span><span class="koboSpan" id="kobo.570.2">To ensure we get started when we enter this </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Find</span></strong><span class="koboSpan" id="kobo.572.1"> state, we will call that </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">newRound</span></strong><span class="koboSpan" id="kobo.574.1"> function in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">onMounted</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.576.1"> hook.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">Next, let’s look at the template of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">Find.vue</span></strong><span class="koboSpan" id="kobo.579.1"> file, where we connect the computed values and methods to a basic </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">interface: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.12-Find(template).vue"><span class="No-Break"><span class="koboSpan" id="kobo.581.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.12-Find(template).vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.582.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">Again, there’s not much special going</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.584.1"> on here. </span><span class="koboSpan" id="kobo.584.2">We’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">&lt;SkipRound /&gt;</span></strong><span class="koboSpan" id="kobo.586.1"> component with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">@skipped</span></strong><span class="koboSpan" id="kobo.588.1"> event to make sure we can move forward in rounds, regardless of whether we’ve been able to use </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">object recognition.</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">Running the app at this stage should give us a result similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.592.1"><img alt="Figure 9.3 – The basic game flow in place" src="image/B19563_09_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.593.1">Figure 9.3 – The basic game flow in place</span></p>
<p><span class="koboSpan" id="kobo.594.1">You should be able to complete the entire flow now by skipping all of the rounds. </span><span class="koboSpan" id="kobo.594.2">A game like this makes more sense on a mobile device than a laptop or personal computer, so this would be a</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.595.1"> good time to make sure </span><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.596.1">we can test the </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">app properly.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.598.1">Testing on a mobile device</span></h2>
<p><span class="koboSpan" id="kobo.599.1">If you’re building an app</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.600.1"> for a specific use case, it makes a lot of sense to test those cases as early as possible! </span><span class="koboSpan" id="kobo.600.2">While we can open the app in mobile views in our browser, it would make a lot of sense to run it on a mobile device as well. </span><span class="koboSpan" id="kobo.600.3">The first thing we can do is automatically expose the development server </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.601.1">host by updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">dev</span></strong><span class="koboSpan" id="kobo.603.1"> script in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">package.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
{    "scripts": {
    "dev": "vite --host",
    "build": "vue-tsc --noEmit &amp;&amp; vite build",
    "preview": "vite preview",
    "lint": "eslint . </span><span class="koboSpan" id="kobo.606.2">--fix --ignore-path .gitignore"
  },
  "dependencies": {
    // ...abbreviated
  },
  "devDependencies": {
    // ...abbreviated
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.607.1">This change automatically serves the content through your local network, so as long as your mobile device and development server are on the same network, you can access the app via the </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">network address:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.609.1"><img alt="Figure 9.4 – Exposing the development server to the network" src="image/B19563_09_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.610.1">Figure 9.4 – Exposing the development server to the network</span></p>
<p><span class="koboSpan" id="kobo.611.1">We’re not there yet, though. </span><span class="koboSpan" id="kobo.611.2">The media feed is only accessible over a secure connection. </span><span class="koboSpan" id="kobo.611.3">Going with </span><strong class="bold"><span class="koboSpan" id="kobo.612.1">Vite’s</span></strong><span class="koboSpan" id="kobo.613.1"> recommendation in</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.614.1"> the official documentation (</span><a href="https://vitejs.dev/config/server-options.html#server-https"><span class="koboSpan" id="kobo.615.1">https://vitejs.dev/config/server-options.html#server-https</span></a><span class="koboSpan" id="kobo.616.1">), we’ll install a plugin for this using </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.618.1">
npm install --save-dev @vitejs/plugin-basic-ssl</span></pre> <p><span class="koboSpan" id="kobo.619.1">Once the installation is completed, we’ll update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">vite.confis.ts</span></strong><span class="koboSpan" id="kobo.621.1"> file so that it can use </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the plugin:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
// Pluginsimport vue from '@vitejs/plugin-vue'
import vuetify, { transformAssetUrls } from 'vite-plugin-vuetify'
</span><strong class="bold"><span class="koboSpan" id="kobo.624.1">import basicSsl from '@vitejs/plugin-basic-ssl'</span></strong><span class="koboSpan" id="kobo.625.1">
// Utilities
import { defineConfig } from 'vite'
import { fileURLToPath, URL } from 'node:url'
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
</span><strong class="bold"><span class="koboSpan" id="kobo.626.1">    basicSsl(),</span></strong><span class="koboSpan" id="kobo.627.1">
    vue({
      template: { transformAssetUrls }
    }),
    // ...abbreviated
  ],
  // ...abbreviated
})</span></pre>
<p><span class="koboSpan" id="kobo.628.1">After saving, we can restart the development server. </span><span class="koboSpan" id="kobo.628.2">The contents are now served over an HTTPS protocol. </span><span class="koboSpan" id="kobo.628.3">It is not using a signed certificate, so you will probably receive a warning from the browser upon first entry. </span><span class="koboSpan" id="kobo.628.4">You can now validate each step using your mobile device </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">as well!</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">With that, we’ve built a basic flow from start to finish and we can test it on a mobile device. </span><span class="koboSpan" id="kobo.630.2">The game itself is not </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.631.1">very interesting yet though, right? </span><span class="koboSpan" id="kobo.631.2">It’s time to add som</span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.632.1">e object recognition to </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">the game!</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.634.1">Object recognition from the camera</span></h1>
<p><span class="koboSpan" id="kobo.635.1">This will be a change that involves </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.636.1">a couple of steps. </span><span class="koboSpan" id="kobo.636.2">First, we’ll introduce a component that can capture video from the browser. </span><span class="koboSpan" id="kobo.636.3">We’ll create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">CameraDetect.vue</span></strong><span class="koboSpan" id="kobo.638.1"> component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">./components</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.640.1">folder: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.13-CameraDetect.vue"><span class="No-Break"><span class="koboSpan" id="kobo.641.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.13-CameraDetect.vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.642.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">The code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">CameraDetect.vue</span></strong><span class="koboSpan" id="kobo.645.1"> component uses composables from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">@vueuse</span></strong><span class="koboSpan" id="kobo.647.1"> package to interact with the browsers’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">Devices</span></strong><span class="koboSpan" id="kobo.649.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">userMedia</span></strong><span class="koboSpan" id="kobo.651.1"> APIs. </span><span class="koboSpan" id="kobo.651.2">We’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">useDevicesList</span></strong><span class="koboSpan" id="kobo.653.1"> to list the available cameras (</span><em class="italic"><span class="koboSpan" id="kobo.654.1">lines 33–40</span></em><span class="koboSpan" id="kobo.655.1">) and populate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">&lt;v-select /&gt;</span></strong><span class="koboSpan" id="kobo.657.1"> component (</span><em class="italic"><span class="koboSpan" id="kobo.658.1">lines 4–14</span></em><span class="koboSpan" id="kobo.659.1">). </span><span class="koboSpan" id="kobo.659.2">This allows the user to switch between </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">available cameras.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">The user needs to manually activate a camera (also when switching between cameras) for security reasons. </span><span class="koboSpan" id="kobo.661.2">The button in the component toggles the camera stream (</span><em class="italic"><span class="koboSpan" id="kobo.662.1">lines 44–46</span></em><span class="koboSpan" id="kobo.663.1">). </span><span class="koboSpan" id="kobo.663.2">To display the stream, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">watchEffect</span></strong><span class="koboSpan" id="kobo.665.1"> to pipe the stream into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">video</span></strong><span class="koboSpan" id="kobo.667.1"> reference (</span><em class="italic"><span class="koboSpan" id="kobo.668.1">lines 48–50</span></em><span class="koboSpan" id="kobo.669.1">). </span><span class="koboSpan" id="kobo.669.2">We can display the camera feed to the user by referencing the stream in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">&lt;video /&gt;</span></strong><span class="koboSpan" id="kobo.671.1"> HTML component (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.672.1">line 20</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">Our stream is the replacement for the file upload of our prototype. </span><span class="koboSpan" id="kobo.674.2">We already have our store prepared to detect objects, so now, we’ll connect </span><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.675.1">the stream to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">detect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.677.1"> function.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.678.1">Detecting and recognizing objects on a stream</span></h2>
<p><span class="koboSpan" id="kobo.679.1">One of the changes from our prototype is the way we provide images to the object recognition method. </span><span class="koboSpan" id="kobo.679.2">Using a </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.680.1">stream means that we need to continuously process inpu</span><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.681.1">t, just as fast as the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">browser can.</span></span></p>
<h3><span class="koboSpan" id="kobo.683.1">Recognizing objects</span></h3>
<p><span class="koboSpan" id="kobo.684.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">detect</span></strong><span class="koboSpan" id="kobo.686.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">objectStore</span></strong><span class="koboSpan" id="kobo.688.1"> needs to </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.689.1">be able to determine if the recognized objects are the objects we are looking for. </span><span class="koboSpan" id="kobo.689.2">We’ll add some capabilities to the function in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">object.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.691.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.692.1">
    // ...abbreviated    const detect = async (img: any, </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">className?: string</span></strong><span class="koboSpan" id="kobo.694.1">) =&gt; {
        try {
            detected.value = []
            const result = await cocoSsdModel.detect(img)
            </span><strong class="bold"><span class="koboSpan" id="kobo.695.1">const filter = className ? </span><span class="koboSpan" id="kobo.695.2">(item: DetectedObject) =&gt; (item.score &gt;= config.DETECTION_ACCURACY_THRESHOLD &amp;&amp; item.class === className) : () =&gt; true</span></strong><span class="koboSpan" id="kobo.696.1">
            detected.value = result.map((item: DetectedObject) =&gt; item)</span><strong class="bold"><span class="koboSpan" id="kobo.697.1">.filter(filter).sort((a: DetectedObject, b: DetectedObject) =&gt; b.score - a.score)</span></strong><span class="koboSpan" id="kobo.698.1">
        } catch (e) {
            // handle error if model is not loaded
        }
    };
    // ...abbreviated</span></pre>
<p><span class="koboSpan" id="kobo.699.1">Here, we’re adding an optional parameter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">className</span></strong><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">If it’s provided, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">filter</span></strong><span class="koboSpan" id="kobo.703.1"> function. </span><span class="koboSpan" id="kobo.703.2">The filter is applied to the collection of recognized objects. </span><span class="koboSpan" id="kobo.703.3">If no </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">className</span></strong><span class="koboSpan" id="kobo.705.1"> is provided, that filter function just defaults to returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">true</span></strong><span class="koboSpan" id="kobo.707.1">, which means it doesn’t filter out any objects. </span><span class="koboSpan" id="kobo.707.2">We only do this to provide backward compatibility</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.708.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">&lt;ImageDetect /&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.710.1">component.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.711.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.712.1">When working on existing code bases, you have to keep these sorts of compatibility issues in mind while developing. </span><span class="koboSpan" id="kobo.712.2">In our case, backward compatibility was needed for a prototype function, so it’s not vital for our app. </span><span class="koboSpan" id="kobo.712.3">I’m highlighting this because, in large-scale applications with low test coverage, you may run into </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">these solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">With our changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">object.ts</span></strong><span class="koboSpan" id="kobo.716.1"> file, w</span><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.717.1">e can pass the stream </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">objectStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.721.1">Detecting objects from the stream</span></h3>
<p><span class="koboSpan" id="kobo.722.1">We’ll begin by passing the video</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.723.1"> stream’s contents to our updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">detect</span></strong><span class="koboSpan" id="kobo.725.1"> function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">objectStore</span></strong><span class="koboSpan" id="kobo.727.1">. </span><span class="koboSpan" id="kobo.727.2">We’ll also include </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">gameStore</span></strong><span class="koboSpan" id="kobo.729.1"> so that we can pass the current category as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">className</span></strong><span class="koboSpan" id="kobo.731.1"> property. </span><span class="koboSpan" id="kobo.731.2">Let’s add these lines to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">CameraDetect.vue</span></strong><span class="koboSpan" id="kobo.733.1"> file to get ourselves </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">set up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.735.1">
import { ref, watchEffect</span><strong class="bold"><span class="koboSpan" id="kobo.736.1">, watch</span></strong><span class="koboSpan" id="kobo.737.1"> } from "vue";// ...abbreviated
import { storeToRefs } from "pinia";
import { useObjectStore } from "@/store/object";
const objectStore = useObjectStore();
const { detected } = storeToRefs(objectStore);
const { detect } = objectStore;
import { useGameStore } from "@/store/game";
const gameStore = useGameStore();
const { currentCategory } = storeToRefs(gameStore);
// ...abbreviated</span></pre>
<p><span class="koboSpan" id="kobo.738.1">Don’t forget about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">watch</span></strong><span class="koboSpan" id="kobo.740.1"> hook that we import from Vue; we’ll need it to monitor camera activity! </span><span class="koboSpan" id="kobo.740.2">Next, we’ll</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.741.1"> add a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">detectObject</span></strong><span class="koboSpan" id="kobo.743.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">our scripts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.745.1">
const detectObject = async (): Promise&lt;void&gt; =&gt; {  if (!props.disabled) {
    await detect(video.value, currentCategory.value);
  }
  window.requestAnimationFrame(detectObject);
};</span></pre>
<p><span class="koboSpan" id="kobo.746.1">What’s happening here? </span><span class="koboSpan" id="kobo.746.2">We’ve created a recursive function that continuously calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">detect</span></strong><span class="koboSpan" id="kobo.748.1"> method by passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">video</span></strong><span class="koboSpan" id="kobo.750.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">currentCategory</span></strong><span class="koboSpan" id="kobo.752.1"> values. </span><span class="koboSpan" id="kobo.752.2">To throttle the calls, we’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">window.requestAnimationFrame</span></strong><span class="koboSpan" id="kobo.754.1"> (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><span class="koboSpan" id="kobo.755.1">https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame</span></a><span class="koboSpan" id="kobo.756.1">). </span><span class="koboSpan" id="kobo.756.2">Normally, this API is meant to query the browser when animating: the browser will accept the callback function once it’s ready to process it. </span><span class="koboSpan" id="kobo.756.3">This is perfect for our use case </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">as well!</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">We can trigger the initial call as soon as the video is enabled. </span><span class="koboSpan" id="kobo.758.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">watch</span></strong><span class="koboSpan" id="kobo.760.1"> hook we’ve imported can monitor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">enabled</span></strong><span class="koboSpan" id="kobo.762.1"> variable and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">detectObject</span></strong><span class="koboSpan" id="kobo.764.1"> function once the video has </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">been enabled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.766.1">
watch(enabled, () =&gt; {  if (enabled.value &amp;&amp; video.value) {
    video.value.addEventListener("loadeddata", detectObject);
  }
});</span></pre>
<p><span class="koboSpan" id="kobo.767.1">Finally, once we’ve found a match, we need to signal this to our application. </span><span class="koboSpan" id="kobo.767.2">We’ll add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">emit</span></strong><span class="koboSpan" id="kobo.769.1"> event called </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">found</span></strong><span class="koboSpan" id="kobo.771.1"> to trigger</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.772.1"> once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">detected</span></strong><span class="koboSpan" id="kobo.774.1"> property has been populated </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">with items:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.776.1">
const emit = defineEmits(["found"]);watch(detected, () =&gt; {
  if (detected.value?.length &gt; 0) {
    emit("found", detected.value[0]);
  }
});</span></pre>
<p><span class="koboSpan" id="kobo.777.1">We’re returning the top match from the collection of </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">detected</span></strong><span class="koboSpan" id="kobo.779.1"> items to the </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">parent component.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.781.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.782.1">You can make testing easier by temporarily modifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">objects</span></strong><span class="koboSpan" id="kobo.784.1"> property in </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">objectsStore</span></strong><span class="koboSpan" id="kobo.786.1"> so that it holds a couple of values of objects you have on hand, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">person</span></strong><span class="koboSpan" id="kobo.788.1">. </span><span class="koboSpan" id="kobo.788.2">Later, you can restore the list to its </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">previous state.</span></span></p>
<p><span class="koboSpan" id="kobo.790.1">Using Vue’s DevTools, you can test the app again. </span><span class="koboSpan" id="kobo.790.2">If you open the DevTools and navigate to the </span><strong class="bold"><span class="koboSpan" id="kobo.791.1">Timeline</span></strong><span class="koboSpan" id="kobo.792.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.793.1">Component events</span></strong><span class="koboSpan" id="kobo.794.1"> panels, once the camera has made a positive match, you will see continuous events being emitted (well, once for every </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">animation frame):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.796.1"><img alt="Figure 9.5 – Positive matches being emitted by the &lt;CameraDetect /&gt; component" src="image/B19563_09_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.797.1">Figure 9.5 – Positive matches being emitted by the &lt;CameraDetect /&gt; component</span></p>
<p><span class="koboSpan" id="kobo.798.1">We can now connect the emitted event to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">Find</span></strong><span class="koboSpan" id="kobo.800.1"> state. </span><span class="koboSpan" id="kobo.800.2">So, let’s move over to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">./views/Find.vue</span></strong><span class="koboSpan" id="kobo.802.1"> file so that </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.803.1">we can pick up on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">found</span><a id="_idTextAnchor314"/></strong><span class="koboSpan" id="kobo.805.1"> event and pull it into our </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">little game!</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.807.1">Connecting detection</span></h2>
<p><span class="koboSpan" id="kobo.808.1">If we open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">Find.vue</span></strong><span class="koboSpan" id="kobo.810.1"> file, we can</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.811.1"> now add the event handler on the component to the template. </span><span class="koboSpan" id="kobo.811.2">We’ll also provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">disable</span></strong><span class="koboSpan" id="kobo.813.1"> property to control the camera by changing the component line to </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.815.1">
&lt;CameraDetect @found="found" :disabled="detectionDisabled" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.816.1">In the script block, we have to make some changes to both pick up on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">found</span></strong><span class="koboSpan" id="kobo.818.1"> event and provide the value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">detectionDisabled</span></strong><span class="koboSpan" id="kobo.820.1"> property. </span><span class="koboSpan" id="kobo.820.2">Let’s look at the new component </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">code: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.14-Find.vue"><span class="No-Break"><span class="koboSpan" id="kobo.822.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/09.tensorflow/.notes/9.14-Find.vue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.823.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.824.1">We’ve added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">detectionDisabled</span></strong><span class="koboSpan" id="kobo.826.1"> reactive variable (</span><em class="italic"><span class="koboSpan" id="kobo.827.1">line 51</span></em><span class="koboSpan" id="kobo.828.1">) and are passing it down to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">&lt;CameraDetect /&gt; </span></strong><span class="koboSpan" id="kobo.830.1">component. </span><span class="koboSpan" id="kobo.830.2">In the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">skip</span></strong><span class="koboSpan" id="kobo.832.1"> function, we’re setting the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">detectionDisabled</span></strong><span class="koboSpan" id="kobo.834.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">false</span></strong><span class="koboSpan" id="kobo.836.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.837.1">line 68</span></em><span class="koboSpan" id="kobo.838.1">). </span><span class="koboSpan" id="kobo.838.2">We’re also adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">found</span></strong><span class="koboSpan" id="kobo.840.1"> function (</span><em class="italic"><span class="koboSpan" id="kobo.841.1">lines 78–86</span></em><span class="koboSpan" id="kobo.842.1">), where we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">detectionDisabled</span></strong><span class="koboSpan" id="kobo.844.1"> value as well and process a new score by calculating the certainty of the recognized object (</span><em class="italic"><span class="koboSpan" id="kobo.845.1">lines 81–83</span></em><span class="koboSpan" id="kobo.846.1">) and updating </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">gameStore</span></strong><span class="koboSpan" id="kobo.848.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.849.1">line 84</span></em><span class="koboSpan" id="kobo.850.1">). </span><span class="koboSpan" id="kobo.850.2">Similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">skip</span></strong><span class="koboSpan" id="kobo.852.1"> function, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">newRound</span></strong><span class="koboSpan" id="kobo.854.1"> function to progress </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">the game.</span></span></p>
<p><span class="koboSpan" id="kobo.856.1">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">newRound</span></strong><span class="koboSpan" id="kobo.858.1"> function has been called, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">detectionDisabled</span></strong><span class="koboSpan" id="kobo.860.1"> variable and set it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">true</span></strong><span class="koboSpan" id="kobo.862.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">continue detection.</span></span></p>
<p><span class="koboSpan" id="kobo.864.1">This would be another good time </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.865.1">to test the app. </span><span class="koboSpan" id="kobo.865.2">In this case, upon detection, you will rapidly progress through the rounds toward the end. </span><span class="koboSpan" id="kobo.865.3">If recognition seems unreliable, you can lower </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">DETECTION_A</span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.867.1">CCURACY_THRESHOLD</span></strong><span class="koboSpan" id="kobo.868.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">./</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">config.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.871.1"> file.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.872.1">Wrapping up the game flow</span></h1>
<p><span class="koboSpan" id="kobo.873.1">Although the game is now functional, it’s not playable since we’re not giving enough feedback to the user. </span><span class="koboSpan" id="kobo.873.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">appStore</span></strong><span class="koboSpan" id="kobo.875.1"> at our disposal, one of the easiest solutions is to use the dialog! </span><span class="koboSpan" id="kobo.875.2">Once</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.876.1"> we’ve incorporated that, our mini-game will </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">be complete!</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">First, we’ll update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">CameraDetect.vue</span></strong><span class="koboSpan" id="kobo.880.1"> file by adding the reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">dialogVisible</span></strong><span class="koboSpan" id="kobo.882.1"> reactive value. </span><span class="koboSpan" id="kobo.882.2">To do this, add the following to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">script</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.885.1">
// ...abbreviatedimport { useAppStore } from "@/store/app";
const appStore = useAppStore();
const { dialogVisible } = storeToRefs(appStore);
// ...abbreviated</span></pre>
<p><span class="koboSpan" id="kobo.886.1">Next, we’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">dialogVisible</span></strong><span class="koboSpan" id="kobo.888.1"> in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">detectObject</span></strong><span class="koboSpan" id="kobo.890.1"> function to assess whether it should call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">detect</span></strong><span class="koboSpan" id="kobo.892.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">objectStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.896.1">
// ...abbreviatedconst detectObject = async (): Promise&lt;void&gt; =&gt; {
  if (!props.disabled &amp;&amp; !dialogVisible.value) {
    await detect(video.value, currentCategory.value);
  }
  window.requestAnimationFrame(detectObject);
};
// ...abbreviated</span></pre>
<p><span class="koboSpan" id="kobo.897.1">This doesn’t affect our code yet since dialog has never been visible up until now. </span><span class="koboSpan" id="kobo.897.2">We’ll remedy that by making </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.898.1">some changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">Find.vue</span></strong><span class="koboSpan" id="kobo.900.1"> file as well. </span><span class="koboSpan" id="kobo.900.2">To define the contents of the dialog, we’ll add the following computed value to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">script</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.902.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.903.1">
// ...abbreviatedconst dialogEndLine = computed(() =&gt;
  objectsFound.value + skips.value &gt;= objectsLimit.value
    ? </span><span class="koboSpan" id="kobo.903.2">"You're done!"
</span><span class="koboSpan" id="kobo.903.3">    : "Get ready for the next round!"
</span><span class="koboSpan" id="kobo.903.4">);
// ...abbreviated</span></pre>
<p><span class="koboSpan" id="kobo.904.1">This returns a motivating line to display to the user. </span><span class="koboSpan" id="kobo.904.2">Feel free to modify this! </span><span class="koboSpan" id="kobo.904.3">The two functions that we’ll change are called </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">found</span></strong><span class="koboSpan" id="kobo.906.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">skipped</span></strong><span class="koboSpan" id="kobo.908.1">. </span><span class="koboSpan" id="kobo.908.2">Let’s have a look at the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">found</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.910.1">function first:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.911.1">
const found = (e: { class: string; score: number }) =&gt; {  detectionDisabled.value = true;
  objectsFound.value++;
  const newScore = Math.round(
    config.SCORE_FOUND * (e.score + 1) * config.SCORE_ACCURACY_MULTIPLIER
  );
  score.value += newScore;
  newRound();
  appStore.showDialog(
</span><strong class="bold"><span class="koboSpan" id="kobo.912.1">    "Congratulations! </span></strong><span class="koboSpan" id="kobo.913.1">🥳</span><strong class="bold"><span class="koboSpan" id="kobo.914.1">",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.915.1">    `&lt;p&gt;You've scored ${newScore} points by finding &lt;strong&gt;${e.class}&lt;/strong&gt;!&lt;/p&gt;&lt;p&gt;${dialogEndLine.value}&lt;/p&gt;`</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.916.1">  );</span></strong><span class="koboSpan" id="kobo.917.1">
};</span></pre>
<p><span class="koboSpan" id="kobo.918.1">As you can see, we’re simply using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">appStore</span></strong><span class="koboSpan" id="kobo.920.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">showDialog</span></strong><span class="koboSpan" id="kobo.922.1"> to present a dialog to the user. </span><span class="koboSpan" id="kobo.922.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">&lt;CameraDetect /&gt;</span></strong><span class="koboSpan" id="kobo.924.1"> component is now able to detect when a dialog is visible </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.925.1">and will stop detecting in the background. </span><span class="koboSpan" id="kobo.925.2">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">skipped</span></strong><span class="koboSpan" id="kobo.927.1"> function, we’ll add </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.929.1">
const skipped = () =&gt; {  detectionDisabled.value = true;
  skips.value++;
  if ((score.value + config.SCORE_SKIP) &lt;= 0) {
    score.value = 0;
  } else {
    score.value += config.SCORE_SKIP;
  }
  newRound();
</span><strong class="bold"><span class="koboSpan" id="kobo.930.1">  appStore.showDialog(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.931.1">    "Oh no! </span></strong><span class="koboSpan" id="kobo.932.1">🙀</span><strong class="bold"><span class="koboSpan" id="kobo.933.1">",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.934.1">    `&lt;p&gt;Skipping cost you ${-config.SCORE_SKIP} points!&lt;/p&gt;&lt;p&gt;${</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.935.1">      dialogEndLine.value</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.936.1">    }&lt;/p&gt;`</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.937.1">  );</span></strong><span class="koboSpan" id="kobo.938.1">
};</span></pre>
<p><span class="koboSpan" id="kobo.939.1">As you can see, these are very similar changes! </span><span class="koboSpan" id="kobo.939.2">Again, feel free to modify these contents to your liking </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.941.1">Our game is now done! </span><span class="koboSpan" id="kobo.941.2">Hooray! </span><span class="koboSpan" id="kobo.941.3">We’ve now almost concluded our collection of applications. </span><span class="koboSpan" id="kobo.941.4">I think this </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.942.1">game lends itself to being enriched with even more capabilities and more customization so that you can make it your own mini-game. </span><span class="koboSpan" id="kobo.942.2">From previous chapters, we’ve touched upon a lot of additional techniques and co</span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.943.1">ncepts you could apply or just </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">get creative.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.945.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.946.1">We started this chapter with a small prototype to experiment with a new sort of technology. </span><span class="koboSpan" id="kobo.946.2">Building something in an isolated environment helps you quickly understand how a certain technology can be adopted in an existing environment. </span><span class="koboSpan" id="kobo.946.3">As you’ve experienced, we were running into limitations that could not be resolved. </span><span class="koboSpan" id="kobo.946.4">In this case, it didn’t matter that much, since we have few business requirements to </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">deal with.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">We also learned how to leverage existing and available APIs from the browser itself to build something unconventional. </span><span class="koboSpan" id="kobo.948.2">When putting together a portfolio, standing out with unique projects can make you stand out as a developer. </span><span class="koboSpan" id="kobo.948.3">Building little projects while combining multiple technologies can help you understand how you can compose applications with them. </span><span class="koboSpan" id="kobo.948.4">This is a more intensive approach but results in a much better understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">of technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.950.1">Feel free to spend some time customizing projects from previous chapters. </span><span class="koboSpan" id="kobo.950.2">In the final chapter, we are going to create a portfolio to host online. </span><span class="koboSpan" id="kobo.950.3">This will be the perfect showcase for everything you’ve achieved </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">so far!</span></span></p>
</div>


<div class="Content" id="_idContainer100">
<h1 id="_idParaDest-187" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.1.1">Part 4: Wrapping Up</span></h1>
<p><span class="koboSpan" id="kobo.2.1">The final part brings all the previous topics together. </span><span class="koboSpan" id="kobo.2.2">You will learn how to optimize Nuxt for a static site purpose and how to deploy to a web host. </span><span class="koboSpan" id="kobo.2.3">Then, we will look into automating workflows such as the deployment process. </span><span class="koboSpan" id="kobo.2.4">This section gives you the freedom to customize the output for your personal use and connects all previous chapters into a </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">presentable portfolio.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapter:</span></span></p>
<ul>
<li><a href="B19563_10.xhtml#_idTextAnchor321"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Building a Portfolio with Nuxt.js and Storyblok</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer101">
</div>
</div>
<div>
<div id="_idContainer102">
</div>
</div>
<div>
<div id="_idContainer103">
</div>
</div>
<div>
<div id="_idContainer104">
</div>
</div>
<div>
<div id="_idContainer105">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer106">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer107">
</div>
</div>
<div>
<div id="_idContainer108">
</div>
</div>
<div>
<div id="_idContainer109">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer110">
</div>
</div>
</body></html>