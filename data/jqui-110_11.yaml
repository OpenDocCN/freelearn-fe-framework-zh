- en: Chapter 11. Drag and Drop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。拖拽功能
- en: So far in this book, we've covered the complete range of fully released interface
    widgets, and over the next four chapters, we're going to shift our focus to the
    core interaction helpers. These are widgets that provide mouse-based interactions
    for widgets, where we can perform actions, such as selecting, dragging, or resizing
    widgets on a website. A perfect example is the resizable widget, which we will
    cover in [Chapter 12](ch12.html "Chapter 12. The Resizable Component"), *The Resizable
    Component*. These interaction components of the library differ from those we've
    already looked at, in that they are not physical objects or widgets that exist
    on the page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经涵盖了完全发布的完整范围的界面小部件，并在接下来的四章中，我们将把重点转向核心交互辅助工具。这些是为小部件提供基于鼠标的交互的小部件，我们可以在网站上执行选择、拖动或调整小部件等操作。一个完美的例子是可调整大小的小部件，我们将在[第12章](ch12.html
    "第12章。可调整大小的组件")中进行讨论，*可调整大小的组件*。这些库的交互组件与我们已经查看过的组件不同，因为它们不是页面上存在的物理对象或小部件。
- en: These are low-level interaction components, as opposed to the high-level widgets
    that we looked at in the first part of this book. They help the elements used
    on your pages to be more engaging and interactive for your visitors, which adds
    value to your site and can help make your web applications appear more professional.
    They also help to blur the distinctions between the browser and the desktop, and
    provide greater usability to make web applications more efficient, effective,
    and natural.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是低级交互组件，与本书第一部分我们查看的高级小部件相对。它们帮助您页面上使用的元素更具吸引力和互动性，为您的访问者增添价值，可以帮助使您的Web应用程序看起来更专业。它们还有助于模糊浏览器和桌面之间的区别，提供更大的可用性，使Web应用程序更加高效、有效和自然。
- en: In this chapter, we'll be covering two very closely related components—**draggables**
    and **droppables**. The draggables API transforms any specified element into something
    that your visitors can pick up with the mouse pointer and drag around the page.
    Methods that are exposed allow you to restrict the draggables movement, make it
    return to its starting point after being dropped, and much more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论两个非常相关的组件—**可拖动**和**可放置物品**。可拖动的API将任何指定的元素转换为您的访问者可以用鼠标指针拾起并在页面上拖动的东西。公开的方法允许您限制拖动物品的移动，使其在放下后返回到起始点，以及更多功能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: How to make elements draggable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使元素可拖动
- en: The options available for configuring draggable objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置可拖动对象的选项
- en: How to make an element return to its starting point once the drag ends
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使一个元素在拖动结束后返回到起始点
- en: How to use event callbacks at different points in an interaction
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在交互的不同点使用事件回调
- en: The role of a drag helper
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动助手的作用
- en: Containing draggables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含可拖动物品
- en: How to control draggability with the component's methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用组件的方法控制可拖动性
- en: Turning an element into a drop target
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元素转换为放置目标
- en: Defining accepted draggables
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义接受的可拖动物品
- en: Working with droppable class names
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可放置类名
- en: Defining drop tolerance
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义放置容忍度
- en: Reacting to interactions between draggables and droppables
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对可拖动物品和可放置物品之间的交互做出反应
- en: The droppables API allows you to define a region of the page or a container
    of some kind for people to drop the draggables on to in order to make something
    else happen, for example, while adding a product to a shopping basket. A rich
    set of events is fired by the droppable widget that lets us react to the most
    interesting moments of any drag interaction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可放置的API允许您定义页面的区域或某种容器，使人们可以将可拖动物品拖放到其中以触发其他操作，例如，将产品添加到购物篮中。可放置小部件触发的一系列事件让我们对任何拖动交互的最有趣时刻做出反应。
- en: The deal with draggables and droppables
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理可拖动和可放置物品的交易
- en: Dragging and dropping as behaviors go hand-in-hand with each other. Where one
    is found, the other is invariably close by. Dragging an element around a web page
    is all very well and good, but if there's nowhere for that element to be dragged
    to, the whole exercise is usually pointless.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放行为总是相辅相成。一个找到，另一个总是附近。在网页上拖曳元素是非常不错的，但如果没有地方可以将该元素拖拽到，那么整个操作通常是没有意义的。
- en: You can use the `draggable` class independently from the `droppable` class,
    as pure dragging for the sake of dragging can have its uses, such as with the
    dialog component. However, you can't use the `droppable` class without the `draggable`
    class. You don't need to make use of any of draggable's methods of course, but
    using droppables without having anything to drop on to them is of no value whatsoever.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以独立使用`draggable`类，而不使用`droppable`类，因为纯粹的拖动可能会有其用途，例如对话框组件。但是，您不能在没有`draggable`类的情况下使用`droppable`类。当然，您不需要使用任何可拖动的方法，但是没有任何东西可放置在其上的可拖放对象是毫无价值的。
- en: Like with the widgets, it is possible, however, to combine some of the interaction
    helpers; draggables and droppables go together obviously. But draggables can also
    be used with sortables, as we'll see in [Chapter 13](ch13.html "Chapter 13. Selecting
    and Sorting with jQuery UI"), *Selecting and Sorting with jQuery UI*, as well
    as resizables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与小部件一样，显然可以将一些交互帮助程序组合起来；拖动和放置显然是一起的。但是，拖动器还可以与可排序的一起使用，正如我们将在[第13章](ch13.html
    "第13章。使用jQuery UI进行选择和排序")所见，*使用jQuery UI进行选择和排序*，以及可调整大小的内容。
- en: Getting started with the draggable widget
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可拖拽小部件入门
- en: The draggables component is used to make any specified element or collection
    of elements draggable, so that they can be picked up and moved around the page
    by a visitor. Draggability is a great effect, and is a feature that can be used
    in numerous ways to improve the interface of our web pages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可拖拽组件用于使任何指定的元素或元素集合可拖动，以便访问者可以将它们拾取并在页面上移动。可拖拽性是一个很棒的效果，是一个可以以多种方式用于改进网页界面的功能。
- en: Using jQuery UI means that we don't have to worry about all of the tricky differences
    between browsers that originally made draggable elements on web pages a nightmare
    to implement and maintain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery UI意味着我们不必担心最初使网页上的可拖动元素实现和维护成为一场噩梦的各种棘手的浏览器之间的差异。
- en: Implementing a basic drag
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基本拖动
- en: Let's look at the default implementation by first making a simple `<div>` element
    draggable. We won't do any additional configuration. Therefore, all that this
    code will allow you to do is pick up the element with the mouse pointer and drag
    it around the viewport.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过首先使简单的`<div>`元素可拖动来查看默认实现。我们不会进行任何其他配置。因此，此代码将允许您使用鼠标指针拾取元素并在视口周围拖动它。
- en: 'In a new file in your text editor, add the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中的新文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save this as `draggable1.html` in your `jqueryui` folder. As with the widget-based
    components of jQuery UI, the draggable component can be enabled using a single
    line of code. This invokes the draggable''s constructor method: `draggable` and
    turns the specified element into a drag object.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`draggable1.html`文件到您的`jqueryui`文件夹中。与jQuery UI的基于小部件的组件一样，可以使用一行代码启用可拖拽组件。这会调用可拖拽的构造方法：`draggable`，并将指定的元素转换为拖动对象。
- en: 'We need the following files from the library to enable draggability on an element:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从库中获取以下文件，以在元素上启用可拖拽性：
- en: '`jquery-2.0.3.js`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-2.0.3.js`'
- en: '`jquery.ui.core.js`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.core.js`'
- en: '`jquery.ui.widget.js`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.widget.js`'
- en: '`jquery.ui.mouse.js`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.mouse.js`'
- en: '`jquery.ui.draggable.js`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.draggable.js`'
- en: 'We''re using a plain `<div>` element with a background image specified in the
    CSS file that we''re linking to in the `<head>` tag of the page. Use the following
    stylesheet for the drag element:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用在页面的`<head>`标签中链接到的CSS文件中指定的带背景图像的普通`<div>`元素。使用以下样式表作为拖动元素：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save this as `draggable.css` in the `css` folder. When you view the page in
    a browser, you''ll see that the image can be moved around the draggable area as
    shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`draggable.css`文件到`css`文件夹中。当您在浏览器中查看页面时，您将看到图像可以在可拖动区域内移动，如以下屏幕截图所示：
- en: '![Implementing a basic drag](img/2209OS_11_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![实现基本拖动](img/2209OS_11_01.jpg)'
- en: Configuring the draggable options
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置可拖拽选项
- en: 'The draggable component has a wide range of configurable options, giving us
    a very fine degree of control over the behavior that it adds. The following table
    lists the options that we can manipulate to configure and control our drag elements:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可拖拽组件具有广泛的可配置选项，使我们对其添加的行为具有非常细微的控制。以下表格列出了我们可以操作以配置和控制我们的拖动元素的选项：
- en: '| Option | Default value | Used to… |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `addClasses` | `true` | Add the `ui-draggable` class to the drag object.
    Set it to `false` to prevent this class being added. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `addClasses` | `true` | 向拖动对象添加`ui-draggable`类。将其设置为`false`以防止添加此类。'
- en: '| `appendTo` | `"parent"` | Specify a container element for drag objects with
    a helper attached. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `appendTo` | `"parent"` | 为带有附加辅助元素的拖动对象指定容器元素。'
- en: '| `axis` | `false` | Constrain drag objects to one axis of motion. Accepts
    the strings `x` and `y` as values, or the Boolean `false`. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `axis` | `false` | 将拖动对象约束于一个运动轴。接受字符串`x`和`y`作为值，或者布尔值`false`。'
- en: '| `cancel` | `":input, option"` | Prevent certain elements from being dragged,
    if they match the specified element selector. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `cancel` | `":input, option"` | 防止匹配指定元素选择器的某些元素被拖动。'
- en: '| `connectToSortable` | `false` | Allow the drag object to be dropped on to
    a sortable list and become one of the sort elements. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `connectToSortable` | `false` | 允许将拖动对象放置到可排序列表中并成为排序元素之一。'
- en: '| `containment` | `false` | Prevent drag objects from being dragged out of
    the bounds of its parent element. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `containment` | `false` | 防止拖动对象被拖出其父元素的边界。'
- en: '| `cursor` | `"auto"` | Specify a CSS cursor to be used while the pointer is
    over the drag object. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `cursor` | `"auto"` | 指定指针在拖动对象上时使用的CSS光标。'
- en: '| `cursorAt` | `false` | Specify a default position at which the cursor appears
    relative to the drag object, while it is being dragged. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `cursorAt` | `false` | 指定拖动对象在拖动时相对于拖动对象出现的默认位置。'
- en: '| `delay` | `0` | Specify a time in milliseconds that the start of the drag
    interaction should be delayed by. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `delay` | `0` | 指定延迟拖动交互开始的时间（以毫秒为单位）。'
- en: '| `disabled` | `false` | Disable dragging on the draggable. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | `false` | 禁用可拖动的拖动对象。'
- en: '| `distance` | `1` | Specify the distance in pixels that the pointer should
    move with the mouse button held down on the drag object, before the drag begins.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | `1` | 指定在鼠标按钮按住拖动对象时指针应该移动的像素距离，以便开始拖动。'
- en: '| `grid` | `false` | Make the drag object snap to an imaginary grid on the
    page. Accepts an array containing `x` and `y` pixel values of the grid. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `grid` | `false` | 使拖动对象吸附到页面上的虚拟网格。接受包含网格的`x`和`y`像素值的数组。'
- en: '| `handle` | `false` | Define a specific area of the drag object that is used
    to hold the pointer on, in order to drag. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `handle` | `false` | 定义用于保持指针以便拖动的拖动对象的特定区域。'
- en: '| `helper` | `"original"` | Define a pseudo-drag element that is dragged instead
    of the drag object. Can accept the string values original or clone, or can accept
    a function that returns the helper element. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `helper` | `"original"` | 定义一个伪拖动元素，该元素代替拖动对象进行拖动。可以接受字符串值original或clone，也可以接受返回辅助元素的函数。'
- en: '| `iframeFix` | `false` | Stop all the `<iframe>` elements on the page from
    capturing mouse events, while a drag is in progress. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `iframeFix` | `false` | 在拖动进行时阻止页面上的所有`<iframe>`元素捕获鼠标事件。'
- en: '| `opacity` | `false` | Set the opacity of the helper element. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `opacity` | `false` | 设置辅助元素的不透明度。'
- en: '| `refreshPositions` | `false` | Calculate the positions of all the drop objects
    while the drag is in progress. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `refreshPositions` | `false` | 在拖动进行中计算所有放置对象的位置。'
- en: '| `revert` | `false` | Make the drag object return to its start position once
    the drag ends, when set to `true`. Can also accept the strings valid and invalid,
    where revert is only applied if the drag object is dropped on a valid drop object
    or vice versa, respectively. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `revert` | `false` | 将拖动对象设置为`true`时，拖动对象在拖动结束时返回其起始位置。还可以接受valid和invalid字符串，其中revert仅在拖动对象放置在有效的放置对象上，或者反之亦然时应用。'
- en: '| `revertDuration` | `500` | Set the number of milliseconds it takes for the
    drag object to return to its starting position. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `revertDuration` | `500` | 拖动对象返回到其起始位置所需的毫秒数。'
- en: '| `scope` | `"default"` | Set the scope of the drag object with respect to
    the drop objects that are valid for it. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | `"default"` | 设置拖动对象相对于对其有效的放置对象的范围。'
- en: '| `scroll` | `true` | Make the viewport automatically scroll when the drag
    object is moved within the threshold of the viewport''s edge. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `scroll` | `true` | 在拖动对象移动到视口边缘的阈值内时，使视口自动滚动。'
- en: '| `scrollSensitivity` | `20` | Define how close in pixels the drag object should
    get to the edge of the viewport, before scrolling begins. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `scrollSensitivity` | `20` | 定义拖动对象在接近视口边缘多少像素之前开始滚动。'
- en: '| `scrollSpeed` | `20` | Set the speed at which the viewport scrolls. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `scrollSpeed` | `20` | 设置视口滚动的速度。'
- en: '| `snap` | `false` | Cause drag objects to snap to the edges of specified elements.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `snap` | `false` | 导致拖动对象捕捉到指定元素的边缘。'
- en: '| `snapMode` | `"both"` | Specify which edges of the element the drag object
    will snap to. Can be set to either `inside`, `outside`, or `both`. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `snapMode` | `"both"` | 指定拖动对象将对元素的哪些边缘进行捕捉。可以设置为`inside`、`outside`或`both`。'
- en: '| `snapTolerance` | `20` | Set the distance from snapping elements that drag
    objects should reach, before snapping occurs. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `snapTolerance` | `20` | 设置拖动对象应达到的与捕捉元素的距离，之后才会发生捕捉。'
- en: '| `stack` | `false` | Ensure that the current drag object is always on top
    of other drag objects in the same group. Accepts an object containing `group`
    and/or `min` properties. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `stack` | `false` | 确保当前拖动对象始终位于同一组中其他拖动对象的顶部。接受包含`group`和/或`min`属性的对象。'
- en: '| `zIndex` | `false` | Set the `zIndex` of the helper element. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `zIndex` | `false` | 设置助手元素的`zIndex`。'
- en: Using the configuration options
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置选项
- en: Let's put some of these options to use. They can be configured in exactly the
    same way as the options exposed by the widgets that we looked at in previous chapters,
    and also usually have both getter and setter modes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其中一些选项投入使用。它们可以以与我们在之前章节中看到的小部件暴露的选项完全相同的方式进行配置，并且通常具有获取器和设置器模式。
- en: In the first example a moment ago, we used CSS to specify that the move cursor
    should be used when the pointer hovers over our draggable `<div>`. Let's change
    this and use the `cursor` option of the draggables component instead.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚才的第一个示例中，我们使用CSS指定当指针悬停在可拖动的`<div>`上时应使用移动光标。让我们改变一下，改为使用拖动组件的`cursor`选项。
- en: 'Remove `cursor: move` from draggable.css, and resave it as `draggableNoCursor
    .css`. Also change the `<link>` tag in `draggable1.html`, to reference the new
    file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '从draggable.css中删除`cursor: move`，并重新保存为`draggableNoCursor .css`。同时将`draggable1.html`中的`<link>`标签更改为引用新文件：'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then change the final `<script>` element to the following one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将最后一个`<script>`元素更改为以下内容：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save this as `draggable2.html`, and try it out in your browser. An important
    point to note about this option is that the move cursor that we have specified
    is not applied until we actually start the drag. While using this option in place
    of simple CSS, we should perhaps provide some other visual cue that the element
    is draggable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`draggable2.html`，在浏览器中尝试一下。关于此选项的一个重要注意事项是，我们指定的移动光标直到实际开始拖动才会应用。在使用此选项替代简单CSS时，也许应该提供一些其他的视觉提示，表明元素是可拖动的。
- en: 'Let''s look at a few more of draggable''s many configuration options. Change
    the configuration object in `draggable2.html` to the following one:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可拖动组件的许多配置选项中的更多。将`draggable2.html`中的配置对象更改为以下内容：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This can be saved as `draggable3.html`. The first new option that we've configured
    is the `axis` option, which has restricted the draggable to moving only upwards
    or downwards in the page, but not side to side across it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将此保存为`draggable3.html`。我们配置的第一个新选项是`axis`选项，这个选项限制了可拖动元素只能在页面上向上或向下移动，而不能横跨页面从一侧到另一侧。
- en: Next, we've specified `30` as the value of the `distance` option. This means
    that the cursor will have to travel `30` pixels across the drag object, with the
    mouse button held down, before the drag begins.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们已将`distance`选项的值指定为`30`。这意味着在按住鼠标按钮的情况下，光标必须横穿拖动对象`30`像素，拖动才会开始。
- en: The final option `cursorAt` is configured using an object literal, whose properties
    can be `top`, `right`, `bottom`, or `left`. The values supplied to the properties
    that we choose to use are the values relative to the drag object that the cursor
    will assume, when a drag occurs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的选项`cursorAt`是使用对象文字配置的，其属性可以是`top`、`right`、`bottom`或`left`。我们选择使用的属性所提供的值是光标在进行拖动时在拖动对象相对于的数值。
- en: However, you'll notice in this example that the value for the `left` option
    seems to be ignored. The reason for this is that we have configured the `axis`
    option. When we begin the drag, the drag object will automatically move so that
    the cursor is at `0` pixels from the top of the element, but it will not move
    so that the cursor is `0` pixels from the left edge as we have specified because
    the drag object cannot move left.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您会注意到在此示例中，`left`选项的值似乎被忽略了。这是因为我们已经配置了`axis`选项。当我们开始拖动时，拖动对象将自动移动，以使光标距元素顶部`0`像素，但它不会移动，以使光标距离左侧边缘`0`像素，因为我们已经指定了拖动对象不能向左移动。
- en: 'Let''s look at some more of the draggable''s options in action. Change `draggable3.html`
    so that the configuration object appears as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些可拖动选项的更多实际操作。更改 `draggable3.html`，使配置对象如下所示：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the file as `draggable4.html`. The `delay` option, which takes a value
    in milliseconds, specifies the length of time that the mouse button must be held
    down with the cursor over the drag object, before the drag begins.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为 `draggable4.html`。`delay` 选项接受以毫秒为单位的值，指定必须将鼠标按钮保持在拖动对象上的时间长度，然后才能开始拖动。
- en: The `grid` option is similar in usage to the `steps` option of the slider widget.
    It is configured using an array of two values representing the number of pixels
    along each `axis` that the drag element should jump when it is dragged. This option
    can be used safely in conjunction with the `axis` option.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid` 选项的用法类似于滑块小部件的 `steps` 选项。它使用一个表示拖动元素在每个 `axis` 上应跳跃的像素数的数组进行配置。此选项可以安全地与
    `axis` 选项一起使用。'
- en: Resetting the dragged elements
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置拖动的元素
- en: 'It is very easy to configure drag objects to return to their original starting
    position on the page once they''ve been dropped, and there are several options
    that can be used to control this behavior. Change the configuration object that
    we used with `draggable4.html`, so that it appears as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 非常容易配置拖动对象，使其在放置后返回到其原始起始位置，并且有几个选项可用于控制此行为。更改我们用于 `draggable4.html` 的配置对象，使其如下所示：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save this as `draggable5.html`. By supplying `true` as the value of the `revert`
    option, we've caused the drag object to return to its starting position at the
    end of any drag interaction. However, you'll notice that the drag element doesn't
    just pop back to its starting position instantly. Rather, it's smoothly animated
    back, with no additional configurations required.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `draggable5.html`。通过将 `revert` 选项的值设置为 `true`，我们导致拖动对象在任何拖动交互结束时返回到其起始位置。但是，您会注意到拖动元素不会立即弹回其起始位置。相反，它会平滑地动画返回，无需额外的配置。
- en: 'Another revert-related option is the `revertDuration` option, which we can
    use to control the speed of the revert animation. Change the configuration object
    in `draggable5.html`, so that it appears as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与恢复相关的选项是 `revertDuration` 选项，我们可以使用它来控制恢复动画的速度。更改 `draggable5.html` 中的配置对象，使其如下所示：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save this as `draggable6.html`. The default value for the `revertDuration` option
    is `500` milliseconds, so by lowering it to `100`, the relative speed of the animation
    is considerably increased.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `draggable6.html`。`revertDuration` 选项的默认值是 `500` 毫秒，因此将其降低到 `100`，动画的相对速度大大增加。
- en: The actual speed of the animation will always be determined on the fly, based
    on the distance from the drop point to the starting point. The `revertDuration`
    option simply defines a target for the animation length in time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的实际速度将根据从放置点到起点的距离实时确定。`revertDuration` 选项只是定义了动画长度的目标时间。
- en: Adding the drag handle support
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加拖动句柄支持
- en: The `handle` option allows us to define a region of the drag object that can
    be used to drag the object. No other areas can be used to drag the object. A simple
    analogy is the `dialog` widget. You can drag the dialog around only if you click
    and hold on the title bar. The title bar is the drag handle.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle` 选项允许我们定义可以用于拖动对象的拖动区域。不能使用其他区域来拖动对象。一个简单的类比是 `dialog` 小部件。只有在标题栏上点击并按住时，才能拖动对话框。标题栏是拖动句柄。'
- en: 'In the following example, we''ll add a simple drag handle to our drag object.
    Put a new empty `<div>` element inside the drag element:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将为拖动对象添加一个简单的拖动句柄。在拖动元素内部放置一个新的空 `<div>` 元素：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, change the configuration object to the following one:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将配置对象更改为以下内容：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save this as `draggable7.html`. We've given the new `<div>` an `id` attribute
    and then specified this `id` as the value of the `handle` option in our configuration
    object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `draggable7.html`。我们给新的 `<div>` 加了一个 `id` 属性，然后在配置对象中将此 `id` 指定为 `handle`
    选项的值。
- en: 'The handle is styled with a few simple style rules. Add the following new styles
    to `draggableNoCursor.css`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 句柄使用几个简单的样式规则进行样式化。将以下新样式添加到 `draggableNoCursor.css`：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save this as `dragHandle.css` in the `css` folder. Don''t forget to link to
    the new stylesheet from `<head>` of `draggable7.html`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `dragHandle.css` 在 `css` 文件夹中。不要忘记从 `draggable7.html` 的 `<head>` 部分链接到新样式表：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we preview the page in a browser, we see that the original drag object
    is still draggable, but only when the handle is selected with the pointer as seen
    in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中预览页面时，我们看到原始拖动对象仍然可拖动，但仅当使用指针选择手柄时才可见，如下截图所示：
- en: '![Adding the drag handle support](img/2209OS_11_02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![添加拖动手柄支持](img/2209OS_11_02.jpg)'
- en: Adding the helper elements
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加助手元素
- en: Several configuration options are directly related to drag helpers. A helper
    is a substitute element that is used to show where the object is on screen, while
    the drag is in progress, instead of moving the actual draggable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 几个配置选项与拖动助手直接相关。助手是一个替代元素，用于在拖动进行中显示对象在屏幕上的位置，而不是移动实际可拖动的元素。
- en: A helper can be a very simple object in place of the actual drag object. It
    can help cut down on the intensity of the drag operation, lessening the load on
    the visitor's processor. Once the drag is completed, the actual element can be
    moved to the new location.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 助手可以是实际拖动对象的非常简单的对象。它可以帮助减少拖动操作的强度，减轻访问者处理器的负载。拖动完成后，实际元素可以移动到新位置。
- en: 'Let''s look at how helpers can be used in the following example. Remove the
    `<div>` element we used for `handle` and revert back to the `draggable.css` stylesheet
    in `draggable7.html`, and then change the configuration object to the following
    one:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看助手如何在以下示例中使用。删除我们用于`handle`的`<div>`元素，并恢复到`draggable7.html`中的`draggable.css`样式表，然后将配置对象更改为以下内容：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Save this file as `draggable8.html`. We also need to tweak the CSS so that
    the cursor changes to indicate that we''re moving the image at the appropriate
    time. Alter the CSS in `draggable.css` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`draggable8.html`。我们还需要调整CSS，以便在适当的时候更改光标以指示我们正在移动图像。如下更改`draggable.css`中的CSS：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The value `clone` for the `helper` option causes an exact copy of the original
    drag object to be created and used as draggable. Therefore, the original object
    stays in its starting position at all times. This also causes the `clone` object
    to revert back to its starting position, an effect that cannot be changed, even
    by supplying `false` as the value of the `revert` option. The following screenshot
    shows the `clone` option in action:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`helper`选项的值`clone`会创建原始拖动对象的精确副本，并将其用作可拖动对象。因此，原始对象始终保持在其起始位置。这也会导致`clone`对象恢复到其起始位置，即使通过提供`false`作为`revert`选项的值也无法更改此效果。以下截图显示了`clone`选项的效果：
- en: '![Adding the helper elements](img/2209OS_11_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![添加助手元素](img/2209OS_11_03.jpg)'
- en: In addition to the string `clone` and the default `original`, we can also use
    a function as the value for this option. This allows us to specify our own custom
    element to use as the helper.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串`clone`和默认的`original`之外，我们还可以使用函数作为此选项的值。这使我们能够指定我们自己的自定义元素用作助手。
- en: 'Change the final `<script>` element in `draggable8.html` to the following one:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将`draggable8.html`中的最终`<script>`元素更改为以下内容：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save this file as `draggable9.html`. Our `helperMaker()` function creates a
    new `<div>` element using standard jQuery functionality, and then sets some CSS
    properties on it to define its physical appearance. It then, importantly, returns
    the new element. While supplying a function as the value of the `helper` option,
    the function must return an element (either a jQuery object, as in this example,
    or an actual DOMNode).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`draggable9.html`。我们的`helperMaker()`函数使用标准的jQuery功能创建一个新的`<div>`元素，然后在其上设置一些CSS属性以定义其外观。然后，重要的是返回新元素。在将函数作为`helper`选项的值时，该函数必须返回一个元素（可以是jQuery对象，如本例中，也可以是实际的DOMNode）。
- en: Now when the drag begins, it is our custom helper that becomes the drag object.
    Because the custom element is much simpler than the original drag object, it can
    help improve the responsiveness and performance of the application in which it
    is used.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当拖动开始时，我们的自定义助手成为拖动对象。由于自定义元素比原始拖动对象简单得多，因此可以帮助改善所使用的应用程序的响应性和性能。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that when you use the helper (clone) elements that you use the element
    with class and not IDs, because IDs must be unique in the DOM, and the clone will
    duplicate it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在使用助手（克隆）元素时使用具有类而不是ID的元素，因为ID在DOM中必须是唯一的，并且克隆将其复制。
- en: 'The following screenshot shows our custom helper:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的自定义助手：
- en: '![Adding the helper elements](img/2209OS_11_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![添加助手元素](img/2209OS_11_04.jpg)'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Helper opacity**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**助手不透明度**'
- en: We used the `css` jQuery method in this example during the creation of the custom
    helper. However, we can also use the `opacity` option of the drag object to set
    the opacity of helper elements as a cross-platform solution.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建自定义助手时在本示例中使用了 `css` jQuery 方法。但是，我们还可以使用拖动对象的 `opacity` 选项来设置助手元素的不透明度，作为跨平台解决方案。
- en: Constraining the drag
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制拖动
- en: Another aspect of drag scenarios is that of containment. In our examples so
    far, the `<body>` element of the page has been the container of the drag object.
    There are also options that we can configure to specify how the drag object behaves
    with regards to another container element.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动场景的另一个方面是 containment（包含性）。到目前为止，我们的示例中，页面的`<body>`元素一直是拖动对象的容器。我们还可以配置选项，以指定拖动对象在与另一个容器元素相关时的行为。
- en: 'We''ll look at these in the following examples, starting with the `containment`
    option, which allows us to specify a container element for the drag object. In
    the `<head>` tag of `draggable9.html`, add the following link to the stylesheet
    that we''ll be using in this example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的示例中查看这些内容，从`containment`选项开始，该选项允许我们为拖动对象指定一个容器元素。在`draggable9.html`的`<head>`标签中，添加以下链接到我们在本示例中将使用的样式表：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then wrap the drag element within a container `<div>` as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将拖动元素包装在一个容器 `<div>` 中，如下所示：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then change the configuration object to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将配置对象更改为以下内容：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save this variant as `draggable10.html`. On the page, we've added a new `<div>`
    element as the parent of the existing drag element. In the code, we've used the
    value `parent` for the `containment` option, so the element that is the direct
    parent of the drag object (the `<div>` element with the `id` of `container` in
    this example) will be used as the container.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将此变体保存为 `draggable10.html`。在页面上，我们添加了一个新的 `<div>` 元素作为现有拖动元素的父级。在代码中，我们使用了 `containment`
    选项的值 `parent`，因此直接父级拖动对象的元素（在本示例中是具有 `id` 为 `container` 的 `<div>` 元素）将被用作容器。
- en: The parent `<div>` needs some basic styling to give dimensions to it and so
    it can be seen on the page. Add the following code to `draggable.css` and resave
    the file as `draggableContainer.css`. Remember, this string is not the `id` of
    an element or a jQuery selector (although selectors are also supported).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 父级 `<div>` 需要一些基本样式以给它尺寸，并且可以在页面上看到。将以下代码添加到 `draggable.css` 中，并将文件另存为 `draggableContainer.css`。记住，这个字符串不是元素的
    `id` 或 jQuery 选择器（尽管选择器也受支持）。
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you run the page in your browser, you'll see that the drag object cannot
    exceed the boundary of its container.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中运行页面时，你会发现拖动对象不能超出其容器的边界。
- en: 'Along with the string `parent` that we used in this example, we could also
    specify a selector, for example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在本示例中使用的字符串 `parent` 外，我们还可以指定一个选择器，例如：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are three additional options related to drag objects within containers
    and these are all related to scrolling. However, you should note that these are
    only applicable when the document is the container.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个与容器内拖动对象相关的额外选项，这些选项都与滚动相关。但是，你应该注意，这些选项仅适用于文档是容器时。
- en: The default value of the `scroll` option is `true`, but when we drag the `<div>`
    element to the edge of the container, it does not scroll. You may have noticed
    in the previous examples, where the drag object was not within a specified container,
    the viewport automatically scrolled. We can fix this by setting the CSS `overflow`
    style to `auto` in a stylesheet if necessary.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`scroll` 选项的默认值是 `true`，但是当我们将 `<div>` 元素拖动到容器的边缘时，它不会滚动。你可能已经注意到在以前的示例中，拖动对象没有在指定的容器内时，视口会自动滚动。如果需要，我们可以通过在样式表中设置
    CSS `overflow` 样式为 `auto` 来解决这个问题。'
- en: Snapping
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 吸附
- en: Drag elements can be given an almost magnetic quality by configuring snapping.
    This feature causes dragged elements to align themselves to specified elements,
    while they are being dragged.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置吸附，可以赋予拖动元素几乎磁性的特性。此功能会导致拖动的元素在拖动过程中与指定的元素对齐。
- en: 'In the next example, we''ll look at the effects that snapping has on the behavior
    of the drag object. Get rid of the container we added in the previous example,
    and add a new empty `<div>` element directly after the drag element, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将查看吸附对拖动对象行为的影响。删除我们在前一个示例中添加的容器，并直接在拖动元素之后添加一个新的空 `<div>` 元素，如下所示：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, change the configuration object so that it appears as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将配置对象更改为以下内容：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Save this as `draggable11.html`. We also need some additional styles; add the
    following code to the bottom of `draggable.css`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个保存为`draggable11.html`。我们还需要一些额外的样式；在`draggable.css`底部添加以下代码：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Save this file as `draggableSnap.css` in the `css` directory. Don''t forget
    to add a link to the new stylesheet in the `<head>` element of the page:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个文件保存为`draggableSnap.css`，放在`css`目录下。别忘了在页面的`<head>`元素中添加一个指向新样式表的链接：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've supplied the selector `#snapper` as the value of the `snap` option in
    our configuration object, and have added a `<div>` element with a matching `id`
    to the page. Therefore, our drag object will snap to this element on the page,
    while the object is being dragged.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置对象中将`snap`选项的值设为`#snapper`选择器，同时在页面中添加了一个匹配的`<div>`元素和一个相同的`id`。因此，在拖动对象时，我们的拖动对象将会吸附到页面上的这个元素。
- en: We also set the `snapMode` option to `inner` (the other possible values are
    `outer` and `both`) so snapping will occur on the inside edges of our `snapper`
    element. If we drag the element towards the outer edge of the `snapper` element
    and get within the tolerance range, the element will snap to the inner edge.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`snapMode`选项设置为`inner`（其他可能的值为`outer`和`both`），因此吸附将发生在我们的`snapper`元素的内部边缘上。如果我们将元素拖向`snapper`元素的外边缘，并在容差范围内，元素将会吸附到内边缘。
- en: Finally, we've set `snapTolerance` to `50`, which is the maximum distance (in
    pixels) the drag object will need to get to the `snapper` element, before snapping
    occurs. As soon as a drag object is within this range, it will snap to the element.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`snapTolerance`设置为`50`，这是拖动对象在吸附到`snapper`元素之前的最大距离（以像素为单位）。一旦拖动对象位于此范围内，它就会吸附到该元素。
- en: 'When we drag the image within `50` pixels of the edge of the snapper element,
    the drag object will automatically align itself to that edge, as shown in the
    following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将图像拖动到`snapper`元素边缘的`50`像素范围内时，拖动对象会自动对齐到该边缘，如下截图所示：
- en: '![Snapping](img/2209OS_11_05.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![吸附](img/2209OS_11_05.jpg)'
- en: Draggable event callbacks
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可拖动事件回调
- en: In addition to the options that we have already looked at, there are three more
    that can be used as callback functions to execute code after specific custom events
    occur.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经看过的选项外，还有三个可以用作回调函数的选项，以在特定的自定义事件发生后执行代码。
- en: 'These events are listed in the following table:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件列在下表中：
- en: '| Event | Fired when… |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 当…时触发 |'
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `drag` | The mouse is moved while dragging |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `drag` | 拖动时鼠标移动 |'
- en: '| `start` | Dragging starts |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `start` | 拖动开始 |'
- en: '| `stop` | Dragging stops |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `stop` | 拖动停止 |'
- en: 'While defining callback functions to make use of these events, the functions
    will always receive two arguments automatically: the original event object as
    the first argument, and a second object containing the following properties:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义回调函数以利用这些事件时，函数将始终自动接收两个参数：第一个参数是原始事件对象，第二个对象包含以下属性：
- en: '| Property | Usage |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 用途 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `helper` | A jQuery object representing the helper element. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `helper` | 一个代表助手元素的 jQuery 对象。 |'
- en: '| `position` | A nested object with properties: `top` and `left`, which is
    the position of the helper element relative to the original drag element. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 一个包含属性 `top` 和 `left` 的嵌套对象，表示助手元素相对于原始拖动元素的位置。 |'
- en: '| `offset` | A nested object with properties: `top` and `left`, which is the
    position of the helper element relative to the page. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `offset` | 一个包含属性 `top` 和 `left` 的嵌套对象，表示助手元素相对于页面的位置。 |'
- en: 'Using the callbacks and the two objects that are passed as arguments is extremely
    easy. We can look at a brief example to highlight their usage. Remove the snapper
    `<div>` in `draggable11.html`, and change the configuration object as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调函数和传递的两个对象非常容易。我们可以看一个简单的示例来突出它们的用法。在`draggable11.html`中删除吸附器`<div>`，并将配置对象更改如下：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Save this as `draggable12.html`. We also need a new stylesheet for this example;
    add the following code to `draggable.css`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个保存为`draggable12.html`。我们还需要一个新的样式表作为示例；在`draggable.css`中添加以下代码：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Save this version of the stylesheet as `draggableEvents.css` in the `css` directory,
    and don't forget to update the link in the `<head>` element of the page to point
    to the new stylesheet.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个版本的样式表保存为`draggableEvents.css`，放在`css`目录下，并且别忘了更新页面`<head>`元素中的链接指向新样式表。
- en: In this example, our configuration object contains just two options—the `start`
    and `stop` callbacks. We set literal functions as the values of these options.
    What all the functions do in this example is add or remove a class name respectively.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们的配置对象仅包含两个选项——`start` 和 `stop` 回调函数。我们将文字函数作为这些选项的值。在此示例中，所有函数的功能都是分别添加或删除类名。
- en: 'The class name adds a slightly different background image to the draggable
    element, which when applied appears as shown in the following before and during
    screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类名添加了一个稍微不同的背景图片到可拖动元素，当应用时，效果如下所示的前后截图：
- en: '![Draggable event callbacks](img/2209OS_11_06.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![可拖动事件回调](img/2209OS_11_06.jpg)'
- en: 'Let''s move on to a slightly more complex example where we can make use of
    the second object passed to our callbacks. We need a couple of new elements on
    the page; change the `<body>` element of the page so that it contains the following
    elements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行稍微复杂一点的示例，其中我们可以利用传递给我们回调函数的第二个对象。我们需要页面上的一些新元素；更改页面的 `<body>` 元素，以使其包含以下元素：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then change the final `<script>` element, so that it appears as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更改最后的 `<script>` 元素，使其如下所示：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save this as `draggable13.html`. We've defined a callback function as the value
    of the `stop` option, so it will be executed each time a drag interaction stops.
    Our callback function receives the event object (which we don't need but must
    specify in order to access the second object) and a `ui` object containing useful
    information about the draggable helper.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `draggable13.html`。我们已将回调函数定义为 `stop` 选项的值，因此每次拖动交互停止时都会执行它。我们的回调函数接收事件对象（我们不需要，但必须指定以便访问第二个对象）和包含有关可拖动助手的有用信息的
    `ui` 对象。
- en: 'All our function needs to do is create two new `<p>` elements, concatenating
    the values found in the `ui` object: `ui.position.top`, `ui.position.left`, `ui.offset.top`,
    and `ui.offset.left`. It then inserts the new elements into the results `<div>`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数所需做的就是创建两个新的 `<p>` 元素，将 `ui` 对象中找到的值连接起来：`ui.position.top`、`ui.position.left`、`ui.offset.top`
    和 `ui.offset.left`。然后，将新元素插入到结果 `<div>` 中。
- en: 'Here''s how the page should look after the draggable has been dragged:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在可拖动元素被拖动后，页面应该是这样的：
- en: '![Draggable event callbacks](img/2209OS_11_07.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![可拖动事件回调](img/2209OS_11_07.jpg)'
- en: Draggable's methods
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可拖动的方法
- en: The draggable interaction helper does not expose any unique methods of its own,
    only the common API methods, which are `destroy`, `disable`, `enable`, `option`,
    and `widget`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可拖动交互助手本身不公开任何独特的方法，只公开了常用的 API 方法，这些方法是 `destroy`、`disable`、`enable`、`option`
    和 `widget`。
- en: Getting started with the droppable widget
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 droppable 小部件
- en: In a nutshell, the droppables component of jQuery UI gives us a place for the
    drag objects to be dropped. A region of the page is defined as a droppable, and
    when a drag object is dropped onto that region, something else is triggered. You
    can react to drops on a valid target very easily using the extensive event model
    exposed by this component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，jQuery UI 的 droppables 组件给了我们一个放置拖动对象的地方。页面的一个区域被定义为可放置的区域，当一个拖动对象被放置到该区域时，会触发其他事件。您可以通过该组件提供的广泛事件模型非常容易地对有效目标的放置做出反应。
- en: 'Let''s start with the default droppable implementation. In a new file in your
    text editor, add the following page:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从默认的 droppable 实现开始。在文本编辑器中的新文件中，添加以下页面：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Save this as `droppable1.html`. The extremely basic stylesheet that is linked
    to, in this example, is simply an updated version of `draggable.css`, and appears
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `droppable1.html`。在本示例中链接的极其基本的样式表只是 `draggable.css` 的更新版本，如下所示：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Save this as `droppable.css` in the `css` folder. When the page runs in a browser,
    it should look like the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为 `droppable.css` 在 `css` 文件夹中。当页面在浏览器中运行时，它应该看起来像以下的截图：
- en: '![Getting started with the droppable widget](img/2209OS_11_08.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 droppable 小部件](img/2209OS_11_08.jpg)'
- en: In this example, the droppable is created; we can see this with the class name
    `ui-droppable`, which is added to the specified element when the page loads.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，droppable 被创建；我们可以看到这一点，因为在页面加载时将类名 `ui-droppable` 添加到指定的元素中。
- en: Even though we haven't added any additional logic to our script, events are
    firing throughout the interaction on both the drag object and the drop target.
    A little later in the chapter, we'll look at these events in more detail to see
    how we can hook into them, to react to successful drops.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们尚未向脚本添加任何额外的逻辑，但在交互过程中，事件会在拖动对象和放置目标上触发。在本章稍后的部分，我们将更详细地查看这些事件，以了解如何钩入它们，以便对成功的放置做出反应。
- en: 'The files we used for this basic droppable implementation are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于这个基本可放置实现的文件如下：
- en: '`jquery-2.0.3.js`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-2.0.3.js`'
- en: '`jquery.ui.core.js`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.core.js`'
- en: '`jquery.ui.widget.js`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.widget.js`'
- en: '`jquery.ui.mouse.js`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.mouse.js`'
- en: '`jquery.ui.draggable.js`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.draggable.js`'
- en: '`jquery.ui.droppable.js`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.droppable.js`'
- en: As you can see, the droppables component is an extension of draggables, rather
    than a completely independent component. Therefore, it requires the `jquery.ui.draggable.js`
    file in addition to its own source file. The reason our droppable does nothing
    is because we haven't configured it, so let's do that next.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，可放置组件是拖动组件的扩展，而不是完全独立的组件。因此，除了其自身的源文件外，它还需要`jquery.ui.draggable.js`文件。我们的可放置对象无所作为的原因是因为我们尚未配置它，所以让我们接下来做这件事。
- en: Configuring droppables
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置可放置对象
- en: 'The `droppable` class is considerably smaller than the `draggable` class, and
    there are fewer configurable options for us to play with. The following table
    lists those options available to us:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`droppable`类比`draggable`类要小得多，并且我们可以玩耍的可配置选项较少。以下表格列出了我们可以使用的这些选项：'
- en: '| Option | Default | Used to… |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用于… |'
- en: '| --- | --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `accept` | `"*"` | Set the draggable element(s) that the droppable will accept.
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `accept` | `"*"` | 设置可放置对象将接受的可拖动元素。 |'
- en: '| `activeClass` | `false` | Set the class that is applied to the droppable,
    while an accepted drag object is being dragged. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `activeClass` | `false` | 设置应用于可放置对象的类，当接受的拖动对象正在被拖动时。 |'
- en: '| `addClasses` | `true` | Add the `ui-droppable` class to the droppable. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `addClasses` | `true` | 向可放置对象添加`ui-droppable`类。 |'
- en: '| `disabled` | `false` | Disable the droppable. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | `false` | 禁用可放置对象。 |'
- en: '| `greedy` | `false` | Stop drop events from bubbling when a drag object is
    dropped onto nested droppables. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `greedy` | `false` | 当拖动对象被放置在嵌套的可放置对象上时，停止放置事件冒泡。 |'
- en: '| `hoverClass` | `false` | Set the class that is applied to the droppable,
    while an accepted drag object is within the boundary of the droppable. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `hoverClass` | `false` | 设置应用于可放置对象的类，当接受的拖动对象在可放置对象的边界内时。 |'
- en: '| `scope` | `"default"` | Define sets of drag objects and drop targets. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | `"default"` | 定义拖动对象和放置目标的集合。 |'
- en: '| `tolerance` | `"intersect"` | Set the mode that triggers an accepted drag
    object being considered over a droppable. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `tolerance` | `"intersect"` | 设置触发接受拖动对象被认为在可放置对象上的模式。 |'
- en: Configuring accepted draggables
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置已接受的可拖动元素
- en: 'In order to get a visible result from the droppable, we''re going to use a
    couple of the configurable options together in the following example, which will
    highlight the drop target when an accepted drag object is interacted with. Change
    the elements on the page in `droppable1.html` so that they appear as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从可放置对象中获得可见的结果，我们将在以下示例中一起使用一些可配置选项，当与接受的拖动对象交互时，它们将突出显示放置目标。修改页面中的元素`droppable1.html`，使其如下所示：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, change the final `<script>` element to the following one:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将最后的`<script>`元素更改为以下内容：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Save this as `droppable2.html`. The `accept` option takes a selector. In this
    example, we've specified that only the drag object that has `id` of `drag1` should
    be accepted by the droppable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`droppable2.html`。`accept`选项接受选择器。在本例中，我们指定只有具有`id`为`drag1`的拖动对象应被可放置对象接受。
- en: We've also specified the class name activated as the value of the `activeClass`
    option. This class name will be applied to the droppable when the accepted drag
    object starts to be dragged. The `hoverClass` option can be used in exactly the
    same way to add styles, when an accepted drag object is over a droppable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了激活的类名作为`activeClass`选项的值。当接受的拖动对象开始被拖动时，此类名将被应用到可放置对象上。`hoverClass`选项可以以完全相同的方式使用，当接受的拖动对象位于可放置对象上时，添加样式。
- en: 'We need a new stylesheet for this example; modify `droppable.css` so that it
    appears as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要一个新的样式表；修改`droppable.css`使其如下所示：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Save this file as `droppableActive.css` in the `css` folder, and link to it
    in the `<head>` element of the page:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`droppableActive.css`在`css`文件夹中，并在页面的`<head>`元素中链接到它：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we view this page in a browser, we should find that when we move the first
    drag object, which is defined as accepted, the droppable picks up the `activated`
    class and turns red. However, when the second drag object is moved, the drop target
    does not respond. The following screenshot shows how the page should look, while
    the first drag object is being dragged over the square:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中查看此页面时，应该发现当我们移动第一个被定义为接受的拖动对象时，可放置区域会接收到`activated`类并变红。然而，当移动第二个拖动对象时，放置目标不会响应。以下截图显示了页面在第一个拖动对象被拖动到方块上方时的外观：
- en: '![Configuring accepted draggables](img/2209OS_11_09.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![配置接受的可拖动对象](img/2209OS_11_09.jpg)'
- en: In addition to a string value, the `accept` option can also take a function
    as its value. This function will be executed once for every drag object that is
    on the page. The function must return either `true`, to indicate that the drag
    object is accepted, or `false` to indicate that it's not.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串值之外，`accept`选项还可以采用函数作为其值。该函数将针对页面上的每个拖动对象执行一次。函数必须返回`true`，表示接受拖动对象，或返回`false`表示不接受。
- en: 'To see the function value of the `accept` option in action change the final
    `<script>` element in `droppable2.html` to the following one:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`accept`选项的功能值，请将`droppable2.html`中的最终`<script>`元素更改为以下内容：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Save this variation as `droppable3.html`. On the surface, the page works exactly
    the same as it did in the previous example. But this time, acceptability is being
    determined by the JavaScript ternary statement within the `dragEnrol` function,
    instead of a simple selector.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将此变体保存为`droppable3.html`。从表面上看，该页面与上一个示例中的工作方式完全相同。但是这次，可接受性是由`dragEnrol`函数中的JavaScript三元语句确定的，而不是简单的选择器。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the function we use with the `accept` option has automatically passed
    a jQuery object representing the drag object as an argument, so we can call the
    jQuery methods on this object. This makes it easy to obtain information about
    it, such as its `id` as in this example. This callback can be extremely useful
    when advanced filtering beyond a selector is required.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们与`accept`选项一起使用的函数已自动将表示拖动对象的jQuery对象作为参数传递，因此我们可以在此对象上调用jQuery方法。这使得很容易获取有关其的信息，例如其`id`，就像这个示例中一样。当需要超出选择器的高级过滤时，此回调非常有用。
- en: Configuring drop tolerance
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置放置容差
- en: 'Drop tolerance refers to the way a droppable detects whether a drag object
    is over it or not. The default value is `intersect`. The following table lists
    the modes that this option may be configured with:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 放置容差指的是可放置区域检测拖动对象是否位于其上的方式。默认值为`intersect`。以下表格列出了此选项可以配置的模式：
- en: '| Mode | Implementation |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 实现 |'
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fit` | The drag object must be completely within the boundary of the droppable
    for it to be considered over it. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `fit` | 拖动对象必须完全位于可放置区域的边界内才能被视为在其上方。 |'
- en: '| `intersect` | At least 25 percent of the drag object must be within the boundary
    of the droppable before it is considered over it. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `intersect` | 在至少有25%的拖动对象位于可放置区域边界内之前，它被视为在其上方。'
- en: '| `pointer` | The mouse pointer must touch the droppable boundary before the
    drag object is considered over the droppable. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `pointer` | 拖动对象被视为位于可放置区域之上之前，鼠标指针必须触及可放置边界。'
- en: '| `touch` | The drag object is over the droppable as soon as an edge of the
    drag object touches an edge of the droppable. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `touch` | 只要拖动对象的边缘触碰到可放置区域的边缘，拖动对象就位于可放置区域上方。 |'
- en: 'So far, all of our droppable examples have used intersect, which is the default
    value of the `tolerance` option. Let''s see what difference the other values for
    this option make to an implementation of the component. Revert to the `#drag`
    and `#target` IDs from their respective elements in `droppable2.html`, and then
    use the following configuration object:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的可放置示例都使用了intersect，这是`tolerance`选项的默认值。让我们看看该选项的其他值对组件实现的影响。从`droppable2.html`中的相应元素中恢复到`#drag`和`#target`的ID，然后使用以下配置对象：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save this as `droppable4.html`. This time we use the `hoverClass` option to
    specify the class name that is added to the droppable. We then use the `tolerance`
    option to specify which tolerance mode is used.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`droppable4.html`。这次我们使用`hoverClass`选项来指定添加到可放置区域的类名。然后，我们使用`tolerance`选项来指定使用哪种容差模式。
- en: 'The part of the drag object that is over the droppable is irrelevant in this
    example; it is the mouse pointer that must cross the boundary of the droppable
    while a drag is in progress for our `activated` class to be triggered:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，拖动对象的一部分位于可放置对象上是不相关的；在拖动进行时，必须越过可放置对象的边界，才会触发我们的 `activated` 类：
- en: '![Configuring drop tolerance](img/2209OS_11_10.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![配置放置容忍度](img/2209OS_11_10.jpg)'
- en: Understanding the droppable callback options
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解可放置回调选项
- en: 'The options that we''ve looked at so far configure various operational features
    of the droppable. In addition to these, there are almost as many callback options
    so that we can define functions that react to different things occurring to the
    droppable and its accepted drag objects. These options are listed in the following
    table:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了配置可放置对象的各种操作特性的选项。除了这些选项之外，还有几乎同样多的回调选项，这样我们就可以定义对可放置对象及其被接受的拖动对象发生不同事情的反应的函数。这些选项列在以下表中：
- en: '| Callback option | Invoked when… |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 回调选项 | 被调用时… |'
- en: '| --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `activate` | An accepted drag object begins dragging. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `activate` | 一个被接受的拖动对象开始拖动。 |'
- en: '| `deactivate` | An accepted drag object stops being dragged. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `deactivate` | 一个被接受的拖动对象停止被拖动。 |'
- en: '| `drop` | An accepted drag object is dropped onto a droppable. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `drop` | 一个被接受的拖动对象被放置到可放置对象上。 |'
- en: '| `out` | An accepted drag object is moved out of the bounds (including the
    tolerance) of the droppable. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `out` | 一个被接受的拖动对象移出可放置对象的边界（包括容忍度）。 |'
- en: '| `over` | An accepted drag object is moved within the bounds (including the
    tolerance) of the droppable. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `over` | 一个被接受的拖动对象在可放置对象的边界内（包括容忍度）移动。 |'
- en: 'Let''s put together a basic example that makes use of these callback options.
    We''ll add a status bar to our droppable that reports the status of different
    interactions between the drag object and the droppable. In `droppable4.html`,
    add the following new element directly after the `target` element:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们组合一个基本的示例，利用这些回调选项。我们将在我们的可放置对象上添加一个状态栏，报告拖动对象和可放置对象之间不同交互的状态。在 `droppable4.html`
    中，在 `target` 元素之后直接添加以下新元素：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, change the final `<script>` element to this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将最终的 `<script>` 元素更改为以下内容：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Save this file as `droppable5.html`. We also need some new styles for this
    example. Create a new stylesheet in your text editor, and add to it the following
    selectors and rules:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `droppable5.html`。我们还需要一些新的样式来进行这个示例。在文本编辑器中创建一个新的样式表，并添加以下选择器和规则：
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Save this file as `droppableEvents.css` in the `css` directory. Don''t forget
    to update `<link>` in the `<head>` element of the page to point to the new stylesheet:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `droppableEvents.css`，放在 `css` 目录中。不要忘记更新页面 `<head>` 元素中的 `<link>`，指向新的样式表：
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `<body>` element of the page contains, along with the droppable, a new status
    bar, which in this case is a simple `<div>` element. In the script, we define
    our configurable options, specifying that the function `eventCallback` should
    be executed when each of the events are detected.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的 `<body>` 元素包含一个新的状态栏，以及可放置对象，在这种情况下是一个简单的 `<div>` 元素。在脚本中，我们定义了可配置的选项，指定了当检测到每个事件时应执行
    `eventCallback` 函数。
- en: Next, we define an object literal, in which the key for each property is set
    to one of the event types that may be triggered. The value of each property is
    the message that we want to display for any given event.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个对象字面量，在其中，每个属性的键设置为可能触发的事件类型之一。每个属性的值是我们希望为任何给定事件显示的消息。
- en: 'We then define our callback function. Like other components, the callback functions
    used in the droppables component automatically pass two objects: the `event` object
    and an object representing the drag element.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的回调函数。与其他组件一样，用于 droppables 组件的回调函数自动传递两个对象：`event` 对象和表示拖动元素的对象。
- en: We use the `type` property of the `event` object to retrieve the appropriate
    message from the `eventMessages` object. We then use standard jQuery element creation
    and manipulation methods to add the message to the status bar.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `event` 对象的 `type` 属性从 `eventMessages` 对象中检索适当的消息。然后，我们使用标准的 jQuery 元素创建和操作方法将消息添加到状态栏中。
- en: 'Here''s how the status bar will look following an interaction:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是交互后状态栏的外观：
- en: '![Understanding the droppable callback options](img/2209OS_11_12.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![理解可放置回调选项](img/2209OS_11_12.jpg)'
- en: After playing around with the page, it may appear that one of our messages is
    not being displayed. When the drag object is dropped onto the droppable, our drop
    message is not shown.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 玩了一会儿页面后，可能会出现我们的一个消息没有显示的情况。当拖动对象放置在droppable上时，我们的drop消息不显示。
- en: Actually, the message is shown, but because the `deactivate` event is fired
    immediately after the `drop` event; the `drop` message is overwritten right away.
    There are a number of ways we could work around this; the simplest, of course,
    would be not to use the `drop` and `deactivate` options together.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，消息是显示出来的，但因为`drop`事件之后立即触发`deactivate`事件；`drop`消息立即被覆盖。我们可以想到许多解决方法；当然，最简单的方法就是不同时使用`drop`和`deactivate`选项。
- en: Although we only make use of the event object (`e`) in this example, a second
    object is also passed automatically to any callback functions we use with the
    event options.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在此示例中我们仅使用事件对象（`e`），但第二个对象也会自动传递给我们在事件选项中使用的任何回调函数。
- en: 'This object contains information relevant to the droppable such as the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象包含与droppable相关的信息，例如以下内容：
- en: '| Property | Value |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 值 |'
- en: '| --- | --- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ui.draggable` | The current drag object. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `ui.draggable` | 当前拖动对象。 |'
- en: '| `ui.helper` | The current drag helper. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `ui.helper` | 当前拖动助手。 |'
- en: '| `ui.position` | The current relative position of the helper. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `ui.position` | 辅助程序的当前相对位置。 |'
- en: '| `ui.offset` | The current absolute position of the helper. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `ui.offset` | 辅助程序的当前绝对位置。 |'
- en: Setting the scope options for droppable
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置droppable的范围选项
- en: 'Both the draggables and droppables feature the scope configuration option that
    allows us to easily define groups of drag objects and drop targets. In this next
    example, we can look at how these options can be configured and the effect it
    has by configuring them. We''ll link to another new stylesheet in this example
    so in the `<head>` element of `droppable5.html`, change the `<link>` element so
    that it appears as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动对象和droppables都具有`scope`配置选项，允许我们轻松定义拖动对象和放置目标的组。在下一个示例中，我们可以看看如何配置这些选项以及配置它们的影响。在这个示例中，我们将链接到另一个新的样式表，所以在`droppable5.html`的`<head>`元素中，将`<link>`元素更改为以下方式：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We need a number of new elements for this example. Change the `<body>` element
    of the page in `droppable5.html` so that it contains the following elements:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要一些新元素。将`droppable5.html`页面中的`<body>`元素更改为包含以下元素：
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To make these elements behave correctly, change the final `<script>` element
    to the following one:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些元素正确工作，请将最后一个`<script>`元素更改为如下所示：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Save this file as `droppable6.html`. Next, we need to create a new CSS file;
    in a new page in your text editor add the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`droppable6.html`。接下来，我们需要创建一个新的CSS文件；在文本编辑器中的新页面中添加以下代码：
- en: '[PRE43]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save this as `droppableScope.css` in the `css` folder.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`droppableScope.css`在`css`文件夹中。
- en: The page has two drop targets and two groups of three drag objects, all of which
    are labeled to show the group they belong to. In the script, we define two configuration
    objects for the two groups of draggables, and two configuration objects for the
    drop targets. Within each configuration object we set the `scope` option.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 页面有两个放置目标和两组三个拖动对象，它们都带有标签以显示它们所属的组。在脚本中，我们为两组dragable定义了两个配置对象，并为drop目标定义了两个配置对象。在每个配置对象中，我们设置了`scope`选项。
- en: The values we set for the `scope` option of each drop target matches `scope`
    of each drag object. Therefore, if we want to use the `scope` option, it must
    be defined for both the drag object and drop target. If we try to set `scope`
    of a droppable, but don't give at least one drag object to the same `scope`, an
    error is thrown.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个放置目标的`scope`选项设置的值与每个拖动对象的`scope`匹配。因此，如果我们想使用`scope`选项，必须为拖动对象和放置目标都定义它。如果我们尝试设置droppable的`scope`，但没有至少为同一`scope`提供一个拖动对象，就会引发错误。
- en: Setting the `scope` option gives us another technique for defining which drag
    objects are accepted by which drop targets, but it is provided as an alternative
    to the `accept` option; the two options should not be used together.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`scope`选项给了我们另一种定义哪些拖动对象被哪些放置目标接受的技术，但它是作为`accept`选项的一个替代提供的；这两个选项不应该一起使用。
- en: 'The following screenshot shows how the page will appear:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了页面的外观：
- en: '![Setting the scope options for droppable](img/2209OS_11_13.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![设置droppable的范围选项](img/2209OS_11_13.jpg)'
- en: Configuring the greedy option
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置贪婪选项
- en: The final option that we are going to look at in connection with the droppable
    component is the `greedy` option. This option can be useful in situations where
    there is a droppable nested within another droppable. If we don't use this option,
    both droppables will fire events during certain interactions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要与可拖放组件一起查看的最后一个选项是`greedy`选项。此选项在有一个可拖放区域嵌套在另一个可拖放区域中的情况下非常有用。如果我们不使用此选项，某些交互期间两个可拖放区域都会触发事件。
- en: The `greedy` option is an easy way to avoid event-bubbling problems in an efficient
    and cross-browser manner. Let's take a closer look at this option with an example.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`greedy`选项是避免事件冒泡问题的一种简单方法，而且在效率和跨浏览器方面都很有效。让我们通过一个例子来更仔细地研究这个选项。'
- en: 'Change the `<link>` element in `droppable6.html` so that it links to a new
    stylesheet:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`droppable6.html`中的`<link>`元素，使其链接到一个新的样式表：
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then change `<body>` so that it contains the following elements:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`<body>`修改为包含以下元素：
- en: '[PRE45]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, change the last `<script>` element so that it appears as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改最后一个`<script>`元素，使其如下所示：
- en: '[PRE46]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Save this example as `droppable7.html`. The CSS for this example is simple and
    builds on the CSS of previous examples.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例保存为`droppable7.html`。此示例的CSS简单，基于之前示例的CSS构建。
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Save this as `droppableNesting.css` in the `css` folder.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例保存为`droppableNesting.css`在`css`文件夹中。
- en: In this example, we have a smaller droppable nested in the center of a larger
    droppable. Their opacity is set using the standard jQuery library's `css()` method.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个较小的可拖放区域嵌套在一个较大的可拖放区域中。它们的不透明度是使用标准的jQuery库的`css()`方法设置的。
- en: In this example, this is necessary because if we alter the `zIndex` option of
    the elements, so that the drag object appears above the nested droppables, the
    target element is not reported correctly.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这是必要的，因为如果我们修改元素的`zIndex`选项，使得拖动对象出现在嵌套的可拖放区域上方，目标元素不会被正确报告。
- en: In this example, we use the `zIndex` option of the draggables component to show
    the drag object above the droppables, while a drag is in progress. The `dropCallback`
    function is used to add a simple message to the status bar, notifying us which
    droppable was the target of the drop.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了拖动组件的`zIndex`选项来在拖动进行时将拖动对象显示在可拖放区域的上方。`dropCallback`函数用于向状态栏添加一个简单的消息，通知我们拖动对象被放置在哪个可拖放区域上。
- en: Our droppables configuration object uses the `drop` option to wire up our callback
    function. However, the key option is the `greedy` option that makes whichever
    target the draggable is dropped on to stop the event from escaping into other
    targets.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可拖放配置对象使用`drop`选项来连接我们的回调函数。然而，关键选项是`greedy`选项，它使得可拖动对象放置在其上时阻止事件逃逸到其他目标。
- en: 'If you run the page and drop the drag object onto one of the droppables, you
    should see something like what''s shown in the following screenshot:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行页面并将拖动对象放置到可拖放区域之一，你应该会看到类似以下截图所示的情况：
- en: '![Configuring the greedy option](img/2209OS_11_14.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![配置`greedy`选项](img/2209OS_11_14.jpg)'
- en: The net effect of setting the `greedy` option to `true` is that the inner droppable
    prevents the event from propagating into the outer droppable and firing again.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将`greedy`选项设置为`true`的净效果是，内部可拖放区域阻止事件传播到外部可拖放区域并再次触发。
- en: If you comment out the `greedy` option and drop the draggable onto the inner
    droppable, the status message will be inserted twice, once by the inner droppable
    and once by the outer droppable.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注释掉`greedy`选项并将可拖动对象放置在内部可拖放区域上，状态消息将会被插入两次，一次是由内部可拖放区域，另一次是由外部可拖放区域。
- en: Droppable methods
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可拖放方法
- en: Like the draggable component, droppable has only the common API methods shared
    by all the library components. This is another component that is primarily option
    driven. The methods available to us are the same ones exposed by draggable, namely
    the standard methods shared by all the library components, which are `destroy`,
    `disable`, `enable`, `option`, and `widget`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 像可拖动组件一样，可拖放组件只有所有库组件共享的通用API方法。这是另一个主要由选项驱动的组件。可用于我们的方法与可拖动对象公开的方法相同，即所有库组件共享的标准方法，这些方法是`destroy`、`disable`、`enable`、`option`和`widget`。
- en: Creating a maze game using the widgets
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用小部件创建迷宫游戏
- en: We've now reached the point where we can have a little fun by putting what we've
    learned about these two components into a fully working example. In our final
    drag-and-drop example, we're going to combine both of these components to create
    a simple maze game.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经达到了可以通过将我们学到的关于这两个组件的知识放入一个完全工作的示例中来玩耍的地步。在我们最终的拖放示例中，我们将结合这两个组件来创建一个简单的迷宫游戏。
- en: The game will consist of a draggable marker that will need to be navigated through
    a simple maze to a specified droppable at the other end of the maze. We can make
    things a little more challenging so that if any of the maze walls are touched
    by the marker, it will return to the starting position.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将由一个可拖动的标记组成，需要通过一个简单的迷宫导航到迷宫的另一端指定的可拖放位置。我们可以使事情变得更具挑战性，以便如果标记触碰到任何迷宫墙壁，它将返回到起始位置。
- en: 'The following screenshot shows what we''re going to build:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示我们将要构建的内容：
- en: '![Creating a maze game using the widgets](img/2209OS_11_15.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![使用小部件创建迷宫游戏](img/2209OS_11_15.jpg)'
- en: 'Let''s start with the markup. In a new page in your text editor, add the following
    code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从标记开始。在文本编辑器中的新页面中添加以下代码：
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Save this file as `dragMaze.html`. On the page, we have our outer container
    that we've given `id` of maze. We have `<div>` elements for the starting and ending
    positions, as well as for the drag marker. Our map will need walls. Rather than
    hand coding the 46 required walls for the map pattern that we're going to use,
    I thought we could use jQuery to do this for us.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`dragMaze.html`。在页面上，我们有一个外部容器，我们给了一个名为迷宫的`id`。我们有用于起始和结束位置以及用于拖动标记的`<div>`元素。我们的地图将需要墙壁。与手工编写我们将使用的地图模式所需的46个墙壁不同，我想我们可以使用jQuery来为我们完成这项工作。
- en: 'We left an empty `<script>` element at the bottom of our page. Let''s fill
    that up with the following code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在页面底部留下了一个空的`<script>`元素。让我们用以下代码填充它：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also need to style up the walls of the maze, but we can''t use any simple
    JavaScript pattern for this. Unfortunately, we have to hardcode them. In another
    new file in your text editor, add the following selectors and rules:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为迷宫的墙壁进行样式处理，但我们不能使用任何简单的JavaScript模式。不幸的是，我们必须将它们硬编码。在文本编辑器中的另一个新文件中，添加以下选择器和规则：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Save this file as `dragMaze.css` in the `css` folder.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`dragMaze.css`，放在`css`文件夹中。
- en: Let's review what the new code does. First, we define a simple configuration
    object for the drag object. The only option we need to configure is the `containment`
    option that constrains the draggable marker element within the maze.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下新代码的作用。首先，我们为拖动对象定义了一个简单的配置对象。我们唯一需要配置的选项是`containment`选项，它将可拖动的标记元素限制在迷宫内。
- en: Next, we define the configuration object for the walls. Each wall is treated
    as a droppable. We specify `touch` as the value of the `tolerance` option, and
    add a callback function to the `over` option. Therefore, whenever the drag object
    touches a wall, the function will be executed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为墙壁定义配置对象。每堵墙都被视为一个可放置的物品。我们将`tolerance`选项的值指定为`touch`，并将回调函数添加到`over`选项中。因此，每当拖动对象触碰到墙壁时，函数将被执行。
- en: All we do in this function is destroy the current drag object and remove it
    from the page.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们所做的一切就是销毁当前拖动对象并将其从页面中移除。
- en: We then create a new drag object back at the starting position and make it draggable
    once more. There is no `cancelDrag` method that causes the drag object to act
    as if it had been dropped and revert to its starting position, but we can easily
    replicate this behavior ourselves.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在起始位置创建一个新的拖动对象，并再次使其可拖动。没有`cancelDrag`方法会使拖动对象像已被放置并返回到起始位置一样操作，但我们可以很容易地自己复制这种行为。
- en: Now, we add another droppable configuration object that configures the ending
    point of the maze. All we configure for this droppable is a function to execute
    when the draggable is over this droppable. In this function, we remove the drag
    object again and present the user with an alert congratulating them.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加另一个可拖放配置对象，用于配置迷宫的结束点。我们为此可拖放配置的唯一配置是一个函数，当可拖放物品位于此可拖放位置时执行。在这个函数中，我们再次移除拖动对象，并向用户显示一个祝贺的警报。
- en: We then use a simple `for` loop to add the walls to our maze. We use the plain
    vanilla `for` loop in conjunction with jQuery to create 46 `<div>` elements, and
    add `id` and `class` attributes to each one, before appending them to the `maze`
    container. Finally, we make the drag object draggable and the walls and the end
    target droppables.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用简单的`for`循环来将墙壁添加到我们的迷宫中。我们结合jQuery使用普通的`for`循环创建46个`<div>`元素，并在将它们附加到`maze`容器之前为每个元素添加`id`和`class`属性。最后，我们使拖动对象可拖动，而墙壁和结束目标可放置。
- en: We can now attempt to navigate the marker from the starting point to the finish
    by dragging it through the maze. If any wall is touched, the marker will return
    to the starting point. We could make it harder (by adding additional obstacles
    to navigate), but for the purpose of having fun with jQuery UI draggables and
    droppables, our work here is complete.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试通过将标记拖动穿过迷宫来从起点到终点进行导航。如果触碰到任何墙壁，标记将返回到起点。我们可以增加难度（增加额外障碍物来导航），但为了与jQuery
    UI的可拖动和可放置功能一起玩耍，我们在这里的工作已经完成。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at two very useful library components in this chapter—the draggable
    and droppable components. Draggables and droppables, as we saw, are very closely
    related and have been designed to be used with each other, allowing us to create
    advanced and highly interactive interfaces.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了两个非常有用的库组件——可拖动组件和可放置组件。正如我们所见，可拖动和可放置是非常密切相关的，并且它们被设计为相互配合使用，让我们能够创建高级且高度交互的界面。
- en: We've covered a lot of material in this chapter, so let's recap what we have
    learned. We saw that the draggable behavior can be added to any element on the
    page with zero configurations. There may be implementations where this is acceptable,
    but usually we'll want to use one or more of the component's extensive range of
    configurable options.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量材料，让我们回顾一下我们所学到的内容。我们看到可拖动行为可以被添加到页面上的任何元素而不需要任何配置。也许有些实现情况下这是可以接受的，但通常我们会想使用该组件广泛的可配置选项中的一个或多个。
- en: In the second part of this chapter, we saw that the `droppables` class allows
    us to easily define areas on the page that draggables can be dropped onto, and
    can react to things being dropped on them. We can also make use of a smaller range
    of configurable droppable options to implement more advanced droppable behavior.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分中，我们看到`droppables`类使我们能够轻松地在页面上定义可放置可拖动物品的区域，并且可以响应有物品放置在上面的情况。我们还可以利用一系列可配置的`droppable`选项来实现更高级的可放置行为。
- en: Both components feature an effective event model for hooking into the interesting
    moments of any drag-and-drop interaction. Our final example showed how both the
    draggables and droppables components can be used together to create a fun and
    interactive game. Although the game was very basic by modern gaming standards,
    it nevertheless provides a sound base that we can easily build upon to add features.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件都具有一个有效的事件模型，用于钩取任何拖放交互的有趣时刻。我们的最终示例展示了如何将可拖动和可放置组件一起使用以创建一个有趣和交互的游戏。尽管这个游戏在现代游戏标准下非常基本，但它仍然提供了一个坚实的基础，我们可以轻易地构建以添加功能。
- en: In the next chapter, we'll take a look at the resizable component, which allows
    users to resize selected elements using a familiar drag-based interface.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看可调整大小的组件，该组件允许用户使用熟悉的基于拖动的界面来调整所选元素的大小。
