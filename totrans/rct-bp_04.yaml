- en: Chapter 4. Building a Real-Time Search App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Search is an important feature in most apps. Depending on the kind of application
    you're developing, you can get away with setting up a field for looking up simple
    keywords, or you may have to delve into a world of fuzzy algorithms and lookup
    tables. In this chapter, we'll create a real-time search app that mimics a web
    search engine. We'll work on quick searches that appear as you type, displaying
    the search results and providing the endless scrolling feature. We'll also create
    our own search API to handle our requests.
  prefs: []
  type: TYPE_NORMAL
- en: The application of these techniques are only limited by your imagination. On
    that note, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the major topics that we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own search API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting your API to MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up API routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing regex-based searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a ReactJS search app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up react-router to handle non-hashed routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a service layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to your API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endless scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own search API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data fetching is a topic fraught with uncertainty, and there really does not
    exist a recommended way of dealing with it that will make sense to everyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two of the main strategies you can search between are as follows: either query
    a data source directly or query an API. Which one is more extensible and future
    proof? Let''s look at it from the perspective of your search controller. Querying
    the data source directly means setting up connectors and the logic involved inside
    your app. You need to construct a proper search query, and then you usually need
    to parse the results. Your data fetching logic is now strongly tied to the data
    source.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying an API means sending a search query and retrieving a preformatted result.
    Now, your app is only loosely tied to the API, and switching it out is often simply
    a matter of changing the API URL.
  prefs: []
  type: TYPE_NORMAL
- en: It's usually preferable to establish loose ties rather than strong ties, so
    we'll start this chapter by creating a Node.js API before moving on to the ReactJS
    app that will display the search results to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with your API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating an empty project. Create a folder to store your files,
    open a terminal, and change the directory to the folder. Run `npm init`. The installer
    will ask you a number of questions, but the defaults are all fine so go ahead
    and press *Enter* until the command is finished. You will be left with a barebones
    `package.json` file that `npm` will use to store your dependency configuration.
    Next, install `express`, `mongoose`, `cors`, `morgan`, and `body-parser` by executing
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Morgan** is a middleware utility designed for automatic logging of requests
    and responses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mongoose** is a utility for connecting to **MongoDB**, a very simple and
    popular document-oriented non-relational database. It''s a good choice for the
    kind of API we want to create because it excels at query speeds and outputs **JSON**
    data by default.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you continue, make sure you have MongoDB installed on your system. You
    can do this by typing in `mongo` in your terminal. If it''s installed, it will
    display something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If it displays an error or **command not found**, you need to install MongoDB
    before proceeding. There are different ways to accomplish this depending on which
    operating system is installed on your computer. If you're on a Mac, you can install
    MongoDB with *Homebrew* by issuing `brew install mongodb`. If you don't have Homebrew,
    you can go to [http://brew.sh/](http://brew.sh/) for instructions on how to install
    it. Windows users and Mac users who don't want to use Homebrew can install MongoDB
    by downloading an executable from [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file called `server.js` in the `root` folder and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will set up our dependencies and make them ready for use. We're opening
    our app for cross-origin requests with the use of the **cors** library. This is
    necessary when we're not running the API on the same domain and port as the app
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: We'll then create a schema that describes what kind of data we'll be working
    with. A schema in Mongoose maps to a MongoDB collection and defines the shape
    of the documents within that collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this is idiomatic to Mongoose as MongoDB is schema-less by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this schema to `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's a very simple schema and all the attributes share the same
    `SchemaType` object. The permitted types are `String`, `Number`, `Date`, `Buffer`,
    `Boolean`, `Mixed`, `ObjectId`, and `Array`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our schema definition, we need to convert our `siteSchema` object into
    a model we can work with. To do so, we pass it to `mongoose.model(modelName, schema)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define our routes. We''ll start by defining a simple search
    route that takes a title as a query and returns a set of matching results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s finish it up by starting the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we tell `express` to use our defined router and prefix it with `v1`. The
    full path to the API will be `http://localhost:5000/v1/search/title`. You can
    now start the API by executing `node server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: We have added `process.env` to some of the variables. The point of this is to
    make it easy to override the values when we start the app. If we want to start
    the app on port `2999`, we will need to start the app with `PORT=2999 node server.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Importing documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inserting documents into a MongoDB collection isn''t very complicated. You
    log in to MongoDB via the terminal, select the database, and run `db.collection.insert({})`.
    Inserting documents manually looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will of course take a lot of time, and making up a set of titles, links,
    and descriptions is not a particularly fruitful endeavor. It''s fortunate that
    there''s a wide range of free and open sets available for us to use. One such
    database is [dmoz.org](http://dmoz.org), and I''ve taken the liberty of downloading
    a sample selection from the database and making it available at [https://websearchapi.herokuapp.com/v1/sites.json](https://websearchapi.herokuapp.com/v1/sites.json)
    in JSON format. Download this set and import it with the `mongoimport` tool, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When executed, it will place 598 documents in your API database.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `get` query can be executed by your browser. Just type in the address and
    a title from the sample JSON file, for instance, `http://localhost:5000/v1/search/CoreChain`.
  prefs: []
  type: TYPE_NORMAL
- en: You may also use the command line with tools such as **cURL** or **HTTPie**.
    The latter is designed to make command-line interactions with web services more
    human-friendly than the likes of cURL, so it's absolutely worth checking it out,
    and it's the one we'll be using in this chapter to test our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the output from the preceding query with HTTPie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is very nice, but notice that the routing we've created demands an exact
    match for the title. Searching for `corechain` or `Corechain` will not return
    any results. Querying `Cubism.js` will return one result, but *Cubism* will return
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this is not a very query-friendly API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a wildcard search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introducing wildcard searches would make the API more user-friendly, but you
    cannot use traditional SQL-based approaches, such as `LIKE`, since MongoDB doesn't
    support these kinds of operations.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, MongoDB comes with full support for regular expressions,
    so it's entirely possible to construct a query that mimics `LIKE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MongoDB, you can use a regular expression object to create a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a regular expression with any of the following syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `<options>` are available for use with a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i`: This is for case insensitivity to match uppercase and lowercase characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: For patterns that include anchors (that is, `^` for the start and `$`
    for the end), match the anchors at the beginning or end of each line for strings
    with multiline values. Without this option, these anchors will only match at the
    beginning or end of the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: This is the "extended" capability to ignore all whitespace characters
    in the `$regex` pattern unless escaped or included in a `character` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: This allows the dot character (`.`) to match all the characters, including
    newline characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `x` and `s` requires `$regex` with the `$options` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know this, let''s start by creating a wildcard query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to restart your node server instance every time you make changes to
    the query logic. You can do this by breaking the instance using a keyboard shortcut,
    such as *CTRL* + *C* (Mac), and then running `node server.js` again.
  prefs: []
  type: TYPE_NORMAL
- en: This query returns any titles that start with the search word, and it will perform
    a case-insensitive search.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remove the first anchor (`^`), it will match all occurrences of the
    word in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the query that we''ll be using for quick searches. It will return hits
    for *Cubism*, *cubism*, and even *ubi*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will do for the kind of app we're building now. There are many ways to
    construct a regular expression, and you may further refine it according to your
    needs. More advanced matching is possible by implementing *soundex*, *fuzzy matching*,
    or *Levenshtein distance*, although none of these are supported by MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: '**Soundex** is a phonetic algorithm for indexing names by sound as pronounced
    in English. It is appropriate when you want to do name lookups and allow users
    to find correct results despite minor differences in spelling.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fuzzy matching** is the technique of finding strings that match a string,
    approximately, not exactly. The closeness of a match is measured in terms of operations
    necessary to convert the string into an exact match. A well-known and often used
    algorithm is **Levenshtein**. It''s a simple algorithm that provides good results,
    but it''s not supported by MongoDB. Measuring the Levenshtein distance must thus
    be done by fetching the entire result set and then applying the algorithm for
    the search query on all the strings. The speed of the operation grows linearly
    with the number of documents in your database, so unless you have a very small
    document set, this is most likely not worth doing.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want these kinds of features, you need to look somewhere else. **Elasticsearch**
    ([https://www.elastic.co/](https://www.elastic.co/)) is a good alternative that's
    worth looking into. You can easily combine a node API, like the one we just created,
    with an `Elasticsearch` instance in the backend instead of MongoDB, or a combination
    of the two.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, your API is accessible to anyone if you put it online. This is not
    an ideal situation, although you can argue that since you only support `GET` requests,
    it's not much different than putting up a simple website.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that you add `PUT` and `DELETE` at some point. You'd definitely want
    to protect it from anyone having complete access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple way of securing it by adding a bearer token to our
    app. We''ll be using the Node.js authentication module, **Passport**, to protect
    our API. Passport has more than 300 strategies of varying applicability. We''ll
    chose the bearer token strategy, so install the following two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In `index.js`, add the following import statements to the head of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code just below the line with `mongoose.connect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to change the route, so replace the search route with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you restart the app, the request will now require the user to send a bearer
    token with *1234567890* as the content. If the token is correct, the app will
    return `true` and execute the query; if not, it will return a simple message saying
    **Unauthorized**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, bearer tokens provide a very weak security layer. It's still possible
    for a potential hacker to sniff your API request and reuse your tokens, but making
    the tokens short-lived and changing them every now and then can help increase
    the security. To make it really secure, it's often used in combination with user
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your ReactJS search app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start this project by making a copy of the scaffolding from [Chapter 1](ch01.html
    "Chapter 1. Diving Headfirst into ReactJS"), *Diving Headfirst into ReactJS*,
    (you will find the code file for this along with the code bundle for this book
    on the Packt Publishing website), and then add `React-Bootstrap` to your project.
    Open up a terminal, go to the root of your project, and issue an `npm install`
    command for React-Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dependencies` section in `package.json` should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If `package.json` doesn''t look like this, please update it and then run `npm
    install` in a terminal from the root of your project. You also need to add the
    `Bootstrap` CSS files to the `<head>` section of your `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Put the preceding code above the line with `app.css` so that you're able to
    override the styles from Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, create a `components` folder inside your `source` folder, then copy
    the components `fontawesome.jsx` and `picture.jsx` from [Chapter 3](ch03.html
    "Chapter 3. Responsive Web Development with ReactJS"), *Responsive Web Development
    with ReactJS*, into this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with our application root, `source/app.jsx`. Replace the contents
    with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to create these four files in your `components` folder in order for
    the app to compile. We''ll do this shortly. Now, refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code sets up a route with the browser history library. One of
    the primary benefits of this library is that you can avoid hashtags in your URL,
    so the app can reference absolute paths such as `http://localhost:3000/search`
    and `http://localhost:3000/search/term`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's create the skeleton files for `SearchActions`, `Search`, `Results`, and
    the complete `Layout` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `source/actions/search.js` and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This sets up two actions that we'll use in `search.jsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `source/components/search.jsx` and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `source/components/results.jsx` and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `source/components/layout.jsx` and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This code propagates pages from the router hierarchy that we set up in `app.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also create a basic fixed footer for our app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `source/components/footer.jsx` and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The app should now compile and you''ll be greeted with a footer message. We''ll
    need to apply a few styles to fix it to the bottom of the page. Open `public/app.css`
    and replace the contents with this styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the page to 100 percent minimum height and setting the footer to the
    absolute position at the bottom will make sure it stays fixed. Now, have a look
    at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is to avoid an outline border from appearing when you click
    on focused divisions. Next, complete the `public/app.css` with the following styling
    to make the search results stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating a search service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you go ahead and create a view layer for your search, you need a way
    to connect to your API. You could go about creating this in a variety of ways,
    and this is one situation where you won't find an authoritative answer. Some prefer
    to put this in the action layer, others in the store, and some would be perfectly
    happy to add it to the view layer.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to take a cue from the MVC architecture and create a service layer.
    We'll access the service from the `action` file you created earlier. We're going
    to do this for the simple reason that it separates the search into a small and
    easily testable subsection of our code. For simplified development and easy testing,
    you always want to make your components as small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `in service` within your `source` folder and add these
    three files: `index.js`, `request.js`, and `search.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the code for `request.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**SuperAgent** is a light-weight client-side HTTP request library that makes
    working with AJAX a lot less painful than it normally is. It''s also fully compatible
    with **node**, which is a huge benefit when performing server-side rendering.
    We''ll delve into server-side rendering in [Chapter 9](ch09.html "Chapter 9. Creating
    a Shared App"), *Creating a Shared App*. Check out the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We're actually only going to use the `get` function in our app. Other methods
    have been added as examples. You could make additions or deletions here, or even
    merge them into a common function (though that would increase the complexity of
    using the function).
  prefs: []
  type: TYPE_NORMAL
- en: 'All operations are sent to the `httpAgent` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We're adding the bearer token scheme that we developed in our API earlier. If
    you skipped that part, you can remove the preceding two lines, though it doesn't
    matter to the API if it receives a bearer token and has no method to handle it.
    In such cases, it will simply discard the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that hardcoding the token in the service is terribly unsecure.
    To make it more secure, you could, for instance, set up a scheme where you can
    create a new token in the browser''s session storage with regular intervals and
    replace the hardcoded variable with a lookup instead. Let''s take a look at the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After we''re done adding parameters, we need to send the request via the `sendAgent`
    function. This function returns a promise that we can listen to, which will in
    time be either rejected or resolved. A `promise` is a construct used for synchronization.
    It''s a proxy for a result that is initially unknown. When we return a promise
    in our code, we get an object that will eventually contain the data that we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The next file we''ll add code for is `search.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This simply imports and extends the code we created in `request.js`. As we don't
    need to extend or modify any of the request code, we'll simply leave it as it
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final file is `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is where we specify the endpoint from where we connect to our API. The
    preceding setting specifies the API running at localhost. You can substitute this
    with the example interface at [http://websearchapi.herokuapp.com/v1/search/](http://websearchapi.herokuapp.com/v1/search/)
    if you'd like to test your code with an external service.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s usually a good idea to store endpoints and other configuration details
    in a separate `configuration` file. Let''s create a `config.js` file and place
    it in the `source` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the contents of `service/index.js` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that we needed to dereference the config name from `config.js`. This is
    because we exported it as a named export with `exports` rather than `module.exports`.
    If we had declared the variable first and exported it with `module.exports`, we
    wouldn't have had to dereference it.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that `exports` is simply a helper to `module`. In the end,
    the module will use `module.exports`, and `Config` will be available as a named
    property to the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also import it with this command: `const Config = require(''../config.js'')`
    or `import * as Config from ''../config.js''`. Both variants will set up a `Config`
    variable that you can access with `Config.Config`.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve made the service, but does it work? Let''s find out. We''ll use a small
    and very competent test framework called **Tape**. Install this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We add `babel-tape-runner` since we're using ECMAScript 6 throughout our app
    and we'd like to use it in our test scripts as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root of the project, create the `test/service` folders and add a file
    called `search.js` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This test will import the search service and search for a specific title in
    the database. It will return `pass` if an exact match is found. You can run it
    by using a terminal and going to the root folder and executing `./.bin/babel-tape-runner
    test/service/search.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the API server must be up and running before your start the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you install `tape` and `babel-tape-runner` globally with the `-g`
    flag, then you don't need to specify the binary version from `node_modules` and
    simply run the test with `babel-tape-runner test/service/search.js`. To make it
    even easier to run the tests, you can add a script inside the `scripts` section
    of your `package.json` file. If you add the test command to the `tests` script,
    you can execute the test by simply executing `npm test`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The store will be very simple. We're going to be performing the service calls
    in the action, so the store will simply hold the results of the service calls
    and pass them on to the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `source` folder, create a new folder and name it `store`. Then create
    a new file, name it `search.js` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the store state. Setting the variable outside the store definition
    automatically makes this a private variable that is only accessible to the store
    itself, and not to the instances of the store. Refer to the ensuing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The line in `init()` sets up a listener for the `emitSearchData` action. Whenever
    this action is called, the `emitSearchResults` function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: These lines look a bit complicated, so let's examine the logic from the last
    line up. The trigger action emits the results from the `_history` variable under
    the `results.query` key, which is the search term being used. The search term
    is wrapped with `JSON.stringify`, which is a method that converts JSON data into
    a string. This allows us to keep the query with spaces and use it as an object
    key for our `_history` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two lines that precede the trigger checks whether the search term has been
    stored in `_history` and adds it if it hasn''t. We currently don''t have a method
    to deal with the history, but it''s conceivable that the store could be extended
    with such a function later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Creating the search view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're finally ready to start work on the view components. Let's open `search.jsx`
    and flesh it out with some content. We'll add a lot of code, so we'll take it
    step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start out by replacing the contents with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to copy the `FontAwesome` and `Picture` components from [Chapter 3](ch03.html
    "Chapter 3. Responsive Web Development with ReactJS"), *Responsive Web Development
    with ReactJS*, to the `source/components` folder, let''s take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`QuickSearch` will pop up a set of search results as you type. We want to keep
    this hidden initially, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The quick-search currently does nothing, let''s take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Picture` component means we can provide a high-resolution version
    for desktop and tablet users and a smaller version for mobile users. A full description
    of this component can be found in [Chapter 3](ch03.html "Chapter 3. Responsive
    Web Development with ReactJS"), *Responsive Web Development with ReactJS*. Now
    refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This will propagate a children page from the routing setup in `app.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Things are finally happening on screen. If you open your web browser now, you'll
    see a logo on the screen; below it, you'll find a search field with a magnifying
    glass to the left and a **Search** button to the right.
  prefs: []
  type: TYPE_NORMAL
- en: However, nothing happens when you start typing, and no results appear when you
    click on the **Search** button. Clearly, there's more work ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s flesh out the `QuickSearch` method. Replace the empty block with this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'And, replace the initial state block with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `QuickSearch` method now iterates over the results from the state and adds
    a `ListGroupItem` item with an `onClick` handler, a header, a description, and
    a link. We'll add the `results` variable to the initial state to avoid the app
    from stopping because of an undefined `state` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we need to add the `onClick` handler to the code. To do this, add
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This code will force the browser to load the URL contained in the target index,
    which corresponds to `targetIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, typing anything in the input field still doesn't do anything. Let's do
    something about it.
  prefs: []
  type: TYPE_NORMAL
- en: Performing searches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea now is to present a real-time search while the user types in the search
    input. We've already created the setup for this to happen; all we need is to connect
    the act of typing into action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first idea that springs to mind is to add an `onChange` handler to the
    input field itself. This is the easiest way to accomplish the first milestone,
    presenting the search. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you''d add a `performSearch` method to the code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When you start typing now, the console log will immediately start filling up
    with values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing searches](img/B04943_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is quite decent, but for a search page that only consists of a single input
    field and nothing more, it would be nice to not have to manually focus on the
    search field in order to input values.
  prefs: []
  type: TYPE_NORMAL
- en: Let's drop the `onChange` handler and start the search process as soon as the
    user inputs data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following two methods to `search.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This sets up two event listeners when the component mounts. The `keypress` event
    listener takes care of ordinary key events, while the `keydown` event listener
    makes sure we can capture the arrow key input as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `handleKeypress` method is quite complex, so let's add the code and examine
    it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''ve registered these event listeners, you''ll be able to capture every
    key event from the user. If the user hits the key *A*, an object will be sent
    to the `handleKeypress` function with a lot of information about the event. Here''s
    a subsection of the attributes from the event object that is of particular interest
    to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: It tells us it's a `keypress` event (the arrow keys would register as a `keydown`
    event). The `charCode` parameter is `97`, and neither the *Alt* key, the *Meta*
    key, the *Ctrl* key, or the *Shift* key was used in conjunction with the event.
  prefs: []
  type: TYPE_NORMAL
- en: We can decode `charCode` with a native JavaScript function. If you execute `String.fromCharCode(97)`,
    you'll get a string back with a lowercase `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with key events based on knowing the numbers is doable, but it''s better
    to map the numbers to friendlier strings, so we''ll add an object to hold the
    `charCode` parameters for us. Add this to the top of the file, just below the
    imports but above the `createClass` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now we can type `keys.BACKSPACE` and it will send the number `8` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `handleKeypress` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we detect that the user is using either the *Ctrl* or *Meta* key (**CMD**
    on Mac), we terminate the function. This allows the user to use regular OS methods,
    such as copy/paste or *Ctrl* + *A* to select all of the text, let''s take a look
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a variable to hold the input field, so we don''t have to look it
    up more than once. For compatibility reasons, we also make sure we get a valid
    character code by checking whether the character type passed to us is a number.
    Refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a `closeSearchField` function in order to hide the search results even
    if it''s populated. We do this because we don''t want it to remain open when the
    user has cleared out all of the text and is ready to start a new search, let''s
    take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also hide the search results if the user presses the *Esc* key, let''s
    take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'These checks don''t do anything, but they''ll prevent the switch to hit `default`
    and thus trigger a search, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added special handling for the arrow keys. When the user presses the
    up arrow, the `activeIndex` will decrease as long as it''s zero or above. This
    will make sure we''ll never have to deal with an invalid `activeIndex` parameter
    (less than `-1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined that the maximum number of results for the quick search is `5`.
    This snippet will make sure `activeIndex` never goes above `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This switch does one of two things. First, if `activeIndex` is `-1`, it means
    the user has not navigated to any of the quick search results, and we'll simply
    go to the results page for all the matches. The same will happen if `activeIndex`
    is not `-1` but `inputfield` still has focus (`inputField === document.activeElement`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, if `activeIndex` is not `-1`, the user has navigated below the input
    and made a choice. In that case, we''ll send the user to the desired URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if none of the switches are valid, for instance, a regular key has
    been pressed, then we'll perform a search. We'll also hide any potential complete
    results with the `SearchActions.hideResults()` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will not compile until we add `hideResults` to our actions, so open
    `actions/search.js` and add these lines to the actions object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The code will compile and when you start typing in the browser, the input field
    will be focused and will receive input. It''s finally time to hook up our search
    service, and we''ll do that in the `actions` file you just edited. Add these two
    lines at the top of the file, just beneath the first import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We'll create a private `_history` variable to hold our search history. It's
    not strictly necessary, but we'll use it to reduce the number of API calls we're
    going to make.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This code will make sure we call our API whenever `performSearch` is triggered.
    Whenever a result is returned from the search service, we store it in our `_history`
    object, and we'll make sure to check whether there's a result ready for us before
    we send a new query to the search service. This will save us a trip to the API
    and the user will get a faster response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the code that will actually perform the search when we type or hit
    the button. Replace the code inside `performSearch()` with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need to do one more thing before we can see the results in the browser,
    but you can verify that it works by typing in search queries and examining the
    network traffic in the developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing searches](img/B04943_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To show our results in the browser, we'll need to add a listener that can react
    to the changes in the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `components/search.jsx` and add this code just before `getInitialState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: What this code does is tell React to call `getSearchResults` when `SearchStore`
    emits new data. The function it calls stores up to five results in the component
    state. When you type in something now, a list group will pop up beneath the search
    field with the results.
  prefs: []
  type: TYPE_NORMAL
- en: You can use your mouse to hover over any result and click on it to visit the
    link it refers to.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the search results with the arrow keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we've already put in so much work with the keyboard events, it would be
    a shame to not utilize it even more. You're already using your keyboard when you're
    searching, so it seems natural to be able to navigate the search results with
    the arrow keys as well, and then press *Enter* to go to the page you've selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `search.jsx`. In `getInitialState` add this key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `renderQuickSearch` function, add the highlighted line with `className`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now you'll be able to move up and down with the arrow keys and hit *Enter* to
    visit the active link. There's a couple of things about this solution that's a
    little bit annoying though. For one, when you're navigating up and down, the input
    field stays focused. If you enter something else, you'll get a new set of search
    results, but the active index will stay the same as before, possibly being out
    of bounds if the new result returns fewer results than the previous one. Second,
    the up and down action moves the cursor in the input field, and that is quite
    disconcerting.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is quite easy to solve; it's simply a matter of adding `activeIndex:-1`
    to the `getSearchResults` function, but the second problem requires us to resort
    to an old web developer trick. There's simply no way to "unfocus" the input field,
    so instead, we'll create a hidden and invisible input field that we'll send the
    focus to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to just above the input field in the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'And then go to the `switch` method and add the highlighted line to the down
    arrow action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'When the app recompiles, you''ll be able to navigate up and down, and the proper
    input field will only activate when you''ve navigated up to the top. The rest
    of the time the hidden input field will have focus, but as it''s placed outside
    the viewport, no one will see it or be able to use it. Let''s take a look at the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigating the search results with the arrow keys](img/B04943_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debouncing the search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every `keypress` class submits a new search to the API. Even with the history
    variable system we've implemented, that's quite a hammering we're bringing down
    on our API. It's not in the user's best interest either, because it will probably
    lead to a slew of irrelevant hits. Imagine you're interested in searching for
    JavaScript. You're probably not interested in getting results for j, ja, jav,
    Java, javas, javasc, javascr, javascri, and JavaScript, but this is currently
    what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it''s quite easy to improve the user experience by simply delaying
    the search. Go to the `switch` statement and replace the content with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll need the `delay` function as well, so add it to the top of the file,
    just below the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This code will make sure the results are delayed just enough to allow the user
    to type in a query before exiting, but not make it feel sluggish. You should experiment
    with the milliseconds setting to suit your needs best.
  prefs: []
  type: TYPE_NORMAL
- en: Moving beyond the quick search to the results page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re almost done with the component now. The final piece of code we''ll add
    to `search.jsx` is the functionality for handling the search button and preparing
    to move on to the next page. To do this, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This code will close the search field and send us to a new route using `push`
    from react-router.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push` parameter is supported by the 2.0 branch of react-router, so all
    we need to do is add a context type to our component. We can do this by adding
    these lines at the top of the component (just beneath the line with `React.createClass`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the results page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the results page is to show all of the search results. Traditionally,
    you show a list of 10-20 results and the paging functionality, which allows you
    to show more results until you reach the end.
  prefs: []
  type: TYPE_NORMAL
- en: Let's set up the results page and start with a traditional pager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `components/results.jsx` and replace the contents with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the `contextType` object is necessary in order to retrieve the `query`
    parameter from the URL. Now look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define that the results should be visible by default. This is necessary
    for users that go to the search page directly. We also define that we want to
    show 10 results per page, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to kick off the search as soon as possible in order to have something
    to display to the user. If we''re moving on from the front page, the results will
    already be ready in the `_history` variable and will be available before the component
    is mounted. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hideResults` and `showResults` methods are actions that will be used when
    the user starts a new query. Instead of pushing the results down or displaying
    the quick search above the results, we simply hide the existing results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'These `setState` functions react to the preceding actions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'When we retrieve fewer results than `this.state.resultsToShow`, we adjust the
    state variable to the number of results in the set, let''s take a look at the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This renderer is almost identical to the one in `search.jsx`. The main difference
    is that we return a button with a `link` style and that we don''t have an `activeIndex`
    attribute that we check, let''s take a look at the remaining code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Setting up pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by adding an attribute to `getInitialState` and a `resetState`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resetState` function needs to be added to `getSearchResults`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: There's absolutely no problem running two `setStates` objects one after the
    other. They will simply be queued on a first come, first served basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a pager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This pager will automatically populate a number of buttons on the page, in this
    case, 10\. The number of items is determined by the number of results divided
    by the number of items to show on each page. `Math.ceil` rounds up to the nearest
    integer, so if you get 54 results, the number of pages will be rounded up to 6
    from 5.4\. The first five pages will show ten results, and the last page will
    show the remaining four results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the pagination component, we need to add it to the imports
    section, so replace the react-bootstrap import with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the pager, replace the render with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'And, add the `handleSelect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all you need to set up a pager. There''s only one problem. When you
    click on **Next**, you are left at the bottom position, and as a user, that doesn''t
    feel right. Let''s add a nice scroll to it with this dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll add it to the imports section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this to the `handleSelect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'There are lots of scroll variants to choose from. Here are some other settings
    you can try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up pagination](img/B04943_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up endless scroll
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Endless scroll** is a very popular functionality, and it so happens that
    it''s very easy to implement in ReactJS. Let''s go back to the state of the code
    as it was before we added the pager and implement endless scrolling instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Endless scrolling works by simply loading more items as you reach the end of
    the page. There are no pagers involved. You simply scroll, and then you scroll
    some more.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can add this to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a couple of attributes to `getInitialState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The `threshold` variable is given in pixels and will activate when we reach
    60 pixels from the bottom. The `increase` variable is how many more items we'll
    load at a time. It's usually the same as the `resultToShow` variable, but in this
    case, three proved to be very visual.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll then add an event listener to mount (and remove it when we''re done
    with it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: These event listeners will listen to the scroll event. It will also start `scrollListener`
    as soon as the component is mounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add the actual function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'While we still have more results, increase the number of results to show with
    the number in `this.state.increase`, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'When we can increase no more, we set `resultsToShow` to be identical to the
    number of results received, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: This function simply finds the top position of the component within the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: When you scroll down now, the page will load new snippets until it runs out
    of results. It can definitely be argued that this is a simplistic endless scroll
    and it's neither endless nor does it actually load more content.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's easy to modify it in such a way that instead of setting a new
    state immediately, it sends an action call that triggers a service call to load
    more data. In this case, the listener needs to be detached until a new set of
    data arrives, and when it does, reattach the listener and set up a new state like
    we did earlier. If you truly have an endless amount of data to fetch, this method
    will not let you down.
  prefs: []
  type: TYPE_NORMAL
- en: We are getting close to completion. There's only one more thing to add. The
    input field is not populated when you go to the results page directly. It's not
    critically important, but it's a nice feature, so let's add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `componentWillMount` function in `results.jsx`, add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open `search.jsx` again and add this line to the mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, add the function that sets the input text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, in `actions/search.js`, add this to the `actions` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: If you navigate directly to the results page now, for instance, by going locally
    to your test site `http://localhost:3001/search?q=javascript` or remotely to the
    example app [http://websearchapp.herokuapp.com/search?q=javascript](http://websearchapp.herokuapp.com/search?q=javascript),
    you'll find the input field being set with whatever you would add to the `q` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made a working API and hooked it up to a MongoDB instance
    before marching to make a snappy search application that displays results as you
    search in real time. Furthermore, we looked at event listeners for keyboard actions
    as well as scroll actions and put them to work.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! That was a lot of hard work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The finished project can be viewed online at [https://reactjsblueprints-chapter4.herokuapp.com](https://reactjsblueprints-chapter4.herokuapp.com).
  prefs: []
  type: TYPE_NORMAL
- en: You can improve the project in many ways. For instance, the search component
    is quite long and hard to maintain. It's a good idea to split it up into a number
    of smaller components.
  prefs: []
  type: TYPE_NORMAL
- en: You can also implement an `update` method so that every click on a search result
    gets stored in your MongoDB instance. This makes it possible for you to range
    popular hits among your users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll venture outside and look at making a map-based application
    and using the HTML5 Geolocation API.
  prefs: []
  type: TYPE_NORMAL
