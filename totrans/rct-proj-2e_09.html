<html><head></head><body>
		<div id="_idContainer054">
			<h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor109"/>Chapter 9</em>: Building a Full-Stack Social Media Application with React Native and Expo</h1>
			<p>Most of the projects that you've created in this book focused on displaying data and making it possible to navigate between pages. When we created our first mobile application with React Native, animations were one of the focus points, which is a must-have when creating a mobile application. In this chapter, we'll be exploring a big advantage of mobile applications, namely the ability to use the camera (or camera roll) from the phone. </p>
			<p>The application we'll be creating in this chapter will follow the same patterns for data-heavy applications as in previous chapters. React techniques such as Context and Hooks are used to get data from a local API that also supports authentication, while React Navigation is used again to create a more advanced routing setup. Also, Expo is used to post images to a social feed by using the camera of the mobile device the application is running on.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Advanced routing with authentication</li>
				<li>Using the camera with React Native and Expo</li>
				<li>Differences in styling for iOS and Android </li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor110"/>Project overview</h1>
			<p>In this chapter, we will <a id="_idIndexMarker629"/>build a mobile social media application that is using a local API to request and add posts to the social feed, including using the camera on the mobile device. Advanced routing with authentication is added using the local API and React Navigation, while Expo is used for access to the camera (roll). </p>
			<p>The <a id="_idIndexMarker630"/>build time is 2 hours.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This chapter is using React Native version 0.64.3 and Expo SDK version 44. As React Native and Expo are updated frequently, make sure that you're working with these versions to ensure the patterns described in this chapter are behaving as expected.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor111"/>Getting started</h1>
			<p>The <a id="_idIndexMarker631"/>project that we'll create in this chapter builds upon an initial version that you can find on GitHub: <a href="https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09-initial">https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09-initial</a>. The complete source code can also be found on GitHub: <a href="https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09">https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter09</a>.</p>
			<p>You need to have the Expo Go application installed on a mobile iOS or Android device to run the project on a physical device. Once you've downloaded the application, you need to create an Expo account to make the development process smoother. Make sure to store your account details somewhere safe, as you need these later on in this chapter.</p>
			<p>Alternatively, you can install either Xcode or Android Studio on your computer to run the application on a virtual device:</p>
			<ul>
				<li><strong class="bold">For iOS</strong>: Information on how to set up your local machine to run the iOS simulator<a id="_idIndexMarker632"/> can be found here: <a href="https://docs.expo.io/workflow/ios-simulator/">https://docs.expo.io/workflow/ios-simulator/</a>.</li>
				<li><strong class="bold">For Android</strong>: Information<a id="_idIndexMarker633"/> on how to set up your local machine to run the emulator from Android Studio can be found here: <a href="https://docs.expo.io/workflow/android-studio-emulator/">https://docs.expo.io/workflow/android-studio-emulator/</a>. <p class="callout-heading">Note</p><p class="callout">It's <strong class="bold">highly recommended</strong> to use the Expo client application to run the project from this chapter on a physical device. Receiving notifications is currently only supported on physical devices, and running the project on either the iOS simulator or Android Studio emulator will result in error messages.</p></li>
			</ul>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor112"/>Checking out the initial project</h2>
			<p>For this <a id="_idIndexMarker634"/>chapter, an initial application has been created with Expo using their CLI, as you learned in the previous chapter. To get started, you'll need to run the following command in this chapter's directory to install all of the dependencies and start both the server and application:</p>
			<p class="source-code">yarn &amp;&amp; yarn start</p>
			<p>This command will start Expo after installing the dependencies, and it gives you the ability to start your project from either the terminal or your browser. In the terminal, you can now either use the QR code to open the application on your mobile device or open the application in a simulator. In the browser, the Expo DevTools will be opened, which also lets you scan the QR code with your phone using the camera or the Expo Go application.</p>
			<p>The local API from which to get the data for our application was created using JSON Server. We've already used this library before, as we used the <strong class="bold">My JSON Server</strong> endpoint based on the <strong class="source-inline">db.json</strong> file in this repository. For this project, we have a separate <strong class="source-inline">db.json</strong> file in the directory for this chapter, which is loaded by the <strong class="source-inline">server.js</strong> file to create a local API. The local API can be started by running the following command in a separate terminal tab or window:</p>
			<p class="source-code">yarn start-server</p>
			<p>This spins up a server at <strong class="source-inline">http://localhost:3000/api/</strong> with, for example, the <strong class="source-inline">http://localhost:3000/api/posts</strong> endpoint, which returns an array of posts. However, when building mobile applications, you cannot use a <strong class="source-inline">localhost</strong> address (or any other address without HTTPS) for security reasons. To be able to use this endpoint in the React Native application, you need to find the local IP address of your machine.</p>
			<p>To find your local IP address, you'll need to do the following depending on your operating system:</p>
			<ul>
				<li><strong class="bold">For Windows</strong>: Open the terminal (or Command Prompt) and run this command:<p class="source-code"><strong class="bold">Ipconfig</strong></p></li>
			</ul>
			<p>This will<a id="_idIndexMarker635"/> return a list like the one you see in the following screenshot with data from your local machine. In this list, you need to look for the <strong class="bold">IPv4 Address</strong> field:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_9.01_B17390.jpg" alt="Figure 9.1 – Finding a local IP address in Windows&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Finding a local IP address in Windows</p>
			<ul>
				<li><strong class="bold">For macOS</strong>: Open the Terminal and run this command:<p class="source-code"><strong class="bold">ipconfig getifaddr en0</strong></p></li>
			</ul>
			<p>After running this command, the local IPv4 address of your machine gets returned, which looks like this:</p>
			<p class="source-code"><strong class="bold">192.168.1.107</strong></p>
			<p>The local IP address can be used as an alternative for <strong class="source-inline">localhost</strong>, which you can try by visiting the following page: <strong class="source-inline">http://192.168.1.107/api/posts</strong>. Make sure to replace the IP address with your own.</p>
			<p>Our application for this chapter has already been set up and needs to know what URL to use for the local API. Configuration in Expo can be stored in <strong class="source-inline">app.json</strong>, but also in <strong class="source-inline">app.config.js</strong> if you want to store specific configuration environment variables. In this file, you can add the following configuration:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">    extra: {</p>
			<p class="source-code">      apiUrl: 'http://<strong class="bold">LOCAL_IP_ADDRESS</strong>:3000',</p>
			<p class="source-code">    },</p>
			<p class="source-code">  };</p>
			<p>In the <a id="_idIndexMarker636"/>preceding <strong class="source-inline">app.config.js</strong> file, you need to replace <strong class="source-inline">LOCAL_IP_ADDRESS</strong> with your own IP address that you acquired from your machine.</p>
			<p>To use this environment variable in our code, we use the <strong class="source-inline">expo-constants</strong> library. This has already been installed in the initial application for this chapter, and an example of how to get <strong class="source-inline">apiUrl</strong> from <strong class="source-inline">app.config.js</strong> can be seen in the <strong class="source-inline">context/PostsContext.js</strong> file:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import { createContext, useReducer } from 'react';</p>
			<p class="source-code"><strong class="bold">import Constants from 'expo-constants';</strong></p>
			<p class="source-code"><strong class="bold">const { apiUrl } = Constants.manifest.extra;</strong></p>
			<p class="source-code">export const PostsContext = createContext();</p>
			<p class="source-code">  // ...</p>
			<p>The <strong class="source-inline">apiUrl</strong> constant is now used to fetch the following local API. No matter whether you've opened the application from a virtual or physical device, the initial application at this point should look something like this:</p>
			<p class="figure-caption">        </p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_9.02_B17390.jpg" alt="Figure 9.2 – The initial application"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – The initial application</p>
			<p>The <strong class="source-inline">screens</strong> directory <a id="_idIndexMarker637"/>for the initial application consists of five screens, which are <strong class="source-inline">Posts</strong>, <strong class="source-inline">PostDetail</strong>, <strong class="source-inline">PostForm</strong>, <strong class="source-inline">Profile</strong>, and <strong class="source-inline">Login</strong>. The <strong class="source-inline">Posts</strong> screen will be the initial screen that is loaded and shows a list of posts on which you can tap to continue to the <strong class="source-inline">PostDetail</strong> screen. For now, the <strong class="source-inline">PostForm</strong>, <strong class="source-inline">Profile</strong>, and <strong class="source-inline">Login</strong> screens aren't visible yet, as we'll add advanced routing and authentication later on in this chapter.</p>
			<p>The project structure from this React Native app is as follows, where the structure is similar to the projects you've created before in this book:</p>
			<p class="source-code">chapter-9-initial  </p>
			<p class="source-code">  |- /.expo</p>
			<p class="source-code">  |- /.expo-shared   </p>
			<p class="source-code">  |- /node_modules </p>
			<p class="source-code">  |- /assets</p>
			<p class="source-code">  |- /components </p>
			<p class="source-code">     |- Button.js</p>
			<p class="source-code">     |- FormItem.js</p>
			<p class="source-code">     |- PostItem.js </p>
			<p class="source-code">  |- /context </p>
			<p class="source-code">     |- AppContext.js </p>
			<p class="source-code">     |- PostsContext.js </p>
			<p class="source-code">     |- UserContext.js </p>
			<p class="source-code">  |- /screens </p>
			<p class="source-code">     |- Login.js</p>
			<p class="source-code">     |- PostDetail.js </p>
			<p class="source-code">     |- PostForm.js</p>
			<p class="source-code">     |- Posts.js</p>
			<p class="source-code">     |- Profile.js</p>
			<p class="source-code">  app.config.js</p>
			<p class="source-code">  app.json  </p>
			<p class="source-code">  App.js</p>
			<p class="source-code">  babel.config.js</p>
			<p class="source-code">  db.json</p>
			<p class="source-code">  server.js</p>
			<p>In the <strong class="source-inline">assets</strong> directory, you<a id="_idIndexMarker638"/> can find the images that are used as the application icon on the home screen once you've installed this application on your mobile device, and the image that will serve as the splash screen, which is displayed when you start the application. The <strong class="source-inline">App.js</strong> file is the actual entry point of your application and all of the components for this application are located in the <strong class="source-inline">screens</strong> and <strong class="source-inline">components</strong> directories. You can also find a directory called <strong class="source-inline">context</strong>. This directory has all the state management components for this application.</p>
			<p class="callout-heading"><strong class="bold">Note</strong></p>
			<p class="callout">If you get an error when loading the application on your local device or emulator stating <strong class="bold">Network request failed</strong>, make sure that you've added your local IP address in <strong class="source-inline">app.config.js</strong>. Also, the server must be running in a separate terminal tab.</p>
			<p>Configurations<a id="_idIndexMarker639"/> for your application, for example, the App Store, are placed in <strong class="source-inline">app.json</strong>, while <strong class="source-inline">babel.config.js</strong> holds specific Babel configurations. As mentioned earlier, the <strong class="source-inline">app.config.js</strong> file holds the configuration for the URL to the local API. There are also two files that are needed to create the local API. These are <strong class="source-inline">db.json</strong> and <strong class="source-inline">server.js</strong>, as described previously in this s<a id="_idTextAnchor113"/>ection.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor114"/>Building a full-stack social media application with React Native and Expo</h1>
			<p>The<a id="_idIndexMarker640"/> application that<a id="_idIndexMarker641"/> you're going to build in this chapter will use a local API to retrieve and mutate data that is available in the<a id="_idIndexMarker642"/> application. This application will <a id="_idIndexMarker643"/>display data from a social media feed, lets you add new posts containing images, and allows you to respond to these social media posts.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor115"/>Advanced routing with authentication</h2>
			<p>We've already <a id="_idIndexMarker644"/>learned how to add routing to a React Native <a id="_idIndexMarker645"/>application using React Navigation. The routing we added was using a stack navigator, which doesn't have a way to display some sort of menu or navigation bar with all the routes. In this section, we'll be adding a tab navigator using React Navigation to display a tab bar at the bottom of the application. Later on, we'll also be adding an authentication flow.</p>
			<h3>Adding bottom tabs</h3>
			<p>Bottom tabs are <a id="_idIndexMarker646"/>common on applications for iOS, but less popular on Android applications. In the final section of this chapter, we'll learn more about the styling differences between iOS and Android. But first, we'll focus on adding bottom tabs to our application.</p>
			<p>To add a tab navigator, we need to complete the following actions:</p>
			<ol>
				<li>React <a id="_idIndexMarker647"/>Navigation has a separate library to create a tab navigator, which we need to install from npm:<p class="source-code"><strong class="bold">yarn add @react-navigation/bottom-tabs</strong></p></li>
			</ol>
			<p>When the installation of <strong class="source-inline">@react-navigation/bottom-tabs</strong> is complete, make sure to restart Expo using the <strong class="source-inline">npm start</strong> command.</p>
			<ol>
				<li value="2">In<a id="_idIndexMarker648"/> the <strong class="source-inline">App.js</strong> file, all the routes for this application are listed, and we need to import the method to create a tab:<p class="source-code">  import { StatusBar } from 'expo-status-bar';</p><p class="source-code">  import React from 'react';</p><p class="source-code">  import { NavigationContainer } from </p><p class="source-code">    '@react-navigation/native';</p><p class="source-code">  import { createStackNavigator } from </p><p class="source-code">    '@react-navigation/stack';</p><p class="source-code"><strong class="bold">+ import { createBottomTabNavigator } from </strong></p><p class="source-code"><strong class="bold">    '@react-navigation/bottom-tabs';</strong></p><p class="source-code">  // ...</p></li>
				<li>The tab navigator can be created using the <strong class="source-inline">createBottomTabNavigator</strong> method. These screens for the navigator must be created in a separate component inside the <strong class="source-inline">App.js</strong> file, where the <strong class="source-inline">Posts</strong>, <strong class="source-inline">PostForm</strong>, and <strong class="source-inline">Profile</strong> screens will be added to it. These screens will later become available in the bottom tabs. It's important to pass the option to not show the header, as the title of the screen will be rendered by the parent navigator:<p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ const Tab = createBottomTabNavigator();</strong></p><p class="source-code"><strong class="bold">+ function Home() {</strong></p><p class="source-code"><strong class="bold">+   return (</strong></p><p class="source-code"><strong class="bold">+     &lt;Tab.Navigator&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;Stack.Screen </strong></p><p class="source-code"><strong class="bold">+         name='Posts' </strong></p><p class="source-code"><strong class="bold">+         component={Posts} </strong></p><p class="source-code"><strong class="bold">+         options={{ headerShown: false }}</strong></p><p class="source-code"><strong class="bold">+       /&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;Stack.Screen </strong></p><p class="source-code"><strong class="bold">+         name='Profile' </strong></p><p class="source-code"><strong class="bold">+         component={Profile} </strong></p><p class="source-code"><strong class="bold">+         options={{ headerShown: false }}</strong></p><p class="source-code"><strong class="bold">+         /&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;Stack.Screen </strong></p><p class="source-code"><strong class="bold">+         name='PostForm' </strong></p><p class="source-code"><strong class="bold">+         component={PostForm} </strong></p><p class="source-code"><strong class="bold">+         options={{ headerShown: false }}</strong></p><p class="source-code"><strong class="bold">+       /&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;/Tab.Navigator&gt;</strong></p><p class="source-code"><strong class="bold">+   );</strong></p><p class="source-code"><strong class="bold">+ }</strong></p><p class="source-code">  export default function App() {</p><p class="source-code">    // ...</p></li>
				<li>To <a id="_idIndexMarker649"/>render the navigator in the application, we need to add<a id="_idIndexMarker650"/> it to the <strong class="source-inline">return</strong> statement inside the <strong class="source-inline">App</strong> component:<p class="source-code">  export default function App() {</p><p class="source-code">    return (</p><p class="source-code">      &lt;AppContext&gt;</p><p class="source-code">        &lt;NavigationContainer&gt;</p><p class="source-code">          &lt;StatusBar style='auto' /&gt;</p><p class="source-code"><strong class="bold">-         &lt;Stack.Navigator initialRouteName='Posts'&gt;</strong></p><p class="source-code"><strong class="bold">-           &lt;Stack.Screen name='Posts' </strong></p><p class="source-code"><strong class="bold">              component={Posts} /&gt;</strong></p><p class="source-code"><strong class="bold">-           &lt;Stack.Screen name='Profile'</strong></p><p class="source-code"><strong class="bold">              component={Profile} /&gt;</strong></p><p class="source-code"><strong class="bold">-           &lt;Stack.Screen name='PostForm' </strong></p><p class="source-code"><strong class="bold">              component={PostForm} /&gt;</strong></p><p class="source-code"><strong class="bold">+         &lt;Stack.Navigator initialRouteName='Home'&gt;</strong></p><p class="source-code"><strong class="bold">+           &lt;Stack.Screen name='Home' component={Home} /&gt;</strong></p><p class="source-code">            &lt;Stack.Screen name='PostDetail'</p><p class="source-code">              component={PostDetail} /&gt;</p><p class="source-code">            &lt;Stack.Screen name='Login' </p><p class="source-code">              component={Login} /&gt;</p><p class="source-code">          &lt;/Stack.Navigator&gt;</p><p class="source-code">        &lt;/NavigationContainer&gt;</p><p class="source-code">      &lt;/AppContext&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p></li>
				<li>When <a id="_idIndexMarker651"/>you now navigate to any of the screens using the tab <a id="_idIndexMarker652"/>navigator, you see that the title in the header is always <strong class="bold">Home</strong>. Because the nested <strong class="source-inline">Home </strong>component is rendered, that on its own end renders the different screens. We can force the header title to be that of the tab that is active by using <strong class="source-inline">getFocusedRouteNameFromRoute</strong> from React Navigation in the <strong class="source-inline">options</strong> prop for the home screen:<p class="source-code">  import { StatusBar } from 'expo-status-bar';</p><p class="source-code">  import React from 'react';</p><p class="source-code"><strong class="bold">- import { NavigationContainer } from </strong></p><p class="source-code"><strong class="bold">   '@react-navigation/native';</strong></p><p class="source-code"><strong class="bold">+ import { NavigationContainer,</strong></p><p class="source-code"><strong class="bold">    getFocusedRouteNameFromRoute }</strong></p><p class="source-code"><strong class="bold">      from '@react-navigation/native';</strong></p><p class="source-code">  </p><p class="source-code">  // ...</p><p class="source-code">  </p><p class="source-code">  export default function App() {</p><p class="source-code">    return (</p><p class="source-code">      &lt;AppContext&gt;</p><p class="source-code">        &lt;NavigationContainer&gt;</p><p class="source-code">          &lt;StatusBar style='auto' /&gt;</p><p class="source-code">          &lt;Stack.Navigator&gt;</p><p class="source-code">            &lt;Stack.Screen</p><p class="source-code">              name='Home'</p><p class="source-code">              component={Home}</p><p class="source-code"><strong class="bold">+             options={({ route }) =&gt; ({</strong></p><p class="source-code"><strong class="bold">+               headerTitle:</strong></p><p class="source-code"><strong class="bold">                  getFocusedRouteNameFromRoute(route),</strong></p><p class="source-code"><strong class="bold">+             })}</strong></p><p class="source-code">            /&gt;</p><p class="source-code">            &lt;Stack.Screen name='PostDetail'</p><p class="source-code">             component={PostDetail} /&gt;</p><p class="source-code">            &lt;Stack.Screen name='Login'</p><p class="source-code">             component={Login} /&gt;</p><p class="source-code">          &lt;/Stack.Navigator&gt;</p><p class="source-code">        &lt;/NavigationContainer&gt;</p><p class="source-code">      &lt;/AppContext&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p></li>
				<li>The bottom <a id="_idIndexMarker653"/>tabs can also have an icon and a custom color when<a id="_idIndexMarker654"/> active. For this, we can alter the <strong class="source-inline">screenOptions</strong> and of the tab navigator. The icons for the tab can be imported from <strong class="source-inline">@expo/vector-icons</strong>, which is already included in Expo:<p class="source-code">  import { StatusBar } from 'expo-status-bar';</p><p class="source-code">  + import { FontAwesome } from '@expo/vector-icons';</p><p class="source-code">  import React from 'react';</p><p class="source-code">  </p><p class="source-code">  // ...</p><p class="source-code"> </p><p class="source-code">  function Home() {</p><p class="source-code">    return (</p><p class="source-code">      &lt;Tab.Navigator</p><p class="source-code"><strong class="bold">+       screenOptions={({ route }) =&gt; ({</strong></p><p class="source-code"><strong class="bold">+         tabBarActiveTintColor: 'blue',</strong></p><p class="source-code"><strong class="bold">+         tabBarInactiveTintColor: 'gray',</strong></p><p class="source-code"><strong class="bold">+         tabBarIcon: ({ color, size }) =&gt; {</strong></p><p class="source-code"><strong class="bold">+           const iconName =</strong></p><p class="source-code"><strong class="bold">+             (route.name === 'Posts' &amp;&amp; 'feed') ||</strong></p><p class="source-code"><strong class="bold">+             (route.name === 'PostForm' &amp;&amp; </strong></p><p class="source-code"><strong class="bold">                'plus-square') ||</strong></p><p class="source-code"><strong class="bold">+             (route.name === 'Profile' &amp;&amp; 'user');</strong></p><p class="source-code"><strong class="bold">+            return &lt;FontAwesome name={iconName} </strong></p><p class="source-code"><strong class="bold">               size={size} color={color} /&gt;;</strong></p><p class="source-code"><strong class="bold">          },</strong></p><p class="source-code"><strong class="bold">+       })}</strong></p><p class="source-code"><strong class="bold">      &gt;</strong></p><p class="source-code">        // ...</p><p class="source-code">      &lt;/Tab.Navigator&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  // ...</p></li>
				<li>Finally, we can also<a id="_idIndexMarker655"/> change the labels of the tabs, for example, for <a id="_idIndexMarker656"/>the <strong class="source-inline">PostForm</strong> screen that displays the form to add a new post:<p class="source-code">  // ...</p><p class="source-code">  function Home() {</p><p class="source-code">    return (</p><p class="source-code">      &lt;Tab.Navigator</p><p class="source-code">        // ...</p><p class="source-code">      &gt;</p><p class="source-code">          &lt;Stack.Screen</p><p class="source-code">          name='PostForm'</p><p class="source-code">          component={PostForm}</p><p class="source-code">          options={{</p><p class="source-code">            headerShown: false,</p><p class="source-code"><strong class="bold">+           tabBarLabel: 'Add post',</strong></p><p class="source-code">          }}</p><p class="source-code">        /&gt;</p><p class="source-code">        &lt;Stack.Screen name='Profile' component={Profile} </p><p class="source-code">        /&gt;</p><p class="source-code">      &lt;/Tab.Navigator&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  // ...</p></li>
			</ol>
			<p>With these <a id="_idIndexMarker657"/>changes, the application now has routing with both a<a id="_idIndexMarker658"/> stack navigator and a tab navigator, and should look something like this:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_9.03_B17390.jpg" alt="Figure 9.3 – The application with bottom tabs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – The application with bottom tabs</p>
			<p>We're now able to reach almost all the screens, with only the <strong class="source-inline">Login</strong> screen still hidden. This screen is added to the stack navigator and should be displayed when the user isn't authenticated. In the next part of this section, we'll add the authentication flow to handle this.</p>
			<h3>Authentication flow</h3>
			<p>For<a id="_idIndexMarker659"/> authentication in frontend applications, most of the time, <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) are<a id="_idIndexMarker660"/> used, which are encrypted tokens that can easily be used to share user information with a backend. The JWT will be returned by the backend when the user is successfully authenticated and often, this token will have an expiration date. With every request that the user should be authenticated for, the token should be sent so that the backend server can determine whether the user is authenticated and allowed to take this action. Although JWTs can be used for authentication since they're encrypted, no private information should be added to them since the tokens should only be used to authenticate the user. Private information can only be sent from the server when a document with the correct JWT has been sent.</p>
			<p>The mobile application we're building in this chapter is only using <strong class="source-inline">GET</strong> requests to retrieve posts, but the local API also supports <strong class="source-inline">POST</strong> requests. But to send <strong class="source-inline">POST</strong> requests, we need to be authenticated, meaning we need to retrieve a token that we can send along with our request to the API. For this, we can use the <strong class="source-inline">api/login</strong> endpoint of the API:</p>
			<ol>
				<li value="1">The <strong class="source-inline">Login</strong> component <a id="_idIndexMarker661"/>can be used to log in but isn't displayed at the moment. To display this component, we need to change the logic in the stack navigator in <strong class="source-inline">App.js</strong>. Instead of having the <strong class="source-inline">App</strong> component return the stack navigator, we need to create a new component in this file called <strong class="source-inline">Navigator</strong>:<p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ function Navigator() {</strong></p><p class="source-code"><strong class="bold">+   return (</strong></p><p class="source-code"><strong class="bold">+     &lt;NavigationContainer&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;StatusBar style='auto' /&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;Stack.Navigator&gt;</strong></p><p class="source-code"><strong class="bold">+         &lt;Stack.Screen name='Login' component={Login}</strong></p><p class="source-code"><strong class="bold">          /&gt;</strong></p><p class="source-code"><strong class="bold">+         &lt;Stack.Screen</strong></p><p class="source-code"><strong class="bold">+           name='Home'</strong></p><p class="source-code"><strong class="bold">+           component={Home}</strong></p><p class="source-code"><strong class="bold">+           options={({ route }) =&gt; ({</strong></p><p class="source-code"><strong class="bold">+             headerTitle:  </strong></p><p class="source-code"><strong class="bold">                getFocusedRouteNameFromRoute(route),</strong></p><p class="source-code"><strong class="bold">+           })}</strong></p><p class="source-code"><strong class="bold">+         /&gt;</strong></p><p class="source-code"><strong class="bold">+         &lt;Stack.Screen name='PostDetail'</strong></p><p class="source-code"><strong class="bold">            component={PostDetail} /&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;/Stack.Navigator&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;/NavigationContainer&gt;</strong></p><p class="source-code"><strong class="bold">+   );</strong></p><p class="source-code"><strong class="bold">+ }</strong></p><p class="source-code">  export default function App() {</p><p class="source-code">    // ...</p></li>
				<li>The <a id="_idIndexMarker662"/>preceding code block can be deleted from <strong class="source-inline">App</strong> and replaced by this new <strong class="source-inline">Navigator</strong> component:<p class="source-code">  // ...</p><p class="source-code">  export default function App() {</p><p class="source-code">    return (</p><p class="source-code">      &lt;AppContext&gt;</p><p class="source-code"><strong class="bold">-       // ...</strong></p><p class="source-code"><strong class="bold">+       &lt;Navigator /&gt;</strong></p><p class="source-code">      &lt;/AppContext&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p></li>
				<li>We <a id="_idIndexMarker663"/>also need to check the value for the token in the <strong class="source-inline">Navigator</strong> component, as we don't want to include the home screen when there is no token provided. The logic to log in is already present in the <strong class="source-inline">UserContext</strong> in the <strong class="source-inline">context/UserContext.js</strong> file and from the <strong class="source-inline">Navigator</strong> component, you can get the <strong class="source-inline">user</strong> object from this context:<p class="source-code">  import { StatusBar } from 'expo-status-bar';</p><p class="source-code">  import { FontAwesome } from '@expo/vector-icons';</p><p class="source-code"><strong class="bold">- import React from 'react';</strong></p><p class="source-code"><strong class="bold">+ import React, { useContext } from 'react';</strong></p><p class="source-code">  // ...</p><p class="source-code">  import AppContext from './context/AppContext';</p><p class="source-code"><strong class="bold">+ import UserContext from './context/UserContext';</strong></p><p class="source-code">  const Stack = createStackNavigator();</p><p class="source-code">  const Tab = createBottomTabNavigator();</p><p class="source-code">  function Home() {</p><p class="source-code">    // ...</p></li>
				<li>Now, we can get the <strong class="source-inline">user</strong> object from the context and add the logic to return the <strong class="source-inline">Login</strong> screen only when no token is present:<p class="source-code">  // ...</p><p class="source-code">  function Navigator() {</p><p class="source-code"><strong class="bold">+   const { user } = useContext(UserContext);</strong></p><p class="source-code">    return (</p><p class="source-code">      &lt;NavigationContainer&gt;</p><p class="source-code">        &lt;StatusBar style='auto' /&gt;</p><p class="source-code"><strong class="bold">-       &lt;Stack.Navigator&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;Stack.Navigator initialRouteName=</strong></p><p class="source-code"><strong class="bold">          {user.token.length ? 'Home' : 'Login'}&gt;</strong></p><p class="source-code">          &lt;Stack.Screen</p><p class="source-code">               name='Home'</p><p class="source-code">               // ...</p><p class="source-code">              /&gt;</p><p class="source-code">              &lt;Stack.Screen name='PostDetail'</p><p class="source-code">               component={PostDetail} /&gt;</p><p class="source-code"><strong class="bold">              &lt;Stack.Screen name='Login' </strong></p><p class="source-code"><strong class="bold">               component={Login} /&gt;</strong></p><p class="source-code"><strong class="bold">            )}</strong></p><p class="source-code">          &lt;/Stack.Navigator&gt;</p><p class="source-code">        &lt;/NavigationContainer&gt;</p><p class="source-code">      );</p><p class="source-code">    }</p><p class="source-code">    export default function App() {</p><p class="source-code">    // ...</p></li>
				<li>If you <a id="_idIndexMarker664"/>now refresh the application, you can see the <strong class="source-inline">Login</strong> component being displayed. You can log in with a username and password combination, which is <strong class="source-inline">test</strong> for both values. After logging in, we want to navigate to the home screen, for which we need to make a change in <strong class="source-inline">screens/Login.js</strong>:<p class="source-code"><strong class="bold">+ import { useNavigation } from </strong></p><p class="source-code"><strong class="bold">   '@react-navigation/core';</strong></p><p class="source-code"><strong class="bold">+ import React, { useContext, useState } from 'react';</strong></p><p class="source-code"><strong class="bold">- import React, { useContext, useEffect, useState } </strong></p><p class="source-code"><strong class="bold">    from 'react';</strong></p><p class="source-code">  // ...</p><p class="source-code">  export default function Login() {</p><p class="source-code">    const [username, setUsername] = useState('');</p><p class="source-code">    const [password, setPassword] = useState('');</p><p class="source-code"><strong class="bold">-    const { error, loginUser } = </strong></p><p class="source-code"><strong class="bold">       useContext(UserContext);</strong></p><p class="source-code"><strong class="bold">+    const { user, error, loginUser } = </strong></p><p class="source-code"><strong class="bold">       useContext(UserContext);</strong></p><p class="source-code"><strong class="bold">+   const navigation = useNavigation();</strong></p><p class="source-code"><strong class="bold">+   useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">+     if (user.token) {</strong></p><p class="source-code"><strong class="bold">+       navigation.navigate('Home');</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }, [user.token]);</strong></p><p class="source-code">    return (</p><p class="source-code">     // ...</p></li>
			</ol>
			<p>When the <a id="_idIndexMarker665"/>value for <strong class="source-inline">token</strong> in the <strong class="source-inline">user</strong> object in the context changes, the user will now be navigated to the home screen. This can be shown by logging in with a username and password combination, which is <strong class="source-inline">test</strong> for both values. If you put in an incorrect value, you'll see an error message, as visible here:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_9.04_B17390.jpg" alt="Figure 9.4 – Handling authentication"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Handling authentication</p>
			<p>The token, however, isn't persisted as the context gets restored when you reload the application. For web applications, we could have used <strong class="source-inline">localStorage</strong> or <strong class="source-inline">sessionStorage</strong>. But for mobile applications, you'd need to use the <strong class="source-inline">AsyncStorage</strong> library from React Native to have persistent storage on both iOS and Android. On iOS, it will use native code blocks to give you the global persistent storage that <strong class="source-inline">AsyncStorage</strong> offers, while on devices running Android, either RocksDB- or SQLite-based storage will be used.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more complex usages, it's recommended to use an abstraction layer on top of <strong class="source-inline">AsyncStorage</strong> as encryption isn't supported out of the box. Also, the use of a key-value system can give you performance issues if you want to store a lot of information for your application using <strong class="source-inline">AsyncStorage</strong>. Both iOS and Android will have set limitations on the amount of storage each application can use. </p>
			<p>To add the<a id="_idIndexMarker666"/> persistence of the user token, we need to install the correct library from Expo and make changes to the context:</p>
			<ol>
				<li value="1">We can install <strong class="source-inline">AsyncStorage</strong> from Expo by running the following command:<p class="source-code"><strong class="bold">expo install @react-native-async-storage/async-storage</strong></p></li>
				<li>To persist, the <strong class="source-inline">AsyncStorage</strong> token can be imported in the <strong class="source-inline">UserContext</strong> in the <strong class="source-inline">context/UserContext.js</strong> file:<p class="source-code">  import React, { createContext, useReducer } </p><p class="source-code">    from 'react';</p><p class="source-code"><strong class="bold">+ import AsyncStorage from </strong></p><p class="source-code"><strong class="bold">   '@react-native-community/async-storage';</strong></p><p class="source-code">  import Constants from 'expo-constants';</p><p class="source-code">  // ...</p></li>
				<li>In the same file, it can be used to store the token in <strong class="source-inline">AsyncStorage</strong> after adding it to the context:<p class="source-code">  // ...</p><p class="source-code">  export const UserContextProvider = ({ children }) =&gt; {</p><p class="source-code">    const [state, dispatch] = useReducer(reducer,</p><p class="source-code">      initialState);</p><p class="source-code">    async function loginUser(username, password) {</p><p class="source-code">      try {</p><p class="source-code">        // ...</p><p class="source-code">        if (result) {</p><p class="source-code">          dispatch({ type: 'SET_USER_TOKEN',</p><p class="source-code">                     payload: result.token });</p><p class="source-code"><strong class="bold">+         AsyncStorage.setItem('token', result.token);</strong></p><p class="source-code">        }</p><p class="source-code">      } catch (e) {</p><p class="source-code">        dispatch({ type: 'SET_USER_ERROR',</p><p class="source-code">                   payload: e.message });</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">    // ...</p></li>
				<li>Now <a id="_idIndexMarker667"/>that the token is persisted after it's retrieved from the local API, it can also be retrieved from <strong class="source-inline">AsyncStorage</strong>. Therefore, we need to create a new function that retrieves the token and adds it to the context:<p class="source-code">    // ...  </p><p class="source-code"><strong class="bold">+   async function getToken() {</strong></p><p class="source-code"><strong class="bold">+     try {</strong></p><p class="source-code"><strong class="bold">+       const token = </strong></p><p class="source-code"><strong class="bold">          await AsyncStorage.getItem('token');</strong></p><p class="source-code"><strong class="bold">+       if (token !== null) {</strong></p><p class="source-code"><strong class="bold">+         dispatch({ type: 'SET_USER_TOKEN', </strong></p><p class="source-code"><strong class="bold">                    payload: token });</strong></p><p class="source-code"><strong class="bold">+       }</strong></p><p class="source-code"><strong class="bold">+     } catch (e) {}</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code">    return (</p><p class="source-code"><strong class="bold">-     &lt;UserContext.Provider value={{ ...state, </strong></p><p class="source-code"><strong class="bold">        loginUser, logoutUser }}&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;UserContext.Provider value={{ ...state, </strong></p><p class="source-code"><strong class="bold">        loginUser, logoutUser, getToken }}&gt;</strong></p><p class="source-code">        {children}</p><p class="source-code">      &lt;/UserContext.Provider&gt;</p><p class="source-code">    );</p><p class="source-code">  };</p><p class="source-code">  export default UserContext;</p></li>
				<li>Finally, this <a id="_idIndexMarker668"/>function needs to be called from <strong class="source-inline">App.js</strong> when the application first renders. That way, you'll get the token once the application starts or is refreshed and the authentication is persisted:<p class="source-code">  import { StatusBar } from 'expo-status-bar';</p><p class="source-code">  import { FontAwesome } from '@expo/vector-icons';</p><p class="source-code">- import React, { useContext } from 'react';</p><p class="source-code">+ import React, { useContext, useEffect } from 'react';</p><p class="source-code">  // ...</p><p class="source-code">  function Navigator() {</p><p class="source-code"><strong class="bold">-   const { user } = useContext(UserContext);</strong></p><p class="source-code"><strong class="bold">+   const { user, getToken } =</strong></p><p class="source-code"><strong class="bold">      useContext(UserContext);</strong></p><p class="source-code"><strong class="bold">+   useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">+     getToken();</strong></p><p class="source-code"><strong class="bold">+   }, []);</strong></p><p class="source-code">    return (</p><p class="source-code">      // ...</p></li>
				<li>The<a id="_idIndexMarker669"/> token is now persisted after logging in once, the application will skip the <strong class="source-inline">Login</strong> screen when it's loaded, and there is a token present in <strong class="source-inline">AsyncStorage</strong>. However, as the token is persisted, we also need a way to log out and remove the token. In the <strong class="source-inline">context/UserContext.js</strong> file, the <strong class="source-inline">logoutUser</strong> function must be altered:<p class="source-code">  // ...</p><p class="source-code">  async function logoutUser() {</p><p class="source-code"><strong class="bold">+   try {</strong></p><p class="source-code"><strong class="bold">+     await AsyncStorage.removeItem('token');</strong></p><p class="source-code">      dispatch({ type: 'REMOVE_USER_TOKEN' });</p><p class="source-code"><strong class="bold">+   } catch (e) { }</strong></p><p class="source-code">  }</p><p class="source-code">  async function getToken() {</p><p class="source-code">    // ...</p></li>
			</ol>
			<p>When <a id="_idIndexMarker670"/>you now go to the <strong class="source-inline">Profile</strong> screen and click the <strong class="bold">Logout</strong> button, nothing happens. Unless you reload the application, you can still visit all the different screens. As the token is already removed from <strong class="source-inline">AsyncStorage</strong> and the application state, we need to navigate the user back to the <strong class="source-inline">Login</strong> screen. Navigating between different nested navigators is demonstrated in the next part of this section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To reload the application in Expo Go, you can shake the device when you're using an iOS or Android phone. By shaking the device, a menu with an option to reload the application will appear. In this menu, you must also select to enable <strong class="bold">Fast refresh</strong> to refresh the application automatically when you make changes to the code.</p>
			<h3>Navigating between nested routes</h3>
			<p>In <a id="_idIndexMarker671"/>React Navigation, we can nest different navigators, such as the stack navigator that renders when the application starts and shows either the <strong class="source-inline">Login</strong> screen or the tab navigator. From a nested navigator, it isn't possible to navigate to the parent navigator directly, as the <strong class="source-inline">navigation</strong> object for parent navigators cannot be accessed. But luckily, we can use a <strong class="source-inline">ref</strong> to create a reference to the "highest" possible navigator. From this reference, we could then access the <strong class="source-inline">navigation</strong> object, which we otherwise would have accessed using the <strong class="source-inline">useNavigation</strong> Hook. To do this for our application, we need to change the following:</p>
			<ol>
				<li value="1">Create a new file called <strong class="source-inline">routing.js</strong> with the following content:<p class="source-code">import React, { createRef } from 'react';</p><p class="source-code">export const navigationRef = createRef(); </p></li>
				<li>This <strong class="source-inline">navigationRef</strong> can be imported in <strong class="source-inline">App.js</strong> and attached to the <strong class="source-inline">NavigationContainer</strong> in the <strong class="source-inline">App</strong> component:<p class="source-code">  // ...</p><p class="source-code">  import AppContext from './context/AppContext';</p><p class="source-code">  import UserContext from './context/UserContext';</p><p class="source-code"><strong class="bold">+ import { navigationRef } from './routing';</strong></p><p class="source-code">  </p><p class="source-code">   // ...</p><p class="source-code">  function Navigator() {</p><p class="source-code">    const { user, getToken } = </p><p class="source-code">      useContext(UserContext);</p><p class="source-code">    // ...</p><p class="source-code">    return (</p><p class="source-code"><strong class="bold">-     &lt;NavigationContainer&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;NavigationContainer ref={navigationRef}&gt;</strong></p><p class="source-code">        // ...</p></li>
				<li>The <strong class="source-inline">navigation</strong> object for the stack navigator that contains the <strong class="source-inline">Login</strong> screen <a id="_idIndexMarker672"/>can now be accessed using this <strong class="source-inline">ref</strong> from the <strong class="source-inline">Profile</strong> screen in <strong class="source-inline">screens/Profile.js</strong>. Using the <strong class="source-inline">reset</strong> method, we can reset the entire <strong class="source-inline">navigation</strong> object and navigate to the <strong class="source-inline">Login</strong> screen:<p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ import { navigationRef } from '../routing';</strong></p><p class="source-code">  export default function Profile() {</p><p class="source-code">    const { logoutUser } = useContext(UserContext);</p><p class="source-code">    return (</p><p class="source-code">      &lt;View style={styles.container}&gt;</p><p class="source-code">        &lt;Button</p><p class="source-code">          onPress={() =&gt; {</p><p class="source-code">            logoutUser();</p><p class="source-code"><strong class="bold">+           navigationRef.current.reset({</strong></p><p class="source-code"><strong class="bold">+             index: 0,</strong></p><p class="source-code"><strong class="bold">+             routes: [{ name: 'Login' }],</strong></p><p class="source-code"><strong class="bold">+           });</strong></p><p class="source-code">          }}</p><p class="source-code">          label='Logout'</p><p class="source-code">        /&gt;</p><p class="source-code">      &lt;/View&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  // ...</p></li>
			</ol>
			<p>With the authentication of the user handled, we can continue to add the functionalities to create a new post with an image in the next section.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor116"/>Using the camera with React Native and Expo</h2>
			<p>Next to<a id="_idIndexMarker673"/> displaying the posts that were already added to the local API, you can also add a post yourself using a <strong class="source-inline">POST</strong> request and send text and an image as variables. Uploading images to your React Native application can be done by either using the camera to take an image or selecting an image from your camera roll. For both use cases, there are APIs available from React Native and Expo, or numerous packages that are installable from npm. For this project, you'll use the <strong class="source-inline">ImagePicker</strong> API from Expo, which combines these functionalities into just one component.</p>
			<p>To add the<a id="_idIndexMarker674"/> feature to create new posts to your social media application, the following changes need to be made to create the new screen to add the post:</p>
			<ol>
				<li value="1">We need to install a library from Expo that allows us to access the camera roll on any device:<p class="source-code"><strong class="bold">expo install expo-image-picker</strong></p></li>
				<li>To use the camera roll, we need to request the <strong class="source-inline">CAMERA_ROLL</strong> permissions from the device, using the <strong class="source-inline">ImagePicker</strong> library we import in the <strong class="source-inline">screens/PostForm.js</strong> file:<p class="source-code">  import React, { useContext, useState } from 'react';</p><p class="source-code">  import { StyleSheet, TouchableOpacity, View, Text,</p><p class="source-code">    KeyboardAvoidingView, Platform, Alert, Image } from </p><p class="source-code">      'react-native';</p><p class="source-code"><strong class="bold">+ import * as ImagePicker from 'expo-image-picker';</strong></p><p class="source-code">  // ...</p><p class="source-code">  export default function PostForm() {</p><p class="source-code">    // ...</p><p class="source-code"><strong class="bold">+   async function uploadImage() {</strong></p><p class="source-code"><strong class="bold">+     const { status } = await ImagePicker</strong></p><p class="source-code"><strong class="bold">        .requestMediaLibraryPermissionsAsync();</strong></p><p class="source-code"><strong class="bold">+     if (status !== 'granted') {</strong></p><p class="source-code"><strong class="bold">+       Alert.alert('Sorry', 'We need camera roll </strong></p><p class="source-code"><strong class="bold">          permissions to make this work!');</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code">    return (</p><p class="source-code">      // ...</p></li>
				<li>This <strong class="source-inline">uploadImage</strong> function must<a id="_idIndexMarker675"/> then be added to the <strong class="source-inline">TouchableOpacity</strong> component in this same file:<p class="source-code">  // ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;KeyboardAvoidingView</p><p class="source-code">      behavior={Platform.OS == 'ios' ? 'padding' :</p><p class="source-code">     'height'}</p><p class="source-code">      style={styles.container}</p><p class="source-code">    &gt;</p><p class="source-code">      &lt;View style={styles.form}&gt;</p><p class="source-code">        &lt;TouchableOpacity</p><p class="source-code"><strong class="bold">+         onPress={() =&gt; uploadImage()}</strong></p><p class="source-code">          style={styles.imageButton}</p><p class="source-code">        &gt;</p><p class="source-code">          &lt;Text style={styles.imageButtonText}&gt;+</p><p class="source-code">          &lt;/Text&gt;</p><p class="source-code">        &lt;/TouchableOpacity&gt;</p><p class="source-code">        // ...</p></li>
				<li>When you now press the button to add the post on this screen, a popup asking to give Expo Go permission to access your camera roll will be displayed. Also, note that on this page, we're not using a <strong class="source-inline">View</strong> component to wrap the screen but a <strong class="source-inline">KeyboardAvoidingView</strong> component. This makes sure that the components on this screen won't be hidden behind the keyboard when you're typing <a id="_idIndexMarker676"/>something.<p class="callout-heading">Note</p><p class="callout">You can't ask the user for permission a second time; instead, you'd need to manually grant the permission to the camera roll. To set this permission again, you should go to the settings screen on iOS and select the Expo application. On the next screen, you're able to add permission to access the camera.</p></li>
				<li>When the user has granted permission to access the camera roll, you can call the <strong class="source-inline">ImagePicker</strong> API from Expo to open the camera roll. This is again an asynchronous function that takes some configuration fields, such as the aspect ratio. If the user has selected an image, the <strong class="source-inline">ImagePicker</strong> API will return an object containing the field URI, which is the URL to the image on the user's device:<p class="source-code">  // ...</p><p class="source-code">  async function uploadImage() {</p><p class="source-code">    const { status } = await ImagePicker</p><p class="source-code">      .requestMediaLibraryPermissionsAsync();</p><p class="source-code">    if (status !== 'granted') {</p><p class="source-code">      Alert.alert(</p><p class="source-code">        'Sorry',</p><p class="source-code">        'We need camera roll permissions to make this </p><p class="source-code">         work!',</p><p class="source-code">      );</p><p class="source-code"><strong class="bold">+   } else {</strong></p><p class="source-code"><strong class="bold">+     const result = </strong></p><p class="source-code"><strong class="bold">        await ImagePicker.launchImageLibraryAsync({</strong></p><p class="source-code"><strong class="bold">+       mediaTypes: ImagePicker.MediaTypeOptions.All,</strong></p><p class="source-code"><strong class="bold">+       allowsEditing: true,</strong></p><p class="source-code"><strong class="bold">+       aspect: [4, 3],</strong></p><p class="source-code"><strong class="bold">+       quality: 1,</strong></p><p class="source-code"><strong class="bold">+     });</strong></p><p class="source-code"><strong class="bold">+     if (!result.cancelled) {</strong></p><p class="source-code"><strong class="bold">+       setImageUrl(result.uri);</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  return (</p><p class="source-code">    // ...</p></li>
				<li>As the URL to the <a id="_idIndexMarker677"/>image is now stored in the local state to the <strong class="source-inline">imageUrl</strong> constant, you can display this URL in an <strong class="source-inline">Image</strong> component. This <strong class="source-inline">Image</strong> component takes <strong class="source-inline">imageUrl</strong> as the value for the source and has been set to use a 100% <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong>:<p class="source-code">  // ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;KeyboardAvoidingView</p><p class="source-code">      behavior={Platform.OS == 'ios' ? 'padding' :</p><p class="source-code">        'height'}</p><p class="source-code">      style={styles.container}</p><p class="source-code">    &gt;</p><p class="source-code">      &lt;View style={styles.form}&gt;</p><p class="source-code">        &lt;TouchableOpacity onPress={() =&gt;</p><p class="source-code">          uploadImage()} style={styles.imageButton}&gt;</p><p class="source-code"><strong class="bold">+         {imageUrl.length ? (</strong></p><p class="source-code"><strong class="bold">+           &lt;Image</strong></p><p class="source-code"><strong class="bold">+             source={{ uri: imageUrl }}</strong></p><p class="source-code"><strong class="bold">+             style={{ width: '100%', height: '100%' </strong></p><p class="source-code"><strong class="bold">                    }}</strong></p><p class="source-code"><strong class="bold">+           /&gt;</strong></p><p class="source-code"><strong class="bold">+         ) : (</strong></p><p class="source-code">            &lt;Text style={styles.imageButtonText}&gt;+&lt;/Text&gt;</p><p class="source-code"><strong class="bold">+         )}</strong></p><p class="source-code">        &lt;/TouchableOpacity&gt;</p><p class="source-code">        // ...</p></li>
			</ol>
			<p>With these changes, the <strong class="source-inline">AddPost</strong> screen should look something like the following screenshots, which were taken from a device running iOS. There might be slight <a id="_idIndexMarker678"/>differences in the appearance of this screen if you're using the Android Studio emulator or a device that runs Android:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_9.05_B17390.jpg" alt="Figure 9.5 – Using the camera roll&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Using the camera roll</p>
			<p>These<a id="_idIndexMarker679"/> changes will make it possible to select a photo from your camera roll, but your users should also be able to upload an entirely new photo by using their camera. With the <strong class="source-inline">ImagePicker</strong> API from Expo, you can handle both scenarios, as this component also has a <strong class="source-inline">launchCameraAsync</strong> method. This asynchronous function will launch the camera and return it the same way as it returns a URL to the image from the camera roll. </p>
			<p>To add the functionality to directly use the camera on the user's device to upload an image, you can make the following changes:</p>
			<ol>
				<li value="1">When the user clicks on the image placeholder, the image roll will be opened by default. But you also want to give the user the option to use their camera. Therefore, a selection must be made between using the camera or the camera roll for uploading the image, which is a perfect use case for implementing an <strong class="source-inline">ActionSheet</strong> component. React Native and Expo both have an <strong class="source-inline">ActionSheet</strong> component; it's advisable to use the one from Expo as it will use the native <strong class="source-inline">UIActionSheet</strong> component on iOS and a JavaScript implementation for Android:<p class="source-code"><strong class="bold">yarn add @expo/react-native-action-sheet</strong></p></li>
				<li>After this, we need to import <strong class="source-inline">ActionSheetProvider</strong> from <strong class="source-inline">@expo/react-native-action-sheet</strong> in our <strong class="source-inline">App.js</strong> file:<p class="source-code">  import { StatusBar } from 'expo-status-bar';</p><p class="source-code">  import { FontAwesome } from '@expo/vector-icons';</p><p class="source-code">  import React, { useContext, useEffect } from 'react';</p><p class="source-code">  import { NavigationContainer, </p><p class="source-code">    getFocusedRouteNameFromRoute } </p><p class="source-code">    from '@react-navigation/native';</p><p class="source-code">  import { createNativeStackNavigator } </p><p class="source-code">    from '@react-navigation/native-stack';</p><p class="source-code">  import { createBottomTabNavigator } </p><p class="source-code">    from '@react-navigation/bottom-tabs';</p><p class="source-code"><strong class="bold">+ import { ActionSheetProvider } </strong></p><p class="source-code"><strong class="bold">    from '@expo/react-native-action-sheet';</strong></p><p class="source-code">  // ...</p></li>
				<li>We <a id="_idIndexMarker680"/>wrap the navigator that contains the <strong class="source-inline">PostForm</strong> screen in this same file so that we can use the Hook to create the action sheet in that screen component:<p class="source-code">  function Home() {</p><p class="source-code">    return (</p><p class="source-code"><strong class="bold">+     &lt;ActionSheetProvider&gt;</strong></p><p class="source-code">        // ...</p><p class="source-code"><strong class="bold">+     &lt;/ActionSheetProvider&gt;</strong></p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  function Navigator() {</p><p class="source-code">    // ...</p></li>
				<li>In the <strong class="source-inline">screens/PostForm.js</strong> file, we can now import the Hook to create the action <a id="_idIndexMarker681"/>sheet from <strong class="source-inline">@expo/react-native-action-sheet</strong>:<p class="source-code">  // ...</p><p class="source-code">  import * as ImagePicker from 'expo-image-picker';</p><p class="source-code"><strong class="bold">+ import { useActionSheet } from </strong></p><p class="source-code"><strong class="bold">   '@expo/react-native-action-sheet';</strong></p><p class="source-code">  import { useNavigation } from '@react-navigation/core';</p><p class="source-code">  import Button from '../components/Button';</p><p class="source-code">  import FormInput from '../components/FormInput';</p><p class="source-code">  import PostsContext from '../context/PostsContext';</p><p class="source-code">  export default function PostForm() {</p><p class="source-code">    // ...</p></li>
				<li>To add the action sheet, a function to open this <strong class="source-inline">ActionSheet</strong> must be added, and by using the <strong class="source-inline">showActionSheetWithOptions</strong> prop and the options, <strong class="source-inline">ActionSheet</strong> should be constructed. The options are <strong class="source-inline">Camera</strong>, <strong class="source-inline">Camera roll</strong>, and <strong class="source-inline">Cancel</strong>, and based on the index of the button that gets pressed, a different function should be called:<p class="source-code">  // ...</p><p class="source-code">  export default function PostForm() {</p><p class="source-code">    // ...</p><p class="source-code">    const { addPost } = useContext(PostsContext);</p><p class="source-code">    const navigation = useNavigation();</p><p class="source-code"><strong class="bold">+   const { showActionSheetWithOptions } = </strong></p><p class="source-code"><strong class="bold">      useActionSheet();</strong></p><p class="source-code">    // ...</p><p class="source-code"><strong class="bold">+   function openActionSheet() {</strong></p><p class="source-code"><strong class="bold">+     const options = ['Camera roll', 'Camera',</strong></p><p class="source-code"><strong class="bold">        'Cancel'];</strong></p><p class="source-code"><strong class="bold">+     const cancelButtonIndex = 2;</strong></p><p class="source-code"><strong class="bold">+     showActionSheetWithOptions(</strong></p><p class="source-code"><strong class="bold">+       { options, cancelButtonIndex },</strong></p><p class="source-code"><strong class="bold">+       (buttonIndex) =&gt; {</strong></p><p class="source-code"><strong class="bold">+         if (buttonIndex === 0) {</strong></p><p class="source-code"><strong class="bold">+           uploadImage()</strong></p><p class="source-code"><strong class="bold">+         }</strong></p><p class="source-code"><strong class="bold">+       },</strong></p><p class="source-code"><strong class="bold">+     );</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code">    return (</p><p class="source-code">      // ...</p></li>
				<li>When the <strong class="source-inline">buttonIndex</strong> is 0, the function to ask for permission to access the camera <a id="_idIndexMarker682"/>roll and select an image from it is called, but we also need a function to ask for camera permission and use the camera:<p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ async function takePicture() {</strong></p><p class="source-code"><strong class="bold">+   const { status } = await </strong></p><p class="source-code"><strong class="bold">      ImagePicker.requestCameraPermissionsAsync();</strong></p><p class="source-code"><strong class="bold">+   if (status !== 'granted') {</strong></p><p class="source-code"><strong class="bold">+     Alert.alert('Sorry', 'We need camera permissions </strong></p><p class="source-code"><strong class="bold">        to make this work!');</strong></p><p class="source-code"><strong class="bold">+   } else {</strong></p><p class="source-code"><strong class="bold">+     const result = </strong></p><p class="source-code"><strong class="bold">        await ImagePicker. launchCameraAsync ({</strong></p><p class="source-code"><strong class="bold">+       mediaTypes: ImagePicker.MediaTypeOptions.All,</strong></p><p class="source-code"><strong class="bold">+       aspect: [4, 3],</strong></p><p class="source-code"><strong class="bold">+       quality: 1,</strong></p><p class="source-code"><strong class="bold">+     });</strong></p><p class="source-code"><strong class="bold">+     if (!result.cancelled) {</strong></p><p class="source-code"><strong class="bold">+       setImageUrl(result.uri);</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code"><strong class="bold">+ }</strong></p><p class="source-code">  function openActionSheet() {</p><p class="source-code">    // ...</p></li>
				<li>Finally, the <strong class="source-inline">openActionSheet</strong> function to open the action sheet must be attached <a id="_idIndexMarker683"/>to the <strong class="source-inline">TouchableOpacity</strong> component:<p class="source-code">  // ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;KeyboardAvoidingView</p><p class="source-code">      behavior={Platform.OS == 'ios' ? 'padding' : </p><p class="source-code">        'height'}</p><p class="source-code">      style={styles.container}</p><p class="source-code">    &gt;</p><p class="source-code">      &lt;View style={styles.form}&gt;</p><p class="source-code">        &lt;TouchableOpacity</p><p class="source-code"><strong class="bold">-         onPress={() =&gt; uploadImage()}</strong></p><p class="source-code"><strong class="bold">+         onPress={() =&gt; openActionSheet()}</strong></p><p class="source-code">          style={styles.imageButton}</p><p class="source-code">        &gt;</p><p class="source-code">        // ...</p></li>
			</ol>
			<p>Pressing the image placeholder will now open up the action sheet to select whether you want to use the camera roll or the camera for the image:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_9.06_B17390.jpg" alt="Figure 9.6 – The action sheet on iOS"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – The action sheet on iOS</p>
			<p>Your post and <a id="_idIndexMarker684"/>image will now be displayed at the top of the <strong class="source-inline">Posts</strong> screen, meaning you've added the post successfully. In the final section of this chapter, we'll be exploring differences in styling between iOS and Android for this application.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor117"/>Differences in styling for iOS and Android </h2>
			<p>When styling your<a id="_idIndexMarker685"/> application, you might want to have different styling rules for iOS and Android, for example, to match the styling of the Android operating system better. There are multiple ways to apply different styling rules to different platforms; one of them is by using the <strong class="source-inline">Platform</strong> module, which can be imported from React Native. </p>
			<p>This module has already been used in parts of this application, but let's have a closer look at its workings by adding different icons to the tabs in the navigator tab depending on the operating system of the device:</p>
			<ol>
				<li value="1">In <strong class="source-inline">App.js</strong>, we've already imported the <strong class="source-inline">FontAwesome</strong> icons from Expo, but for Android, we want to import <strong class="source-inline">MaterialIcons</strong> so they can be displayed instead. Also, we need to import <strong class="source-inline">Platform</strong> from React Native:<p class="source-code">  import { StatusBar } from 'expo-status-bar';</p><p class="source-code">  import { </p><p class="source-code">    FontAwesome,</p><p class="source-code"><strong class="bold">+   MaterialIcons, </strong></p><p class="source-code">  } from '@expo/vector-icons';</p><p class="source-code">  import React, { useContext, useEffect } </p><p class="source-code">    from 'react';</p><p class="source-code"><strong class="bold">+ import { Platform } from 'react-native';</strong></p><p class="source-code">  // ...</p></li>
				<li>With <a id="_idIndexMarker686"/>the <strong class="source-inline">Platform</strong> module, you can check whether your mobile device is running iOS or Android by checking whether the value of <strong class="source-inline">Platform.OS</strong> is <strong class="source-inline">ios</strong> or <strong class="source-inline">android</strong>. The module must be used in the tab navigator, where we can make the distinction between the two platforms:<p class="source-code">  // ...</p><p class="source-code">  function Home() {</p><p class="source-code">    return (</p><p class="source-code">      &lt;ActionSheetProvider&gt;</p><p class="source-code">        &lt;Tab.Navigator</p><p class="source-code">          // ...</p><p class="source-code">          screenOptions={({ route }) =&gt; ({</p><p class="source-code">            tabBarIcon: ({ color, size }) =&gt; {</p><p class="source-code">              // ...</p><p class="source-code"><strong class="bold">-             return &lt;FontAwesome name={iconName} </strong></p><p class="source-code"><strong class="bold">                size={size} color={color} /&gt;;</strong></p><p class="source-code"><strong class="bold">+             return Platform.OS === 'ios' ? (</strong></p><p class="source-code"><strong class="bold">+               &lt;FontAwesome name={iconName} </strong></p><p class="source-code"><strong class="bold">                 size={size} color={color} /&gt;</strong></p><p class="source-code"><strong class="bold">+             ) : (</strong></p><p class="source-code"><strong class="bold">+               &lt;MaterialIcons name={iconName} </strong></p><p class="source-code"><strong class="bold">                  size={size} color={color} /&gt;</strong></p><p class="source-code"><strong class="bold">+           );</strong></p><p class="source-code">          },</p><p class="source-code">        })}</p><p class="source-code">      &gt;</p><p class="source-code">      // ...</p></li>
				<li>This will<a id="_idIndexMarker687"/> replace the <strong class="source-inline">FontAwesome</strong> icons on Android with <strong class="source-inline">MaterialIcons</strong>. This icon library uses different names for the icons, so we also need to make the following change: <p class="source-code">  // ...</p><p class="source-code">  function Home() {</p><p class="source-code">    return (</p><p class="source-code">      &lt;ActionSheetProvider&gt;</p><p class="source-code">        &lt;Tab.Navigator</p><p class="source-code">          // ...</p><p class="source-code">          screenOptions={({ route }) =&gt; ({</p><p class="source-code">            tabBarIcon: ({ color, size }) =&gt; {</p><p class="source-code">              const iconName =</p><p class="source-code"><strong class="bold">-               (route.name === 'Posts' &amp;&amp; 'feed') ||</strong></p><p class="source-code"><strong class="bold">-               (route.name === 'PostForm' &amp;&amp; </strong></p><p class="source-code"><strong class="bold">                 'plus-square') ||</strong></p><p class="source-code"><strong class="bold">-               (route.name === 'Profile' &amp;&amp; 'user');</strong></p><p class="source-code"><strong class="bold">+               (route.name === 'Posts' &amp;&amp;</strong></p><p class="source-code"><strong class="bold">+                 (Platform.OS === 'ios' ? 'feed' :</strong></p><p class="source-code"><strong class="bold">                   'rss-feed')) ||</strong></p><p class="source-code"><strong class="bold">+               (route.name === 'PostForm' &amp;&amp;</strong></p><p class="source-code"><strong class="bold">+                 (Platform.OS === 'ios' ? </strong></p><p class="source-code"><strong class="bold">                   'plus-square' : 'add-box')) ||</strong></p><p class="source-code"><strong class="bold">+               (route.name === 'Profile' &amp;&amp;</strong></p><p class="source-code"><strong class="bold">                  (Platform.OS === 'ios' ? 'user' :</strong></p><p class="source-code"><strong class="bold">                   'person'));</strong></p><p class="source-code">              return Platform.OS === 'ios' ? (</p><p class="source-code">                // ...</p></li>
			</ol>
			<p>When you're running the application on a mobile device with Android, the navigator tab will display the icons based on Material Design. If you're using an Apple device, it will display different icons; you can change the <strong class="source-inline">Platform.OS === 'ios'</strong> condition to <strong class="source-inline">Platform.OS === 'android'</strong> to add the Material Design icons to iOS instead. If you don't see any changes yet, try reloading the application on your device.</p>
			<ol>
				<li value="4">We can <a id="_idIndexMarker688"/>also use the <strong class="source-inline">Platform</strong> module directly inside a <strong class="source-inline">StyleSheet</strong>, for example, to change the color of the <strong class="source-inline">Button</strong> component in our application. By default, our <strong class="source-inline">Button</strong> component has a blue background color, but let's change it to purple on Android. In <strong class="source-inline">components/Button.js</strong>, we need to import the <strong class="source-inline">Platform</strong> module:<p class="source-code">  import React from 'react';</p><p class="source-code">  import {</p><p class="source-code">    StyleSheet,</p><p class="source-code">    TouchableOpacity,</p><p class="source-code">    View,</p><p class="source-code">    Text,</p><p class="source-code"><strong class="bold">+   Platform,</strong></p><p class="source-code">  } from 'react-native';</p><p class="source-code">  export default function Button({ onPress, label }) {</p><p class="source-code">    // ...</p></li>
				<li>We <a id="_idIndexMarker689"/>use the <strong class="source-inline">select</strong> method inside the creation of <strong class="source-inline">StyleSheet</strong>:<p class="source-code">  // ... </p><p class="source-code">  const styles = StyleSheet.create({</p><p class="source-code">    button: {</p><p class="source-code">      width: '100%',</p><p class="source-code">      padding: 20,</p><p class="source-code">      borderRadius: 5,</p><p class="source-code"><strong class="bold">-     backgroundColor: 'blue',</strong></p><p class="source-code"><strong class="bold">+     ...Platform.select({</strong></p><p class="source-code"><strong class="bold">+       ios: {</strong></p><p class="source-code"><strong class="bold">+         backgroundColor: 'blue',</strong></p><p class="source-code"><strong class="bold">+       },</strong></p><p class="source-code"><strong class="bold">+       android: {</strong></p><p class="source-code"><strong class="bold">+         backgroundColor: 'purple',</strong></p><p class="source-code"><strong class="bold">+       },</strong></p><p class="source-code">      }),</p><p class="source-code">    },</p><p class="source-code">    // ...</p></li>
			</ol>
			<p>Another component that can be styled differently between iOS and Android is the <strong class="source-inline">PostItem</strong> component. As mentioned before, there are multiple ways to do this; besides using the <strong class="source-inline">Platform</strong> module, you can also use platform-specific file extensions. Any file that has the <strong class="source-inline">*.ios.js</strong> or <strong class="source-inline">*.android.js</strong> extension will only be rendered on the platform specified in the extension. You can not only apply different styling rules but also have <a id="_idIndexMarker690"/>changes in functionality on different platforms:</p>
			<ol>
				<li value="1">Rename the current <strong class="source-inline">components/PostItem.js</strong> file <strong class="source-inline">components/PostItem.android.js</strong>, and create a new file called <strong class="source-inline">components/PostItem.ios.js</strong> with the following contents:<p class="source-code">import React from 'react';</p><p class="source-code">import { StyleSheet, Text, Dimensions, Image, View }</p><p class="source-code">  from 'react-native';</p><p class="source-code">const PostItem = ({ data }) =&gt; (</p><p class="source-code">  &lt;View style={styles.container}&gt;</p><p class="source-code">    &lt;View style={styles.details}&gt;</p><p class="source-code">      &lt;Text&gt;{data.description}&lt;/Text&gt;</p><p class="source-code">    &lt;/View&gt;</p><p class="source-code">    &lt;Image source={{ uri: data.imageUrl }} </p><p class="source-code">     style={styles.thumbnail} /&gt;</p><p class="source-code">  &lt;/View&gt;</p><p class="source-code">);</p></li>
				<li>This will <a id="_idIndexMarker691"/>change the order of the title and the image of a post on iOS, showing the title above the image. Also, we need to add the following styling to the end of this file:<p class="source-code">// ...</p><p class="source-code">const styles = StyleSheet.create({</p><p class="source-code">  container: {</p><p class="source-code">    display: 'flex',</p><p class="source-code">    alignItems: 'center',</p><p class="source-code">    justifyContent: 'flex-start',</p><p class="source-code">    backgroundColor: 'white',</p><p class="source-code">    borderWidth: 1,</p><p class="source-code">    borderColor: '#ccc',</p><p class="source-code">    marginBottom: '2%',</p><p class="source-code">  },</p><p class="source-code">  thumbnail: {</p><p class="source-code">    width: Dimensions.get('window').width * 0.98,</p><p class="source-code">    height: Dimensions.get('window').width * 0.98,</p><p class="source-code">    margin: Dimensions.get('window').width * 0.01,</p><p class="source-code">  },</p><p class="source-code">  details: {</p><p class="source-code">    width: '95%',</p><p class="source-code">    margin: '2%',</p><p class="source-code">  },</p><p class="source-code">});</p><p class="source-code">export default PostItem;</p></li>
				<li>Instead of a<a id="_idIndexMarker692"/> border around this component on iOS, we want to display a shadow. To add this shadow, we need to alter the styles for the component:<p class="source-code">// ...</p><p class="source-code">const styles = StyleSheet.create({</p><p class="source-code">  container: {</p><p class="source-code">    display: 'flex',</p><p class="source-code">    alignItems: 'center',</p><p class="source-code">    justifyContent: 'flex-start',</p><p class="source-code">    backgroundColor: 'white',</p><p class="source-code"><strong class="bold">-   borderWidth: 1,</strong></p><p class="source-code"><strong class="bold">-   borderColor: '#ccc',</strong></p><p class="source-code"><strong class="bold">-   marginBottom: '2%',</strong></p><p class="source-code"><strong class="bold">+   margin: '2%',</strong></p><p class="source-code"><strong class="bold">+   shadowColor: 'black',</strong></p><p class="source-code"><strong class="bold">+   shadowOffset: {</strong></p><p class="source-code"><strong class="bold">+     width: 0,</strong></p><p class="source-code"><strong class="bold">+     height: 2,</strong></p><p class="source-code"><strong class="bold">+   },</strong></p><p class="source-code"><strong class="bold">+   shadowOpacity: 0.25,</strong></p><p class="source-code"><strong class="bold">+   shadowRadius: 4,</strong></p><p class="source-code"><strong class="bold">+   elevation: 4,</strong></p><p class="source-code">  },</p><p class="source-code">  // ...</p><p class="callout-heading">Note</p><p class="callout">To have a depth of the shadow, iOS will look at the <strong class="source-inline">shadowRadius</strong> rule, while Android uses the <strong class="source-inline">elevation</strong> rule. </p></li>
				<li>Finally, we <a id="_idIndexMarker693"/>also need to change the dimensions of the image as we added a margin to the <strong class="source-inline">container</strong> style:<p class="source-code">// ...</p><p class="source-code">const styles = StyleSheet.create({</p><p class="source-code">  // ...</p><p class="source-code">  thumbnail: {</p><p class="source-code"><strong class="bold">-   width: Dimensions.get('window').width * 0.98,</strong></p><p class="source-code"><strong class="bold">-   height: Dimensions.get('window').width * 0.98,</strong></p><p class="source-code"><strong class="bold">+   width: Dimensions.get('window').width * 0.94,</strong></p><p class="source-code"><strong class="bold">+   height: Dimensions.get('window').width * 0.94,</strong></p><p class="source-code">    margin: Dimensions.get('window').width * 0.01,</p><p class="source-code">  },</p></li>
			</ol>
			<p>This will have the following result on iOS and Android, where the border has been replaced by a shadow:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_9.07_B17390.jpg" alt="Figure 9.7 – Differences in styling on iOS and Android"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Differences in styling on iOS and Android</p>
			<p>Depending on your type of phone you can <a id="_idIndexMarker694"/>also rename this file from <strong class="source-inline">components/PostItem.ios.js</strong> to <strong class="source-inline">components/PostItem.android.js</strong> to see the same changes on Android.</p>
			<p>That's it. With these final changes, you've created a React Native application that will run on both Android and iOS devices and has differences in styling between these two platforms.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor118"/>Summary</h1>
			<p>In this chapter, you've created a mobile social media application with React Native and Expo that uses a local API to send and receive data as well for authentication. To handle authentication, multiple types of navigators are combined. We've learned how to use the camera and the camera roll of a mobile device, after getting the permissions to use them. Also, the differences in styling between iOS and Android were explained.</p>
			<p>In completing this social media application, you've completed the final React Native chapter of this book and are now ready to start the very last chapter. In the last chapter, you'll be exploring another use case of React, which is VR. By combining React with Three.js, you can create 360-degree 2D and 3D experiences by writing React components. </p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor119"/>Further reading</h1>
			<ul>
				<li>Expo camera: <a href="https://docs.expo.io/versions/latest/sdk/camera/">https://docs.expo.io/versions/latest/sdk/camera/</a></li>
				<li>Platform-specific code: <a href="https://reactnative.dev/docs/platform-specific-code">https://reactnative.dev/docs/platform-specific-code</a></li>
			</ul>
		</div>
	</body></html>