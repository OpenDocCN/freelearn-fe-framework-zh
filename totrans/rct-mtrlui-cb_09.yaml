- en: Snackbars - Temporary Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Snackbar content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling visibility with state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snackbar transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning Snackbars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error boundaries and error Snackbars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snackbars with actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queuing Snackbars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material-UI comes with a `Snackbar` component that's used to display messages
    for users. These messages are brief, short-lived, and don't interfere with the
    main application components.
  prefs: []
  type: TYPE_NORMAL
- en: Snackbar content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text is the most common form of `Snackbar` message content that you'll display
    for your users. Because of this, the `Snackbar` component makes it straightforward
    to set message content and display the snackbar.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `message` property of the `Snackbar` component accepts a string value,
    or any other valid `React` element. Here''s the code that shows you how to set
    the content of the `Snackbar` component and display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the page first loads, you''ll see a snackbar that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc06a237-9745-43d4-a248-8c6f9981fffa.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a snackbar is nothing fancy, but it renders your text content as
    specified in the `message` property. The `open` property is set to true because
    any other value hides the snackbar.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Snackbar` components use `SnackbackContent` components to render the actual
    content that's displayed. In turn, `SnackbarContent` uses `Paper`, which uses
    `Typography`. It's kind of tricky to navigate through all of this indirection,
    but, thankfully, you don't have to. Instead, you can pass properties all the way
    to the `Typography` component from `Snackbar` via the `ContentProps` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you wanted to use the `h6` typography variant. Here''s how
    you could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Any properties that you want to pass to the component used by `Paper` can be
    set by `ContentProps`. Here, you''re passing the `variant` property—which results
    in the following visual change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e10fdf00-cbab-41a8-a9b1-2de68451df9b.png)'
  prefs: []
  type: TYPE_IMG
- en: The end result is larger text and a wider margin. The aim of this example isn't
    this particular typography change, but rather the idea that you can customize
    `Snackbar` text in the exact same way as you would `Typography` components.
  prefs: []
  type: TYPE_NORMAL
- en: You can put as many or as few components as you want into your snackbar content.
    For example, you can pass child components to `Snackbar` instead of in the `message`
    property. However, I would advise keeping your snackbar content as simple as possible.
    The last place where you want to go down a design rabbit hole is in a component
    that's already been designed to handle simple text.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling visibility with state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snackbars are displayed in response to something. For example, if a new resource
    in your application is created, then using a `Snackbar` component to relay this
    information to the user is a good choice. If you need to control the state of
    your snackbars, then you need to add a state that controls the visibility of the
    snackbar.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `open` property is used to control the visibility of the snackbar. All
    you need in order to control this property value is a state value that''s passed
    to it. Then, when this state changes, so does the visibility of the snackbar.
    Here''s some code that illustrates the basic idea of state-controlling snackbars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you first load the screen, all you''ll see is a SHOW SNACKBAR button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c500fa7d-3e9b-4916-b2d4-8e23d05a8e02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on this button shows the snackbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c17cca7-da80-40a3-a894-455b920c859b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The component has an `open` state that determines the visibility of the snackbar.
    The value of `open` is passed to the `open` property of `Snackbar`. When the user
    clicks on the SHOW SNACKBAR button, the `showSnackbar()` function sets the `open`
    state to true. As a result, the true value is passed to the `open` property of
    `Snackbar`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you've displayed a snackbar, you're going to need to be able to close it
    somehow. Once again, the `open` state can hide the snackbar. But how do you change
    the open state back to false? The typical pattern with snackbar messages is to
    have them appear only briefly, after which they're automatically hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'By passing two more properties to `Snackbar`, you can enhance this example
    so that the snackbar automatically hides itself after a certain time. Here''s
    the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A new function—`hideSnackbar()`—was added to the component. This is passed to
    the `onClose` property of `Snackbar`. The `autoHideDuration` component is the
    number of milliseconds that you want the snackbar to stay visible. In this example,
    after five seconds, the `Snackbar` component will call the function passed to
    its `onClose` property. This sets the `open` state to false, which is in turn
    passed to the `open` property of `Snackbar`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snackbar transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can control the transitions used by `Snackbar` components when it is displayed
    and hidden. The `Snackbar` component directly supports transition customization
    through properties, so you don't have to spend too much time thinking about how
    to implement your snackbar transitions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you want to make it easier to change the transition used by
    snackbars throughout your application. You could create a thin wrapper component
    around `Snackbar` that takes care of setting the appropriate properties. Here''s
    what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code renders four buttons and four snackbars. When you first load the
    screen, you''ll only see buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dedee27e-04ff-445e-b341-67407a1e9064.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on each of these buttons will display their corresponding `Snackbar`
    component at the bottom of the screen. If you pay attention to the transitions
    used when each of the snackbars is displayed, you''ll notice the difference depending
    on the buttons you press. For example, clicking on the Fade button will use the
    `fade` transition, resulting in the following snackbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9daca37-2d08-4039-9988-b0cdd6defdb6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the `MySnackbar` component that was created in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are two properties of interest here. The first is the `transition` string.
    This is used to look up the transition component to use. For example, the string
    `slide` will use the `Slide` component. The resulting component is used by the
    `TransitionComponent` property. The `Snackbar` components will use this component
    internally to apply the desired transition to your snackbars. The `direction`
    property is used with the `Slide` transition, which is why this property is passed
    to `TransitionProps`. These property values are passed directly to the component
    that's passed to `TransitionComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to using `TransitionProps` is to create a higher-order component
    that wraps its own property customization values. But since `Snackbar` is already
    set up to help you pass properties, there's no need to create yet another component
    if you want to avoid doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the component state and the functions that change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `first`, `second`, `third`, and `fourth` states correspond to their own
    `Snackbar` components. These state values control the visibility of each function,
    and their corresponding setter functions show or hide the snackbars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at two of the `MySnackbar` components being rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Both of these instances use the `slide` transition. However, the `direction`
    property is different for each. The `MySnackbar` abstraction makes it a little
    simpler for you to specify transitions and transition arguments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slide` API documentation: [https://material-ui.com/api/slide/](https://material-ui.com/api/slide/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grow` API documentation: [https://material-ui.com/api/grow/](https://material-ui.com/api/grow/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fade` API documentation: [https://material-ui.com/api/fade/](https://material-ui.com/api/fade/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning snackbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material-UI Snackbar components have an `anchorOrigin` property that allows
    you to change the position of the snackbar when it's displayed. You might be fine
    using the default positioning of snackbars, but sometimes you'll need this level
    of customization to stay consistent with other parts of your application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While you can''t arbitrarily position snackbars on the screen, there are a
    number of options that allow you to change the position of the snackbar. Here''s
    some code that allows you to play around with the `anchorOrigin` property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the screen first loads, you''ll see controls for changing the position
    of the snackbar, and the `Snackbar` component in its default position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29816333-2b70-4315-8640-ab8ea3bd3a35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you change any of the position control values, the snackbar will move to
    the new position. For example, if you changed the vertical anchor to top and the
    horizontal anchor to the right, here''s what you''d see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e4851ae-c7fb-46d4-b028-9a224197965f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two radio button groups in this example are only used to illustrate the
    different position value combinations that are available. In a real application
    where you show snackbars, you wouldn't have the configurable state to change the
    positioning of your snackbars. Instead, you should think of a value passed to
    the `anchorOrigin` property as a configuration value that is set once during startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'It isn''t good to rely on state values, as is the case in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you would set the `anchorOrigin` values statically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you know where you want to position your snackbars, you can create your
    own `Snackbar` component that has the `anchorOrigin` values defined. Here''s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Anywhere in your app that `MySnackbar` is used, the snackbars will be displayed
    in the top-right corner of the screen. Otherwise, `MySnackbar` is just like a
    regular `Snackbar` component.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error boundaries and error snackbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Error boundaries** in React enable you to capture errors that happen when
    your components attempt to render. You can use the `Snackbar` components in your
    error boundaries to display captured errors. Furthermore, you can style snackbars
    so that errors are visually distinctive from normal messages.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have an error boundary at the top level of your application
    and you want to use the `Snackbar` component to display error messages to users.
    Here''s an example that shows how you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you load this screen, the `MyButton` component throws an error when it
    is rendered. Here''s what you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bead05ef-fa91-4b44-bb5e-71077ede8232.png)'
  prefs: []
  type: TYPE_IMG
- en: It explicitly throws an error so that you can see the error boundary mechanism
    in action. In a real application, the error could be triggered by any function
    that's called during the rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by taking a closer look at the `ErrorBoundary` component. It has
    an `error` state that is initially null. The `componentDidCatch()` life cycle
    method changes this state when an error happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s take a closer look at the `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It uses the `error` state to determine whether children should be rendered.
    When the `error` state is non-null, it doesn't make sense to render child components
    because you'll be stuck in an infinite loop of error being thrown and handled.
    The `error` state is also used as the `open` property to determine whether the
    snackbar should be displayed, and as the message text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ContentProps` property is used to style the snackbar so that it looks
    like an error. The `error` class uses `theme` values to change the background
    and text color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The error boundary used in this example covered the entire application. This
    is good in the sense that you can blanket the entire application with error handling
    in one shot. But this is also bad, because the entire user interface vanishes,
    as the error boundary has no idea which component failed.
  prefs: []
  type: TYPE_NORMAL
- en: Because error boundaries are components, you can place as many of them as you
    like at any level of your component tree. This way, you can show Material-UI `error`
    snackbars while keeping the parts of the UI that haven't failed visible on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the scope of the error boundary used in the example. First, you
    can change the `MyButton` implementation so that it only throws an error when
    a Boolean property is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can render a button with a given label. If `throwError` is `true`,
    then nothing is rendering due to the error. Next, let''s change the markup of
    the example to include multiple buttons and multiple `error` boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first button renders without any issues. However, if the error boundary
    were all-encompassing as was the case earlier, then this button wouldn''t be displayed.
    The second button throws an error because the `throwError` property is true. Because
    this button has its own error boundary, it doesn''t prevent other parts of the
    UI that are working fine from rendering. Here''s what you''ll see when you run
    the example now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d99b7b87-8bdd-4a81-a7de-f75153243672.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React `error` boundaries: [https://reactjs.org/docs/error-boundaries.html](https://reactjs.org/docs/error-boundaries.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` demos:[ https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snackbars with actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of Material-UI snackbars is to display brief messages for the user.
    Additionally, you can embed the next course of action for the user in the snackbar.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you want a simple button in your snackbar that closes the snackbar.
    This could be useful for closing the snackbar before it automatically closes.
    Alternatively, you might want to require the user to explicitly acknowledge the
    message by having to close it manually. Here''s the code to add a close button
    to a `Snackbar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When the screen first loads, you''ll only see a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a61bb63f-4c29-47b1-8335-33d0566a7e9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on this button will display the snackbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d5f0fca-e179-4564-a0cd-eb26271e5357.png)'
  prefs: []
  type: TYPE_IMG
- en: The close icon button on the right side of the snackbar, when clicked on, closes
    the snackbar.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The close button is added to the `Snackbar` component via the `action` property,
    which accepts either a node or an array of nodes. The `SnackbarContent` component
    takes care of applying styles to align the actions within the snackbar.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When users create new resources in your application, you probably want to let
    them know when the resource is created successfully. Snackbars are a good tool
    for this because they don't force the user away from anything that they might
    be in the middle of. What would be nice is if you included an action button in
    the snackbar that linked to the newly created resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify this example so that, when the user clicks on the CREATE button,
    they''ll see a snackbar with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A close action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A link to the new resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add routes from `react-router-dom` and then add the link to the snackbar.
    Here''s the new markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first route is for the index page, so, when the screen first loads, the
    user will see the button that''s rendered by this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7991362c-463f-4c48-ad8e-66e363af3fac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on this button, you''ll see the snackbar that includes a link
    to the newly-created resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99462ff9-de18-4dae-821e-da1340720b9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you've given the user an easy way to navigate to the resource without disrupting
    what they're currently doing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React router guide: [https://reacttraining.com/react-router/web/guides/quick-start](https://reacttraining.com/react-router/web/guides/quick-start)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queuing snackbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With larger Material-UI applications, you're likely to find yourself in a situation
    where more than one snackbar message is sent in a very short period of time. To
    deal with this, you can create a queue for all snackbar messages so that only
    the most recent notification is displayed, and so that the transitions are handled
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that you have several components throughout your application that
    need to send snackbar messages to your users. Having to manually render `Snackbar`
    components everywhere would be cumbersome—especially if all you're trying to do
    is display simple text snackbars.
  prefs: []
  type: TYPE_NORMAL
- en: 'One alternative approach is to implement a higher-order component that wraps
    your components with the ability to display messages by calling a function and
    then passing the text as the argument. Then, you can wrap any components that
    need the snackbar capability. Here''s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the screen first loads, you''ll see a message button. Clicking on it will
    display a snackbar message that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/785de96d-5cee-4ab8-a83f-7c2c6f825242.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the message button again will clear the current snackbar by visually
    transitioning it off of the screen before transitioning the new snackbar onto
    the screen. Even if you click the button several times in rapid succession, everything
    works smoothly and you''ll always see the latest message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7740450-84b3-44e7-9951-8ff3ab18688d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the `QueuingSnackbars` component that renders the
    button that sends messages when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `withMessage()` wrapper provides the component with a `message()` function
    as a property. If you look at the `onClick()` handler, you can see the `message()`
    function in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s break down the `withMessage()` higher-order component. We''ll
    start with the markup and work our way downward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Wrapped` component is the component that `withMessage()` was called on.
    It''s passed the normal props that it would be called with normally, plus the
    `message()` function. Adjacent to this is the `Snackbar` component. There are
    two interesting properties that are worth pointing out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key`: This value is used internally by `Snackbar` to determine whether a new
    message is being displayed. It should be a unique value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onExit`: This is called when the transition of a snackbar that is closing
    completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `sendMessage()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function is called whenever a component wants to display a snackbar message.
    It puts the `message` string into the queue. If the message is the only item in
    the queue, then the `open` and `message` states are updated right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `onClose()` function. This is called when the snackbar
    is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The only job of this function is to make sure that the open state is false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s look at the `onExit()` function that''s called when a snackbar
    has completed its exit transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The fist message in the queue is assigned to the `message` constant. If there's
    a message, it becomes the active message state and the next snackbar is opened.
    The item is also removed from the queue at this point.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Snackbar` demos: [https://material-ui.com/demos/snackbars/](https://material-ui.com/demos/snackbars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Snackbar` API documentation: [https://material-ui.com/api/snackbar/](https://material-ui.com/api/snackbar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button` API documentation: [https://material-ui.com/api/button/](https://material-ui.com/api/button/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
