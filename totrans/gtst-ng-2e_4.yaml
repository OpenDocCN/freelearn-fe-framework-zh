- en: Chapter 4. Getting Started with Angular Components and Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point, we're already familiar with the core building blocks that Angular
    provides for the development of single-page applications and the relations between
    them. However, we've touched only the surface by introducing the general idea
    behind Angular's concepts and the basic syntax used for their definition. In this
    chapter, we'll take a deep dive into Angular's components and directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforced separation of concerns of the building blocks that Angular provides
    for developing applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The appropriate use of directives or components when interacting with the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in directives and developing custom ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-depth look at components and their templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content projection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View children versus content children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component's life cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using template references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Angular's change detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "Hello world!" application in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s build our first "Hello world!" application in Angular. In order
    to get everything up and running as easy and quickly as possible, for our first
    application, we will use the ECMAScript 5 syntax with the transpiled bundle of
    Angular. First, create the `index.html` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the examples in this book are built with Angular 2.2.0\. In case you're
    using a newer version of the framework there might be slight differences. For
    further information take a look at the changelog at [https://github.com/angular/angular/blob/master/CHANGELOG.md](https://github.com/angular/angular/blob/master/CHANGELOG.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding HTML file defines the basic structure of our page. Just before
    closing the `body` tag, we have references to a few script files: polyfills (zone.js
    and reflect-metadata) required by the framework, RxJS, the ES5 bundles of different
    packages of Angular, and the file that contains the application we''re going to
    build.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RxJS is used by Angular's core in order to allow us to empower the reactive
    programming paradigm in our applications. In the following content, we will take
    only a shallow look at how we can take advantage of observables. For further information,
    you can visit the RxJS GitHub repository at [https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same directory where your `index.html` resides, create a file called
    `app.js` and enter the following content inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we defined a component called `App` with an `my-app`
    selector. The component has the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This syntax should already be familiar to you from AngularJS. When compiled
    in the context of the given component, the preceding snippet will interpolate
    the template with the result of the expression inside the curly brackets. In our
    case, the expression is simply the `target` variable.
  prefs: []
  type: TYPE_NORMAL
- en: To `Class`, we pass an object literal, which has a single method called `constructor`.
    This **DSL** (**domain-specific language**) provides an alternative way to define
    classes in ECMAScript 5\. In the body of the `constructor` function, we add a
    property called `target` with a value of the `"world"` string. Right after that,
    we define our `AppModule` class. Note that every component on our application
    must be associated with a module. Inside the module, as explained in [Chapter
    2](ch02.html "Chapter 2. The Building Blocks of an Angular Application"), *The
    Building Blocks of an Angular Application*, we define the declarations, imports,
    and the bootstrap component.
  prefs: []
  type: TYPE_NORMAL
- en: At the last line of the snippet, we invoke the `bootstrapModule` method of the
    object returned by the invocation of `ng.platformBrowserDynamic()`. As argument
    of `bootstrapModule`, we pass the `AppModule` we just defined.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `bootstrapModule` is under the `ng.platformBrowserDynamic` namespace.
    This is due to the fact that the framework is built with different platforms in
    mind, such as the browser, NativeScript, and so on. By placing the bootstrap methods
    used by the different platforms under a separate namespace, Angular can implement
    different logic to initialize the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you open `index.html` with your browser, you should see some errors,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The "Hello world!" application in Angular](img/B06166_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: 'This happened because we missed something quite important. We didn''t use the
    root component anywhere inside `index.html`. In order to finish the application,
    add the following HTML element after the open tag of the body element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can refresh your browser to see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The "Hello world!" application in Angular](img/2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: Using TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we already have an Angular application running, we can do much better!
    We didn't use any package manager or module loader. We spent all of [Chapter 3](ch03.html
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*, talking about
    TypeScript; however, we didn't write a single line of it in the preceding application.
    Although it is not required that you use TypeScript with Angular, it's more convenient
    to take advantage of all the bonuses that static typing provides. By using TypeScript,
    we can also use the Ahead-of-Time compilation in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core team of Angular developed a brand new CLI tool for Angular, which allows
    us to bootstrap our applications with a few commands. Although we will introduce
    it in the final chapter, by then, in order to boost our learning experience, we
    will use the code located at [https://github.com/mgechev/getting-started-with-angular](https://github.com/mgechev/getting-started-with-angular).
    This repository includes all the examples in this book, in one big application.
    It has all the required dependencies declared in `package.json`, the definition
    of basic gulp tasks, such as the development server, the transpilation of your
    TypeScript code to ECMAScript 5, live-reload, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The project that contains all the examples for this book is based on angular-seed
    ([https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)),
    which allows us to quickly bootstrap an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: In order to set up the `getting-started-with-angular` project, you'll need Git,
    Node.js v6.x.x, and npm up and running on your computer. If you have a different
    version of the Node.js installed, I recommend that you take a look at nvm (the
    Node.js version manager, which is available at [https://github.com/creationix/nvm](https://github.com/creationix/nvm))
    or n ( [https://www.npmjs.com/package/n](https://www.npmjs.com/package/n) ). Using
    these tools, you'll be able to have multiple versions of Node.js on your machine
    and switch between them with a single command via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the sample project repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by setting up the `getting-started-with-angular` project. Open
    your terminal and enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line will clone the `getting-started-with-angular` project into a
    directory called `getting-started-with-angular`; after that we enter that directory.
  prefs: []
  type: TYPE_NORMAL
- en: The last step before being able to run the seed project is to install all the
    required dependencies using npm. This step may take a while depending on your
    Internet connection, so be patient and do not interrupt it. If you encounter any
    problems, do not hesitate to raise the issues at [https://github.com/mgechev/getting-started-with-angular/issues](https://github.com/mgechev/getting-started-with-angular/issues).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step left is to start the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the process of the transpilation is completed, your browser will automatically
    open with `http://localhost:5555/dist/dev`. You should now see a view similar
    to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the sample project repository](img/3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Angular and TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s play around with the files we already have. Navigate to the `app/ch4/ts/hello-world`
    directory inside `getting-started-with-angular`. Then, open `app.ts` and replace
    its content with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the code line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we import the `@Component` and `@NgModule` decorators from the `@angular/core`
    module, `BrowserModule` from `@angular/platform-browser` and the `platformBrowserDynamic` object
    from `@angular/platform-browser-dynamic`. Later, we use `@Component` to decorate
    the `App` class. To the `@Component` decorator, we pass the same object literal
    that we used in the ECMAScript 5 version of the application, but this time we
    reference to an external template.
  prefs: []
  type: TYPE_NORMAL
- en: As a next step, we define the view of the component. However, note that in this
    case, we use `templateUrl` instead of simply inlining the component's template.
  prefs: []
  type: TYPE_NORMAL
- en: Open `app.html` and replace the file's content with `<h1>Hello {{target}}!</h1>`.
    The content of `app.html` should be the same as the inlined template we have used
    previously. Since we can use a template by both inlining it (with `template`)
    and setting its URL (`templateUrl`), in some sense, the component's API is similar
    to the AngularJS directives API.
  prefs: []
  type: TYPE_NORMAL
- en: In the last line of the snippet, we bootstrap the application by providing the
    root module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at `index.html` in order to get a sense of what goes
    on when we start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that inside the body of the page, we use the `my-app` element with content
    a text node with value `"Loading..."`. The `"Loading..."` label will be visible
    until the application gets bootstrapped and the main component gets rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are template placeholders `<%= INIT %>`  and `<-- inject:js...` that inject
    content that is specific to individual demos. They are not Angular specific, but
    instead aim to prevent code duplications in the code samples attached to the book
    because of the shared structure between them. In order to see how this specific
    HTML file has been transformed, open `/dist/dev/ch4/ts/hello-world/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already built our simple "Hello world!" app. Now, let's start building
    something that is closer to a real-life application. By the end of this section,
    we'll have a simple application that lists a number of items we need to do and
    greets us at the header of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by developing our `app` component. The two modifications from
    the preceding example that we need to make are renaming the `target` property
    to `name` and adding a list of `todos` to the component''s controller definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The only thing left is to update the template in order to consume the provided
    data. We're already familiar with the `ng-repeat` directive from AngularJS. It
    allows us to loop over a list of items using a microsyntax, which is later interpreted
    by AngularJS. However, the directive doesn't carry enough semantics, so it is
    hard to build tools that perform static code analysis and help us improve our
    development experience. Since the `ng-repeat` directive is quite useful, Angular
    kept the idea and improved it further in order to allow more sophisticated tooling
    by introducing further semantics on top of it. It allows IDEs and text editors
    to perform better static code analysis. Such support will prevent us from making
    typos in the code we write and allow us to have a smoother development experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.html`, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `template` element is a place where we can hold markup and make sure that
    it won't be rendered by the browser. This is quite useful if we need to embed
    the templates of our application directly into the markup of the page and let
    the template engine we're using to process them at some point. In the current
    example, this means that if the Angular's DOM compiler doesn't process the DOM
    tree, we will not see the list item inside the `ul` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after you refresh your browser, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Angular directives](img/4-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good! The only new things left in the preceding snippets are the
    attributes of the `template` element that we're not familiar with, such as `ngFor`,
    `let-todo`, and `[ngForOf]`. Let's take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: The ngFor directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ngFor` directive is a directive that allows us to loop over a collection
    of items and does exactly what `ng-repeat` does in AngularJS, but it brings some
    extra semantics. Note that the `ngForOf` attribute is surrounded by brackets.
    At first, these brackets may seem like invalid HTML. However, according to the
    HTML specification, their use is permitted in attribute names. The only thing
    the W3C validator will complain about is the fact that the `template` element
    doesn't own such attributes; however, browsers won't have problems processing
    the markup.
  prefs: []
  type: TYPE_NORMAL
- en: The semantics behind these brackets is that the value of the attribute surrounded
    by them is an expression, which needs to be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Improved semantics of the directives syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. Get Going with Angular"), *Get Going with
    Angular*, we mentioned the opportunity for improved tooling in Angular. A big
    issue in AngularJS is the different ways in which we can use directives. This
    requires an understanding of the attribute values, which can be literals, expressions,
    callbacks, or a microsyntax. Starting with Angular 2, this problem is eliminated
    by introducing a few simple conventions that are built into the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`propertyName="value"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[propertyName]="expression"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(eventName)="handler()"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first line, the `propertyName` attribute accepts a string literal as
    a value. Angular will not process the attribute's value any further; it will use
    it the way it is set in the template.
  prefs: []
  type: TYPE_NORMAL
- en: The second syntax, `[propertyName]="expression"`, gives a hint to Angular that
    the value of the attributes should be handled as an expression. When Angular finds
    an attribute surrounded by brackets, it will interpret the expression in the context
    of the component associated with the template. In short, if we want to set a nonstring
    value or the result of an expression as value of given property, we will need
    to use this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The last example shows how we can bind to events. The semantics behind `(eventName)="handler()"`
    is that we want to handle all events called `eventName` that are triggered by
    the given component with the `handler()` expression.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss more examples later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular provides alternative canonical syntax, which allows us to define the
    bindings of the elements without using brackets. For instance, the property binding
    can be expressed using the following code: `<input [value]="foo">`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be expressed using this: `<input bind-value="foo">`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can express the event bindings with the following code: `<button
    (click)="handle()">Click me</button>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'They can also be expressed using this: `<button on-click="handle()">Click me</button>`'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables inside a template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing left from the preceding template is the `let-todo` attribute.
    Using this syntax, we are telling Angular that we want to declare a new variable
    called `todo` and bind it to the individual items from the collection we get from
    the evaluation of the expression set as a value of `[ngForOf]`.
  prefs: []
  type: TYPE_NORMAL
- en: Using syntax sugar in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the template syntax provides much more meaning of the code to the IDEs
    or text editors we use, it is quite verbose. Angular provides an alternative syntax,
    which will be desugared to the one shown in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few Angular directives that require the usage of a template element,
    for example, `ngForOf`, `ngIf`, and `ngSwitch`. Since such directives are used
    often, there''s an alternative syntax for them. Instead of typing down the entire
    template element explicitly, we can simply prefix the directive with `*`. This
    will allow us to turn our `ngForOf` directive syntax usage into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Later, this template will be desugared by Angular to the more verbose syntax
    described earlier. Since the less verbose syntax is easier to read and write,
    its use is considered as the best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `*` character allows us to remove the `template` element and put the directive
    directly on the top-level child element of the `template` (in the preceding example,
    the list item, `li`).
  prefs: []
  type: TYPE_NORMAL
- en: Defining Angular directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've built a simple Angular component, let's continue our journey
    by understanding the Angular directives.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular directives, we can apply different behavioral or structural changes
    over the DOM. In this example, we will build a simple tooltip directive.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to components, directives do not have views and templates. Another
    core difference between these two concepts is that the given HTML element may
    have only a single component but multiple directives on it. In other words, directives
    augment the elements compared to components that are the actual elements in our
    views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular''s official style guide''s recommendation is to use directives as attributes,
    prefixed with a namespace. Keeping this in mind, we will use the tooltip directive
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we use the tooltip directive over the `div` element.
    As a namespace, its selector uses the `sa` string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the focus of the book is an efficient and intuitive learning of Angular's
    concepts, the code snippets may not completely align with the Angular style guide.
    However, for production applications, following best practices is essential. You
    can find the official Angular style guide at [https://angular.io/styleguide](https://angular.io/styleguide)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s develop a tooltip directive! Before implementing it, we need to
    import a couple of symbols from `@angular/core`. Open a new TypeScript file called
    `app.ts` and enter the following content; we''ll fill the placeholders later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line, we import the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ElementRef`: This allows us to inject the element reference (we''re not limited
    to the DOM only) to the host element. In the sample usage of the preceding tooltip,
    we get an Angular wrapper of the `div` element, which holds the `saTooltip` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Directive`: This decorator allows us to add the metadata required for the
    new directives we define.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostListener(eventname)`: This is a method decorator that accepts an event
    name as an argument. During initialization of the directive, Angular will add
    the decorated method as an event handler for the `eventname` events fired by the
    host element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the directive''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Setting the directive's inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we declared a directive with the `saTooltip` selector.
    Note that Angular's HTML compiler is case sensitive, which means that it will
    distinguish the `[satooltip]` and `[saTooltip]` selectors. After that, we declare
    the input of the directive using the `@Input` decorator over the `saTooltip` property.
    The semantics behind this code is that we declare a property called `saTooltip`
    and bind it to the value of the result that we got from the evaluation of the
    expression passed to the `saTooltip` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Input` decorator accepts a single argument, that is, the name of the attribute
    we want to bind to. In case we don't pass an argument, Angular will create a binding
    between the attribute with the same name as the property itself. We will explain
    the concept of input and output in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the directive's constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constructor declares two private properties: `el` of the `ElementRef` type
    and `overlay` of the `Overlay` type. The `Overlay` class implements logic to manage
    the tooltips'' overlays and will be injected using the DI mechanism of Angular.
    In order to declare it as available for injection, we will need to declare the
    top-level component in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will take a look at the dependency injection mechanism of Angular in the
    next chapter, where we will explain the way in which we can declare the dependencies
    of our services, directives, and components. The implementation of the `Overlay`
    class is not important for the purpose of this chapter. However, if you're interested
    in it, you can find the implementation at `ch4/ts/tooltip/app.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Better encapsulation of directives with NgModules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make the tooltip directive available to the Angular''s compiler,
    we will need to explicitly declare where we intend to use it. For instance, take
    a look at the `AppModule` class at `ch4/ts/tooltip/app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To the `@NgModule` decorator, we pass an object literal that has the `declarations` property.
    This property contains a list of all the directives that will be available in
    all component subtrees with roots any of the components listed in the `bootstrap`
    array. Another way to extend the list of available directives is to import a module.
    For instance, the module `BrowserModule` includes some very commonly used directives
    for the browser environment.
  prefs: []
  type: TYPE_NORMAL
- en: At first, it might seem annoying that you should explicitly declare all the
    directives that are used in your modules; however, this enforces better encapsulation.
    In AngularJS, all directives are in a global namespace. This means that all the
    directives defined in the application are accessible in all the templates. This
    brings in some problems, for example, name collision. In order to deal with this
    issue, we introduced naming conventions, for instance, the `"ng-"` prefix of all
    the directives defined by AngularJS and `"ui-"` for all directives coming with
    the Angular UI.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, by explicitly declaring all the directives that are used within a
    given module, we create a namespace specific to the individual components' subtrees
    (that is, the directives will be visible to the given root component and all of
    its successor components). Preventing name collisions is not the only benefit
    we get; it also helps us with better semantics of the code that we produce, since
    we're always aware of the directives accessible by the given component when we
    know in which module it's declared. We can find all the accessible directives
    of the given component by following the path from the component to the top module and
    taking the union of all the values of `declarations` and the declarations of the
    modules' `imports`. Given that components are extended from directives, we need
    to explicitly declare all the used components as well.
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular defines a set of built-in directives, `BrowserModule` exports
    them by exporting the module `CommonModule`, which contains them. This list of
    predefined directives includes `NgClass`, `NgFor`, `NgIf`, `NgStyle`, `NgSwitch`,
    `NgSwitchWhen`, and `NgSwitchDefault`. Their names are quite self-explanatory;
    we'll take a look at how we can use some of them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using NgModules for declaring reusable components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With NgModules, we can achieve a good degree of encapsulation. By explicitly
    exporting the public components, directives, pipes, and services, we can hide
    some of the implementation details of our modules. This way we can implement reusable
    modules and expose only their public interface, and we do not reveal any low-level
    components to the user of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a better idea, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we declare the components `Zippy`, `ZippyHeader`,
    and `App`. `Zippy` is a component that has a header and a content; we can toggle
    the visibility of the content by clicking on the header. In the component `ZippyHeader`,
    we can implement some logic for handling the click events and/or visualizing the
    header. In the `App` component, we use the `Zippy` component by passing text for
    it's header and content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a working Angular application, we will need to declare an
    NgModule, which somehow references all the three components. We can approach this
    in two main ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a single NgModule and include all the three components inside of its
    list of declarations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare two NgModules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One that declares the `Zippy` and `ZippyHeader` components, called `ZippyModule`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another one that declares the `App` component and imports the module `ZippyModule`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second approach has a couple of advantages: in `ZippyModule`, we can declare
    both `Zippy` and `ZippyHeader`, but we can export only `Zippy` because `ZippyHeader`
    is used internally, within `Zippy`, and we don't have to expose it to the user.
    By declaring the module `ZippyModule`, we can import it into other modules in
    our application where we want to reuse the `Zippy` component, or we can even extract
    it as a separate npm module and reuse it in multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, in the module `ZippyModule`, we declare both `Zippy`
    and `ZippyHeader`, but we export only `Zippy`. We also import the module `CommonModule`
    from `@angular/common` in order to reuse Angular's built-in directives (for instance, `NgIf`
    is exported by the `CommonModule`).
  prefs: []
  type: TYPE_NORMAL
- en: In the `AppModule`, all we need to do is to import `ZippyModule`, and this way,
    we'll be able to use all of its exports and providers. We'll discuss providers
    further in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that good practices suggest that we should implement each individual component
    into a separate file. For the sake of simplicity in the examples for this book,
    we've violated this practice. For a list of best practices, visit [https://angular.io/styleguide](https://angular.io/styleguide).
  prefs: []
  type: TYPE_NORMAL
- en: Using custom element schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we want to add a timer to our page and reuse a Web Component
    that we have already built. In this case, our application can look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run our application, we''ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom element schema](img/B06166_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5
  prefs: []
  type: TYPE_NORMAL
- en: When Angular parses the template of the `App` component, it will find the `<simple-timer></simple-timer>`.
    It is not an element defined by the HTML specification and it doesn't match any
    of the selectors of the directives declared or imported in the `AppModule`, so
    the framework will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how we can use Angular with custom components? The solution is to use the
    `schemas` property of the object literal we pass to `@NgModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This way we change the default schema that Angular uses for the validation of
    the elements and their attributes during parsing.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the framework will throw an error if it finds an element that doesn't
    match the element selector of any of the imported or declared directive, or an
    element defined by the HTML5 spec.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom Angular components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's build a simple to-do application in order to demonstrate the syntax
    to define components further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our to-do items will have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by importing everything we will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare the component and the metadata associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify that the selector of the `Todo` component will be the `todo-app`
    element. Later, we add the template URL, which points to the `app.html` file.
    After that, we use the `styles` property; this is the first time we encounter
    it. As we can guess from its name, it is used to set the styles of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the component's view encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, Angular is inspired from Web Components, whose core feature is the
    shadow DOM. The shadow DOM allows us to encapsulate the styles of our Web Components
    without allowing them to leak outside the component's scope; Angular provides
    this feature. If we want Angular's renderer to use the shadow DOM, we can use
    `ViewEncapsulation.Native`. However, at the time of writing this book, the shadow
    DOM was not supported by all browsers; if we want to have the same level of encapsulation
    without using the shadow DOM, we can use `ViewEncapsulation.Emulated`.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't want to have any encapsulation at all, we can use `ViewEncapsulation.None`.
    By default, the renderer uses encapsulation of the type `Emulated`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the component's controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s continue with the implementation of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here is part of the implementation of the controller associated with the template
    of the `Todo` application. Inside the class declaration, we initialized the `todos`
    property to an array with two `todo` items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s update the template and render these items. Here''s how this is
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding template, we iterate over all the `todo` items inside the
    `todos` property of the controller. For each `todo` item, we create a checkbox
    that can `toggle` the item''s completion status; we also render the `todo` item''s
    label with the interpolation directive. Here, we can note a syntax that was explained
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: We bind to the change event of the checkbox using `(change)="statement"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We bind to the property of the `todo` item using `[checked]="expr"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to have a line across the completed `todo` items, we bind to the `class.completed`
    property of the element. Since we want to apply the `completed` class to all the
    completed to-do items, we use `[class.completed]="todo.completed"`. This way,
    we declare that we want to apply the `completed` class depending on the value
    of the `todo.completed` expression. Here is how our application looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the component''s controllers](img/6-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the class binding syntax, Angular allows us to bind to the element''s
    styles and attributes. For instance, we can bind to the `td` element''s `colspan`
    attribute using the following line of code: `<td [attr.colspan]="colspanCount"></td> `'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, we can bind to any `style` property using this line of code:
     `<div [style.backgroundImage]="expression"></td>`'
  prefs: []
  type: TYPE_NORMAL
- en: Handling user actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, so good! Now, let''s implement the `toggleCompletion` method. This
    method accepts the index of the to-do item as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In `toggleCompletion`, we simply toggle the `completed` boolean value associated
    with the current to-do item, which is specified by the index passed as an argument
    to the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a text input to add the new to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The input here defines a new variable called `newtodo`. Now, we can reference
    the input element using the `newtodo` identifier inside the template. Once the
    user clicks on the button, the `addTodo` method defined in the controller will
    be invoked with the value of the `newtodo` input as an argument. Inside the statement
    that is passed to the `(click)` attribute, we also reset the value of the `newtodo`
    input by setting it to the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that directly manipulating DOM elements is not considered as the best practice
    since it will prevent our component from running properly outside the browser
    environment. We will explain how we can migrate this application to Web Workers
    in [Chapter 8](ch08.html "Chapter 8. Tooling and Development Experience"),  *Tooling
    and Development Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the `addTodo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inside it, we create a new to-do item using the object literal syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing left out of our application is to implement removal of the existing
    to-do items. Since it is quite similar to the functionality used to toggle the
    completion of the to-do items, I'll leave its implementation as a simple exercise
    for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Using inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By refactoring our `todo` application, we will demonstrate how we can take
    advantage of the directives'' inputs and outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using inputs and outputs](img/B06166_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7
  prefs: []
  type: TYPE_NORMAL
- en: We can think of the inputs as properties (or even arguments) that the given
    directive accepts. The outputs could be considered as events that it triggers.
    When we use a directive provided by a third-party library, mostly, we care about
    its inputs and outputs because they define its API.
  prefs: []
  type: TYPE_NORMAL
- en: Inputs refer to values that parameterize the directive's behavior and/or view.
    On the other hand, outputs refer to events that the directive fires when something
    special happens.
  prefs: []
  type: TYPE_NORMAL
- en: Determining of the inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s divide our monolithic to-do application into separate components
    that communicate with each other. In the following screenshot, you can see the
    individual components, which when composed together, implement the functionality
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining of the inputs and outputs](img/8-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8
  prefs: []
  type: TYPE_NORMAL
- en: The outer rectangle represents the entire `Todo` application. The first nested
    rectangle contains the component that is responsible for entering labels of the
    new to-do items, and the one below it lists the individual items stored in the
    root component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said this, we can define these three components as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TodoApp`: This is responsible for maintaining the list of to-do items (adding
    new items and toggling the completion status).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputBox`: This is responsible for entering the label of the new to-do item.
    It has the following inputs and outputs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inputs: a placeholder for the textbox and a label for the submit button.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Outputs: the content of the textbox once the submit button is clicked.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TodoList`: This is responsible for rendering the individual to-do items. It
    has the following inputs and outputs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inputs: a list of to-do items.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Outputs: the completion status of a to-do item.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's begin with the implementation!
  prefs: []
  type: TYPE_NORMAL
- en: Defining the inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use a bottom-up approach, and start with the `InputBox` component. Before
    that, we need a couple of imports from Angular''s `@angular/core` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we import the `@Component`, `@Input`, and `@Output` decorators
    and the `EventEmitter` class. As their names state, `@Input` and `@Output` are
    used for declaring the directive's inputs and outputs. `EventEmitter` is a generic
    class (that is, accepting a type parameter), which when combined with the `@Output`
    decorator helps us emit outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the next step, let''s take a look at the `InputBox` component''s declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the template, we declare a text input and keep a reference to
    it using the `todoInput` identifier, and set its placeholder property to the value
    that we got from the evaluation of the `inputPlaceholder` expression. The value
    of the expression is the value of the `inputPlaceholder` property defined in the
    component''s controller. This is the first input that we need to declare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we declare the other input of the `buttonLabel` component, which
    we use as a value of the label of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding template, we bind the click event of the button to this  `emitText(todoInput.value);
    todoInput.value = '''';` statement. The `emitText` method should be defined in
    the component''s controller; once it is invoked, it should emit the value of the
    text input. Here is how we can implement this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we declare an output called `inputText`. As its value, we set a new
    instance of the type `EventEmitter<string>` that we create.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that all the outputs of all the components need to be instances of `EventEmitter`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `emitText` method, we invoke the `emit` method of the `inputText` and
    as its argument we pass the value of the text input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the `TodoList` component in the same fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since the value of the object literal passed to the `@Component` decorator is
    not essential for the purpose of this section, we omitted it. The complete implementation
    of this example can be found at `ch4/ts/inputs-outputs/app.ts`. Let's take a look
    at the body of the `TodoList` class. Similarly, to the `InputBox` component, we
    define the `todos` input. We also define the `toggle` output by declaring the
    `toggle` property, setting its value to a new instance of the type `EventEmitter<Todo>`
    and decorating it with the `@Output` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Passing inputs and consuming the outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's combine the components we defined in the preceding section and implement
    our complete application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last component we need to take a look at is `TodoApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we define the `TodoApp` class and decorate it with the `@Component`
    decorator. Note that in order to use the `InputBox` and `TodoList` components,
    we will need to include them in the `declarations` property of the decorator of
    the module, which declares `TodoApp`. The magic of how these components collaborate
    together happens in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, we use the `InputBox` component and pass values to the inputs `inputPlaceholder`
    and `buttonLabel`. Note that just like we saw earlier, if we want to pass an expression
    as a value to any of these inputs, we will need to surround them with brackets
    (that is, `[inputPlaceholder]="expression"`). In this case, the expression will
    be evaluated in the context of the component that owns the template, and the result will
    be passed as an input to the component that owns the given property.
  prefs: []
  type: TYPE_NORMAL
- en: Right after we pass the value for the `buttonLabel` input, we consume the `inputText`
    output by setting the value of the `(inputText)` attribute to the `addTodo($event)`
    expression. *The value of* `$event` *will equal the value we passed to the* `emit`
    *method of the* `inputText` *object inside the* `emitText` *method of* `InputBox`
    (in case we bind to a native event, the value of the event object will be the
    native event object itself).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, we pass the input of the `TodoList` component and handle its
    toggle output. Now, let''s define the logic behind the `TodoApp` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `addTodo` method, we simply push a new to-do item to the `todos` array.
    The implementation of `toggleCompletion` is even simpler: we toggle the value
    of the completed flag that is passed as an argument to the to-do item. Now, we
    are familiar with the basics of the components'' inputs and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Angular, we have the same bubbling behavior we''re used to in the DOM. For
    instance, let''s suppose we have the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of `input-box` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Once the user clicks on the button defined within the template of the `input-box`
    component, the `handleClick($event)` expression will be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the `target` property of the first argument of `handleClick` will be
    the button itself, but the `currentTarget` property will be the `input-box` element.
    The event will bubble the same way if we're not using Angular. At some point,
    it will reach the document unless a handler along the way doesn't stop its propagation.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, if we have a custom `@Output`, the event will not bubble and instead
    of a DOM event, the value of the `$event` variable will be the value that we pass
    to the emit method of the output.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming the inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will explore how we can rename the directives'' inputs and outputs.
    Let''s suppose that we have the following definition of the `TodoList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the component is called `toggle`; the method that handles changes
    in the checkboxes responsible for toggling completion of the individual to-do
    items is also called `toggle`. This code will not be compiled, as in the `TodoList`
    controller we have two identifiers named in the same way. We have two options
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: We can rename the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can rename the property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we rename the property, this will change the name of the component''s output
    as well. So, the following line of code will no longer work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can do instead is rename the `toggle` property and explicitly set the
    name of the output using the `@Output` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This way, we will be able to trigger the `toggle` output using the `toggleEvent`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that such renames could be confusing and are not considered as best practices.
    For a complete set of best practices, visit [https:// angular.io/styleguide](https://angular.io/styleguide)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can rename the component''s inputs using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it doesn''t matter that we renamed the input and output properties of
    `TodoList`; it still has the same public interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: An alternative syntax to define inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@Input` and `@Output` decorators are syntax sugar for easier declaration
    of the directive''s inputs and outputs. The original syntax for this purpose is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `@Input` and `@Output`, the preceding syntax is equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Although both have the same semantics, according to the best practices, we should
    use the latter one, because it is easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Angular's content projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content projection is an important concept when developing user interfaces.
    It allows us to project pieces of content into different places of the user interface
    of our application. Web Components solve this problem with the `content` element.
    In AngularJS, it is implemented with the infamous transclusion.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is inspired by modern Web standards, especially Web Components, which
    led to the adoption of some of the methods of content projection used there. In
    this section, we'll look at them in the context of Angular using the `ng-content`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: Basic content projection in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s suppose we''re building a component called `fancy-button`. This component
    will use the standard HTML button element and add some extra behavior to it. Here
    is the definition of the `fancy-button` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the `@Component` decorator, we set the inline template of the component
    together with its selector. Now, we can use the component with the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: On the screen, we will see a standard HTML button that has a label with the
    content **Click me**. This is not a very flexible way to define reusable UI components.
    Most likely, the users of the fancy button will need to change the content of
    the label to something, depending on their application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In AngularJS, we were able to achieve this result with `ng-transclude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the new Angular, we have the `ng-content` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can pass custom content to the fancy button by executing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As a result, the content between the opening and the closing `fancy-button`
    tags will be placed where the `ng-content` directive resides.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting multiple content chunks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another typical use case of content projection is when we pass content to a
    custom Angular component or AngularJS directive and we want different parts of
    this content to be projected to different locations in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s suppose we have a `panel` component that has a title and
    a body, and we can use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The template of our `panel` component looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In AngularJS 1.5, we are able to do this using multi-slot transclusion, which
    was implemented in order to allow us to have a smoother transition to Angular
    2 and later versions. Let''s take a look at how we can proceed in Angular in order
    to define such a `panel` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We have already described the `selector` and `styles` properties, so let's take
    a look at the component's template. We have a `div` element with the `panel` class,
    which wraps the two nested `div` elements, respectively – one for the title of
    `panel` and one for the content of `panel`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to project the content of the `section` element with class name `panel-title` to
    where the title should be, we will need to use the `ng-content` element. As its
    `selector` attribute, we will need to use a CSS selector, which matches the element
    whose content we want to project (in this case, the selector should be `.panel-title` or
    `section.panel-title`).
  prefs: []
  type: TYPE_NORMAL
- en: In case we set the value of the `selector` attribute to `.panel-title`, it will
    match all the elements with classes `.panel-title`  that reside inside the target
    `panel` element. After this, `ng-content` will grab their content and set them
    as its own content.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already built a few simple applications as a composition of components
    and directives. We saw that components are basically directives with views, so
    we can implement them by nesting or composing other directives and components.
    The following figure illustrates this with a structural diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nesting components](img/B06166_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9
  prefs: []
  type: TYPE_NORMAL
- en: 'The composition could be achieved by nesting directives and components within
    the components'' templates, taking advantage of the nested nature of the used
    markup. For instance, let''s say we have a component with the `sample-component`
    selector, which has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The template of the `Sample` component has a single-child element with the tag
    name `view-child`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we can use the `Sample` component inside the template of
    another component, and since it can be used as an element, we can also nest other
    components or directives inside of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the `sample-component` component has two different types of successors:'
  prefs: []
  type: TYPE_NORMAL
- en: Successors defined within its template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Successors passed as nested elements between its opening and closing tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of Angular, the direct children elements defined within the component's
    template are called **view children** and the ones nested between its opening
    and closing tags are called **content children**.
  prefs: []
  type: TYPE_NORMAL
- en: Using ViewChildren and ContentChildren
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of the `Tabs` component, which uses
    the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding structure is composed of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tab` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TabTitle` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TabContent` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of the `TabTitle` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new in this implementation. We define a `TabTitle` component,
    which has a single property called `tabSelected`. It is of the type `EventEmitter`
    and will be triggered once the user clicks on the tab title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `TabContent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This has an even simpler implementation – all we do is project the DOM passed
    to the `tab-content` element inside `ng-content` and hide it once the value of
    the `isActive` property becomes `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part of the implementation is the `Tabs` component itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this implementation, we have a decorator that we haven''t used yet: the
    `@ContentChildren` decorator. The `@ContentChildren` property decorator fetches
    the content children of the given component. This means that we can get references
    to all `TabTitle` and `TabContent` instances from within the instance of the `Tabs`
    component and get them in the order in which they are declared in the markup.
    There''s an alternative decorator called `@ViewChildren`, which fetches all the
    view children of the given element. Let''s take a look at the difference between
    view children versus content children before we explain the implementation further.'
  prefs: []
  type: TYPE_NORMAL
- en: ViewChild versus ContentChild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although both concepts sound similar, they have quite different semantics.
    In order to understand them better, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve defined two components: `UserBadge` and `UserRating`. Let''s define
    a parent component, which comprises both the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the template of the view of `UserPanel` contains only the `UserBadge`
    component''s selector. Now, let''s use the `UserPanel` component in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The template of our main `App` component uses the `UserPanel` component and
    nests the `UserRating` component inside it. Now, let''s suppose we want to get
    a reference to the instance of the `UserRating` component that is used inside
    the `user-panel` element in the `App`''s template and a reference to the `UserBadge`
    component, which is used inside the `UserPanel`''s template. In order to do this,
    we can add two more properties to the `UserPanel` controller and add the `@ContentChild`
    and `@ViewChild` decorators to them with the appropriate arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The semantics of the `badge` property declaration is "get the instance of the
    first child component of the type `UserBadge`, which is used inside the `UserPanel`
    template". Accordingly, the semantics of the `rating` property's declaration is
    "get the instance of the first child component of the type `UserRating`, which
    is nested inside the `UserPanel` host element".
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run this code, you'll note that the values of the `badge` and `rating`
    properties are still equal to the `undefined` value inside the controller's constructor.
    This is because they are still not initialized in this phase of the component's
    life cycle. The life cycle hooks that we can use in order to get a reference to
    these child components are `ngAfterViewInit` and `ngAfterContentInit`. We can
    use these hooks simply by adding definitions of the `ngAfterViewInit` and `ngAfterContentInit`
    methods to the component's controller. We will make a complete overview of the
    life cycle hooks that Angular provides shortly.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, we can say that the content children of the given components are the
    child elements that are nested within the component's host element. In contrast,
    the view children directives of the given component are the elements used within
    its template.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to get a platform independent reference to a DOM element, again, we
    can use `@ContentChild` and `@ViewChild`. For instance, if we have the following
    template: `<input #todo>` we can get a reference to the `input` by using: `@ViewChild(''todo'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are already familiar with the core differences between view children
    and content children now, we can continue with our tabs implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the tabs component, instead of using the `@ContentChild` decorator, we use
    `@ContentChildren`. We do this because we have multiple content children and we
    want to get them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Another main difference that we will note is that the types of the `tabTitles`
    and `tabContents` properties are `QueryList` with their respective type parameter
    and not the component's type itself. We can think of the `QueryList` data structure
    as a JavaScript array – we can apply the same high-order functions (`map`, `filter`,
    `reduce`, and so on) over it and loop over its elements; however, `QueryList`
    is also observable, that is, we can observe it for changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the final step of our `Tabs` definition, let''s take a peek at the implementation
    of the `ngAfterContentInit` and `select` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the method's implementation, we loop all `tabTitles` and
    take the observable's references. These objects have a method called `subscribe`,
    which accepts a callback as an argument. Once the `.emit()` method of the `EventEmitter`
    instance (that is, the `tabSelected` property of any tab) is called, the callback
    passed to the `subscribe` method will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `select` method''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, since `tabContents` is of the type `QueryList<TabContent>`,
    we get its array representation. After that, we set the `isActive` flag of the
    current active tab to `false` and select the next active one. In the last line
    in the `select` method's implementation, we trigger the selected event of the
    `Tabs` component by invoking `this.tabChanged.emit` with the index of the currently
    selected tab.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into the component's life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components in Angular have a well-defined life cycle, which allows us to hook
    into different phases of it and have further control over our application. We
    can do this by implementing specific methods in the component's controller. In
    order to be more explicit, thanks to the expressiveness of TypeScript, we can
    implement different interfaces associated with the life cycle's phases. Each of
    these interfaces has a single method, which is associated with the phase itself.
  prefs: []
  type: TYPE_NORMAL
- en: Although code written with explicit interface implementation will have better
    semantics, since Angular supports ES5 as well, within the component we can simply
    define methods with the same names as the life cycle hooks (but this time, prefixed
    with `ng`) and take advantage of duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows all the phases we can hook into:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hooking into the component''s life cycle](img/B06166_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the different life cycle hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnChanges`: This hook will be invoked once a change in the input properties
    of a given component is detected. For instance, let''s take a look at the following
    component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the value of the expression associated with the `[title]` attribute is
    changed, the `ngOnChanges` hook will be invoked. We can implement it using this
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet will display all the changed bindings and their old values.
    In order to be more explicit in the implementation of the hook, we can use interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: All the interfaces representing the individual life cycle hooks declare a single
    method with the name of the interface itself prefixed with `ng`. In the upcoming
    list, we'll use the term life cycle hook, both for interface and/or the method,
    except if we won't imply anything specifically for only one of them.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnInit`: This hook will be invoked once the given component is initialized.
    We can implement it using the `OnInit` interface with its `ngOnInit` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoCheck`: This will be invoked when the change detector of the given component
    is invoked. It allows us to implement our own change detection algorithm for the
    given component. Note that `DoCheck` and `OnChanges` should not be implemented
    together on the same directive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDestroy`: If we implement the `OnDestroy` interface with its `ngOnDestroy`
    method, we can hook into the destroy life cycle phase of a component. This method
    will be invoked once the component is detached from the component tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the life cycle hooks associated with the component''s
    content and view children:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AfterContentInit`: If we implement the `ngAfterContentInit` life cycle hook,
    we will be notified when the component''s content is fully initialized. This is
    the phase when the properties decorated with `ContentChild` or `ContentChildren`
    will be initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterContentChecked`: By implementing this hook, we''ll be notified each time
    the content of the given component has been checked by the change detection mechanism
    of Angular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterViewInit`: If we implement this life cycle hook with its `ngAfterViewInit` method,
    we will be notified when the component''s view is initialized. This is the phase
    when the properties decorated with `ViewChild` or `ViewChildren` will be initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AfterViewChecked`: This is similar to `AfterContentChecked`. The `AfterViewChecked`
    hook will be invoked once the view of our component is checked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order of execution of the life cycle hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to trace the order of execution of the callbacks associated with each
    hook, let''s take a peek at the `ch4/ts/life-cycle/app.ts` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `Panel` component implements all the hooks without explicitly implementing
    the interfaces associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the component in the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a panel and a button. Upon each click of the
    button, the panel will be either removed or appended to the view by the `ngIf`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: During the application initialization, if the result of the `"counter % 2 ==
    0"` expression is evaluated to `true`, the `ngOnChanges` method will be invoked.
    This happens because the values of the title and caption properties will be set
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, the `ngOnInit` method will be called, since the component
    has been initialized. Once the component's initialization is completed, the change
    detection will be triggered, which will lead to the invocation of the `ngDoCheck`
    method that allows us to hook custom logic for detecting changes in the state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you are not supposed to implement both `ngDoCheck` and `ngOnChanges`
    methods for the same component, since `ngOnChanges` will keep being called when
    the internal change detector detects changes. The example here does this for learning
    purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: After the `ngDoCheck` method, the change detector will perform a check on the
    component's content (`ngAfterContentInit` and `ngAfterContentChecked` will be
    invoked in this order). Right after this, the same will happen for the component's
    view (`ngAfterViewInit` followed by `ngAfterViewChecked`).
  prefs: []
  type: TYPE_NORMAL
- en: Once the expression of the `ngIf` directive is evaluated to `false`, the entire
    component will be detached from the view, which will lead to the invocation of
    the `ngOnDestroy` hook.
  prefs: []
  type: TYPE_NORMAL
- en: On the next click, if the value of the expression of `ngIf` is equal to `true`,
    the same sequence of calls of the life cycle hooks as the one during the initialization
    phase will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining generic views with TemplateRef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are already familiar with the concepts of inputs, content children, and view
    children, and we also know when we can get a reference to them in the component's
    life cycle. Now, we will combine them and introduce a new concept-`TemplateRef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a step back and take a look at the last to-do application we developed
    earlier in this chapter. In the following screenshot, you can see what its UI
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining generic views with TemplateRef](img/11-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11
  prefs: []
  type: TYPE_NORMAL
- en: If we take a look at its implementation in `ch4/ts/inputs-outputs/app.ts`, we'll
    see that the template used to render the individual to-do items is defined inside
    the template of the entire to-do application.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to use a different layout to render the to-do items? We can
    do this by creating another component called `Todo`, which encapsulates the responsibility
    of rendering them. Then, we can define separate `Todo` components for the different
    layouts we want to support. This way, we need to have *n* different components
    for *n* different layouts, even though we need to change only their templates.
  prefs: []
  type: TYPE_NORMAL
- en: Angular comes with a more elegant solution. Earlier in this chapter, we have
    already discussed the template element. We said that it allows us to define a
    chunk of HTML that will not be processed by the browser. Angular allows us to
    reference such template elements and use them by passing them as content children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can pass the custom layout to our refactored `TodoApp` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In the template, we declare a variable called `todo`. Later in the template,
    we can use it to specify the way in which we want to visualize the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how we can get a reference to this template in the
    controller of the `TodoApp` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: All we do here is define a property called `itemsTemplate` and decorate it with
    the `@ContentChild` decorator. During the component's life cycle (more accurately,
    in `ngAfterContentInit`), the value of `itemsTemplate` will be set to a reference
    of the template that we passed as the content of the `todo-app` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more problem though – we need the template in the `TodoList` component,
    since that''s the place where we render the individual to-do items. What we can
    do is define another input of the `TodoList` component and pass the template directly
    from `TodoApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to pass it as an input from the template of `TodoApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left is to use this template reference in the template of the
    `TodoList` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We have explained the extended syntax of the `ngForOf` directive in the previous
    sections of this chapter. The preceding snippet shows one more property of this
    directive that we can set: the `ngForTemplate` property. By default, the template
    of the `ngForOf` directive is the element it is used on. By specifying a template
    reference to the `ngForTemplate` property, we can use the passed `TemplateRef`
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and enhancing the change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already briefly described the change detection mechanism of the framework.
    We said that compared to AngularJS, where it runs in the context of the "scope",
    in Angular 2 and later versions, it runs in the context of the individual components.
    Another concept we mentioned is the zones, which basically intercept all the asynchronous
    calls that we make using the browser APIs and provide execution context for the
    change detection mechanism of the framework. Zones fix the annoying problem that
    we have in AngularJS, where when we use APIs outside of Angular, we needed to
    explicitly invoke the `digest` loop.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Get Going with Angular"), *Get Going with
    Angular* and [Chapter 2](ch02.html "Chapter 2. The Building Blocks of an Angular
    Application"), *The Building Blocks of an Angular Application*, we discussed that
    the code that performs change detection over our components is being generated,
    either runtime (**Just-in-Time**) or as part of our build process (**Ahead-of-Time**).
    AoT compilation works great for environments with strict **CSP** (**Content-Security-Policy**)
    because of the disabled dynamic evaluation of JavaScript; it also provides much
    better performance since Angular will not have to compile the components' templates.
    We will explain it in detail in [Chapter 8](ch08.html "Chapter 8. Tooling and
    Development Experience"), *Tooling and Development Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore another property of the `@Component` decorator's
    configuration object, which provides us further control over the change detection
    mechanism of the framework by changing its strategy. By explicitly setting the
    strategy, we are able to prevent the change detection mechanism from running over
    a component's subtrees, which in some cases can bring great performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: The order of execution of the change detectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's briefly describe the order in which the change detectors are invoked
    in a given component tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will use the last implementation of the to-do application
    we have, but this time, we''ll extract the logic to render the individual to-do
    items into a separate component called TodoItem. In the following diagram, we
    can see the application''s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The order of execution of the change detectors](img/B06166_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top level is the **TodoApp** component, which has two children: **InputBox**
    and **TodoList**. The **TodoList** component renders the individual to-do items
    using the **TodoItem** components. The implementation details are not important
    for our purpose, so we will ignore them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to realize that there is an implicit dependency between the state
    of the parent component and its children. For instance, the state of the **TodoList**
    component depends completely on the to-do items that are located at its parent:
    the **TodoApp** component. There''s a similar dependency between **TodoItem**
    and **TodoList** since the **TodoList** component passes the individual to-do
    items to a separate instance of the **TodoItem** component. This means that if
    the list of to-do items in **TodoList** changes, this will automatically reflect
    some of the **TodoItem** components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The order of execution of the change detectors](img/B06166_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13
  prefs: []
  type: TYPE_NORMAL
- en: Owing to our last observation, the order of execution of the change detectors
    attached to the individual components is like the one shown in the preceding figure.
    Once the change detection mechanism run, initially it will perform a check over
    the **TodoApp** component. Right after this, the **InputBox** component will be
    checked for changes, followed by the **TodoList** component. In the end, Angular
    will invoke the change detector of the **TodoItem** component.
  prefs: []
  type: TYPE_NORMAL
- en: You can trace the order of execution in the `ch4/ts/change_detection_strategy_order/app.ts`
    example, where each individual component logs a message once its `ngDoCheck` method
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that only the components have an instance of a change detector attached
    to them; directives use the change detector of their parent component.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Angular's change detection strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The change detection strategies that Angular provides are `Default` and `OnPush`.
    We will describe how we can take advantage of `OnPush` in detail, since it is
    very powerful when working with immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s import the TypeScript enum, which can be used to configure the
    strategy used for the individual components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can configure the `TodoList` component to use the `OnPush` strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This way, the change detection will be skipped until the component doesn't receive
    inputs that have different values. Note that comparison uses equality check, which
    means that it'll compare primitive types by their value and objects by comparing
    their references. You can go to `http://localhost:5555/dist/dev/ch4/ts/change_detection_strategy_broken/`
    and see the inconsistent behavior of the `TodoList` component. When you add a
    new to-do item in the input and click on the **Add** button, it won't immediately
    appear in the list.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the change detection will always check for changes.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing immutable data structures and OnPush
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will describe the `OnPush` change detection strategy. It is extremely
    useful when the result that the given component produces depends only on its inputs.
    In such cases, we can pass an immutable data to its inputs in order to make sure
    that it will not be mutated by any component. This way, by having a component
    that depends only on its immutable inputs and doesn't produce any side effects,
    we can make sure that it produces different user interfaces only once it receives
    different inputs (that is, with different reference).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will apply the `OnPush` strategy to the `TodoList` component.
    Since it depends only on its inputs (the `todos` input), we want to make sure
    that its change detection will be performed only once it receives a new reference
    of the `todos` collection.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of an immutable data is that it cannot change. This means that once
    we create the `todos` collection, we cannot change it; instead, the `add` (or,
    in our case, `push`) method will return a new collection-a copy of the initial
    collection with the new item included.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem like a huge overhead-to copy the entire collection on each change.
    In big applications, this may have a big performance impact. However, we don't
    need to copy the entire collection. There are libraries that implement the immutable
    data structure using smarter algorithms, for example, persistent data structures.
    Persistent data structures are out of the scope of the current content. Further
    information about them can be found in most computer science textbooks for advanced
    data structures. The good thing is that we don't have to understand their implementation
    in depth in order to use them. There is a library called *Immutable.js* that implements
    a few commonly used immutable data structures. In our case, we will use the immutable
    list. Generally, the immutable list behaves just like a normal list, but on each
    operation that is supposed to mutate it, it returns a new immutable list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if we have a list called `foo`, which is immutable, and append
    a new item to the list, we will get a new reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In order to take advantage of immutability, we will need to install Immutable.js
    using npm.
  prefs: []
  type: TYPE_NORMAL
- en: The library is already a part of the project that contains the code for the
    book. You can find a reference to Immutable.js in `package.json`, located in the
    root of the project. You can take a look at `ch4/ts/change_detection_strategy/app.ts` to
    see how we include the immutable collections in our TypeScript application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to refactor our to-do application and make it use immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: Using immutable data in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we currently keep the to-do items in the `TodoApp`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We use an array of `Todo` items. The JavaScript array is mutable, which means
    that if we pass it to a component that uses the `OnPush` strategy, it is not safe
    to skip the change detection in case we get the same input reference. For instance,
    we may have two components that use the same list of to-do items. Both components
    can modify the list since it is mutable. This will lead to an inconsistent state
    for any of the components in case their change detection is not performed. That''s
    why we need to make sure that the list that holds the items is immutable. All
    we need to do in the `TodoApp` component in order to make sure that it holds its
    data in an immutable data structure is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we construct the `todos` property as an immutable list, which contains
    immutable objects; all we need to do is to invoke the function `fromJS` exported
    by Immutable.js. It will recursively turn any JavaScript object into an immutable
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, since the mutation operations of the immutable list return a new list,
    we need to make a slight modification in `addTodo` and `toggleTodoCompletion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `addTodo` function looks exactly the same as before, except that we set
    the result of the `push` method as a value to the `todos` property.
  prefs: []
  type: TYPE_NORMAL
- en: In `toggleTodoCompletion`, we use the `update` method of the immutable list.
    As the first argument, we pass the index of the to-do item we want to modify,
    and the second argument is a callback that does the actual modification. Note
    that since we use immutable data in this case, we copy the modified to-do item.
    This is required because it tells the `update` method that the item with the given
    index has been changed (since it is immutable, it is considered as changed only
    when it has a new reference), which means that the entire list has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was the complex part! Now, let''s take a look at the `TodoList` component''s
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to modify the way we access the properties of the immutable
    to-do items inside the templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The change we made here is that instead of using direct property access, such
    as `todo.completed`, we invoke the object's `get` method by passing the property
    the value we want to get as a string, in this case `"completed"`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `@Component` decorator, we set the `changeDetection` property to
    the value of the `OnPush` strategy. This means that the component will run its
    change detector only when any of its inputs gets a new reference. Everything else,
    except the property access, inside of the template of the component stays exactly
    the same since `ngForOf` internally uses ES2015 iterators to loop over the items
    in the provided collection. They are supported by Immutable.js, so no changes
    in the template are required.
  prefs: []
  type: TYPE_NORMAL
- en: Since we need the index of the changed item instead of its reference (the one
    we use in the `update` method of the `todos` collection in `TodoApp`), we change
    the type of the output of the component to `EventEmitter<number>`. In `toggleCompletion`,
    we emit the index of the changed to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we optimized our simple to-do application by preventing the change
    detection mechanism from running in the entire right subtree, in case the parent
    component hasn't pushed an input with a new reference.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we went through the core building blocks of an Angular application:
    directives and components. We built a couple of sample components, which showed
    us the syntax to be used for the definition of these fundamental concepts. We
    also described the life cycle of each directive and the core set of features the
    given directive and component have. As the next step, we saw how we can enhance
    the performance of our application using the `OnPush` change detection strategy
    with an immutable data.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is completely dedicated to the Angular services and the dependency
    injection mechanism of the framework. We will take a look at how we can define
    and instantiate custom injectors and how we can take advantage of the dependency
    injection mechanism in our directives and components.
  prefs: []
  type: TYPE_NORMAL
