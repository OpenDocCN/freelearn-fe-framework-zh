- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Testing RxJS Observables
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试RxJS可观察者
- en: Observables play a central role in managing asynchronous data streams and event-driven
    interactions. By thoroughly testing Observables, developers can verify the correctness
    of their asynchronous code, anticipate and handle various edge cases, and ensure
    consistent behavior across different environments and use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察者在管理异步数据流和事件驱动交互中扮演着核心角色。通过彻底测试可观察者，开发者可以验证其异步代码的正确性，预测并处理各种边缘情况，并确保在不同环境和用例中的一致行为。
- en: The comprehensive testing of Observables not only enhances the robustness of
    applications but also improves code quality, reduces the likelihood of bugs and
    regressions, and ultimately enhances the overall user experience. With rigorous
    testing practices in place, developers can confidently deploy reactive applications
    that meet high standards of reliability, performance, and usability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对可观察者的全面测试不仅增强了应用程序的健壮性，还提高了代码质量，减少了错误和回归的可能性，并最终提升了整体用户体验。有了严格的测试实践，开发者可以自信地部署符合高标准的可靠性、性能和可用性的响应式应用程序。
- en: Many developers consider testing Observables a challenging task. This is true.
    However, if you learn the right techniques, you can implement maintainable and
    readable tests in a very effective manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为测试可观察者是一项具有挑战性的任务。这是真的。然而，如果您掌握了正确的技术，您就可以以非常有效的方式实现可维护和可读的测试。
- en: In this chapter, we will walk you through three commonly used patterns for testing
    streams. We will start by explaining the subscribe and assert pattern, after which
    we will discuss the marble testing pattern. Finally, we will highlight a suitable
    pattern for testing streams that are returned from `HTTPClient` by focusing on
    a concrete example in our recipe app.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍三种常用的测试流模式。我们将首先解释订阅和断言模式，然后讨论弹珠测试模式。最后，我们将通过关注我们的食谱应用中的具体示例，突出一种适合测试由`HTTPClient`返回的流的模式。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Learning about the subscribe and assert pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解订阅和断言模式
- en: Learning about the marble testing pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解弹珠测试模式
- en: Highlighting testing streams using `HTTPClientTestingModule`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HTTPClientTestingModule`突出显示测试流
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter assumes that you have a basic understanding of RxJS and unit testing
    in Angular using Jasmine. Follow this link for more information: [https://angular.dev/guide/testing#set-up-testing](https://angular.dev/guide/testing#set-up-testing).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您对RxJS和Angular中使用Jasmine进行单元测试有基本的了解。有关更多信息，请点击此链接：[https://angular.dev/guide/testing#set-up-testing](https://angular.dev/guide/testing#set-up-testing)。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[angular.dev](http://angular.dev) will be the new documentation site for Angular
    developers; it offers updated features and documentation. [angular.io](http://angular.io)
    will be deprecated in future releases.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[angular.dev](http://angular.dev)将成为Angular开发者的新文档网站；它提供了更新的功能和文档。[angular.io](http://angular.io)将在未来的版本中弃用。'
- en: We will be testing Observables in an Angular context. The source code for this
    chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap13](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap13).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Angular环境中测试可观察者。本章的源代码可在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap13](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap13)找到。
- en: We will be completing a unit test for the `saveRecipe` method, which is available
    under the `RecipesService` class. You can find the complete code in the `recipes.service.spec`
    file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完成对`saveRecipe`方法的单元测试，该方法位于`RecipesService`类下。您可以在`recipes.service.spec`文件中找到完整的代码。
- en: Learning about the subscribe and assert pattern
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解订阅和断言模式
- en: As you will already know, Observables are lazy, and we don’t obtain any value
    until we subscribe to them. In tests, it is the same thing; Observables will not
    emit any value until we subscribe to them. To solve this, programmers always tend
    to subscribe to the Observables manually inside the tests and then perform assertions
    on the emitted values. This is what we call the **subscribe and** **assert** pattern.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，可观察者是懒惰的，我们只有在订阅它们之后才能获得任何值。在测试中，情况也是如此；可观察者不会发出任何值，直到我们订阅它们。为了解决这个问题，程序员总是倾向于在测试中手动订阅可观察者，然后对发出的值进行断言。这就是我们所说的**订阅和断言**模式。
- en: Let’s delve into testing using the subscribe and assert pattern across three
    distinct scenarios. We will demonstrate testing for methods returning a single
    value, methods returning multiple values, and methods returning timed values (values
    returned after a specified time duration).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨使用订阅和断言模式在三个不同场景下的测试。我们将演示测试返回单个值的方法、返回多个值的方法以及返回定时值的方法（在指定时间后返回的值）。
- en: Testing single-value output methods
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试单值输出方法
- en: 'Let’s suppose we have to test a method that returns a single value. The method
    is called `getValue(value: boolean)` and is available in an Angular service called
    `SampleService`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们必须测试一个返回单个值的方法。该方法名为 `getValue(value: boolean)`，并在名为 `SampleService` 的
    Angular 服务中可用。'
- en: 'The method itself is very simple, returning an Observable that will emit the
    Boolean input value as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法本身非常简单，返回一个 Observable，将按照以下方式发出布尔输入值：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The test of this method will look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的测试看起来是这样的：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we start by defining our test suite using the Jasmine `describe()` function.
    The function is used to define a test suite, which is a logical grouping of test
    cases to execute a single task with different test scenarios. It serves as a way
    to organize and structure your tests, making them more readable and maintainable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用 Jasmine 的 `describe()` 函数定义我们的测试套件。该函数用于定义一个测试套件，它是一组逻辑上相关的测试用例，用于执行单个任务的不同测试场景。它作为组织和管理测试的方式，使测试更加可读和可维护。
- en: 'The `describe()` function takes two parameters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()` 函数接受两个参数：'
- en: A string description of the test suite (in the previous code snippet, `SampleService`,
    which is the name of the service that we are going to test and refers to the description
    of our test suite).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试套件的字符串描述（在前面的代码片段中，`SampleService` 是我们要测试的服务名称，它指的是测试套件的描述）。
- en: 'A function that contains the test cases for that suite (in testing frameworks,
    “test case” and “spec” typically refer to a single unit of testing within a test
    suite). Inside this function, we inject `SampleService` into the `beforeEach`
    statement to provide a shared instance of the service that we will be using in
    all the test cases. Finally, we define the test case of our `getValue(value: boolean)`
    method by using the Jasmine function `it()`. The `it()` function takes two parameters:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '包含该套件测试用例的函数（在测试框架中，“测试用例”和“规格”通常指测试套件内的单个测试单元）。在这个函数中，我们将 `SampleService`
    注入到 `beforeEach` 语句中，以提供我们将要在所有测试用例中使用的服务的共享实例。最后，我们使用 Jasmine 的 `it()` 函数定义我们的
    `getValue(value: boolean)` 方法的测试用例。`it()` 函数接受两个参数：'
- en: A string description of the test case (in the previous code snippet, `should
    return true as a value` refers to the description of our test case).
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例的字符串描述（在前面的代码片段中，`should return true as a value` 指的是测试用例的描述）。
- en: A function that contains the test logic. In this function, we subscribe to the
    `getValue(true)` method and expect the result to be equal to `true` since we passed
    the `true` value as input. Expectations are built using the `expect()` Jasmine
    function and are used to assert or verify that certain conditions are met during
    the execution of a test.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含测试逻辑的函数。在这个函数中，我们订阅 `getValue(true)` 方法，并期望结果等于 `true`，因为我们传递了 `true` 作为输入值。期望是通过使用
    Jasmine 的 `expect()` 函数构建的，并在测试执行期间用于断言或验证是否满足某些条件。
- en: 'Now, let’s run `ng test`; the test passes, and everything is fine:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `ng test`；测试通过，一切正常：
- en: '![Figure 13.1 – ng test output](img/B21180_13_1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – ng 测试输出](img/B21180_13_1.jpg)'
- en: Figure 13.1 – ng test output
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – ng 测试输出
- en: Quite simple, right? This is the expected behavior when running a positive scenario.
    A positive scenario typically involves providing input or conditions that align
    with the expected behavior of the code being tested, resulting in successful execution
    without errors or failures.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，对吧？这是运行正面场景时的预期行为。正面场景通常涉及提供与正在测试的代码预期行为一致的输入或条件，从而在没有错误或失败的情况下成功执行。
- en: 'Now, let’s handle a negative scenario by providing input or conditions that
    are intended to trigger failures in the code being tested. To do so, we will replace
    `true` with `false` in the following assertion:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过提供旨在触发正在测试的代码中失败的输入或条件来处理一个负面场景。为此，我们将以下断言中的 `true` 替换为 `false`：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run `ng test` again, our test will fail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行 `ng test` 时，我们的测试将失败。
- en: However, in some cases, the test will still pass. How is this possible?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，测试仍然会通过。这是怎么可能的？
- en: The thing with expectations in testing is that if you have an unmet assertion,
    it throws an error. Plus, if you have an unhandled error inside an RxJS subscription,
    it will be thrown on a separate call stack, meaning that it is asynchronously
    thrown. Therefore, tests that use the subscribe and assert pattern can sometimes
    be green even though, in reality, they are failing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的预期问题是，如果你有一个未满足的断言，它会抛出一个错误。此外，如果你在RxJS订阅中有一个未处理的错误，它将在另一个调用堆栈上抛出，这意味着它是异步抛出的。因此，使用订阅和断言模式的测试有时可能会显示为绿色，尽管实际上它们是失败的。
- en: 'To overcome this, we should pass a `done` callback to the test function and
    call it manually after our expectations for when the test has been completed,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们应该向测试函数传递一个`done`回调，并在测试完成后的预期时间手动调用它，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `done` callback is a mechanism used in asynchronous testing to signal the
    completion of a test case to the testing framework. It is supported by many testing
    frameworks, such as Jasmine, Jest, and Mocha. Calling the `done` callback ensures
    that the test doesn’t finish prematurely before all asynchronous tasks have been
    executed and assertions have been verified. Therefore, we prevent false positives
    and ensure that our tests accurately reflect the behavior of the code being tested,
    particularly in asynchronous scenarios. So, don’t forget to call the `done` callback
    in asynchronous scenarios!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`done`回调是在异步测试中用于向测试框架发出测试用例完成信号的一种机制。它被许多测试框架支持，如Jasmine、Jest和Mocha。调用`done`回调确保在所有异步任务执行和断言验证之前，测试不会提前完成。因此，我们防止了假阳性，并确保我们的测试准确地反映了被测试代码的行为，尤其是在异步场景中。所以，不要忘记在异步场景中调用`done`回调！'
- en: Now, let’s consider a more complicated method that will return multiple values
    instead of one value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个更复杂的方法，该方法将返回多个值而不是一个值。
- en: Testing multiple-value output methods
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试多值输出方法
- en: 'Let’s consider a method called `getValues`, which will return multiple values
    like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个名为`getValues`的方法，它将返回多个值，如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The values will be emitted one by one in the aforementioned order.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 值将按照上述顺序逐个发出。
- en: 'When using the assert and subscribe pattern, the test will look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用断言和订阅模式时，测试将看起来像这样：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we created an array that represents the expected values
    in order; then, we subscribed to the `getValues` method and compared the emitted
    values with the expected value using a counter (`expectedValues[index]`). After
    finishing, we called the `done()` callback.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个数组，表示预期的值顺序；然后，我们订阅了`getValues`方法，并使用计数器（`expectedValues[index]`）将发出的值与预期值进行比较。完成后，我们调用了`done()`回调。
- en: 'However, instead of the counter, we can use the `toArray` operator of RxJS,
    which will put the values that have been emitted in an array and then compare
    the resulting array with the expected array we defined:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用RxJS的`toArray`操作符而不是计数器，它将发出的值放入一个数组中，然后比较得到的数组与我们定义的预期数组：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Well, this is working fine, and `ng test` will pass. However, in both cases,
    even though we are dealing with a simple stream, we were forced to add some logic;
    in the first example, we added a counter, while in the second example, we used
    the `toArray` operator. This boils down the tests and adds some unnecessary testing
    logic; these are the most significant drawbacks of the subscribe and assert pattern.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这工作得很好，`ng test`将会通过。然而，在这两种情况下，尽管我们处理的是一个简单的流，但我们被迫添加一些逻辑；在第一个例子中，我们添加了一个计数器，而在第二个例子中，我们使用了`toArray`操作符。这简化了测试并添加了一些不必要的测试逻辑；这些都是订阅和断言模式的最显著缺点。
- en: Now, let’s move on to a different example and explore testing methods that output
    timed values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向一个不同的例子，并探索输出定时值的测试方法。
- en: Testing timed-value output methods
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试定时值输出方法
- en: 'Let’s update the method `getValues()` and add a timer to return the values
    after a specific duration as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`getValues()`方法，并添加一个计时器，在特定持续时间后返回值，如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we used the RxJS `timer` in this method to emit a value every 5 seconds.
    Since `timer` produces an endless stream, we call the `take` operator to return
    the first three emissions and complete them. Then, for every emission, we use
    the `switchMap` operator to return an Observable that emits three values consecutively.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们在该方法中使用了RxJS的`timer`，每5秒发出一个值。由于`timer`产生一个无止境的流，我们调用`take`操作符来返回前三个发出值并完成它们。然后，对于每个发出值，我们使用`switchMap`操作符返回一个连续发出三个值的Observable。
- en: This is tricky, right? If we use the subscribe and assert pattern here, the
    tests would be very complicated and may take a lot of time, depending on the value
    that’s passed to `timer`. However, the unit tests should be fast and reliable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棘手，对吧？如果我们在这里使用subscribe和assert模式，测试将会非常复杂，并且可能需要很多时间，这取决于传递给`timer`的值。然而，单元测试应该是快速且可靠的。
- en: In this case, having a virtual timer can be beneficial. A virtual timer refers
    to a simulated passage of time controlled by the testing framework. Instead of
    waiting for actual time to pass, which could lead to slow and unreliable tests,
    the virtual timer allows testers to control time programmatically. This means
    they can advance time forward or backward as needed to trigger certain events
    or test scenarios, making it easier to write reliable and deterministic tests
    for code that depends on time-based behavior. This approach ensures that tests
    are fast, predictable, and independent of real-time conditions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，拥有一个虚拟计时器可能会有所帮助。虚拟计时器指的是由测试框架控制的模拟时间流逝。我们不需要等待实际时间的流逝，这可能导致测试缓慢且不可靠，虚拟计时器允许测试人员以编程方式控制时间。这意味着他们可以根据需要向前或向后推进时间，以触发某些事件或测试场景，这使得为依赖于基于时间的行为的代码编写可靠且确定性的测试变得更容易。这种方法确保测试快速、可预测，并且独立于实时条件。
- en: 'So, in a nutshell, the subscribe and assert pattern is a valid and easy technique
    that most developers adopt. However, it has some drawbacks that I pointed out
    throughout this section:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，subscribe和assert模式是一种有效且易于采用的技术，大多数开发者都会采用。然而，它也有一些我在本节中指出的缺点：
- en: We need to remember to call the `done` callback in asynchronous tests; otherwise,
    the tests will return invalid results.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要记住在异步测试中调用`done`回调；否则，测试将返回无效的结果。
- en: In some scenarios, we end up with boiled tests and unwanted testing logic.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会遇到过度的测试和不需要的测试逻辑。
- en: Timed Observables are very complicated to test.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时观察者非常难以测试。
- en: 'Now, let’s explore another approach for testing Observables: marble testing
    with RxJS testing utilities.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索另一种测试可观察者的方法：使用RxJS测试工具的弹珠测试。
- en: Learning about the marble testing pattern
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解弹珠测试模式
- en: Marble diagrams are very useful for visualizing Observable execution. You will
    already know this, as we introduced marble diagrams back in [*Chapter 1*](B21180_01.xhtml#_idTextAnchor016),
    *Diving into the Reactive Paradigm*, and we’ve used them in almost all the reactive
    patterns we’ve implemented in this book. They are simple to understand and delightful
    to read. So, why not also use them in code? What you will be surprised to know
    is that RxJS introduced marble testing as an intuitive and clean way to test Observables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 弹珠图对于可视化可观察者执行非常有用。您已经知道了这一点，因为我们早在[*第一章*](B21180_01.xhtml#_idTextAnchor016)中介绍了弹珠图，*深入响应式范式*，并且我们在本书中实现的几乎所有响应式模式中都用到了它们。它们易于理解，阅读起来令人愉悦。那么，为什么不在代码中也使用它们呢？您可能会惊讶地知道，RxJS引入了弹珠测试作为一种直观且干净的测试可观察者的方式。
- en: Let’s discover what marble testing is about. We will start by explaining the
    syntax in the next section and then learn how we can write marble tests in our
    code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先解释下一节中的语法，然后学习我们如何在代码中编写弹珠测试。
- en: Understanding the syntax
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解语法
- en: 'To understand the syntax, we should know about the following semantics:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解语法，我们应该了解以下语义：
- en: '| **Character** | **Meaning** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | **含义** |'
- en: '| `'' ''` | This represents a special character that will not be interpreted.
    It can be used to align your marble string. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `'' ''` | 这代表一个特殊字符，它不会被解释。它可以用来对齐您的弹珠字符串。|'
- en: '| `''-''` | This represents a frame of virtual time passing. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `''-''` | 这代表虚拟时间的流逝帧。|'
- en: '| `''&#124;''` | This represents the completion of an Observable. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `''&#124;''` | 这代表了一个可观察对象的完成。|'
- en: '| `[``a-z]` | This represents a value that is emitted by an Observable. It
    is an alphanumeric character. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `[``a-z]` | 这代表由可观察者发出的值。它是一个字母数字字符。|'
- en: '| `''#''` | This represents an error. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `''#''` | 这代表了一个错误。|'
- en: '| `''()''` | This represents a group of events that occur in the same frame.
    It can be used to group any values emitted, errors, and completion. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `''()''` | 这代表在同一帧中发生的事件组。它可以用来组合任何发出的值、错误和完成。|'
- en: '| `''^''` | This represents the subscription point and will only be used when
    you’re dealing with hot Observables. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `''^''` | 这代表订阅点，并且仅在您处理热可观察者时使用。|'
- en: '| `[``0-9]+[ms&#124;s&#124;m]` | This represents time progression and allows
    you to progress virtual time by a specific amount. It’s a number, followed by
    a time unit in **milliseconds** (**ms**), **seconds** (**s**), or **minutes**
    (**m**) without any space between them. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `[``0-9]+[ms&#124;s&#124;m]` | 这代表时间进度，并允许你通过特定数量推进虚拟时间。它是一个数字，后面跟着一个时间单位，以
    **毫秒**（**ms**）、**秒**（**s**）或 **分钟**（**m**）表示，它们之间没有空格。|'
- en: Figure 13.2 – Marble testing syntax
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 宝石测试语法
- en: 'This is the basic syntax. Let’s look at some examples to practice the syntax:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基本语法。让我们看看一些例子来练习语法：
- en: '`---`: This represents an Observable that never emits.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`---`: 这代表一个永远不会发出的可观察对象。'
- en: '`-x--y--z|`: This represents an Observable that emits `x` on the first frame,
    `y` on the fourth, and `z` on the seventh. After emitting `z`, the Observable
    completes.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x--y--z|`: 这代表一个在第一帧发出 `x`，在第四帧发出 `y`，在第七帧发出 `z` 的可观察对象。在发出 `z` 之后，可观察对象完成。'
- en: '`--xy--#`: This represents an Observable that emits `x` on frame two, `y` on
    frame three, and an error on frame six.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--xy--#`: 这代表一个可观察对象，在第二帧发出 `x`，在第三帧发出 `y`，并在第六帧发出错误。'
- en: '`-x^(yz)--|`: This is a hot Observable that emits `x` before the subscription.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x^(yz)--|`: 这是一个在订阅之前发出 `x` 的热可观察对象。'
- en: You’ve got the idea, right? Now, let’s learn how to implement marble tests in
    our code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经明白了，现在让我们学习如何在我们的代码中实现宝石测试。
- en: Introducing TestScheduler
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 TestScheduler
- en: 'There are different packages out there that can help you write marble tests,
    including `jasmine-marbles`, `jest-marbles`, and `rxjs-marbles`. However, RxJS
    provides testing utilities out of the box, and all the libraries are just wrappers
    around the RxJS testing utilities. I recommend working with the RxJS utilities
    for the following reasons:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的包可以帮助你编写宝石测试，包括 `jasmine-marbles`、`jest-marbles` 和 `rxjs-marbles`。然而，RxJS
    提供了开箱即用的测试实用工具，所有库都是围绕 RxJS 测试实用工具的包装。我建议使用 RxJS 实用工具，以下是一些原因：
- en: You don’t have to include a third-party dependency
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要包含第三方依赖项
- en: You stay up to date with the core implementation
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以保持核心实现的最新状态
- en: You stay up to date with the latest features
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以保持对最新功能的了解
- en: The RxJS API that’s provided for testing is based on `TestScheduler`. This API
    allows you to test time-dependent RxJS code in a controlled and deterministic
    manner, which is crucial for writing reliable and predictable tests for Observables
    with time-based operators.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的 RxJS API 用于测试是基于 `TestScheduler` 的。这个 API 允许你以可控和确定性的方式测试基于时间的 RxJS 代码，这对于编写基于时间操作符的可靠和可预测的可观察对象测试至关重要。
- en: 'To define our test logic, the `TestScheduler` API provides a `run` method that
    has the following signature:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义我们的测试逻辑，`TestScheduler` API 提供了一个具有以下签名的 `run` 方法：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `run` method takes a `callback` function as an argument. This `callback`
    function is where you define your test logic, including setting up Observables,
    defining expectations, and making assertions. The `callback` function takes one
    argument named `helpers` of type `RunHelpers`, which provides various utility
    functions and properties to assist you in writing marble tests for Observables.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 方法接受一个 `callback` 函数作为参数。这个 `callback` 函数是你定义测试逻辑的地方，包括设置可观察对象、定义期望和进行断言。`callback`
    函数接受一个名为 `helpers` 的参数，其类型为 `RunHelpers`，它提供了各种实用函数和属性，以帮助你编写可观察对象的宝石测试。'
- en: 'The `RunHelpers` interface contains the following properties:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`RunHelpers` 接口包含以下属性：'
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s look at these properties one by one:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些属性：
- en: '`cold`: This produces a cold Observable based on a given marble diagram. Here
    is the signature of the method:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cold`: 这根据给定的宝石图产生一个冷可观察对象。以下是该方法的签名：'
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`hot`: This produces a hot Observable based on a given marble diagram. Here
    is the signature of the method:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hot`: 这根据给定的宝石图产生一个热可观察对象。以下是该方法的签名：'
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you’re creating a hot Observable, you can use `^` to point out the first
    frame:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你创建一个热可观察对象时，可以使用 `^` 来指出第一帧：
- en: '`flush`: This starts virtual time. It’s only needed if you use helpers outside
    the `run` callback or if you want to use `flush` more than once.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flush`: 这开始虚拟时间。只有在你在 `run` 回调之外使用辅助工具或想要多次使用 `flush` 时才需要。'
- en: '`expectObservable`: This asserts that an Observable matches a marble diagram.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectObservable`: 这断言一个可观察对象与宝石图匹配。'
- en: '`expectSubscriptions`: This asserts that an Observable matches the expected
    subscriptions.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectSubscriptions`: 这断言一个可观察对象与预期的订阅匹配。'
- en: Now, let’s learn how we can implement marble testing using `TestScheduler` in
    the following section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用 `TestScheduler` 在下一节中实现弹珠测试。
- en: Implementing marble tests
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现弹珠测试
- en: 'In this section, we will consider implementing marble tests for the `getValues`
    method previously mentioned in the subscribe and assert pattern:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑实现之前在订阅和断言模式中提到的 `getValues` 方法的弹珠测试：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The steps for writing the marble testing implementation pattern are simple:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编写弹珠测试实现模式的步骤很简单：
- en: 'Import `TestScheduler` from `rxjs/testing`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `rxjs/testing` 中导入 `TestScheduler`：
- en: '[PRE13]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `beforeEach` statement, inject `SampleService`. Then, instantiate `TestScheduler`
    and pass an input function that compares the actual output with the expected output
    of the Observable:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `beforeEach` 语句中，注入 `SampleService`。然后，实例化 `TestScheduler` 并传递一个输入函数，该函数比较实际输出与
    Observable 的预期输出：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the expected output and actual output are not equal, it throws an error,
    failing the test.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果预期输出和实际输出不相等，它会抛出一个错误，导致测试失败。
- en: 'Use `TestScheduler` to test your stream by calling the `run` method and passing
    a callback to it (remember that the callback needs to accept `RunHelpers` as the
    first parameter):'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `TestScheduler` 通过调用 `run` 方法并传递一个回调来测试你的流（记住，回调需要接受 `RunHelpers` 作为第一个参数）：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is also useful to destruct the helpers into variables and use them directly
    to implement the marble tests. We will be destructuring the `expectObservable`
    variable, as we will use it to assert that the Observable matches the marble diagram,
    as follows:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将辅助函数解构到变量中并直接使用它们来实现弹珠测试也是有用的。我们将解构 `expectObservable` 变量，因为我们将会使用它来断言 Observable
    是否与弹珠图匹配，如下所示：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, declare the expected marble and values and perform the expectation:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，声明预期的弹珠和值，并执行期望：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `expectedMarble` constant represents the marble diagram. Since the `getValues`
    method returns three values consecutively, we used parentheses to group the `a`,
    `b`, and `c` emissions. The stream then completes, so we use the `|` character.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`expectedMarble` 常量代表弹珠图。由于 `getValues` 方法连续返回三个值，我们使用了括号来分组 `a`、`b` 和 `c`
    的发射。然后流完成，所以我们使用 `|` 字符。'
- en: The `expectedValues` constant represents the values of the `a`, `b`, and `c`
    characters that we put in `expectedMarble`. It represents `'Hello'`, `'Packt'`,
    and `'Readers'`, consecutively, which are nothing but the values that are emitted
    by the Observable that we want to test.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`expectedValues` 常量代表我们放入 `expectedMarble` 中的 `a`、`b` 和 `c` 字符的值。它代表 `''Hello''`、`''Packt''`
    和 `''Readers''`，连续的，这不过是我们要测试的 Observable 发射的值。'
- en: The last instruction is the expectation; we should provide the expected result
    that our methods should return. Here, we must use `expectObservable`, which takes
    the Observable we want to test as a parameter and matches it with `expectedMarble`
    and `expectedValues`.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一条指令是期望；我们应该提供我们的方法应该返回的预期结果。在这里，我们必须使用 `expectObservable`，它接受我们想要测试的 Observable
    作为参数，并将其与 `expectedMarble` 和 `expectedValues` 匹配。
- en: 'That’s it. Let’s have a look at the complete test setup:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。让我们看看完整的测试设置：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run `ng test`, this test will pass. If you enter wrong values in `expectedValues`,
    the test will fail:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `ng test` 时，这个测试将会通过。如果你在 `expectedValues` 中输入错误值，测试将会失败：
- en: '![Figure 13.3 – ng test failing](img/B21180_13_2.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – ng test 失败](img/B21180_13_2.jpg)'
- en: Figure 13.3 – ng test failing
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – ng test 失败
- en: Well, this is cleaner than the subscribe and assert pattern implementation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这比订阅和断言模式实现要干净。
- en: Now, let’s look at a more difficult example and see how we can implement it
    using marble testing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个更复杂的例子，看看我们如何使用弹珠测试来实现它。
- en: Testing timed-value output methods
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试定时值输出方法
- en: 'We will consider the testing of a timed Observable that was complicated to
    implement using the subscribe and assert pattern. Let’s revisit the timer example
    that we explained earlier in the subscribe and assert pattern section:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑测试一个使用订阅和断言模式实现起来复杂的定时 Observable。让我们回顾一下我们在订阅和断言模式部分中解释过的定时器示例：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The cool `TestScheduler` feature that can help us here is **virtual time**;
    this allows us to test asynchronous streams synchronously by virtualizing time
    and ensuring that the correct items are emitted at the correct time. Thanks to
    the time progression syntax, we can advance virtual time by milliseconds (ms),
    seconds (s), or even minutes (m). This is extremely useful in the case of timed
    Observables.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里能帮到我们的酷炫功能是**虚拟时间**；这允许我们通过虚拟化时间来同步测试异步流，并确保正确的时间发出正确的内容。多亏了时间进度语法，我们可以以毫秒（ms）、秒（s）甚至分钟（m）为单位推进虚拟时间。这在测试定时Observables的情况下非常有用。
- en: 'Let’s consider the following marble diagram:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下大理石图：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the diagram indicates that `e` is emitted immediately. Then, after 1 second,
    `f` and `g` are emitted. Then, 1 second later, `h` is emitted, after which `I`
    is emitted, and the stream finally completes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，图表明`e`立即发出。然后，1秒后，`f`和`g`发出。然后，1秒后，`h`发出，之后`I`发出，流最终完成。
- en: Why use `999` and `996`? Well, we’re using `999` because `e` takes 1 ms to emit
    and `996` because the characters in the `(fg)` group take 1 ms each.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用`999`和`996`？嗯，我们使用`999`是因为`e`发出需要1毫秒，而`996`是因为`(fg)`组中的字符每个需要1毫秒。
- en: 'With all this in mind, the marble tests of `getValues` will look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，`getValues`的大理石测试将看起来像这样：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The group of values `(abc)` is emitted every 5 seconds or 5000 ms, and since
    the characters are counted inside the group, we put `4995ms`. So, the whole test
    case will look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值组`(abc)`每5秒或5000毫秒发出一次，由于字符在组内计数，所以我们放置`4995ms`。因此，整个测试用例将看起来像这样：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s how we resolved the test of a timed Observable using marble tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何通过大理石测试解决了定时Observables的测试。
- en: Marble testing is extremely powerful and helpful. It allows you to test a very
    high level of detail and complicated things such as concurrency and timed Observables.
    It also makes your tests cleaner. However, it requires you to learn a new syntax,
    and it is not recommended for testing business logic. Marble testing was designed
    for testing operators with arbitrary time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大理石测试非常强大且有用。它允许您测试非常详细和复杂的事情，如并发和定时Observables。它还使您的测试更加简洁。然而，它要求您学习一种新的语法，并且不建议用于测试业务逻辑。大理石测试是为测试具有任意时间的操作符而设计的。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about marble testing, you can check out the official docs at
    [https://rxjs.dev/guide/testing/marble-testing](https://rxjs.dev/guide/testing/marble-testing).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于大理石测试的更多细节，您可以在[https://rxjs.dev/guide/testing/marble-testing](https://rxjs.dev/guide/testing/marble-testing)的官方文档中查看。
- en: Now, let’s highlight a very common pattern for testing business logic.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们突出一个用于测试业务逻辑的非常常见的模式。
- en: Highlighting testing streams using HttpClientTestingModule
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HttpClientTestingModule突出测试流
- en: Observables that are returned from the HTTP client are frequently used in our
    Angular code, but how can we test those streams? Let’s look at the pattern we
    can use to test those Observables. We will be shifting our focus away from general
    testing practices and narrowing our attention specifically to testing our recipe
    app.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从HTTP客户端返回的Observables在我们的Angular代码中经常被使用，但我们是怎样测试这些流的呢？让我们看看我们可以用来测试这些Observables的模式。我们将把我们的重点从一般测试实践转移到具体测试我们的食谱应用。
- en: 'Consider the following method inside `RecipeService`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`RecipeService`中的方法：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `saveRecipe` method issues an HTTP request and returns an Observable of
    recipe. In order to test the output Observable, there is a very useful API that
    can be used: `HttpClientTestingModule`. This API allows us to test HTTP methods
    that use the HTTP client. It also allows us to easily mock HTTP requests by providing
    the `HttpTestingController` service. In short, it enables us to mock requests
    instead of making real API requests to our API backend when testing.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveRecipe`方法发出一个HTTP请求并返回一个食谱的Observable。为了测试输出Observable，有一个非常有用的API可以用来：`HttpClientTestingModule`。此API允许我们测试使用HTTP客户端的HTTP方法。它还允许我们通过提供`HttpTestingController`服务来轻松模拟HTTP请求。简而言之，它使我们能够在测试时模拟请求，而不是向我们的API后端发出真实的API请求。'
- en: 'Let’s see the steps required to test the `saveRecipe` method using the `HttpClientTestingModule`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`HttpClientTestingModule`测试`saveRecipe`方法所需的步骤：
- en: 'Before you can use `HttpClientTestingModule`, import and inject it in your
    `TestBed` in the `beforeEach` statement, as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您可以使用`HttpClientTestingModule`之前，请在`beforeEach`语句中导入并注入它到您的`TestBed`中，如下所示：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, import and inject `HttpTestingController` and `RecipesService` and provide
    a shared instance of each to use in our tests:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导入并注入 `HttpTestingController` 和 `RecipesService`，并为每个测试提供一个共享实例：
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, implement the test case of saving the recipe. We’ll mock `saveRecipe`
    as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现保存菜谱的测试用例。我们将按照以下方式模拟 `saveRecipe`：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we created a constant called `recipeToSave`, which represents a mocked
    recipe that we will post to the server to be saved. Then, we subscribed to the
    `saveRecipe` method and passed `recipeToSave` to it as a parameter. Inside the
    subscription, we defined our expectations. Then, we called the `expectOne` method,
    which expects a single request that’s been made to match a given URL (in our case,
    `/api/recipes`) and returns mock data using the `flush` method, which resolves
    the request by returning a mocked body. Finally, we released the subscription.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `recipeToSave` 的常量，它代表我们将要发送到服务器保存的模拟菜谱。然后，我们订阅了 `saveRecipe`
    方法，并将 `recipeToSave` 作为参数传递给它。在订阅内部，我们定义了我们的期望。然后，我们调用了 `expectOne` 方法，它期望一个已发送到匹配给定
    URL（在我们的情况下，是 `/api/recipes`）的单个请求，并使用 `flush` 方法返回模拟数据，该方法通过返回模拟体来解析请求。最后，我们释放了订阅。
- en: 'The last step is to add an `afterEach()` block, in which we run the `verify`
    method of our controller:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是添加一个 `afterEach()` 块，在其中运行我们控制器的 `verify` 方法：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `verify()` method ensures that there are no outstanding HTTP requests that
    have not been handled or flushed. When you make HTTP requests in your tests using
    `HttpClientTestingModule`, they are intercepted by `httpTestingController` instead
    of being sent over the network. The `verify()` method ensures that all requests
    have been properly handled and allows your tests to pass only if there are no
    pending requests remaining.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`verify()` 方法确保没有未处理的 HTTP 请求未被处理或刷新。当您在测试中使用 `HttpClientTestingModule` 发送
    HTTP 请求时，它们会被 `httpTestingController` 截获，而不是通过网络发送。`verify()` 方法确保所有请求都得到了适当的处理，并且只有当没有挂起的请求时，测试才能通过。'
- en: In summary, the `afterEach()` block with `httpTestingController.verify()` is
    used in Angular tests to clean up and verify that there are no unhandled HTTP
    requests left over after each test case. This helps ensure that your tests are
    isolated and reliable, without unexpected network interactions.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结来说，在 Angular 测试中使用 `afterEach()` 块和 `httpTestingController.verify()` 来清理并验证在每个测试用例之后没有未处理的
    HTTP 请求留下。这有助于确保您的测试是隔离和可靠的，没有意外的网络交互。
- en: And that’s it; the pattern for testing methods that issue HTTP requests is complete.
    Just run the `ng test` command and ensure everything works fine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，测试发出 HTTP 请求的方法的模式就完成了。只需运行 `ng test` 命令并确保一切正常。
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`HttpClientTestingModule` is very useful in this use case. For more details,
    please refer to [https://angular.dev/guide/testing/services#httpclienttestingmodule](https://angular.dev/guide/testing/services#httpclienttestingmodule).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientTestingModule` 在这个用例中非常有用。有关更多详细信息，请参阅 [https://angular.dev/guide/testing/services#httpclienttestingmodule](https://angular.dev/guide/testing/services#httpclienttestingmodule)。'
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I’ve elucidated three common approaches for testing Observables
    in RxJS and Angular. Each solution has its strengths and weaknesses, and there
    is no one-size-fits-all answer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我阐述了在 RxJS 和 Angular 中测试可观察对象的三种常见方法。每种解决方案都有其优点和缺点，并没有一种适合所有情况的答案。
- en: First, we learned about the subscribe and assert pattern, as well as its advantages
    and drawbacks. This pattern is straightforward to understand but may not cover
    all edge cases, especially when dealing with complex asynchronous behavior.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们学习了订阅和断言模式，以及它的优点和缺点。这种模式易于理解，但可能无法涵盖所有边缘情况，尤其是在处理复杂的异步行为时。
- en: Then, we learned about the marble testing pattern and its syntax, features,
    advantages, and drawbacks. We studied a basic example and an example that uses
    virtual time to test timed Observables. Marble testing provides a visual representation
    of Observable behavior; it is suitable for testing complex asynchronous scenarios.
    However, it requires special syntax, meaning it may have a steep learning curve
    for beginners.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了宝石测试模式及其语法、特性、优点和缺点。我们研究了一个基本示例和一个使用虚拟时间来测试定时可观察对象的示例。宝石测试提供了可观察对象行为的可视化表示；它适用于测试复杂的异步场景。然而，它需要特殊的语法，这意味着对于初学者来说可能有一个陡峭的学习曲线。
- en: Finally, we learned about a pattern that we can use to test streams that are
    returned from the HTTP client. This pattern provides control over responses and
    doesn’t rely on external APIs. However, it can be tedious to set up and maintain
    and may not accurately simulate real-world network behavior in some cases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了一种可以用来测试从HTTP客户端返回的流的模式。这个模式可以控制响应，并且不依赖于外部API。然而，设置和维护它可能很繁琐，并且在某些情况下可能无法准确模拟现实世界的网络行为。
- en: In conclusion, each testing approach offers its advantages and trade-offs. Depending
    on your project requirements, you can choose the solution that aligns best with
    your testing needs and project constraints.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，每种测试方法都提供了其优势和权衡。根据您的项目需求，您可以选择最适合您测试需求和项目约束的解决方案。
- en: At this point, our journey into reactive patterns is coming to an end. In this
    book, I tried to highlight the most used reactive patterns that solve a lot of
    recurrent use cases in web applications. You can use them immediately in your
    current projects, adapt them to your needs, or get inspired to create your own
    reactive pattern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对反应式模式的探索即将结束。在这本书中，我试图突出最常用的反应式模式，这些模式解决了许多在Web应用程序中反复出现的用例。您可以直接在当前项目中使用它们，根据您的需求进行修改，或者从中获得灵感来创建您自己的反应式模式。
- en: This book is not just about patterns, though; it is also about the reactive
    approach and how to switch your mindset from imperative to reactive thinking;
    in most chapters, this is why I’ve highlighted the classic pattern before the
    reactive one to provide you with a smooth transition between the two.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书不仅仅关于模式；它还涉及反应式方法以及如何将你的思维方式从命令式转变为反应式思考；在大多数章节中，这就是为什么我在反应式模式之前先强调经典模式，以便您在这两种模式之间有一个平滑的过渡。
- en: And with that, we reach the end of our journey together. Thank you for reading
    and embarking on this reactive adventure with me!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的共同之旅到达了终点。感谢您阅读并与我一起踏上这场反应式冒险之旅！
