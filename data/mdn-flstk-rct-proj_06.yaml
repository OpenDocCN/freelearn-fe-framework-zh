- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Integrating a Frontend Using React and TanStack Query
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 和 TanStack Query 集成前端
- en: After designing, implementing, and testing our backend service, it’s now time
    to create a frontend to interface with the backend. First, we will start by setting
    up a full-stack React project based on the Vite boilerplate and the backend service
    created in the previous chapters. Then, we are going to create a basic user interface
    for our blog application. Finally, we will use TanStack Query, a data fetching
    library to handle backend state, to integrate the backend API into the frontend.
    By the end of this chapter, we will have successfully developed our first full-stack
    application!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计、实现和测试我们的后端服务之后，现在是时候创建一个前端来与后端接口了。首先，我们将基于 Vite 模板和前几章创建的后端服务设置一个全栈 React
    项目。然后，我们将为我们的博客应用程序创建一个基本用户界面。最后，我们将使用 TanStack Query，一个数据获取库来处理后端状态，将后端 API 集成到前端。到本章结束时，我们将成功开发我们的第一个全栈应用程序！
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Principles of React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 原则
- en: Setting up a full-stack React project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置全栈 React 项目
- en: Creating the user interface for our application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建用户界面
- en: Integrating the backend service using TanStack Query
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TanStack Query 集成后端服务
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请安装 [*第 1 章*](B19385_01.xhtml#_idTextAnchor016) 中提到的 *全栈开发准备* 和 [*第
    2 章*](B19385_02.xhtml#_idTextAnchor028) 中提到的 *了解 Node.js* 和 *MongoDB* 的所有要求。
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)
    and *2*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是本书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在这本书提供的代码和步骤中遇到问题，请尝试使用
    [*第 1 章*](B19385_01.xhtml#_idTextAnchor016) 和 *2* 中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch4](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch4)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch4](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch4)
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您克隆了本书的完整仓库，在运行 `npm install` 时，Husky 可能找不到 `.git` 目录。在这种情况下，只需在相应章节文件夹的根目录下运行
    `git init`。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/WXqJu2Ut7Hs](https://youtu.be/WXqJu2Ut7Hs)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可在：[https://youtu.be/WXqJu2Ut7Hs](https://youtu.be/WXqJu2Ut7Hs) 找到
- en: Principles of React
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 原则
- en: 'Before we start learning how to set up a full-stack React project, let’s revisit
    the three fundamental principles of React. These principles allow us to easily
    write scalable web applications:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习如何设置全栈 React 项目之前，让我们回顾 React 的三个基本原则。这些原则使我们能够轻松编写可扩展的 Web 应用程序：
- en: '**Declarative**: Instead of telling React how to do things, we tell it what
    we want it to do. As a result, we can easily design our applications and React
    will efficiently update and render just the right components when the data changes.
    For example, the following code, which duplicates strings in an array is imperative,
    which is the opposite of declarative:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式**：不是告诉 React 如何做事，而是告诉它我们想要它做什么。因此，我们可以轻松地设计我们的应用程序，当数据发生变化时，React 将高效地更新和渲染正确的组件。例如，以下代码，它将数组中的字符串重复，是命令式的，与声明式相反：'
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, in imperative code, we need to tell JavaScript exactly what
    to do, step by step. However, with declarative code, we can simply tell the computer
    what we want, as follows:'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，在命令式代码中，我们需要逐步告诉 JavaScript 应该做什么。然而，在声明式代码中，我们只需简单地告诉计算机我们想要什么，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this declarative code, we tell the computer that we want to map each element
    of the `input` array from `str` to `str + str`. As you can see, declarative code
    is much more concise.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个声明式代码中，我们告诉计算机我们想要将 `input` 数组中的每个 `str` 元素映射到 `str + str`。如您所见，声明式代码要简洁得多。
- en: '**Component-based**: React encapsulates components that manage their own state
    and views and then allows us to compose them in order to create complex user interfaces.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于组件的**：React封装了管理自身状态和视图的组件，然后允许我们组合它们以创建复杂用户界面。'
- en: '**Learn once, write anywhere**: React does not make assumptions about your
    technology stack and tries to ensure that you can develop apps without rewriting
    existing code as much as possible.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次学习，到处编写**：React不对你的技术栈做出假设，并试图确保你可以尽可能不重写现有代码来开发应用程序。'
- en: React’s three fundamental principles make it easy to write code, encapsulate
    components, and share code across multiple platforms. Instead of reinventing the
    wheel, React tries to make use of existing JavaScript features as much as possible.
    As a result, we will learn software design patterns that will be applicable in
    many more cases than just designing user interfaces.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: React的三个基本原理使其易于编写代码、封装组件以及在多个平台上共享代码。React试图尽可能多地利用现有的JavaScript特性，而不是重新发明轮子。因此，我们将学习适用于许多更多情况的软件设计模式，而不仅仅是设计用户界面。
- en: Now that we have learned the fundamental principles of React, let’s get started
    setting up a full-stack React project!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了React的基本原理，让我们开始设置一个全栈React项目！
- en: Setting up a full-stack React project
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个全栈React项目
- en: 'Before we can start developing our frontend application, we first need to merge
    our previously created frontend boilerplate based on Vite with the backend service
    created in [*Chapter 3*](B19385_03_split_000.xhtml#_idTextAnchor050), *Implementing
    a Backend Using Express, Mongoose ODM, and Jest*. Let’s merge them now by following
    these steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发前端应用程序之前，我们首先需要将基于Vite创建的先前创建的前端模板与在[*第3章*](B19385_03_split_000.xhtml#_idTextAnchor050)中创建的后端服务合并，即使用Express、Mongoose
    ODM和Jest实现后端。让我们按照以下步骤合并它们：
- en: 'Copy the **ch1** folder to a new **ch4** folder, as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ch1**文件夹复制到新的**ch4**文件夹中，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Copy the **ch3** folder to a new **ch4/backend** folder, as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ch3**文件夹复制到新的**ch4/backend**文件夹中，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Delete* the **.git** folder in the copied **ch4/backend** folder, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* 复制的**ch4/backend**文件夹中的**.git**文件夹，如下所示：'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open the new **ch4** folder in VS Code.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开新的**ch4**文件夹。
- en: '*Remove* the Husky **prepare** script (the line is highlighted in the code
    snippet) from the **backend/package.json** file, as we already have Husky set
    up in the root directory:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* **backend/package.json**文件中的Husky **prepare**脚本（代码片段中已突出显示），因为我们已经在根目录中设置了Husky。'
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also *remove* the following **lint-staged** config from the **backend/package.json**
    file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时*删除*以下**lint-staged**配置从**backend/package.json**文件中：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, *remove* the **backend/.husky**, **backend/.vscode**, and **backend/.git**
    folders.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*删除* **backend/.husky**、**backend/.vscode**和**backend/.git**文件夹。
- en: 'To make sure all dependencies are installed properly, run the following command
    in the root of the **ch4** folder:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保所有依赖项都已正确安装，请在**ch4**文件夹的根目录下运行以下命令：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Also go to the **backend/** directory and install all dependencies there:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时也前往**backend/**目录并在那里安装所有依赖项：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now also remove the **husky**, **lint-staged**, and **@commitlint**
    packages from the backend project, as we already have it set up in the main project
    folder:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在也可以从后端项目中删除**husky**、**lint-staged**和**@commitlint**包，因为我们已经在主项目文件夹中设置了。
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is always a good idea to regularly check which packages you still need and
    which you can get rid of, to keep your project clean. In this case, we copied
    code from another project, but do not need the Husky / lint-staged / commitlint
    setup, as we already have it set up in the root of our project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 定期检查哪些包你仍然需要，哪些可以丢弃，以保持项目整洁总是一个好主意。在这种情况下，我们从另一个项目中复制了代码，但不需要Husky / lint-staged
    / commitlint设置，因为我们已经在项目的根目录中设置了。
- en: 'Now go back to the root of the **ch4** folder and run the following command
    to start the frontend server:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到**ch4**文件夹的根目录，并运行以下命令以启动前端服务器：
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the frontend in your browser by going to the URL shown by Vite: **http://localhost:5173/**'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问Vite显示的URL在浏览器中打开前端：**http://localhost:5173/**
- en: 'Open **src/App.jsx**, change the title as follows, and save the file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**src/App.jsx**，按照以下方式更改标题，并保存文件：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will see that the change is reflected instantly in the browser!
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到变化立即在浏览器中反映出来！
- en: After successfully setting up our full-stack project by combining our projects
    from previous chapters, let’s now get started designing and creating the user
    interface for our blog application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合我们之前章节的项目成功设置我们的全栈项目后，现在让我们开始设计和创建博客应用的用户界面。
- en: Creating the user interface for our application
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们应用的用户界面
- en: When designing the structure of a frontend, we should also consider the folder
    structure, so that our app can grow easily in the future. Similar to how we did
    for the backend, we will also put all our source code into a `src/` folder. We
    can then group the files in separate folders for the different features. Another
    popular way to structure frontend projects is to group code by routes. Of course,
    it is also possible to mix them, for example, in Next.js projects we can group
    our components by features and then create another folder and file structure for
    the routes, where the components are used. For full-stack projects, it additionally
    makes sense to first separate our code by creating separate folders for the API
    integration and UI components.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计前端的结构时，我们也应该考虑文件夹结构，以便我们的应用在未来可以轻松扩展。类似于我们为后端所做的那样，我们也会把所有源代码放入一个 `src/`
    文件夹中。然后我们可以根据不同的功能将文件分组到不同的文件夹中。另一种流行的前端项目结构方式是按路由分组代码。当然，混合它们也是可能的，例如，在Next.js项目中，我们可以按功能分组我们的组件，然后为使用组件的路由创建另一个文件夹和文件结构。对于全栈项目，首先通过创建用于API集成和UI组件的单独文件夹来分离代码也是有意义的。
- en: 'Now, let’s define the folder structure for our project:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们项目的文件夹结构：
- en: Create a new **src/api/** folder.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/api/** 文件夹。
- en: Create a new **src/components/** folder.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/components/** 文件夹。
- en: Tip
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is a good idea to start with a simple structure at first, and only nest more
    deeply when you actually need it. Do not spend too much time thinking about the
    file structure when starting a project, because usually, you do not know upfront
    how files should be grouped, and it may change later anyway.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从一个简单的结构开始是个好主意，只有在实际需要时才进行更深的嵌套。在开始一个项目时，不要花太多时间思考文件结构，因为通常你事先不知道文件应该如何分组，而且它可能以后还会改变。
- en: After defining the high-level folder structure for our projects, let’s now take
    some time to consider the component structure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义我们项目的高级文件夹结构之后，现在让我们花些时间考虑组件结构。
- en: Component structure
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件结构
- en: 'Based on what we defined in the backend, our blog application is going to have
    the following features:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在后端定义的内容，我们的博客应用将具有以下功能：
- en: Viewing a single post
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看单个帖子
- en: Creating a new post
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新帖子
- en: Listing posts
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出帖子
- en: Filtering posts
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤帖子
- en: Sorting posts
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对帖子进行排序
- en: The idea of components in React is to have each component deal with a single
    task or UI element. We should try to make components as fine-grained as possible,
    in order to be able to reuse code. If we find ourselves copying and pasting code
    from one component to another, it might be a good idea to create a new component
    and reuse it in multiple other components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: React中组件的理念是让每个组件处理单个任务或UI元素。我们应该尽量使组件尽可能细粒度，以便能够重用代码。如果我们发现自己正在从一个组件复制粘贴代码到另一个组件，那么创建一个新的组件并在多个其他组件中重用它可能是个好主意。
- en: 'Usually, when developing a frontend, we start with a UI mock-up. For our blog
    application, a mock-up could look as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在开发前端时，我们从一个UI原型开始。对于我们的博客应用，原型可能看起来如下：
- en: '![Figure 4.1 – An initial mock-up of our blog application](img/B19385_04_1.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 我们博客应用的初始原型](img/B19385_04_1.jpg)'
- en: Figure 4.1 – An initial mock-up of our blog application
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 我们博客应用的初始原型
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we will not cover UI or CSS frameworks. As such, the components
    are designed and developed without styling. Instead, the book focuses on the full-stack
    aspect of the integration of backends with frontends. Feel free to use a UI framework
    (such as MUI), or a CSS framework (such as Tailwind) to style the blog application
    on your own.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会涵盖UI或CSS框架。因此，组件的设计和开发没有添加样式。相反，本书专注于后端与前端集成的全栈方面。您可以根据自己的需要使用UI框架（如MUI），或CSS框架（如Tailwind）来为博客应用添加样式。
- en: When splitting up the UI into components, we use the **single-responsibility
    principle**, which states that every module should have responsibility over a
    single encapsulated part of the functionality.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当将UI拆分为组件时，我们使用 **单一职责原则**，该原则指出每个模块应该对功能的一个封装部分负责。
- en: 'In our mock-up, we can draw boxes around each component and subcomponent, and
    give them names. Keep in mind that each component should have exactly one responsibility.
    We start with the fundamental components that make up the app:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的原型中，我们可以围绕每个组件和子组件绘制方框，并给它们命名。请记住，每个组件应该只有一个职责。我们首先从构成应用的基本组件开始：
- en: '![Figure 4.2 – Defining the fundamental components in our mock-up](img/B19385_04_2.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 在我们的原型中定义基本组件](img/B19385_04_2.jpg)'
- en: Figure 4.2 – Defining the fundamental components in our mock-up
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 在我们的原型中定义基本组件
- en: We defined a `CreatePost` component, with a form to create a new post, a `PostFilter`
    component to filter the list of posts, a `PostSorting` component to sort posts,
    and a `Post` component to display a single post.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`CreatePost`组件，用于创建新帖子，一个`PostFilter`组件用于过滤帖子列表，一个`PostSorting`组件用于排序帖子，以及一个`Post`组件用于显示单个帖子。
- en: 'Now that we have defined our fundamental components, we are going to look at
    which components logically belong together, thereby forming a group: we can group
    the `Post` components together in `PostList`, then make an `App` component to
    group everything together and define the structure of our app.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了基本组件，我们将查看哪些组件在逻辑上属于一组，从而形成一个组：我们可以在`PostList`中将`Post`组件分组，然后创建一个`App`组件来将所有内容分组并定义应用的结构。
- en: Now that we are done with structuring our React components, we can move on to
    implementing the static React components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了React组件的结构化，我们可以继续实现静态React组件。
- en: Implementing static React components
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现静态React组件
- en: Before integrating with the backend, we are going to model the basic features
    of our application as static React components. Dealing with the static view structure
    of our application first makes sense, as we can play around and re-structure the
    application UI if needed, before adding integration to the components, which would
    make it harder and more tedious to move them around. It is also easier to deal
    only with the UI first, which helps us to get started quickly with projects and
    features. Then, we can move on to implementing integrations and handling state.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在与后端集成之前，我们将应用的基本功能建模为静态React组件。首先处理应用静态视图结构是有意义的，因为我们可以在添加组件集成之前，如果需要的话，可以随意调整应用UI的结构，这将使得移动它们变得更加困难和繁琐。首先处理UI也更容易，这有助于我们快速开始项目和功能。然后，我们可以继续实现集成和处理状态。
- en: Let’s get started implementing the static components now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始实现静态组件。
- en: The Post component
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Post组件
- en: We have already thought about which elements a post has during the creation
    of the mock-up and the design of the backend. A post should have a `title`, `contents`,
    and an `author`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建原型和后端设计时，我们已经考虑了帖子应该包含哪些元素。帖子应该有一个`title`、`contents`和`author`。
- en: 'Let’s implement the `Post` component now:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在实现`Post`组件：
- en: First, create a new **src/components/Post.jsx** file.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的**src/components/Post.jsx**文件。
- en: 'In that file, import **PropTypes**:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个文件中，导入**PropTypes**：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define a function component, accepting **title**, **contents**, and **author**
    props:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数组件，接受**title**、**contents**和**author**属性：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, render all props in a way that resembles the mock-up:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，以类似于原型的方式渲染所有属性：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Tip
- en: Please note that you should always prefer spacing via CSS, rather than using
    the **<br />** HTML tag. However, we are focusing on the UI structure and integration
    with the backend in this book, so we simply use HTML whenever possible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你应该始终优先使用CSS进行间距设置，而不是使用**<br />**HTML标签。然而，在这本书中，我们专注于UI结构和与后端的集成，所以我们尽可能使用HTML。
- en: 'Now, define **propTypes**, making sure only **title** is required:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义**propTypes**，确保只有**title**是必需的：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Info
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Info
- en: '**PropTypes** are used to validate the props passed to React components and
    to ensure that we are passing the correct props when using JavaScript. When using
    a type-safe language, such as TypeScript, we can instead do this by directly typing
    the props passed to the component.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**PropTypes**用于验证传递给React组件的属性，并确保我们在使用JavaScript时传递了正确的属性。当使用类型安全的语言，如TypeScript时，我们可以通过直接为传递给组件的属性类型化来做到这一点。'
- en: 'Let’s test out our component by *replacing* the **src/App.jsx** file with the
    following contents:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过**替换****src/App.jsx**文件的内容来测试我们的组件：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Edit **src/main.jsx** and update the import of the **App** component, because
    we are now not using **export** **default** anymore:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/main.jsx**并更新**App**组件的导入，因为我们现在不再使用**export** **default**：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Info
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Info
- en: I personally tend to prefer not using default exports, as they make it harder
    to re-group and re-export components and functions from other files. Also, they
    allow us to change the names of the components, which could be confusing. For
    example, if we change the name of a component, the name when importing it is not
    changed automatically.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人倾向于不使用默认导出，因为它们使得从其他文件重新组合和重新导出组件和函数变得更加困难。此外，它们允许我们更改组件的名称，这可能会造成混淆。例如，如果我们更改组件的名称，导入时的名称不会自动更改。
- en: 'Also, *remove* the following line from **src/main.jsx**:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，从 **src/main.jsx** 中*删除*以下行：
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, we can *delete* the **index.css** and **App.css** files, as they are
    not needed anymore.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以*删除* **index.css** 和 **App.css** 文件，因为它们不再需要了。
- en: Now that our static `Post` component has been implemented, we can move on to
    the `CreatePost` component.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了静态的 `Post` 组件，我们可以继续到 `CreatePost` 组件。
- en: The CreatePost component
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CreatePost 组件
- en: We’ll now implement a form to allow for the creation of new posts. Here, we
    provide fields for `author` and `title` and a `<textarea>` element for the contents
    of the blog post.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一个表单，允许创建新的帖子。在这里，我们提供了 `author` 和 `title` 字段，以及一个 `<textarea>` 元素用于输入博客帖子的内容。
- en: 'Let’s implement the `CreatePost` component now:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现 `CreatePost` 组件：
- en: Create a new **src/components/CreatePost.jsx** file.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/components/CreatePost.jsx** 文件。
- en: 'Define the following component, which contains a form to enter the title, author,
    and contents of a blog post:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义以下组件，它包含一个表单，用于输入博客帖子的标题、作者和内容：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code block, we defined an `onSubmit` handler and called `e.preventDefault()`
    on the event object to avoid a page refresh when the form is submitted.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们定义了一个 `onSubmit` 处理程序，并在事件对象上调用 `e.preventDefault()` 以避免在表单提交时刷新页面。
- en: 'Let’s test the component out by *replacing* the **src/App.jsx** file with the
    following contents:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过*替换* **src/App.jsx** 文件的内容来测试这个组件：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the `CreatePost` component renders fine. We can now move on
    to the `PostFilter` and `PostSorting` components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`CreatePost` 组件渲染良好。我们现在可以继续到 `PostFilter` 和 `PostSorting` 组件。
- en: Tip
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to test out multiple components at once and keep the tests around
    for later, or build a style guide for your own component library, you should look
    into Storybook ([https://storybook.js.org](https://storybook.js.org)), which is
    a useful tool to build, test, and document UI components in isolation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一次性测试多个组件并保留测试结果以供以后使用，或者为你的组件库创建一个样式指南，你应该了解一下 Storybook ([https://storybook.js.org](https://storybook.js.org))，这是一个用于独立构建、测试和记录
    UI 组件的有用工具。
- en: The PostFilter and PostSorting components
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostFilter 和 PostSorting 组件
- en: 'Similar to the `CreatePost` component, we will be creating two components that
    provide input fields to filter and sort posts. Let’s start with `PostFilter`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `CreatePost` 组件类似，我们将创建两个组件，它们提供输入字段以过滤和排序帖子。让我们从 `PostFilter` 开始：
- en: Create a new **src/components/PostFilter.jsx** file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/components/PostFilter.jsx** 文件。
- en: 'In this file, we import **PropTypes**:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们导入 **PropTypes**：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we define the **PostFilter** component and make use of the **field** prop:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义 **PostFilter** 组件并使用 **field** 属性：
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we are going to define the `PostSorting` component.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将定义 `PostSorting` 组件。
- en: Create a new **src/components/PostSorting.jsx** file.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/components/PostSorting.jsx** 文件。
- en: 'In this file, we create a **select** input to select which field to sort by.
    We also create another **select** input to select the sort order:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们创建了一个 **select** 输入以选择要排序的字段。我们还创建了一个另一个 **select** 输入以选择排序顺序：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we have successfully defined UI components to filter and sort posts. In
    the next step, we are going to create a `PostList` component to combine the filter
    and sorting with a list of posts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功定义了用于过滤和排序帖子的 UI 组件。在下一步中，我们将创建一个 `PostList` 组件，将过滤和排序与帖子列表结合起来。
- en: The PostList component
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostList 组件
- en: After implementing the other post-related components, we can now implement the
    most important part of our blog app, that is, the feed of blog posts. For now,
    the feed is simply going to show a list of blog posts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了其他与帖子相关的组件之后，我们现在可以开始实现我们博客应用最重要的部分，即博客帖子的源。目前，源将简单地显示一个博客帖子列表。
- en: 'Let’s start implementing the `PostList` component now:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始实现 `PostList` 组件：
- en: Create a new **src/components/PostList.jsx** file.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/components/PostList.jsx** 文件。
- en: 'First, we import **Fragment**, **PropTypes**, and the **Post** component:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入 **Fragment**、**PropTypes** 和 **Post** 组件：
- en: '[PRE24]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we define the **PostList** function component, accepting a **posts**
    array as a prop. If **posts** is not defined, we set it to an empty array, by
    default:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了**PostList**函数组件，它接受一个作为属性的**posts**数组。如果**posts**未定义，我们默认将其设置为空数组：
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we render all posts by using the **.map** function and the spread syntax:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用**.map**函数和扩展语法来渲染所有帖子：
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We return the `<Post>` component for each post, and pass all the keys from
    the `post` object to the component as props. We do this by using the spread syntax,
    which has the same effect as listing all the keys from the object manually as
    props, like so:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为每个帖子返回`<Post>`组件，并将`post`对象中的所有键作为属性传递给组件。我们通过使用扩展语法来完成此操作，这具有与手动将对象的所有键作为属性列出相同的效果，如下所示：
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we are rendering a list of elements, we have to give each element a unique
    **key** prop. React uses this **key** prop to efficiently compute the difference
    between two lists when the data has changed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在渲染元素列表，我们必须给每个元素一个唯一的**key**属性。React使用这个**key**属性在数据发生变化时高效地计算两个列表之间的差异。
- en: 'We used the `map` function, which applies a function to all the elements of
    an array. This is similar to using a `for` loop and storing all the results, but
    it is more concise, declarative, and easier to read! Alternatively, we could do
    the following instead of using the `map` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`map`函数，它将一个函数应用于数组的所有元素。这与使用`for`循环并存储所有结果类似，但更简洁、声明性更强、更容易阅读！作为使用`map`函数的替代方案，我们可以这样做：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, using this style is *not* recommended with React.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种风格在React中**不**被推荐。
- en: 'We also still need to define the prop types. Here, we can make use of the prop
    types from the **Post** component, by wrapping it inside the **PropTypes.shape()**
    function, which defines an object prop type:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定义属性类型。在这里，我们可以利用**Post**组件的属性类型，通过将其包裹在**PropTypes.shape()**函数中来使用，该函数定义了一个对象属性类型：
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the mock-up, we have a horizontal line after each blog post. We can implement
    this without an additional **<div>** container element, by using **Fragment**,
    as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原型中，我们每篇博客文章后面都有一个水平线。我们可以通过使用**Fragment**来实现这一点，而不需要额外的**<div>**容器元素，如下所示：
- en: '[PRE30]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **key** prop always has to be added to the uppermost parent element that
    is rendered within the **map** function. In this case, we had to move the **key**
    prop from the **Post** component to **Fragment**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**属性始终必须添加到在**map**函数中渲染的最高父元素。在这种情况下，我们必须将**key**属性从**Post**组件移动到**Fragment**。'
- en: 'Again, we test our component by editing the **src/App.jsx** file:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们通过编辑**src/App.jsx**文件来测试我们的组件：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we can see that our app lists all the posts that we defined in the `posts`
    array.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以看到我们的应用列出了我们在`posts`数组中定义的所有帖子。
- en: As you can see, listing multiple posts via the `PostList` component works fine.
    We can now move on to putting the app together.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过`PostList`组件列出多个帖子工作得很好。现在我们可以继续组装应用。
- en: Putting the app together
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装应用
- en: After implementing all the components, we now have to put everything together
    in the `App` component. Then, we will have successfully reproduced the mock-up!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所有组件后，我们现在必须在`App`组件中将所有内容组合在一起。然后，我们将成功复制原型！
- en: 'Let’s start modifying the `App` component and putting our blog app together:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始修改`App`组件并将我们的博客应用组装起来：
- en: 'Open **src/App.jsx** and add imports for the **CreatePost**, **PostFilter**,
    and **PostSorting** components:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**src/App.jsx**并为**CreatePost**、**PostFilter**和**PostSorting**组件添加导入：
- en: '[PRE32]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Adjust the **App** component to contain all the components:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整**App**组件以包含所有组件：
- en: '[PRE33]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After saving the file, the browser should automatically refresh, and we can
    now see the full UI:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件后，浏览器应自动刷新，现在我们可以看到完整的UI：
- en: '![Figure 4.3 – Full implementation of our static blog app, according to the
    mock-up](img/B19385_04_3.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 根据原型实现的我们的静态博客应用完整实现](img/B19385_04_3.jpg)'
- en: Figure 4.3 – Full implementation of our static blog app, according to the mock-up
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 根据原型实现的我们的静态博客应用完整实现
- en: As we can see, all of the static components that we defined earlier are rendered
    together in one `App` component. Our app now looks just like a mock-up. Next,
    we can move on to integrating our components with the backend service.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们之前定义的所有静态组件都在一个`App`组件中一起渲染。现在，我们的应用看起来就像原型一样。接下来，我们可以继续将我们的组件与后端服务集成。
- en: Integrating the backend service using TanStack Query
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TanStack Query集成后端服务
- en: After finishing creating all the UI components, we can now move on to integrating
    them with the backend we created in the previous chapter. For the integration,
    we are going to use TanStack Query (previously called React Query), which is a
    data fetching library that can also help us with caching, synchronizing, and updating
    data from a backend.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有 UI 组件的创建后，我们现在可以继续将它们与上一章中创建的后端集成。对于集成，我们将使用 TanStack Query（之前称为 React
    Query），这是一个数据获取库，它还可以帮助我们进行缓存、同步和从后端更新数据。
- en: 'TanStack Query specifically focuses on managing the state of fetched data (server
    state). While other state management libraries can also deal with server state,
    they specialize in managing client state instead. Server state has some stark
    differences from client state, such as the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: TanStack Query 专注于管理获取的数据的状态（服务器状态）。虽然其他状态管理库也可以处理服务器状态，但它们专注于管理客户端状态。服务器状态与客户端状态有一些明显的区别，例如以下内容：
- en: Being persisted remotely in a location the client does not control directly
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端无法直接控制的位置远程持久化
- en: Requiring asynchronous APIs to fetch and update state
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要异步 API 来获取和更新状态
- en: Having to deal with shared ownership, which means that other people can change
    the state without your knowledge
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须处理共享所有权，这意味着其他人可以在你不知情的情况下更改状态
- en: State becoming stale (“out of date”) at some point when changed by the server
    or other people
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器或其他人在某个时候更改状态时，状态变得过时（“过时”）
- en: These challenges with server state result in issues such as having to cache,
    deduplicate multiple requests, update “out of date” state in the background, and
    so on.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与服务器状态相关的挑战导致了一系列问题，例如必须缓存、去重多个请求、在后台更新“过时”状态等。
- en: TanStack Query provides solutions to these issues out of the box and thus makes
    dealing with server state simple. You can always combine it with other state management
    libraries that focus on client state as well. For use cases where the client state
    essentially just reflects the server state though, TanStack Query on its own can
    be good enough as a state management solution!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: TanStack Query 提供了现成的解决方案来解决这些问题，因此处理服务器状态变得简单。你总是可以将其与其他关注客户端状态的州管理库结合使用。对于客户端状态本质上只是反映服务器状态的使用案例，TanStack
    Query 本身就足以作为一个状态管理解决方案！
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why React Query got renamed to TanStack Query is that the library
    now also supports other frameworks, such as Solid, Vue, and Svelte!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 被重命名为 TanStack Query 的原因是这个库现在也支持其他框架，例如 Solid、Vue 和 Svelte！
- en: Now that you know why and how TanStack Query can help us integrate our frontend
    with the backend, let’s get started using it!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了为什么以及如何使用 TanStack Query 来帮助我们集成前端和后端，让我们开始使用它吧！
- en: Setting up TanStack Query for React
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 React 设置 TanStack Query
- en: To set up TanStack Query, we first have to install the dependency and set up
    a query client. The query client is provided to React through a context and will
    store information about active requests, cached results, when to periodically
    re-fetch data, and everything needed for TanStack Query to function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 TanStack Query，我们首先必须安装依赖项并设置一个查询客户端。查询客户端通过上下文提供给 React，并将存储有关活动请求、缓存结果、何时定期重新获取数据以及
    TanStack Query 运作所需的一切信息。
- en: 'Let’s get started setting it up now:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始设置它：
- en: 'Open a new Terminal (do not quit Vite!) and install the **@tanstack/react-query**
    dependency by running the following command in the root of our project:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端（不要退出 Vite！）并在我们项目的根目录下运行以下命令来安装 **@tanstack/react-query** 依赖项：
- en: '[PRE34]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Rename the **src/App.jsx** file to **src/Blog.jsx**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **src/App.jsx** 文件重命名为 **src/Blog.jsx**。
- en: Do not update imports yet. If VS Code asks you to update imports, click **No**.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要更新导入。如果 VS Code 要求你更新导入，请点击 **No**。
- en: 'Now, in **src/Blog.jsx**, change the function name from **App** to **Blog**:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **src/Blog.jsx** 中，将函数名从 **App** 改为 **Blog**：
- en: '[PRE35]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new **src/App.jsx** file. In this file, import **QueryClient** and
    **QueryClientProvider** from TanStack React Query:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/App.jsx** 文件。在这个文件中，从 TanStack React Query 导入 **QueryClient** 和
    **QueryClientProvider**：
- en: '[PRE36]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Also, import the **Blog** component:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要导入 **Blog** 组件：
- en: '[PRE37]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, create a new query client:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的查询客户端：
- en: '[PRE38]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define the **App** component and render the **Blog** component wrapped inside
    **QueryClientProvider**:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 **App** 组件并渲染包裹在 **QueryClientProvider** 中的 **Blog** 组件：
- en: '[PRE39]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That’s all there is to setting up TanStack Query! We can now make use of it
    inside our `Blog` component (and its children).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是设置 TanStack Query 所需要做的全部！现在我们可以在我们的 `Blog` 组件（及其子组件）中使用它了。
- en: Fetching blog posts
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取博客文章
- en: 'The first thing we should do is fetch the list of blog posts from our backend.
    Let’s implement that now:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该做的是从我们的后端获取博客文章列表。现在让我们来实现它：
- en: 'First of all, in the second Terminal window opened (not where Vite is running),
    run the backend server (do not quit Vite!), as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在打开的第二个终端窗口中（不是Vite运行的地方），运行后端服务器（不要退出Vite！），如下所示：
- en: '[PRE40]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you get an error, make sure Docker and MongoDB are running properly!
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果出现错误，请确保Docker和MongoDB正在正常运行！
- en: Tip
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to develop the backend and frontend at the same time, you can start
    the backend using **npm run dev** to make sure it hot reloads when you change
    the code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想同时开发后端和前端，你可以使用**npm run dev**启动后端，以确保在更改代码时它能够热重载。
- en: 'Create a **.env** file in the root of the project, and enter the following
    contents into it:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中创建一个**.env**文件，并将以下内容输入到其中：
- en: '[PRE41]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Vite supports `dotenv` out of the box. All environment variables that should
    be available to be accessed within the frontend need to be prefixed with `VITE_`.
    Here, we set an environment variable to point to our backend server.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Vite默认支持`dotenv`。所有应该在前端中可访问的环境变量都需要以`VITE_`为前缀。在这里，我们设置一个环境变量以指向我们的后端服务器。
- en: 'Create a new **src/api/posts.js** file. In this file, we are going to define
    a function to fetch posts, which accepts the query params for the **/posts** endpoint
    as an argument. These query params are used to filter by author and tag and define
    sorting using **sortBy** and **sortOrder**:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/api/posts.js**文件。在这个文件中，我们将定义一个函数来获取文章，该函数接受作为参数的**/posts**端点的查询参数。这些查询参数用于按作者和标签筛选，并使用**sortBy**和**sortOrder**定义排序：
- en: '[PRE42]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Remember that we can use the **fetch** function to make a request to a server.
    We need to pass the environment variable to it and add the **/posts** endpoint.
    After the path, we add query params, which are prefixed with the **?** symbol:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，我们可以使用**fetch**函数向服务器发送请求。我们需要将环境变量传递给它，并添加**/posts**端点。在路径之后，我们添加查询参数，这些参数以**?**符号为前缀：
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we need to use the **URLSearchParams** class to turn an object into query
    params. That class will automatically escape the input for us and turn it into
    valid query params:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要使用**URLSearchParams**类将一个对象转换为查询参数。这个类会自动为我们转义输入并将其转换为有效的查询参数：
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Like we did before in the browser, we need to parse the response as JSON:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在浏览器中之前做的那样，我们需要将响应解析为JSON：
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Edit **src/Blog.jsx** and *remove* the sample **posts** array:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/Blog.jsx**并*删除*示例**posts**数组：
- en: '[PRE46]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, import the **useQuery** function from **@tanstack/react-query** and the
    **getPosts** function from our **api** folder in the **src/Blog.jsx** file:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，从**@tanstack/react-query**导入**useQuery**函数，并从**src/Blog.jsx**文件中的**api**文件夹导入**getPosts**函数：
- en: '[PRE47]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside the **Blog** component, define a **useQuery** hook:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Blog**组件内部，定义一个**useQuery**钩子：
- en: '[PRE48]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After the **useQuery** hook, we get the posts from our query and fall back
    to an empty array if the posts are not loaded yet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**useQuery**钩子之后，我们从查询中获取文章，如果文章尚未加载，则回退到空数组：
- en: '[PRE49]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Check your browser, and you will see that the posts are now loaded from our
    backend!
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你的浏览器，你会看到文章现在是从我们的后端加载的！
- en: Now that we have successfully fetched blog posts, let’s get the filters and
    sorting working!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功获取了博客文章，让我们让筛选和排序工作起来！
- en: Implementing filters and sorting
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现筛选和排序
- en: 'To implement filters and sorting, we need to handle some local state and pass
    it as query params to `postsQuery`. Let’s do that now:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现筛选和排序，我们需要处理一些本地状态，并将其作为查询参数传递给`postsQuery`。现在让我们来做这件事：
- en: 'We start by editing the **src/Blog.jsx** file and importing the **useState**
    hook from React:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先编辑**src/Blog.jsx**文件并从React导入**useState**钩子：
- en: '[PRE50]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then we add state hooks for the **author** filter and the sorting options inside
    the **Blog** component, before the **useQuery** hook:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Blog**组件中，在**useQuery**钩子之前添加**author**筛选器和排序选项的状态钩子：
- en: '[PRE51]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we adjust **queryKey** to contain the query params (so that whenever
    a query param changes, TanStack Query will re-fetch unless the request is already
    cached). We also adjust **queryFn** to call **getPosts** with the relevant query
    params:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将**queryKey**调整为包含查询参数（这样每当查询参数发生变化时，TanStack Query都会重新获取，除非请求已经被缓存）。我们还将**queryFn**调整为调用带有相关查询参数的**getPosts**：
- en: '[PRE52]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now pass the values and relevant **onChange** handlers to the filter and sorting
    components:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将值和相关的**onChange**处理程序传递给筛选和排序组件：
- en: '[PRE53]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity’s sake, we are only using state hooks for now. A state management
    solution or context could make dealing with filters and sorting much easier, especially
    for larger applications. For our small blog application, it is fine to use state
    hooks though, as we are focusing mostly on the integration of the backend and
    frontend.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们现在只使用状态钩子。状态管理解决方案或上下文可以使处理过滤和排序变得容易得多，尤其是在大型应用程序中。对于我们的小型博客应用程序，使用状态钩子是可以的，因为我们主要关注后端和前端之间的集成。
- en: 'Now, edit **src/components/PostFilter.jsx** and add the **value** and **onChange**
    props:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑**src/components/PostFilter.jsx**并添加**value**和**onChange**属性：
- en: '[PRE54]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also do the same for **src/components/PostSorting.jsx**:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也为**src/components/PostSorting.jsx**做同样的处理：
- en: '[PRE55]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In your browser, enter **Daniel Bugl** as the author. You should see TanStack
    Query re-fetch the posts from the backend as you type, and once a match is found,
    the backend will return all posts by that author!
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中，输入**Daniel Bugl**作为作者。您应该看到TanStack Query在您输入时从后端重新获取帖子，一旦找到匹配项，后端将返回该作者的所有帖子！
- en: After testing it out, make sure to clear the filter again, so that newly created
    posts are not filtered by the author anymore later on.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试完毕后，请确保再次清除过滤器，这样后来创建的帖子就不会再根据作者进行过滤。
- en: Tip
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you do not want to make that many requests to the backend, make sure to use
    a debouncing state hook, such as **useDebounce**, and then pass only the debounced
    value to the query param. If you are interested in gaining further knowledge about
    the **useDebounce** hook and other useful hooks, I recommend checking out my book
    titled *Learn* *React Hooks*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想向后端发送那么多请求，请确保使用防抖状态钩子，如**useDebounce**，然后将仅防抖的值传递给查询参数。如果您对了解**useDebounce**钩子和其他有用的钩子感兴趣，我建议您查看我写的名为*Learn
    React Hooks*的书籍。
- en: 'The application should now look as follows, with the posts being filtered by
    the author entered in the field, and sorted by the selected field, in the selected
    order:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在应该如下所示，帖子根据在字段中输入的作者进行过滤，并按所选字段排序，按所选顺序排序：
- en: '![Figure 4.4 – Our first full-stack application – a frontend fetching posts
    from a backend!](img/B19385_04_4.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 我们的第一个全栈应用程序 – 前端从后端获取帖子！](img/B19385_04_4.jpg)'
- en: Figure 4.4 – Our first full-stack application – a frontend fetching posts from
    a backend!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 我们的第一个全栈应用程序 – 前端从后端获取帖子！
- en: Now that sorting and filtering are working properly, let’s learn about mutations,
    which allow us to make requests to the server that change the state of the backend
    (for example, inserting or updating entries in the database).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在排序和过滤都正常工作后，让我们了解突变，它允许我们向服务器发送更改后端状态（例如，在数据库中插入或更新条目）的请求。
- en: Creating new posts
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新帖子
- en: 'We are now going to implement a feature to create posts. To do this, we need
    to use the `useMutation` hook from TanStack Query. While queries are meant to
    be idempotent (meaning that calling them multiple times should not affect the
    result), mutations are used to create/update/delete data or perform operations
    on the server. Let’s get started using mutations to create new posts now:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现创建帖子的功能。为此，我们需要使用TanStack Query的`useMutation`钩子。虽然查询意味着是幂等的（这意味着多次调用它们不应影响结果），但突变用于创建/更新/删除数据或在服务器上执行操作。现在让我们开始使用突变来创建新的帖子：
- en: 'Edit **src/api/posts.js** and define a new **createPost** function, which accepts
    a **post** object as an argument:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/api/posts.js**并定义一个新的**createPost**函数，该函数接受一个**post**对象作为参数：
- en: '[PRE56]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We also make a request to the **/posts** endpoint, like we did for **getPosts**:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还像对**getPosts**一样向**/posts**端点发送请求：
- en: '[PRE57]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'However, now we also set **method** to a **POST** request, pass a header to
    tell the backend that we will be sending a JSON body, and then send our **post**
    object as a JSON string:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，现在我们也将**method**设置为**POST**请求，传递一个头部信息告诉后端我们将发送一个JSON体，然后将我们的**post**对象作为JSON字符串发送：
- en: '[PRE58]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Like with **getPosts**, we also need to parse the response as JSON:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像**getPosts**一样，我们还需要将响应解析为JSON：
- en: '[PRE59]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: After defining the `createPost` API function, let’s use it in the `CreatePost`
    component by creating a new mutation hook there.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在定义了`createPost` API函数之后，让我们在`CreatePost`组件中使用它，通过在那里创建一个新的突变钩子：
- en: 'Edit **src/components/CreatePost.jsx** and import the **useMutation** hook
    from **@tanstack/react-query**, the **useState** hook from React, and our **createPost**
    API function:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/components/CreatePost.jsx**并从**@tanstack/react-query**导入**useMutation**钩子，从React导入**useState**钩子以及我们的**createPost**
    API函数：
- en: '[PRE60]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Inside the **CreatePost** component, define state hooks for **title**, **author**,
    and **contents**:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**CreatePost**组件内部，为**title**、**author**和**contents**定义状态钩子：
- en: '[PRE61]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, define a mutation hook. Here, we are going to call our **createPost**
    function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个突变钩子。在这里，我们将调用我们的**createPost**函数：
- en: '[PRE62]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we are going to define a **handleSubmit** function, which will prevent
    the default submit action (which refreshes the page), and instead call **.mutate()**
    to execute the mutation:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个**handleSubmit**函数，该函数将阻止默认的提交操作（这将刷新页面），而是调用**.mutate()**来执行突变：
- en: '[PRE63]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We add the **onSubmit** handler to our form:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将**onSubmit**处理程序添加到我们的表单中：
- en: '[PRE64]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We also add the **value** and **onChange** props to our fields, as we did before
    for the sorting and filters:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还像之前为排序和过滤器所做的那样，为我们的字段添加了**value**和**onChange**属性：
- en: '[PRE65]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'For the submit button, we make sure it says **Creating…** instead of **Create**
    while we are waiting for the mutation to finish, and we also disable the button
    if no title was set (as it is required), or if the mutation is currently pending:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于提交按钮，我们确保在等待突变完成时显示**Creating…**而不是**Create**，并且如果没有设置标题（这是必需的），或者突变当前正在挂起时，我们也会禁用按钮：
- en: '[PRE66]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Lastly, we add a message below the submit button, which will be shown if the
    mutation is successful:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在提交按钮下方添加了一条消息，如果突变成功，将会显示：
- en: '[PRE67]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to **isPending** and **isSuccess**, mutations also return **isIdle**
    (when the mutation is idle or in a fresh/reset state) and **isError** states.
    The same states can also be accessed from queries, for example, to show a loading
    animation while posts are fetching.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**isPending**和**isSuccess**，突变还会返回**isIdle**（当突变处于空闲或新鲜/重置状态时）和**isError**状态。相同的也可以从查询中访问，例如，在帖子正在获取时显示加载动画。
- en: Now we can try adding a new post, and it seems to work fine, but the post list
    is not updating automatically, only after a refresh!
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试添加一个新的帖子，看起来工作得很好，但是帖子列表并没有自动更新，只有刷新后才会更新！
- en: The issue is that the query key did not change, so TanStack Query does not refresh
    the list of posts. However, we also want to refresh the list when a new post is
    created. Let’s fix that now.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于查询键没有改变，所以TanStack Query没有刷新帖子列表。然而，我们还想在创建新帖子时刷新列表。现在让我们修复这个问题。
- en: Invalidating queries
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无效化查询
- en: 'To ensure that the post list is refreshed after creating a new post, we need
    to invalidate the query. We can make use of the query client to do this. Let’s
    do it now:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保创建新帖子后帖子列表被刷新，我们需要无效化查询。我们可以利用查询客户端来完成这个操作。现在让我们来做这件事：
- en: 'Edit **src/components/CreatePost.jsx** and import the **useQueryClient** hook:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/components/CreatePost.jsx**并导入**useQueryClient**钩子：
- en: '[PRE68]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Use the query client to invalidate all queries starting with the **''posts''**
    query key. This will work with any query params to the **getPosts** request, as
    it matches all queries starting with **''posts''** in the array:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用查询客户端无效化以**'posts'**查询键开头的所有查询。这将与**getPosts**请求的任何查询参数一起工作，因为它匹配数组中所有以**'posts'**开头的查询：
- en: '[PRE69]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Try creating a new post, and you will see that it works now, even with active
    filters and sorting! As we can see, TanStack Query is great for handling server
    state with ease.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个新的帖子，你会看到现在它确实可以工作，即使有活跃的过滤器和排序！正如我们所看到的，TanStack Query在轻松处理服务器状态方面非常出色。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned how to create a React frontend and integrate it
    with our backend using TanStack Query. We have covered the main functionality
    of our backend: listing posts with sorting, creating posts, and filtering by author.
    Dealing with tags and deleting and editing posts are similar to the already explained
    functionalities and are left as an exercise for you.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建一个React前端，并使用TanStack Query将其与我们的后端集成。我们已经涵盖了后端的主要功能：按排序列出帖子、创建帖子以及按作者过滤。处理标签以及删除和编辑帖子与已解释的功能类似，留作你的练习。
- en: In the next chapter, [*Chapter 5*](B19385_05.xhtml#_idTextAnchor090), *Deploying
    the Application with Docker and CI/CD*, we are going to deploy our application
    with Docker and set up CI/CD pipelines to automate the deployment of our application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第五章*](B19385_05.xhtml#_idTextAnchor090)，*使用Docker和CI/CD部署应用程序*，我们将使用Docker部署我们的应用程序，并设置CI/CD管道来自动化应用程序的部署。
