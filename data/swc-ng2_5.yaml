- en: Chapter 5. Dependency Injection in Angular 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Angular 2中的依赖注入
- en: In this chapter, we'll explain how to take advantage of the **dependency injection**
    (**DI**) mechanism of the framework with all its various features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何利用框架的**依赖注入**（**DI**）机制及其各种特性。
- en: 'We will explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下主题：
- en: Configuring and creating injectors.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和创建注入器。
- en: Instantiating objects using injectors.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注入器实例化对象。
- en: Injecting dependencies into our directives and components. This way, we will
    be able to reuse the business logic defined within the services and wire it up
    with the UI logic.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将依赖项注入到我们的指令和组件中。这样，我们将能够重用服务中定义的业务逻辑，并将其与UI逻辑连接起来。
- en: Annotating the ES5 code we will write in order to get the exact same result
    we get when we are using the TypeScript syntax.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释我们将编写的ES5代码，以便获得与使用TypeScript语法时相同的结果。
- en: Why do I need Dependency Injection?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我为什么需要依赖注入？
- en: 'Let''s suppose that we have a `Car` class that depends on the `Engine` and
    `Transmission` classes. How can we implement this system? Let''s take a look:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个依赖于`Engine`和`Transmission`类的`Car`类。我们如何实现这个系统？让我们看一下：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we created the dependencies of the `Car` class inside of its
    constructor. Although it looks simple, it is far from being flexible. Each time
    we create an instance of the `Car` class, instances of the same `Engine` and `Transmission`
    classes will be created. This may be problematic because of the following reasons:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`Car`类的构造函数中创建了它的依赖关系。虽然看起来很简单，但远非灵活。每次我们创建`Car`类的实例时，都会创建相同的`Engine`和`Transmission`类的实例。这可能会有问题，原因如下：
- en: The `Car` class gets less testable because we can't test it independently from
    its `engine` and `transmission` dependencies.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Car`类变得不太可测试，因为我们无法独立测试它的`engine`和`transmission`依赖关系。'
- en: We couple the `Car` class with the logic used for the instantiation of its dependencies.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Car`类与用于实例化其依赖关系的逻辑耦合在一起。
- en: Dependency Injection in Angular 2
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2中的依赖注入
- en: 'Another way we can approach this is by taking advantage of the DI pattern.
    We''re already familiar with it from AngularJS 1.x. Let''s demonstrate how we
    can refactor the preceding code using DI in the context of Angular 2:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用的另一种方法是利用DI模式。我们已经从AngularJS 1.x中熟悉了它。让我们演示如何在Angular 2的上下文中使用DI重构前面的代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All we did in the preceding snippet was add the `@Injectable` class decorator
    on top of the definition of the `Car` class and provide type annotations for the
    parameters of its constructor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们所做的只是在`Car`类的定义顶部添加了`@Injectable`类装饰器，并为其构造函数的参数提供了类型注解。
- en: Benefits of DI in Angular 2
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2中DI的好处
- en: 'There is one more step left, which we''ll take a look at in the next section.
    But let''s see what the benefits of the mentioned approach are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一步剩下，我们将在下一节中看一下。但让我们看看所述方法的好处是什么：
- en: We can easily pass different versions of the dependencies of the `Car` class
    for a testing environment.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松地为测试环境传递`Car`类的不同版本的依赖关系。
- en: We're not coupled with the logic around the dependencies' instantiation.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再与依赖关系实例化周围的逻辑耦合在一起。
- en: The `Car` class is only responsible for implementing its own domain-specific
    logic instead of being coupled with additional functionalities, such as the management
    of its dependencies. Our code also got more declarative and easier to read.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`类只负责实现自己的领域特定逻辑，而不是与其他功能耦合，比如管理它的依赖关系。我们的代码也变得更加声明性和易于阅读。'
- en: Now, after we've realized some of the benefits of the DI, let's take a look
    at the missing pieces in order to make this code work!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们意识到DI的一些好处之后，让我们看看为使这段代码工作所缺少的部分！
- en: Configuring an injector
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置注入器
- en: The primitive used for the instantiation of the individual dependencies in our
    Angular 2 applications via the DI mechanism of the framework is called the **injector**.
    The injector contains a set of **providers** that encapsulate the logic for the
    instantiation of registered dependencies associated with **tokens**. We can think
    of tokens as identifiers of the different providers registered within the injector.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Angular 2应用程序中，通过框架的DI机制实例化各个依赖项的基本方法称为**注入器**。注入器包含一组**提供者**，封装了与**token**关联的已注册依赖项实例化的逻辑。我们可以将token视为注入器中注册的不同提供者的标识符。
- en: 'Let''s take a look at the following snippet, which is located at `ch5/ts/injector-basics/injector.ts`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的代码片段，它位于`ch5/ts/injector-basics/injector.ts`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can run the file using the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行该文件：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you haven't installed `ts-node` yet, take a look at [Chapter 3](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*, which explains
    how you can proceed in order to have it up and running on your computer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装`ts-node`，请参阅[第3章](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582
    "第3章。TypeScript Crash Course") *TypeScript Crash Course*，了解如何继续在计算机上安装并运行它。
- en: We import `Injector`, `Injectable`, `Inject`, `OpaqueToken`, and `provide`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`Injector`、`Injectable`、`Inject`、`OpaqueToken`和`provide`。
- en: Injector represents the **container** used for the instantiation of the different
    dependencies. Using the rules declared with the `provide` function and the metadata
    generated by the TypeScript compiler, it knows how to create them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注入器表示用于实例化不同依赖项的**容器**。使用`provide`函数声明的规则和TypeScript编译器生成的元数据，它知道如何创建它们。
- en: In the preceding snippet, we initially defined the `BUFFER_SIZE` constant and
    set it to the `new OpaqueToken('buffer-size')` value. We can think of the value
    of `BUFFER_SIZE` as a unique value that cannot be duplicated in the application
    (`OpaqueToken` is an alternative of the `Symbol` class from ES2015, since at the
    time of writing this, it is not supported by TypeScript).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先定义了`BUFFER_SIZE`常量，并将其设置为`new OpaqueToken('buffer-size')`的值。我们可以将`BUFFER_SIZE`的值视为应用程序中无法复制的唯一值（`OpaqueToken`是ES2015中`Symbol`类的替代品，因为在撰写本文时，TypeScript不支持`Symbol`）。
- en: 'We defined two classes: `Buffer` and `Socket`. The `Buffer` class has a constructor
    that accepts only a single dependency called `size`, which is of the type `Number`.
    In order to add additional metadata for the process of dependency resolution,
    we use the `@Inject` parameter decorator. This decorator accepts an identifier
    (also known as **token**) of the dependency we want to inject. Usually, it is
    the type of the dependency (that is, a reference of a class), but in some cases,
    it can be a different type of a value. For example, in our case, we used the instance
    of the `OpaqueToken` class.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个类：`Buffer`和`Socket`。`Buffer`类有一个构造函数，只接受一个名为`size`的依赖项，类型为`Number`。为了为依赖项解析过程添加额外的元数据，我们使用`@Inject`参数装饰器。这个装饰器接受一个标识符（也称为**token**），表示我们要注入的依赖项。通常情况下，它是依赖项的类型（即类的引用），但在某些情况下，它可以是不同类型的值。例如，在我们的例子中，我们使用了`OpaqueToken`类的实例。
- en: Dependency resolution with generated metadata
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用生成的元数据进行依赖项解析
- en: Now let's take a look at the `Socket` class. We decorate it with the `@Injectable`
    decorator. This decorator is supposed to be used by any class that accepts dependencies
    that should be injected via the dependency injection mechanism of Angular 2.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`Socket`类。我们用`@Injectable`装饰它。这个装饰器应该被任何接受依赖项的类使用，这些依赖项应该通过Angular 2的依赖注入机制注入。
- en: The `@Injectable` decorator forces the TypeScript compiler to generate additional
    metadata for the types of dependencies that a given class accepts. This means
    that if we omit the `@Injectable` decorator, Angular's DI mechanism will not be
    aware of the tokens associated with the dependencies it needs to resolve.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Injectable`装饰器会强制TypeScript编译器为给定类接受的依赖项的类型生成额外的元数据。这意味着如果我们省略`@Injectable`装饰器，Angular的DI机制将不会意识到与它需要解决的依赖项相关联的标记。'
- en: TypeScript doesn't generate any metadata if no decorator is used on top of a
    class mostly for performance concerns. Imagine if such metadata was generated
    for each individual class that accepts dependencies—in this case, the output would
    be bloated with additional type metadata that would be unused.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在类的顶部没有使用装饰器，TypeScript不会生成任何元数据，这主要是出于性能方面的考虑。想象一下，如果为每个接受依赖项的类生成了这样的元数据，那么输出将充斥着未使用的额外类型元数据。
- en: 'An alternative to using `@Injectable` is to explicitly declare the types of
    dependencies using the `@Inject` decorator. Take a look at the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Injectable`的另一种方法是使用`@Inject`装饰器显式声明依赖项的类型。看一下下面的例子：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that the preceding code has equivalent semantics to the code that
    uses `@Injectable`, as mentioned earlier. The only difference is that Angular
    2 will get the type of dependency (that is, the token associated with it) explicitly
    (directly from the metadata added by the `@Injector` decorator) compared to the
    case where `@Injectable` is used, when it will look at the metadata generated
    by the compiler.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着前面的代码与使用`@Injectable`的代码具有等效的语义，正如前面提到的。唯一的区别是，Angular 2将会直接从`@Injector`装饰器添加的元数据中获取依赖项的类型（即与之关联的标记），而不是使用`@Injectable`时，它将查看编译器生成的元数据。
- en: Instantiating an injector
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化注入器
- en: 'Now, let''s create an instance of an injector in order to use it for the instantiation
    of registered tokens:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个注入器的实例，以便用它来实例化已注册的标记：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We create an instance of the `Injector` using its static method called `resolveAndCreate`.
    This is a factory method that accepts an array of providers as argument and returns
    a new `Injector`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`resolveAndCreate`的静态方法创建`Injector`的一个实例。这是一个工厂方法，接受一个提供者数组作为参数，并返回一个新的`Injector`。
- en: '`resolve` means that the providers will go through a resolution process, which
    includes some internal processing (flattening multiple nested arrays and converting
    individual providers into an array). Later, the injector can instantiate any of
    the dependencies for which we have registered providers based on the rules the
    providers encapsulate.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`意味着提供者将经过解析过程，其中包括一些内部处理（展平多个嵌套数组并将单个提供者转换为数组）。稍后，注入器可以根据提供者封装的规则实例化我们已注册提供者的任何依赖项。'
- en: In our case, we used the `provide` method in order to explicitly tell the Angular
    2 DI mechanism to use the value `42` when the `BUFFER_SIZE` token is required.
    The other two providers are implicit. Angular 2 will instantiate them by invoking
    the provided class with the `new` operator once all of their dependencies are
    resolved.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用`provide`方法明确告诉Angular 2 DI机制在需要`BUFFER_SIZE`标记时使用值`42`。另外两个提供者是隐式的。一旦它们的所有依赖项都得到解决，Angular
    2将通过使用`new`运算符调用提供的类来实例化它们。
- en: 'We request the `BUFFER_SIZE` value in the constructor of the `Buffer` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Buffer`类的构造函数中请求`BUFFER_SIZE`的值：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we used the `@Inject` parameter decorator. It hints
    the DI mechanism that the first argument of the constructor of the `Buffer` class
    should be instantiated with the provider associated with the `BUFFER_SIZE` token
    passed to the injector.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`@Inject`参数装饰器。它提示DI机制，`Buffer`类的构造函数的第一个参数应该用与传递给注入器的`BUFFER_SIZE`标记相关联的提供者实例化。
- en: Introducing forward references
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入前向引用
- en: 'Angular 2 introduced the concept of **forward references**. It is required
    due to the following reasons:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2引入了**前向引用**的概念。这是由于以下原因所必需的：
- en: ES2015 classes are not hoisted.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES2015类不会被提升。
- en: Allow resolution of the dependencies that are declared after the declaration
    of the dependent providers.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许解析在声明依赖提供者之后声明的依赖项。
- en: In this section, we're going to explain the problem that forward references
    solve and the way we can take advantage of them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释前向引用解决的问题以及我们可以利用它们的方式。
- en: 'Now, let''s suppose that we have defined the `Buffer` and `Socket` classes
    in the opposite order:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们已经以相反的顺序定义了`Buffer`和`Socket`类：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have the exact same dependencies as in the ones in the previous example,
    but in this case, the `Socket` class definition precedes the definition of the
    `Buffer` class. Note that the value of the `Buffer` identifier will equal `undefined`
    until the JavaScript virtual machine evaluates the declaration of the `Buffer`
    class. However, the metadata for the types of dependencies that `Socket` accepts
    will be generated and placed right after the `Socket` class definition. This means
    that along with the interpretation of the generated JavaScript, the value of the
    `Buffer` token will equal `undefined`—that is, as a type of dependency (or in
    the context of the DI mechanism of Angular 2, its token), the framework will get
    an invalid value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有与前面例子中相同的依赖关系，但在这种情况下，`Socket`类的定义在`Buffer`类的定义之前。请注意，直到JavaScript虚拟机评估`Buffer`类的声明之前，`Buffer`标识符的值将等于`undefined`。然而，`Socket`接受的依赖项类型的元数据将在`Socket`类定义之后生成并放置。这意味着除了解释生成的JavaScript之外，`Buffer`标记的值将等于`undefined`——也就是说，在Angular
    2的DI机制的上下文中，框架将获得一个无效的值。
- en: 'Running the preceding snippet will result in a runtime error of the following
    form:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段将导致以下形式的运行时错误：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The best way to resolve this issue is by swapping the definitions with their
    proper order. Another way we can proceed is to take advantage of a solution that
    Angular 2 provides: a forward reference:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方法是通过交换定义的顺序。我们可以继续的另一种方法是利用Angular 2提供的解决方案：前向引用：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding snippet demonstrates how we can take advantage of forward references.
    All we need to do is use the `@Inject` parameter decorator and pass the result
    of the invocation of the `forwardRef` function to it. The `forwardRef` function
    is a higher-order function that accepts a single argument—another function that
    is responsible for returning the token associated with the dependency (or more
    precisely associated with its provider) that needs to be injected. This way, the
    framework provides a way to defer the process of resolving the types (tokens)
    of dependencies.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段演示了我们如何利用前向引用。我们所需要做的就是使用`@Inject`参数装饰器，并将`forwardRef`函数的调用结果传递给它。`forwardRef`函数是一个高阶函数，接受一个参数——另一个负责返回与需要被注入的依赖项（或更准确地说是与其提供者相关联的）关联的标记的函数。这样，框架提供了一种推迟解析依赖项类型（标记）的过程的方式。
- en: The token of the dependency will be resolved the first time `Socket` needs to
    be instantiated, unlike the default behavior in which the token is required at
    the time of the declaration of the given class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的标记将在首次需要实例化`Socket`时解析，而不是默认行为，在给定类的声明时需要标记。
- en: Configuring providers
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置提供程序
- en: 'Now, let''s take a look at an example similar to the one used earlier but with
    a different configuration of the injector:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个类似于之前使用的示例，但注入器的配置不同的示例。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, inside of the provider, we explicitly declared that we want the
    `Buffer` class to be used for the construction of the dependency with a token
    equal to the reference of the `Buffer` class. We do the exact same thing for the
    dependency associated with the `Socket` token; but this time, we provide the `Socket`
    class instead. This is how Angular 2 will proceed when we omit the call of the
    `provide` function and pass only a reference to a class instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在提供程序内部，我们明确声明了我们希望使用`Buffer`类来构建具有与`Buffer`类引用相等的标记的依赖项。对于与`Socket`标记关联的依赖项，我们做了完全相同的事情；但这次，我们提供了`Socket`类。这就是当我们省略`provide`函数的调用并只传递一个类的引用时，Angular
    2将如何进行。
- en: Explicitly declaring the class used for the instantiation of the same class
    may seem quite worthless, and given the examples we looked at so far, this'll
    be completely correct. In some cases, however, we might want to provide a different
    class for the instantiation of a dependency associated with given class token.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 明确声明用于实例化相同类的类可能看起来毫无价值，鉴于我们迄今为止看到的例子，这完全正确。然而，在某些情况下，我们可能希望为与给定类标记关联的依赖项的实例化提供不同的类。
- en: 'For instance, let''s suppose we have the `Http` service that is used in a service
    called `UserService`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个名为`Http`的服务，它在一个名为`UserService`的服务中使用：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `UserService` service uses `Http` for communication with a RESTful service.
    We can instantiate `UserService` using `injector.get(UserService)`. This way,
    the constructor of `UserService` invoked by the injector''s `get` method will
    accept an instance of the `Http` service as an argument. However, if we want to
    test `UserService`, we don''t really need to make HTTP calls to the RESTful service.
    In case of unit testing, we can provide a dummy implementation that will only
    fake these HTTP calls. In order to inject an instance of a different class to
    the `UserService` service, we can change the configuration of the injector to
    the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService`服务使用`Http`与RESTful服务进行通信。我们可以使用`injector.get(UserService)`来实例化`UserService`。这样，由注入器的`get`方法调用的`UserService`构造函数将接受`Http`服务的实例作为参数。然而，如果我们想要测试`UserService`，我们实际上并不需要对RESTful服务进行HTTP调用。在单元测试的情况下，我们可以提供一个虚拟实现，只会伪造这些HTTP调用。为了向`UserService`服务注入一个不同类的实例，我们可以将注入器的配置更改为以下内容：'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, when we instantiate `UserService`, it's constructor will receive a reference
    to an instance of the `DummyHttp` service. This code is available at `ch5/ts/configuring-providers/dummy-http.ts`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们实例化`UserService`时，它的构造函数将接收一个`DummyHttp`服务实例的引用。这段代码位于`ch5/ts/configuring-providers/dummy-http.ts`中。
- en: Using existing providers
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用现有的提供程序
- en: 'Another way to proceed is using the `useExisting` property of the provider''s
    configuration object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用提供程序配置对象的`useExisting`属性：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding snippet, we registered three tokens: `DummyService`, `UserService`,
    and `Http`. We declared that we want to bind the `Http` token to the existing
    token, `DummyService`. This means that when the `Http` service is requested, the
    injector will find the provider for the token used as the value of the `useExisting`
    property and instantiate it or get the value associated with it. We can think
    of `useExisting` as creating an alias of the given token:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们注册了三个令牌：`DummyService`、`UserService`和`Http`。我们声明要将`Http`令牌绑定到现有令牌`DummyService`。这意味着当请求`Http`服务时，注入器将找到用作`useExisting`属性值的令牌的提供者并实例化它或获取与之关联的值。我们可以将`useExisting`视为创建给定令牌的别名：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding snippet will create an alias of the `Http` token to the `DummyHttp`
    token. This means that once the `Http` token is requested, the call will be forwarded
    to the provider associated with the `DummyHttp` token, which will be resolved
    to the value `dummyHttp`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段将创建一个`Http`令牌到`DummyHttp`令牌的别名。这意味着一旦请求`Http`令牌，调用将转发到与`DummyHttp`令牌关联的提供者，该提供者将解析为值`dummyHttp`。
- en: Defining factories for instantiating services
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义实例化服务的工厂
- en: Now, let's suppose we want to create a complex object, for example, one that
    represents a **Transport Layer Security** (**TLS**) connection. A few of the properties
    of such an object are a socket, a set of crypto protocols, and a certificate.
    In the context of this problem, the features of the DI mechanism of Angular 2
    we have so far looked at might seem a bit limited.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想创建一个复杂的对象，例如代表**传输层安全**（**TLS**）连接的对象。这样一个对象的一些属性是套接字、一组加密协议和证书。在这个问题的背景下，我们迄今为止看到的Angular
    2的DI机制的特性似乎有点有限。
- en: For example, we might need to configure some of the properties of the `TLSConnection`
    class without coupling the process of its instantiation with all the configuration
    details (choose appropriate crypto algorithms, open the TCP socket over which
    we will establish the secure connection, and so on).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能需要配置`TLSConnection`类的一些属性，而不将其实例化过程与所有配置细节耦合在一起（选择适当的加密算法，打开我们将建立安全连接的TCP套接字等）。
- en: 'In this case, we can take advantage of the `useFactory` property of the provider''s
    configuration object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以利用提供者配置对象的`useFactory`属性：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code seems a bit complex at first, but let''s take a look at
    it step by step. We can start with the parts we''re already familiar with:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码一开始似乎有点复杂，但让我们一步一步地来看看它。我们可以从我们已经熟悉的部分开始：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Initially, we registered a number of providers: `Buffer`, `Socket`, `Certificate`,
    and `Crypto`. Just like in the preceding example, we also registered the `BUFFER_SIZE`
    token and associated it with the value `42`. This means that we can already create
    objects of the `Buffer`, `Socket`, `Certificate`, and `Crypto` types:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们注册了一些提供者：`Buffer`、`Socket`、`Certificate`和`Crypto`。就像前面的例子一样，我们还注册了`BUFFER_SIZE`令牌，并将其与值`42`关联起来。这意味着我们已经可以创建`Buffer`、`Socket`、`Certificate`和`Crypto`类型的对象：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can create and configure an instance of the `TLSConnection` object in the
    following way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式创建和配置`TLSConnection`对象的实例：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, if we register a provider that has the `TLSConnection` token as a dependency,
    we will prevent the dependency injection mechanism of Angular from taking care
    of the dependency resolution process. In order to handle this problem, we can
    use the `useFactory` property of the provider''s configuration object. This way,
    we can specify a function in which we can manually create the instance of the
    object associated with the provider''s token. We can use the `useFactory` property
    together with the `deps` property in order to specify the dependencies to be passed
    to the factory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们注册一个具有`TLSConnection`标记作为依赖项的提供者，我们将阻止Angular的依赖注入机制处理依赖项解析过程。为了解决这个问题，我们可以使用提供者配置对象的`useFactory`属性。这样，我们可以指定一个函数，在这个函数中我们可以手动创建与提供者标记相关联的对象的实例。我们可以将`useFactory`属性与`deps`属性一起使用，以指定要传递给工厂的依赖项：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding snippet, we defined the factory function used for the instantiation
    of `TLSConnection`. As dependencies, we declared `Socket`, `Certificate`, and
    `Crypto`. These dependencies are resolved by the DI mechanism of Angular 2 and
    injected to the factory function. You can take a look at the entire implementation
    and play with it at `ch5/ts/configuring-providers/factory.ts`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们定义了用于实例化`TLSConnection`的工厂函数。作为依赖项，我们声明了`Socket`，`Certificate`和`Crypto`。这些依赖项由Angular
    2的DI机制解析并注入到工厂函数中。您可以在`ch5/ts/configuring-providers/factory.ts`中查看整个实现并进行操作。
- en: Child injectors and visibility
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子注入器和可见性
- en: In this section, we're going to take a look at how we can build a hierarchy
    of injectors. This is a completely new concept introduced by Angular 2\. Each
    injector can have zero or one parent injectors and each parent injector can have
    zero or more children, respectively. In contrast to AngularJS 1.x, where all the
    registered providers are stored in a flat structure in Angular 2, they are stored
    in a tree. The flat structure is more limited; for instance, it doesn't support
    the namespacing of tokens; that is, we cannot declare different providers for
    the same token, which might be required in some cases. So far, we looked at an
    example of injector that doesn't have any children or a parent. Now let's build
    a hierarchy of injectors!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何构建注入器的层次结构。这是Angular 2引入的一个全新概念。每个注入器可以有零个或一个父注入器，每个父注入器可以分别有零个或多个子注入器。与AngularJS
    1.x相比，在Angular 2中，所有注册的提供者都存储在树中，而不是存储在一个扁平的结构中。扁平结构更为有限；例如，它不支持标记的命名空间；也就是说，我们不能为同一个标记声明不同的提供者，这在某些情况下可能是必需的。到目前为止，我们看了一个没有任何子节点或父节点的注入器的示例。现在让我们构建一个注入器的层次结构！
- en: 'In order to gain a better understanding of this hierarchical structure of injectors,
    let''s take a look at the following figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这种注入器的层次结构，让我们看一下下图：
- en: '![Child injectors and visibility](../images/00022.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![子注入器和可见性](../images/00022.jpeg)'
- en: 'Here, we see a tree where each node is an injector and each of these injectors
    keeps a reference to its parent. Injector **House** has three child injectors:
    **Bathroom**, **Kitchen**, and **Garage**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个树，其中每个节点都是一个注入器，每个注入器都保留对其父级的引用。注入器**House**有三个子注入器：**Bathroom**，**Kitchen**和**Garage**。
- en: '**Garage** has two children: **Car** and **Storage**. We can think of these
    injectors as containers with registered providers inside of them.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Garage**有两个子节点：**Car**和**Storage**。我们可以将这些注入器视为内部注册了提供者的容器。'
- en: Let's suppose we want to get the value of the provider associated with the token
    **Tire**. If we use the injector **Car**, this means that Angular 2's DI mechanism
    will try to find the provider associated with this token in **Car** and all of
    its parents, **Garage** and **House**, until it finds it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取与标记**Tire**相关联的提供程序的值。如果我们使用注射器**Car**，这意味着Angular 2的DI机制将尝试在**Car**及其所有父级**Garage**和**House**中查找与此标记相关联的提供程序，直到找到为止。
- en: Building a hierarchy of injectors
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建注射器的层次结构
- en: 'In order to gain a better understanding of the previous paragraph, let''s take
    a look at this simple example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解上一段，让我们看一个简单的例子：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The imports are omitted, since they are not essential to explain the preceding
    snippet. We have two services, `Http` and `UserService`, where `UserService` depends
    on the `Http` service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们对于解释前面的片段并不重要，所以省略了导入部分。我们有两个服务，`Http`和`UserService`，其中`UserService`依赖于`Http`服务。
- en: Initially, we created an injector using the `resolveAndCreate` static method
    of the `Injector` class. We passed an implicit provider to this injector, which
    will later be resolved to a provider with an `Http` token. Using `resolveAndCreateChild`,
    we resolved the passed providers and instantiated an injector, which points to
    `parentInjector` (so we get the same relation as the one between **Garage** and
    **House** on the diagram above).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们使用`Injector`类的`resolveAndCreate`静态方法创建了一个注射器。我们向此注射器传递了一个隐式提供程序，稍后将解析为具有`Http`标记的提供程序。使用`resolveAndCreateChild`，我们解析了传递的提供程序并实例化了一个注射器，该注射器指向`parentInjector`（因此我们得到与上图中**Garage**和**House**之间相同的关系）。
- en: Now, using `childInjector.get(UserService)`, we are able to get the value associated
    with the `UserService` token. Similarly, using `childInjector.get(Http)` and `parentInjector.get(Http)`,
    we get the same value associated with the `Http` token. This means that `childInjector`
    asks its parent for the value associated with the requested token.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`childInjector.get(UserService)`，我们能够获取与`UserService`标记相关联的值。类似地，使用`childInjector.get(Http)`和`parentInjector.get(Http)`，我们得到与`Http`标记相关联的相同值。这意味着`childInjector`向其父级请求与请求的标记相关联的值。
- en: However, if we try to use `parentInjector.get(UserService)`, we won't be able
    to get the value associated with the token, since in this injector, we don't have
    a registered provider with this token.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试使用`parentInjector.get(UserService)`，我们将无法获取与该标记相关联的值，因为在此注射器中，我们没有注册具有此标记的提供程序。
- en: Configuring dependencies
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置依赖关系
- en: Now that we're familiar with the injectors' hierarchy, let's see how we can
    get the dependencies from the appropriate injectors in it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了注射器的层次结构，让我们看看如何从其中获取适当注射器的依赖关系。
- en: Using the @Self decorator
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用@Self装饰器
- en: 'Now let''s suppose we have the following configuration:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有以下配置：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can instantiate the `UserService` token using:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方法实例化`UserService`标记：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `UserService`, we can declare that we want to get the `Channel` dependency
    from the current injector (that is, `childInjector`) using the `@Self` decorator:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserService`中，我们可以声明我们要使用`@Self`装饰器从当前注射器（即`childInjector`）获取`Channel`依赖项的值：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Although this is going to be the default behavior during the instantiation
    of the `UserService`, using `@Self`, we can be more explicit. Let''s suppose we
    change the configuration of `childInjector` to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在实例化`UserService`期间，这将是默认行为，但使用`@Self`，我们可以更加明确。假设我们将`childInjector`的配置更改为以下内容：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we keep the `@Self` decorator in the `UserService` constructor and try to
    instantiate `UserService` using `childInjector`, we will get a runtime error because
    of the missing provider for `Channel`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`UserService`构造函数中保留`@Self`装饰器，并尝试使用`childInjector`实例化`UserService`，由于缺少`Channel`的提供程序，我们将收到运行时错误。
- en: Skipping the self injector
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过自注入器
- en: 'In some cases, especially while injecting the dependencies of UI components,
    we may want to use the provider registered in the parent injector instead of the
    one registered in the current injector. We can achieve this behavior by taking
    advantage of the `@SkipSelf` decorator. For instance, let''s suppose we have the
    following definition of the class `Context`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，特别是在注入UI组件的依赖项时，我们可能希望使用父注入器中注册的提供者，而不是当前注入器中注册的提供者。我们可以通过利用`@SkipSelf`装饰器来实现这种行为。例如，假设我们有以下类`Context`的定义：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Each instance of the `Context` class has a parent. Now let''s build a hierarchy
    of two injectors, which will allow us to create a context with a parent context:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`类的每个实例都有一个父级。现在让我们构建一个包含两个注入器的层次结构，这将允许我们创建一个具有父上下文的上下文：'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since the root context doesn't have a parent, we will set the value of its provider
    to be `new Context(null)`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于根上下文没有父级，我们将设置其提供者的值为`new Context(null)`。
- en: 'If we want to instantiate the child context, we can use:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要实例化子上下文，我们可以使用：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the instantiation of the child, `Context` will be used by the provider registered
    within the `childInjector`. However, as a dependency it accepts an object which
    is an instance of the `Context` class. Such classes exist in the same injector,
    which means that Angular will try to instantiate it, but it has a dependency of
    the `Context` type. This process will lead to an infinite loop that will cause
    a runtime error.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于子级的实例化，`Context`将由`childInjector`中注册的提供者使用。但是，作为一个依赖项，它接受一个`Context`类的实例对象。这些类存在于同一个注入器中，这意味着Angular将尝试实例化它，但它具有`Context`类型的依赖项。这个过程将导致一个无限循环，从而导致运行时错误。
- en: 'In order to prevent it from happening, we can change the definition of `Context`
    in the following way:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们可以以以下方式更改`Context`的定义：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only change that we introduced is the addition of the parameter decorator
    `@SkipSelf`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入的唯一变化是参数装饰器`@SkipSelf`的添加。
- en: Having optional dependencies
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有可选依赖项
- en: Angular 2 introduces the `@Optional` decorator, which allows us to deal with
    dependencies that don't have a registered provider associated with them. Suppose
    a dependency of a provider is not available in any of the target injectors responsible
    for its instantiation. If we use the `@Optional` decorator, during the instantiation
    of the dependent provider for value of the missing dependency will be passed `null`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2引入了`@Optional`装饰器，它允许我们处理没有与之关联的已注册提供者的依赖项。假设一个提供者的依赖项在负责其实例化的任何目标注入器中都不可用。如果我们使用`@Optional`装饰器，在实例化缺失依赖项的依赖提供者时，缺失依赖项的值将被传递为`null`。
- en: 'Now let''s take a look at the following example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个例子：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, we defined an abstract class called `SortingAlgorithm` and a class
    called `Collection`, which accepts an instance of a concrete class as a dependency
    that extends `SortingAlgorithm`. Inside of the `Collection` constructor, we set
    the `sort` instance property to the passed dependency of the `SortingAlgorithm`
    type or a default sorting algorithm implementation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们定义了一个名为`SortingAlgorithm`的抽象类和一个名为`Collection`的类，它接受一个扩展`SortingAlgorithm`的具体类的实例作为依赖项。在`Collection`构造函数内，我们将`sort`实例属性设置为传递的`SortingAlgorithm`类型的依赖项或默认的排序算法实现。
- en: We didn't define any providers for the `SortingAlgorithm` token in the injector
    we configured. So, if we want to get an instance of the `Collection` class using
    `injector.get(Collection)`, we'll get a runtime error. This means that if we want
    to get an instance of the `Collection` class using the DI mechanism of the framework,
    we must register a provider for the `SortingAlgorithm` token, although we can
    fall back to the default sorting algorithm's implementation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在我们配置的注入器中为`SortingAlgorithm`令牌定义任何提供者。因此，如果我们想使用`injector.get(Collection)`来获取`Collection`类的实例，我们将会得到一个运行时错误。这意味着，如果我们想使用框架的DI机制获取`Collection`类的实例，我们必须为`SortingAlgorithm`令牌注册一个提供者，尽管我们可以回退到默认排序算法的实现。
- en: Angular 2 provides a solution to this problem with the `@Optional` decorator.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2通过`@Optional`装饰器为这个问题提供了解决方案。
- en: 'This is how we can approach the problem using the `@Optional` decorator provided
    by the framework:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以使用框架提供的`@Optional`装饰器来解决问题的方式。
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding snippet, we declared the `sort` dependency as optional, which
    means that if Angular 2 doesn't find any provider for its token, it will pass
    the `null` value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们将`sort`依赖声明为可选的，这意味着如果Angular 2找不到其令牌的任何提供者，它将传递`null`值。
- en: Using multiproviders
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多提供者
- en: Multiproviders are another new concept brought to the Angular 2 DI mechanism.
    They allow us to associate multiple providers with the same token. This can be
    quite useful if we're developing a third-party library that comes with some default
    implementations of different services, but you want to allow the users to extend
    it with custom ones. They are also exclusively used to declare multiple validations
    over a single control in the Angular 2 form module. We will explain this module
    in [Chapter 6](part0062_split_000.html#1R42S1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 6. Working with the Angular 2 Router and Forms"), *Working with the Angular
    2 Router and Forms*, and [Chapter 7](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 7. Explaining Pipes and Communicating with RESTful Services"), *Explaining
    Pipes and Communicating with RESTful Services*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 多提供者是Angular 2 DI机制引入的另一个新概念。它们允许我们将多个提供者与相同的令牌关联起来。如果我们正在开发一个带有不同服务的默认实现的第三方库，但是你想允许用户使用自定义的实现来扩展它，这将非常有用。它们还专门用于在Angular
    2表单模块中对单个控件进行多个验证。我们将在[第6章](part0062_split_000.html#1R42S1-a118c4c18dd64e8ab73e171b466b6582
    "第6章。使用Angular 2路由器和表单")和[第7章](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "第7章。解释管道和与RESTful服务通信")中解释这个模块。
- en: Another sample of an applicable use case of multiproviders is what Angular 2
    uses for event management in their WebWorkers implementation. They create multiproviders
    for event management plugins. Each of the providers returns a different strategy,
    which supports a different set of events (touch events, keyboard events, and so
    on). Once a given event occurs, they can choose the appropriate plugin that handles
    it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个适用于多提供者的用例示例是Angular 2在其WebWorkers实现中用于事件管理的。他们为事件管理插件创建了多提供者。每个提供者返回一个不同的策略，支持不同的事件集（触摸事件、键盘事件等）。一旦发生特定事件，他们可以选择处理它的适当插件。
- en: 'Let''s take a look at an example that illustrates the typical usage of multiproviders:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，说明了多提供者的典型用法：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding snippet, we declared a constant called `VALIDATOR` with a new
    instance of `OpaqueToken`. We also created an injector where we registered three
    providers—two of them are used as value functions that, based on different criteria,
    validate instances of the class `Employee`. These functions are of the type `EmployeeValidator`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为`VALIDATOR`的常量，其中包含`OpaqueToken`的新实例。我们还创建了一个注入器，在那里我们注册了三个提供程序——其中两个被用作值函数，根据不同的标准，验证`Employee`类的实例。这些函数的类型是`EmployeeValidator`。
- en: 'In order to declare that we want the injector to pass all the registered validators
    to the constructor of the class `Employee`, we need to use the following constructor
    definition:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明我们希望注入器将所有注册的验证器传递给`Employee`类的构造函数，我们需要使用以下构造函数定义：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, we declared a class `Employee` that accepts a single
    dependency—an array of `EmployeeValidators`. In the method `validate`, we applied
    the individual validators over the current class instance and filtered the results
    in order to get only the ones that have returned an error message.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个名为`Employee`的类，它接受一个依赖项——一个`EmployeeValidators`数组。在`validate`方法中，我们对当前类实例应用了各个验证器，并过滤结果，以便只获取返回错误消息的验证器。
- en: Notice that the constructor argument `validators` is of the `EmployeeValidator[]`
    type. Since we can't use the type "array of objects" as a token for a provider,
    because it is not a valid type reference, we need to use the `@Inject` parameter
    decorator.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意构造函数参数`validators`的类型是`EmployeeValidator[]`。由于我们不能将类型“对象数组”用作提供程序的标记，因为它不是有效的类型引用，所以我们需要使用`@Inject`参数装饰器。
- en: Using DI with components and directives
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在组件和指令中使用DI
- en: In [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*, when we developed our first
    Angular 2 directive, we saw how we can take advantage of the DI mechanism to inject
    services into our UI-related components (that is, directives and components).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "第4章。使用Angular
    2组件和指令入门")中，*使用Angular 2组件和指令入门*，当我们开发了我们的第一个Angular 2指令时，我们看到了如何利用DI机制将服务注入到我们的UI相关组件（即指令和组件）中。
- en: 'Let''s take a quick look at what we did earlier, but from a DI perspective:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从依赖注入的角度快速看一下我们之前做的事情：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Most of the code from the earlier implementation is omitted because it is not
    directly related to our current focus.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大部分早期实现的代码与我们当前的重点无直接关系，因此被省略。
- en: 'Note that the constructor of `Tooltip` accepts two dependencies:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`Tooltip`的构造函数接受两个依赖项：
- en: An instance of the `ElementRef` class.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementRef`类的一个实例。'
- en: An instance of the `Overlay` class.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Overlay`类的一个实例。'
- en: The types of dependencies are the tokens associated with their providers, and
    the corresponding values from the providers are going to be injected with the
    DI mechanism of Angular 2.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的类型是与其提供程序关联的标记，来自提供程序的相应值将使用Angular 2的DI机制进行注入。
- en: Although the declaration of the dependencies of the `Tooltip` class looks exactly
    the same as what we did in the previous sections, there's neither any explicit
    configuration nor any instantiation of an injector.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Tooltip`类的依赖项声明看起来与我们在之前的部分中所做的完全相同，但既没有任何显式配置，也没有任何注入器的实例化。
- en: Introducing the element injectors
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍元素注入器
- en: 'Under the hood, Angular will create injectors for all the directives and components,
    and add a default set of providers to it. This is the so-called **element injector**
    and is something the framework takes care of itself. The injectors associated
    with the components are called **host injectors**. One of the providers in each
    directive and component injector is associated with the `ElementRef` token; it
    will return a reference to the host element of the directive. But where is the
    provider for the `Overlay` class declared? Let''s take a look at the implementation
    of the top-level component:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Angular将为所有指令和组件创建注入器，并向其添加一组默认提供者。这就是所谓的**元素注入器**，是框架自己处理的事情。与组件关联的注入器称为**宿主注入器**。每个指令和组件注入器中的一个提供者与`ElementRef`令牌相关联；它将返回指令的宿主元素的引用。但是`Overlay`类的提供者在哪里声明？让我们看一下顶层组件的实现：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We configured the element injector for the `App` component by declaring the
    `providers` property inside of the `@Component` decorator. At this point, the
    registered providers are going to be visible by the directive or the component
    associated with the corresponding element injector and the component's entire
    component subtree, unless it is overridden somewhere in the hierarchy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`@Component`装饰器内声明`providers`属性来为`App`组件配置元素注入器。在这一点上，注册的提供者将被相应元素注入器关联的指令或组件以及组件的整个子树所看到，除非在层次结构的某个地方被覆盖。
- en: Declaring providers for the element injectors
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明元素注入器的提供者
- en: Having the declaration of all the providers in the same place might be quite
    inconvenient. For example, imagine we're developing a large-scale application
    that has hundreds of components depending on thousands of services. In this case,
    configuring all the providers in the root component is not a practical solution.
    There will be name collisions when two or more providers are associated to the
    same token. The configuration will be huge and it will be hard to trace where
    the different tokens need to be injected.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有提供者的声明放在同一个地方可能会非常不方便。例如，想象一下，我们正在开发一个大型应用程序，其中有数百个组件依赖于成千上万的服务。在这种情况下，在根组件中配置所有提供者并不是一个实际的解决方案。当两个或更多提供者与相同的令牌相关联时，将会出现名称冲突。配置将会很庞大，很难追踪不同的令牌需要被注入的地方。
- en: 'As we mentioned, Angular 2''s `@Directive` (and respectively `@Component`)
    decorator allows us to introduce directive-specific providers using the `providers`
    property. Here is how we can approach this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，Angular 2的`@Directive`（以及相应的`@Component`）装饰器允许我们使用`providers`属性引入特定于指令的提供者。以下是我们可以采用的方法：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding example overrides the provider for the `Overlay` token in the
    `Tooltip` directive's declaration. This way, Angular will inject an instance of
    `OverlayMock` instead of `Overlay` during the instantiation of the tooltip.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例覆盖了`Tooltip`指令声明中`Overlay`令牌的提供者。这样，Angular在实例化工具提示时将注入`OverlayMock`的实例，而不是`Overlay`。
- en: 'A better way to override the provider is using the `bootstrap` function. We
    can do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖提供者的更好方法是使用`bootstrap`函数。我们可以这样做：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding `bootstrap` call, we provided a different top-level component
    and provider for the `Overlay` service that will return an instance of the `OverlayMock`
    class. This way, we can test the `Tooltip` directive ignoring the implementation
    of `Overlay`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`bootstrap`调用中，我们为`Overlay`服务提供了一个不同的顶层组件和提供者，它将返回`OverlayMock`类的实例。这样，我们可以测试`Tooltip`指令，忽略`Overlay`的实现。
- en: Exploring DI with components
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索组件的依赖注入
- en: Since components are generally directives with views, everything we've seen
    so far regarding how the DI mechanism works with directives is valid for components
    as well. However, because of the extra features that the components provide, we're
    allowed to have further control over their providers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件通常是带有视图的指令，到目前为止我们所看到的关于DI机制如何与指令一起工作的一切对组件也是有效的。然而，由于组件提供的额外功能，我们可以对它们的提供程序有更多的控制。
- en: As we said, the injector associated with each component will be marked as a
    **host** injector. There's a parameter decorator called `@Host`, which allows
    us to retrieve a given dependency from any injector until it reaches the closest
    host injector. This means that by using the `@Host` decorator in a directive,
    we can declare that we want to retrieve the given dependency from the current
    injector or any parent injector until we reach the injector of the closest parent
    component.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，与每个组件关联的注入器将被标记为**宿主**注入器。有一个称为`@Host`的参数装饰器，它允许我们从任何注入器中检索给定的依赖项，直到达到最近的宿主注入器。这意味着通过在指令中使用`@Host`装饰器，我们可以声明我们要从当前注入器或任何父注入器中检索给定的依赖项，直到达到最近父组件的注入器。
- en: The `viewProviders` property added to the `@Component` decorator is in charge
    of achieving even more control.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`@Component`装饰器的`viewProviders`属性负责实现更多的控制。
- en: viewProviders versus providers
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: viewProviders与providers
- en: 'Let''s take a look at an example of a component called `MarkdownPanel`. This
    component will be used in the following way:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个名为`MarkdownPanel`的组件的示例。这个组件将以以下方式使用：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The content of each section of the panel will be translated from the markdown
    to the HTML. We can delegate this functionality to a service called `Markdown`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 面板每个部分的内容将从markdown翻译成HTML。我们可以将这个功能委托给一个名为`Markdown`的服务：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Markdown` service wraps the markdown module in order to make it injectable
    through the DI mechanism.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Markdown`服务将markdown模块包装起来，以便通过DI机制进行注入。'
- en: Now let's implement `MarkdownPanel`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`MarkdownPanel`。
- en: 'In the following snippet, we can find all the important details from the component''s
    implementation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们可以找到组件实现的所有重要细节：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We used the `markdown-panel` selector and set the `viewProviders` property.
    In this case, there''s only a single view provider: the one for the `Markdown`
    service. By setting this property, we declared that all the providers declared
    in it will be accessible from the component itself and all of its **view children**.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`markdown-panel`选择器并设置了`viewProviders`属性。在这种情况下，只有一个单一的视图提供程序：`Markdown`服务的提供程序。通过设置这个属性，我们声明了所有在其中声明的提供程序将可以从组件本身和所有的**视图子级**中访问。
- en: 'Now, let''s suppose we have a component called `MarkdownButton` and we want
    to add it to our template in the following way:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个名为`MarkdownButton`的组件，并且我们希望以以下方式将其添加到我们的模板中：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Markdown` service will not be accessible by the `MarkdownButton` used
    below the `panel-content` element; however, it''ll be accessible if we use the
    button in the component''s template:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Markdown`服务将无法被下面使用`panel-content`元素的`MarkdownButton`访问；但是，如果我们在组件的模板中使用按钮，它将是可访问的：'
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If we need the provider to be visible in all the content and view children,
    all we should do is change the property name of the `viewProviders` property to
    `providers`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要提供程序在所有内容和视图子级中可见，我们只需要将`viewProviders`属性的属性名更改为`providers`。
- en: You can find this example in the file in the examples directory at `ch5/ts/directives/app.ts`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`ch5/ts/directives/app.ts`目录下的文件中找到这个示例。
- en: Using Angular's DI with ES5
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ES5的Angular DI
- en: We are already proficient in using the dependency injection of Angular 2 with
    TypeScript! As we know, we are not limited to TypeScript for the development of
    Angular 2 applications; we can also use ES5, ES2015, and ES2016 (as well as Dart,
    but that is out of the scope of this book).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟练使用TypeScript进行Angular 2的依赖注入！正如我们所知，我们在开发Angular 2应用程序时并不局限于TypeScript；我们也可以使用ES5、ES2015和ES2016（以及Dart，但这超出了本书的范围）。
- en: 'So far, we declared the dependencies of the different classes in their constructor
    using standard TypeScript type annotations. All such classes are supposed to be
    decorated with the `@Injectable` decorator. Unfortunately, some of the other languages
    supported by Angular 2 miss a few of these features. In the following table, we
    can see that ES5 doesn''t support type annotations, classes, and decorators:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在构造函数中使用标准的TypeScript类型注释声明了不同类的依赖关系。所有这些类都应该用`@Injectable`装饰器进行修饰。不幸的是，Angular
    2支持的其他一些语言缺少了一些这些特性。在下表中，我们可以看到ES5不支持类型注释、类和装饰器：
- en: '|   | ES5 | ES2015 | ES2016 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|   | ES5 | ES2015 | ES2016 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Classes | No | Yes | Yes |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 否 | 是 | 是 |'
- en: '| Decorators | No | No | Yes (no parameter decorators) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 装饰器 | 否 | 否 | 是（没有参数装饰器） |'
- en: '| Type annotations | No | No | No |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 类型注释 | 否 | 否 | 否 |'
- en: In this case, how we can take advantage of the DI mechanism in these languages?
    Angular 2 provides an internal JavaScript **Domain Specific Language** (**DSL**),
    which allows us to take advantage of the entire functionality of the framework
    using ES5.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们如何利用这些语言中的DI机制？Angular 2提供了一个内部JavaScript**领域特定语言**（**DSL**），允许我们利用ES5的整个框架功能。
- en: 'Now, let''s translate the `MarkdownPanel` example we took a look at in the
    previous section from TypeScript to ES5\. First, let''s start with the `Markdown`
    service:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们在上一节中看到的`MarkdownPanel`示例从TypeScript翻译成ES5。首先，让我们从`Markdown`服务开始：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We defined a variable called `Markdown` and set its value to the returned result
    from the invocation of `ng.core.Class`. This construct allows us to emulate ES2015
    classes using ES5\. The argument of the `ng.core.Class` method is an object literal,
    which must have the definition of a `constructor` function. As a result, `ng.core.Class`
    will return a JavaScript constructor function with the body of `constructor` from
    the object literal. All the other methods defined within the boundaries of the
    passed parameter will be added to the function's prototype.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Markdown`的变量，并将其值设置为从调用`ng.core.Class`返回的结果。这种构造允许我们使用ES5模拟ES2015类。`ng.core.Class`方法的参数是一个对象字面量，必须包含`constructor`函数的定义。因此，`ng.core.Class`将返回一个JavaScript构造函数，其中包含来自对象字面量的`constructor`的主体。传递参数边界内定义的所有其他方法将被添加到函数的原型中。
- en: 'One problem is solved: we can now emulate classes in ES5; there are two more
    problems left!'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题已经解决：我们现在可以在ES5中模拟类；还有两个问题没有解决！
- en: 'Now, let''s take a look at how we can define the `MarkdownPanel` component:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何定义`MarkdownPanel`组件：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*, we are already familiar with
    the ES5 syntax used to define components. Now, let's take a look at the constructor
    function of `MarkdownPanel` in order to make sure how we can declare the dependencies
    of our components and even classes in general.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "第4章。使用Angular
    2组件和指令入门"), *使用Angular 2组件和指令入门*，我们已经熟悉了用于定义组件的ES5语法。现在，让我们看一下`MarkdownPanel`的构造函数，以确保我们如何声明我们组件甚至一般类的依赖关系。
- en: 'From the preceding snippet, we can note that the value of the constructor is
    not a function this time, but an array instead. This might seem familiar to you
    from AngularJS 1.x, where we are able to declare the dependencies of the given
    service by listing their names:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的片段中，我们可以注意到构造函数的值这次不是一个函数，而是一个数组。这可能让你觉得很熟悉，就像在AngularJS 1.x中一样，我们可以通过列出它们的名称来声明给定服务的依赖项：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although the syntax in Angular 2 is similar, it brings a lot of improvements.
    For instance, we're no longer limited to using strings for the dependencies' tokens.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Angular 2中的语法类似，但它带来了许多改进。例如，我们不再局限于使用字符串来表示依赖项的标记。
- en: 'Now, let''s suppose we want to make the `Markdown` service an optional dependency.
    In this case, we can approach this by passing an array of decorators:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想将`Markdown`服务作为可选依赖项。在这种情况下，我们可以通过传递装饰器数组来实现：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This way, by nesting arrays, we can apply a sequence of decorators: `[[ng.core.Optional()`,
    `ng.core.Self()`, `Markdown]`, `...]`. In this example, the `@Optional` and `@Self`
    decorators will add the associated metadata to the class in the specified order.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过嵌套数组，我们可以应用一系列装饰器：`[[ng.core.Optional()`, `ng.core.Self()`, `Markdown]`, `...]`。在这个例子中，`@Optional`和`@Self`装饰器将按指定的顺序向类添加关联的元数据。
- en: Although using ES5 makes our build simpler and allows us to skip the intermediate
    step of transpilation, which can be tempting, Google's recommendation is to take
    advantage of static typing using TypeScript. This way, we have a much clearer
    syntax, which carries better semantics with less typing and provides us with great
    tooling.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用ES5使我们的构建更简单，并允许我们跳过转译的中间步骤，这可能很诱人，但谷歌的建议是利用TypeScript的静态类型优势。这样，我们就有了更清晰的语法，更少的输入，更好的语义，并提供了强大的工具。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the DI mechanism of Angular 2\. We briefly discussed
    the positives of using dependency injection in our projects by introducing it
    in the context of the framework. The second step in our journey was how to instantiate
    and configure injectors; we also explained the injectors' hierarchy and the visibility
    of the registered providers. In order to enforce a better separation of concerns,
    we mentioned how we can inject services carrying the business logic of our application
    in our directives and components. The last point we took a look at was how we
    can use the DI mechanism with the ES5 syntax.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Angular 2的DI机制。我们简要讨论了在项目中使用依赖注入的优点，通过在框架的上下文中引入它。我们旅程的第二步是如何实例化和配置注入器；我们还解释了注入器的层次结构和已注册提供者的可见性。为了更好地分离关注点，我们提到了如何在指令和组件中注入承载应用程序业务逻辑的服务。我们最后关注的一点是如何使用ES5语法与DI机制配合使用。
- en: In the next chapter, we'll introduce the new routing mechanism of the framework.
    We'll explain how we can configure the component-based router and add multiple
    views to our application. Another important topic we are going to cover is the
    new form module. By building a simple application, we will demonstrate how we
    can create and manage forms.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍框架的新路由机制。我们将解释如何配置基于组件的路由器，并向我们的应用程序添加多个视图。我们将要涵盖的另一个重要主题是新的表单模块。通过构建一个简单的应用程序，我们将演示如何创建和管理表单。
