- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real Time with Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web platform offers standards and capabilities to send data in real time.
    With real-time technologies, we can implement chat features and multiplayer UIs
    for real-time collaboration and interactions. We have seen several apps with real-time
    features grow in popularity and redefine their product categories, such as Google
    Docs and Figma. In this chapter, we will learn about real-time UIs with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is split into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with real-time technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building real-time UIs with Remix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will compare real-time technologies and discuss the requirements for
    hosting providers and server environments. Next, we will outline implementations
    with Remix. Finally, we will implement a simple real-time UI in BeeRich by utilizing
    **Server-Sent** **Events** (**SSE**).
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand the requirements for working
    with real-time technologies in Remix. You will also be able to name the differences
    between polling, SSE, and WebSocket. Finally, you will know how to work with SSE
    in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/14-real-time-with-remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/14-real-time-with-remix).
    No additional setup is required for this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with real-time technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web platform offers different protocols and standards for real-time communication.
    In this section, we will review different technologies and techniques and discuss
    the requirements for utilizing them with Remix. We will discuss polling, learn
    about SSE, and review the WebSocket API. First, let’s have a look at polling techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding polling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polling is a client-pull technique in which the client requests data from the
    server. Instead of relying on a server to push updates, polling utilizes intervals
    to check for the latest data from the server.
  prefs: []
  type: TYPE_NORMAL
- en: We can differentiate between short and long polling. Short polling sends requests
    in time-based intervals to the server. The server responds immediately, either
    with new data or indicating nothing has changed. With long polling, the server
    only responds once new data is available, keeping the request unanswered until
    then. The client sends a new request once the server responds or the request times
    out.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of polling is that it does not require the server environment
    and hosting provider to support WebSockets, HTTP/2, or long-running streaming
    responses. Polling can be a great compromise when working with server environments
    and hosting providers that do not support real-time protocols and standards. It
    is also simpler to implement and potentially a great tool for prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of polling is its wasteful resource consumption and delayed
    real-time behavior. Short polling creates many unnecessary requests that yield
    no new data, while long polling forces the server to handle idle requests until
    new data is received. Short polling may also delay real-time updates based on
    the interval retry time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a look at SSE.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SSE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSE is an HTTP-based server push standard and part of the HTML5 spec. SSE requires
    both a client and a server. The client requests a connection using the `EventSource`
    API; the server implements an endpoint that returns a stream response with the
    `text/event-stream` media type.
  prefs: []
  type: TYPE_NORMAL
- en: The stream response creates a one-way communication line from the server to
    the client. This allows the server to send events to the client without the need
    for the client to use polling.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of SSE is reduced resource consumption. The client does not need
    to send unnecessary requests to the server. Instead, the server only sends events
    to the client once an update is available.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of SSE is the long-running HTTP connection, which needs to
    be maintained by the server. Additionally, SSE only provides a one-way communication
    line. The client is not able to send messages to the server. Finally, HTTP/1 only
    allows servers to maintain six concurrent connections at a time. Luckily, most
    server environments support HTTP/2, but the HTTP/1 limitation may still be relevant,
    depending on your hosting provider.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WebSocket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSocket is a communication protocol that’s implemented through the web’s WebSocket
    API and creates a persistent two-way communication line. Unlike SSE and polling
    solutions, WebSocket operates directly on TCP rather than HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Once a WebSocket connection has been established, both parties (for example,
    the browser and the server) can send and receive messages simultaneously. Since
    the protocol operates on TCP, it can transfer not only UTF-8-encoded data but
    also binary data, making it a performant lower-level protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of WebSocket connections is their two-way communication channel
    and the increased performance from using TCP directly. However, WebSocket connections
    are not supported by all hosting providers and JavaScript runtimes as they require
    long-running servers. The WebSocket API is also the most complex to implement
    and utilize, requiring the setup of a WebSocket server.
  prefs: []
  type: TYPE_NORMAL
- en: All three techniques enable us to implement real-time capabilities. Polling
    lets us build multiplayer UIs, even if our server environment does not support
    streaming responses or setting up WebSocket servers. SSE provides a simpler way
    for the server to send events and data to the client. The WebSocket API is a lower-level
    protocol that allows us to create bi-directional communication channels capable
    of creating performant and scalable multiplayer UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the differences between polling, SSE, and the WebSocket
    API, we can implement a real-time UI in BeeRich. In the next section, we will
    do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Building real-time UIs with Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BeeRich uses Remix’s Express.js adapter and runs on a long-running server. As
    such, BeeRich can take advantage of polling, SSE, and the WebSocket API to implement
    real-time features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Short polling is simple to set up. We can implement short polling in Remix
    by using Remix’s `useRevalidator` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `revalidate` function of the `useRevalidator` hook triggers a `loader` revalidation.
    This allows us to refetch all loader data, similar to how Remix refetches all
    loader data after executing an `action` function.
  prefs: []
  type: TYPE_NORMAL
- en: Since the WebSocket protocol is TCP-based, we would need to create the WebSocket
    server and endpoint outside of our Remix application using the `server.js` file
    at the root of our project or using a different server environment altogether.
    This is doable but outside the scope of this book. Instead, we will review how
    to use SSE with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Remix’s `loader` and `action` functions can create HTTP-based resource routes.
    We can implement an SSE endpoint on a long-running server environment by using
    a `loader` function to return a stream response with the `text/event-stream` media
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We aim to inform all devices and open browser tabs that are logged in with
    the same user of expense and invoice data changes. We also want to revalidate
    the UI whenever such a change is detected. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new `server-sent-events` folder in `app/modules/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create an `events.server.ts` file in the new folder and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `EventEmitter` API from Node.js and declare a globally accessible
    event emitter for our server environment. The `EventEmitter` object can be used
    to listen to and emit events. We will utilize the `emit` function in our `action`
    functions to communicate data changes to the server-sent event connection handler
    code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the `EventEmitter` API has nothing to do with SSE but provides a neat
    way for event-based communication in our Node.js server environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, implement an `eventStream` helper function in `events.server.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, implement the endpoint responsible for delivering the event stream response.
    Create a new `/sse.tsx` route in the `/``routes` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the global `emitter` object to all expense and invoice `action` functions.
    Whenever an action succeeds, we want to emit the `server-change` event on the
    server and trigger a new event to all connected clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For instance, in the `action` function of the `dashboard.expenses._index.tsx`
    route module, add the event emitter call before returning the redirect. This ensures
    the event is only emitted after the action has succeeded and the database has
    been updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import { emitter } from '~/modules/server-sent-events/events.server';
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After adding the `emit` function call to the expense and invoice creation actions,
    add `emit` function calls to the `handleDelete`, `handleUpdate`, and `handleRemoveAttachment`
    functions in the `dashboard.expenses.$id._index.tsx` route module. Again, call
    `emit` after the data mutation has succeeded to avoid race conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you also apply the same changes to the invoice `action` functions.
    You can always review the final implementation in the solution folder of this
    chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s turn our attention to the client environment. Add a new `event-source.tsx`
    file in the `app/modules/server-sent-events` folder and implement the event stream
    connection request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, import the new hook in the `dashboard.tsx` route module and call the
    hook in the route module component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application locally by calling `npm run dev` in a terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the implementation by opening BeeRich in two or more tabs. You can also
    run BeeRich in several browsers to investigate the real-time behavior. Log in
    as the same user and update and delete invoices and expenses. Do you see how the
    expense history grows with every change in real time? Can you see the UI update
    across the different windows and tabs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great work! Just like that, we can implement real-time UIs in Remix. However,
    the current implementation has one notable issue: the client that calls the `action`
    function revalidates its UI twice – one time using Remix’s built-in revalidation
    step and once after receiving the server-sent event. This puts an extra burden
    on the server and the user’s network bandwidth. Do you have an idea of how we
    could avoid the double revalidation?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider implementing this yourself to practice working with SSE in Remix!
    Maybe you can use a unique connection identifier to avoid the server-sent event
    revalidation in the browser tab that mutates the data. You could add the identifier
    to the server-sent event payload and compare it with a local version stored on
    the client. Alternatively, you could use Remix’s `shouldRevalidate` route module
    API to avoid Remix’s built-in revalidation after `action` function calls that
    trigger the server-sent events. Refer to the Remix documentation for more information
    about the `shouldRevalidate` function: [https://remix.run/docs/en/2/route/should-revalidate#shouldrevalidate](https://remix.run/docs/en/2/route/should-revalidate#shouldrevalidate).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you implemented an SSE endpoint in BeeRich to revalidate loader
    data whenever the user mutates data in an `action` function across different tabs,
    browsers, and devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about real-time technologies and techniques and
    how to use them in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: First, we discussed polling, SSE, and the WebSocket API and compared their advantages
    and disadvantages. Polling is the easiest to set up. A simple polling implementation
    does not require changes on the server. SSE provides a one-way communication line
    using the HTTP protocol, while WebSocket connections use TCP and are bi-directional.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you learned about server requirements for SSE and WebSocket. You now
    understand that SSE requires support for streaming responses, while WebSocket
    servers can only run on long-running servers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implemented a real-time UI in BeeRich by utilizing SEE. We implemented
    a new endpoint and associated React hook using the `EventSource` API. Since Remix’s
    `loader` functions return HTTP `Response` objects, we can implement the server-sent
    event endpoint in Remix using a resource route.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about session management and discuss
    advanced session management patterns with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can read more about SSE and WebSocket in the MDN Web Docs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API](https://developer.mozilla.org/en-US/docs/Web/API/Websockets_API)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a great talk from Remix Conf 2023 about SSE by Alex Anderson: [https://www.youtube.com/watch?v=cAYHw_dP-Lc](https://www.youtube.com/watch?v=cAYHw_dP-Lc).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sergio Xalambrí wrote an article on how to set up Remix with socket.io to create
    a WebSocket connection: [https://sergiodxa.com/articles/use-remix-with-socket-io](https://sergiodxa.com/articles/use-remix-with-socket-io).'
  prefs: []
  type: TYPE_NORMAL
