- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregating and Visualizing Statistics Using MongoDB and Victory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to collect, aggregate, and visualize
    statistics for our blog application using MongoDB and Victory. We start out by
    learning how we can collect events from users viewing blog posts. Then, we randomly
    generate some events to have a dataset to work with. We use this dataset to learn
    how to aggregate data with MongoDB and generate summary statistics, such as the
    number of views per post, or the average session duration on a post. This kind
    of information will help authors know how well their posts are doing. Finally,
    we create some graphs to visualize these aggregated statistics using the Victory
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting and simulating events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregating data with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing data aggregation in the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating and visualizing data on the frontend using Victory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in *Chapters 1*
    and *2.*
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch10](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch10).'
  prefs: []
  type: TYPE_NORMAL
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/DmSq2P_IQQs](https://youtu.be/DmSq2P_IQQs).'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting and simulating events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can get started aggregating and visualizing statistics, we first
    need to collect (and later simulate) events, which we are going to use to create
    the statistics. We will start by thinking about which data we want to collect,
    and which data would be useful for us. We will focus on post views for now, so
    we would like to show the following statistics per post:'
  prefs: []
  type: TYPE_NORMAL
- en: Total number of views on a post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Daily views on a post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Daily average viewing duration on a post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by creating the database model for events that will allow us to
    show these statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the event model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create these statistics, we need to collect events from users. Events will
    contain a reference to a post, a session ID to track events from the same viewing,
    an action (started viewing, ended viewing), and a date of when the event happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started defining the database model for events:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the existing **ch9** folder to a new **ch10** folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **ch10** folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new **backend/src/db/models/event.js** file. Inside this file, define
    a schema that contains a reference to a post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then define a **session**, **action**, and **date**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, export the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have defined the database model, let’s continue by defining a service
    function and route to track events.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a service function and route to track events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have successfully defined our database model for events, let’s
    create a service function and route to track new events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate session IDs, we are going to use the **uuid** library, which generates
    **universally unique identifiers (UUIDs)** for us. Install it by running the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **backend/src/services/events.js** file. Inside it, import the
    **v4** function from **uuid** and the **Event** model and define a function to
    create a new event document, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the arguments to the function, we set the default session ID to a randomly
    generated UUID and the date to the current date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new **backend/src/routes/events.js** file. Inside it, import the **trackEvent**
    function and the **getPostById** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new **POST /api/v1/events** route, in which we get the **postId**,
    **session**, and **action** from the body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we check whether a post with the given ID exists in the database. If
    not, we return a **400 Bad Request** status code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the post exists, we get the session ID and use the **trackEvent** function
    to create a new event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **backend/src/app.js** and import **eventRoutes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then mount the routes to the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the backend as follows (and keep it running for future development):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have successfully defined a backend route to track events, let’s
    implement event collection on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting events on the frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining the route, let’s create the API function for the frontend and
    define a way to track when a user started and ended viewing a post. Follow these
    steps to collect events on the frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **src/api/events.js** file and define a **postTrackEvent** function,
    which takes an event object and sends it to the previously defined route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/pages/ViewPost.jsx** and import the **useEffect**, **useState**,
    and **useMutation** hooks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, import the **postTrackEvent** API function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inside the **ViewPost** function, define a new state hook to store the
    session ID, and a mutation to track the events. When an event is successfully
    tracked, we get a session ID from the backend. We store this in the state hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a new effect hook in which we track a **startView** event a second
    after the user opened the post (to prevent tracking accidental events, such as
    from quick refreshes), and an **endView** event when the effect hook unmounts.
    We give it no dependencies to ensure the effect hook is only triggered when the
    page mounts and unmounts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the frontend as follows (and keep it running for future development):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you now open a post in your browser and take a look at the `startView` event
    is tracked. When we navigate away from the page, the `endView` event is tracked.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to simulating events so that we have more data to aggregate
    and visualize later.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simulating events is a great way to generate sample data to be used for testing
    the aggregations and visualizations. In our simulation, we first clear all current
    users from the database and then create a set of sample users. We repeat the same
    process for posts, and then for events, simulating that a random user creates
    a post and that someone views a random post for a random amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement a simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we should change the database to avoid losing any data we previously
    created in the other chapters. Edit **backend/.env** and change the following
    line from **blog** to **blog-simulated**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new **backend/simulateEvents.js** file, in which we import **dotenv**,
    the **initDatabase** function, and all the relevant models and service functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a start time for the simulation, which here is set to 30 days ago (30
    days * 24 hours * 60 minutes * 60 seconds * 1000 milliseconds), and an end time,
    which is now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also define the number of users, posts, and views to simulate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define the **simulateEvents** function, in which we first initialize
    the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, *delete* all existing users and create new users by initializing an empty
    array with the number of users to be simulated and mapping over it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: The **Array(X)** function can be used to create an array with **X** entries,
    which then needs to be filled with an initial value before it can be iterated
    over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, repeat the same process for posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: We use **Math.floor(Math.random() * maxNumber)** to create a random integer
    between **0** and **maxNumber** (non-inclusive), which is perfect to be used for
    indexing an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we repeat the same for events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we start the session at a random time within the defined simulation dates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And we end it randomly after 0 to 5 minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we simulate the event collection, first by creating a **startView** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then we simulate an **endView** event, where we use the session ID returned
    from the first event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we disconnect from the database and call the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our simulation is now ready to be used! Execute the following command to start
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see that the simulation first creates 5 users, then 10 posts, and finally
    simulates 10,000 views.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to use this dataset to try out some aggregations
    with MongoDB!
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating data with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we do not just want to simply retrieve data from the database, but
    instead, we want to create some statistics from the data by combining and summarizing
    it. This process is called **data aggregation**, and it can help us understand
    more about the data. For example, we can count the total number of views per post,
    get the number of daily views per post, or calculate the average session duration
    when viewing a post.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB supports a special aggregation syntax using the `.aggregate()` function
    on a collection. Using this aggregation functionality from MongoDB allows us to
    efficiently query and process documents. The operations it provides are similar
    to what can be done with **Structured Query Language** (**SQL**) queries. Mainly,
    we are going to use the following aggregation operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$match**: Used to filter documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$group**: Used to group documents by a certain property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$project**: Used to map properties to different properties, or process them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$sort**: Used to sort documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB provides many more advanced aggregation operations, all of which can
    be found in their documentation ([https://www.mongodb.com/docs/manual/aggregation/](https://www.mongodb.com/docs/manual/aggregation/)).
    They are also constantly adding more operations to make aggregation even more
    powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The `aggregate` function works by providing an array of objects, each of which
    defines a **stage** of the **aggregation pipeline**. We are going to learn more
    about aggregations in this chapter by using them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the total number of views per post
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first aggregation that we are going to define is a way to get the total
    number of views per post. For such an aggregation, we are going to need `$match`
    to filter all `startView` actions (otherwise we would be counting views twice,
    because there is also an `endView` action for each blog post view), and `$group`
    to group the results by post ID and then return the number of documents using
    `$count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your first aggregation pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **backend/playground/** folder for our playground scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the MongoDB extension (the leaf icon) in the VS Code sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the database, then expand the **Playgrounds** section (if it is not
    expanded already), and click on the **Create New** **Playground** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new file will open up with some code already predefined for us. *Delete* all
    predefined code, as we are going to *replace* it with our own.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, define the **use** and **db** globals, which the MongoDB Playground
    provides for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use the **blog-simulated** database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, execute the following aggregation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first stage of the pipeline will be matching all **startView** actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we group by post. The **$group** stage requires us to define an **_id**,
    which contains the property to be grouped by. We need to use the **$** operator
    to resolve the variable to be used, so **$post** will access the **event.post**
    property (which contains a post ID):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script as a **backend/playground/views-per-post.mongodb.js** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Play** icon at the top right to run the script. A new tab will
    open with the results of the aggregation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Our first MongoDB aggregation result!](img/B19385_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Our first MongoDB aggregation result!
  prefs: []
  type: TYPE_NORMAL
- en: After creating and executing our first simple aggregation, let’s continue practicing
    by writing more advanced aggregations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the number of daily views per post
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are already familiar with the general process of writing MongoDB
    aggregations, let’s try writing a bit more complicated aggregation: getting the
    number of daily views per post. Follow these steps to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new playground file, as before, with the following aggregation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, we first match only the **startView** actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we use **$project** to keep the **post** property, and define a new **day**
    property, which uses the **$dateTrunc** function to simplify the **date** property
    to only cover days (instead of containing the full timestamp):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An important thing to keep in mind with `$project` is that only properties that
    are listed here will be passed on to further stages in the pipeline, so we need
    to list all properties that we are still going to need later here!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we use **$group** to group the documents by **post** and **day** by
    passing an object to the **_id** property. We use **$count** again to count the
    number of documents in each group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script as a **backend/playground/views-per-post-per-day.mongodb.js**
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run this script by clicking on the **Play** button and you will see that we
    are now getting a list of documents grouped by post and day, and the corresponding
    number of views of a certain post on a certain day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Showing the number of views per post per day](img/B19385_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Showing the number of views per post per day
  prefs: []
  type: TYPE_NORMAL
- en: After getting the number of daily views per post, let’s continue practicing
    by calculating the average session duration.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the average session duration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may remember, we are first sending a `startView` action, and then later
    an `endView` action, both of which have a separate `date`. Let’s use aggregations
    to group these two actions together into a single document, and then compute the
    duration of a session:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new playground file, and start writing an aggregation that first creates
    some new properties using **$project**, and keeps the **session** property, as
    we will need it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we are using the `$cond` operator to create a conditional (kind of like
    a ternary/if statement). It accepts an array with three elements: the first being
    a condition, the next a result if the condition matches, and lastly, a result
    if the condition does not match. In our case, we check whether the `action` property
    is `startView` (using the `$eq` operator). If true, then we set the date to the
    `startDate` property. Otherwise, we do not define the `startDate` property. Similarly,
    if the action is `endView`, we create an `endDate` property.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can group the documents by the session ID and select the lowest start
    date and the highest end date of a session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There should only be one `startView` and `endView` action per session anyway,
    but we cannot guarantee this, so we need to aggregate them down into a single
    value!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we use **$project** again to rename the **_id** property to **session**,
    and calculate the **duration** by subtracting the **startDate** from the **endDate**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script as a **backend/playground/session-duration.mongodb.js** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the script and you will see a list of documents with a session ID and a
    corresponding duration in milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Aggregation result of the session durations](img/B19385_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Aggregation result of the session durations
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more familiar with how data aggregation works in MongoDB, let’s
    implement similar aggregations in our backend!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing data aggregation in the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our backend, we are going to use very similar aggregation pipelines. However,
    we need to adjust them slightly, as we always want to get the data for a single
    post only. As such, we will first be using `$match` to filter our documents. This
    also ensures that the aggregation stays fast, even if we have millions of events
    in our database, because we are first filtering down to all events of a single
    post!
  prefs: []
  type: TYPE_NORMAL
- en: Defining aggregation service functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the aggregation functions in the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **backend/src/services/events.js** and define a new function to get the
    total number of views for a post. In this case, we can simplify our code by using
    the **countDocuments** function instead of the aggregate function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a new function to get the daily views of a post with a given ID.
    We now use the **$match** operation to only get the **startView** actions of a
    certain post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use the **$group** operation in combination with **$dateTrunc** to
    get the views per day, just like we did before in the MongoDB Playground script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we use the **$sort** operation to sort the resulting documents by **_id**
    (which contains the day):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the last function, we use our session duration aggregation, but extend
    it a little bit to give the average duration per day. Again, we first need to
    match a post ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use the same **$project** and **$group** operations to get the **session**,
    **startDate**, and **endDate**, just like we did before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we use the **$project** operation to get **day** from our **startDate**,
    like we did in the previous aggregation where we got the number of daily views
    of a post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We group the results per day, and calculate the average duration of a day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we sort the results per day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, aggregation pipelines are extremely powerful and allow us to
    do a lot of data processing directly in the database! In the next section, we
    are going to create routes for these aggregation functions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining the routes is pretty straightforward; we simply check whether a post
    with the given ID exists, and if it does, we return the results from the corresponding
    aggregation service function. Let’s start defining the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **backend/src/routes/events.js** and import the **getTotalViews**, **getDailyViews**,
    and **getDailyDurations** functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, inside the **eventRoutes** function, define a new route for getting the
    total number of views of a post, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then define a similar route for the number of daily views of a post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, define a route for the daily average viewing duration of a post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have successfully defined routes for our aggregation functions,
    it’s time to integrate them into the frontend and start visualizing the data we
    have been simulating and collecting!
  prefs: []
  type: TYPE_NORMAL
- en: Integrating and visualizing data on the frontend using Victory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section, we are going to integrate the aggregation endpoints we
    previously defined. Then, we are going to introduce the Victory library in the
    frontend to create graphs to visualize our aggregated data!
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the aggregation API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to integrate the API routes in the frontend, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the **src/api/events.js** file and add three new API functions to get
    the total views, daily views, and daily durations of a post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **src/components/PostStats.jsx** file, in which we are going to
    query these new API routes. Start by importing **useQuery**, **PropTypes**, and
    the three API functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new component that takes a **postId** and fetches all the stats that
    we aggregated on the backend using query hooks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While the stats are loading, we display a simple loading message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the stats are finished loading, we can display them. For now, we simply
    display the total number of views and the JSON responses from the other two API
    requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We still need to define the prop types for this component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can render the **PostStats** component in our **ViewPost** page component.
    Edit **src/pages/ViewPost.jsx** and import the **PostStats** component there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, at the bottom of the component, render the stats as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you open a post on the frontend now (you may need to refresh the frontend
    if you see an error), you will see that all the stats are properly fetched! Now,
    all that’s left to do is visualize the daily stats using Victory!
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing data using Victory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Victory is a React library that provides modular components that can be used
    to create charts and all kinds of data visualizations. It even supports interactive
    visualization tools, such as brushing and grouping (where you, for example, select
    a certain section of a graph to more closely inspect it on other graphs). In this
    chapter, we are only going to scratch the surface of what Victory can do, as data
    visualization in React is a big topic on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about Victory on their official website: [https://commerce.nearform.com/open-source/victory/](https://commerce.nearform.com/open-source/victory/)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get started visualizing our data using Victory now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the library by executing the following command in the root of the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/components/PostStats.jsx** and import the following components from
    Victory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Replace* the **<pre>** tags at the end of the component with the following
    charts, starting with the daily views chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a bar chart with **VictoryBar**, using **VictoryTooltip** to display
    the labels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The tooltip looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.4 – A tooltip on a bar chart in Victory](img/B19385_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – A tooltip on a bar chart in Victory
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we get to the most important part, the data. Here, we map over our **dailyViews**
    data returned by the query hook to bring it into a format that Victory understands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We map the **_id** property to the **x**-axis value (parsing it as a date),
    and the **views** property to the **y**-axis value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we create a label, where we turn the day into a local date string and
    then show the number of views on the given day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have successfully created our first visualization using Victory! The chart
    will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Our first chart in Victory – a bar chart!](img/B19385_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Our first chart in Victory – a bar chart!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Victory automatically formatted the dates for us and adjusted
    the axes to fit our chart into the allotted space!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s visualize the daily average viewing duration next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a line chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a line chart in Victory is pretty similar to creating a bar chart,
    with one exception: the tooltips. In line charts, we cannot use tooltips directly,
    as lines could theoretically be continuous (not discrete blocks of data), so it
    is unclear where to place the tooltip. Instead, we use a **Voronoi container**
    for displaying tooltips on line charts in Victory. The name Voronoi comes from
    mathematics, where a Voronoi diagram partitions a region into multiple sections.
    In simple terms, the Voronoi container makes an intersection between the mouse
    position and the line chart, gets the data from that intersection point, and then
    displays a tooltip there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, let’s now get started creating the line chart for the daily
    average viewing duration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/components/PostStats.jsx** and continue where we left off with the
    other chart, adding a new **VictoryChart** after the container of the bar chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **VictoryChart** component, we now define **containerComponent**, which
    will contain our **VictoryVoronoiContainer**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We defined it to only intersect with the values on the `x`-axis, meaning that
    the mouse pointer will only intersect with the days on our chart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now define labels for our container, using the **datum** property to
    get the data entry that intersects with the mouse pointer to create a label. Our
    label should display the current date and the viewing duration in minutes, fixed
    to two decimal points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, we use **VictoryTooltip** to display these labels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can finally define the **VictoryLine** chart, in which we map the data
    again, parsing dates and dividing the average duration to convert it from milliseconds
    to minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, the rest was pretty simple and similar to creating the bar
    chart! It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – A line chart using Victory, displaying the daily average viewing
    duration of a post!](img/B19385_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – A line chart using Victory, displaying the daily average viewing
    duration of a post!
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, Victory is a pretty powerful library for creating charts with
    React, and we have only scratched the surface of what it can do! You can still
    customize the theme of the charts and create all sorts of complex visualizations.
    In this chapter, however, we focused on the most essential and widely used charts:
    bar and line charts.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about tracking events using our backend and frontend.
    Then, we simulated events to be used as a sample dataset for our aggregations
    and visualizations. Next, we learned how to aggregate data with MongoDB using
    the MongoDB Playground. Then, we implemented data aggregation functions in our
    backend. Finally, we integrated and visualized the data on the frontend using
    Victory.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 11*](B19385_11.xhtml#_idTextAnchor213), *Building
    a Backend with a GraphQL API*, we are going to learn how to use an alternative
    to REST, called GraphQL, to query deeply nested objects more easily.
  prefs: []
  type: TYPE_NORMAL
