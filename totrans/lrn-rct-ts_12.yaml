- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing with Jest and React Testing Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learn how to use Jest and React Testing Library, two popular
    automated testing tools that can be used together in React applications. We will
    create tests on the checklist component we created in [*Chapter 11*](B19051_11.xhtml#_idTextAnchor273),
    *Reusable Components*.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by focusing on Jest and using it to test simple functions, learning
    about Jest’s common **matcher** functions for writing expectations, and how to
    execute tests to check whether they pass.
  prefs: []
  type: TYPE_NORMAL
- en: We will then move on to learning about component testing using React Testing
    Library. We’ll understand the different query types and variants and how they
    help us create robust tests.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will learn the most accurate way to simulate user interactions
    using a React Testing Library companion package. We will use this to create tests
    for items being checked in the checklist component.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will learn how to determine which code is covered
    by tests and, more importantly, which code is uncovered. We use Jest’s code coverage
    tool to do this and understand all the different coverage stats it gives us.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating user interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting code coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js** and **npm**: You can install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: You can install it from [https://code.visualstudio.com/](https://code.visualstudio.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with a modified version of the code we finished in the last chapter.
    The modified code contains logic extracted into pure functions, which will be
    ideal to use in the first tests we write. This code can be found online at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start).
  prefs: []
  type: TYPE_NORMAL
- en: 'Carry out the following steps to download this to your local computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://download-directory.github.io/](https://download-directory.github.io/)
    in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the textbox on the web page, enter the following URL: [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* key. A ZIP file containing the `start` folder will now be
    downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the ZIP file to a folder of your choice and open that folder in Visual
    Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio Code’s terminal, execute the following command to install
    all the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are now ready to start writing tests for the checklist component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start by understanding the fundamental parts of a Jest
    test. Then, we will put this into practice by implementing tests on a pure function
    in the checklist component.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function has a consistent output value for a given set of parameter values.
    These functions depend only on the function parameters and nothing outside the
    function, and also don’t change any argument values passed into them. So, pure
    functions are nice for learning how to write tests because there are no tricky
    side effects to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will also cover how to test exceptions, which is useful
    for testing type assertion functions. Finally, at the end of this section, we
    will learn how to run the tests in a test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a Jest test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jest is preinstalled in a Create React App project and configured to look for
    tests in files with particular extensions. These file extensions are `.test.ts`
    for tests on pure functions and `.test.tsx` for tests on components. Alternatively,
    a `.spec.*` file extension could be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A test is defined using Jest’s `test` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test` function has two parameters for the test name and implementation.
    It is common practice for the test implementation to be an anonymous function.
    The test implementation can be asynchronous by placing the `async` keyword in
    front of the anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The test implementation will consist of calling the function with arguments
    being tested and checking the result is as we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Jest’s `expect` function is used to define our expectations. The result of the
    function call is passed into `expect`, and it returns an object containing methods
    we can use to define specific expectations for the result. These methods are referred
    to as **matchers**. If the expectation fails, Jest will fail the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding test uses the `toBe` matcher. The `toBe` matcher checks that
    primitive values are equal, and the preceding test uses it to check that the `someResults`
    variable is equal to `"something"`. Other common matchers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toStrictEqual` for checking the values in an object or array. This recursively
    checks every property in the object or array. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`not` for checking the opposite of a matcher. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`toMatch` for checking strings against **regular expressions** (**regexes**).
    Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`toContain` for checking if an element is in an array. Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A complete list of all the standard matchers can be found in the Jest documentation
    at [https://jestjs.io/docs/expect](https://jestjs.io/docs/expect).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basics of a Jest test, we will create our first Jest
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing isChecked
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first function we will test is `isChecked`. This function has two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`checkedIds`: This is an array of IDs that are currently checked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idValue`: This is the ID to determine whether it is checked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will write a test for when the list item is checked and another for when
    it isn’t checked:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `isChecked.test.ts` in the `src/Checklist` folder that
    will contain the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is best practice to place test files adjacent to the source file being tested.
    This allows the developers to navigate to the test for a function quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `isChecked.test.ts` and import the `isChecked` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start to create the first test as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Jest puts the `test` function in the global scope, so there is no need to import
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the test name as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Forming a naming convention for test names is good practice so that they are
    consistent and easy to understand. Here, we have used the following naming structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**should {expected output / behaviour} when {input /** **state condition}**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start to implement the logic inside the test. The first step in
    the test is to call the function being tested with the arguments we want to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second (and last) step in the test is to check that the result is what
    we expect, which is `true` for this test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the result is a primitive value (a Boolean), we use the `toBe` matcher
    to verify the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a second test to cover the case when the ID isn’t in the checked IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the tests on the `isChecked` function. Next, we will learn how
    to test exceptions that are raised. We will check that our tests work after that.
  prefs: []
  type: TYPE_NORMAL
- en: Testing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to test the `assertValueCanBeRendered` type assertion function.
    This is a little different from the last function we tested because we want to
    test whether an exception is raised rather than the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest has a `toThrow` matcher that can be used to check whether an exception
    has been raised. For this to catch exceptions, the function being tested has to
    be executed inside the expectation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this approach to add three tests on the `assertValueCanBeRendered`
    type assertion function. Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `assertValueCanBeRendered.test.ts` in the `src/Checklist`
    folder for the tests and import the `assertValueCanBeRendered` type assertion
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first test we will add is to check whether an exception is raised when
    the value isn’t a string or number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We pass the `true` Boolean value, which should cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will test whether an exception isn’t raised when the value is a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `not` matcher with `toThrow` to check that an exception is not raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last test will test an exception isn’t raised when the value is a number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes the tests for the `assertValueCanBeRendered` type assertion function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have implemented some tests, we will learn how to run them next.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create React App has an npm script called `test` that runs the tests. After
    the tests are run, a watcher will rerun the tests when the source code or test
    code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Carry out the following steps to run all the tests and experiment with the
    test watcher options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`test` is a very common npm script, so the `run` keyword can be omitted. In
    addition, `test` can be shortened to `t`. So, a shortened version of the previous
    command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests will be run, and the following summary will appear in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – First test run](img/B19051_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – First test run
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there is no Command Prompt in the terminal like there usually is
    after a command has finished executing. This is because the command hasn’t fully
    completed as the test watcher is running—this is called **watch mode**. The command
    won’t complete until watch mode is exited using the *q* key. Leave the terminal
    in watch mode and carry on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the tests pass at the moment. Now, we will deliberately make a test fail
    so that we can see the information Jest provides us. So, open `assertValueCanBeRendered.ts`
    and change the expected error message on the first test as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As soon as the test file is saved, the tests are rerun, and a failing test
    is reported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Failing test](img/B19051_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Failing test
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest provides valuable information about the failure that helps us quickly
    resolve test failures. It tells us this:'
  prefs: []
  type: TYPE_NORMAL
- en: Which test failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the expected result was, in comparison to the actual result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line in our code where the failure occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resolve the test failure by reverting the test to check for the correct error
    message. The test should be as follows now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now start to explore some of the options on the test watcher. Press
    the *w* key in the terminal, where the test watcher is still running. The test
    watcher options will be listed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Test watcher options](img/B19051_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Test watcher options
  prefs: []
  type: TYPE_NORMAL
- en: 'We can filter the test files that Jest executes by using the *p* watch option.
    Press the *p* key and enter `isChecked` when prompted for the pattern. The pattern
    can be any regex. Jest will search for test files that match the regex pattern
    and execute them. So, Jest runs the tests in `isChecked.test.ts` in our test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Jest running a test file checking for a matching pattern](img/B19051_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Jest running a test file checking for a matching pattern
  prefs: []
  type: TYPE_NORMAL
- en: To clear the filename filter, press the *c* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also filter the tests that Jest executes by the test name using the
    *t* watch option. Press *t* and enter `should return false when not in checkedIds`
    when prompted for the test name. Jest will search for test names that match the
    regex pattern and execute them. So, Jest runs the `should return false when not
    in checkedIds` test in our test suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Jest running test name matching a pattern](img/B19051_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Jest running test name matching a pattern
  prefs: []
  type: TYPE_NORMAL
- en: Press the *c* key to clear the test name filter and then press the *q* key to
    exit the test watcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That completes our exploration of running Jest tests and this section on testing
    pure functions. Here’s a quick recap of the key points:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests are defined using Jest’s `test` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expectations within the test are defined using Jest’s `expect` function in combination
    with one or more matchers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `expect` function argument can be a function that executes the function
    being tested. This is useful for testing exceptions with the `toThrow` matcher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jest’s test runner has a comprehensive set of options for running tests. The
    test watcher is particularly useful on large code bases because it only runs tests
    impacted by changes by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will learn how to test React components.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing components is important because this is what the user interacts with.
    Having automated tests on components gives us confidence that the app is working
    correctly and helps prevent regressions when we change code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to test components with Jest and React Testing
    Library. Then, we will create some tests on the checklist component we developed
    in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding React Testing Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Testing Library is a popular companion library for testing React components.
    It provides functions to render components and then select internal elements.
    Those internal elements can then be checked using special matchers provided by
    another companion library called `jest-dom`.
  prefs: []
  type: TYPE_NORMAL
- en: A basic component test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s an example of a component test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain the test:'
  prefs: []
  type: TYPE_NORMAL
- en: React Testing Library’s `render` function renders the component we want to test.
    We pass in all the appropriate attributes and content so that the component is
    in the required state for the checks. In this test, we have specified some text
    in the content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line selects an internal element of the component. There are lots of
    methods on React Testing Library’s `screen` object that allow the selection of
    elements. These methods are referred to as `getByText` selects an element by matching
    the text content specified. In this test, an element with `Some heading` text
    content will be selected and assigned to the `heading` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line in the test is the expectation. The `toBeInTheDocument` matcher
    is a special matcher from `jest-dom` that checks whether the element in the expectation
    is in the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A React Testing Library query is a method that selects a DOM element within
    the component being rendered. There are many different queries that find the element
    in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ByRole`: Queries elements by their role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: DOM elements have a `role` attribute that allows assistive technologies such
    as screen readers to understand what they are. Many DOM elements have this attribute
    preset—for example, the `button` element automatically has the role of `'button'`.
    For more information on roles, see [https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles).
  prefs: []
  type: TYPE_NORMAL
- en: '`ByLabelText`: Queries elements by their associated label. See this page in
    the React Testing Library documentation for the different ways elements can be
    associated with a label: [https://testing-library.com/docs/queries/bylabeltext](https://testing-library.com/docs/queries/bylabeltext).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ByPlaceholderText`: Queries elements by their placeholder text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ByText`: Queries elements by their text content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ByDisplayValue`: Queries `input`, `textarea`, and `select` elements by their
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ByAltText`: Queries `img` elements by their `alt` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ByTitle`: Queries elements by their `title` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ByTestId`: Queries elements by their test ID (the `data-testid` attribute).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also different types of queries that behave slightly differently
    on the found element. Each query type has a particular prefix on the query method
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getBy`: Throws an error if a single element is not found. This is ideal for
    synchronously getting a single element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAllBy`: Throws an error if at least one element is not found. This is ideal
    for synchronously getting multiple elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findBy`: Throws an error if a single element is not found. The check for an
    element is repeated for a certain amount of time (1 second by default). So, this
    is ideal for asynchronously getting a single element that might not be immediately
    in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findAllBy`: Throws an error if at least one element is not found within a
    certain time (1 second by default). This is ideal for asynchronously getting multiple
    elements that might not be immediately in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryBy`: This returns `null` if an element is not found. This is ideal for
    checking that an element does *not* exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryAllBy`: This is the same as `queryBy`, but returns an array of elements.
    This is ideal for checking multiple elements do *not* exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the `getByText` query we used in the preceding test finds the element by
    the text content specified and raises an error if no elements are found.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on queries, see the following page in the React Testing
    Library documentation: [https://testing-library.com/docs/queries/about/](https://testing-library.com/docs/queries/about/).'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that none of these queries references implementation details such as
    an element name, ID, or CSS class. If those implementation details change due
    to code refactoring, the tests shouldn’t break, which is precisely what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand React Testing Library, we will use it to write our first
    component test.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing checklist component tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component test we will write is to check that list items are rendered
    correctly. The second component test will check list items are rendered correctly
    when custom rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Testing Library and `jest-dom` are preinstalled in a Create React App
    project, which means we can get straight to writing the test. Carry out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in the `src/Checklist` folder called `Checklist.test.tsx`
    and add the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start to create the test as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the test, render `Checklist` with some data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve rendered a single list item that should have primary text `Lucy` and secondary
    text `Manager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check `Lucy` has been rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have selected the element using the `getByText` query and fed that directly
    into the expectation. We use the `toBeInTheDocument` matcher to check that the
    found element is in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the test by adding a similar expectation for checking for `Manager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes our first component test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the second test in one go, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We render a single list item with the same data as the previous test. However,
    this test custom renders the list items with a hyphen between the name and role.
    We use the same `getByText` query to check that the list item with the correct
    text is found in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the tests aren’t automatically running, run them by running `npm test` in
    the terminal. Use the *p* option to run these two new tests—they should both pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Component tests passing](img/B19051_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Component tests passing
  prefs: []
  type: TYPE_NORMAL
- en: That completes our first two component tests. See how easy React Testing Library
    makes this!
  prefs: []
  type: TYPE_NORMAL
- en: Using test IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next test we will implement is to check that a list item is checked when
    specified. This test will be slightly trickier and requires a test ID on the checkboxes.
    Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening `Checklist.tsx` and notice the following test ID on the `input`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test IDs are added to elements using a `data-testid` attribute. We can concatenate
    the list item ID so that the test ID is unique for each list item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, return to the `Checklist.test.tsx` file and begin to write the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have rendered the checklist with the same data as the previous tests. However,
    we have specified that the list item is checked using the `checkedIds` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on to the expectation for the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We select the checkbox by its test ID using the `getByTestId` query. We then
    use the `toBeChecked` matcher to verify the checkbox is checked. `toBeChecked`
    is another special matcher from the `jest-dom` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new test should pass, leaving us with three passing tests on `Checklist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – All three component tests passing](img/B19051_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – All three component tests passing
  prefs: []
  type: TYPE_NORMAL
- en: Stop the test runner by pressing the *q* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That completes this section on testing components. Here’s a quick recap:'
  prefs: []
  type: TYPE_NORMAL
- en: React Testing Library contains lots of useful queries for selecting DOM elements.
    Different query types will find single or many elements and will or won’t error
    if an element isn’t found. There is even a query type for repeatedly searching
    for elements rendered asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jest-dom` contains lots of useful matchers for checking DOM elements. A common
    matcher is `toBeInTheDocument`, which verifies an element is in the DOM. However,
    `jest-dom` contains many other useful matchers, such as `toBeChecked` for checking
    whether an element is checked or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will learn how to simulate user interactions in tests.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating user interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our tests have simply rendered the checklist component with various
    props set. Users can interact with the checklist component by checking and unchecking
    items. In this section, we will first learn how to simulate user interactions
    in tests. We will then use this knowledge to test whether list items are checked
    when clicked and that `onCheckedIdsChange` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding fireEvent and user-event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Testing Library has a `fireEvent` function that can raise events on DOM
    elements. The following example raises a `click` event on a **Save** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'This is okay, but what if logic was implemented using a `mousedown` event rather
    than `click`? The test would then need to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, there is an alternative approach to performing user interactions
    in tests. The alternative approach is to use the `user-event` package, which is
    a React Testing Library companion package that simulates user interactions rather
    than specific events. The same test using `user-event` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The test would cover logic implemented using a `click` event or `mousedown`
    event. So, it is less coupled to implementation details, which is good. For this
    reason, we’ll use the `user-event` package to write interactive tests on our checklist
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `user-event` package can simulate interactions other than clicks. See the
    documentation at the following link for more information: [https://testing-library.com/docs/user-event/intro](https://testing-library.com/docs/user-event/intro).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing checklist tests for checking items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now write two interactive tests on the checklist component. The first
    test will check items are checked when clicked. The second test will check `onCheckedIdsChange`
    is called when items are clicked. Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create React App does preinstall the `user-event` package, but it may be a
    version before version 14, which has a different API. Open `package.json`, and
    then find the `@testing-library/user-event` dependency and check the version.
    If the version isn’t 14 or above, then run the following command in the terminal
    to update it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will add the interactive tests in the same test file as the other component
    tests. So, open `Checklist.test.tsx` and add an import statement for `user-event`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first test will test that items are checked when clicked. Start to implement
    this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have marked the test as asynchronous because the simulated user interactions
    in `user-event` are asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, initialize the user simulation as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now render a list item as we have done in previous tests. We will also
    get a reference to the checkbox in the rendered list item and check that it isn’t
    checked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, on to the user interaction. Simulate the user clicking the list item by
    calling the `click` method on the `user` object; the checkbox to be clicked needs
    to be passed into the `click` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step in the test is to check that the checkbox is now checked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next test will test that the function assigned to the `onCheckedIdsChange`
    prop is called when a list item is clicked. Here is the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We set a `calledWith` variable to the value of the `onCheckedIdsChange` parameter.
    After the list item is clicked, we check the value of the `calledWith` variable
    using the `toStrictEqual` matcher. The `toStrictEqual` matcher is a standard Jest
    matcher that is ideal for checking arrays and objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second test references the `IdValue` type, so add an import statement for
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the tests by running `npm test` in the terminal. Press the *p* key to run
    all the tests in the `Checklist.test.tsx` file. We should now have five passing
    component tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Five passing component tests](img/B19051_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Five passing component tests
  prefs: []
  type: TYPE_NORMAL
- en: Stop the test runner by pressing the *q* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That completes the tests for clicking items and this section on simulating user
    interactions. We learned that React Testing Library’s `fireAction` function raises
    a particular event that couples tests to implementation details. A better approach
    is to use the `user-event` package to simulate user interactions, potentially
    raising several events in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to quickly determine any code that isn’t covered by
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code coverage is how we refer to how much of our app code is covered by unit
    tests. As we write our unit tests, we’ll have a fair idea of what code is covered
    and not covered, but as the app grows and time passes, we’ll lose track of this.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to use Jest’s code coverage option so that
    we don’t have to keep what is covered in our heads. We will use the code coverage
    option to determine the code coverage on the checklist component and understand
    all the different statistics in the report. We will use the code coverage report
    to find some uncovered code in our checklist component. We will then extend the
    tests on the checklist component to achieve full code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Running code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get code coverage, we run the `test` command with a `--coverage` option.
    We also include a `--watchAll=false` option that tells Jest not to run in watch
    mode. So, run the following command in a terminal to determine code coverage on
    our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests take a little longer to run because of the code coverage calculations.
    When the tests have finished, a code coverage report is output in the terminal
    with the test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Terminal code coverage report](img/B19051_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Terminal code coverage report
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take some time to understand this code coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code coverage report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The coverage report lists the coverage for each file and aggregates coverage
    in a folder for all the files in the project. So, the whole app has between 57.44%
    and 62.5% code coverage, depending on which statistic we take.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an explanation of all the statistic columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**% Stmts**: This is **statement coverage**, which is how many source code
    statements have been executed during test execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**% Branch**: This is **branch coverage**, which is how many of the branches
    of conditional logic have been executed during test execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**% Funcs**: This is **function coverage**, which is how many functions have
    been called during test execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**% Lines**: This is **line coverage**, which is how many lines of source code
    have been executed during test execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rightmost column in the report is very useful. It gives the lines of source
    code that aren’t covered by tests. For example, the `getNewCheckedIds.ts` file
    in the checklist component has lines 9 and 10, which are uncovered.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another version of the report that is generated in HTML format. This
    file is automatically generated every time a test is run with the `--coverage`
    option. So, this report has already been generated because we have just run the
    tests with the `--coverage` option. Carry out the following steps to explore the
    HTML report:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The report can be found in an `index.html` file in the `coverage\lcov-report`
    folder. Double-click on the file so that it opens in a browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – HTML coverage report](img/B19051_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – HTML coverage report
  prefs: []
  type: TYPE_NORMAL
- en: The report contains the same data as the terminal report, but this one is interactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **src/Checklist** link in the second row of the report. The page
    now shows the coverage for the files in the checklist component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Coverage report for checklist component files](img/B19051_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Coverage report for checklist component files
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the `getNewCheckedIds.ts` link to drill into the coverage for that
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Coverage report for getNewCheckedIds.ts](img/B19051_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Coverage report for getNewCheckedIds.ts
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the uncovered lines 9 and 10 are very clearly highlighted in
    the `getNewCheckedIds.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: So, the HTML coverage report is useful in a large code base because it starts
    with high-level coverage and allows you to drill into coverage on specific folders
    and files. When viewing a file in the report, we can quickly determine where the
    uncovered code is because it is clearly highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will update our tests so that lines 9 and 10 in `getNewCheckedIds.ts`
    are covered.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining full coverage on the checklist component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logic not currently being checked by tests is the logic used when a list
    item is clicked but has already been checked. We will extend the `''should check
    items when clicked''` test to cover this logic. Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Checklist.test.tsx` and rename the `''should check items when clicked''`
    test as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following highlighted lines at the end of the test to click the checkbox
    for a second time and check it is unchecked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the terminal, rerun the tests with coverage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All the tests still pass, and the coverage on the checklist component is now
    reported as 100% on all the statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – 100% coverage on the checklist component](img/B19051_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – 100% coverage on the checklist component
  prefs: []
  type: TYPE_NORMAL
- en: The checklist component is now well covered. However, it is a little annoying
    that `index.ts` and `types.ts` appear in the report with zero coverage. We’ll
    resolve this next.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring files in the coverage report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will remove `index.ts` and `types.ts` from the coverage report because they
    don’t contain any logic and create unnecessary noise. Carry out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `package.json` file. We can configure Jest in the `package.json` file
    in a `jest` field, and there is a `coveragePathIgnorePatterns` configuration option
    for removing files from the coverage report. Add the following Jest configuration
    to `package.json` to ignore the `types.ts` and `index.ts` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the terminal, rerun the tests with coverage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `types.ts` and `index.ts` files are removed from the coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – types.ts and index.ts files removed from the coverage report](img/B19051_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – types.ts and index.ts files removed from the coverage report
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes this section on code coverage. Here’s a quick recap:'
  prefs: []
  type: TYPE_NORMAL
- en: The `--coverage` option outputs a code coverage report after the tests have
    run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interactive HTML code coverage report is generated in addition to the one
    in the terminal. This is useful on a large test suite to drill into uncovered
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both report formats highlight uncovered code, giving us valuable information
    to improve our test suite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created tests on a checklist component using Jest and React
    Testing Library. In addition, we learned about common Jest matchers in Jest’s
    core package and useful matchers for component testing in a companion package
    called `jest-dom`.
  prefs: []
  type: TYPE_NORMAL
- en: We used Jest’s test runner and used options to run certain tests. This is particularly
    useful on large code bases.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the wide variety of queries available in React Testing Library
    to select elements in different ways. We used the `getByText` query extensively
    in the checklist tests. We also created a test ID on list item checkboxes so that
    the `getByTestId` query could be used to select them uniquely.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that the `user-event` package is an excellent way of simulating user
    interactions that are decoupled from the implementation. We used this to simulate
    a user clicking a list item checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to produce code coverage reports and understood all the statistics
    in the report. The report included information about uncovered code, which we
    used to gain 100% coverage on the checklist component.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have reached the end of this book. You are now comfortable with both
    React and TypeScript and have excellent knowledge in areas outside React core,
    such as styling, client-side routing, forms, and web APIs. You will be able to
    develop components that are reusable across different pages and even different
    apps. On top of that, you will now be able to write a robust test suite so that
    you can ship new features with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the knowledge from this book will allow you to efficiently build
    the frontend of large and complex apps with React and TypeScript. I hope you have
    enjoyed reading this book as much as I did writing it!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to check what you have learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We have written some tests for a `HomePage` component and placed them in a file
    called `HomePage.tests.tsx`. However, the tests aren’t run when the `npm test`
    command is executed—not even when the *a* key is pressed to run all the tests.
    What do you think the problem might be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why doesn’t the following expectation pass? How could this be resolved?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Which matcher can be used to check that a variable isn’t `null`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an expectation that checks whether a **Save** button is disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The expectation passes as expected, but is there a different matcher that can
    be used to simplify this?
  prefs: []
  type: TYPE_NORMAL
- en: Write a test for the `getNewCheckedIds` function we used in this chapter. The
    test should check if an ID is removed from the array of checked IDs if it is already
    in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have a `form` element containing a `findBy` query type so that the query
    retries until the data has been fetched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, the expectation doesn’t work—can you spot the problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following expectation attempts to check that a **Save** button isn’t in
    the DOM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This doesn’t work as expected, though. Instead, an error is raised because the
    **Save** button can’t be found. How can this be resolved?
  prefs: []
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem is that the file extension is `tests.tsx` rather than `test.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `toBe` matcher should only be used for checking primitive values such as
    numbers and strings—this is an object. The `toStrictEqual` matcher should be used
    to check objects because it checks the values of all its properties instead of
    the object reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `not` and `toBeNull` matchers can be combined to check a variable isn’t
    `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `toBeDisabled` matcher can be used from `jest-dom`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s a test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `findBy` query type requires awaiting because it is asynchronous:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `queryBy` query type can be used because it doesn’t throw an exception
    when an element isn’t found. In addition, the `not` and `toBeInTheDocument` matchers
    can be used to check that the element isn’t in the DOM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
