- en: '24'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '24'
- en: Showing Progress
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示进度
- en: This chapter is all about communicating progress to the user. React Native has
    different components that are used to handle the different types of progress that
    you want to communicate. First, you’ll learn why you need to communicate progress
    in the app. Then, you’ll learn how to implement progress indicators and progress
    bars. And finally, you’ll see specific examples that show you how to use progress
    indicators with navigation while data loads and progress bars to communicate the
    current position in a series of steps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于向用户传达进度。React Native有不同类型的组件，用于处理你想要传达的不同类型的进度。首先，你将学习为什么需要在应用中传达进度。然后，你将学习如何实现进度指示器和进度条。最后，你将看到具体的示例，展示如何在数据加载时使用进度指示器进行导航，以及如何使用进度条来传达一系列步骤中的当前位置。
- en: 'The following sections are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下内容：
- en: Understanding progress and usability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解进度和可用性
- en: Indicating progress
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示进度
- en: Measuring progress
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量进度
- en: Exploring navigation indicators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索导航指示器
- en: Step progress
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤进度
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter21)4.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter21)。
- en: Understanding progress and usability
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解进度和可用性
- en: 'Imagine that you have a microwave oven that has no window and makes no sound.
    The only way to interact with it is by pressing a button labeled “cook.” As absurd
    as this device sounds, it’s what many software users face: no indication of progress.
    Is the microwave cooking anything? If so, how do we know when it will be done?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个没有窗户且不发出声音的微波炉。与它交互的唯一方式是按下标有“烹饪”的按钮。这个设备听起来可能很荒谬，但这就是许多软件用户面临的情况：没有进度指示。微波炉在烹饪吗？如果是，我们怎么知道它什么时候会完成？
- en: One way to improve the microwave situation is to add a beep sound. This way,
    the user gets feedback after pressing the cook button. You’ve overcome one hurdle,
    but the user is still left asking, “When will my food be ready?” Before you go
    out of business, you had better add some sort of progress measurement display,
    such as a timer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 改善微波炉状况的一种方法是在其中添加蜂鸣声。这样，用户在按下烹饪按钮后就能得到反馈。你已经克服了一个障碍，但用户仍然会问，“我的食物什么时候能准备好？”在你破产之前，你最好添加某种进度测量显示，比如计时器。
- en: It’s not that UI programmers don’t understand the basic principles of this usability
    concern; it’s just that they have stuff to do, and this sort of thing simply slips
    through the cracks in terms of priority. In React Native, there are components
    to give the user indeterminate progress feedback and precise progress measurements.
    It’s always a good idea to make these things a top priority if you want a good
    user experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并非UI程序员不理解这种可用性关注的基本原则；只是他们有事情要做，这类事情在优先级上只是被忽略了。在React Native中，有组件可以给用户提供不确定的进度反馈和精确的进度测量。如果你想要良好的用户体验，始终将这些事情作为首要任务是明智的。
- en: Now that you understand the role of progress in usability, it’s time to learn
    how to indicate progress in your React Native UIs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了进度在可用性中的作用，是时候学习如何在React Native UI中指示进度了。
- en: Indicating progress
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指示进度
- en: In this section, you’ll learn how to use the `ActivityIndicator` component.
    As its name suggests, you render this component when you need to indicate to the
    user that something is happening. The actual progress may be indeterminate, but
    at least you have a standardized way to show that something is happening, despite
    there being no results to display yet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用`ActivityIndicator`组件。正如其名称所暗示的，当你需要向用户指示正在发生某事时，你将渲染此组件。实际的进度可能是不确定的，但至少你有一个标准化的方式来显示正在发生某事，尽管目前还没有结果可以显示。
- en: 'Let’s create an example so that you can see what this component looks like.
    Here’s the `App` component:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例，以便你可以看到这个组件的外观。以下是`App`组件：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `<ActivityIndicator />` component is platform-agnostic. Here’s how it looks
    on iOS:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ActivityIndicator />`组件是平台无关的。以下是它在iOS上的外观：'
- en: '![Picture 1](img/B19636_24_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/B19636_24_01.png)'
- en: 'Figure 24.1: An activity indicator on iOS'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.1：iOS上的活动指示器
- en: It renders an animated spinner in the middle of the screen. This is the large
    spinner, as specified in the `size` property. The `ActivityIndicator` spinner
    can also be small, which makes more sense if you’re rendering it inside another
    smaller element.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它在屏幕中间渲染一个动画旋转器。这是在`size`属性中指定的较大旋转器。`ActivityIndicator`旋转器也可以是小的，如果您在另一个较小的元素内部渲染它，这更有意义。
- en: 'Now, let’s take a look at how this looks on an Android device:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这在一个Android设备上的样子：
- en: '![Picture 2](img/B19636_24_02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/B19636_24_02.png)'
- en: 'Figure 24.2: An activity indicator on Android'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.2：Android上的活动指示器
- en: 'The spinner looks different, as it should, but your app conveys the same thing
    on both platforms: you’re waiting for something.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转器的样子不同，正如它应该的那样，但您的应用在两个平台上传达了相同的信息：您正在等待某事。
- en: 'This example spins forever. But don’t worry: there’s a more realistic progress
    indicator example coming up that shows you how to work with navigation and loading
    API data.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例会无限旋转。但不用担心：接下来会有一个更现实的进度指示器示例，向您展示如何处理导航和加载API数据。
- en: Exploring navigation indicators
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索导航指示器
- en: Earlier in this chapter, you were introduced to the `ActivityIndicator` component.
    In this section, you’ll learn how it can be used when navigating an application
    that loads data. For example, the user navigates from page or screen one to page
    two. However, page two needs to fetch data from the API that it can display to
    the user. So, while this network call is happening, it makes more sense to display
    a progress indicator instead of a screen devoid of useful information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，您已经了解了`ActivityIndicator`组件。在本节中，您将学习如何在加载数据的程序导航中使用它。例如，用户从页面或屏幕一导航到页面二。然而，页面二需要从API获取数据，以便向用户显示。因此，当这个网络调用正在进行时，显示一个进度指示器比显示一个没有有用信息的屏幕更有意义。
- en: 'Doing this is actually kind of tricky because you have to make sure that the
    data that’s required by the screen is fetched from the API each time the user
    navigates to the screen. Your goals should be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事实际上有点棘手，因为您必须确保每次用户导航到该屏幕时，屏幕所需的数据都是从API中获取的。您的目标应该是以下这些：
- en: Have the `Navigator` component automatically fetch API data for the scene that’s
    about to be rendered.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让`Navigator`组件自动获取即将渲染的场景的API数据。
- en: Use the promise that’s returned by the API call as a means to display the spinner
    and hide it once the promise has been resolved.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API调用返回的promise作为显示旋转器和在promise解析后隐藏它的手段。
- en: 'Since your components probably don’t care about whether a spinner is displayed
    or not, let’s implement this as a generic `Wrapper` component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的组件可能不关心是否显示旋转器，让我们将其实现为一个通用的`Wrapper`组件：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `LoadingWrapper` component takes a `children` component and returns it
    (read renders) under a `loading` condition. It has a `useEffect()` hook with a
    timeout, and when it resolves, it changes the `loading` state to `false`. As you
    can see, the `loading` state determines whether the spinner or the `children`
    component is rendered.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此`LoadingWrapper`组件接受一个`children`组件，并在`loading`条件下返回它（即渲染）。它有一个带有超时的`useEffect()`钩子，当它解析时，它会将`loading`状态更改为`false`。如您所见，`loading`状态决定了是渲染旋转器还是`children`组件。
- en: 'With the `LoadingWrapper` component in place, let’s take a look at the first
    screen component that you’ll use with `react-navigation`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LoadingWrapper`组件已经就位的情况下，让我们看看您将使用`react-navigation`的第一个屏幕组件：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This component renders a layout that’s wrapped with the `LoadingWrapper` component
    we created earlier. It wraps the whole screen so that a spinner is displayed while
    the `setTimeout` method is pending. This is a useful approach to hiding extra
    logic in one place and reusing it on every page. Instead of the `setTimeout` method,
    in a real app, you can pass additional props to the `LoadingWrapper` and have
    full control of `loading` state from that screen itself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件渲染了一个由我们之前创建的`LoadingWrapper`组件包裹的布局。它包裹了整个屏幕，以便在`setTimeout`方法挂起时显示一个旋转器。这是一种有用的方法，可以在一个地方隐藏额外的逻辑，并在每个页面上重用它。在实际应用中，您可以通过传递额外的属性到`LoadingWrapper`来完全控制该屏幕的`loading`状态。
- en: Measuring progress
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量进度
- en: The downside of just indicating that progress is being made is that there’s
    no end in sight for the user. This leads to a feeling of unease, like when you’re
    waiting for food to cook in a microwave with no timer. When you know how much
    progress has been made and how much is left to go, you feel better. That is why
    it’s always better to use a deterministic progress bar whenever possible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 仅指示进度正在进行的缺点是用户看不到结束的迹象。这会导致不安的感觉，就像你在没有计时器的微波炉里等待食物烹饪时一样。当你知道已经完成了多少进度以及还剩下多少进度时，你会感觉更好。这就是为什么在可能的情况下，始终使用确定性进度条会更好。
- en: Unlike the `ActivityIndicator` component, there’s no platform-agnostic component
    in React Native for progress bars. So, we’ll use the `react-native-progress` library
    for rendering progress bars.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ActivityIndicator`组件不同，React Native中没有跨平台的进度条组件。因此，我们将使用`react-native-progress`库来渲染进度条。
- en: In the past, React-Native had special components for showing progress bars for
    iOS and Android, but due to React-Native size optimization, the Meta team is working
    on moving such components to separate packages. So, `ProgressViewIOS` and `ProgressBarAndroid`
    have been moved outside of the React-Native library.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，React-Native有专门用于显示iOS和Android进度条的组件，但由于React-Native的大小优化，Meta团队正在努力将这些组件移动到单独的包中。因此，`ProgressViewIOS`和`ProgressBarAndroid`已经被移动到React-Native库之外。
- en: 'Now, let’s build the `ProgressBar` component that the application will use:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建应用程序将使用的`ProgressBar`组件：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ProgressBar` component accepts the `progress` property and renders the
    label and progress bar. The `<Progress.Bar />` component accepts a set of props,
    but we need only `width`, `progress`, and `useNativeDriver` (for better animation).
    Now, let’s put this component to use in the `App` component:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressBar`组件接受`progress`属性并渲染标签和进度条。《Progress.Bar />`组件接受一组属性，但我们只需要`width`、`progress`和`useNativeDriver`（用于更好的动画）。现在，让我们将这个组件用于`App`组件：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Initially, the `<ProgressBar>` component is rendered at 0%. In the `useEffect()`
    hook, the `updateProgress()` function uses a timer to simulate a real process
    that you want to show the progress of.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，`<ProgressBar>`组件渲染为0%。在`useEffect()`钩子中，`updateProgress()`函数使用计时器来模拟你想要显示进度的真实过程。
- en: In the real world, you’ll probably never use a simulation of timers. However,
    there are specific scenarios where this approach might be valuable, such as when
    displaying statistical data or monitoring the progress of file uploads to servers.
    In these situations, even though you’re not relying on a direct timer, you will
    still have access to a current progress value that you can use.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，你可能永远不会使用计时器的模拟。然而，在某些特定场景下，这种方法可能非常有价值，例如在显示统计数据或监控文件上传到服务器的进度时。在这些情况下，即使你并不依赖于直接的计时器，你仍然可以访问到当前进度值，并可以使用它。
- en: 'Here’s what the screen looks like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个屏幕的样子：
- en: '![Picture 3](img/B19636_24_03.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/B19636_24_03.png)'
- en: 'Figure 24.3: The progress bar'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.3：进度条
- en: Showing a quantitative measure of progress is important so that users can gauge
    how long something will take. In the next section, you’ll learn how to use step
    progress bars to show the user where they are in terms of navigating screens.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 显示进度的定量度量很重要，这样用户就可以判断某件事需要多长时间。在下一节中，你将学习如何使用步骤进度条来显示用户在导航屏幕中的位置。
- en: Step progress
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤进度
- en: In this final example, you’ll build an app that displays the user’s progress
    through a predefined number of steps. For example, it might make sense to split
    a form into several logical sections and organize them in such a way that, as
    the user completes one section, they move to the next step. A progress bar would
    be helpful feedback for the user.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，你将构建一个应用程序，显示用户通过预定义步骤的进度。例如，将表单分成几个逻辑部分并按这种方式组织它们，当用户完成一个部分时，他们就可以移动到下一个步骤。进度条对用户来说是一个有用的反馈。
- en: You’ll insert a progress bar into the navigation bar, just below the title,
    so that the user knows how far they’ve gone and how far is left to go. You’ll
    also reuse the `ProgressBar` component that you used earlier in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在导航栏中插入进度条，位于标题下方，这样用户就可以知道他们已经走了多远以及还剩下多远。你还将重用本章前面使用的`ProgressBar`组件。
- en: 'Let’s take a look at the result first. There are four screens in this app that
    the user can navigate. Here’s what the **First** page (scene) looks like:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看结果。在这个应用程序中，用户可以导航的屏幕有四个。这是**第一页**（场景）的样子：
- en: '![Picture 4](img/B19636_24_04.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/B19636_24_04.png)'
- en: 'Figure 24.4: The first screen'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.4：第一个屏幕
- en: 'The progress bar under the title reflects the fact that the user is 25% through
    the navigation. Let’s see what the **Third** screen looks like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 标题下的进度条反映了用户已经完成了导航的25%。让我们看看**第三**个屏幕的样子：
- en: '![Picture 5](img/B19636_24_05.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/B19636_24_05.png)'
- en: 'Figure 24.5: The third screen'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.5：第三个屏幕
- en: 'The progress is updated to reflect where the user is in the route stack. Let’s
    take a look at the `App` component here: [https://github.com/PacktPublishing/React-and-React-Native-5E/blob/main/Chapter21/step-progress-new/App.tsx](https://github.com/PacktPublishing/React-and-React-Native-5E/blob/main/Chapter21/step-progress-new/App.tsx).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 进度更新以反映用户在路由堆栈中的位置。让我们看看这里的`App`组件：[https://github.com/PacktPublishing/React-and-React-Native-5E/blob/main/Chapter21/step-progress-new/App.tsx](https://github.com/PacktPublishing/React-and-React-Native-5E/blob/main/Chapter21/step-progress-new/App.tsx)。
- en: This app has four screens. The components that render each of these screens
    are stored in the `routes` constant, which is then used to configure the stack
    navigator using `createNativeStackNavigator()`. The reason for creating the `routes`
    array is so that it can be used by the `progress` parameter that is passed by
    `initialParams` to every route. To calculate the progress, we take the current
    route index as a value of the route’s length.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用有四个屏幕。渲染每个屏幕的组件存储在`routes`常量中，然后使用`createNativeStackNavigator()`配置堆栈导航器。创建`routes`数组的原因是它可以由`initialParams`传递给每个路由的`progress`参数使用。为了计算进度，我们取当前路由索引作为路由长度的值。
- en: For example, `Second` is in the number 2 position (an index of 1 + 1) and the
    length of the array is 4\. This will set the progress bar to 50%.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Second`位于数字2的位置（索引为1 + 1），数组的长度为4。这将使进度条达到50%。
- en: Also, the **Next** and **Previous** buttons’ calls to `navigation.navigate()`
    have to pass `routeName`, so we added the `nextRouteName` and `prevRouteName`
    variables to the `screenOptions` handler.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**下一页**和**上一页**按钮调用`navigation.navigate()`时必须传递`routeName`，因此我们在`screenOptions`处理程序中添加了`nextRouteName`和`prevRouteName`变量。
- en: Summary
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to show your users that something is happening
    behind the scenes. First, we discussed why showing progress is important for the
    usability of an application. Then, we implemented a basic screen that indicated
    progress was being made. After that, we implemented a `ProgressBar` component,
    which is used to measure specific progress amounts.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何向用户展示幕后正在发生的事情。首先，我们讨论了为什么显示进度对于应用程序的可用性很重要。然后，我们实现了一个基本的屏幕，指示正在进行的进度。之后，我们实现了一个`ProgressBar`组件，用于测量特定的进度量。
- en: Indicators are good for indeterminate progress. We implemented navigation that
    showed progress indicators while network calls were pending. In the final section,
    we implemented a progress bar that showed the user where they were in a predefined
    number of steps.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 指示器适用于不确定的进度。我们实现了在网络调用挂起时显示进度指示器的导航。在最后一节中，我们实现了一个进度条，显示了用户在预定义的步骤中的位置。
- en: In the next chapter, we’ll look at React Native maps and geolocation data in
    action.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨React Native地图和地理位置数据在实际中的应用。
