- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routes and Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `index.html` page and, from there, all the content of the web application
    is rendered using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: From the user’s perspective, however, they are interacting with the application
    on different interfaces (or pages) such as the login screen, the home page, and
    the purchase form. Technically, they are all rendered on the `index.html` page
    but, for the user, they are different experiences.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism responsible for this flow of interfaces that the client interacts
    with in a SPA is the routing engine. The Angular framework has this feature out
    of the box and, in this chapter, we will explore it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Routes and navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining an error page and title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic routes – wildcards and parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing routes – guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the experience – Resolve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to use Angular’s routing mechanisms
    to create navigation flows that will improve your users’ experience.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch7](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch7).
  prefs: []
  type: TYPE_NORMAL
- en: While following this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: Routes and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s improve our project by creating a home page with a simplified menu for
    our interface, thereby exploring the possibilities we can have with Angular routes.
    In the command line, we’ll use the Angular CLI to create a new module and the
    component page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we first create a new module, and by using the `--routing`
    parameter, we instruct the Angular CLI to create the module along with the routing
    file. The following command creates the component we are working on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For more details about the Angular CLI and modules, you can refer to [*Chapter
    2*](B19562_02.xhtml#_idTextAnchor081), *Organizing* *Your Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create the template in the HTML file of the component we just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this template example, we are using the `<aside>` and `<main>` HTML elements
    to create the menu and the area where the selected pages will be projected. For
    this purpose, we are using the `<router-outlet>` directive to indicate the correct
    area to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the home page the main page, we need to modify the main routing module
    of our application in the `app-routing.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `routes` array is the main element of the Angular routing mechanism. We
    define objects in it that correspond to the routes our users will have access
    to. In this example, we defined that the root route (`"/"`) of our application
    will redirect the user to the `home` route using the `redirectTo` property.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we should use the `pathMatch` property with the `"full"` value. This is
    because it determines whether the Angular route engine will match the first route
    that matches the pattern (the default behavior, which is `"prefix"`), or whether
    it will match the entire route.
  prefs: []
  type: TYPE_NORMAL
- en: In the second object, we are defining the `home` route and loading the `Home`
    module lazily. For more details about lazy loading, you can refer to [*Chapter
    2*](B19562_02.xhtml#_idTextAnchor081), *Organizing* *Your Application*.
  prefs: []
  type: TYPE_NORMAL
- en: When running our application, we have the menu and the area where the pages
    of our workout diary will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the workout diary on the home page, we need to modify the `HomeRoutingModule`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this routes file, similar to the previous one, we define that the main route
    will direct to the `HomeComponent` component. However, here, we want the routes
    and modules to be rendered in the *router outlet* of the component instead of
    `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `children` property comes into play in which we will define the nested
    routes for this module. Since we want to use `DiaryComponent`, we are performing
    lazy loading of its module. This follows the Angular best practice of separating
    functional modules in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when running our application again, we have the diary page back.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Gym Diary home page with Diary](img/B19562_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Gym Diary home page with Diary
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude this session, let’s add the links for the new exercise entry in
    the `Home` template. Make the following modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are using the Angular `routerLink` directive to create the link in the template,
    specifying the URL it should navigate to.
  prefs: []
  type: TYPE_NORMAL
- en: An important detail to note is that we are using the relative path of the project
    to create the link using `./`. Since the entry form route is located in the diary
    module, Angular interprets that the module has already been loaded and allows
    the link without requiring an additional declaration in the `HomeRoutingModule`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s explore how to handle a scenario in which the user
    enters a date that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an error page and title
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our current project, if the user enters a path that does not have a mapped
    route, they will be faced with a blank screen. This is not a good **user experience**
    (**UX**) practice; ideally, we need to handle this error by presenting an error
    page for it to be redirected to the correct page.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create the component using the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating the component directly in `AppModule` because we want
    to give this treatment to our entire system and not to a specific functional module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the template for this component with the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have the link to the home page as a call to action for the user
    to return to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to update the `AppRoutingModule` routes file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At this point, Angular will do its job. Just by defining the error page route
    and then creating another entry in the array, we have defined the `'**'` path
    and redirected it to the error route.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run our project, if the user enters an incorrect page, the following
    message will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Incorrect route error page](img/B19562_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Incorrect route error page
  prefs: []
  type: TYPE_NORMAL
- en: Another point that we can improve in our application is the title of the page
    in the **Browser** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we can once again use Angular’s routing mechanisms. In `DiaryRoutingModule`,
    we need to change the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To change the title, we just need to inform the `title` property in the route
    definition. Another approach that is possible (but longer) is to use Angular’s
    `Title` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s exemplify this in the `NewEntryFormTemplateComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After injecting the `Title` service, we are using it in the `OnInit` lifecycle
    hook. Although the route approach is much simpler and more intuitive, the `Title`
    service can be used if the title can change dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: We will now learn how to pass information from one route to another in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routes – wildcards and parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to change the function of the **New Rep** button so that instead of
    adding a rep to the entry, the user can actually edit the entry, opening the form
    with the data filled in.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add a new method to the `ExerciseSetsService` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In addition to creating the new method by getting a specific item, we also prepared
    the `update` method to accept `Partial` of the `ExerciseSet` object.
  prefs: []
  type: TYPE_NORMAL
- en: The form for editing the diary entry will be the same as for adding a new entry,
    with the difference that it will be filled in and will call the `update` method.
    So, let’s reuse the `NewEntryFormReactiveComponent` component for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by editing the `DiaryRoutingModule` routes file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `route` array, we change the route of the new form to `entry` and create
    the `entry/:id` route.
  prefs: []
  type: TYPE_NORMAL
- en: This route is pointing to the same component, but note that `:id` tells Angular
    that it is a dynamic route – that is, it will receive a variable value that must
    be directed to the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this change, we need to refactor some parts of our application. In the
    `HomeComponent` menu, let’s adjust the application route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to adjust the journal and input components to call the new route
    instead of increasing the number of repetitions. In the `EntryItemComponent` component,
    we are going to adjust the component’s method and `Output` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we remove the treatment and just emit the event. In the template, we
    will adjust the HTML content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also adjust the `ListEntriesComponent` component to properly propagate
    `editEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll make a small change to the diary to reflect the new route. We’ll do this
    in the template first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the component, we will change the `newRep` method, which, in addition to
    the name change, will redirect to the new route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To redirect to the new route, we are doing string interpolation to include
    `id` that was emitted by the output of the list item. Finally, let’s focus our
    attention on the form. In the `NewEntryFormReactiveComponent` component, let’s
    adjust the `button` label in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `NewEntryFormReactiveComponent` component, we will adapt it to now be
    the form for creating and editing entries in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we use the `OnInit` lifecycle hook to configure the form according
    to the route it was called. For this, Angular has a service called `ActivatedRoute`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ngOnInit` method, we capture the parameter of the route that called
    our application and, if the component receives the ID, it will fetch the entry
    from the backend and update the form according to the return.
  prefs: []
  type: TYPE_NORMAL
- en: One detail here is that we are using the destructuring assignment to remove
    the `id` field from the object because it does not exist in the form’s data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same component, we need to change the recording of the diary entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `newEntry` method, if the component has received the object’s `id` via
    the route, it will behave as an edition and call the corresponding method of the
    `exerciseSetsService` service.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the project, we now have the input edit form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Gym Diary edit entry form](img/B19562_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Gym Diary edit entry form
  prefs: []
  type: TYPE_NORMAL
- en: From version 16 of Angular, we have an improvement in the use of route parameters.
    In addition to the `ActivatedRoute` service, we can map the inputs of page components
    directly to route variables in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor our example to this; first, change the main routing module,
    `AppRoutingModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To use this resource, we need to add the `bindToComponentInputs` attribute in
    the general configuration of the application’s route.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our form page, we will refactor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We create `Input` for the `entryId` property and define that the route’s wildcard
    variable will be `id`. We did this to prevent needing to refactor the rest of
    the component, but we could also change the property name to also be `id`, as
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The important thing here is that Angular automatically binds the information
    that comes from the route in the attribute, simplifying even more the passing
    of parameters via the URL to the component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to protect the route from being incorrectly
    accessed by studying route guards.
  prefs: []
  type: TYPE_NORMAL
- en: Securing routes – guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve seen how to take data through the route to determine the behavior
    of a `page` component. However, the routing created in Angular is versatile and
    also allows you to shape the customer’s journey by conditioning resources based
    on a business rule.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this feature, we are going to create a login screen with a simplified
    authentication mechanism. To create the components, we are going to use the Angular
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command prompt of your operating system, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first command creates a `Login` module with the `routes` file. The second
    creates the `login` page component and, finally, we have the service that will
    manage the interaction with the authentication of our backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Login` module, we will configure the dependencies of the new module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s add the new module to `AppRoutingModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `LoginRoutingModule` module, we will configure the component we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the handling of the request and response payload of our authentication
    service, let’s create an interface with the new types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `LoginForm` interface corresponds to the data that we are going to send
    and the `Token` interface is the API return, which is basically the access token
    that the application will send the client’s JWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the interface created, let’s create a service that will orchestrate the
    interaction with the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this service, we make the request to the backend using the `HttpClient` service
    (for more details, read [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163), *Angular
    Services and the Singleton Pattern*). We are using the RxJS tap operator so that
    as soon as the request is successful, it saves the token in a `service` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is through this variable that we create the `isLogged` property, which will
    be important for controlling the route. With the services created, we can develop
    the `Login` page template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When creating `Login` pages, an important point is to correctly use the HTML
    `input` field types for the correct UX treatment and accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the template completed, let’s develop the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are creating the reactive form, and in the `login` method,
    we are using the `AuthService` service. Run the project and, in `url /login`,
    we will have our login screen. To use the screen, we have the username `mario`
    and password `1234`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Login page](img/B19562_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Login page
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the logout treatment, we will create a link in the `HomeComponent`
    component menu and create the `logout` method in it, redirecting to the login
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With the page created, now we need a way to guarantee access to the diary only
    if the user is logged in. For this type of route checking, we should use Angular’s
    **route** **guard** feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create it, we can count on the help of the Angular CLI; in the command line,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A selection list will be presented; choose **CanActivate**. In the new file,
    let’s create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Since version 14, the recommended way to create route guards is through functions
    and not classes.
  prefs: []
  type: TYPE_NORMAL
- en: We are creating the `authGuard` function that has the `CanActivateFn` interface,
    which is a function that expects a Boolean return or an object of the `UrlTree`
    class to redirect the user to the indicated route.
  prefs: []
  type: TYPE_NORMAL
- en: In the function, we first inject the `AuthService` and `Router` services; notice
    that the `inject` function in this context is mandatory because, in a function,
    we don’t have a constructor to inject the services.
  prefs: []
  type: TYPE_NORMAL
- en: With the services configured, we make an `if` statement evaluating the `isLogged`
    service property. We return `true` if the user is logged in, allowing the route
    to be navigated. Otherwise, we return an object of the `UrlTree` class with the
    login page route.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the guard, let’s change `DiaryRoutingModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By using the `canActivate` attribute, we can pass one or more route guards.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application, we can see that we are directed to the login page.
    But if we directly call the `/home/diary/entry` route, we realize that it is not
    protected. This happens because we set `guard` only on the `/``diary` route.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we can set the `canActivate` attribute on all routes, but a more
    effective way would be to change the type of the route to `CanActivateChild`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the `route` function, let’s change its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to refactor `DiaryRoutingModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a component-less route pattern; basically, we create a route
    without a component and put all the routes as children of it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the `canActivateChild` attribute to call the route’s guard, so
    we don’t need to repeat all the routes in this module.
  prefs: []
  type: TYPE_NORMAL
- en: The route guard feature can do more for your application than flow control;
    we can improve its perceived performance, as we’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the experience – Resolve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance is one of the biggest variables that impact the experience and satisfaction
    of our users; therefore, optimal performance should be a constant goal for the
    web developer.
  prefs: []
  type: TYPE_NORMAL
- en: Perceived perception is the game we want to win, and we have plenty of options
    in the Angular ecosystem. We can load the information that our page will require
    before it renders and, for that, we will use the Resolveroute saver resource.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the guard we studied earlier, its purpose is to return information needed
    by the page being directed by the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create this guard using the Angular CLI. In your command prompt, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the new file created, let’s change the function that the Angular CLI generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The function injects the `ExerciseSetsService` service and returns the observable
    returned by the `getInitialList` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure `DiaryRoutingModule` with this new resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `resolve` property, much like configuring a route guide, with
    the difference that we associate an object with the function, which will be important
    for the component to consume the data generated by it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DiaryComponent` component, we will refactor the component to consume
    data from the resolver instead of fetching the information from the service directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The component is now consuming the `data` attribute of the route. It returns
    an observable that has an object with the `diaryApi` attribute – the same one
    we configured in the `routes` module.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our project again, we see that the behavior of the screen does not
    change externally; however, internally, we are fetching information from the gym
    diary before the component is loaded. This change in our example may have been
    imperceptible, but in a larger and more complex application, it could be the difference
    that you and your team are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to bear in mind that this will not speed up the request to the
    backend. It will take the same time as before, but the performance perception
    that your user will have may be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do this same treatment to load the diary entry edit page; in the same
    `resolve` file, we will create a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The function injects the service but, this time, we are using the `route` parameter
    to extract the `id` of the entry to load it. This parameter is offered by Angular
    so that you can extract any attribute from the route in which you will configure
    the resolver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `route` module, we will add the `resolve` function to the edit route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to refactor the component to use the route guard information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the same way as we did with the diary page, here, we are replacing the consumption
    of the service with the consumption of the route.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with routes and their resources to guide and organize
    user flows in our application. We learned about the router concept in the Angular
    framework and created an error page in case a user uses a route that does not
    exist. We created our edit diary entry page by reusing a form and, with the dynamic
    route feature, we learned how to capture route data for page setup.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the route guards feature, created our simplified login
    flow, and saw how to optimize the user experience by loading the backend information
    before the page loads using the guard resolve feature.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use a resource to streamline our requests
    to the backend using the interceptor design pattern.
  prefs: []
  type: TYPE_NORMAL
