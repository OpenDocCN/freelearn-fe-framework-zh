<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Rethinking User Interfaces with Flux, Vue, and Vuex</h1>
                </header>
            
            <article>
                
<p>I started my first job as a Java EE programmer at the end of 2007. I still remember my friend Giuseppe saying, <em>You don't like JavaScript, do you?</em> and me answering, <em>No, I don't. Each time I write something in JavaScript, it doesn't work in all versions of Internet Explorer... not to mention Firefox!</em> He just replied, <em>Have a look at jQuery</em>. Today, I like to call myself a JavaScript programmer.</p>
<p>Since then, web development has evolved a lot. A number of JavaScript frameworks became popular and then declined because new frameworks emerged. You may think that it <span>is not worth</span> <span>learning new frameworks  since they will eventually decline in popularity. Well, in my opinion, that is not true. Each framework added something useful to web development, something that we still use. For example, jQuery made use of JavaScript that was so simple that we started moving client logic to the browser instead of rendering everything server-side.</span></p>
<p>Today, we write progressive web applications that are complex applications with web user interfaces. This complexity requires discipline and best practices. Fortunately, big companies such as Facebook, Google, and others have introduced frameworks and guidelines to help web programmers. You may have heard about Google's <em>Material Design</em> or Facebook's <em>Flux</em>.</p>
<p>In this chapter we will focus on the following:</p>
<ul>
<li><strong>Model-view-controller</strong> (<strong>MVC</strong>) problems, and using Facebook Flux architecture to solve these problems</li>
<li>Flux fundamentals</li>
<li>What Vuex is</li>
<li>Architectural differences between Flux and Vuex</li>
</ul>
<p>To understand this book, you need a good knowledge of Vue.js and JavaScript, a basic understanding of ECMAScript 6, and a very basic knowledge of webpack. In any case, almost all the concepts used here, Vuex and otherwise, are explained.</p>
<p>After explaining the Flux concepts, this book will help you understand how Vuex implements these concepts, how to use Vue.js and Vuex to build professional web applications, and finally how to extend Vuex functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MVC problems and the Flux solution</h1>
                </header>
            
            <article>
                
<p>Each time we speak about an application with a user interface, the MVC pattern comes out. But what is the MVC pattern? It is an architectural pattern that divides components into three parts: a <strong>Model</strong>, a <strong>View</strong>, and a <strong>Controller</strong>. You can see <span>the classic diagram describing MVC </span><span>in the following figure:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/97330382-a3be-4205-9fb3-64fcd418944f.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.0: Classic MVC diagram</div>
<p>Most of the modern frameworks for progressive web applications use the MVC pattern. In fact, if you look at the Vue.js single file component shown in the following figure, you can clearly see the three parts of the MVC pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c0ea9c0a-8155-4ab5-b80c-35373ae3fcec.png" style=""/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Figure 1.1: Vue.js single file component</div>
<p>The <kbd>template</kbd> and <kbd>style</kbd> parts represent the view section,  the <kbd>script</kbd> part provides the controller, and the <kbd>data</kbd> section of the controller is the model.</p>
<p>But what happens when we need some data from the model of a component that's inside another component? Moreover, in general, how can we interconnect all the components of a page?</p>
<p>Clearly, providing direct access to the model of the components from other components is not a good idea. The following screenshot shows the dependencies in the case of exposing the models:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6574c3ed-6a76-4d69-94d5-29984a28dc37.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.2: MVC hell</div>
<p>Vue.js provides a good way of communicating between parent and child components: You can use P<em>rops</em> to pass values from a parent to a child component, and you can <em>emit</em> data from a child component to its parent. The following figure shows a visual representation of this concept:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/99cc432f-79f5-46f8-badc-398fd5b46feb.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.3: Vue.js parent–child communication</div>
<p>However, when multiple components share a common state, this way of communicating is not enough. The following are the issues that would come up:</p>
<ul>
<li>Multiple views may share the same piece of state</li>
<li>User actions from different views may need to change the same piece of state</li>
</ul>
<p><span>Some frameworks provide a component called <kbd>EventBus</kbd>; in fact, the Vue instance itself is an <kbd>EventBus</kbd>. It has two methods: <kbd>Vue.$emit(event, [eventData])</kbd> and <kbd>Vue.$on(event, callback([eventData]))</kbd></span>. The following is an example of how to create a global event bus:</p>
<pre><span>// EventBus.js<br/>import </span>Vue <span>from </span><span>'vue'</span><span>;<br/></span><span>export const </span>EventBus = <span>new </span>Vue()<span>;<br/></span><span><br/></span><span>// HelloWorldEmitter.js<br/><span class="kr"><span class="hljs-keyword">import</span></span> <span class="p">{</span> <span class="nx">EventBus</span> <span class="p">}</span> <span class="nx"><span class="hljs-keyword">from</span></span> <span class="s1"><span class="hljs-string">'./EventBus.js'</span></span><span class="p">;</span><br/></span>EventBus.<span>$emit</span>(<span>'an-event'</span><span>, 'Hello world'</span>)<span>;<br/></span><span><br/>// HelloWorldReceiver.js<br/>import { EventBus } from './EventBus.js';<br/></span>EventBus.<span>$on</span>(<span>'an-event'</span><span>, </span>eventData =&gt; {<br/> console.<span>log</span>(eventData)<span>;<br/></span>})<span>;</span></pre>
<p>Even with a global event bus, making components communicate is not easy. What if a component that registers to an event gets loaded after the event is fired? It will miss the event. This may happen if that component is inside a module that gets loaded later, which is likely to happen in a progressive web app where modules are lazily loaded.</p>
<p>For example, say that a user wants to add a product to the cart list. She taps on the <em><span class="packt_screen">Add to cart</span></em> button, which is likely to be in the <kbd>CartList</kbd> component, and she expects the product she sees on the screen to be saved in the cart. How can the <kbd>CartList</kbd> component find out what the product is that should be added to its list?</p>
<p>Well, it seems that Facebook programmers faced similar problems, and to solve those problems, they designed what they called <em>Flux</em>: Application architecture for building user interfaces.</p>
<p>Inspired by Flux and Elm architecture, Evan You, the author of  <em>Vue.js</em>, created Vuex. You may know Redux already. In that case, you will find that Vuex and Redux are similar, and that Evan You saved us time by implementing Vuex instead of forcing every programmer to integrate Redux inside a Vue.js application. In addition, Vuex is designed around Vue.js to provide the best integration between the two frameworks.</p>
<p>But what is Vuex? That is the topic of the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is Vuex?</h1>
                </header>
            
            <article>
                
<p>Evan You<em> </em>defines Vuex as:</p>
<div class="packt_quote"><em> "</em>state management pattern + library for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion."</div>
<p>Without knowing Flux, this definition sounds a little bit obscure. Actually, Vuex is a Flux implementation that exploits the reactivity system of Vue using a <span>single, centralized store, and ensures that <em>the state can only be mutated in a predictable fashion</em></span>.</p>
<p>Before focusing on Vuex itself, we are going to understand the <span>fundamentals</span><span> of</span><span> Flux and how Vuex took inspiration from these concepts.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the Flux fundamentals</h1>
                </header>
            
            <article>
                
<p><span>Flux is a pattern for managing data flow in your application, and it is the application architecture that Facebook uses for building its web applications. The following diagram shows the structure and data flow in Flux:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/022c599e-8a98-4e29-947f-fde93d093c77.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.4: Structure and data flow in Flux</div>
<p>As shown in the preceding figure, Flux is divided into four parts, and <em>data flows in only one direction</em>. In the next sections, we will see how data flows through the following parts:</p>
<ul>
<li>Actions</li>
<li>Dispatchers</li>
<li>Stores</li>
<li>Views</li>
</ul>
<p>Although it is important to understand how Flux works, Vuex has its own implementation of Flux architecture that differs from Flux, and it will be explained in detail in the following chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Actions</h1>
                </header>
            
            <article>
                
<p><span>Actions define the internal API of your application. They represent what can be done, but not how it is done. The logic of state mutation is contained inside stores. An action is simply an object with a type and some data. </span></p>
<p>Actions should be meaningful to the reader and they should avoid implementation details. For example, <kbd>remove-product-from-cart</kbd><span> </span>is better than splitting it into<span> </span><kbd>update-server-cart</kbd>,<span> </span><kbd>refresh-cart-list</kbd>, and<span> </span><kbd>update-money-total</kbd>.</p>
<p>An action is dispatched to all the stores and it can cause more than one store to update. So dispatching an action will result in one or more stores executing the corresponding action handler.</p>
<p>For example, when a user taps on the<span> </span><em><span class="packt_screen">Remove from cart</span></em><span> </span>button, a <kbd>remove-product-from-cart</kbd><span> </span>action is dispatched:</p>
<pre>{type: 'remove-product-from-cart', productID: '21'}</pre>
<p>In Vuex, the action system is a bit different, and it splits Flux actions into two concepts:</p>
<ul>
<li>Actions</li>
<li>Mutations</li>
</ul>
<p>Actions represent a behavior of an application, something that the application must do. The result of an action consists typically of one or more mutations being committed. Committing a mutation means executing its associated handler. It is not possible to change the Vuex state directly inside an action; instead, actions commit mutations.</p>
<p class="mce-root">You have to deal with asynchronous code inside actions, since mutations must be synchronous.</p>
<p class="mce-root">Mutations, on the other hand, can and do modify the application state. They represent the application logic directly connected to the application state. Mutations should be simple, since complex behavior should be handled by actions.</p>
<p>Since there is only one store in Vuex, actions are dispatched using the store, and there is a direct connection between an action and its handler. In Flux, on the other hand, every store knows what to do when responding to the action.</p>
<p>You will read about the Vuex action/mutation system in the following chapters. Right now, you just need to understand the concepts behind actions, and that Vuex implements actions in a slightly different way than the one used by Flux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dispatcher</h1>
                </header>
            
            <article>
                
<p>There is only one dispatcher per application, and it receives actions and dispatches them to the stores. Every store receives every action. It is a simple mechanism to dispatch actions, and it can handle dependencies between stores by dispatching actions to the stores in a specific order.</p>
<p>For example:</p>
<ol>
<li>A user taps on the <em><span class="packt_screen">Add to cart</span></em> button</li>
<li>The view captures this event and dispatches an <kbd>add-to-cart</kbd> action</li>
<li>Every store receives this action</li>
</ol>
<p><span>Since </span><span>Vuex differs from Flux because the dispatcher is inside the store, what you should remember here </span>is that every change in the application begins by dispatching an action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stores</h1>
                </header>
            
            <article>
                
<p>Stores contain the application state and logic. Stores can be mutated only by actions and do not expose any setter method. T<span>here can be more than one store i</span><span>n Flux, each one representing a domain within the application.</span> In Vuex, there is only one store, and its state is called a single state tree<span>. Vuex is not the only framework that enforces the use of a single store: Redux explicitly states that there is one store per Redux application. You may think that a single store may break modularity. We will see later how modularity works on Vuex.</span></p>
<p>Before switching to Flux architecture, Facebook chat kept experiencing a bug where the number of unread messages was wrong. Instead of having two lists—one of read messages and another of unread ones—they used to derive the number of unread messages from other components events. It is indeed better to have an explicit state where all the information is stored. Think of the state as an application snapshot: You could save it before the application page gets closed and restore it when the application gets opened again so that the user will find the application in the same state it was left in.</p>
<p>There are three important concepts regarding stores:</p>
<ul>
<li>Stores can be mutated only by actions</li>
<li>Once a store is mutated, it notifies it has changed to the views</li>
<li>Stores represent explicit data, as opposed to deriving data from events</li>
</ul>
<p>Here is an example of a store reacting to the<span> </span><kbd>add-to-cart</kbd> action dispatched in the previous example:</p>
<ol>
<li>The store receives the <kbd>add-to-cart</kbd> action</li>
<li>It decides it is relevant and executes the logic of the action by adding the current product to the cart product list</li>
<li>It updates its data and then notifies the views that it has changed</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Views</h1>
                </header>
            
            <article>
                
<p>Views, or view controllers, display data from the stores. Here is where a framework like Vue.js plugs in.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering data in the stores</h1>
                </header>
            
            <article>
                
<p>In the Facebook video introducing Flux, software engineer Jing Chen talks about some of the problems they faced while developing Facebook Chat, and what lessons they learned. One interesting lesson they learned concerns rendering: They didn't want to rerender all the messages in the chat, but instead wanted to optimize it a bit by updating the chat view with only the new messages. If you are an experienced programmer, you may think, T<em>his is a premature optimization</em>. Indeed it is! It is much more simple to pass <span>the whole view-model</span><span> </span><span>to the views rather than just pass the differences from the old and new model.</span></p>
<p>Say that a programmer wants to add a new feature to a view: If the view-model is rendered by the view each time it is modified, they just need to add some properties to the model and add some code to the view to display these new properties. They don't need to worry about updating/rendering logic.</p>
<p>But what about performance? Isn't it bad to rerender the whole page just because the number of unread messages has changed? Here, Vue.js comes to help us. A programmer just needs to update the view-model and Vue.js will understand what has changed and will rerender only the <strong>Document Object Model</strong> (<strong>DOM</strong>) parts that actually changed. The following diagram schematizes this concept: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/37625ad0-2d63-46fe-891d-02d91f4d847c.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1.5: Vue.js updating a DOM node</div>
<p>The lesson is this: Spend time on designing explicit, meaningful models and let Vue.js take care of the performance and rendering logic.</p>
<div class="packt_infobox"><span>The <strong>DOM</strong> is used to render a web page. See <a href="https://www.w3schools.com/js/js_htmldom.asp">https://www.w3schools.com/js/js_htmldom.asp</a> for more information.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stores and private components model</h1>
                </header>
            
            <article>
                
<p>Since views display data from stores, you may think that a view-model is just a portion of a store. Actually, each component can have a private model that can hold values that are needed just inside the component. There is no need to put every value in a store. Stores should contain only data relevant to the application.</p>
<p>For example, say you want to select some photos from a list and share them. The view-model of the photo list component will contain the list of selected photos, and when a user taps on the<span> </span><span class="packt_screen">Share</span> button, the view-controller just needs to dispatch an action called<span> </span><kbd>share-photos</kbd> with the selected photo list as data in the <kbd>action</kbd> object. There is no need to put the selected photo list inside a store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summarizing Flux architecture</h1>
                </header>
            
            <article>
                
<p>The following is the Flux architecture summarized in a single image:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9a48c973-8e31-4f23-942f-560cb9cbdd84.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1.6: Flux data flow explained </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits of using Flux</h1>
                </header>
            
            <article>
                
<p>The following are<span> </span>some of the benefits that Facebook gained after introducing Flux to their web applications:</p>
<ul>
<li>Better scalability than the classic MVC</li>
<li>Easy-to-understand data flow</li>
<li>Easier and more effective unit tests</li>
<li>Since actions represent behaviors of the application, behavior-driven development is a perfect match to write applications using Flux architecture</li>
</ul>
<p>By adding the Vuex framework to your <kbd>Vue.js</kbd> application, you will experience the same benefits. In addition, Vuex, like Redux, simplified this architecture in several different ways, such as using a single store per application and removing the dispatcher from the process in favor of using the store to dispatch actions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at why Facebook engineers designed the Flux architecture. We focused on the fundamentals of Flux and learned that Vuex <span>differs</span><span> </span><span>slightly from Flux. We can now summarize Flux in one sentence: Flux is a predictable state management system with a one-way data flow.</span></p>
<p>In <a href="80f5c4a1-49e4-44f6-aa6e-8012d8608f3d.xhtml" target="_blank">Chapter 2</a>, <em>Implementing Flux Architecture with Vuex</em>, you will learn the <span>core concepts</span><span> of Vuex, as well as how you can use Vuex in your applications.</span></p>


            </article>

            
        </section>
    </body></html>