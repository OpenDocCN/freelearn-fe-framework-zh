- en: '*Chapter 3*: Building a Dynamic Project Management Board'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*: 构建动态项目管理板'
- en: In the first two chapters of this book, you created two React projects all by
    yourself, and you should, by now, have a solid understanding of the core concepts
    of React. The concepts you've used so far will also be used in this chapter to
    create your third project with React, including some new and more advanced concepts
    that will show you the strength of using React. Again, if you feel you lack some
    of the knowledge you'll need to finalize the contents of this chapter, you can
    always repeat what you have built so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前两章中，你独立创建了两个React项目，到现在你应该已经对React的核心概念有了扎实的理解。你到目前为止所使用的概念也将在本章中用于创建你的第三个React项目，包括一些新的更高级的概念，这些概念将展示使用React的优势。再次提醒，如果你觉得你缺少完成本章内容所需的一些知识，你总是可以重复你迄今为止所构建的内容。
- en: This chapter will once again use Create React App, which you used in the previous
    chapter. During the development of the project management board application for
    this chapter, we'll create and use a custom Hook for data fetching. HTML5 web
    APIs will be used to dynamically drag and drop components, which are set up as
    reusable components with `styled-components`. Following this, you'll use more
    advanced React techniques to control the data flow throughout your components,
    such as by creating custom Hooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将再次使用Create React App，这是你在上一章中使用过的。在本章的项目管理板应用开发过程中，我们将创建并使用一个自定义钩子进行数据获取。将使用HTML5网络API动态拖放组件，这些组件被设置为可重用组件，并使用`styled-components`进行样式设置。随后，你将使用更高级的React技术来控制组件间的数据流，例如通过创建自定义钩子。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Handling the data flow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据流
- en: Working with custom Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义钩子
- en: Using HTML5 web APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5网络API
- en: Styling React with `styled-components`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`styled-components`为React添加样式
- en: Project overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a dynamic project management board that has
    reusable React components and styling using Create React App and `styled-components`.
    The application will feature a dynamic drag and drop interface that uses the HTML5
    Drag and Drop API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个动态项目管理板，它使用Create React App和`styled-components`具有可重用React组件和样式。该应用将具有一个使用HTML5拖放API的动态拖放界面。
- en: The build time is 1.5–2 hours.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间约为1.5-2小时。
- en: Getting started
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'The project that we''ll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter03-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter03-initial).
    The complete source code for this application can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter03).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将创建的项目基于GitHub上可找到的初始版本：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter03-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter03-initial)。该应用的完整源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter03)。
- en: After downloading the initial application from GitHub, we can start by moving
    into its root directory and running the `npm install` command. This will install
    the core packages from Create React App (`react`, `react-dom`, and `react-scripts`).
    After the installation, we can start the application by executing the `npm start`
    command and visit the project in the browser by visiting `http://localhost:3000`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下载初始应用后，我们可以先进入其根目录，并运行`npm install`命令。这将安装Create React App的核心包（`react`、`react-dom`和`react-scripts`）。安装完成后，我们可以通过执行`npm
    start`命令来启动应用，并在浏览器中通过访问`http://localhost:3000`来访问项目。
- en: As shown in the following screenshot, the application has a basic header with
    a title and is divided into four columns. These columns are the lanes for the
    project management board and will contain the individual tasks once we've connected
    the project to the data file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，应用有一个带有标题的基本页眉，并分为四个列。这些列是项目管理板的通道，一旦我们将项目连接到数据文件，它们将包含个别任务。
- en: '![Figure 3.1 – The initial application'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 初始应用'
- en: '](img/Figure_3.1_B17390.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1]'
- en: Figure 3.1 – The initial application
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 初始应用
- en: If we look at the project's structure, we'll see that it's structured in the
    same way as the projects in the previous chapters. The entry point of the application
    is the `src/index.js` file, which renders a component called `App`, which holds
    two other components called `Header` and `Board`. The first one is the actual
    header of the application, while the `Board` component holds the four columns
    we can see in the application. These columns are represented by the `Lane` component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看项目的结构，我们会看到它与上一章的项目结构相同。应用程序的入口点是`src/index.js`文件，它渲染一个名为`App`的组件，该组件包含两个其他组件，即`Header`和`Board`。第一个是应用程序的实际头部，而`Board`组件包含我们在应用程序中可以看到的四个列。这些列由`Lane`组件表示。
- en: 'In this application, you can see that we''ve further split up the components
    into separate directories. Every component in either the `components` or `pages`
    directory now has its own subdirectory:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，你可以看到我们已经将组件进一步拆分到单独的目录中。现在，`components`或`pages`目录中的每个组件都有自己的子目录：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a project management board application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目管理板应用程序
- en: In this section, we'll create a project management board PWA that uses custom
    Hooks for data fetching and the HTML5 Drag and Drop API to make it dynamic. We're
    going to use a boilerplate application that is set up with Create React App, which
    we can find in the GitHub repository for this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个使用自定义钩子进行数据获取和HTML5拖放API使其动态化的项目管理板PWA。我们将使用一个由Create React App设置的样板应用程序，我们可以在本章的GitHub仓库中找到它。
- en: Handling the data flow
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理数据流
- en: With the initial version of the application in place, the next step is to fetch
    the initial data for the project management board and handle its flow through
    the components. For this, we will create a custom Hook for data fetching that
    can be reused in other components.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的初始版本就绪后，下一步是获取项目管理板初始数据并处理其通过组件的流动。为此，我们将创建一个用于数据获取的自定义钩子，该钩子可以在其他组件中重用。
- en: The first part of this section will show us how to load data from a data source
    using React life cycle methods and display this in React components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的第一部分将展示我们如何使用React生命周期方法从数据源加载数据，并在React组件中显示这些数据。
- en: Loading and displaying the data
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和显示数据
- en: Loading and displaying data that is retrieved from a data source is something
    we did in the previous chapter. The data used in this chapter is coming from a
    mock REST API, created with My JSON Server from Typicode. Using a file called
    `db.json`, which is placed in the repository for this book, we can automatically
    create REST endpoints.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和显示从数据源检索到的数据是我们上一章所做的事情。本章使用的数据来自一个模拟的REST API，由Typicode的My JSON Server创建。使用名为`db.json`的文件，该文件位于本书的仓库中，我们可以自动创建REST端点。
- en: '![Figure 3.2 – Using My JSON Server'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 使用My JSON Server'
- en: '](img/Figure_3.2_B17390.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B17390.jpg)'
- en: Figure 3.2 – Using My JSON Server
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 使用My JSON Server
- en: Using My JSON Server, the [https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/tasks](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/tasks)
    endpoint returns a list of tasks, which we'll load into our project management
    board in this section. The response is an array consisting of objects that contain
    information about our tasks defined in the id, title, body, and lane fields.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用My JSON Server，[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/tasks](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/tasks)端点返回一个任务列表，在本节中我们将将其加载到我们的项目管理板中。响应是一个包含id、标题、正文和通道字段中定义的任务信息的对象数组。
- en: 'This section will explore this further. Follow these steps to get started:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将进一步探讨这个问题。按照以下步骤开始：
- en: 'We will start by fetching the project data from the data file. To do this,
    we need to add the necessary functions to the `Board` component. We need these
    to access the React life cycles using Hooks, which we already did in the earlier
    chapters:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从数据文件中获取项目数据。为此，我们需要向`Board`组件添加必要的函数。我们需要这些函数来使用Hooks访问React生命周期，这我们在前面的章节中已经做了：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `useEffect` Hook, the data is fetched inside a `try..catch` statement.
    This statement catches any errors that are being returned from the data fetching
    process and replaces the error state with this message.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`useEffect`钩子中，数据是在`try..catch`语句中获取的。这个语句捕获数据获取过程中返回的任何错误，并用此消息替换错误状态。
- en: 'Now, we can distribute the tasks over the corresponding lanes:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将任务分配到相应的通道上：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `return` statement, you can see a function that iterates over the `lanes`
    constant and that these values are passed as props to the `Lane` component. Also,
    something special is going on when we pass the tasks to the components since the
    `filter` function is being used to only return tasks from the tasks state that
    match the lane ID.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`return`语句中，你可以看到一个迭代`lanes`常量的函数，并将这些值作为props传递给`Lane`组件。另外，当我们向组件传递任务时，有一些特别的事情正在发生，因为`filter`函数正在被用来只返回与lane
    ID匹配的任务状态。
- en: 'Next, we need to make some changes to the `Lane` component so that it will
    use the data that we fetched from the REST API to display the tasks for us:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要对`Lane`组件做一些修改，以便它能够使用我们从REST API获取的数据来显示任务：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Lane` component now takes three other props, which are `tasks`, `loading`,
    and `error`, where `tasks` contains the array of tasks from the REST API, `loading`
    indicates whether the loading message should be displayed, and `error` contains
    the error message when there is one. We can see that inside the `map` function
    to iterate over the tasks, the `Task` component that displays the information
    will be rendered.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lane`组件现在接受另外三个props，分别是`tasks`、`loading`和`error`，其中`tasks`包含从REST API获取的任务数组，`loading`指示是否应显示加载消息，而`error`包含当存在错误时的错误消息。我们可以看到，在`map`函数中迭代任务时，将渲染显示信息的`Task`组件。'
- en: 'To create this task, we need to create a directory called `Task` in the `components`
    directory and place a new file for the `Task` component inside. This new file
    is called `Task.js`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建此任务，我们需要在`components`目录中创建一个名为`Task`的目录，并在其中放置一个名为`Task.js`的新文件，用于`Task`组件：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This component takes its styling from another file that we need to create inside
    the `Task` directory, which is called `Task.css` and has the following contents:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此组件从我们需要在`Task`目录内创建的另一个文件中获取样式，该文件名为`Task.css`，内容如下：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we visit our application in a web browser at `http://localhost:3000`, we
    will see the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在网页浏览器中访问我们的应用程序`http://localhost:3000`，我们将看到以下内容：
- en: '![Figure 3.3 – Our application with data from the mock REST API'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 我们的应用程序，使用模拟REST API的数据'
- en: '](img/Figure_3.3_B17390.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.3_B17390.jpg)'
- en: Figure 3.3 – Our application with data from the mock REST API
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 我们的应用程序，使用模拟REST API的数据
- en: Fetching data from a data source is logic that can be reused throughout our
    application. In the next section, we will explore how this logic can be reused
    across multiple components by creating a custom Hook.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据源获取数据是可以在我们的应用程序中复用的逻辑。在下一节中，我们将探讨如何通过创建自定义Hook来跨多个组件复用这种逻辑。
- en: Working with custom Hooks
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义Hooks
- en: Hooks are a way to use React features for creating local state or to watch for
    updates in that state using life cycles. But Hooks are also a way to reuse logic
    that you create for your own React application. This is a pattern that is popular
    among a lot of libraries that create functionalities for React, such as `react-router`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks是一种使用React功能来创建本地状态或使用生命周期来监视该状态更新的方法。但Hooks也是复用你为React应用程序创建的逻辑的一种方式。这是许多为React创建功能库中流行的一种模式，例如`react-router`。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before React introduced Hooks themselves, it was a popular pattern to create
    **Higher-Order Components** (**HOCs**) to reuse logic. HOCs are advanced features
    in React that focus on the reusability of components. The React documentation
    described them as follows: *"A higher-order component is a function that takes
    a component and returns a new component."*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在React引入Hooks之前，创建**高阶组件**（**HOCs**）以复用逻辑是一种流行的模式。HOCs是React的高级特性，专注于组件的可复用性。React文档这样描述它们：“一个高阶组件是一个函数，它接受一个组件并返回一个新的组件。”
- en: In the first part of this section, we'll create our first custom Hook, which
    uses logic to retrieve data from the data source that we created in the previous
    section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一个部分，我们将创建我们的第一个自定义Hook，它使用逻辑从我们在上一节创建的数据源中检索数据。
- en: Creating custom Hooks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义Hooks
- en: We already saw that we can reuse components in React, but the next step is to
    reuse logic that you have inside these components. To explain what this means
    in practice, let's create an example. Our project has a `Board` component, which
    fetches the REST API and renders all the lanes and tasks. There is logic in this
    component in the form of a local state created with the `useState` Hook, data
    fetching inside a `useEffect` Hook, and information about how each `Lane` component
    is being rendered. How will we handle a situation where we just want to show a
    board without lanes and only tasks? Do we just send different props from the `Board`
    component? Sure, that's possible, but, in React, that's what custom Hooks are
    used for.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们可以在 React 中重用组件，但下一步是重用这些组件内部的逻辑。为了解释这在实践中意味着什么，让我们创建一个示例。我们的项目有一个 `Board`
    组件，它获取 REST API 并渲染所有通道和任务。这个组件中有逻辑，以 `useState` Hook 创建的本地状态、`useEffect` Hook
    内部的数据获取和关于每个 `Lane` 组件如何渲染的信息的形式存在。如果我们只想显示没有通道且只有任务的板怎么办？我们只是从 `Board` 组件发送不同的属性吗？当然，这是可能的，但在
    React 中，这就是自定义 Hook 的用途。
- en: A `Board` component without lanes wouldn't map over all the lanes and render
    the corresponding lane with the tasks as a prop. Instead, it would map over all
    the tasks and render them directly. Although the rendered components are different,
    the logic to set the initial state, fetch the data, and render the component(s)
    can be reused. The custom Hook should be able to use the local state and execute
    data fetching from any component that it's used in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 没有通道的 `Board` 组件不会遍历所有通道并渲染带有任务的相应通道作为属性。相反，它会遍历所有任务并直接渲染它们。尽管渲染的组件不同，但设置初始状态、获取数据和渲染组件的逻辑可以重用。自定义
    Hook 应该能够使用本地状态并在任何使用它的组件中执行数据获取。
- en: 'To create the custom Hook, create a new file called `useDataFetching.js` inside
    a new directory called `hooks` in the `src` directory. Now, follow these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义 Hook，在 `src` 目录下创建一个名为 `hooks` 的新目录，并在其中创建一个名为 `useDataFetching.js` 的新文件。现在，按照以下步骤操作：
- en: 'Import the `useState` and `useEffect` Hooks from React and create a new function
    for the Hook, which becomes the default export. This function will take one parameter
    called `dataSource`. Since this Hook will use the life cycles for data fetching,
    let''s call this custom Hook `useDataFetching` and have it return an empty array:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 React 中导入 `useState` 和 `useEffect` Hook 并为 Hook 创建一个新的函数，该函数成为默认导出。这个函数将接受一个名为
    `dataSource` 的参数。由于这个 Hook 将使用数据获取的生命周期，让我们将这个自定义 Hook 命名为 `useDataFetching` 并使其返回一个空数组：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside this function, add the `useState` Hooks to create a local state for
    `loading`, `error`, and `data`, which has almost the same structure as our local
    state inside the `Board` component:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数内部，添加 `useState` Hook 来创建 `loading`、`error` 和 `data` 的本地状态，其结构与 `Board`
    组件内部的本地状态几乎相同：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we need to use the `useEffect` hook, which is where the data fetching
    will be done. The `dataSource` parameter is used as the location to fetch from.
    Also, notice that the constant names are now more generic and no longer specify
    a single use:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 `useEffect` Hook，这是数据获取将发生的地方。`dataSource` 参数用作获取的位置。注意，常量名称现在更加通用，不再指定单一用途：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This adds the method to do data fetching, and in the `return` statement, we're
    returning the `data`, `loading`, and `error` state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了进行数据获取的方法，并且在 `return` 语句中，我们返回 `data`、`loading` 和 `error` 状态。
- en: 'Congratulations! You''ve created your very first Hook! However, it still needs
    to be added to a component that supports data fetching. Therefore, we need to
    refactor our `Board` component to use this custom Hook for data fetching instead:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经创建了你的第一个 Hook！然而，它仍然需要添加到一个支持数据获取的组件中。因此，我们需要重构我们的 `Board` 组件以使用这个自定义
    Hook 进行数据获取：
- en: 'Import the custom Hook from the `src/hooks/useDataFetching.js` file and delete
    the imports of the React Hooks:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `src/hooks/useDataFetching.js` 文件中导入自定义 Hook 并删除 React Hook 的导入：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Subsequently, we can delete the usage of the `useState` and `useEffect` Hooks
    in the `Board` component:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，我们可以删除 `Board` 组件中 `useState` 和 `useEffect` Hook 的使用：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instead, use the imported custom Hook to handle our data fetching. The Hook
    returns the `loading`, `error`, and `tasks` state as before, but the data state
    is renamed `tasks` to fit the needs of our component:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，使用导入的自定义 Hook 来处理我们的数据获取。该 Hook 返回与之前相同的 `loading`、`error` 和 `tasks` 状态，但数据状态被重命名为
    `tasks` 以适应我们组件的需求：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the next section, we'll learn how to reuse a custom Hook by importing it
    from a different component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何通过从不同的组件导入来重复使用自定义钩子。
- en: Reusing a custom Hook
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复使用自定义钩子
- en: 'With the very first custom Hook in place, it''s time to think of other components
    that could do data fetching, such as a component that is displaying only tasks.
    The process to create this component consists of two steps: creating the actual
    component and using the custom Hook for data fetching. Let''s get started:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了第一个自定义钩子之后，是时候考虑其他可以进行数据获取的组件了，例如仅显示任务的组件。创建此组件的过程包括两个步骤：创建实际组件和使用自定义钩子进行数据获取。让我们开始吧：
- en: 'Inside the directory pages, we need to create a new file called `Backlog.js`
    in a new directory called `Backlog`. In this file, we can place the following
    code to create the component, import the custom Hook, and import the CSS for styling:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pages`目录中，我们需要在名为`Backlog`的新目录中创建一个名为`Backlog.js`的新文件。在此文件中，我们可以放置以下代码以创建组件，导入自定义钩子，并导入CSS进行样式设置：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `return` statement is now returning an empty `div` element, so we need
    to add the code to render the tasks here:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在的`return`语句正在返回一个空的`div`元素，因此我们需要在此处添加代码以渲染任务：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This component imports the `Backlog.css` file for styling, and we''ve also
    added classes to the elements in this file. But we also need to create and add
    some basic styling rules to `Backlog.css`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此组件导入`Backlog.css`文件进行样式设置，我们还在此文件中的元素上添加了类。但我们也需要在`Backlog.css`中创建并添加一些基本的样式规则：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `App` component, we can import this component to render it below the
    `Board` component:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件中，我们可以导入这个组件，在`Board`组件下方渲染它：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will render the new `Backlog` component below our board with all the different
    tasks. These tasks are the same ones as in the `Board` component, as the same
    REST API endpoint is used. Also, you can set up `react-router` for this project
    to render the `Backlog` component on a different page instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的板子下方渲染新的`Backlog`组件，其中包含所有不同的任务。这些任务与`Board`组件中的任务相同，因为我们使用了相同的REST API端点。此外，您还可以为这个项目设置`react-router`，以便在另一个页面上渲染`Backlog`组件。
- en: All the tasks that are displayed in the lanes are only in one part of our application,
    since we want to be able to drag and drop these tasks into different lanes. We'll
    learn how to do this in the next section, where we'll add dynamic functionalities
    to the board.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在车道上显示的所有任务仅在我们应用程序的一个部分，因为我们希望能够将这些任务拖放到不同的车道中。我们将在下一节中学习如何做到这一点，我们将为板子添加动态功能。
- en: Making the board dynamic
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使板子动态化
- en: One of the things that usually give project management boards great user interaction
    is the ability to drag and drop tasks from one lane into another. This is something
    that can easily be accomplished using the HTML5 Drag and Drop API, which is available
    in every modern browser, including IE11.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 项目管理板通常具有很好的用户交互能力之一是能够将任务从一个车道拖放到另一个车道。这是可以使用HTML5拖放API轻松实现的事情，该API在所有现代浏览器中都是可用的，包括IE11。
- en: The HTML5 Drag and Drop API makes it possible for us to drag and drop elements
    across our project management board. To make this possible, it uses drag events.
    `onDragStart`, `onDragOver`, and `onDrop` will be used for this application. These
    events should be placed on both the `Lane` and the `Task` components.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5拖放API使我们能够在项目管理板之间拖放元素。为了实现这一点，它使用拖放事件。`onDragStart`、`onDragOver`和`onDrop`将用于此应用程序。这些事件应该放置在`Lane`和`Task`组件上。
- en: 'In the file for the `Board` component, let''s add the functions that respond
    to the drop events, which need to be sent to the `Lane` and `Task` components.
    Let''s get started:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Board`组件的文件中，让我们添加响应拖放事件的函数，这些事件需要发送到`Lane`和`Task`组件。让我们开始吧：
- en: 'Start by adding the `event handler` function for the `onDragStart` event, which
    fires when the dragging operation is started, to the `Board` component. This function
    needs to be passed to the `Lane` component, where it can be passed on to the `Task`
    component. This function sets an ID for the task that is being dragged to the
    `dataTransfer` object of the element, which is used by the browser to identify
    the drag element:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先为`onDragStart`事件添加`事件处理函数`，该事件在拖动操作开始时触发，并将其添加到`Board`组件中。这个函数需要传递给`Lane`组件，然后可以传递给`Task`组件。此函数为正在拖动的任务设置一个ID，并将其放置在元素的`dataTransfer`对象中，浏览器使用该对象来识别拖放元素：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `Lane` component, we need to pass this `event handler` function to the
    `Task` component:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Lane`组件中，我们需要将这个`事件处理函数`传递给`Task`组件：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can invoke this function in the `Task` component, where we also need
    to add the draggable attribute to the `div` element with the class name `Task-wrapper`.
    Here, we send the element and the task ID as a parameter to the event handler:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `Task` 组件中调用此函数，在那里我们还需要将可拖动属性添加到具有 `Task-wrapper` 类名的 `div` 元素上。在这里，我们将元素和任务
    ID 作为参数传递给事件处理程序：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After making these changes, we should be able to see that each task can be
    dragged around. But don''t drop them anywhere yet – the other drop events and
    event handlers that update the state should be added as well. Dragging a task
    from one lane to another can be done by clicking on a task without releasing the
    mouse and dragging it to another lane, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，我们应该能够看到每个任务都可以被拖动。但不要将它们放在任何地方——还需要添加其他更新状态的拖放事件和事件处理程序。将任务从一个车道拖动到另一个车道可以通过单击任务而不释放鼠标并将其拖动到另一个车道来完成，如下面的截图所示：
- en: '![Figure 3.4 – The interactive project management board'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 交互式项目管理板'
- en: '](img/Figure_3.4_B17390.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4_B17390.jpg)'
- en: Figure 3.4 – The interactive project management board
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 交互式项目管理板
- en: 'With the `onDragStart` event implemented, the `onDragOver` and `onDrop` events
    can be implemented as well. Let''s get started:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了 `onDragStart` 事件后，可以实施 `onDragOver` 和 `onDrop` 事件。让我们开始吧：
- en: 'By default, it''s impossible to drop elements into another element – for example,
    a `Task` component into a `Lane` component. This can be prevented by calling the
    `preventDefault` method for the `onDragOver` event:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，无法将元素拖放到另一个元素中——例如，将 `Task` 组件拖放到 `Lane` 组件中。这可以通过调用 `onDragOver` 事件的
    `preventDefault` 方法来防止：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This function needs to be imported and placed as an event handler on the `div`
    element with the class name `Lane-wrapper` in the `Lane` component:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数需要被导入，并放置在 `Lane` 组件中具有 `Lane-wrapper` 类名的 `div` 元素上作为事件处理程序：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `onDrop` event is where things get interesting, since this event makes
    it possible for us to mutate the state after we''ve finished the drag operation.
    Before we can add this event handler, we need to create a new local state variable
    called `tasks` in the `Board` component. This state variable is overwritten when
    the data is being fetched from the `useDataFetching` Hook and is used to display
    the tasks from the `Lane` components:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onDrop` 事件是事情变得有趣的地方，因为这个事件使得我们在完成拖动操作后能够修改状态成为可能。在我们能够添加此事件处理程序之前，我们需要在 `Board`
    组件中创建一个新的局部状态变量 `tasks`。当从 `useDataFetching` 钩子获取数据时，此状态变量会被覆盖，并用于显示来自 `Lane`
    组件的任务：'
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The new event handler function can now be created, and when it''s invoked,
    we can call the `setTasks` function from the `useState` Hook for the tasks state:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以创建新的事件处理函数，当它被调用时，我们可以从 `useState` 钩子中的任务状态调用 `setTasks` 函数：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, this event handler function should be passed as a prop to the `Task`
    component:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，此事件处理函数应作为属性传递给 `Task` 组件：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This `onDrop` event handler function takes an element and the ID of the lane
    as a parameter because it needs the ID of the dragged element and the new lane
    it should be placed in. With this information, the function uses a `filter` function
    to find the task that needs to be moved and changes the ID of the lane. This new
    information will replace the current object for the task in the state with the
    `setState` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `onDrop` 事件处理函数接受一个元素和车道 ID 作为参数，因为它需要拖动元素的 ID 和它应该放置的新车道。有了这些信息，函数使用 `filter`
    函数找到需要移动的任务，并更改车道的 ID。这个新信息将用 `setState` 函数替换状态中当前的任务对象。
- en: 'Since the `onDrop` event gets fired from the `Lane` component, it is passed
    as a prop to this component. Also, the ID of the lane is added as a prop because
    this needs to be passed to the `onDrop` event handler function from the `Lane`
    component:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `onDrop` 事件是从 `Lane` 组件触发的，因此它作为属性传递给此组件。此外，还添加了车道 ID 作为属性，因为需要将其传递给来自 `Lane`
    组件的 `onDrop` 事件处理函数：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this, we're able to drag and drop tasks onto other lanes in our board –
    something that you can also do for the `Backlog` component – or even make this
    logic reusable with another custom Hook. But instead, we'll be looking at how
    to make the styling for our component more flexible and reusable by using the
    `styled-components` library in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们能够将任务拖放到我们板上的其他车道上——你也可以为 `Backlog` 组件做同样的事情——或者甚至通过另一个自定义钩子使此逻辑可重用。但相反，我们将探讨如何通过使用
    `styled-components` 库来使我们的组件样式更加灵活和可重用，在下一节中。
- en: Styling in React with styled-components
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 styled-components 在 React 中进行样式设计
- en: So far, we've been using CSS files to add styling to our React components. However,
    this forces us to import these files across different components, which makes
    our code less reusable. Therefore, we'll add the `styled-components` package to
    the project, which allows us to write CSS inside JavaScript (so-called CSS-in-JS)
    and create components.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 CSS 文件来为我们的 React 组件添加样式。然而，这迫使我们必须在不同的组件之间导入这些文件，这使得我们的代码的可重用性降低。因此，我们将向项目中添加
    `styled-components` 包，这允许我们在 JavaScript 中编写 CSS（所谓 CSS-in-JS）并创建组件。
- en: By doing this, we'll get more flexibility out of styling our components, be
    able to prevent the duplication or overlapping of styles due to `classNames`,
    and add dynamic styling to components with ease. All of this can be done using
    the same syntax we used for CSS, right inside our React components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将获得更多样式的灵活性，能够防止由于 `classNames` 而导致的样式重复或重叠，并且可以轻松地为组件添加动态样式。所有这些都可以使用我们用于
    CSS 的相同语法，直接在我们的 React 组件内部完成。
- en: 'The first step is installing `styled-components` using npm:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用 npm 安装 `styled-components`：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you look at the official documentation of `styled-components`, you will notice
    that they strongly advise you to use the Babel plugin for this package as well.
    But since you're using Create React App to initialize your project, you don't
    need to add this plugin, as all the compilation that your application needs has
    already been taken care of by `react-scripts`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 `styled-components` 的官方文档，您会注意到他们强烈建议您也使用此包的 Babel 插件。但是，由于您正在使用 Create
    React App 来初始化项目，因此您不需要添加此插件，因为 `react-scripts` 已经处理了您应用程序所需的全部编译。
- en: 'After installing `styled-components`, let''s try to delete the CSS file from
    one of our components. A good start will be the `Task` component since this is
    a very small component with limited functionality:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 `styled-components` 之后，让我们尝试从我们的组件中删除 CSS 文件。一个好的开始是 `Task` 组件，因为这个组件非常小，功能有限：
- en: 'Start by importing the `styled-components` package and creating a new styled
    component called `TaskWrapper`. This component extends a `div` element and takes
    the CSS rules we already have for the `Task-wrapper` class name in `Task.css`.
    Also, we no longer have to import this file, since all the styling is now being
    done inside this JavaScript file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入 `styled-components` 包并创建一个新的样式组件，命名为 `TaskWrapper`。该组件扩展了一个 `div` 元素，并采用了我们已经在
    `Task.css` 中的 `Task-wrapper` 类名所拥有的 CSS 规则。此外，我们不再需要导入此文件，因为所有的样式现在都在这个 JavaScript
    文件内部完成：
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code block, we''ve added the styling of the `h3` element in
    the styled component for `TaskWrapper`, but we can also do this inside a specific
    styled component as well:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们在 `TaskWrapper` 样式组件中添加了 `h3` 元素的样式，但我们也可以在特定的样式组件内部做同样的事情：
- en: '[PRE27]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also do this for the other components in our project, starting with
    the `Lane` component, for which we first need to create the styled components
    that use the same styling as those in the `Lane.css` file:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以为项目中的其他组件做同样的事情，从 `Lane` 组件开始，我们需要首先创建使用与 `Lane.css` 文件中相同的样式的样式组件：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Replace the existing `div` and `h3` elements with these new components:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `div` 和 `h3` 元素替换为这些新组件：
- en: '[PRE29]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we visit our project in the browser after running `npm start` again, we'll
    see that our application still looks the same after deleting the CSS files for
    the Ticket and `Lane` component. You can, of course, also do the same thing for
    the other components in the project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中再次运行 `npm start` 后访问我们的项目，我们会看到在删除了 Ticket 和 `Lane` 组件的 CSS 文件后，我们的应用程序仍然看起来一样。当然，您也可以为项目中的其他组件做同样的事情。
- en: 'Let''s proceed and convert another component to use `styled-components` instead
    of CSS – for example, the component in the `src/App.js` file. This one is using
    the `src/App.css` file to style the `div` element that wraps all the components
    in our application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将另一个组件转换为使用 `styled-components` 而不是 CSS，例如 `src/App.js` 文件中的组件。这个组件正在使用
    `src/App.css` 文件来为包含我们应用程序中所有组件的 `div` 元素添加样式：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After making these changes, you can delete the `src/App.css` file as we're no
    longer using it to style the `App` component.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，您可以删除 `src/App.css` 文件，因为我们不再使用它来为 `App` 组件添加样式。
- en: 'Another possibility with `styled-components` is creating a global style for
    our application, which is currently done in `src/index.css`. This file is imported
    in `src/index.js` and therefore loaded into every page of the application, as
    it is the entry to our React application. But the `App` component in `src/App.js`
    also wraps all our components, in which we can copy the styling rules from `src/index.css`
    and use them to create a `GlobalStyle` component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`styled-components`的另一种可能性是为我们的应用程序创建一个全局样式，这目前在`src/index.css`中完成。此文件在`src/index.js`中导入，因此被加载到应用程序的每一页，因为它是我们React应用程序的入口。但是`src/App.js`中的`App`组件也包装了所有我们的组件，我们可以在其中复制`src/index.css`中的样式规则，并使用它们来创建一个`GlobalStyle`组件：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This global style that we just created must be added to the return statement
    for the `App` component, above the `AppWrapper` component. As we can only return
    a single element or component from the `return` statement, we need to wrap the
    contents into another element. If we wanted to apply styling to this element,
    we could do this with a `div` element. As we don''t want that in this scenario,
    we''ll be using a React fragment instead. With a fragment, we can wrap elements
    and components without rendering anything in the browser:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的全局样式必须添加到`App`组件的返回语句中，在`AppWrapper`组件之上。因为我们只能从`return`语句返回一个元素或组件，所以我们需要将内容包装到另一个元素中。如果我们想给这个元素应用样式，我们可以使用一个`div`元素。但由于在这个场景中我们不希望这样做，我们将使用React片段。使用片段，我们可以包装元素和组件，而不会在浏览器中渲染任何内容：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `<>` notation is shorthand for `<React.Fragment>`; you can use both notations
    in React. For the `<React.Fragment>` notation, you can also import `Fragment`
    from React to write `<Fragment>`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`<>`符号是`<React.Fragment>`的简写；你可以在React中使用这两种符号。对于`<React.Fragment>`符号，你也可以从React中导入`Fragment`来编写`<Fragment>`。'
- en: 'Finally, you can delete the `src/index.css` file and the line in `src/index.js`
    that imports this file into our application:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以删除`src/index.css`文件和`src/index.js`中导入此文件的行：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With these final additions, we've styled large parts of our application with
    `styled-components` instead of CSS. By writing the styling rules directly in the
    components, we can reduce the number of files in the project and also make it
    easier to find what styling is applied to our elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些最终添加，我们已使用`styled-components`而不是CSS来设计了我们应用程序的大部分样式。通过直接在组件中编写样式规则，我们可以减少项目中的文件数量，并使查找应用于我们元素的风格变得更加容易。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you created a project management board that lets you move,
    drag, and drop tasks from one lane to another using the HTML5 Drag and Drop API.
    The data flow of this application is handled using local state and life cycles
    and determines which tasks are displayed in the different lanes. This chapter
    also introduced the advanced React pattern of custom Hooks. With custom Hooks,
    you can reuse state logic in function components across your applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你创建了一个项目管理板，允许你使用HTML5拖放API将任务从一个通道拖放到另一个通道。此应用程序的数据流由本地状态和生命周期处理，并确定哪些任务显示在不同的通道中。本章还介绍了React的高级模式自定义Hooks。使用自定义Hooks，你可以在你的应用程序中跨功能组件重用状态逻辑。
- en: This advanced pattern will be also be used in the next chapter, which will handle
    routing and **Server-Side Rendering** (**SSR**) in React applications using Next.js.
    Have you ever tried using Stack Overflow to find a solution to a programming issue
    you once had? I have! In the next chapter, we will be building a community feed
    that uses Stack Overflow as a data source and React to render the application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种高级模式也将在下一章中使用，下一章将处理React应用程序中使用Next.js的**服务器端渲染**（**SSR**）和路由。你有没有尝试过使用Stack
    Overflow来寻找你曾经遇到过的编程问题的解决方案？我有！在下一章中，我们将构建一个使用Stack Overflow作为数据源并使用React来渲染应用程序的社区动态。
- en: Further reading
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The HTML Drag and Drop API: [https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HTML拖放API: [https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API)'
- en: 'DataTransfer: [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DataTransfer: [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)'
- en: 'React DnD: [https://github.com/react-dnd/react-dnd](https://github.com/react-dnd/react-dnd)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'React DnD: [https://github.com/react-dnd/react-dnd](https://github.com/react-dnd/react-dnd)'
