# 2

# 服务器状态与客户端状态的比较

全局状态是我们看待状态最常见的方式。它是通过一个或多个组件在我们的应用程序中全局共享的状态。

我们通常不知道的是，在我们的日常开发中，我们的全局状态最终会在我们的应用程序外部持久化的状态和仅存在于我们应用程序内的状态之间分割。第一种类型的状态被称为**服务器状态**，而第二种类型的状态被称为**客户端状态**。这两种类型的状态都有它们特定的挑战，并需要不同的工具来帮助管理它们。

在本章中，我们将了解为什么我们主要将状态称为全局状态，以及为什么我们应该调整我们的思维模型以包括客户端和服务器状态。

我们还将回顾每种类型的状态负责什么，如何在应用程序中区分它们，以及理解导致 React Query 创建的挑战。

到本章结束时，你将能够通过应用你刚刚学到的思维模型，将全局状态完全分割成客户端状态和服务器状态。

你还将了解在应用程序中拥有服务器状态所创造的所有挑战，并准备好用 React Query 克服它们。

在本章中，我们将涵盖以下主题：

+   什么是全局状态？

+   什么是客户端状态？

+   什么是服务器状态？

+   理解与服务器状态相关的常见挑战

# 技术要求

本章的所有代码示例都可以在 GitHub 上找到，链接为[`github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_2`](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_2)。

# 什么是全局状态？

当我们在 React 世界中开始状态管理时，我们通常不熟悉不同的概念。

通常，我们只是通过思考我们在组件中拥有的`useState`或`useReducer`钩子的数量来查看状态。然后，当`useState`或`useReducer`模式停止工作，我们需要在更多组件之间共享状态时，我们要么将状态提升到最近的父组件，当这个状态只需要该组件的子组件时，要么找到一个共同的地方，这个状态可以存在，并且所有我们想要的组件都可以访问它。这种状态通常被称为全局状态。

让我们看看一个应用程序中全局状态可能是什么样子的例子。在这里，我们有一个负责管理主题选择、获取数据和跟踪此获取请求加载状态的商店：

```js
const theme = {
  DARK: "dark",
  LIGHT: "light",
};
export const GlobalStore = () => {
  const [selectedTheme, setSelectedTheme] = useState
    (theme.LIGHT);
  const [serverData, setServerData] = useState(null);
  const [isLoadingData, setIsLoadingData] = useState
    (false);
  const toggleTheme = () => {
    setSelectedTheme((currentTheme) =>
      currentTheme === theme.LIGHT ? theme.DARK :
        theme.LIGHT
    );
  };
  const fetchData = (name = "Daniel") => {
    setIsLoadingData(true);
    fetch(`<insert_url_here>/${name}`)
      .then((response) => response.json())
      .then((responseData) => {
        setServerData(responseData);
      })
 .finally(() => {
        setIsLoadingData(false);
      })
      .catch(() => setIsLoadingData(false));
  };
  useEffect(() => {
    fetchData();
  }, []);
  return {
    selectedTheme,
    toggleTheme,
    serverData,
    isLoadingData,
    fetchData
  };
};
```

这个片段展示了某些典型全局状态的一个示例。通过使用 React Context，我们创建了一个包含以下内容的商店：

+   一个名为`selectedTheme`的状态变量，用于管理所选主题

+   一个名为`serverData`的状态变量，用于显示从我们的 API 请求返回的数据

+   一个名为`isLoadingData`的状态变量，用于显示我们的 API 请求当前加载状态是否仍在加载。

+   一个名为`toggleTheme`的函数，允许我们在浅色和深色模式之间切换。

+   一个`fetchData`函数，允许我们获取给定数据并设置我们的加载状态为`true`或`false`，这取决于请求的状态。

+   一个`useEffect`钩子，它将触发初始数据获取以提供我们的`serverData`状态。

useEffect 是什么？

`useEffect`是一个 React 钩子，允许你在组件中执行副作用。

所有这些都是从我们的存储中返回的，以便上下文的消费者可以在整个应用程序中访问它们，只要他们订阅我们的上下文。

从第一眼看来，这个状态似乎没有问题，并且可能对大多数应用程序来说已经足够了。问题是，大多数时候，这个状态会因为新的开发需求而增长。这通常会导致我们的状态大小增加。

现在，让我们设想我们需要一个次要主题，并且需要添加另一个名为`secondaryTheme`的状态变量。我们的代码看起来会像这样：

```js
const [selectedTheme, setSelectedTheme] = useState(theme.LIGHT);
const [secondaryTheme, setSecondaryTheme] = useState(theme.LIGHT);
…
  const toggleSecondaryTheme = () => {
    setSecondaryTheme((currentTheme) =>
      currentTheme === theme.LIGHT ? theme.DARK :
        theme.LIGHT
    );
  };
  const toggleTheme = () => {
    setSelectedTheme((currentTheme) =>
      currentTheme === theme.LIGHT ? theme.DARK :
        theme.LIGHT
    );
  };
```

因此，在这个片段中，我们添加了我们的`secondaryTheme`状态变量，它的工作方式非常类似于`selectedTheme`。

现在，我们在这里使用上下文；这意味着每次我们触发状态更新时，任何消费这个状态的组件都将被迫重新渲染以接收新的状态更新。这对我们意味着什么？

让我们设想我们有两个组件（让我们称它们为*组件 A*和*组件 B*）正在消费这个上下文，但*组件 B*只解构`selectedTheme`状态，而*组件 A*解构一切。如果*组件 A*在`secondaryTheme`上触发状态更新，那么*组件 B*也将重新渲染，因为 React 注意到了它们共享的上下文中的更新。

这就是 React Context 的工作方式，我们无法改变这一点。我们可以争论，我们可以要么分割上下文，要么将订阅的组件分割成两个组件，并将第二个组件包裹在`memo`中，或者只是将我们的返回包裹在`useMemo`钩子中。当然，这可能会解决我们的问题，但我们只是在处理一种创建全局状态的状态类型的变化。

memo 和 useMemo 是什么？

`memo`是一个你可以将其包裹在组件中来定义其记忆化版本的函数。这将保证你的组件只有在它的属性发生变化时才会重新渲染。

`useMemo`是一个 React 钩子，允许你记忆化一个值。通常，我们想要记忆化的值是昂贵计算的结果。

现在，假设我们需要添加另一个 API 请求上下文。同样，上下文增长，我们最终会遇到与主题相同的问题。

如您现在可能已经理解的那样，状态组织有时可能是一个噩梦。我们可以求助于第三方库来帮助我们，但，再次强调，这仅仅是我们状态问题的一小部分。

到目前为止，我们只处理状态的组织，但现在想象一下，我们需要缓存我们从 API 请求中获得的数据。这可能会让我们陷入疯狂。

从我们刚刚注意到的问题中，我们可以看到，在我们的全局状态中，我们往往面临不同的挑战，一个解决方案可能对某件事有效，但对另一件事可能无效。这就是为什么分割我们的全局状态很重要。我们的全局状态通常是客户端状态和服务器状态的混合。在接下来的章节中，你将了解这些状态中的每一个是什么，我们将专注于服务器状态，最终理解为什么 React Query 如此受欢迎，并使我们的开发者生活变得更加容易。

# 客户端状态是什么？

我知道，到现在为止，你一定在想，这本书什么时候会开始介绍 React Query？我们几乎到了，我向你保证。我只是需要你完全理解为什么我如此热爱 React Query，而要做到这一点，了解它解决的主要问题非常重要。

现在，客户端状态不是它解决的问题之一，但你必须能够在作为开发者的日常工作中识别客户端状态，以便你完全理解应该由 React Query 管理什么，应该由其他状态管理工具管理什么。

客户端状态是应用程序拥有的状态。

这里有一些有助于定义你的客户端状态的东西：

+   这种状态是同步的，这意味着你可以无需等待时间，通过使用同步 API 来访问它。

+   它是局部的；因此，它只存在于你的应用程序中。

+   它是临时的，所以页面刷新时可能会丢失，并且在会话之间通常是非持久的。

带着这些知识，如果你回顾一下`GlobalStore`，你会把什么识别为属于客户端状态？

可能只有`selectedTheme`，对吧？

让我们应用从上一个要点中学到的知识：

+   我们需要等待获取它的值吗？*不*，这意味着它是同步的。

+   `selectedTheme`只存在于我们的应用程序中吗？*是的*。

+   它会在页面刷新时丢失吗？*是的*，如果我们不在本地存储中持久化它或检查浏览器首选项，那么它的值将在页面刷新之间丢失。

考虑到这一点，我们可以肯定地说`selectedTheme`属于我们的客户端状态。

为了管理这种类型的状态，我们可以使用从 React Context 到 Redux、Zustand 或 MobX 等第三方库的任何东西，当事情开始变得难以组织和维护时。

如果我们对`serverData`状态变量提出相同的问题，它会产生相同的效果吗？

+   数据只存在于我们的应用程序中吗？*不*，它存在于某个地方的数据库中。

+   它会在页面刷新时丢失吗？*不*，数据库仍然保留着数据，所以当我们重新加载时，它将再次被检索。

+   我们需要等待获取它吗？*是的*，我们需要触发一个获取此数据的请求。

这意味着我们的`serverData`状态变量不属于我们的客户端状态。这是我们将其归类为服务器状态的一部分。

现在，让我们谈谈让你来到这本书并使 React Query 变得必要的那个东西。

# 服务器状态是什么？

我们在应用程序中始终有服务器状态。主要问题是，我们试图将其与我们的客户端状态管理解决方案结合起来。试图将我们的服务器状态与我们的客户端状态管理解决方案结合的一个常见例子是使用**Redux Saga**或**Redux Thunk**。它们都使得进行数据获取和存储服务器状态变得更容易。主要问题开始于我们必须处理服务器状态带来的挑战，但让我们不要走得太远；你将在下一节中了解这些挑战。

现在，你可能想知道，服务器状态是什么？

好吧，正如其名所示，服务器状态是存储在您的服务器上的状态类型。以下是一些有助于识别您的服务器状态的事情：

+   这个状态是异步的，这意味着你需要使用异步 API 来获取和更新它。

+   它被远程持久化——大多数情况下是在数据库或您不拥有或控制的外部位置。

+   在你的应用程序中，这个状态不一定是最新的，因为大多数情况下，你拥有它的共享所有权，它可能被其他人改变，他们也在消费它。

带着这些知识，让我们回顾一下`GlobalStore`和我们的`serverData`状态变量，并应用这些规则来识别我们的服务器状态：

+   我们需要异步 API 来访问这个状态吗？我们需要！我们需要向服务器发送一个获取请求并等待它发送数据回来。

+   它是否被远程持久化？当然是的。就像我在上一个要点中说的那样，我们需要向我们的服务器请求它。

+   这个状态在我们应用程序中总是最新的吗？我们不知道。我们无法控制状态。这意味着如果任何消费相同 API 的人决定更新它，那么我们的`serverData`状态变量将立即过时。

现在，你可能正在回顾`GlobalStore`并思考以下问题：如果`selectedTheme`是客户端状态，而`data`是服务器状态，那么`isLoadingData`状态变量是什么呢？

好吧，这是一个派生状态变量。这意味着它的状态将始终取决于我们当前`serverData`获取请求的状态。如果我们获取数据，那么`isLoadingData`将是`true`；一旦我们完成数据获取，那么`isLoadingData`将回到`false`。

现在，想象一下，在你的应用程序中，每种服务器状态变量都需要一个这样的派生状态变量。我还要让你想象一个场景，在这个场景中，你需要处理获取请求失败时的错误。你可能为错误创建另一个状态变量，对吧？但你不最终会遇到和加载状态相同的问题吗？

之前提到的场景只是服务器状态带给你的应用程序挑战的冰山一角。想象一下，你的团队技术负责人有一天来到办公室告诉你，现在你需要开始缓存数据；哦，上帝，我们还没有考虑到的另一个挑战。正如你所见，服务器状态有许多挑战，在下一节中，我们将看到其中的一些。

# 理解服务器状态中的常见挑战

到现在为止，你可能已经意识到服务器状态带来了相当多的问题。这些挑战使得 React Query 在发布时更加突出，因为它以如此简单的方式解决了这些问题，以至于看起来太好了而不像是真的。

现在，这些挑战是什么，为什么它们大多数时候都如此复杂难以解决？

在本节中，我们将看到我们与服务器状态相关的所有常见挑战，并了解我们在 React Query 出现之前作为开发者必须自己解决的一些难题。

## 缓存

这可能是我们在服务器状态管理中面临的最具挑战性的问题之一。

为了提高页面性能并使你的网站更具响应性，你通常需要缓存你的数据。这意味着能够重用你之前获取的数据，以避免再次从服务器获取。

现在，你可能认为这听起来很简单，但考虑以下事项：

+   在保持应用程序响应的同时，你需要在后台更新你的缓存。

+   你需要能够评估你的缓存数据何时变得过时并需要更新。

+   一旦数据有一段时间未被访问，你必须回收这些数据。

+   在获取数据之前，你可能希望用一些模板数据初始化你的缓存。

如你所见，缓存带来了它应有的问题，想象一下你必须自己解决所有这些问题。

## 乐观更新

在执行变更时，你通常希望提升用户体验。变更是一个请求，它将创建或更新你的服务器状态。有时，你希望提升用户体验。我们都讨厌填写表格，然后看着加载指示器，同时我们的应用程序在后台执行变更、重新获取数据并更新用户界面。

为了提升用户体验，我们可以求助于乐观更新。

乐观更新是指在变更进行中时，我们更新我们的用户界面以显示变更完成后将如何显示，尽管那个变更尚未被确认完成。基本上，我们是乐观的，认为这些数据将改变，并在变更后成为我们期望的样子，这样我们就可以为用户节省一些时间，并给他们一个他们最终会看到的用户界面。

现在，想象一下实现这一点。在进行变更时，你需要以我们期望变更成功后的方式更新应用程序中的服务器状态。这将使 UI 对用户更加响应，他们可以更早地与之交互。变更成功后，你需要重新触发手动重新获取服务器状态，以便你实际上在应用程序中拥有更新的状态。现在，想象一个变更失败的场景。你需要手动将状态回滚到乐观更新之前的版本。

乐观更新为用户提供了一个惊人的用户体验，但管理所有成功和错误场景，以及保持服务器数据更新，可能是一件困难的事情。

## 去重请求

让我们描绘以下场景。

你在 UI 中有一个按钮，当用户点击时，会触发一个获取请求以部分更新你的服务器状态。在获取操作进行时，按钮被禁用。

这可能看起来没问题，一点也不麻烦，但想象一下，在你加载状态更新和你的按钮最终被禁用之前，用户可以点击按钮 10 次。你得到了什么？应用程序中针对相同数据的 10 次额外的意外请求。

这就是为什么去重请求很重要。当获取相同类型的数据时，如果我们触发了针对相同数据的多个请求，我们只想发送其中一个请求，并避免用不必要的请求污染用户的网络。

现在，想象一下你需要自己实现这一点。你需要了解应用程序中当前正在进行的所有请求。当其中一个请求与另一个请求完全匹配时，你需要取消第二个、第三个或第四个请求。

## 性能优化

有时，你可能需要在服务器状态中做一些额外的性能优化。以下是一些你可能需要用于特定服务器状态管理的优化模式。

+   **延迟加载**：你可能只想在满足特定条件时执行一次特定的数据获取请求。

+   **无限滚动**：当处理大量列表时，无限滚动是一种非常常见的模式，你只是逐渐将更多数据加载到你的服务器状态中。

+   **分页数据**：为了帮助结构化大型数据集，你可以选择分页你的数据。这意味着每当用户决定从第 1 页移动到第 2 页时，你需要获取该页面对应的数据。

正如你所见，我们需要解决几个挑战，才能在我们的应用程序中拥有我们认为是处理服务器状态的最佳体验。

问题在于，作为开发者，决定自己处理这些挑战可能需要相当长的时间，而我们最终创建的代码往往容易出错。大多数情况下，这些实现最终会影响我们代码的可读性，并显著增加理解我们项目所需的复杂性。

如果我告诉你，有一种东西可以在后台为你处理所有这些挑战，同时给你一个超级干净、简单的 API，这将使你的代码更易于阅读、理解，并让你感觉自己是一位真正的服务器状态大师，你会怎么想？

如果你正在阅读这本书，那么你可能已经知道了答案。是的，我正在谈论 React Query。

因此，打包好你的服务器状态知识，准备好你的项目，因为从下一章开始，我们将改变你处理服务器状态的方式。

# 摘要

在本章中，我们完全理解了全局状态的概念。到现在为止，你应该能够理解为什么我们的状态经常被称为全局状态，以及如果我们不将其拆分，维护它可能会变得多么困难。

你已经学会了如何将你的状态分为客户端和服务器端状态，并理解了每种类型的状态对于你的应用的重要性，以及如何在你的代码中识别它们。

最后，你已经熟悉了服务器状态可能给你的应用带来的挑战，并理解了如果你要自己解决所有这些问题，那么你的代码复杂性将会显著增加，你可能会失去一些非常需要的睡眠时间。

在*第三章*《React Query – 介绍、安装和配置》中，你将开始亲身体验 React Query。你将了解它是什么，以及它是如何帮助你摆脱服务器状态给应用带来的所有烦恼。你将学习如何为你的应用安装和配置它，以及如何添加专门的 React Query 开发者工具，使你的开发生活更加轻松。
