- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building a Local Weather App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建本地天气应用程序
- en: Now that we can build a small app, we can add a bit more complexity. In this
    case, we’ll take a look at including another browser API and combining it with
    an external data source for our app. We will build a small weather app that returns
    the current weather.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够构建一个小型应用程序，我们可以添加更多复杂性。在这种情况下，我们将探讨包括另一个浏览器API，并将其与外部数据源结合用于我们的应用程序。我们将构建一个小型天气应用程序，返回当前天气。
- en: We will start applying a different means of styling, using Tailwind as our CSS
    framework of choice, and in order to provide some additional robustness, we will
    also take a look at including some tests in our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始应用不同的样式方法，选择Tailwind作为我们的CSS框架，并且为了提供额外的稳健性，我们还将考虑在我们的应用程序中包含一些测试。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with external data coming from different types of APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与来自不同类型API的外部数据合作
- en: How to handle asynchronous data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理异步数据
- en: Applying Tailwind to quickly style any application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Tailwind应用于快速样式化任何应用程序
- en: Ensuring stability by adding unit tests for features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为功能添加单元测试来确保稳定性
- en: Let’s see what requirements we have to fulfil to get our application up and
    running.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要满足哪些要求才能使我们的应用程序运行起来。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we are going to use a third-party API to provide us with actual
    data. We need to register an account at [https://www.weatherapi.com/](https://www.weatherapi.com/)
    and retrieve the API keys for usage in our app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用第三方API为我们提供实际数据。我们需要在[https://www.weatherapi.com/](https://www.weatherapi.com/)注册一个账户，并检索用于我们应用程序的API密钥。
- en: We’ll add Tailwind CSS to apply styling to our app. The [https://tailwindcss.com/](https://tailwindcss.com/)
    website offers extensive documentation as well as an installation guide.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加Tailwind CSS来为我们的应用程序应用样式。[https://tailwindcss.com/](https://tailwindcss.com/)网站提供了广泛的文档以及安装指南。
- en: 'For our unit test, we’ll use the Vitest framework: [https://vitest.dev/](https://vitest.dev/).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的单元测试，我们将使用Vitest框架：[https://vitest.dev/](https://vitest.dev/)。
- en: 'You can find the source code here: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/03.weather](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/03.weather).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到源代码：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/03.weather](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/03.weather)。
- en: Initializing the app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化应用程序
- en: 'Let’s begin by starting with a slightly different configuration for the Vue.js
    CLI starter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为Vue.js CLI启动器设置一个稍微不同的配置开始：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Hit `y` to proceed, choose `vue-local-weather` as the project name, and select
    the options shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按`y`继续，选择`vue-local-weather`作为项目名称，并选择以下截图所示的选项：
- en: '![Figure 3.1 – The setup configuration for the local weather app](img/B19563_03_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 本地天气应用程序的设置配置](img/B19563_03_01.jpg)'
- en: Figure 3.1 – The setup configuration for the local weather app
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 本地天气应用程序的设置配置
- en: After following the instructions to install the dependencies and cleaning up
    the default files, we can get to work!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循安装依赖项和清理默认文件的说明后，我们可以开始工作！
- en: Working with different types of APIs
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与不同类型的API合作
- en: In order to retrieve local weather, we need a way to retrieve a location. The
    weather service we will be using accepts different sorts of location data, but
    we’ll go with latitude and longitude for this example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索本地天气，我们需要一种获取位置的方法。我们将使用的天气服务接受不同类型的位置数据，但在这个例子中我们将使用纬度和经度。
- en: It’s convenient that the browser’s geolocation API can provide us with just
    that! Let’s start by building a component that requests this information and displays
    it to the user interface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的地理位置API能够提供所需的信息真是太方便了！让我们先构建一个组件，请求这些信息并将其显示在用户界面上。
- en: 'Let’s create a file in the `components` folder, called `GetLocation.vue`. We’ll
    start in the `script` tag by importing the utilities from Vue.js and define the
    data that’s expected to be available:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`components`文件夹中创建一个名为`GetLocation.vue`的文件。我们将在`script`标签中导入Vue.js的实用工具，并定义预期可用的数据：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we’re saying that we will expect the reactive property `coords` to contain
    a latitude and longitude. Nothing fancy. Let’s write a function that retrieves
    the data from the geolocation API ([https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation)).
    Now, bear in mind that a user can deny access to this API, so we need a fallback
    as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们说我们期望响应式属性 `coords` 包含纬度和经度。没有什么特别的。让我们编写一个函数来从地理位置 API（[https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation)）获取数据。现在，请注意，用户可以拒绝访问此
    API，因此我们还需要一个后备方案。
- en: 'We’ll add a reactive Boolean property, `geolocationBlockedByUser`, to keep
    track of the success of calling the API and a function that does the actual calling:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个响应式布尔属性 `geolocationBlockedByUser` 来跟踪调用 API 的成功情况，以及一个执行实际调用的函数：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There’s a couple of things going on here. The `getGeolocation` function is being
    defined and, because it is dependent on user input, it is an asynchronous function
    by default. The promise it returns is empty because we use `successCallback` to
    update our reactive property.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个问题。`getGeolocation` 函数正在被定义，因为它依赖于用户输入，所以它默认是一个异步函数。它返回的承诺是空的，因为我们使用 `successCallback`
    来更新我们的响应式属性。
- en: That bit is empty right now, but we’ll add it in the next step. The `errorCallback`
    function only gets called if the geolocation cannot be retrieved, and for now,
    we’ll just assume that the user declined usage. So, we set the `geolocationBlockedByUser`
    value to true and log the error to the console.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这部分是空的，但我们在下一步中会添加它。`errorCallback` 函数仅在无法获取地理位置时被调用，目前我们假设用户拒绝了使用。因此，我们将
    `geolocationBlockedByUser` 的值设置为 true 并将错误记录到控制台。
- en: 'Looking at the documentation ([https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API/Using_the_Geolocation_API#getting_the_current_position](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API/Using_the_Geolocation_API#getting_the_current_position)),
    we see that `getCurrentPosition` returns an object (position) that holds latitude
    and longitude on a `coords` property. Since our `coords` reactive property expects
    a latitude and longitude, we process the data from the API as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文档（[https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API/Using_the_Geolocation_API#getting_the_current_position](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API/Using_the_Geolocation_API#getting_the_current_position)），我们看到
    `getCurrentPosition` 返回一个对象（位置），该对象在 `coords` 属性上持有纬度和经度。由于我们的 `coords` 响应式属性期望纬度和经度，我们按照以下方式处理来自
    API 的数据：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This all works now, but the function hasn’t been executed yet. Like in the
    previous chapter, we’ll use the `onMounted` hook to execute the function once
    the component gets mounted on the DOM. The entire `script` tag should now look
    like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前一切正常，但函数尚未执行。就像在上一章中一样，我们将使用 `onMounted` 钩子来在组件被挂载到 DOM 上时执行该函数。整个 `script`
    标签现在应该看起来像这样：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s quickly add a template block that renders the output like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速添加一个模板块，以渲染如下输出：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding the component to `App.vue` is a matter of importing the component and
    rendering it on the template:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件添加到 `App.vue` 中只需导入组件并在模板上渲染它：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Start our development server with `npm run dev`. Now, if you open the app in
    the browser, you should expect to see a browser popup asking for permission to
    share your location. If you grant access, you should see coordinates that your
    browser determined as your location (results may vary). If you have denied access,
    you should see the message stating that you did.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm run dev` 启动我们的开发服务器。现在，如果你在浏览器中打开应用，你应该会看到一个浏览器弹出窗口请求分享你的位置权限。如果你允许访问，你应该会看到浏览器确定的你的坐标（结果可能不同）。如果你拒绝了访问，你应该会看到一个消息说明你已拒绝。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you inspect the console closely, you may notice a warning: **Only request
    geolocation information in response to a user gesture**. It is typically considered
    an anti-pattern or rude to immediately attempt to gather geo information. Not
    all browsers will always show a confirmation dialog and that could lead to users
    disclosing information without them knowing!'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细检查控制台，可能会注意到一个警告：**仅对用户手势做出响应请求地理位置信息**。立即尝试收集地理位置信息通常被认为是一种反模式或是不礼貌的行为。并非所有浏览器都会始终显示确认对话框，这可能导致用户在不了解的情况下泄露信息！
- en: The correct approach would be to add a button to the template that executes
    the `getGeolocation` function using the `onClick` directive. That way, a user
    actively initiates the request for geolocation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的做法是在模板中添加一个按钮，使用 `onClick` 指令执行 `getGeolocation` 函数。这样，用户会主动发起地理位置请求。
- en: Handling data from a third-party API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理第三方 API 的数据
- en: Now that we have our coordinates, we can start to request localized weather
    data. For this example, we’ll make use of a public weather API ([https://www.weatherapi.com/](https://www.weatherapi.com/)).
    In order to make use of the service, we’ll need to request an API key. If you
    sign up for an account, the free tier will allow you to make 1,000,000 requests
    per month, which should be more than enough!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了坐标，我们可以开始请求本地化的天气数据。在这个例子中，我们将使用一个公共天气 API ([https://www.weatherapi.com/](https://www.weatherapi.com/))。为了使用这项服务，我们需要请求一个
    API 密钥。如果你注册一个账户，免费层每月允许你进行 1,000,000 次请求，这应该绰绰有余！
- en: It is common practice to store these sorts of access keys or secrets in a local
    environment variables file. This practice allows our build processes to detach
    local development operations from our production environments. It keeps those
    variables in one place, rather than being spread throughout your application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将这类访问密钥或秘密存储在本地环境变量文件中是一种常见做法。这种做法允许我们的构建过程将本地开发操作与我们的生产环境分离。它将这些变量集中在一个地方，而不是散布在你的应用程序中。
- en: 'For now, we’ll store the API key in a file at the root of your project called
    `.env`, with the following contents:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将在项目根目录下创建一个名为 `.env` 的文件来存储 API 密钥，内容如下：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `VITE_APP_` prefix makes sure that Vite automatically exposes the variable
    to the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`VITE_APP_` 前缀确保 Vite 自动将变量暴露给应用程序。'
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With a client-based web application, the key will be exposed by default, since
    it will be attached to API calls that you can inspect via your browser’s network
    requests. For our purposes, this is fine. In a production-like environment, you
    would likely proxy the request via your own backend to obfuscate any secrets from
    the public.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于客户端的 Web 应用程序，密钥默认会暴露，因为它将附加到你可以通过浏览器网络请求检查的 API 调用。对我们来说，这没问题。在一个类似生产的环境中，你可能会通过自己的后端代理请求来隐藏任何秘密。
- en: Constructing the API call
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造 API 调用
- en: Having our token on hand, we can start to make the call. Let’s discover how
    we need to construct the endpoint address to retrieve our relevant data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有我们的令牌后，我们可以开始进行调用。让我们了解我们需要如何构造端点地址来检索我们的相关数据。
- en: Using the API explorer ([https://www.weatherapi.com/api-explorer.aspx](https://www.weatherapi.com/api-explorer.aspx)),
    we see that we can fetch data from the service using a location. While the explorer
    shows a place name, if we dig into the request parameters ([https://www.weatherapi.com/docs/#intro-request](https://www.weatherapi.com/docs/#intro-request)),
    we see that the `q` parameter also accepts a latitude and longitude in decimal
    degrees, such as `q=48.8567,2.3508`. This is something we can use!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 API 探索器 ([https://www.weatherapi.com/api-explorer.aspx](https://www.weatherapi.com/api-explorer.aspx))，我们看到我们可以使用位置从服务中获取数据。虽然探索器显示了一个地点名称，但如果我们深入研究请求参数
    ([https://www.weatherapi.com/docs/#intro-request](https://www.weatherapi.com/docs/#intro-request))，我们会看到
    `q` 参数也接受十进制度数的纬度和经度，例如 `q=48.8567,2.3508`。这正是我们需要的东西！
- en: 'Looking at the docs, we need something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文档后，我们需要类似以下内容：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can manually call this by pasting this endpoint as a URL in the browser,
    replacing the variables with our actual data. You should see a formatted JSON
    object with weather data for your location! Now that we’re assured that everything
    works, we can move the logic to a Vue component to include it in our app.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将此端点作为 URL 粘贴到浏览器中手动调用它，用我们的实际数据替换变量。你应该会看到一个格式化的 JSON 对象，包含你位置的天气数据！现在我们确认一切正常工作后，我们可以将逻辑移动到
    Vue 组件中，以便将其包含在我们的应用程序中。
- en: 'Let’s create a component called `WeatherReport.vue` in the `component` folder.
    We’ll start with the `script` block, and start by describing two types that we
    will be working with and defining the props that this component needs (`coords`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `component` 文件夹中创建一个名为 `WeatherReport.vue` 的组件。我们将从 `script` 块开始，首先描述我们将要使用两种类型，并定义这个组件需要的属性（`coords`）：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the `WeatherData` type, I’ve taken a look at what the API returns to us,
    only describing the properties that we’re interested in. Feel free to pick metric
    or imperial units when implementing! The `Coords` type is as simple as holding
    numerical values for latitude and longitude and we can reuse that type within
    our `script` block, for instance, to describe the `coords` component property.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `WeatherData` 类型，我查看了一下API返回给我们的内容，只描述了我们感兴趣的属性。在实现时，请随意选择公制或英制单位！`Coords`
    类型非常简单，只需持有纬度和经度的数值，我们可以在 `script` 块内部重用该类型，例如，用来描述 `coords` 组件属性。
- en: 'If we want to use the response from the endpoint, we need to make it reactive.
    We can do this using `ref` and we’ll map it to a data constant:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用端点的响应，我们需要使其变得响应式。我们可以使用 `ref` 来做这件事，并将其映射到一个数据常量：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this in place, we’re ready to define the caller function, using the fetch
    API. In the function, we’ll take in a parameter representing the coordinates for
    our request. We’ll return the data so we can later map it to the `data` property
    we’ve just created:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们准备好定义调用函数，使用fetch API。在函数中，我们将接受一个参数，代表我们请求的坐标。我们将返回数据，以便我们稍后将其映射到我们刚刚创建的
    `data` 属性：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we’re describing a `fetchWeather` function that returns a promise
    in the shape of the `WeatherData` type. We use the `coords` parameter to construct
    the URL, combining it with the secret key. On fulfilling the request with a response,
    we transform it to JSON and return the value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们描述了一个返回 `WeatherData` 类型形状的promise的 `fetchWeather` 函数。我们使用 `coords` 参数来构造URL，将其与密钥结合。在请求得到响应后，我们将其转换为JSON并返回值。
- en: Similar to our `GetLocation` component, we want to fetch the data immediately,
    so we’ve used the `onMount` hook in a similar fashion. We’ve passed the component
    props to the `fetchWeather` function and mapped the response to the reactive data
    variable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的 `GetLocation` 组件类似，我们希望立即获取数据，所以我们以类似的方式使用了 `onMount` 钩子。我们将组件属性传递给 `fetchWeather`
    函数，并将响应映射到响应式数据变量。
- en: Now that we have our data, we can mark up the template to show the information!
    We’re dealing with asynchronous data, so we have a UI state where data is still
    loading.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，我们可以标记模板来显示信息！我们处理的是异步数据，因此有一个数据仍在加载的UI状态。
- en: 'Let’s start with adding the two states to the `WeatherReport.vue` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `WeatherReport.vue` 文件中添加两个状态开始：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Provided you have a quick response from the server, the data should show up
    almost instantly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从服务器得到快速响应，数据应该几乎瞬间显示出来。
- en: Now let’s take a look at how we can build our interface with style!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何以风格构建我们的界面！
- en: Styling with Tailwind
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tailwind进行样式设计
- en: '**Tailwind CSS** is a popular utility-based CSS framework that we can use to
    build and style user interfaces by using and combining predefined classes. Tailwind
    is very scalable due to abstracting the writing of CSS rules, which provides consistency
    and maintainability where it’s used. Let’s take a look at how we can apply Tailwind
    CSS to our little application.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tailwind CSS** 是一个流行的基于实用工具的CSS框架，我们可以通过使用和组合预定义的类来构建和样式化用户界面。由于抽象了CSS规则的编写，Tailwind非常可扩展，这提供了在使用时的一致性和可维护性。让我们看看我们如何将Tailwind
    CSS应用到我们的小型应用中。'
- en: 'The installation guide ([https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite))
    covers all of the steps we need to execute:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装指南 ([https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite))
    覆盖了我们需要执行的步骤：
- en: 'First, we will have to add the dependencies to the project:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须向项目中添加依赖项：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’re installing Tailwind, but also the tooling to allow Vite to process the
    stylesheet using PostCSS. PostCSS is a powerful JS tool for transforming CSS using
    JavaScript ([https://postcss.org/](https://postcss.org/)).
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在安装Tailwind，同时也安装了允许Vite使用PostCSS处理样式的工具。PostCSS是一个强大的JavaScript工具，用于使用JavaScript转换CSS
    ([https://postcss.org/](https://postcss.org/))。
- en: 'Next, we’ll initialize the default configuration for Tailwind:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将初始化Tailwind的默认配置：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a `style.css` file in the `./src` folder and add the following lines
    to import Tailwind CSS utility classes in your development and build steps:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `./src` 文件夹中创建一个 `style.css` 文件，并在你的开发和构建步骤中添加以下行以导入Tailwind CSS实用工具类：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And finally, open the `./src/main.ts` file to import the CSS file into the
    app:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `./src/main.ts` 文件，将CSS文件导入到应用中：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Bear in mind that an imported CSS file differs from how you would traditionally
    link a CSS stylesheet to an HTML file. By importing it, the CSS file will be part
    of the development and build pipelines, which allows us to perform advanced operations
    on the styles before they are output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，导入的CSS文件与您传统上将CSS样式表链接到HTML文件的方式不同。通过导入它，CSS文件将成为开发和构建管道的一部分，这允许我们在样式输出之前对样式执行高级操作。
- en: In our case, we’re importing references to Tailwind CSS, adding browser-specific
    prefixes, and removing unused classes from the stylesheet. Having this amount
    of control and power is very convenient for building advanced apps!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们正在导入Tailwind CSS的引用，添加浏览器特定的前缀，并从样式表中删除未使用的类。拥有如此多的控制和力量对于构建高级应用程序来说非常方便！
- en: With our setup in place, we can start to apply Tailwind CSS to our application.
    Tailwind uses utility classes to define the styling of an element.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设置就绪后，我们可以开始将Tailwind CSS应用到我们的应用程序中。Tailwind使用实用类来定义元素的样式。
- en: Utility classes
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用类
- en: The approach of utility-class-based CSS frameworks is built around the notion
    of having CSS tightly coupled with a user interface while abstracting underlying
    rules and definitions. Instead of adding a class name to an element and then applying
    CSS styles within that class, you now add multiple class names to an element that
    describe the CSS behavior.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 基于实用类CSS框架的方法是围绕将CSS紧密耦合到用户界面，同时抽象底层规则和定义的概念构建的。您现在不是向元素添加一个类名并在该类中应用CSS样式，而是向元素添加多个类名来描述CSS行为。
- en: Having a tightly coupled relationship between an element and how it’s styled
    has the benefit of it being very maintainable, with few hidden rules or side effects
    that affect how an element will be rendered. The base CSS file remains the same
    size; it’s just the list of all utility classes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 元素与其样式之间的紧密耦合关系的好处是它非常易于维护，几乎没有隐藏的规则或副作用影响元素的渲染方式。基础CSS文件的大小保持不变；它只是所有实用类的列表。
- en: We can even remove unused styles since we know what classes we’re using in the
    markup. This has a higher level of predictability than more traditional CSS, where
    the relation between a style definition and the element that depended on the style
    is a lot less clear. Especially for rapid prototyping, the utility-based approach
    really shines, so let’s put it into practice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以移除未使用的样式，因为我们知道在标记中使用哪些类。这比更传统的CSS具有更高的可预测性，在传统CSS中，样式定义与依赖于该样式的元素之间的关系远没有那么清晰。特别是对于快速原型设计，基于实用性的方法确实非常出色，所以让我们将其付诸实践。
- en: 'Let’s make a small change to the `index.html` file to see Tailwind CSS in action.
    We’re going to add a list of classes to the `<div/>` element where our app is
    mounted:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`index.html`文件进行一些小的修改，以看到Tailwind CSS的实际应用。我们将向我们的应用程序挂载的`<div/>`元素添加一个类列表：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One of the strengths of Tailwind CSS is its readability. From the markup, we
    can visualize how the component will render in the browser. In this case, a multi-colored
    gradient as a background and the content at the horizontal and vertical center
    of the page. To learn more about the available Tailwind utility classes, the official
    docs provide a comprehensive list of all available classes: [https://tailwindcss.com/docs](https://tailwindcss.com/docs).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS的一个优点是其可读性。从标记中，我们可以可视化组件在浏览器中的渲染方式。在这种情况下，背景是一个多色渐变，内容位于页面的水平和垂直中心。要了解更多关于可用的Tailwind实用类，官方文档提供了一个所有可用类的综合列表：[https://tailwindcss.com/docs](https://tailwindcss.com/docs)。
- en: 'The file looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文件看起来是这样的：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we look at the application in the browser now, we can see the result of this
    change. Combining more of the utility classes, we’ll stylize the data we get from
    the weather API.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在浏览器中查看应用程序，我们可以看到这个更改的结果。结合更多的实用类，我们将对从天气API获取的数据进行样式化。
- en: 'Let’s go over to `WeatherReport.vue` and add some styling and HTML elements:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到`WeatherReport.vue`并添加一些样式和HTML元素：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is already looking good! See how we’re combining Tailwind classes to determine
    how an element should be styled? You can experiment with all sorts of different
    ways of presenting the data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来已经很不错了！看看我们是如何结合Tailwind类来确定元素的样式？你可以尝试各种不同的方式来展示数据。
- en: We have a couple of predefined properties not yet mapped to the template. Let’s
    take a look at them because they require some extra attention.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些预定义的属性尚未映射到模板中。让我们看看它们，因为它们需要一些额外的关注。
- en: Formatting data
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据格式化
- en: 'Let’s take a look at the timestamp from the service. We’re receiving it as
    a `datetime` string. We can format it to show up as a bit more readable information.
    We can just use a formatting function to format any date string into something
    we like. We’ll create the function in the `<script>` block of the component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看来自服务的时间戳。我们以 `datetime` 字符串的形式接收它。我们可以将其格式化以显示更易读的信息。我们可以简单地使用一个格式化函数将任何日期字符串格式化为我们喜欢的格式。我们将在组件的
    `<script>` 块中创建这个函数：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We’re using the browser’s built-in `Intl` namespace ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl))
    to interpret date information and returning it to the user based on the browser’s
    settings. Now we can simply call the method from the template:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用浏览器的内置 `Intl` 命名空间（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)）来解释日期信息，并根据浏览器的设置将其返回给用户。现在我们可以在模板中简单地调用该方法：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Vue.js interprets the information between the brackets as an expression, so
    it will just evaluate the output of the `formatDate` method as the rendered information.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 将括号之间的信息解释为表达式，所以它将只评估 `formatDate` 方法的输出作为渲染信息。
- en: Custom style use cases
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义样式用例
- en: 'Now we’re left with information regarding wind: speed and direction. Representing
    the wind speed is straightforward: either pick the metric value or the imperial
    value and render it in the template. Representing the wind direction, we can make
    it a bit more user-friendly by indicating direction using an arrow that points
    in a certain direction.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们剩下关于风的信息：速度和方向。表示风速是直接的：要么选择公制值，要么选择英制值，并在模板中渲染它。表示风向，我们可以通过使用指向特定方向的箭头来使其更易于用户理解。
- en: 'For such a specialized operation, it is best to create a new component. Let’s
    create one called `WindDirection.vue` for the moment. It will receive a numerical
    property called `degrees`. We will use the property to create a dynamic (computed)
    style, depending on the input:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一项专业操作，最好是创建一个新的组件。我们先创建一个名为 `WindDirection.vue` 的组件。它将接收一个名为 `degrees`
    的数值属性。我们将使用这个属性来创建一个动态（计算）样式，根据输入来决定：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the file, there are two interesting things going on. For starters, the `degrees`
    property gets used to create a computed value called `windStyle`. That value holds
    a dynamic CSS property and thus will be responsive to any prop it will get. We
    apply the style by binding it to the `:style` property of the `<span>` element,
    which simply holds an arrow.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，有两件有趣的事情在进行。首先，`degrees` 属性被用来创建一个名为 `windStyle` 的计算值。这个值包含一个动态的 CSS 属性，因此将对其接收到的任何属性做出响应。我们通过将其绑定到
    `<span>` 元素的 `:style` 属性来应用样式，该属性简单地包含一个箭头。
- en: The second thing to point out is the `<span>` element with the `sr-only` class.
    This is a technique to make the content more accessible and it is something you
    should always consider. The arrow and its rotation only make sense when you can
    see the component being rendered. Not everybody can rely on sight when using the
    web. Some people use tools such as screen readers to process information on a
    given page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点要指出的是具有 `sr-only` 类的 `<span>` 元素。这是一种使内容更易于访问的技术，这是你应该始终考虑的事情。箭头及其旋转只有在你可以看到渲染的组件时才有意义。并不是每个人在使用网络时都能依赖视觉。有些人使用屏幕阅读器等工具来处理给定页面上的信息。
- en: Tailwind offers a special class utility to mark content for screen readers only,
    which means its contents are hidden by default browser behavior. A screen reader
    will likely read out the contents of the element. In this case, we’re describing
    the meaning of the arrow with its rotation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind 提供了一个特殊的类工具，用于标记仅对屏幕阅读器可见的内容，这意味着其内容默认情况下会被浏览器行为隐藏。屏幕阅读器可能会读取该元素的内容。在这种情况下，我们通过其旋转描述箭头的含义。
- en: Please be mindful of providing tools to make any website or application accessible
    for all by default.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意提供工具，使任何网站或应用默认对所有用户都易于访问。
- en: 'Let’s now add this component to our application to wrap it all up:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把这个组件添加到我们的应用中，以完成整个应用：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That’s it! That’s our weather app! You can style it any way you want. If you
    want to add or remove properties, please finish the last part first, because it
    will help you maintain stability throughout your changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这就是我们的天气应用！你可以按任何你想要的方式对其进行样式设计。如果你想添加或删除属性，请先完成最后一部分，因为它将帮助你保持更改过程中的稳定性。
- en: In our next section, we’ll add unit tests for specific features of the app.
    Unit tests take in small bits (units) of the code and validate that these parts
    have the same output when given certain conditions. Let’s see how that works.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为应用程序的特定功能添加单元测试。单元测试接受代码的小部分（单元），并验证在给定某些条件下这些部分具有相同的输出。让我们看看它是如何工作的。
- en: Ensuring stability with Vitest
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vitest确保稳定性
- en: Now that we have a working app, adding or removing a property can be done with
    ease. Just update the file and you’re ready. This is, however, not always a desirable
    situation. Having the ability to remove properties that easily could result in
    unwanted bugs in your application!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的应用程序，添加或删除属性可以轻松完成。只需更新文件即可。然而，这并不总是理想的情况。能够轻松删除属性可能会导致应用程序中出现不希望的bug！
- en: We can add more control to our code by describing its behavior using tests.
    In this part, we’ll take a look at adding unit tests with Vitest and Vue Test
    Utils, to demonstrate where unit tests can help you (and where they cannot).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用测试来描述代码的行为，从而增加对代码的控制。在本部分中，我们将查看如何使用Vitest和Vue Test Utils添加单元测试，以展示单元测试如何帮助你（以及它们不能帮助你之处）。
- en: Vue Test Utils
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue Test Utils
- en: The official testing library for Vue.js projects is **Vue Test Utils** ([https://test-utils.vuejs.org/](https://test-utils.vuejs.org/)).
    A testing framework is a series of tools and functions that you can use to create
    isolated instances of a component and manipulate it to assert certain behaviors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js项目的官方测试库是**Vue Test Utils**([https://test-utils.vuejs.org/](https://test-utils.vuejs.org/))。测试框架是一系列工具和函数，你可以使用它们来创建组件的独立实例，并操纵它以断言某些行为。
- en: The purpose of unit testing is to validate that each unit (or component) of
    the software is working as expected and meets the specified requirements. In our
    case, we could write tests for our Vue components, but also for JavaScript files
    that just export functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的目的是验证软件的每个单元（或组件）是否按预期工作并满足指定的要求。在我们的情况下，我们可以为我们的Vue组件编写测试，也可以为仅导出函数的JavaScript文件编写测试。
- en: With our selected preset, we’ve already included the test tooling in our app.
    It even added a test script as part of the `package.json` file to run our tests
    with, so we can get started with writing some tests. There are several ways of
    organizing and structuring code. I prefer to have tests next to the component
    that they are testing. Test files are identified by a `.spec.ts` suffix in the
    filename, so you can always spot them with ease.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们选择的预设，我们已经将测试工具包含在我们的应用程序中。它甚至将测试脚本作为`package.json`文件的一部分添加，以便我们可以运行测试。有几种组织和结构化代码的方式。我更喜欢将测试放在它们所测试的组件旁边。测试文件通过文件名中的`.spec.ts`后缀来识别，因此你可以轻松地找到它们。
- en: 'There are a couple of things to consider when it comes to writing good unit
    tests:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编写好的单元测试时，有几个方面需要考虑：
- en: You should be able to test each functionality in isolation
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该能够独立测试每个功能
- en: Each unit test should be independent of all other tests, and not rely on the
    state of other tests or functions
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元测试都应该独立于所有其他测试，并且不依赖于其他测试或函数的状态
- en: Tests support your documentation, so use logical and descriptive names to help
    understand what a test covers
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试支持你的文档，因此请使用逻辑和描述性的名称来帮助理解测试覆盖的内容
- en: We’ll discover what I mean while we are writing different sets of tests or both
    Vue components as plain JavaScript files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写不同的测试集或将Vue组件作为纯JavaScript文件时，我们将发现我的意思。
- en: 'Let’s start with something simple. Our entry point of the application is the
    `./src/app.vue` component. Let’s quickly open the file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的事情开始。应用程序的入口点是`./src/app.vue`组件。让我们快速打开文件：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, in terms of functionality, little can go wrong. It imports the `GetLocation`
    component and mounts it to the template. If we consider this from a documentation
    point of view, you could describe the functionality of the component as *it should
    render the GetLocation component*. We can assert this, and this is exactly how
    we will write our first test.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从功能的角度来看，很少会出现错误。它导入了`GetLocation`组件并将其挂载到模板上。如果我们从文档的角度来考虑，你可以将组件的功能描述为*它应该渲染GetLocation组件*。我们可以断言这一点，这正是我们将要编写的第一个测试的方式。
- en: 'Create a file called `App.spec.ts` with the following content:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`App.spec.ts`的文件，内容如下：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we import some tools to write our tests and assertions from
    Vitest. We also import a method to mount a component in our test and import the
    `GetLocation` and `App` components. You can execute the unit tests with this command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们导入了一些来自 Vitest 的工具来编写我们的测试和断言，还导入了一个用于在测试中挂载组件的方法，以及导入 `GetLocation`
    和 `App` 组件。你可以使用以下命令执行单元测试：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command will execute all of the recognized test files and keep a watcher
    running to rerun any changed tests. The script automatically generates a report
    of the tests in the console.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将执行所有已识别的测试文件，并保持一个监视器运行以重新运行任何更改的测试。脚本会自动在控制台生成测试报告。
- en: A (shallow) mounted component will behave just as it would when being rendered
    by a browser, but we run this in isolation. With Vue Test Utils, you can either
    `mount` or `shallowMount` a component, with the difference being that a mount
    also attempts to render any children. A `shallowMount` function creates stubs
    for any children, which reduces side effects and focuses directly on the component
    itself. As a rule of thumb, I tend to always use `shallowMount` unless I need
    to assert specific parent-child behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: （浅度）挂载的组件将表现得就像它被浏览器渲染时一样，但我们是在隔离状态下运行的。使用 Vue Test Utils，你可以选择 `mount` 或 `shallowMount`
    一个组件，区别在于挂载会尝试渲染任何子组件。`shallowMount` 函数为任何子组件创建存根，这减少了副作用并直接关注组件本身。作为一个经验法则，我倾向于总是使用
    `shallowMount`，除非我需要断言特定的父子行为。
- en: We scope the test with a `describe` block and make sure that we describe what
    the subject of our test is.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `describe` 块来限定测试范围，并确保我们描述了测试的主题。
- en: 'Then we write our test: *it renders the GetLocation component*. This simply
    mounts the `App` component and then asserts whether the stub of the `GetLocation`
    component was found in the render tree.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们编写我们的测试：*它渲染了 GetLocation 组件*。这仅仅是挂载了 `App` 组件，然后断言 `GetLocation` 组件的存根是否在渲染树中被找到。
- en: Global test functions
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局测试函数
- en: We will use three functions in all our tests to create our test assertions.
    These functions are used to create clear and organized testing code, with the
    `describe` function used to group tests into logical test suites, the `it` function
    used to define individual test cases, and the `expect` function used to define
    the expected behavior of the code being tested.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有测试中，我们将使用三个函数来创建我们的测试断言。这些函数用于创建清晰和有组织的测试代码，其中 `describe` 函数用于将测试分组到逻辑测试套件中，`it`
    函数用于定义单个测试用例，而 `expect` 函数用于定义正在测试的代码的预期行为。
- en: We can make a small modification in our project files that removes the need
    for manually importing those much used functions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在项目文件中进行一些小的修改，以消除手动导入这些常用函数的需求。
- en: 'Open the `vite.config.ts` file and look for the `test` property. If we add
    a new property called `globals` with the value `true` as a child of the `test`
    property, you should end up with something similar to this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `vite.config.ts` 文件并查找 `test` 属性。如果我们向 `test` 属性添加一个名为 `globals` 的属性，其值为
    `true`，那么最终的结果应该类似于以下内容：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can use the functions, but our IDE is not aware of those functions,
    so we need to configure some additional settings. First, we need to install some
    types by running the following command in the CLI:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些函数，但我们的 IDE 并不知道这些函数，因此我们需要配置一些额外的设置。首先，我们需要通过在 CLI 中运行以下命令来安装一些类型：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We’ll update the `tsconfig.vitest.json` file with the following addition to
    `types`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下添加到 `types` 的内容来更新 `tsconfig.vitest.json` 文件：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now our IDE is perfectly okay with directly using the `describe`, `it`, and
    `expect` functions. And that’s all you need to do in order to register them as
    globally available functions. You can remove that line from our first test file
    if you like.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 IDE 完美地支持直接使用 `describe`、`it` 和 `expect` 函数。这就是你需要做的全部，以便将它们注册为全局可用函数。如果你喜欢，你可以从我们的第一个测试文件中删除那行代码。
- en: A simple component test
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的组件测试
- en: Let’s work our way on to more complex components now. Let’s start with the `WindDirection`
    component. We can assert a couple of things here that the component renders, but
    also that it adds the correct style to the direction indicator and that the screen
    reader text reflects the same value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始处理更复杂的组件。让我们从 `WindDirection` 组件开始。我们可以断言组件渲染的内容，以及它是否添加了正确的样式到方向指示器，以及屏幕阅读器文本是否反映了相同的值。
- en: 'First, we’ll create the `WindDirection.spec.ts` file, with the following contents:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 `WindDirection.spec.ts` 文件，内容如下：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This only asserts that the component should not error when provided with the
    minimum requirement of properties. `toBeTruthy` is a loose assertion that asserts
    if the value is any expression or value that evaluates to true.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这只断言组件在提供最小属性要求时不应出错。`toBeTruthy` 是一个宽松的断言，它断言值是任何表达式或值，该表达式或值评估为真。
- en: 'When we take into consideration that we want to isolate tests as much as possible,
    we can add a test for rendering the wind direction arrow with the appropriate
    style. For that, we want to retrieve an element – the `span` element the computed
    style is applied to. It is common practice in these cases to add a specific attribute
    called `data-testid` to the element. Modify the `span` element to add the `data-testid`
    attribute:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑到我们尽可能想要隔离测试时，我们可以添加一个测试来渲染带有适当样式的风向箭头。为此，我们需要检索一个元素——应用计算样式的 `span` 元素。在这些情况下，给元素添加一个特定的属性，称为
    `data-testid` 是常见的做法。修改 `span` 元素以添加 `data-testid` 属性：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we have something to have our tests point at. The benefit of adding a specific
    attribute for testing over targeting by class name or hierarchical structure is
    that this is far less likely to be subject to changes over time, which makes your
    tests more robust:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些测试可以指向的东西。添加特定属性进行测试而不是通过类名或层次结构进行定位的好处是，这不太可能随着时间的推移而发生变化，这使得你的测试更加健壮：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we localized the element using the `[data-testid=direction]`
    query and then asserted its style. By mapping it to the contents (a downward-pointing
    arrow), the combination of rotation with the arrow provides meaningful context.
    If we were to replace the downward-facing arrow with any other content, the component
    would lose its meaning and the test would rightfully fail.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用 `[data-testid=direction]` 查询来本地化元素，然后断言其样式。通过将其映射到内容（一个向下指的箭头），旋转与箭头的组合提供了有意义的上下文。如果我们用任何其他内容替换向下指向的箭头，组件就会失去其意义，测试也会相应地失败。
- en: 'We can add the final assertion, aimed at screen reader usage. First, we’ll
    add another `data-testid` attribute to the component. In this case, to the screen-reader-related
    element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个针对屏幕阅读器使用的最终断言。首先，我们将给组件添加另一个 `data-testid` 属性。在这种情况下，添加到与屏幕阅读器相关的元素：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This value has to be unique in order for us to target it from the test file,
    which now looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值必须唯一，这样我们才能从测试文件中定位它，现在的测试文件如下所示：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In terms of isolation, we are executing this test on a new instance of the mounted
    component, and we are only looking at the contents of the `direction-sr` attributed
    component. We do this because, if a test fails, we should be able to immediately
    see what the cause and effect is.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在隔离方面，我们在这个挂载组件的新实例上执行这个测试，并且我们只关注 `direction-sr` 属性组件的内容。我们这样做是因为，如果测试失败，我们应该能够立即看到原因和影响。
- en: We could add the `expect` lines to the previous test block, but if any assertion
    failed, we would not be able to see the direct cause. In small code bases, it
    wouldn’t be a big concern, but you can imagine the complexity when you’re dealing
    with a code base made up of hundreds of components with their unit tests. That
    is why isolation and simplicity are key.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `expect` 行添加到之前的测试块中，但如果任何断言失败，我们就无法看到直接的失败原因。在小型代码库中，这不会是一个大问题，但你可以想象当你处理由数百个组件及其单元测试组成的代码库时的复杂性。这就是为什么隔离和简单是关键。
- en: Mocking external sources
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟外部源
- en: The previous component only dealt with its own state. But we’ve also incorporated
    external sources in our application. We can’t test what we can’t control, so we
    don’t have to test those external sources. We do have to test the way that our
    component interacts with external sources. To make that more predictable, we can
    use mocks to control the output.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的组件只处理其自身的状态。但我们在我们的应用程序中也集成了外部源。我们无法测试我们无法控制的内容，因此我们不需要测试那些外部源。我们必须测试我们的组件与外部源交互的方式。为了使其更可预测，我们可以使用模拟来控制输出。
- en: A good example is the browser API we’re using to retrieve the geolocation of
    a user. Let’s create our `GetLocation.spec.ts` file to test the component!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是我们用来检索用户地理位置的浏览器API。让我们创建我们的 `GetLocation.spec.ts` 文件来测试这个组件！
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we run our test now, it will fail. We need to fix two things here, to be
    honest. First of all, the test is an asynchronous test, since the retrieval of
    geolocation is a promise:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，它将会失败。坦白说，我们需要修复两件事。首先，这个测试是一个异步测试，因为地理位置的检索是一个承诺：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Unfortunately, this still doesn’t work. This is because the tests are not executed
    in an actual browser, but in `jsdom`, which is a JavaScript-based browser environment.
    It doesn’t support (all of the) native browser APIs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这仍然不起作用。这是因为测试不是在实际浏览器中执行的，而是在 `jsdom` 中执行的，`jsdom` 是一个基于 JavaScript 的浏览器环境。它不支持（所有）原生浏览器
    API。
- en: 'The component tries to access the `navigator.geolocation.getCurrentPosition`
    API, but it doesn’t exist! We need to mock it to allow our component to render.
    Mocking can be a bit abstract, but it is really about controlling the environment
    that affects our components. In our case, we can use a very straightforward implementation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 组件尝试访问 `navigator.geolocation.getCurrentPosition` API，但它不存在！我们需要模拟它以允许我们的组件渲染。模拟可能有点抽象，但它实际上是关于控制影响我们组件的环境。在我们的情况下，我们可以使用一个非常直接的实施方法：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, we’re simply providing a method called `getCurrentPosition` so
    that it exists in the *browser* when we’re executing our test. This service doesn’t
    return any valid or useful information, but that’s not what we’re interested in
    here. We just want our component to be able to render.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们只是提供了一个名为 `getCurrentPosition` 的方法，以便在执行测试时存在于 *浏览器* 中。这个服务不返回任何有效或有用的信息，但这不是我们这里感兴趣的地方。我们只是希望我们的组件能够渲染。
- en: 'Also bear in mind that this test highlights a flaw in our application: it needs
    `navigator.geolocation.getCurrentPosition` to be present; otherwise, it will fail!'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同时请注意，这个测试突显了我们应用程序的一个缺陷：它需要 `navigator.geolocation.getCurrentPosition` 存在；否则，它将失败！
- en: Mocking for success
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成功模拟
- en: To extend our testing scenario, we need to assert that our component is able
    to return a successfully resolved geolocation. We are going to create a new test
    case, because of isolation, and improve upon our mocked navigator API. We’ll use
    Vitest,s `vi.fn()` function for this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展我们的测试场景，我们需要断言我们的组件能够返回一个成功解析的地理位置。我们将创建一个新的测试用例，因为隔离，并改进我们的模拟导航器 API。我们将使用
    Vitest 的 `vi.fn()` 函数来完成这项工作。
- en: The `vi.fn()` function ([https://vitest.dev/api/vi.html#vi-fn](https://vitest.dev/api/vi.html#vi-fn))
    is a Vitest function that creates a spy on the function. This means it stores
    all call arguments, returns, and instances. By storing it in `mockGeoLocation`,
    we can assert its properties more easily. The function takes in an argument, which
    is a callable mock instance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`vi.fn()` 函数 ([https://vitest.dev/api/vi.html#vi-fn](https://vitest.dev/api/vi.html#vi-fn))
    是一个 Vitest 函数，它会在函数上创建一个间谍。这意味着它存储了所有调用参数、返回值和实例。通过将其存储在 `mockGeoLocation` 中，我们可以更容易地断言其属性。该函数接受一个参数，即一个可调用的模拟实例。'
- en: 'At the top of the test file, we’ll import the `vi` function like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件顶部，我们将像这样导入 `vi` 函数：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s have a look at the test:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看测试：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, instead of just having an empty function on the `navigator.geolocation.getCurrentPostition`
    method, we’ve created a mock of what a successful resolution would look like.
    We can find out the specifications of the `getCurrentPosition` API ([https://w3c.github.io/geolocation-api/#dom-geolocation-getcurrentposition](https://w3c.github.io/geolocation-api/#dom-geolocation-getcurrentposition))
    in order to have our mock match the expected behavior.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不是在 `navigator.geolocation.getCurrentPostition` 方法上只有一个空函数，而是创建了一个模拟，模拟了一个成功的解决方案。我们可以找到
    `getCurrentPosition` API 的规范 ([https://w3c.github.io/geolocation-api/#dom-geolocation-getcurrentposition](https://w3c.github.io/geolocation-api/#dom-geolocation-getcurrentposition))，以便我们的模拟匹配预期的行为。
- en: We’re providing a `successCallback` function, which returns coordinates just
    as the browser API would, and we’re immediately invoking it to simulate a user
    granting access to the geolocation data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个 `successCallback` 函数，它返回坐标，就像浏览器 API 一样，并且我们立即调用它来模拟用户授予对地理位置数据的访问权限。
- en: Having a successful resolution, we can assert that the component received the
    same `coords` object that came from the browser.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在有一个成功的解决方案的情况下，我们可以断言组件接收到了来自浏览器的相同的 `coords` 对象。
- en: Unhappy path
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不愉快路径
- en: 'Having tested a successful resolution, the last thing to test is what would
    happen if the user declined access to the location data. We will use a very similar
    approach, but instead of the successful callback, we will provide a secondary
    callback for failure. Again, this is according to the specification:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试了一个成功的解决方案之后，最后要测试的是如果用户拒绝访问位置数据会发生什么。我们将使用一个非常类似的方法，但我们将提供一个失败的次要回调而不是成功的回调。再次强调，这是根据规范：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, in this case, we’re completely ignoring `successCallback` and
    instead defining and invoking `errorCallback`. As the component dictates, the
    reactive `geolocationBlockedByUser` property will be set to true and we will show
    an error message.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，我们完全忽略了 `successCallback`，而是定义和调用 `errorCallback`。正如组件所指示的，反应性的
    `geolocationBlockedByUser` 属性将被设置为 true，我们将显示错误消息。
- en: 'The complete test file now looks like this, where we assert that the component
    renders, and it can resolve a successful query and handle a denied request:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试文件现在看起来是这样的，其中我们断言组件可以渲染，并且可以解析成功的查询并处理拒绝的请求：
- en: '[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/03.weather/.notes/2.1-GetLocation.spec.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/03.weather/.notes/2.1-GetLocation.spec.ts)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/03.weather/.notes/2.1-GetLocation.spec.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/03.weather/.notes/2.1-GetLocation.spec.ts)'
- en: We’ve made sure we’ve tested both the happy and the unhappy path. Let’s see
    how we can apply testing to components dealing with external data from an endpoint.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保我们已经测试了快乐和不幸的路径。让我们看看我们如何将测试应用到处理来自端点的外部数据的组件上。
- en: Testing with APIs
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 API
- en: 'Our final component also has an external dependency. This is not much different
    from mocking a browser API, as we will discover in this section. If we look at
    our component, it has the following features: shows the loading state when no
    data is retrieved and displays the response from the service in a nicely formatted
    way.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的组件也有外部依赖。这并不比模拟浏览器 API 差很多，正如我们将在本节中发现的那样。如果我们看看我们的组件，它有以下特点：在没有检索到数据时显示加载状态，并以良好的格式显示服务的响应。
- en: 'Let’s start with assessing that the component can render in a file called `WeatherRepost.spec.ts`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从评估组件是否可以在名为 `WeatherRepost.spec.ts` 的文件中渲染开始：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, you see that instead of mocking a `navigator` property, we’re
    mocking a global `fetch` property. We don’t need to return anything, so we’re
    keeping this test as simple as possible.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以看到，我们不是模拟 `navigator` 属性，而是在模拟全局的 `fetch` 属性。我们不需要返回任何东西，所以我们保持这个测试尽可能简单。
- en: 'On to testing the loading state. In fact, we’re actually cheating a little
    bit here. There is simply a state of not having data or having data. We’re treating
    not having data as a loading state for the sake of simplicity:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是测试加载状态。实际上，我们在这里有点作弊。这里只有一个没有数据或有数据的状态。我们为了简单起见，将没有数据视为加载状态：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For this test, we’re just resolving the data as nothing. That means there’s
    no data available to render, which will keep the component in its loading state.
    We can assert that without data, the **Loading…** text stays visible.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们只是将数据解析为无。这意味着没有可渲染的数据，这将保持组件在加载状态。我们可以断言，在没有数据的情况下，**Loading…** 文本仍然可见。
- en: 'We can also assert the situation when we did receive data from the service.
    This involves a similar approach, with the difference that instead of resolving
    nothing, we resolve with a mock weather report:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以断言当我们从服务接收到数据的情况。这涉及到类似的方法，区别在于我们不是解析无，而是解析一个模拟的天气报告：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We assert that the `mockData` properties are being mapped to the wrapper. There
    is a problem, though: the assertions are failing! We have two problems, in fact.
    The `shallowMount` function is flattening the HTML structure a bit and we have
    to wait for the promises to be resolved.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们断言 `mockData` 属性正在映射到包装器。然而，有一个问题：断言失败了！实际上，我们有两个问题。`shallowMount` 函数稍微简化了
    HTML 结构，我们必须等待承诺得到解决。
- en: 'Luckily, Vue Test Utils has a useful utility for dealing with the promises:
    `flushPromises` is a utility function that makes sure all pending promises are
    resolved. We can import it at the top of our file together with our `mount` functions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vue Test Utils 有一个处理承诺的有用工具：`flushPromises` 是一个实用函数，确保所有挂起的承诺都得到解决。我们可以在文件顶部导入它，与我们的
    `mount` 函数一起：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we rerun our test, it will succeed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行我们的测试，它将成功：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There’s one final check since we have a formatter for our timestamp. Let’s
    add a `data-testid` attribute to the element:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有时间戳的格式化器，所以有一个最后的检查。让我们给元素添加一个 `data-testid` 属性：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: it('displays formats the datetime to a locale format', async () => {  const
    mockData = {
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: it('displays formats the datetime to a locale format', async () => {  const
    mockData = {
- en: 'location: {'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'location: {'
- en: 'localtime: new Date(),'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'localtime: new Date(),'
- en: '},'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: 'current: {'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'current: {'
- en: 'condition: {},'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'condition: {},'
- en: '}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: global.fetch = vi.fn(() => Promise.resolve({
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: global.fetch = vi.fn(() => Promise.resolve({
- en: 'json: () => Promise.resolve(mockData)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '})) as any'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '})) as any'
- en: const wrapper = mount(WeatherReport, {
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: const wrapper = mount(WeatherReport, {
- en: 'props: {'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'props: {'
- en: 'coords: {'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标：{
- en: 'latitude: 0,'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度：0，
- en: 'longitude: 0'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 经度：0
- en: '}'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '})'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '})'
- en: await flushPromises();
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: const localtime = wrapper.find("[data-testid=localtime]");
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: const localtime = wrapper.find("[data-testid=localtime]");
- en: expect(localtime.text()).toEqual('January 31, 2001 at 11:45 AM')
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 预期(localtime.text()).toEqual('2001年1月31日 上午11:45')
- en: '});'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: it('displays formats the datetime to a locale format', async () => {  const
    mockDateTime = new Date(2000, 12, 31, 11, 45, 0, 0)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: it('显示格式化为本地格式的日期时间', async () => {  const mockDateTime = new Date(2000, 12,
    31, 11, 45, 0, 0)
- en: vi.setSystemTime(mockDateTime)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: vi.setSystemTime(mockDateTime)
- en: const mockData = {
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: const mockData = {
- en: 'location: {'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 位置：{
- en: 'localtime: new Date(),'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'localtime: new Date(),'
- en: '},'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: 'current: {'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当前：{
- en: 'condition: {},'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'condition: {},'
- en: '}'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: global.fetch = vi.fn(() => Promise.resolve({
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: global.fetch = vi.fn(() => Promise.resolve({
- en: 'json: () => Promise.resolve(mockData)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: json：() => Promise.resolve(mockData)
- en: '})) as any'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '})) as any'
- en: const wrapper = mount(WeatherReport, {
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: const wrapper = mount(WeatherReport, {
- en: 'props: {'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'props: {'
- en: 'coords: {'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标：{
- en: 'latitude: 0,'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度：0，
- en: 'longitude: 0'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 经度：0
- en: '}'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '})'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '})'
- en: await flushPromises();
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 等待(flushPromises());
- en: const localtime = wrapper.find("[data-testid=localtime]");
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: const localtime = wrapper.find("[data-testid=localtime]");
- en: expect(localtime.text()).toEqual('January 31, 2001 at 11:45 AM')
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 预期(localtime.text()).toEqual('2001年1月31日 上午11:45')
- en: vi.useRealTimers()
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: vi.useRealTimers()
- en: '});'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 等待(flushPromises());
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
