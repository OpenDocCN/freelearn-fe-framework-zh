<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Asynchronous Programming</h1>
                </header>
            
            <article>
                
<p>To learn what asynchronous code is, let's first cover what synchronous code is. With synchronous code, you have one statement being executed after another. The code is predictable; you know what happens and when. This is because you can read the code from top to bottom like this:</p>
<pre>print('a')<br/>print('b')<br/>print('c')<br/><br/>// output<br/><strong>a, b, c</strong></pre>
<p>Now, with asynchronous code you lose all the nice predictability that the synchronous code offers. In fact, there is very little you know about asynchronous code other than that it finishes executing, eventually. So asynchronous, or async, code looks more like this:</p>
<pre>asyncPrint('a')<br/>asyncPrint('b')<br/>asyncPrint('c')<br/><br/>// output<br/><strong>c, b, a</strong></pre>
<p>As you can see, the order in which a statement finishes is not determined by when a statement occurs in the code. Instead, there is a time element involved that decides when a statement has run its course.</p>
<p>Asynchronous code runs in an event loop. This means that async code runs in the following order:</p>
<ol>
<li>Run async code</li>
<li>Wait for the response to be ready, then fire an interrupt</li>
<li>Run the event handler</li>
</ol>
<p>An important thing to stress here is that async code is non-blocking—other operations can take place while async code is running. Therefore, async code is a good candidate to be used when dealing with I/O, long-running tasks, and network requests.</p>
<p>In this chapter, we will:</p>
<ul>
<li>Learn what asynchronous programming is and how it differs from synchronous programming</li>
<li>Explain the callback model</li>
<li>Describe promises and how they completely reformed how we write asynchronous code</li>
<li>Look at which other asynchronous libraries exist and in what cases they should be used</li>
<li>Discover the new standard async/await</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The callback pattern</h1>
                </header>
            
            <article>
                
<p>Previously, we described what asynchronous and synchronous code looks like when you encounter it in your everyday life as a developer. What might be of interest is to know how an operating system looks at such code and how it deals with it. An operating system deals with asynchronous code by thinking of it in terms of the following concepts:</p>
<ul>
<li>Events, these are messages that signals to the operating system that a certain type of action has occurred</li>
<li>Event handler, this is the piece of code that should run when an event has occurred</li>
<li>Event queue, this is where all events and their event handlers are placed, waiting to be executed</li>
</ul>
<p>Let's illustrate this flow in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-259 image-border" src="assets/479cdc64-c4d1-459e-86d2-c0d74e1b9a52.png" style=""/></div>
<p>What we can see in the preceding image is how events are being picked from an event queue. Here, the <strong>CLICK</strong> event is being run when a Dispatcher tells it to and its corresponding event handler is executed. The event handler runs the associated lines of code in the event handler and when that's done, gives <span>control </span>back to the Dispatcher. Thereafter, the cycle begins anew for the next event in the queue. This is what it usually looks like in a single-threaded system, where only one event handler is executed at a time.  There is also such a thing as a multithreaded system. In a multithreaded system, multiple threads exist. This means we might have several event handlers being executed at once. But even though there are multiple threads, there is only one active thread. The system itself is still single-threaded. Confused? Here is the thing: threads in a multithreaded system are cooperative, which means they can be interrupted. This means that the active thread is changed after a unit of work has been carried out. This creates an effect where it seems like everything happens in parallel. Let's illustrate this for clarity:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-260 image-border" src="assets/72f27ff3-d8a0-471b-942d-cd3010f29b8d.png" style=""/></div>
<p>Here, we can see that a piece of code is divided into different regions. When a certain region has been executed, it gives control to the next <strong>Thread</strong>, which becomes the new <strong>Active thread</strong>. Once that thread has executed code through one of its regions, it gives control to the next thread. With the arrival of multiple CPUs, we are able to go from perceived parallelism (described previously) to actual parallel execution. In such a reality, one thread per CPU exists and we therefore have multiple active threads. </p>
<p>These are the different ways you can execute asynchronous code. We will focus on single-threaded execution, as this is how it is implemented in JavaScript and on the web.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The callback pattern on the web</h1>
                </header>
            
            <article>
                
<p>The way to go about it is to attach functions to future events. When the event occurs, our attached function gets executed. An example of this is <kbd>XMLHttpRequest</kbd>, which looks like this:</p>
<pre>const xhr = new XMLHttpRequest();<br/>xhr.open('GET','/path', true);<br/>xhr.onload = () =&gt; {<br/>  // run me when the request is finished<br/>}<br/><br/>xhr.send(null);</pre>
<p>What we can see here is that all lines are executed synchronously except for <kbd>xhr.onload</kbd>. Attaching the function to <kbd>onload</kbd> happens synchronously, but running the function that <kbd>onload</kbd> is pointing to doesn't happen until the request finishes. We can also define other events, such as <kbd>onreadystatechange</kbd> , and attach a function to that as well:</p>
<pre>xhr.onreadystatechange = () =&gt; {}</pre>
<p>As the web is single-threaded, this is how we deal with asynchronous code. The <kbd>onreadystatechange</kbd> object and its callback are registered with the operating system. Once the asynchronous part has been completed the operating system is woken up by an event being dispatched. Thereafter, the callback is invoked.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The callback pattern in Node.js</h1>
                </header>
            
            <article>
                
<p>Node.js is single-threaded, just like the web. To handle long running operations it also uses a callback pattern. The callback pattern in Node.js has a a few more details to it and can be described as having the following properties:</p>
<ul>
<li>There is only one function to handle success and error responses</li>
<li>The callback is called only once</li>
<li>The function is the last parameter of the calling function</li>
<li>The callback consists of the parameter's errors and results, in that order, which is also called error-first</li>
</ul>
<p>Let's now showcase what the calling code looks like, with a callback supplied as the function's last argument:</p>
<pre>callAsync('1',2, (error, response) =&gt; {<br/>  if(error) {<br/>    console.error(error);<br/>  } else {<br/>    console.log('response', response); <br/>    // do something with the response<br/>  }<br/>})</pre>
<p>This piece of code fulfills all the properties laid out by the pattern, namely that the last parameter in the function call is the callback function. Furthermore, the callback function has the error as the first parameter and the response as the second parameter. In addition, the body of the callback function checks whether there is an error first and then, in the absence of an error, deals with the response we get back. </p>
<p>For reference, let's also look at how <kbd>callAsync()</kbd> is implemented:</p>
<pre>function callAsync(param, param2, fn) {<br/>  setTimeout(() =&gt; {<br/>   if(param &gt; param2) {<br/>     fn(null, 'success');<br/>   } else {<br/>     fn('error', null);<br/>   }<br/>}</pre>
<p>The preceding implementation is just a mockup but it does show off two important aspects. One aspect is the time factor the <kbd>setTimeout()</kbd> function represents and the fact that the function takes time to complete.</p>
<p>The other aspect is our third parameter, <kbd>fn()</kbd> which is invoked differently. We call <kbd>fn(null, 'success')</kbd> when everything is alright and <kbd>fn('error', null)</kbd> when an error has occurred. The way we invoke <kbd>fn()</kbd> is how we communicate success and failure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Problems with structuring async code – callback hell</h1>
                </header>
            
            <article>
                
<p>In the previous section, we introduced the callback pattern as a way to deal with asynchronous calls. The pattern offers a structured way of dealing with such calls, in that we can always know what to expect in its method signature; the error is the first parameter, the second parameter is the response, and so on. But the pattern does have its shortcomings. The shortcomings might not be obvious at first, because you might only call the code like this:</p>
<pre>openFile('filename', (err, content) =&gt; {<br/>  console.log( content );<br/>  statement4;<br/>  statement5;<br/>})<br/><br/>statement2;<br/>statement3</pre>
<p>What we see here is how we invoke the method <kbd>openFile()</kbd>. Once that runs to completion, the callback is called and, inside of the callback, we continue invoking <kbd>statement4</kbd> and <kbd>statement5</kbd>.</p>
<p>This looks okay in the sense that it is still readable. The problem arises when you need to do several async calls one after another and those calls are dependent upon each other. It might be that you first need to log in to a system and then fetch the other data, or it might mean that you need to make a call as to whose data needs to be used as input for the next call, like in this example:</p>
<pre>getData('url', (err, data) =&gt; {<br/>  getMoreData('newurl/'+ data.id, (moreData) =&gt; {<br/>    getEvenMoreData('moreurl/'+ moreData.id, () =&gt; {<br/>      console.log('done here');<br/>    })<br/>  })<br/>})</pre>
<p>The anti-pattern we see emerging here is that of tabulation and lost readability. For each call we make, we see the code is tabbed one step in; it's nested. When we have three calls like this, we can see that the code doesn't look very nice; it is readable, but not very pleasing to the eye. Another drawback is it's also technically hard to get right, in that we might struggle to place the parentheses and curly brackets in the correct place. Throw a few <kbd>if...else</kbd> clauses in there and you will have a hard time matching all the symbols.</p>
<p>There are several ways you can address this problem:</p>
<ul>
<li>Keep the code shallow and use named functions over anonymous ones</li>
<li>Reduce the cognitive load and move functions into their own modules</li>
<li>Use more advanced constructs, such as promises, generators, and async functions from ES7 and other async libraries</li>
</ul>
<p>Keeping the code shallow is about giving our anonymous functions a dedicated name and breaking them out into their own functions; this will make our code look like this:</p>
<pre>function getEvenMoreDataCallback(err, evenMoreData) {<br/>  console.log('done here');<br/>}<br/><br/>function getMoreDataCallback(err, moreData){<br/>  getEvenMoreData('moreurl/'+ moreData.id, getEvenMoreDataCallback);<br/>}<br/><br/>function getDataCallback(err, data){<br/>  getMoreData('newurl/'+ data.id, getMoreDataCallback);<br/>}<br/><br/>getData('url', getDataCallback)</pre>
<p>This clearly flattens out the code and makes it more easier to read. It also removes the need to match curly brackets correctly as the functions are only one level deep.</p>
<p>This gets the code part out of the way, but there is still a cognitive load as we have to process three function definitions and one function call. We can move them out to their own dedicated modules, like this:</p>
<pre>let getDataCallback  = require('./datacallback');<br/>getData('url', getDataCallback);</pre>
<p>And for the other method, it would look like this:</p>
<pre>function getEvenMoreDataCallback(err, evenMoreData) {<br/>  console.log('done here');<br/>}</pre>
<p>And this:</p>
<pre>var getEvenMoreDataCallback = require('./evenmorecallback');<br/><br/>function getMoreDataCallback(err, moreData){<br/>  getEvenMoreData('moreurl/'+ moreData.id, getEvenMoreDataCallback);<br/>}</pre>
<p class="mce-root">Now we have removed quite a lot of the cognitive code. It may not have paid for itself in this case, as the methods were not that long, but imagine the methods spanned 30 or 40 lines in size; putting them in a separate module would have made a lot more sense. </p>
<p>The third option is to deal with this kind of code using more advanced constructs. We will address these in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Promises</h1>
                </header>
            
            <article>
                
<p>Promises came about as a response to the callback hell problem described in the previous section. They have quite a long history, stretching back to the early 80s, when the legendary <em>Barbara Liskov</em> coined the term <kbd>Promise</kbd>. The idea of a <kbd>Promise</kbd> is to flatten out async code. A promise is said to have the following states:</p>
<ul>
<li><strong>Pending</strong>: This means it has not yet been decided or that the data is not available yet</li>
<li><strong>Fulfilled</strong>: The data has come back</li>
<li><strong>Rejected</strong>: An error happened during the operation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Thenables</h1>
                </header>
            
            <article>
                
<p><span>Something important to know is that a <kbd>Promise</kbd> returns straight away, but the result is not available straight away. </span>Promises are also known as <em>thenables</em>, because you need to register a callback with its <kbd>then()</kbd> method once the data has been received, like so:</p>
<pre>const promise = new Promise((resolve, reject) =&gt; {<br/>  // either call resolve() if we have a success or reject() if it fails <br/>});<br/><br/>// the 'promise' variable points to a construct <br/>// that will eventually contain a value<br/><br/>promise((data) =&gt; {  // &lt;- registering a callback on then()<br/>  // our data has arrived at this point<br/>})</pre>
<p>In the preceding code, we demonstrated how to create a promise and how to register it with the <kbd>then()</kbd> method. The <kbd>promise</kbd> variable instance contains a construct that is returned straight away. The callback in the <kbd>then()</kbd> method gets invoked once the data is ready for us to use. In that sense, a <kbd>Promise</kbd> resembles a callback pattern.</p>
<p>A <kbd>Promise</kbd> is really just a wrapping around an asynchronous construct.</p>
<p>In short, to use Promises we need to:</p>
<ul>
<li>Create the <kbd>promise</kbd> and make sure to call <kbd>resolve()</kbd> or <kbd>reject()</kbd> when the data has arrived or an error has occurred</li>
<li>Register a callback with its <kbd>then()</kbd> method</li>
<li>Register a callback to handle errors as well, as that is the responsible thing to do</li>
</ul>
<p>To put a promise to use, we need to instantiate it and make it part of a method, like so:</p>
<pre>function<span> </span><span>getData</span><span>() {<br/></span>  return<span> </span><span>new</span><span> </span><span>Promise</span><span>((</span><span>resolve</span><span>, </span><span>reject</span><span>) </span><span>=&gt;</span><span> {<br/>    </span>setTimeout<span>(() </span><span>=&gt;</span><span> {<br/>      </span>resolve<span>(</span><span>'data'</span><span>);<br/>    </span>},<span>1000</span><span>);<br/></span>  })<br/>}</pre>
<p>We see that; when we instantiate a <kbd>Promise</kbd> object, its constructor takes two parameters, <kbd>resolve</kbd> and <kbd>reject</kbd>. Let's connect this to the states we know a promise can have, namely, pending, fulfilled, and rejected. When <kbd>getData()</kbd> is initially called, the <kbd>promise</kbd> returned and has the state <kbd>pending</kbd>. After a second, the promise will be fulfilled, because we called the <kbd>resolve()</kbd> method. Let's look at the <kbd>getMoreData()</kbd> <span>method</span><span> to see how we can put a <kbd>Promise</kbd> into a rejected state:</span></p>
<pre>function<span> </span><span>getMoreData</span><span>() {<br/></span>  return<span> </span><span>new</span><span> </span><span>Promise</span><span>((</span><span>resolve</span><span>, </span><span>reject</span><span>) </span><span>=&gt;</span><span> {<br/>    </span>setTimeout<span>(() </span><span>=&gt;</span><span> {<br/></span>      reject<span>(</span><span>'error from more data'</span><span>)<br/>    </span>},<span>1000</span><span>);<br/>  </span>})<br/>}</pre>
<p>In this case, we call the <kbd>reject()</kbd> method after a second. This will put the promise into a rejected state. To get the data from a <kbd>promise</kbd> instance, we need to call the <kbd>then()</kbd> method on it, like so:</p>
<pre>promise.then( successCallback, &lt;optional error call back&gt; );</pre>
<p>A promise's <kbd>then()</kbd> method takes two callbacks: the first callback is the data callback and the second callback is an optional error callback. Let's put this in use on our defined <kbd>getData()</kbd> method, like so:</p>
<pre>getData().then( (data) =&gt; {<br/>  console.log('data', data);<br/>})</pre>
<p>It's clear that we can't just call <kbd>getData()</kbd> on the method straight away to get the data, but we need to call <kbd>.then()</kbd> on the <kbd>promise</kbd> it returns. Once we provide a callback, we are able to get the data and deal with it as we see fit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling rejected promises</h1>
                </header>
            
            <article>
                
<p>For a rejected promise, we have two ways of handling it: we can either use the second callback in the <kbd>.then()</kbd> method, or we can use the <kbd>.catch()</kbd> method. Here are the two versions available to us:</p>
<pre>// alternative 1<br/>getMoreData().then(<br/>  data =&gt; { <br/>    console.log('data',data); <br/>  }, <br/>  err =&gt; { <br/>    console.log('error',err); <br/>  }<br/>)<br/><br/>// alternative 2<br/>getMoreData().then(data =&gt; {<br/>  console.log('data', data);<br/>})<br/>.catch((err) =&gt; { <br/>  console.log('error', err); <br/>}); </pre>
<p>In the first case, we have a second callback added to the <kbd>then()</kbd> method, and in the second version, we chain a <kbd>catch()</kbd> method to the existing <kbd>then()</kbd> method. They are equivalent so you can use either one, but only one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chaining – dealing with several promises</h1>
                </header>
            
            <article>
                
<p>The most powerful feature of the promise lies in its ability to chain calls, thereby making code look synchronous. A chain looks like this:</p>
<pre>getData()<br/>  .then(getMoreData)<br/>  .then(getEvenMoreData)<br/>  .catch(handleError)</pre>
<p>This makes the code very easy to read. You are able to tell in which order things happen; namely, <kbd>getData()</kbd> followed by <kbd>getMoreData()</kbd>, followed by <kbd>getEvenMoreData()</kbd>. Not only are we able to run the methods in the order that we want, but we are also able to access the data from the previous <kbd>promise</kbd>, like so:</p>
<pre>function getData() {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve('data');<br/>    })<br/>  })<br/>}<br/><br/>function getMoreData(data) { // data is from getData<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve('data');<br/>    })<br/>  })<br/>}<br/><br/>getData().then(getMoreData)</pre>
<p>We can also see how we can add the <kbd>.catch()</kbd> <span>method to</span><span> the end to handle errors. The nature of chained promises are such that an error propagates all the way down to the </span><kbd>catch()</kbd><span> method.</span></p>
<p>It is, however, quite possible to handle an error at a specific level, like so:</p>
<pre>getData()<br/>  .then(getMoreData, <strong>(err) =&gt; {}</strong>) // local error handler<br/>  .then(getEvenMoreData )<br/>  .then(data =&gt; {} )<br/>  .catch(handleError ) // global error handler</pre>
<p>Now we have two error handlers, one at a local level <kbd>.then(getMoreData, (err) =&gt; {})</kbd> as the second argument in the <kbd>then()</kbd> method. This has a different effect than only adding <kbd>.catch()</kbd> to the bottom of our call chain. If only the <kbd>.catch()</kbd> method at the bottom exists, then the chain is short-circuited. As it stands, the current chain will call the local error function, the <kbd>.catch()</kbd> method, and the last <kbd>.then()</kbd> method when a <kbd>promise</kbd> is rejected from the <kbd>getMoreData()</kbd> method. The data parameter in the last <kbd>.then()</kbd> method will, however, not be set if the <kbd>promise</kbd> is rejected. Chaining is powerful and gives us the following:</p>
<ul>
<li>An ordered way of calling async methods</li>
<li>The previously resolved promise data as input to our method</li>
<li>The ability to handle errors globally as well as per promise, though with different results</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous libraries</h1>
                </header>
            
            <article>
                
<p>So far, we have discussed callback patterns and how using promises gives your code that badly needed sense of order. Writing asynchronous code isn't just about stopping yourself from drowning in messy code, it's about being productive as well. Libraries exist out there that will make you really productive if you mean business about taking asynchronous coding head on. The best known libraries at the time of writing are:</p>
<ul>
<li><strong>Async</strong>: This is by far the best known. It can be found at <a href="https://caolan.github.io/async/">https://caolan.github.io/async/</a>.<a href="https://caolan.github.io/async/"/></li>
<li><strong>Step</strong>: This library sells itself as a library that will help you with serial execution, parallel execution, and promises to make error handling painless. It can be found at <a href="https://github.com/creationix/step">https://github.com/creationix/step</a>.<a href="https://github.com/creationix/step"/></li>
<li><strong>Node fibers</strong>: This is a very different library than the first two and can be thought of more as bringing a light-thread support to JavaScript. It can be found at <a href="https://github.com/laverdet/node-fibers">https://github.com/laverdet/node-fibers</a>.<a href="https://github.com/laverdet/node-fibers"/></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Async library</h1>
                </header>
            
            <article>
                
<p>We have so far shown callbacks and Promises. We went from the problem with callbacks, namely callback hell, and how Promises solved that. However, there is a library called <strong>async</strong>, which is an alternative to callbacks and promises. So why would we want to use the async library instead? The async library is meant to operate on collections in an asynchronous context. The library authors themselves say this about it:</p>
<div class="packt_quote"><span>Async is a utility module which provides straight-forward, powerful functions for working with asynchronous JavaScript</span></div>
<p>So, if your asynchronous code starts to become unmanageable and you find yourself wanting to operate on asynchronous collections rather than a few calls here and there, this library might be for you. In most scenarios, promises are most likely what you want though.</p>
<p>The async library comes with a lot of nice functionality. The idea of the async library is to make your code look a lot better so you can focus on building things instead of struggling to see what the code is doing.</p>
<p>To use it, simply install it by typing:</p>
<pre><strong>npm install async --save</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">async.map()</h1>
                </header>
            
            <article>
                
<p>Let's have a look at an example where <kbd>async</kbd> shines and is able to remove unnecessary code. The following example shows how we call the <kbd>fs.stat()</kbd> method that will asynchronously tell us about a file, such as its size, when it was created, and so on. A normal call <kbd>fs.stat()</kbd> would look like this:</p>
<pre>// async-demo/app.js<br/><span><br/></span>const<span> fs </span><span>=</span><span> require(</span><span>'fs'</span><span>);<br/></span><br/>const<span> basePath </span><span>=</span><span> __dirname </span><span>+</span><span> </span><span>'/files/'</span><span>;<br/></span>const<span> files </span><span>=</span><span> [</span><span>'file1.txt'</span><span>, </span><span>'file2.txt'</span><span>, </span><span>'file3.txt'</span><span>];<br/></span><br/>fs.stat(basePath <span>+</span><span> </span><span>'file1.txt'</span><span>, (err, result) </span><span>=&gt;</span><span> {<br/></span>  if<span>(err) {<br/></span>    console.log(<span>'err'</span><span>);<br/></span>  } <span>else</span><span> {<br/></span>    const<span> { size, birthtime } </span><span>=</span><span> result;<br/></span>    console.log(<span>'Size'</span><span>,size);<br/></span>    console.log(<span>'Created'</span><span>, birthtime);<br/></span>  }<br/>});</pre>
<p>What if we wanted to make several calls and wanted to know the stats of several files? Firing off a number of calls- one per file- would mean our calls would come back at different times, depending on the size of the file. What if we don't care about the response until everything comes back? This is what the async library can help us with. There is a <kbd>map()</kbd> function that will allow us to fire off several calls at once and only return once all the calls are done, like so:</p>
<pre>// app-map.js<br/><br/>const<span> async </span><span>=</span><span> require(</span><span>'async'</span><span>);<br/></span>const<span> fs </span><span>=</span><span> require(</span><span>'fs'</span><span>);<br/></span>const<span> basePath </span><span>=</span><span> __dirname </span><span>+</span><span> </span><span>'/files/'</span><span>;<br/></span>const<span> files </span><span>=</span><span> [</span><span>'file1.txt'</span><span>, </span><span>'file2.txt'</span><span>, </span><span>'file3.txt'</span><span>];<br/></span>const<span> mappedFiles </span><span>=</span><span> files.map( f </span><span>=&gt;</span><span> basePath </span><span>+</span><span> f);<br/><br/></span>async.map(mappedFiles, fs.stat,(err, results) <span>=&gt;</span><span> {<br/></span>  if<span>(err) {<br/></span>    console.log(<span>'error'</span><span>, err);<br/></span>  }else<span> {<br/>    // looping through our results array<br/></span>    results.forEach(({size, birthtime}) <span>=&gt;</span><span> {<br/></span>      console.log(<span>'Size'</span><span>,size);<br/></span>      console.log(<span>'Created'</span><span>, birthtime);<br/></span>    });<br/>  }<br/>});</pre>
<p>So, what makes this so great? First off, our code aims to find out some file statistics about every file. Let's look at what life would look like without the async library:</p>
<pre>// example of running a callback method in a forEach()<br/><br/>[<span>'file1'</span><span>,</span><span>'file2'</span><span>,</span><span>'file3'</span><span>].</span><span>forEach</span><span>( </span><span>f</span><span> </span><span>=&gt;</span><span> {<br/>  var states = [];<br/>  </span>fs<span>.</span><span>stat</span><span>(</span><span>f</span><span>, </span><span>(</span><span>err</span><span>, </span><span>stat</span><span>) =&gt; {<br/>    </span>console<span>.</span><span>log</span><span>(</span><span>'stat'</span><span>, </span><span>stat</span><span>);<br/>    states.push( stat );<br/>  </span>})<br/>})</pre>
<p>We can see that we need to introduce a states array just to collect all the results and even then, we probably need to add some logic to know that we are on the last item in the array and can therefore start processing based on the fact that we now have all the results. Conversely, using <kbd>async.map()</kbd> means we have access to a function that collects the result in an array and also waits until the full array has been processed and all the results have come back.</p>
<p>So, the takeaway from all this is that <kbd>async.map()</kbd> helps us call a list of asynchronous calls into one call enabling us to process all the results once every single call is done, not before.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">async.parallel()</h1>
                </header>
            
            <article>
                
<p>Another important method in this library is <kbd>async.parallel()</kbd>, which lets us send off a lot of statements in parallel, like so:</p>
<pre>// async-demo/app-parallell.js<br/><br/>const<span> async </span><span>=</span><span> require(</span><span>'async'</span><span>);<br/></span><br/>function<span> getMessages(fn) {<br/></span>  setTimeout(() <span>=&gt;</span><span> {<br/></span>    fn(<span>null</span><span>,[</span><span>'mess1'</span><span>, </span><span>'mess2'</span><span>, </span><span>'mess3'</span><span>]);<br/></span>  }, <span>3000</span><span>);<br/></span>}<br/><br/>function<span> getOrders(fn) {<br/></span>  setTimeout(() <span>=&gt;</span><span> {<br/></span>    fn(<span>null</span><span>, [</span><span>'order1'</span><span>, </span><span>'order2'</span><span>, </span><span>'order3'</span><span>]);<br/></span>  }, <span>5000</span><span>);<br/></span>}<br/><br/>async.parallel([<br/>  getMessages,<br/>  getOrders<br/>],(error, results) <span>=&gt;</span><span> {<br/></span>  if<span>(error) {<br/></span>    console.log(<span>'error'</span><span>, error);<br/></span>  } <span>else</span><span> {<br/></span>    console.log(<span>'results'</span><span>, results);<br/></span>  }<br/>});</pre>
<p>What we can see from the previous code is that it allows us to kick off several calls in parallel. We specify the calls in an array that we provide to the <kbd>async.parallell([])</kbd> method. From what you can discern here, the functions we provide take one parameter, <kbd>fn</kbd>, which is the callback, for example <kbd>getOrders(fn) {}</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">async.series()</h1>
                </header>
            
            <article>
                
<p>Another scenario is that you might want to actually have the calls happen one after another. For that, we get the <kbd>async.series()</kbd> <span>method</span><span>, which we call like this:</span></p>
<pre>async.series([<br/>  function login(){}<br/>  function loadUserDetails() {}<br/>],(result) =&gt; {})</pre>
<p>Running the code like this guarantees the order in which it will be run, but also ensures that the chain of calls does not continue if there is an error.</p>
<p>There are a ton of useful functions in this library and we urge you to have a look at the documentation at <a href="https://caolan.github.io/async/docs.html">https://caolan.github.io/async/docs.html</a>.<a href="https://caolan.github.io/async/docs.html"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Async/await</h1>
                </header>
            
            <article>
                
<p>The async/await is part of the ECMAScript standard ES2017. This construct provides a synchronous-looking experience when dealing with async. Currently, you need something like Babel to run it in the frontend, but for Node.js it is sufficient to run it on version &gt;= 8. Async/await is currently implemented with a concept called generators in the background. Generators are functions that can be exited and re-entered later. To read more about generators, have a look at the following link: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*</a>. It is the new way of dealing with asynchronous code and it really helps make our code look synchronous, which takes away a lot of the cognitive pain associated with asynchronous programming.</p>
<p>Let's remind ourselves of our old example, illustrating the callback hell situation:</p>
<pre>getData()<br/>  .then( data =&gt; {<br/>    getMoreData(moreData =&gt; {<br/>      getEvenMoreData(() =&gt; {<br/>        // do stuff<br/>      })<br/>    })<br/>  });</pre>
<p>We clearly see the downsides to calling the code this way. The async/await plays the role of a savior, in that it really cleans things up here. However, let's first explain the different parts and how we can work towards refactoring the previous example. A method using async/await is usually the highest-level method; the highest level in the sense that it is the first method to be called in a chain of <kbd>async</kbd> methods. In the previous example, this would be the <kbd>getData()</kbd> method. Let's transform <kbd>getData()</kbd> to look like this:</p>
<pre><strong>async</strong> function getData() {<br/>  // more to come<br/>} </pre>
<p>What we need to realize at this point, is that we need to refactor the other two methods, <kbd>getMoreData()</kbd> and <kbd>getEvenMoreData()</kbd>, into methods that return promises instead of being callback-based. Why is that, you might wonder? Well, when we use async/await, we want to call the code in a certain way. As hinted at earlier, we will use the keyword <kbd>async</kbd> in front of our <kbd>getData()</kbd> function. What's more is that we want to use the keyword <kbd>await</kbd> in the following way:</p>
<pre><strong>async</strong> function getData() {<br/>  let data = <strong>await</strong> getMoreData();<br/>  let otherData = await getEvenMoreData();<br/>} </pre>
<p>Looking at the preceding code, we realize that there is a mismatch in our existing method signature. The mismatch is not the main reason we need to switch our implementation to being promise-based. The real reason is the fact the <kbd>await</kbd> keyword is able to unwrap promises but not callback based methods. Unwrapping means it can take the resulting value of our asynchronous operation and return it.</p>
<p>The current state of our methods before changing them into promises is:</p>
<pre>function getMoreData(cb) { <br/>  setTimeout(() =&gt; cb('more data'), 3000); <br/>}<br/>function getEvenMoreData(cb) { <br/>  setTimeout( () =&gt; cb('even more data'), 3000 ); <br/>}</pre>
<p>Turning them into promise-based methods means they should now look something like this:</p>
<pre>function getMoreData() { <br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; resolve('more data'))<br/>  });<br/> <br/>}<br/><br/>function getEvenMoreData() { <br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; resolve('more data'))<br/>  });<br/>}</pre>
<p>At this point, we are ready to return back to our <kbd>getData()</kbd> method and add the missing code. When we call <kbd>getMoreData()</kbd> and <kbd>getEvenMoreData()</kbd>, we can now use the keyword <kbd>await</kbd> to wait for the promise to resolve, like so:</p>
<pre>async function getData() {<br/>  var data = <strong>await</strong> Promise.resolve('data');<br/>  var moreData = <strong>await</strong> getMoreData(data);<br/>  var evenMoreData = <strong>await</strong> getEvenMoreData(moreData);<br/>  return evenMoreData; <br/>}</pre>
<p>What we get now is completely synchronous-looking code. How do we retrieve the data from <kbd>getData()</kbd> though? Easy—it returns a <kbd>promise</kbd>. So, we can call it like this:</p>
<pre>getData().then((result) =&gt; console.log('result', result) );</pre>
<p>The async/await is a truly powerful construct, in that it takes away a lot of the cognitive pain caused by callback hell and further improves upon the concept of promises.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered asynchronous code, when it is used, and for what purposes. It is clear that asynchronous code becomes harder and harder to read and maintain as it grows, giving rise to patterns such as callback hell. There are several techniques to deal with this, as described throughout this chapter. Changing your coding style a little is one way. Looking at constructs such as promises, especially in conjunction with async/await, is another way. Using async/await means we suddenly get something that can be likened to order in your async code. We have tried to keep things as framework free as possible as it is important to understand all the mentioned concepts without mixing them up with concepts from a specific application framework. One thing can be said though: Angular allows you to use whichever asynchronous method you want to organize your code. Doing HTTP calls, for example, uses an Angular service that is strongly tied to the RxJS library, but you are free to use a promise-based style such as the <kbd>fetch()</kbd> API. It is also possible to leverage async/await with Angular using Babel and the transformer that supports it.</p>
<p>This chapter has laid a foundation for what asynchronous coding is. The next chapter will build on that foundation by introducing the concept of <strong>Functional Reactive Programming</strong> (<strong>FRP</strong>). It deals more with how to reason around the fact that data arrives seemingly when it wants to. As messy as that sounds, even that can be modeled to create a sense of structure and order if we think of our data as a stream. More on that in the next chapter.</p>


            </article>

            
        </section>
    </body></html>