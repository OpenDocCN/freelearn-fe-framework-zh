<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer008">
<h1 class="ch pter-number" id="_idParaDest-17"><a id="_idTextAnchor015"/><a id="_idTextAnchor016"/>1</h1>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><a id="_idTextAnchor018"/><a id="_idTextAnchor019"/><a id="_idTextAnchor020"/>What Is State and How Do We Manage It?</h1>
<p><strong class="bold">State</strong> is a mutable data <a id="_idIndexMarker000"/>source that can be used to store data in a <strong class="bold">React</strong> application and can change over time and be used to determine how your <span class="No-Break">component renders.</span></p>
<p>This chapter will refresh your existing knowledge about state in the React ecosystem. We will review what it is and why it is needed, and understand how it helps you build <span class="No-Break">React applications.</span></p>
<p>We’ll also review how you can manage state natively in React by using the <strong class="bold">useState</strong> hook, the <strong class="bold">useReducer</strong> hook, and <span class="No-Break"><strong class="bold">React Context</strong></span><span class="No-Break">.</span></p>
<p>Finally, we’ll offer brief descriptions of the common state management solutions such as <strong class="bold">Redux</strong>, <strong class="bold">Zustand</strong>, and <strong class="bold">MobX</strong> and understand why they have been created and the main common concept they <span class="No-Break">all share.</span></p>
<p>By the end of this chapter, you will have either learned or remembered everything about state necessary to proceed in this book. You will also notice a pattern in how state is managed between different state management solutions and meet or get reacquainted with a familiar term. Spoiler alert: it is <span class="No-Break">global state.</span></p>
<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li>What is state <span class="No-Break">in React?</span></li>
<li>Managing state <span class="No-Break">in React</span></li>
<li>What do different state management libraries have <span class="No-Break">in common?</span></li>
</ul>
<h1 id="_idParaDest-19"><a id="_idTextAnchor021"/>Technical requirements</h1>
<p>In this book, you are going to see some code snippets. If you want to try them out, you are going to need <span class="No-Break">the following:</span></p>
<ul>
<li>An <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) such as Visual <span class="No-Break">Studio Code.</span></li>
<li>A web browser (Google Chrome, Firefox, <span class="No-Break">or Edge).</span></li>
<li>Node.js. All the code in this book was written with the current LTS version <span class="No-Break">installed (16.16.0).</span></li>
<li>A package manager (npm, Yarn, <span class="No-Break">or pnpm).</span></li>
<li>A React project. If you don’t have one, you can create one with Create React App by running the following command in <span class="No-Break">your terminal:</span><pre class="source-code">
<strong class="bold">npx create-react-app my-react-app</strong></pre></li>
</ul>
<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at<a id="_idTextAnchor022"/><a id="_idTextAnchor023"/> </span><a href="https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_1"><span class="No-Break">https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_1</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor024"/>What is state in React?</h1>
<p>State is the heart <a id="_idIndexMarker001"/>of your <span class="No-Break">React application.</span></p>
<p>I challenge <a id="_idIndexMarker002"/>you to try to build a React application without any <a id="_idIndexMarker003"/>type of state. You’d probably be able to do something, but you would soon conclude that props cannot do everything for you and <span class="No-Break">get stuck.</span></p>
<p>As mentioned in the introduction, state is a mutable data source used to store <span class="No-Break">your data.</span></p>
<p>State is mutable, which means that it can be changed over time. When a state variable changes, your React component will re-render to reflect any changes that the state causes to <span class="No-Break">your UI.</span></p>
<p>Okay, now, you might be wondering, “<em class="it lic">What will I store in my state?</em>” Well, the rule of thumb that I follow is that if your data fits into any of the following points, then it’s <span class="No-Break">not state:</span></p>
<ul>
<li><span class="No-Break">Props</span></li>
<li>Data that will always be <span class="No-Break">the same</span></li>
<li>Data that can be derived from other state variables <span class="No-Break">or props</span></li>
</ul>
<p>Anything that doesn’t fit this list can be stored in state. This means things such as data you just fetched through a request, the light or dark mode option of a UI, and a list of errors that you got from filling a form in the UI are all examples of what can <span class="No-Break">be state.</span></p>
<p>Let’s look at the <span class="No-Break">following example:</span></p>
<pre class="source-code">
const NotState = ({<strong class="bold">aList</strong> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  ]}) =&gt; {
  const <strong class="bold">value</strong> = "a constant value";
  const <strong class="bold">filteredList</strong> = aList.filter((item) =&gt; item % 2 ===
    0);
  return filteredList.map((item) =&gt;
    &lt;div key={item}&gt;{item}&lt;/div&gt;);<a id="_idTextAnchor025"/><a id="_idTextAnchor026"/><a id="_idTextAnchor027"/><a id="_idTextAnchor028"/>
};</pre>
<p>Here, we have a<a id="_idIndexMarker004"/> component called <strong class="source-inline">NotState</strong>. Let’s look at the values we <a id="_idIndexMarker005"/>have in there and use our rule <span class="No-Break">of thumb.</span></p>
<p>The <strong class="source-inline">aList</strong> variable is a component prop. Since our component will receive this, it doesn’t need to <span class="No-Break">be state.</span></p>
<p>Our <strong class="source-inline">value</strong> variable is assigned a string value. Since this value will always be <em class="it lic">constant</em>, then it doesn’t need to <span class="No-Break">be state.</span></p>
<p>Finally, the <strong class="source-inline">filteredList</strong> variable is something that can be derived from our <strong class="source-inline">aList</strong> prop; therefore, it doesn’t need to <span class="No-Break">be state.</span></p>
<p>Now that you are familiar with the concept of state, let’s get our hands dirty and understand how can we manage it <span class="No-Break">in React.</span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor029"/>Managing state in React</h1>
<p>Before diving into <a id="_idIndexMarker006"/>some examples, it is important to mention <a id="_idIndexMarker007"/>that in this book, <em class="it lic">all the examples shown are in a React version after 16.8</em>. This is because <strong class="bold">React Hooks</strong> were introduced <a id="_idIndexMarker008"/>in this version. Hooks changed the way we write React code and allowed for the appearance of libraries such as React Query, so it makes sense that any examples shown <span class="No-Break">leverage them.</span></p>
<p class="c llout-he ding">What is React Query?</p>
<p class="c llout">React Query is a <a id="_idIndexMarker009"/>protocol-agnostic collection of hooks for fetching, caching, and updating server state <span class="No-Break">in React.</span></p>
<p>In this section, I’ll show you how React allows us to handle state in a component and what we should do if we need to share state <span class="No-Break">between components.</span></p>
<p>Let’s consider the <span class="No-Break">following scenario.</span></p>
<p>I want to build an application that allows me to count something. In this application, I want to be able to do <span class="No-Break">the following:</span></p>
<ul>
<li>See the current <span class="No-Break">counter value</span></li>
<li>Increment <span class="No-Break">my counter</span></li>
<li>Decrement <span class="No-Break">my counter</span></li>
<li>Reset <span class="No-Break">the counter</span></li>
</ul>
<p>Let’s imagine that we have a React component <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">App</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const App = () =&gt; {
  ...
  return (
    &lt;div className="App"&gt;
      &lt;div&gt;Counter: {<strong class="bold">count</strong>}&lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={<strong class="bold">increment</strong>}&gt;+1&lt;/button&gt;
        &lt;button onClick={<strong class="bold">decrement</strong>}&gt;-1&lt;/button&gt;
        &lt;button onClick={<strong class="bold">reset</strong>}&gt;Reset&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;</pre>
<p>This app provides the UI needed to handle our counter needs, such as a <strong class="source-inline">div</strong> that we should use <a id="_idIndexMarker010"/>to display our <strong class="source-inline">count</strong> and three buttons with an <strong class="source-inline">onClick</strong> event <a id="_idIndexMarker011"/>waiting for a callback function to perform each of the following <span class="No-Break">actions needed.</span></p>
<p>We are just missing the heart of this component, which is the state. Natively, React gives us two ways to hold state in our applications: <strong class="source-inline">useState</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break">.</span></p>
<p>Let’s start by looking <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">useState</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor030"/>Managing state with useState</h2>
<p><strong class="source-inline">useState</strong> is a <a id="_idIndexMarker012"/>React Hook that allows you to hold a stateful <a id="_idIndexMarker013"/>value. When calling this hook, it will return the stateful value and a function to <span class="No-Break">update it.</span></p>
<p>Let’s look at an example of how to leverage <strong class="source-inline">useState</strong> to build the <span class="No-Break">counter<a id="_idTextAnchor031"/><a id="_idTextAnchor032"/> application:</span></p>
<pre class="source-code">
const App = () =&gt; {
<strong class="bold">  const [count, setCount] = useState(0);</strong>
  const increment = () =&gt; <strong class="bold">setCount((currentCount) =&gt;</strong>
<strong class="bold">    currentCount + 1)</strong>;
  const decrement = () =&gt; <strong class="bold">setCount((currentCount) =&gt;</strong>
<strong class="bold">    currentCount - 1);</strong>
  const reset = () =&gt; <strong class="bold">setCount(0);</strong>
  return (
    &lt;div className="App"&gt;
      &lt;div&gt;Counter: {count}&lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={increment}&gt;+1&lt;/button&gt;
        &lt;button onClick={decrement}&gt;-1&lt;/button&gt;
        &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</pre>
<p>The preceding snippet leverages the <strong class="source-inline">useState</strong> hook to hold our counter state. When we first call <strong class="source-inline">useState</strong>, two things <span class="No-Break">are done:</span></p>
<ul>
<li>The state value is initiated <span class="No-Break">as 0</span></li>
<li>The <strong class="source-inline">count</strong> state variable is destructured; then, the same is done to the state updater function, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">setCount</strong></span></li>
</ul>
<p>After this, we <a id="_idIndexMarker014"/>declare functions where we use the state updater <a id="_idIndexMarker015"/>function, <strong class="source-inline">setCount</strong>, to either increment, decrement, or reset our <a id="_idTextAnchor033"/><a id="_idTextAnchor034"/><span class="No-Break">state variable.</span></p>
<p>Finally, we assign our state variable to the respective UI section and pass the callbacks to our buttons’ <span class="No-Break"><strong class="source-inline">onClick</strong></span><span class="No-Break"> events.</span></p>
<p>With that, we have built a simple counter application. Our application will start rendering our count as 0. Every time we click on the buttons, it will execute the respective state update, re-render our application, and display the new <span class="No-Break">count value.</span></p>
<p><strong class="source-inline">useState</strong> is the answer most of the time when you need any state in your React applications. Just <a id="_idIndexMarker016"/>don’t forget to apply the “<em class="it lic">what will I store in my state?</em>” rule <a id="_idIndexMarker017"/>of <span class="No-Break">thumb before!</span></p>
<p>Now, let’s see an example of how to manage state and build the same counter application by using the <span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break"> hook.</span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor035"/>Managing state with useReducer</h2>
<p><strong class="source-inline">useReducer</strong> is the <a id="_idIndexMarker018"/>preferred option when we have a more <a id="_idIndexMarker019"/>complex state. Before using the hook, we need to do some setup so that we have everything we need to send to our <span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break"> hook:</span></p>
<pre class="source-code">
const initialState = { count: 0 };
const types = {
  INCREMENT: "increment",
  DECREMENT: "decrement",
  RESET: "reset",
};
const reducer = (state, action) =&gt; {
  switch (action) {
    case types.INCREMENT:
      return { count: state.count + 1 };
    case types.DECREMENT:
      return { count: state.count - 1 };
    case types.RESET:
      return { count: 0 };
    default:
      throw new Error("This type does not exist");
  }
};</pre>
<p>In the preceding snippet, we created <span class="No-Break">three things:</span></p>
<ul>
<li>An <strong class="source-inline">initialState</strong> object. This object has a property count with <strong class="source-inline">0</strong> as <span class="No-Break">its value.</span></li>
<li>A <strong class="source-inline">types</strong> object that describes all the action types we <span class="No-Break">will support.</span></li>
<li>A <strong class="bold">reducer</strong>. This reducer is responsible <a id="_idIndexMarker020"/>for receiving our state and action. By matching <a id="_idIndexMarker021"/>that action with the expected <a id="_idIndexMarker022"/>type, we’ll be able to update <span class="No-Break">the state.</span></li>
</ul>
<p>Now that the setup is done, let’s create <span class="No-Break">our counter:</span></p>
<pre class="source-code">
const AppWithReducer = () =&gt; {
<strong class="bold">  const [state, dispatch] = useReducer(reducer,</strong>
<strong class="bold">    initialState);</strong>
  const increment = () =&gt; <strong class="bold">dispatch(types.INCREMENT)</strong>;
  const decrement = () =&gt; <strong class="bold">dispatch(types.DECREMENT)</strong>;
  const reset = () =&gt; <strong class="bold">dispatch(types.RESET)</strong>;
  return (
    &lt;div className="App"&gt;
      &lt;div&gt;Counter: {<strong class="bold">state.count</strong>}&lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={increment}&gt;+1&lt;/button&gt;
        &lt;button onClick={decrement}&gt;-1&lt;/button&gt;
        &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</pre>
<p>The preceding snippet leverages the <strong class="source-inline">useReducer</strong> hook to hold our counter state. When we first call <strong class="source-inline">useReducer</strong>, three things <span class="No-Break">are done:</span></p>
<ul>
<li>We indicate to our hook what<a id="_idTextAnchor036"/><a id="_idTextAnchor037"/> <strong class="source-inline">reducer</strong> should <span class="No-Break">be used</span></li>
<li>We initialize our state with the <span class="No-Break"><strong class="source-inline">initialState</strong></span><span class="No-Break"> object</span></li>
<li>We destructure the <strong class="source-inline">state</strong> object and then the <strong class="source-inline">dispatch</strong> function, which allows us to dispatch an action from the <span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break"> hook</span></li>
</ul>
<p>After this, we <a id="_idIndexMarker023"/>create the functions that will be responsible <a id="_idIndexMarker024"/>for calling the <strong class="source-inline">dispatch</strong> function with the <span class="No-Break">expected action.</span></p>
<p>Finally, we assign our state variable to the respective UI section and pass the callbacks to our buttons’ <span class="No-Break"><strong class="source-inline">onClick</strong></span><span class="No-Break"> events.</span></p>
<p>With these two <em class="it lic">hooks</em> under your belt, you now know how to manage state in <span class="No-Break">your components.</span></p>
<p>Now, let’s picture the following scenario: what if you need your counter state to be accessible in <span class="No-Break">other components?</span></p>
<p>You could pass them by props. But what if this state needs to be sent to five other components and different levels on the tree? Would you be prop-drilling it and passing it to <span class="No-Break">every component?</span></p>
<p>To deal with this scenario and improve your code readability, <strong class="bold">Re<a id="_idTextAnchor038"/><a id="_idTextAnchor039"/>act Context</strong> <span class="No-Break">was created.</span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor040"/>Sharing state with React Context</h2>
<p>Context allows <a id="_idIndexMarker025"/>you to natively share values between <a id="_idIndexMarker026"/>components without having to prop drill them. Let’s learn how to build a context to handle <span class="No-Break">our counter:</span></p>
<pre class="source-code">
import { useState, createContext } from "react";
export const CountContext = <strong class="bold">createContext()</strong>;
export const CountStore = () =&gt; {
  const [count,<a id="_idTextAnchor041"/> s<a id="_idTextAnchor042"/><a id="_idTextAnchor043"/><a id="_idTextAnchor044"/><a id="_idTextAnchor045"/><a id="_idTextAnchor046"/>etCount] = useState(0);
  const increment = () =&gt; setCount((currentCount) =&gt;
    currentCount + 1);
  const decrement = () =&gt; setCount((currentCount) =&gt;
    currentCount - 1);
  const reset = () =&gt; setCount(0);
  return {
    count,
    increment,
    decrement,
    reset,
  };
};
<strong class="bold">const CountProvider = (children) =&gt; {</strong>
<strong class="bold">  return &lt;CountContext.Provider value={CountStore()}</strong>
<strong class="bold">    {...children} /&gt;;</strong>
<strong class="bold">};</strong>
export default CountProvider;</pre>
<p>In the preceding snippet, we are doing <span class="No-Break">three things:</span></p>
<ul>
<li>Using the <strong class="source-inline">createContext</strong> function to create <span class="No-Break">our context.</span></li>
<li>Creating a <strong class="bold">store</strong>. This store will be responsible for holding our state. Here, you can see we leverage the <strong class="source-inline">useState</strong> hook. At the end of the store, we return an object that contains the functions to do the state updates and create our <span class="No-Break">state variable.</span></li>
<li>Creating a <strong class="source-inline">CountProvider</strong>. This provider is responsible for creating a provider that <a id="_idIndexMarker027"/>will be used to wrap a component. This <a id="_idIndexMarker028"/>will allow every component that is inside of that provider to access our <span class="No-Break"><strong class="source-inline">CountStore</strong></span><span class="No-Break"> values.</span></li>
</ul>
<p>Once this setup has been done, we need to make sure our components can access <span class="No-Break">our context:</span></p>
<pre class="source-code">
root.render(
<strong class="bold">  &lt;CountProvider&gt;</strong>
    &lt;App /&gt;
<strong class="bold">  &lt;/CountProvider&gt;</strong>
);</pre>
<p>The preceding snippet leverages <strong class="source-inline">CountProvider</strong>, which we created in the <em class="it lic">previous snippet</em>, to wrap up our <strong class="source-inline">App</strong> component. This allows every component inside <strong class="source-inline">App</strong> to consume <span class="No-Break">our context:</span></p>
<pre class="source-code">
import { CountContext } from "./CountContext/CountContext";
const AppWithContext = () =&gt; {
<strong class="bold">  const { count, increment, decrement, reset } =</strong>
<strong class="bold">    useContext(CountContext);</strong>
  return (
    &lt;div className="App"&gt;
      &lt;div&gt;Counter: {count}&lt;/div&gt;
      &lt;div&gt;
        &lt;button onClick={increment}&gt;+1&lt;/button&gt;
        &lt;button onClick={decrement}&gt;-1&lt;/button&gt;
        &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</pre>
<p>Finally, in this snippet, we leverage the <strong class="source-inline">useContext</strong> hook to consume our <strong class="source-inline">CountContext</strong>. Since our component is rendered inside our custom provider, we can access the state held inside <span class="No-Break">our context.</span></p>
<p>Every time the state updates inside of our context, React will make sure that every component that <a id="_idIndexMarker029"/>is consuming our context will re-render, as well <a id="_idIndexMarker030"/>as receive the state updates. This can often lead to unnecessary re-renders because if you are consuming only a variable from the state and for some reason another variable changes, then the context will force all consumers <span class="No-Break">to re-render.</span></p>
<p>One of the downsides of context is that often, unrelated logic tends to get grouped. As you can see from the preceding snippets, it comes at the cost of a bit of <span class="No-Break">boilerplate code.</span></p>
<p>Now, Context is still great, and it’s how React enables you to share state between components. However, it was not always around, so the community had to come up with ideas on how to enable state sharing. To do so, state management libraries <span class="No-Break">were created.</span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor047"/>What do different state management libraries have in common?</h1>
<p>One of the freedoms React offers you is that it does not impose any standards or practices for <a id="_idIndexMarker031"/>your development. While this is great, it also leads to different practices <span class="No-Break">and implementations.</span></p>
<p>To make this easier and give developers some structure, state management libraries <span class="No-Break">were created:</span></p>
<ul>
<li><strong class="bold">Redux</strong> promotes an approach focused on stores, reducers, and selectors. This leads to needing to <a id="_idIndexMarker032"/>learn specific concepts and filling your project with a bunch of boilerplate code that might impact the code’s readability and increase <span class="No-Break">code complexity.</span></li>
<li><strong class="bold">Zustand</strong> promotes a custom hook approach where each hook holds your state. This is by far <a id="_idIndexMarker033"/>the simplest solution and currently my favorite one. It synergizes with React and fully <span class="No-Break">embraces hooks.</span></li>
<li><strong class="bold">MobX</strong> doesn’t impose an architecture but focuses on a functional reactive approach. This leads <a id="_idIndexMarker034"/>to more specific concepts, and the diversity of practices can lead the developer to run into the same struggles of code structure that they might already suffer from <span class="No-Break">with React.</span></li>
</ul>
<p>One common thing in all these libraries is that all of them are trying to solve the same type of issues that we tried to solve with React Context: <em class="it lic">a way to manage our </em><span class="No-Break"><em class="it lic">shared state</em></span><span class="No-Break">.</span></p>
<p>The state that is accessible to multiple components inside a React tree is often called global state. Now, global state is often misunderstood, which leads to the addition of unnecessary <a id="_idIndexMarker035"/>complexity to your code and often needing to resort to the libraries mentioned in <span class="No-Break">this section.</span></p>
<p>At the end of the day, each developer and team have their preferences and choices. Considering React gives you the freedom to handle your state however you want, you must consider all the advantages and disadvantages of each solution before making your choice. Migrating from one to another can take a lot of time and completely change the paradigm of how state is handled in your application, so choose wisely and take <span class="No-Break">your time.</span></p>
<p>While global state <a id="_idIndexMarker036"/>is not the reason why React Query was built, it has an impact on its creation. The way global state is often composed led to the need to manage a specific part of it that has <a id="_idIndexMarker037"/>many challenges. This specific <a id="_idIndexMarker038"/>part is called server state and the way it was historically handled paved the way to motivate Tanner Linsley to create <span class="No-Break">React Query.</span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor048"/>Summary</h1>
<p>In this chapter, we became familiar with the concept of state. By now, you should understand the importance of state as the heart of React applications and know how you can manage it natively with the help of <strong class="source-inline">useState</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">useReducer</strong></span><span class="No-Break">.</span></p>
<p>You learned that sometimes, you need to share your state with multiple components and that you can do it with Context or by leveraging a third-party state management library. Each of these solutions has its pros and cons, and at the end of the day, it will be a question of <span class="No-Break">developer preference.</span></p>
<p>In <a href="B18501_02.xhtml#_idTextAnchor049"><span class="No-Break"><em class="it lic">Chapter 2</em></span></a>, <em class="it lic">Server State versus Client State</em>, you will understand more about global state, and you find out that often, our global state is a combination of both server and client state. You will learn what these terms mean, how to identify these states, and what the common challenges associated with <span class="No-Break">them are.</span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer009">
</div>
</div>
</div></body></html>