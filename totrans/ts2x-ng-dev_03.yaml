- en: Typescript Native Types and Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 本地类型和功能
- en: 'You have seen different kinds of examples of using TypeScript. Hopefully, you
    now know what TypeScript can offer you as a developer. There are still some TypeScript
    core concepts to learn before hopping right into using it to build Angular 2 apps.
    This chapter will cover the following TypeScript concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了使用 TypeScript 的不同示例。希望你现在知道 TypeScript 作为开发者能为你提供什么。在使用 TypeScript 构建
    Angular 2 应用之前，还有一些 TypeScript 核心概念需要学习。本章将涵盖以下 TypeScript 概念：
- en: Basic types, such as strings, numbers, Boolean, arrays, void, and so on
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型，如字符串、数字、布尔、数组、void 等
- en: Function types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型
- en: Interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Decorators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Basic types
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: Let's revisit the basic types. Most of the types that we will be discussing
    are familiar to you from JavaScript, but it's nice to have a refresher session
    to better appreciate what TypeScript offers. Some of the types, on the other hand,
    are not available in JavaScript but are TypeScript-specific.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下基本类型。我们将讨论的大多数类型对你来说都很熟悉，因为它们来自 JavaScript，但有一个复习课程来更好地欣赏 TypeScript
    提供的功能是很好的。另一方面，有些类型在 JavaScript 中不可用，但 TypeScript 有特定的类型。
- en: Strings
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are available in both JavaScript and TypeScript. They are used to represent
    textual data. This data appears in programs as string literals. These literals
    are easily identified in most programming languages because of the wrapping double
    quotes (`""`).  In JavaScript (and TypeScript), the literals are represented with
    both double quotes (`""`) and single quotes (`''''`):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串在 JavaScript 和 TypeScript 中都可用。它们用于表示文本数据。这些数据以字符串字面量的形式出现在程序中。这些字面量在大多数编程语言中很容易识别，因为它们被双引号（`""`）包围。在
    JavaScript（和 TypeScript）中，字面量用双引号（`""`）和单引号（`''`）表示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding snippet, the `text` variable stores this string: `"Hi, I am
    a string. Now you know!"`. Because TypeScript supports the latest features of
    JavaScript, you can use the new ES6 template literal:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`text` 变量存储了这个字符串：`"Hi, I am a string. Now you know!"`。因为 TypeScript
    支持最新的 JavaScript 功能，所以你可以使用新的 ES6 模板字面量：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Numbers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Numbers are available in JavaScript and TypeScript.Numbers represent floating
    numbers in JavaScript. You feed them right in with the keyboard, without any decoration
    like we had to do for strings:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数字在 JavaScript 和 TypeScript 中都可用。在 JavaScript 中，数字代表浮点数。你可以直接用键盘输入它们，而不需要像字符串那样进行任何装饰：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Boolean
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boolean
- en: 'The Boolean type is available in JavaScript and TypeScript**. **Booleans are
    the simplest types you will ever meet in a programming language. They answer the
    question with yes or no, which is represented in JavaScript as `true` or `false`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型在 JavaScript 和 TypeScript 中都可用**。**布尔类型是你在编程语言中会遇到的最简单的类型。它们用 yes 或 no 回答问题，在
    JavaScript 中表示为 `true` 或 `false`：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Arrays
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are available in both JavaScript and TypeScript**. **Data structures
    in JavaScript are basically represented with objects and arrays. Objects are key-value
    pairs while arrays have an indexable structure. There is no `array` type,  rather
    you provide types for the items that are contained in an array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在 JavaScript 和 TypeScript 中都可用**。**JavaScript 中的数据结构基本上用对象和数组表示。对象是键值对，而数组有可索引的结构。没有
    `array` 类型，而是你为数组中包含的项提供类型。
- en: 'You have two options for doing this. You can use the `[]` symbol pair, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个选择来做这件事。你可以使用 `[]` 符号对，如下所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, you can use the built-in generic type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用内置的泛型类型：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Void
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Void
- en: 'Void is available *only *in TypeScript**. **The `void` type is applicable to
    functions'' return types (we will discuss this soon). Void indicates that a function
    is not expected to return anything:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Void 只在 TypeScript 中可用**。**`void` 类型适用于函数的返回类型（我们很快会讨论这个问题）。Void 表示函数不应该返回任何内容：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Any
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Any
- en: Any is available *only *in TypeScript**.** The`any` type is the most flexible
    type. It allows you to get closer to the loose nature of JavaScript when there
    is a need for it. Such needs could arise from third-party libraries that are not
    typed and if you don't know which value type may be returned from a property or
    method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 只在 TypeScript 中可用**。**`any` 类型是最灵活的类型。当需要更接近 JavaScript 的宽松性质时，它允许你这样做。这种需求可能来自未类型化的第三方库，或者如果你不知道属性或方法可能返回哪种值类型。'
- en: 'This type can store all the known JavaScript types:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型可以存储所有已知的 JavaScript 类型：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tuple
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are available *only *in TypeScript**. **They allow you to have varying
    types in an array. Tuples come with the implication that the fixed number of elements
    in an array must be defined while creating the type. For example, if we need an
    array of `string`, `number`, and `boolean`, it will look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 元组仅在 TypeScript 中可用**。**它们允许你在数组中拥有不同的类型。元组意味着数组中固定数量的元素在创建类型时必须被定义。例如，如果我们需要一个包含`string`、`number`和`boolean`的数组，它将看起来像这样：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you try to access an index that was not initially created, the new index
    is added with the appropriate inferred type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试访问一个最初未创建的索引时，新的索引会以适当的推断类型添加：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Enums
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Enums are available *only *in TypeScript**.** On a few occasions, you may simply
    want to store a set of numbers, serially or not. Enums hand you a numeric data
    structure control without having to drag in the complexities of arrays or objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举仅在 TypeScript 中可用**。**在少数情况下，你可能只想存储一组数字，可以是顺序的，也可以不是。枚举为你提供了一个数值数据结构控制，而无需引入数组或对象的复杂性。
- en: 'The following example shows an `enum` type with numbers from `0` to `2`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个从`0`到`2`的`enum`类型：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Enums are `0`-based; therefore, `Started` holds `0`, `InProgress` holds `1`,
    and `Completed` holds `2`. In addition, enums are flexible; hence, you can provide
    a number for the starting point instead of `0`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是基于`0`的；因此，`Started`持有`0`，`InProgress`持有`1`，`Completed`持有`2`。此外，枚举是灵活的；因此，你可以提供一个起始数字而不是`0`：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can write more expressive code with Enums. Let''s see how, by using percentage
    values for the status in the preceding example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用枚举编写更具有表达性的代码。让我们通过使用前一个示例中的百分比值来查看状态，看看如何做到这一点：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It''s easy to find out the name of the value if you know the actual value:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道实际值，很容易找到值的名称：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Functions and function types
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和函数类型
- en: 'JavaScript functions are loosely typed and are some of the most common sources
    of errors in the language. This is what a basic function looks like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数是弱类型化的，并且是语言中最常见的错误来源之一。这是一个基本函数的样子：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How sure are we that `char` is not a number? Well, we might not have any control
    over what the developer consuming `stringToArray` will pass in. This is why we
    need to be strict about the value types using TypeScript.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多确定`char`不是一个数字？好吧，我们可能无法控制使用`stringToArray`的开发者会传递什么。这就是为什么我们需要使用 TypeScript
    对值类型进行严格限制。
- en: 'Functions use types in two different parts of their declaration:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在其声明的两个不同部分使用类型：
- en: Function parameters
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数参数
- en: Function return value
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数返回值
- en: Function parameters
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'You can tell TypeScript what type of values a function should expect, and it
    will strictly adhere to it. The following example shows a function that receives
    a typed string and a number as its parameters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以告诉 TypeScript 函数应该期望哪种类型的值，并且它将严格遵循这一点。以下是一个接收类型化字符串和数字作为参数的函数示例：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `char` and `index` parameters have the `string` and `number` types, respectively.
    Even before things get to the browser, TypeScript will alert you when you try
    something silly:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`和`index`参数分别具有`string`和`number`类型。即使在事情到达浏览器之前，TypeScript 也会在你尝试愚蠢的事情时提醒你：'
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Of course, function expressions are not left out:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数表达式也不会被遗漏：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Moreover, arrow functions are welcome too:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，箭头函数也受到欢迎：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Function return value
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数返回值
- en: 'The value expected from a function when it is executed can also be strictly
    typed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数执行时预期的值也可以是严格类型化的：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see from the preceding code snippet, the return type comes after
    the brackets containing the parameters and before the opening curly bracket of
    the function's body. The preceding function is expected to, and must, return a
    string. Anything other than a string will scream at you with errors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中可以看到，返回类型位于包含参数的括号之后和函数体开括号之前。前面的函数预期并必须返回一个字符串。任何非字符串的内容都会以错误的形式向您尖叫。
- en: Optional parameters
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选参数
- en: When a function's parameter is strictly typed, it feels rigid when the function
    needs to be flexible. Why should we pass in `index` to our previous example in
    a situation where we intend to return the whole string if the index is missing?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数的参数是严格类型时，如果函数需要灵活，就会感觉比较僵硬。为什么在索引缺失时，我们还要在我们的前一个例子中传递`index`呢？如果我们打算在没有索引的情况下返回整个字符串呢？
- en: 'When the index parameter is omitted while calling the function, TypeScript
    will throw an error. To overcome this issue, we can declare the `index` parameter
    as optional:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时省略索引参数，TypeScript 将抛出错误。为了解决这个问题，我们可以将 `index` 参数声明为可选的：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The question mark succeeding the parameter name tells TypeScript that it's okay
    if the parameter is missing when called. Be careful to handle such cases of parameters
    not being supplied in the function body, as shown in the preceding example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名后面的问号告诉 TypeScript，如果调用时参数缺失是可以的。请小心处理函数体中未提供参数的情况，如前例所示。
- en: Interfaces
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are contracts that our code adheres too. It's an agreement that data
    structures must follow. This helps every data/logic implementing an interface
    stay safe from improper or non-matching types. It also validates the types and
    availability of values passed in.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是我们代码遵守的合同。这是一个数据结构必须遵循的协议。这有助于每个实现接口的数据/逻辑保持安全，避免不适当或不匹配的类型。它还验证了传入值的类型和可用性。
- en: 'In TypeScript, interfaces are used for the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，接口用于以下目的：
- en: Creating types for JavaScript objects.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 JavaScript 对象创建类型。
- en: Setting up contracts for classes to adhere to.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为类设置遵守的合同。
- en: We will discuss how interfaces are applied in the scenarios we just listed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论接口如何在上述场景中应用。
- en: Interfaces for JavaScript object types
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 对象类型的接口
- en: 'We agree that the following is a valid JavaScript object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同意以下是一个有效的 JavaScript 对象：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is a valid JavaScript code but loosely typed. All this while, we have been
    discussing strings, numbers, Boolean, and even arrays. We are yet to consider
    objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段有效的 JavaScript 代码，但类型松散。到目前为止，我们一直在讨论字符串、数字、布尔值，甚至数组。我们还没有考虑对象。
- en: 'As you may have imagined, the following code snippet demonstrates a typed version
    of the preceding example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象的那样，以下代码片段演示了前面示例的已类型化版本：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is correct in fact, but TypeScript could use interfaces to make it more
    maintainable and easy to comprehend. The following is how we write interfaces
    in TypeScript:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是正确的，但 TypeScript 可以使用接口使其更易于维护和易于理解。以下是在 TypeScript 中编写接口的方式：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What you can then do is make the `options` variable of the `OptionBag` type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以这样做的是将 `OptionBag` 类型的 `options` 变量：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Optional properties
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选属性
- en: One thing about interfaces, though, is that the defined properties/methods of
    an interface must be supplied when creating the values that are typed with that
    interface. Basically, I am saying that we must adhere strictly to the contract
    established with an interface.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于接口，有一点需要注意的是，接口中定义的属性/方法在创建使用该接口类型化的值时必须提供。基本上，我是在说我们必须严格遵循与接口建立的合同。
- en: 'Therefore, the following is incorrect and will throw an error:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是不正确的，并且会抛出错误：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can make `container` optional; we use the question mark literal, as seen
    in a previous example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使 `container` 可选；我们使用前例中看到的问号字面量：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Be careful, though, to account for when the optional parameter is not supplied.
    The following is an example that does so:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，当可选参数未提供时的情况。以下是一个示例，展示了这种情况：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Read-only properties
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读属性
- en: 'Another typical situation is when you have properties to which you intend to
    assign values only once, just like we do with the ES6 `const` declaration keyword.
    You can mark the values as `readonly`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个典型的情况是，当你有只打算赋值一次的属性时，就像我们使用 ES6 的 `const` 声明关键字那样。您可以标记这些值为 `readonly`：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Interfaces as contracts
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口作为合同
- en: You can ensure that a class adheres to a particular contract using interfaces.
    I use the term contract in the sense that all the properties and methods defined
    in the interface must be implemented in the class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用接口确保一个类遵循特定的合同。我使用术语合同是指接口中定义的所有属性和方法都必须在类中实现。
- en: 'Let''s assume that we have the following `Note` interface:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下 `Note` 接口：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To implement the interface using a class, we add the `implements` keyword after
    the class name followed by the interface we are implementing:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用类实现接口，我们在类名后添加 `implements` 关键字，后跟我们要实现的接口：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Interfaces do not only define the signatures for properties but they also accept
    function types as methods:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接口不仅定义了属性的签名，还接受函数类型作为方法：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This could be implemented by a class in the following way:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下方式通过一个类来实现：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: TypeScript will throw an error if neither the `wordCount` property nor the `updateCount` method
    exists in the `NoteTaker` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `NoteTaker` 类中既不存在 `wordCount` 属性也不存在 `updateCount` 方法，TypeScript 将会抛出一个错误。
- en: Decorators
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'The most common feature introduced in Angular 2+ is **decorators**. Decorators,
    at first glance, are confusing because of the unusual `@` sign preceding their
    usage:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 2+ 中引入的最常见特性是**装饰器**。乍一看，装饰器可能会因为其使用前不寻常的 `@` 符号而让人困惑：
- en: '![](img/f2d6b017-9e35-49d8-9d9e-85f6a967d310.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2d6b017-9e35-49d8-9d9e-85f6a967d310.png)'
- en: The preceding screenshot is a code snippet from an Angular application. It shows
    a component decorator decorating a class called `AppComponent`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图是从一个 Angular 应用程序中提取的代码片段。它显示了一个组件装饰器正在装饰一个名为 `AppComponent` 的类。
- en: At first, this might look overwhelming because, in the history of JavaScript,
    I have never seen the `@` literal used this way. If only we knew it was just a
    function that had access to the members of what it is decorating! Classes, properties,
    methods, and accessors are all allowed to be decorated. Let's discuss how to decorate
    methods and classes
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，这可能会看起来令人不知所措，因为在 JavaScript 的历史中，我从未见过 `@` 文字以这种方式使用。如果我们知道它只是一个可以访问它所装饰成员的函数就好了！类、属性、方法和访问器都可以被装饰。让我们讨论如何装饰方法和类
- en: Decorating methods
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰方法
- en: 'Let''s assume that we want to make a method on a class read-only. Therefore,
    after creating the method, it cannot be overridden for any reason. For example,
    this is what the method looks like:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将类上的一个方法设置为只读。因此，在创建该方法之后，它不能因为任何原因被重写。例如，这个方法看起来是这样的：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we do not want to override `error` in the application''s lifecycle, we could
    write a decorator to set the descriptor''s `writable` property to `false`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在应用程序的生命周期中覆盖 `error`，我们可以编写一个装饰器来将描述符的 `writable` 属性设置为 `false`：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The common signature is that a method decorator takes the same parameters as
    `Object.defineProperty`. In such a case, the target will be the class, the key
    will be the method name, which is a property of the class, and the descriptor
    will be the `config` object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的签名是方法装饰器接受与 `Object.defineProperty` 相同的参数。在这种情况下，目标将是类，键将是方法名，它是类的一个属性，描述符将是
    `config` 对象。
- en: 'We can now decorate the `error` method with the just created `readonly` decorator:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用刚刚创建的 `readonly` 装饰器来装饰 `error` 方法：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Any attempt to mutate the error property will fail:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试修改错误属性的行为都将失败：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Decorating classes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰类
- en: Another commonly decorated member is the class. In fact, in Angular, almost
    all classes (components, services, modules, filters, and directives) are decorated.
    This is why it is important to understand the importance of the existence of decorators.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的装饰成员是类。实际上，在 Angular 中，几乎所有的类（组件、服务、模块、过滤器以及指令）都被装饰了。这就是为什么理解装饰器存在的重要性很重要的原因。
- en: 'Decorators can be used to extend the features of a class, as shown in the following
    example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可以用来扩展类的功能，如下面的例子所示：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Decorator factories
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器工厂
- en: The preceding example is rigid because the `options` object will always have
    the same value. What if we needed to receive dynamic values? Of course, that's
    a valid question to ask because the `id` property may not always be `#main`. Therefore,
    we need to be more flexible.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子是固定的，因为 `options` 对象将始终具有相同的值。如果我们需要接收动态值怎么办？当然，这是一个合理的问题，因为 `id` 属性可能并不总是
    `#main`。因此，我们需要更加灵活。
- en: 'Decorator factories are functions that return a decorator, giving you the power
    to pass in arguments for the decorator via its factory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器工厂是返回装饰器的函数，这让你能够通过其工厂传递参数给装饰器：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We spent time in the first three chapters discussing TypeScript fundamentals
    with the intention that while walking through the rest of the chapters (which
    are filled with a lot of Angular stuff), TypeScript will be something you don't
    have to worry about.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三章中，我们花费时间讨论 TypeScript 的基础知识，目的是在浏览其余章节（其中充满了大量的 Angular 内容）时，TypeScript
    将不会成为你需要担心的东西。
- en: It is fine to assume that the basic types, function types, decorators, and interfaces
    have been added to your existing knowledge of TypeScript.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经将基本类型、函数类型、装饰器和接口添加到了你对 TypeScript 的现有知识中。
- en: In the coming chapters of this book, we will soak ourselves in Angular. If you
    have come this far, then you made it through the boring parts of this book because,
    henceforth, we will be building a lot of fun examples with Angular 2+.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将深入探索 Angular。如果你已经走到这一步，那么你已经成功通过了本书的枯燥部分，因为从现在开始，我们将使用 Angular
    2+ 构建许多有趣的示例。
