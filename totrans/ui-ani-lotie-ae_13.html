<html><head></head><body>
		<div id="_idContainer272">
			<h1 id="_idParaDest-174"><em class="italic"><a id="_idTextAnchor175"/>Chapter 10</em>: How To Nail It: Controlling Your Animation</h1>
			<p>At this point, we have a fully functional animation in our React Native app that starts playing as a loop when it is mounted and stops when unmounted. But what if we want to control the playback of the animation? Let's give an example: we need to display the animation of a loading bar while we sequentially download five different files into our app. The loading bar will show the progress of the downloading files by filling itself (20% more each time a file is downloaded), resulting in a fully filled bar once those five files have been downloaded.</p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/B17930_10_01.jpg" alt="Figure 10.1 – Animated loading bar used as an example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Animated loading bar used as an example</p>
			<p>In this case, we need to control the animation, updating it every time a file has been fully downloaded and stopping it while the next download is in progress.</p>
			<p>To explain how this process works in <strong class="source-inline">lottie-react-native</strong>, we will review two different alternatives: the declarative and the imperative APIs. By the end of this chapter, we will know not only how to render Lottie animations in our React Native apps but we will be able to control their playback and layout.</p>
			<p>To explain how this process works in <strong class="source-inline">lottie-react-native</strong>, we will review different alternatives:</p>
			<ul>
				<li>The declarative API</li>
				<li>The imperative API</li>
			</ul>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor176"/>Technical requirements</h1>
			<p>To complete this chapter, we have to have a functioning React Native app running on a simulator or device. We will modify this app to include a <strong class="source-inline">LottieView</strong> component as we learned in previous chapters so we can modify and control the animation through methods and properties.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor177"/>The declarative API</h1>
			<p>The most<a id="_idIndexMarker579"/> frequent explanation for the distinction between imperative and declarative programming is that imperative code instructs the computer on how to perform tasks, whereas declarative code concentrates on what you want the computer to do. </p>
			<p>Your code in imperative programming is made up of statements that affect the program's state by instructing the computer what to do. To put it another way, your code is built around defining variables and altering their values.</p>
			<p>Your code in declarative programming is made up of expressions that evaluate their output based on their input by telling the machine what you want.</p>
			<p>React was designed following the declarative paradigm, although it allows you to control some components the imperative way when needed. So <a id="_idIndexMarker580"/>does <strong class="source-inline">lottie-react-native</strong> as it provides different APIs for imperative or declarative control on the animations rendered within an app.</p>
			<p>In this section, we will focus on how to control the example animated loading bar with the <strong class="source-inline">lottie-react-native</strong> library's declarative API.</p>
			<p>Here's an example of <a id="_idIndexMarker581"/>how controlling a Lottie animation can be achieved with the declarative API:</p>
			<pre class="source-code">const numFilesToDownload = 5;</pre>
			<pre class="source-code">const duration = 2000;</pre>
			<pre class="source-code">const App = ({downloadedFiles}) =&gt; {</pre>
			<pre class="source-code">  const progress = useMemo(() =&gt; new Animated.Value(0), []); </pre>
			<pre class="source-code">  useEffect(() =&gt; {</pre>
			<pre class="source-code">    Animated.timing(progress, {</pre>
			<pre class="source-code">      toVal4deue: downloadedFiles.length / numFilesToDownload,</pre>
			<pre class="source-code">      duration: duration,</pre>
			<pre class="source-code">      useNativeDriver: true,</pre>
			<pre class="source-code">      easing: Easing.linear,</pre>
			<pre class="source-code">    }).start();</pre>
			<pre class="source-code">  }, [downloadedFiles, progress]);</pre>
			<pre class="source-code">  return (</pre>
			<pre class="source-code">    &lt;SafeAreaView&gt;</pre>
			<pre class="source-code">      &lt;View style={styles.container}&gt;</pre>
			<pre class="source-code">        &lt;LottieView</pre>
			<pre class="source-code">          source={require('./assets/animations/loadingBar.          json')}</pre>
			<pre class="source-code">          progress={progress}</pre>
			<pre class="source-code">        /&gt;</pre>
			<pre class="source-code">      &lt;/View&gt;</pre>
			<pre class="source-code">    &lt;/SafeAreaView&gt;</pre>
			<pre class="source-code">  );</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">export default App;</pre>
			<p>In this <a id="_idIndexMarker582"/>example, our <strong class="source-inline">App</strong> component receives a prop named <strong class="source-inline">downloadedFiles</strong> including the information of the files downloaded by the app. This information can be provided by Redux, MobX, a component wrapping app, or any other way. What's important for the sake of this example is to know that <strong class="source-inline">downloadedFiles</strong> is an array that will increase its size from <strong class="source-inline">0</strong> until the maximum number of files to be downloaded (defined by <strong class="source-inline">const numFilesToDownload = 5;</strong> in the example).</p>
			<p>We are using the Animated API from React Native to hold the progress of the animation: <strong class="source-inline">const progress = useMemo(() =&gt; new Animated.Value(0), []);</strong> . This is an <strong class="source-inline">Animated.Value</strong> that will start from <strong class="source-inline">0</strong> and progressively reach <strong class="source-inline">1</strong>, defining we want <a id="_idIndexMarker583"/>our animation to be complete. We are using <strong class="source-inline">useMemo</strong> here. As <strong class="source-inline">progress</strong> is a variable, we want to update it using React Native's Animated API:</p>
			<pre class="source-code">  useEffect(() =&gt; {</pre>
			<pre class="source-code">    Animated.timing(progress, {</pre>
			<pre class="source-code">      toValue: downloadedFiles.length / numFilesToDownload,</pre>
			<pre class="source-code">      duration: duration,</pre>
			<pre class="source-code">      useNativeDriver: true,</pre>
			<pre class="source-code">      easing: Easing.linear,</pre>
			<pre class="source-code">    }).start();</pre>
			<pre class="source-code">  }, [downloadedFiles, progress]);</pre>
			<p>In this part, we are creating an effect that will update <strong class="source-inline">progress</strong> based on the number of files downloaded (<strong class="source-inline">downloadedFiles.length</strong>) and the number of files to be downloaded (<strong class="source-inline">numFilesToDownload</strong>). With this, we will be pushing the progress bar 20% toward its total every time a new file is downloaded. For example, if we've downloaded 2 of 5 files, <strong class="source-inline">progress</strong> will be set to 0.4, meaning the animation needs to smoothly play until 40% of its total play time.</p>
			<p>We also define the duration for every push of the loading bar in the following line of code: </p>
			<pre class="source-code">const duration = 2000;</pre>
			<p>The most important part in this example is the <strong class="source-inline">LottieView</strong> component:</p>
			<pre class="source-code">        &lt;LottieView</pre>
			<pre class="source-code">          source={require('./assets/animations/loadingBar.          json')}</pre>
			<pre class="source-code">          progress={progress}</pre>
			<pre class="source-code">        /&gt;</pre>
			<p>We use the <strong class="source-inline">progress</strong> prop here so we can declare the progress of the animation <a id="_idIndexMarker584"/>based on an Animated value (<strong class="source-inline">progress</strong>), which depends on the number of files being downloaded at a certain moment.</p>
			<p>We can find all the declarative properties, their descriptions, and default values in the <strong class="source-inline">lottie-react-native</strong> library's README file (<a href="https://github.com/lottie-react-native/lottie-react-native/blob/master/docs/api.md">https://github.com/lottie-react-native/lottie-react-native/blob/master/docs/api.md</a>).</p>
			<p>All of them can be declaratively used on a <strong class="source-inline">LottieView</strong> component to control the rendering and behavior of our Lottie animations. In the next section, we will learn how to control our animations with the imperative API for those cases where we need to explicitly say what to do to our animation instead of reacting to state changes.</p>
			<p>We have already learned how to use some of these properties in our <strong class="source-inline">LottieView</strong> objects. We will now show examples using other important props.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>speed</h2>
			<p>The <strong class="source-inline">speed</strong> property<a id="_idIndexMarker585"/> is a number that sets the speed of the <a id="_idIndexMarker586"/>animation based on how many times the default speed should be played:</p>
			<pre class="source-code">&lt;LottieView </pre>
			<pre class="source-code">    source={require('./assets/animations/myLottieFile.json')} </pre>
			<pre class="source-code">    speed={2} </pre>
			<pre class="source-code">/&gt;</pre>
			<p>The example above will play our animation twice as fast as the original animation speed.</p>
			<pre class="source-code">&lt;LottieView </pre>
			<pre class="source-code">    source={require('./assets/animations/myLottieFile.json')} </pre>
			<pre class="source-code">    speed={-1} </pre>
			<pre class="source-code">/&gt;</pre>
			<p>The example above will play our animation in reverse at the original animation speed. With this in <a id="_idIndexMarker587"/>mind, we could create a loop that renders the animation back and forth every 2 seconds<a id="_idIndexMarker588"/> instead of repeating it over:</p>
			<pre class="source-code">const App = ({}) =&gt; {</pre>
			<pre class="source-code">  const [speed, setSpeed] = useState(1);</pre>
			<pre class="source-code">  const reverseSpeed = useCallback(() =&gt; {</pre>
			<pre class="source-code">    if (speed === 1) {</pre>
			<pre class="source-code">      setSpeed(-1);</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">      setSpeed(1);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }, [speed]);</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">  useEffect(() =&gt; {</pre>
			<pre class="source-code">    setTimeout(() =&gt; {</pre>
			<pre class="source-code">      reverseSpeed();</pre>
			<pre class="source-code">    }, 2000);</pre>
			<pre class="source-code">  }, [reverseSpeed]);</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">  return (</pre>
			<pre class="source-code">    &lt;SafeAreaView&gt;</pre>
			<pre class="source-code">      &lt;View style={styles.container}&gt;</pre>
			<pre class="source-code">        &lt;LottieView</pre>
			<pre class="source-code">          source={require('./assets/animations/loadingBar.          json')}</pre>
			<pre class="source-code">          autoPlay</pre>
			<pre class="source-code">          speed={speed}</pre>
			<pre class="source-code">        /&gt;</pre>
			<pre class="source-code">      &lt;/View&gt;</pre>
			<pre class="source-code">    &lt;/SafeAreaView&gt;</pre>
			<pre class="source-code">  );</pre>
			<pre class="source-code">};</pre>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>onAnimationFinish</h2>
			<p>The <strong class="source-inline">onAnimationFinish</strong> property<a id="_idIndexMarker589"/> is a <a id="_idIndexMarker590"/>callback that will be triggered when the animation completes its playback. We can use it to navigate away to a new screen when the displaying animation finishes its playback:</p>
			<pre class="source-code">const App = ({navigation}) =&gt; {</pre>
			<pre class="source-code">  const onAnimationFinish = useCallback(() =&gt; {</pre>
			<pre class="source-code">    navigation.navigate('NextScreen');</pre>
			<pre class="source-code">  }, []);</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">  return (</pre>
			<pre class="source-code">    &lt;SafeAreaView&gt;</pre>
			<pre class="source-code">      &lt;View style={styles.container}&gt;</pre>
			<pre class="source-code">        &lt;LottieView</pre>
			<pre class="source-code">          source={require('./assets/animations/loadingBar.          json')}</pre>
			<pre class="source-code">          autoPlay</pre>
			<pre class="source-code">          onAnimationFinish={onAnimationFinish}</pre>
			<pre class="source-code">          loop={false}</pre>
			<pre class="source-code">        /&gt;</pre>
			<pre class="source-code">      &lt;/View&gt;</pre>
			<pre class="source-code">    &lt;/SafeAreaView&gt;</pre>
			<pre class="source-code">  );</pre>
			<pre class="source-code">};</pre>
			<p>Note <strong class="source-inline">loop={false}</strong> is necessary for <strong class="source-inline">onAnimationFinish</strong> to work properly as a looped animation<a id="_idIndexMarker591"/> won't ever finish.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>colorFilters</h2>
			<p>The <strong class="source-inline">colorFilters</strong> property<a id="_idIndexMarker592"/> is an <a id="_idIndexMarker593"/>array of objects containing the string-coded hex colors that enables developers to change the colors for specific layers programmatically. For this prop to work properly, the correct keypath (a property set when creating the app in After Effects and stored in the Lottie JSON file) needs to be provided along with the code:</p>
			<pre class="source-code">&lt;LottieView</pre>
			<pre class="source-code">    autoPlay</pre>
			<pre class="source-code">    source={require('./assets/animations/loadingBar.json')}</pre>
			<pre class="source-code">    colorFilters={[</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">        keypath: 'button',</pre>
			<pre class="source-code">        color: '#FF0000',</pre>
			<pre class="source-code">      },</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">        keypath: 'circle',</pre>
			<pre class="source-code">        color: '#00FF00',</pre>
			<pre class="source-code">      },</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">        keypath: 'square',</pre>
			<pre class="source-code">        color: '#0000FF',</pre>
			<pre class="source-code">      },</pre>
			<pre class="source-code">    ]}</pre>
			<pre class="source-code">/&gt;</pre>
			<p>This piece <a id="_idIndexMarker594"/>of code modifies three After Effect layers (<strong class="source-inline">button</strong>, <strong class="source-inline">circle</strong>, and <strong class="source-inline">square</strong>) to change their colors to red (<strong class="source-inline">'#FF0000'</strong>), green (<strong class="source-inline">'#00FF00'</strong>), and blue (<strong class="source-inline">'#0000FF'</strong>) respectively.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/>textFiltersAndroid and textFiltersIOS</h2>
			<p><strong class="source-inline">textFiltersAndroid</strong> and <strong class="source-inline">textFiltersIOS</strong> contain<a id="_idIndexMarker595"/> an<a id="_idIndexMarker596"/> array of objects including<a id="_idIndexMarker597"/> texts to replace so we can programmatically modify<a id="_idIndexMarker598"/> a specific text in the animation. This property is useful when dealing with translations in our apps:</p>
			<pre class="source-code">&lt;LottieView</pre>
			<pre class="source-code">  autoPlay</pre>
			<pre class="source-code">  source={require('./assets/animations/loadingBar.json')}</pre>
			<pre class="source-code">  textFiltersAndroid={[</pre>
			<pre class="source-code">    {find: 'Hello!', replace: 'Hola!'},</pre>
			<pre class="source-code">    {find: 'Bye!', replace: 'Adios!'},</pre>
			<pre class="source-code">  ]}</pre>
			<pre class="source-code">     textFiltersIOS={[</pre>
			<pre class="source-code">    {find: 'Hello!', replace: 'Hola!'},</pre>
			<pre class="source-code">    {find: 'Bye!', replace: 'Adios!'},</pre>
			<pre class="source-code">  ]}</pre>
			<pre class="source-code">/&gt;</pre>
			<p>In this example, we are replacing the text <strong class="source-inline">'Hello!'</strong> with <strong class="source-inline">'Hola!'</strong> and <strong class="source-inline">'Bye!'</strong> with <strong class="source-inline">'Adios!'</strong> in our animation for both iOS and Android devices.</p>
			<p>Now that we have learned how to use the declarative API, let's move on to a different way of interacting with our Lottie animations: the imperative API.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>The imperative API</h1>
			<p>Sometimes, it's just <a id="_idIndexMarker599"/>easier using imperative programming in our app, for example, sometimes we need to play/stop our animation based on user interactions inside the app. For these cases, we can use the <strong class="source-inline">lottie-react-native</strong> library's imperative API, which allows developers to control the animation playback in a very straightforward way.</p>
			<p>React automatically <a id="_idIndexMarker600"/>provides the <strong class="source-inline">ref</strong> prop on all its components and the <strong class="source-inline">useRef</strong> hook to be used whenever we need to control the component in an imperative way.</p>
			<p>The piece of code we wrote in the previous section is actually a good example of how imperative programming makes more sense when we need to directly trigger an action on a component, improving readability and making our code easier to reason about:</p>
			<pre class="source-code">import React, {useEffect, useRef} from 'react';</pre>
			<pre class="source-code">import LottieView from 'lottie-react-native';</pre>
			<pre class="source-code">import {SafeAreaView, View, StyleSheet} from 'react-native';</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">const numFramesPerFile = 9;</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">const App = ({downloadedFiles}) =&gt; {</pre>
			<pre class="source-code">  const animation = useRef(null);</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">  useEffect(() =&gt; {</pre>
			<pre class="source-code">    if (downloadedFiles.length === 0) {</pre>
			<pre class="source-code">      animation.current.reset();</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">      const startFrame = numFramesPerFile * (downloadedFiles.      length - 1);</pre>
			<pre class="source-code">      animation.current.play(startFrame, startFrame +       numFramesPerFile);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }, [downloadedFiles]);</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">  return (</pre>
			<pre class="source-code">    &lt;SafeAreaView&gt;</pre>
			<pre class="source-code">      &lt;View style={styles.container}&gt;</pre>
			<pre class="source-code">        &lt;LottieView</pre>
			<pre class="source-code">          ref={animation}</pre>
			<pre class="source-code">          source={require('./assets/animations/loadingBar.          json')}</pre>
			<pre class="source-code">          loop={false}</pre>
			<pre class="source-code">        /&gt;</pre>
			<pre class="source-code">      &lt;/View&gt;</pre>
			<pre class="source-code">    &lt;/SafeAreaView&gt;</pre>
			<pre class="source-code">  );</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">const styles = StyleSheet.create({</pre>
			<pre class="source-code">  container: {</pre>
			<pre class="source-code">    width: '100%',</pre>
			<pre class="source-code">    height: '100%',</pre>
			<pre class="source-code">    justifyContent: 'center',</pre>
			<pre class="source-code">    alignItems: 'center',</pre>
			<pre class="source-code">  },</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">export default App;</pre>
			<p>For this approach, we need to first identify <a id="_idIndexMarker601"/>how many frames our animation contains and how many frames we need to render once we download each of the files to be downloaded. In this example, we could calculate it in the following way:</p>
			<ol>
				<li>Number of frames contained in the animation: <strong class="source-inline">45</strong></li>
				<li>Number of files to be downloaded: <strong class="source-inline">5</strong></li>
				<li>Number of frames to be played on every file download: <strong class="source-inline">45</strong> / <strong class="source-inline">5</strong> = <strong class="source-inline">9</strong></li>
			</ol>
			<p>Then, we define the calculated number of frames to be played on every file download as a constant in our code: </p>
			<p><strong class="source-inline">const numFramesPerFile = 9;</strong></p>
			<p>Next, we need to create a reference to our <strong class="source-inline">LottieView</strong> component that will enable us to call imperative methods on it. We do this using the <strong class="source-inline">useRef</strong> hook provided by React: </p>
			<p><strong class="source-inline">const animation = useRef(null);</strong></p>
			<p>This reference needs to be passed as the <strong class="source-inline">ref</strong> prop to our <strong class="source-inline">LottieView</strong> component:</p>
			<pre class="source-code">        &lt;LottieView</pre>
			<pre class="source-code">          ref={animation}</pre>
			<pre class="source-code">          source={require('./assets/animations/loadingBar.          json')}</pre>
			<pre class="source-code">          loop={false}</pre>
			<pre class="source-code">        /&gt;</pre>
			<p>We also see how we explicitly pass <strong class="source-inline">loop={false}</strong> so the animation doesn't repeat when we call any imperative playback methods on it.</p>
			<p>Having all this setup ready, we can create an effect that will be triggered on every file download. This effect will use the imperative play method on the referenced component. This play method accepts the initial and the final frames we want to play in the animation. </p>
			<p>We will use <a id="_idIndexMarker602"/>these parameters to reproduce just a part of the animation on every file download:</p>
			<pre class="source-code">  useEffect(() =&gt; {</pre>
			<pre class="source-code">    if (downloadedFiles.length === 0) {</pre>
			<pre class="source-code">      animation.current.reset();</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">      const startFrame = numFramesPerFile * (downloadedFiles.      length - 1);</pre>
			<pre class="source-code">      animation.current.play(startFrame, startFrame +       numFramesPerFile);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }, [downloadedFiles]);</pre>
			<p>When we know how many files the app has downloaded (<strong class="source-inline">downloadedFiles.length</strong>), we can easily calculate what the initial frame will be where the next animation part should start:</p>
			<pre class="source-code">const startFrame = numFramesPerFile * (downloadedFiles.length - 1);</pre>
			<p>Then, we reach the most important part of this code: the part where we use the imperative API to reproduce the animation from the initial frame (<strong class="source-inline">startFrame</strong>) until the final frame (<strong class="source-inline">startFrame + numFramesPerFile</strong>):</p>
			<pre class="source-code">animation.current.play(startFrame, startFrame + numFramesPerFile);</pre>
			<p>Note how we reset the animation if the number of downloaded files is zero, so we make sure we always start <a id="_idIndexMarker603"/>from the initial frame:</p>
			<pre class="source-code">    if (downloadedFiles.length === 0) {</pre>
			<pre class="source-code">      animation.current.reset();</pre>
			<pre class="source-code">    }</pre>
			<p>Besides <strong class="source-inline">play</strong> and <strong class="source-inline">reset</strong>, we can find other imperative methods in the <strong class="source-inline">lottie-react-native</strong> library's README file found at <a href="https://github.com/lottie-react-native/lottie-react-native/blob/master/docs/api.md">https://github.com/lottie-react-native/lottie-react-native/blob/master/docs/api.md</a>.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor183"/>Summary</h1>
			<p>In this chapter we reviewed the differences between the declarative and the imperative APIs for <strong class="source-inline">lottie-react-native</strong>, which can be used to control the looks and the playback of our animation. On top of that, we learned how to use React Native's Animated API to smoothly control the progress of a Lottie animation.</p>
			<p>In the next chapter, we will go through some of the most common issues, pitfalls, and problems we may face when using <strong class="source-inline">lottie-react-native</strong> in our React Native apps.</p>
		</div>
	</body></html>