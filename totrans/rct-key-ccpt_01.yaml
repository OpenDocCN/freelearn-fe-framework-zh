- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: React – What and Why
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React – 什么是 React 以及为什么使用它
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下内容：
- en: Describe what React is and why you would use it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述 React 是什么以及为什么你会使用它
- en: Compare React to web projects built with just JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 React 与仅使用 JavaScript 构建的 Web 项目进行比较
- en: Explain the difference between imperative and declarative code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释命令式和声明式代码之间的区别
- en: Differentiate between **single-page applications** ( **SPAs** ) and multi-page
    apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分**单页应用程序**（**SPAs**）和多页应用程序
- en: Create new React projects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的 React 项目
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**React.js** (or just **React** , as it’s also called and as it’ll be referred
    to for the majority of this book) is one of the **most popular frontend JavaScript
    libraries** – maybe even the most popular one, according to a 2023 Stack Overflow
    developer survey. It is currently used by over 5% of the top 1,000 websites and
    compared to other popular frontend JavaScript libraries and frameworks like Angular,
    React is leading by a huge margin, when looking at key metrics like weekly package
    downloads via **npm** , which is a tool commonly used for downloading and managing
    JavaScript packages.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**React.js**（或简称**React**，本书中也将这样称呼，并将在大多数情况下使用此称呼）是最受欢迎的前端 JavaScript 库之一——根据
    2023 年 Stack Overflow 开发者调查，可能甚至是最受欢迎的一个。目前，它被前 1000 个顶级网站中的超过 5% 使用，与其他流行的前端
    JavaScript 库和框架（如 Angular）相比，React 在关键指标（如通过 npm 的每周包下载量）上领先巨大，npm 是一个常用于下载和管理
    JavaScript 包的工具。'
- en: Though it is certainly possible to write good React code without fully understanding
    how React works and why you’re using it, you’ll likely be able to learn advanced
    concepts quicker and avoid errors when trying to understand the tools you’re working
    with as well as the reasons for picking a certain tool in the first place.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当然可以在不完全理解 React 的工作原理以及为什么使用它的前提下编写好的 React 代码，但你可能会更快地学习高级概念，并在尝试理解你正在使用的工具以及最初选择该工具的原因时避免错误。
- en: Therefore, before considering anything about its core concepts and ideas or
    reviewing example code, you first need to understand what React actually is and
    why it exists. This will help you understand how React works internally and why
    it offers the features it does.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在考虑其核心概念和理念或审查示例代码之前，你首先需要了解 React 究竟是什么以及为什么它存在。这将帮助你理解 React 内部是如何工作的以及为什么它提供了这些功能。
- en: If you already know why you’re using React, why solutions like React, in general,
    are being used instead of **vanilla JavaScript** (i.e., JavaScript without any
    frameworks or libraries, more on this in the next section), and what the idea
    behind React and its syntax is, you may, of course, skip this section and jump
    ahead to the more practice-oriented chapters later in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经知道为什么你使用 React，为什么像 React 这样的解决方案通常会被用于代替**纯 JavaScript**（即没有框架或库的 JavaScript，更多内容将在下一节中介绍），以及
    React 及其语法的理念是什么，你当然可以跳过这一节，直接跳到本书后面更注重实践的章节。
- en: But if you only *think* that you know it and are not 100% certain, you should
    definitely read this chapter first.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你只是**认为**自己了解它，并且并不完全确定，你绝对应该首先阅读这一章。
- en: What is React?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 React？
- en: 'React is a JavaScript library, and if you take a look at the official web page
    (the official React website and documentation are available at this link: [https://react.dev/](https://react.dev/)
    ), you learn that the creators call it *“The library for web and native user interfaces.”*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个 JavaScript 库，如果你查看官方网页（官方 React 网站和文档可在以下链接找到：[https://react.dev/](https://react.dev/)），你会了解到创造者称其为*“用于
    Web 和原生用户界面的库。”*
- en: But what does this mean?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但这究竟意味着什么？
- en: First, it’s important to understand that React is a JavaScript library. As a
    reader of this book, you know what JavaScript is and why you use JavaScript in
    the browser. JavaScript allows you to add interactivity to your website since,
    with JavaScript, you can react to user events and manipulate the page after it
    is loaded. This is extremely valuable as it allows you to build highly interactive
    web **user interfaces** ( **UIs** ).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要理解 React 是一个 JavaScript 库。作为本书的读者，你知道 JavaScript 是什么以及为什么你在浏览器中使用 JavaScript。JavaScript
    允许你在页面加载后添加交互性，因为你可以通过 JavaScript 对用户事件做出反应并操作页面。这非常有价值，因为它允许你构建高度交互的 Web **用户界面**（**UIs**）。
- en: But what is a “library” and how does React help with building UIs?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但“库”是什么？React 又是如何帮助构建用户界面的？
- en: While you can have philosophical discussions about what a library is (and how
    it differs from a framework), the pragmatic definition of a library is that it’s
    a collection of functionalities that you can use in your code to achieve results
    that would normally require more code and work from your side. Libraries can help
    you write more concise and possibly also less error-prone code and enable you
    to implement certain features more quickly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以就库是什么（以及它与框架的区别）进行哲学讨论，但库的实用定义是它是一组你可以用于代码中的功能，以实现通常需要更多代码和工作的结果。库可以帮助你编写更简洁的代码，可能也更不容易出错，并使你能够更快地实现某些功能。
- en: React is such a library – one that focuses on providing functionalities that
    help you create interactive and reactive UIs. Indeed, React deals with more than
    web interfaces (i.e., websites loaded in browsers). You can also build native
    apps for mobile devices with React and React Native, which is another library
    that utilizes React under the hood. The React concepts covered in this book still
    apply, no matter which target platform is chosen. But examples will focus on React
    for web browsers. No matter which platform you’re targeting though, creating interactive
    UIs with just JavaScript can quickly become very complex and overwhelming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: React就是这样的一个库——它专注于提供帮助你创建交互性和响应性UI的功能。确实，React不仅处理Web界面（即浏览器中加载的网站），你还可以使用React和React
    Native（这是一个在底层使用React的库）为移动设备构建原生应用。本书中涵盖的React概念，无论选择哪个目标平台都适用。但示例将专注于React Web浏览器。不过，无论你针对哪个平台，仅使用JavaScript创建交互式UI可能会迅速变得非常复杂和令人不知所措。
- en: The Problem with “Vanilla JavaScript”
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “纯JavaScript”的问题
- en: Vanilla JavaScript is a term commonly used in web development to refer to JavaScript
    without any frameworks or libraries. That means you write all the JavaScript on
    your own, without falling back to any libraries or frameworks that would provide
    extra utility functionalities. When working with vanilla JavaScript, you especially
    don’t use major frontend frameworks or libraries like React or Angular.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 纯JavaScript是Web开发中常用术语，指的是没有框架或库的JavaScript。这意味着你将所有JavaScript代码都自己编写，而不依赖任何提供额外实用功能的库或框架。当使用纯JavaScript时，你尤其不使用像React或Angular这样的主要前端框架或库。
- en: Using vanilla JavaScript generally has the advantage that visitors of a website
    have to download less JavaScript code (as major frameworks and libraries typically
    are quite sizeable and can quickly add 50+ KB of extra JavaScript code that has
    to be downloaded).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯JavaScript通常具有这样的优势，即网站的访问者需要下载的JavaScript代码更少（因为主要的框架和库通常相当庞大，并且可以快速添加50+
    KB的额外JavaScript代码，这些代码必须下载）。
- en: The downside of relying on vanilla JavaScript is that you, as the developer,
    must implement all functionalities from the ground up on your own. This can be
    error prone and highly time consuming. Therefore, especially more complex UIs
    and websites can quickly become very hard to manage with vanilla JavaScript.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于纯JavaScript的缺点是，作为开发者，你必须从头开始自己实现所有功能。这可能会导致错误，并且非常耗时。因此，特别是对于更复杂的UI和网站，使用纯JavaScript很快就会变得非常难以管理。
- en: React simplifies the creation and management of such UIs by moving from an **imperative**
    to a **declarative** approach. Though this is a nice sentence, it can be hard
    to grasp if you haven’t worked with React or similar frameworks before. To understand
    it, the idea behind “imperative versus declarative approaches,” and why you might
    want to use React instead of just vanilla JavaScript, it’s helpful to take a step
    back and evaluate how vanilla JavaScript works.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React通过从**命令式**方法转向**声明式**方法来简化此类UI的创建和管理。尽管这是一个不错的句子，但如果之前没有使用过React或类似框架，可能会很难理解。为了理解它，了解“命令式与声明式方法”背后的理念，以及为什么你可能想使用React而不是仅仅使用纯JavaScript，退一步评估纯JavaScript的工作方式是有帮助的。
- en: 'Let’s look at a short code snippet that shows how you could handle the following
    UI actions with vanilla JavaScript:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简短的代码片段，展示你如何使用纯JavaScript处理以下UI操作：
- en: Add an event listener to a button to listen for `click` events.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加事件监听器以监听`click`事件。
- en: Replace the text of a paragraph with new text once a click on the button occurs.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦点击按钮，就用新文本替换段落中的文本。
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example is deliberately kept simple, so it’s probably not looking too bad
    or overwhelming. It’s just a basic example to show how code is generally written
    with vanilla JavaScript (a more complex example will be discussed later). But
    even though this example is straightforward to digest, working with vanilla JavaScript
    will quickly reach its limits for feature-rich UIs and the code to handle various
    user interactions accordingly also becomes more complex. Code can quickly grow
    significantly, so maintaining it can become a challenge.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子故意保持简单，所以它看起来可能并不太糟糕或令人不知所措。它只是一个基本的例子，用来展示代码通常是如何用纯JavaScript编写的（稍后会讨论一个更复杂的例子）。但即使这个例子很容易理解，使用纯JavaScript处理功能丰富的UI以及相应处理各种用户交互的代码也会很快达到其极限。代码可以迅速增长，因此维护它可能成为一个挑战。
- en: In the preceding example, code is written with vanilla JavaScript and, as a
    consequence, imperatively. This means that you write instruction after instruction,
    and you describe every step that needs to be taken in detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，代码是用纯JavaScript编写的，并且是命令式的。这意味着你一条条地写下指令，并详细描述需要采取的每一步。
- en: 'The code shown previously could be translated into these more human-readable
    instructions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的代码可以翻译成以下更易于阅读的指令：
- en: Look for an **HTML** element of the `button` type to obtain a reference to the
    first button on the page.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找页面上的第一个`button`类型的`HTML`元素以获取对该按钮的引用。
- en: Create a constant (i.e., a data container) named `buttonElement` that holds
    that button reference.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`buttonElement`的常量（即数据容器），其中包含按钮引用。
- en: Repeat *Step 1* but get a reference to the first element that is of type of
    `p` .
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1*，但获取类型为`p`的第一个元素的引用。
- en: Store the paragraph element reference in a constant named `paragraphElement`
    .
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将段落元素引用存储在名为`paragraphElement`的常量中。
- en: Add an event listener to the `buttonElement` that listens for `click` events
    and triggers the `updateTextHandler` function whenever such a `click` event occurs.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`buttonElement`添加一个事件监听器，该监听器监听`click`事件，并在发生此类`click`事件时触发`updateTextHandler`函数。
- en: Inside the `updateTextHandler` function, use the `paragraphElement` to set its
    `textContent` to `"Text was changed!"` .
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`updateTextHandler`函数内部，使用`paragraphElement`将其`textContent`设置为`"Text was changed!"`。
- en: Do you see how every step that needs to be taken is clearly defined and written
    out in the code?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否看到每个需要采取的步骤都在代码中被清晰地定义和写出？
- en: 'This shouldn’t be too surprising because that is how most programming languages
    work: you define a series of steps that must be executed in order. It’s an approach
    that makes a lot of sense because the order of code execution shouldn’t be random
    or unpredictable.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人惊讶，因为大多数编程语言都是这样工作的：你定义一系列必须按顺序执行的步骤。这是一个很有意义的做法，因为代码执行的顺序不应该随机或不可预测。
- en: However, when working with UIs, this imperative approach is not ideal. Indeed,
    it can quickly become cumbersome because, as a developer, you have to add a lot
    of instructions that, despite adding little value, cannot simply be omitted. You
    need to write all the **Document Object Model** ( **DOM** ) instructions that
    allow your code to interact with elements, add elements, manipulate elements,
    and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当与UI一起工作时，这种命令式方法并不理想。实际上，它可能会很快变得繁琐，因为作为开发者，你必须添加很多指令，尽管这些指令增加的价值很少，但它们不能简单地被省略。你需要编写所有允许你的代码与元素交互、添加元素、操作元素等的**文档对象模型**（**DOM**）指令。
- en: Your core business logic (e.g., deriving and defining the actual text that should
    be set after a click) therefore often makes up only a small chunk of the overall
    code. When controlling and manipulating web UIs with JavaScript, a huge chunk
    (often the majority) of your code is frequently made up of DOM instructions, event
    listeners, HTML element operations, and UI state management.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的核心业务逻辑（例如，在点击后推导和定义应设置的文本）通常只占整体代码的一小部分。当用JavaScript控制和管理Web UI时，大量的代码（通常是大多数）经常由DOM指令、事件监听器、HTML元素操作和UI状态管理组成。
- en: As a result, you end up describing all the steps that are required to interact
    with the UI technically **and** all the steps that are required to derive the
    output data (i.e., the desired final state of the UI).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你最终需要描述所有与UI技术交互所需的步骤，以及所有推导输出数据（即UI的期望最终状态）所需的步骤。
- en: '**Note**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: This book assumes that you are familiar with the DOM. In a nutshell, the DOM
    is the “bridge” between your JavaScript code and the HTML code of the website
    with which you want to interact. Via the built-in **DOM API** , JavaScript is
    able to create, insert, manipulate, delete, and read HTML elements and their content.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你已经熟悉DOM。简而言之，DOM是你JavaScript代码和想要与之交互的网站HTML代码之间的“桥梁”。通过内置的**DOM API**，JavaScript能够创建、插入、操作、删除和读取HTML元素及其内容。
- en: 'You can learn more about the DOM in this article: [https://academind.com/tutorials/what-is-the-dom](https://academind.com/tutorials/what-is-the-dom)
    .'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这篇文章中了解更多关于DOM的信息：[https://academind.com/tutorials/what-is-the-dom](https://academind.com/tutorials/what-is-the-dom)。
- en: Modern web UIs are often quite complex, with lots of interactivity going on
    behind the scenes. Your website might need to listen for user input in an input
    field, send that entered data to a server to validate it, output a validation
    feedback message on the screen, and show an error overlay modal if incorrect data
    is submitted.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web UI通常相当复杂，幕后有很多交互性。你的网站可能需要在输入字段中监听用户输入，将输入的数据发送到服务器进行验证，在屏幕上输出验证反馈消息，如果提交了错误数据，则显示错误覆盖模态。
- en: The button-clicking example is not a complex example in general, but the vanilla
    JavaScript code for implementing such a scenario can be overwhelming. You end
    up with lots of DOM selection, insertion, and manipulation operations, as well
    as multiple lines of code that do nothing but manage event listeners. Also, keeping
    the DOM updated, without introducing bugs or errors, can be a nightmare since
    you must ensure that you update the right DOM element with the right value at
    the right time. Here, you will find a screenshot of some example code for the
    described use case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮点击示例在一般情况下并不是一个复杂的例子，但实现此类场景的原生JavaScript代码可能会让人感到压倒性。你最终会进行大量的DOM选择、插入和操作操作，以及多行代码，这些代码除了管理事件监听器之外什么都不做。此外，保持DOM更新，不引入错误或bug，可能是一个噩梦，因为你必须确保在正确的时间更新正确的DOM元素和正确的值。在这里，你可以找到描述的使用案例的一些示例代码的截图。
- en: '**Note**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The full, working, code can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/vanilla-javascript](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/vanilla-javascript)
    .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的、可工作的代码可以在GitHub上找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/vanilla-javascript](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/vanilla-javascript)。
- en: If you take a look at the JavaScript code in the screenshot (or in the linked
    repository), you will probably be able to imagine how a more complex UI is likely
    to look.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看截图中的JavaScript代码（或链接的仓库），你可能会想象出一个更复杂的UI可能看起来是什么样子。
- en: '![A screenshot of a computer program  Description automatically generated](img/B31339_01_01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图 自动生成描述](img/B31339_01_01.png)'
- en: 'Figure 1.1: An example JavaScript code file that contains over 100 lines of
    code for a fairly trivial UI'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：一个包含超过100行代码的示例JavaScript代码文件，用于一个相当简单的UI
- en: This example JavaScript file already contains roughly 110 lines of code. Even
    after minifying (“minifying” means that code is shortened automatically, e.g.,
    by replacing long variable names with shorter ones and removing redundant whitespace;
    in this case, via [https://www.toptal.com/developers/javascript-minifier](https://www.toptal.com/developers/javascript-minifier)
    ) it and splitting the code across multiple lines thereafter (to count the raw
    lines of code), it still has around 80 lines of code. That’s a full 80 lines of
    code for a simple UI with only basic functionality. The actual business logic
    (i.e., input validation, determining whether and when overlays should be shown,
    and defining the output text) only makes up a small fraction of the overall code
    base – around 20 to 30 lines of code, in this case (around 20 after minifying).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例JavaScript文件已经包含了大约110行代码。即使经过压缩（“压缩”意味着代码会自动缩短，例如通过用较短的变量名替换较长的变量名和删除冗余空格；在这种情况下，通过[https://www.toptal.com/developers/javascript-minifier](https://www.toptal.com/developers/javascript-minifier)）并随后将代码拆分到多行（以计算原始代码行数），它仍然有大约80行代码。这是一个简单UI的完整80行代码，只具有基本功能。实际的业务逻辑（即输入验证、确定何时显示覆盖层以及定义输出文本）只占整个代码库的一小部分——在这个例子中大约20到30行代码，经过压缩后大约20行。
- en: That’s roughly 75% of the code spent on pure DOM interaction, DOM state management,
    and similar boilerplate tasks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约是75%的代码用于纯DOM交互、DOM状态管理和类似样板任务。
- en: As you can see by these examples and numbers, controlling all the UI elements
    and their different states (e.g., whether an info box is visible or not) is a
    challenging task, and trying to create such interfaces with just JavaScript often
    leads to complex code that might even contain errors.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如这些示例和数字所示，控制所有UI元素及其不同状态（例如，信息框是否可见）是一项具有挑战性的任务，而仅使用JavaScript尝试创建此类界面通常会导致代码复杂，甚至可能包含错误。
- en: 'That’s why the imperative approach, wherein you must define and write down
    every single step, has its limits in situations like this. This is the reason
    why React provides utility functionalities that allow you to write code differently:
    with a declarative approach.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为在这种情况中，必须定义并写下每个单独步骤的命令式方法有其局限性，这就是为什么React提供了允许您以不同的方式编写代码的实用功能：使用声明式方法。
- en: '**Note**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'This is not a scientific paper, and the preceding example is not meant to act
    as an exact scientific study. Depending on how you count lines and which kind
    of code you consider to be “core business logic,” you will end up with higher
    or lower percentage values. The key message doesn’t change though: lots of code
    (in this case most of it) deals with the DOM and DOM manipulation – not with the
    actual logic that defines your website and its key features.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一篇科学论文，前面的例子也不是作为精确的科学研究的意图。根据您如何计算行数以及您认为哪种代码是“核心业务逻辑”，您最终会得到更高的或更低的百分比值。不过，关键信息并没有改变：大量的代码（在这种情况下，大部分）处理DOM和DOM操作——而不是定义您的网站及其关键功能的实际逻辑。
- en: React and Declarative Code
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React和声明式代码
- en: 'Coming back to the first, simple code snippet from earlier, here’s that same
    code snippet, this time using React:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前的第一段简单代码片段，这里是相同的代码片段，这次使用React：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This snippet performs the same operations as the first did with just vanilla
    JavaScript:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段执行与第一个相同的操作，只是使用了纯JavaScript：
- en: 'Add an event listener to a button to listen for `click` events (now with some
    React-specific syntax: `onClick={…})` .'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向按钮添加事件监听器以监听`click`事件（现在带有一些React特定的语法：`onClick={…})`。
- en: Replace the text of a paragraph with a new text once the click on the button
    occurs.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦点击按钮，就用新文本替换段落的文本。
- en: Nonetheless, this code looks totally different – like a mixture of JavaScript
    and HTML. Indeed, React uses a syntax extension called **JSX** (i.e., JavaScript
    extended to include XML-like syntax). For the moment, it’s enough to understand
    that this JSX code will work because of a **pre-processing** (or **transpilation**
    ) step that’s part of the build workflow of every React project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这段代码看起来完全不同——就像JavaScript和HTML的混合体。确实，React使用一种名为**JSX**（即扩展JavaScript以包含类似XML的语法）的语法扩展。目前，只需理解这种JSX代码能够工作，是因为它包含在每个React项目构建工作流程中的**预处理器**（或**转译**）步骤。
- en: Pre-processing means that certain tools, which are part of React projects, analyze
    and transform the code before it is deployed. This allows for development-only
    syntax like JSX, which would not work in the browser and is for that reason transformed
    to regular JavaScript before deployment. (You’ll get a thorough introduction to
    JSX in *Chapter 2* , *Understanding React Components and JSX* .)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器意味着某些工具，它们是React项目的一部分，会在代码部署之前分析和转换代码。这允许使用仅适用于开发的语法，如JSX，这在浏览器中无法工作，因此在部署之前将其转换为常规JavaScript。（您将在*第2章*，*理解React组件和JSX*中详细了解JSX。）
- en: 'In addition, the snippet shown previously contains a React-specific feature:
    State. state will be discussed in greater detail later in the book ( *Chapter
    4* , *Working with Events and State* , will focus on handling events and states
    with React). For the moment, you can think of this state as a variable that, when
    changed, will trigger React to update the UI in the browser.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，之前显示的代码片段包含一个React特有的功能：状态。本书稍后将对状态进行更详细的讨论（*第4章*，*处理事件和状态*，将专注于使用React处理事件和状态）。目前，您可以将其视为一个变量，当它改变时，将触发React更新浏览器中的UI。
- en: 'What you see in the preceding example is the “declarative approach” used by
    React: you write your JavaScript logic (e.g., functions that should eventually
    be executed), and you combine that logic with the HTML code that should trigger
    it or that is affected by it. You don’t write the instructions for selecting certain
    DOM elements or changing the text content of some DOM elements. Instead, with
    React and JSX, you focus on your JavaScript business logic and define the desired
    HTML output that should eventually be reached. This output can, and typically
    will, contain dynamic values that are derived inside of your main JavaScript code.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你所看到的是 React 使用的“声明式方法”：你编写你的 JavaScript 逻辑（例如，最终应该被执行的函数），并将该逻辑与触发它的或受它影响的
    HTML 代码结合起来。你不需要编写选择某些 DOM 元素或更改某些 DOM 元素的文本内容的指令。相反，使用 React 和 JSX，你专注于你的 JavaScript
    业务逻辑，并定义最终应该达到的期望 HTML 输出。这个输出可以，并且通常将，包含在主 JavaScript 代码内部推导出的动态值。
- en: In the preceding example, `outputText` is some state managed by React. In the
    code, the `updateTextHandler` function is triggered upon a click, and the `outputText`
    state value is set to a new string value ( `'` `Text was changed!'` ) with the
    help of the `setOutputText` function. The exact details of what’s going on here
    will be explored in *Chapter 4* .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`outputText` 是由 React 管理的一些状态。在代码中，`updateTextHandler` 函数在点击时触发，并使用
    `setOutputText` 函数将 `outputText` 状态值设置为一个新的字符串值（`'Text was changed!'`）。这里发生的确切细节将在
    *第 4 章* 中探讨。
- en: The general idea, though, is that the state value is changed and, since it’s
    being referenced in the last paragraph ( `<p>{outputText}</p>` ), React outputs
    the current state value in that place in the actual DOM (and hence, on the actual
    web page). React will keep the paragraph updated, and therefore, whenever `outputText`
    changes, React will select this paragraph element again and update its `textContent`
    automatically.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总体思路是状态值发生变化，由于它在最后一段（`<p>{outputText}</p>`）中被引用，React 在实际的 DOM（以及因此，在实际的网页）中的那个位置输出当前状态值。React
    将保持段落更新，因此，每当 `outputText` 发生变化时，React 将再次选择这个段落元素并自动更新其 `textContent`。
- en: This is the declarative approach in action. As a developer, you don’t need to
    worry about the technical details (for example, selecting the paragraph and updating
    its `textContent` ). Instead, you will hand this work off to React. You will only
    need to focus on the desired end states where the goal simply is to output the
    current value of `outputText` in a specific place (i.e., in the second paragraph
    in this case) on the page. It’s React’s job to do the “ *behind the scenes* ”
    work of getting to that result.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是声明式方法的应用。作为一个开发者，你不需要担心技术细节（例如，选择段落并更新其 `textContent`）。相反，你将这项工作交给 React。你只需要关注期望的最终状态，目标仅仅是输出
    `outputText` 的当前值在页面的特定位置（即在这个例子中的第二个段落）。这是 React 的任务，在幕后完成达到该结果的工作。
- en: It turns out that this code snippet isn’t shorter than the vanilla JavaScript
    one; indeed, it’s actually even a bit longer. But that’s only the case because
    this first snippet was deliberately kept simple and concise. In such cases, React
    actually adds a bit of overhead code. If that were your entire UI, using React
    indeed wouldn’t make too much sense. Again, this snippet was chosen because it
    allows us to see the differences at a glance. Things change if you take a look
    at the more complex vanilla JavaScript example from before and compare that to
    its React alternative.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这个代码片段并不比纯 JavaScript 的代码片段短；实际上，它甚至更长。但这仅仅是因为这个第一个片段被故意保持简单和简洁。在这种情况下，React
    实际上添加了一些开销代码。如果那将是你的整个 UI，使用 React 确实没有太多意义。再次强调，这个片段被选择是因为它使我们能够一目了然地看到差异。如果你看一下之前更复杂的纯
    JavaScript 示例，并将其与它的 React 选项进行比较，情况就会发生变化。
- en: '**Note**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Referenced code can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/vanilla-javascript](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/vanilla-javascript)
    and [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/reactjs](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/reactjs)
    , respectively.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 参考代码可以在 GitHub 上找到，分别位于 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/vanilla-javascript](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/vanilla-javascript)
    和 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/reactjs](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/examples/example-1/reactjs)。
- en: '![A screenshot of a computer program  Description automatically generated](img/B31339_01_02.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述自动生成](img/B31339_01_02.png)'
- en: 'Figure 1.2: The code snippet from before is now implemented via React'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：之前的代码片段现在通过 React 实现
- en: It’s still not short because all the JSX code (i.e., the HTML output) is included
    in the JavaScript file. If you ignore pretty much the entire right side of that
    screenshot (since HTML was not part of the vanilla JavaScript files either), the
    React code gets much more concise. However, most importantly, if you take a closer
    look at all the React code (also in the first, shorter snippet), you will notice
    that there are absolutely no operations that would select DOM elements, create
    or insert DOM elements, or edit DOM elements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然不短，因为所有的 JSX 代码（即，HTML 输出）都包含在 JavaScript 文件中。如果你几乎忽略那个截图的整个右侧（因为 HTML 也不是纯
    JavaScript 文件的一部分），React 代码会变得更加简洁。然而，最重要的是，如果你仔细查看所有的 React 代码（也包括第一个较短的片段），你会注意到绝对没有选择
    DOM 元素、创建或插入 DOM 元素或编辑 DOM 元素的操作。
- en: This is the core idea of React. You don’t write down all the individual steps
    and instructions; instead, you focus on the “big picture” and the desired end
    states of your page content. With React, you can merge your JavaScript and markup
    code without having to deal with the low-level instructions of interacting with
    the DOM like selecting elements via `document.getElementById()` or similar operations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 React 的核心思想。你不需要写下所有单独的步骤和指令；相反，你专注于“大局”和页面内容的期望最终状态。使用 React，你可以合并你的 JavaScript
    和标记代码，而无需处理与 DOM 交互的低级指令，如通过 `document.getElementById()` 或类似操作选择元素。
- en: Using this declarative approach instead of the imperative approach with vanilla
    JavaScript allows you, the developer, to focus on your core business logic and
    the different states of your HTML code. You don’t need to define all the individual
    steps that have to be taken (like “adding an event listener,” “selecting a paragraph,”
    etc.), and this simplifies the development of complex UIs tremendously.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种声明式方法而不是纯 JavaScript 的命令式方法，可以让开发者专注于核心业务逻辑和 HTML 代码的不同状态。你不需要定义所有必须采取的单独步骤（如“添加事件监听器”、“选择段落”等），这极大地简化了复杂
    UI 的开发。
- en: '**Note**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It is worth emphasizing that React is not a great solution if you’re working
    on a very simple UI. If you can solve a problem with a few lines of vanilla JavaScript
    code, there is probably no strong reason to integrate React into the project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，如果你正在处理一个非常简单的 UI，React 并不是一个很好的解决方案。如果你可以用几行纯 JavaScript 代码解决问题，那么将
    React 集成到项目中可能没有强烈的理由。
- en: Looking at React code for the first time, it can look very unfamiliar and strange.
    It’s not what you’re used to from JavaScript. Still, it is JavaScript – just enhanced
    with this JSX feature and various React-specific functionalities (like state).
    It may be less confusing if you remember that you typically define your UI (i.e.,
    your content and its structure) with HTML. You don’t write step-by-step instructions
    there either but rather create a nested tree structure with HTML tags. You express
    your content, the meaning of different elements, and the hierarchy of your UI
    by using different HTML elements and nesting HTML tags.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次看 React 代码时，它可能看起来非常陌生和奇怪。它不是你从 JavaScript 中习惯看到的样子。然而，它仍然是 JavaScript –
    只是通过 JSX 功能和各种 React 特定功能（如状态）进行了增强。如果你记得你通常使用 HTML 定义你的 UI（即，你的内容和其结构），可能会更容易理解。你不会在那里写一步一步的指令，而是使用
    HTML 标签创建一个嵌套的树结构。你通过使用不同的 HTML 元素和嵌套 HTML 标签来表达你的内容、不同元素的意义以及你 UI 的层次结构。
- en: If you keep this in mind, the “traditional” (vanilla JavaScript) approach of
    manipulating the UI should seem rather odd. Why would you start defining low-level
    instructions like *“insert a paragraph element below this button and set its text
    to <some text>”* if you don’t do that in HTML at all? React, in the end, brings
    back that HTML syntax, which is far more convenient when it comes to defining
    content and structure. With React, you can write dynamic JavaScript code side
    by side with the UI code (i.e., the HTML code) that is affected by it or related
    to it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记住这一点，那么“传统”的（纯JavaScript）操作UI的方法看起来可能相当奇怪。如果你在HTML中根本不做这样的低级指令，比如*“在这个按钮下方插入一个段落元素并设置其文本为<某些文本>”*，你会怎么做呢？最终，React恢复了HTML语法，这在定义内容和结构时更为方便。使用React，你可以将动态JavaScript代码与受其影响的UI代码（即HTML代码）并排编写。
- en: How React Manipulates the DOM
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React如何操作DOM
- en: 'As mentioned earlier, when writing React code, you typically write it as shown
    previously: you blend HTML with JavaScript code by using the JSX syntax extension.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在编写React代码时，你通常按照前面所示的方式编写：通过使用JSX语法扩展将HTML与JavaScript代码混合。
- en: It is worth pointing out that JSX code does not run like this in browsers. It
    instead needs to be pre-processed before deployment. The JSX code must be transformed
    into regular JavaScript code before being served to browsers. The next chapter
    will take a closer look at JSX and what it’s transformed into. For the moment,
    though, simply keep in mind that JSX code must be transformed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，JSX代码在浏览器中不会像这样运行。它需要在部署之前进行预处理。JSX代码必须在发送到浏览器之前被转换成常规JavaScript代码。下一章将更详细地探讨JSX及其转换后的内容。不过，目前只需记住JSX代码必须被转换。
- en: 'Nonetheless, it is worth knowing that the code to which JSX will be transformed
    will also not contain any DOM instructions. Instead, the transformed code will
    execute various utility methods and functions that are built into React (in other
    words, those that are provided by the React package that need to be added to every
    React project). Internally, React creates a virtual DOM-like tree structure that
    reflects the current state of the UI. This book takes a closer look at this abstract,
    virtual DOM, and how React works in *Chapter 10* , *Behind the Scenes of React
    and Optimization Opportunities* . That’s why React (the library) splits its core
    logic across two main packages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，了解以下信息是很有价值的：JSX将被转换成的代码也不会包含任何DOM指令。相反，转换后的代码将执行各种内置在React中的实用方法和函数（换句话说，那些由React包提供，需要添加到每个React项目中的函数）。在内部，React创建了一个类似于虚拟DOM的树结构，反映了UI的当前状态。本书将更深入地探讨这个抽象的虚拟DOM，以及React在*第10章*，*React幕后和优化机会*中的工作方式。这就是为什么React（库）将其核心逻辑分布在两个主要包之间：
- en: The main `react` package
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要的`react`包
- en: The `react-dom` package
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-dom`包'
- en: The main `react` package is a third-party JavaScript library that needs to be
    imported into a project to use React’s features (like JSX or state) there. It’s
    this package that creates this virtual DOM and derives the current UI state. But
    you also need the `react-dom` package in your project if you want to manipulate
    the DOM with React.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的`react`包是一个第三方JavaScript库，需要将其导入到项目中才能使用React的功能（如JSX或状态）。是这个包创建了虚拟DOM并推导出当前的UI状态。但如果你想在项目中使用React操作DOM，你还需要`react-dom`包。
- en: The `react-dom` package, specifically the `react-dom/client` part of that package,
    acts as a “translation bridge” between your React code, the internally generated
    virtual DOM, and the browser with its actual DOM that needs to be updated. It’s
    the `react-dom` package that will produce the actual DOM instructions that will
    select, update, delete, and create DOM elements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-dom`包，特别是该包的`react-dom/client`部分，充当了React代码、内部生成的虚拟DOM以及需要更新的浏览器实际DOM之间的“翻译桥”。是`react-dom`包将生成实际的DOM指令，用于选择、更新、删除和创建DOM元素。'
- en: This split exists because you can also use React with other target environments.
    A very popular and well-known alternative to the DOM (i.e., to the browser) would
    be React Native, which allows developers to build native mobile apps with the
    help of React. With React Native, you also include the react package in your project,
    but in place of `react-dom` , you would use the `react-native` package. In this
    book, “React” refers to both the `react` package and the “bridge” packages (like
    `react-dom)` .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分割存在是因为你还可以在其他目标环境中使用React。一个非常流行且广为人知的DOM（即浏览器）的替代方案是React Native，它允许开发者借助React构建原生移动应用。使用React
    Native时，你也会在你的项目中包含react包，但会使用`react-native`包代替`react-dom`。在这本书中，“React”既指`react`包也指“桥接”包（如`react-dom`）。
- en: '**Note**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: As mentioned earlier, this book focuses on React itself. The concepts explained
    in this book, therefore, will apply to both web browsers and websites as well
    as mobile devices. Nonetheless, all examples will focus on the web and `react-dom`
    since that avoids introducing extra complexity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这本书主要关注React本身。因此，书中解释的概念将适用于网络浏览器、网站以及移动设备。尽管如此，所有示例都将关注网络和`react-dom`，因为这可以避免引入额外的复杂性。
- en: Introducing SPAs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍单页应用（SPAs）
- en: 'React can be used to simplify the creation of complex UIs, and there are two
    main ways of doing that:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: React可以用来简化复杂UI的创建，主要有两种方式：
- en: Manage parts of a website (e.g., a chat box in the bottom left corner).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理网站的部分（例如，左下角的聊天框）。
- en: Manage the entire page and all user interactions that occur on it.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理整个页面以及在该页面上发生的所有用户交互。
- en: 'Both approaches are viable, but the more popular and common scenario is the
    second one: using React to manage the entire web page, instead of just parts of
    it. This approach is more popular because most websites that have complex UIs
    have not just one, but multiple complex elements on their pages. Complexity would
    actually increase if you were to start using React for some website parts without
    using it for other areas of the site. For this reason, it’s very common to manage
    the entire website with React.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是可行的，但更流行和常见的场景是第二种：使用React来管理整个网页，而不是仅仅管理其部分。这种方法之所以更受欢迎，是因为大多数具有复杂UI的网站在其页面上不仅有单个复杂元素，还有多个复杂元素。实际上，如果你开始使用React处理网站的部分区域而不处理其他区域，复杂性实际上会增加。因此，使用React来管理整个网站是非常常见的。
- en: This doesn’t even stop after using React on one specific page of the site. Indeed,
    React can be used to handle URL path changes and update the parts of the page
    that need to be updated in order to reflect the new page that should be loaded.
    This functionality is called **routing** and third-party packages like `react-router-dom`
    (see *Chapter 13* , *Multipage Apps with React Router* ), which integrate with
    React, allow you to create a website wherein the entire UI is controlled via React.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至在使用React处理网站的一个特定页面后也不会停止。实际上，React可以用来处理URL路径变化，并更新需要更新的页面部分，以反映应该加载的新页面。这种功能被称为**路由**，与React集成的第三方包（如`react-router-dom`，见第13章，*使用React
    Router的多页应用*）允许你创建一个整个UI都通过React控制的网站。
- en: A website that does not just use React for parts of its pages but instead for
    all subpages and for routing is often built as a SPA because it’s common to create
    React projects that contain only one HTML file (typically named `index.html` ),
    which is used to initially load the React JavaScript code. Thereafter, the React
    library and your React code take over and control the actual UI. This means that
    the entire UI is created and managed by JavaScript via React and your React code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不仅在其页面部分使用React，而是对所有子页面和路由都使用React的网站通常被构建为单页应用（SPA），因为创建只包含一个HTML文件（通常命名为`index.html`）的React项目是很常见的，该文件用于最初加载React
    JavaScript代码。之后，React库和你的React代码接管并控制实际的UI。这意味着整个UI都是由JavaScript通过React和你的React代码创建和管理的。
- en: That being said, it’s also becoming more and more popular to build full-stack
    React apps, where frontend and backend code are merged. Modern React frameworks
    like **Next.js** simplify the process of building such web apps. Whilst the core
    concepts are the same, no matter which kind of application is built, this book
    will explore full-stack React app development in greater detail in *Chapter 15*
    , *Server-side Rendering & Building Fullstack Apps with Next.js* , *Chapter* *16*
    , *React Server Components and Server Actions* and *Chapter* *17* , *Understanding
    React Suspense and the use() Hook* .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，构建全栈React应用也越来越受欢迎，其中前端和后端代码被合并。现代React框架如**Next.js**简化了构建此类Web应用的过程。虽然核心概念相同，无论构建哪种类型的应用，本书将在第15章*服务器端渲染与使用Next.js构建全栈应用*、第16章*React服务器组件和服务器操作*以及第17章*理解React
    Suspense和use() Hook的使用*中更详细地探讨全栈React应用开发。
- en: Ultimately, this book prepares you for working with React on all kinds of React
    projects since the core building blocks and key concepts are always the same.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这本书为你准备在所有类型的React项目中使用React，因为核心构建块和关键概念始终相同。
- en: Creating a React Project with Vite
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vite创建React项目
- en: To work with React, the first step is the creation of a React project. The official
    documentation recommends using a framework like Next.js. But while this might
    make sense for complex web applications, it’s overwhelming for getting started
    with React and for exploring React concepts. Next.js and other frameworks introduce
    their own concepts and syntax. As a result, learning React can quickly become
    frustrating since it can be difficult to tell React features apart from framework
    features. In addition, not all React apps need to be built as full-stack web apps
    – consequently, using a framework like Next.js might add unnecessary complexity.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用React，第一步是创建一个React项目。官方文档建议使用像Next.js这样的框架。但对于复杂Web应用来说，这可能是有意义的，但对于React入门和探索React概念来说可能会感到压倒性。Next.js和其他框架引入了它们自己的概念和语法。因此，学习React可能会很快变得令人沮丧，因为很难区分React功能和框架功能。此外，并非所有React应用都需要构建为全栈Web应用
    – 因此，使用像Next.js这样的框架可能会增加不必要的复杂性。
- en: That’s why Vite-based React projects have emerged as a popular alternative.
    **Vite** is an open-source development and build tool that can be used to create
    and run web development projects based on all kinds of libraries and frameworks
    – React is just one of the many options.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，基于Vite的React项目已成为一个流行的替代方案。**Vite**是一个开源的开发和构建工具，可以用于创建和运行基于所有类型库和框架的Web开发项目
    – React只是众多选项之一。
- en: Vite creates projects that come with a built-in, preconfigured build process
    that, in the case of React projects, takes care of the JSX code transpilation.
    It also provides a development web server that runs locally on your system and
    allows you to preview the React app while you’re working on it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Vite创建的项目自带预配置的构建过程，在React项目中，它会处理JSX代码的转译。它还提供了一个本地运行的开发Web服务器，允许你在开发过程中预览React应用。
- en: You need a project setup like this because React projects typically use features
    like JSX, which wouldn’t work in the browser without prior code transformation.
    Hence, as mentioned earlier, a pre-processing step is required.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个这样的项目设置，因为React项目通常使用JSX这样的特性，如果没有先前的代码转换，这些特性在浏览器中是无法工作的。因此，正如之前提到的，需要一个预处理步骤。
- en: To create a project with Vite, you must have Node.js installed – preferably
    the latest (or latest **LTS** ) version. You can get the official Node.js installer
    for all operating systems from [https://nodejs.org/](https://nodejs.org/) . Once
    you have installed Node.js, you will also gain access to the built-in `npm` command,
    which you can use to utilize the Vite package to create a new React project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Vite创建项目，你必须安装Node.js –最好是最新版（或最新**LTS**版）。你可以从[https://nodejs.org/](https://nodejs.org/)获取所有操作系统的官方Node.js安装程序。一旦安装了Node.js，你也将获得内置的`npm`命令的访问权限，你可以使用它来利用Vite包创建一个新的React项目。
- en: 'You can run the following command inside of your command prompt (Windows),
    bash (Linux), or terminal (macOS) program. Just make sure that you navigate (via
    `cd` ) into the folder in which you want to create your new project:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在命令提示符（Windows）、bash（Linux）或终端（macOS）程序中运行以下命令。只需确保你已经导航（通过`cd`）到你想创建新项目的文件夹中：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once executed, this command will prompt you to choose a framework or library
    you want to use for this new project. You should choose React and then JavaScript.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，系统将提示你选择你想要用于此新项目的框架或库。你应该选择React和JavaScript。
- en: This command will create a new subfolder with a basic React project setup (i.e.,
    with various files and folders) in the place where you ran it. You should run
    it in some path on your system where you have full read and write access and where
    you’re not conflicting with any system or other project files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在你运行它的位置创建一个新的子文件夹，其中包含基本的React项目设置（即，包含各种文件和文件夹）。你应该在系统中的某个路径上运行它，你拥有完整的读写权限，并且不会与任何系统或其他项目文件冲突。
- en: 'It’s worth noting that the project creation command does not install any required
    dependencies such as the React library packages. For that reason, you must navigate
    into the created folder in your system terminal or command prompt (via `cd my-react-project`
    ) and install these packages by running the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，项目创建命令不会安装任何必需的依赖项，例如React库包。因此，你必须进入系统终端或命令提示符中创建的文件夹（通过 `cd my-react-project`）并运行以下命令来安装这些包：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the installation finishes successfully, the project setup process is complete.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装成功，项目设置过程就完成了。
- en: 'To view the created React application, you can start a development server on
    your machine via this command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看创建的React应用程序，你可以在你的机器上通过此命令启动开发服务器：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This invokes a script provided by Vite, which will spin up a locally running
    web server that pre-processes, builds, and hosts your React-powered SPA – by default
    on `localhost:5173` . Therefore, while working on the code, you typically have
    this development server up and running as it allows you to preview and test code
    changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用Vite提供的脚本，该脚本将启动一个本地运行的Web服务器，该服务器会预处理、构建并托管你的React驱动的SPA - 默认为 `localhost:5173`。因此，在编写代码时，你通常需要保持这个开发服务器运行，因为它允许你预览和测试代码更改。
- en: Best of all, this local development server will automatically update the website
    whenever you save any code changes, hence allowing you to preview your changes
    almost instantly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的是，这个本地开发服务器将自动更新网站，每当保存任何代码更改时，因此允许你几乎瞬间预览你的更改。
- en: You can quit this server whenever you’re done for the day by pressing *Ctrl*
    + *C* in the terminal or command prompt where you executed `npm run dev` .
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你一天的工作完成时，你可以通过在执行 `npm run dev` 的终端或命令提示符中按 *Ctrl* + *C* 来退出此服务器。
- en: Whenever you’re ready to start working on the project again, you can restart
    the server via `npm run dev` .
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好再次开始工作在项目上时，你可以通过 `npm run dev` 命令重新启动服务器。
- en: '**Note**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'In case you encounter any issues with creating a React project, you can also
    download and use the following starting project: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/react-starting-project](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/react-starting-project)
    . It’s a project created via Vite, which can be used in the same way as if it
    were created with the preceding command.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在创建React项目时遇到任何问题，你也可以下载并使用以下起始项目：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/react-starting-project](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/01-what-is-react/react-starting-project)。这是一个通过Vite创建的项目，可以像使用前面的命令创建的项目一样使用。
- en: When using this starting project (or, in fact, any GitHub-hosted code snapshot
    belonging to this book), you need to run `npm install` in the project folder first,
    before running `npm run dev` .
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此起始项目（或者，实际上，任何属于此书的GitHub托管代码快照）时，你需要在项目文件夹中首先运行 `npm install`，然后再运行 `npm
    run dev`。
- en: 'The exact project structure (that is, the file names and folder names) may
    vary over time, but generally, every new Vite-based React project contains a couple
    of key files and folders:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的项目结构（即，文件名和文件夹名）可能会随时间而变化，但通常，每个新的基于Vite的React项目都包含一些关键文件和文件夹：
- en: 'A `src/` folder, which contains the main source code files for the project:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `src/` 文件夹，其中包含项目的源代码文件：
- en: A `main.jsx` file, which is the main entry script file that will be executed
    first
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `main.jsx` 文件，这是首先执行的入口脚本文件
- en: An `App.jsx` file, which contains the root component of the application (you’ll
    learn more about components in the next chapter)
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `App.jsx` 文件，其中包含应用程序的根组件（你将在下一章中了解更多关于组件的内容）
- en: Various styling ( `*.css` ) files, which are imported by the JavaScript files
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种样式（ `*.css` ）文件，这些文件被JavaScript文件导入
- en: An `assets/` folder that can be used to store images or other assets that should
    be used in your React code
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `assets/` 文件夹，可以用来存储在 React 代码中使用的图像或其他资产
- en: A `public/` folder, which contains static files that will be part of the final
    website (e.g., a favicon)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `public/` 文件夹，其中包含将成为最终网站一部分的静态文件（例如，一个图标）
- en: An `index.html` file, which is the single HTML page of this website
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `index.html` 文件，这是本网站的单一 HTML 页面
- en: '`package.json` and `package-lock.json` are files that list and define the third-party
    dependencies of your project:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json` 和 `package-lock.json` 是列出和定义项目第三方依赖项的文件：'
- en: Production dependencies like `react` or `react-dom`
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产依赖项，如 `react` 或 `react-dom`
- en: Development dependencies like `eslint` for automated code quality checks
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发依赖项，如 `eslint` 用于自动代码质量检查
- en: Other project configuration files (e.g., `.gitignore` for managing Git file
    tracking)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他项目配置文件（例如，`.gitignore` 用于管理 Git 文件跟踪）
- en: A `node_modules` folder, which contains the actual code of the installed third-party
    packages
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `node_modules` 文件夹，其中包含已安装的第三方包的实际代码
- en: It’s worth noting that `App.jsx` and `main.jsx` use `.jsx` as a file extension,
    not `.js` . This is a file extension that’s enforced by Vite for files that do
    not just contain standard JavaScript but also JSX code. When working on a Vite
    project, most of your project files will consequently use `.jsx` as an extension.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`App.jsx` 和 `main.jsx` 使用 `.jsx` 作为文件扩展名，而不是 `.js`。这是一个由 Vite 强制执行的文件扩展名，用于包含标准
    JavaScript 以及 JSX 代码的文件。当在 Vite 项目中工作时，大多数项目文件将相应地使用 `.jsx` 作为扩展名。
- en: Almost all of the React-specific code will be written in the `App.jsx` file
    or custom component files that will be added to the project. We will explore components
    in the next chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的 React 特定代码都将写在 `App.jsx` 文件或将被添加到项目中的自定义组件文件中。我们将在下一章探讨组件。
- en: '**Note**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '`package.json` is the file in which you actually manage packages and their
    versions. `package-lock.json` is created automatically (by `Node.js` ). It locks
    in exact dependency and sub-dependency versions, whereas `package.json` only specifies
    version ranges. You can learn more about these files and package versions at [https://docs.npmjs.com/](https://docs.npmjs.com/)
    .'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 是你实际管理包及其版本的文件。`package-lock.json` 是自动创建的（由 `Node.js` 创建）。它锁定确切的依赖项和子依赖项版本，而
    `package.json` 只指定版本范围。你可以在 [https://docs.npmjs.com/](https://docs.npmjs.com/)
    上了解更多关于这些文件和包版本的信息。'
- en: The code of the project’s dependencies is stored in the `node_modules` folder.
    This folder can become very big since it contains the code of all installed packages
    and their dependencies. For that reason, it’s typically not included if projects
    are shared with other developers or pushed to GitHub. The `package.json` file
    is all you need. By running `npm install` , the `node_modules` folder will be
    recreated locally.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 项目依赖项的代码存储在 `node_modules` 文件夹中。由于它包含所有已安装包及其依赖项的代码，这个文件夹可能会变得非常大。因此，当项目与其他开发者共享或推送到
    GitHub 时，通常不会包含它。你只需要 `package.json` 文件。通过运行 `npm install`，`node_modules` 文件夹将在本地重新创建。
- en: Summary and Key Takeaways
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: 'React is a library, though it’s actually a combination of two main packages:
    `react` and `react-dom` .'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 是一个库，尽管它实际上是两个主要包的组合：`react` 和 `react-dom`。
- en: Though it is possible to build non-trivial UIs without React, simply using vanilla
    JavaScript to do so can be cumbersome, error prone, and hard to maintain.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然没有 React 也可以构建非平凡的 UI，但仅使用纯 JavaScript 来做这样的事情可能会很繁琐、容易出错且难以维护。
- en: React simplifies the creation of complex UIs by providing a declarative way
    to define the desired end states of the UI.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 通过提供一种声明式的方式来定义 UI 的期望最终状态，简化了复杂 UI 的创建。
- en: '**Declarative** means that you define the target UI content and structure,
    combined with different states (e.g., *“Is a modal open or closed?”* ), and you
    leave it up to React to figure out the appropriate DOM instructions.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式**意味着你定义目标 UI 内容和结构，结合不同的状态（例如，“模态是打开还是关闭？”），然后将其留给 React 来确定适当的 DOM 指令。'
- en: The react package itself derives UI states and manages a virtual DOM. It is
    a “bridge,” like `react-dom` or `react-native` , that translates this virtual
    DOM into actual UI (DOM) instructions.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本身，react 包导出 UI 状态并管理虚拟 DOM。它是一个“桥梁”，类似于 `react-dom` 或 `react-native`，将这个虚拟
    DOM 转换为实际的 UI（DOM）指令。
- en: With React, you can build SPAs, meaning that React is used to control the entire
    UI on all pages as well as the routing between pages.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React，你可以构建单页应用（SPAs），这意味着 React 用于控制所有页面上的整个 UI 以及页面间的路由。
- en: You can also use React, in combination with frameworks like Next.js, to build
    full-stack web applications where server- and client-side code are connected.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以结合 Next.js 等框架使用 React 来构建全栈 Web 应用程序，其中服务器端和客户端代码是连接在一起的。
- en: React projects can be created with the help of the Vite package, which provides
    a readily configured project folder and a live preview development server.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 Vite 包来创建 React 项目，它提供了一个预先配置好的项目文件夹和一个实时预览的开发服务器。
- en: What’s Next?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: At this point, you should have a basic understanding of what React is and why
    you might consider using it, especially for building non-trivial UIs. You learned
    how to create new React projects with Vite, and you are now ready to dive deeper
    into React and the actual key features it offers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对 React 是什么以及为什么你可能考虑使用它有一个基本的了解，尤其是对于构建非平凡的用户界面。你学习了如何使用 Vite 创建新的
    React 项目，现在你准备好更深入地了解 React 以及它提供的实际关键特性。
- en: In the next chapter, you will learn about a concept called **components** ,
    which are the fundamental building blocks of React apps. You will learn how components
    are used to compose UIs and why those components are needed in the first place.
    The next chapter will also dive deeper into JSX and explore how it is transformed
    into regular JavaScript code and which kind of code you could write alternatively
    to JSX.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习一个名为 **组件** 的概念，它们是 React 应用的基本构建块。你将了解组件是如何用来组合 UI 的，以及为什么最初需要这些组件。下一章还将更深入地探讨
    JSX，并探索它如何被转换成常规 JavaScript 代码，以及你可以用其他什么类型的代码来替代 JSX。
- en: Test Your Knowledge!
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge about the concepts covered in this chapter by answering
    the following questions. You can then compare your answers to example answers
    that can be found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/01-what-is-react/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/01-what-is-react/exercises/questions-answers.md)
    .'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后你可以将你的答案与这里可以找到的示例答案进行比较：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/01-what-is-react/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/01-what-is-react/exercises/questions-answers.md)。
- en: What is React?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 React？
- en: Which advantage does React offer over vanilla JavaScript projects?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 相比纯 JavaScript 项目有哪些优势？
- en: What’s the difference between imperative and declarative code?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令式代码和声明式代码有什么区别？
- en: What is a **Single-Page-Application** ( **SPA** )?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 **单页应用程序**（**SPA**）？
- en: How can you create new React projects and why do you need such a complex project
    setup?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建新的 React 项目，为什么你需要这样一个复杂的项目设置？
- en: Join Us on Discord
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord
- en: Read this book alongside other users, AI experts, and the author himself.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、AI 专家和作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，还有更多。
- en: Scan the QR code or visit the link to join the community.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描二维码或访问链接加入社区。
- en: '[https://packt.link/ReactKeyConcepts2e](https://packt.link/ReactKeyConcepts2e)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/ReactKeyConcepts2e](https://packt.link/ReactKeyConcepts2e)'
- en: '![img](img/QR_Code1044817876677025718.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code1044817876677025718.png)'
