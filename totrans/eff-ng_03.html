<html><head></head><body>
<div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.2.1">Enhancing Your Applications with Directives, Pipes, and Animations</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When building frontend applications, we often need to enhance, transform, add, remove, or replace DOM elements and values within HTML templates. </span><span class="koboSpan" id="kobo.3.2">The Angular framework facilitates this through the use of directives, pipes, and animations. </span><span class="koboSpan" id="kobo.3.3">This chapter will explain how to create and use directives, pipes, and animations within Angular. </span><span class="koboSpan" id="kobo.3.4">By the end of this chapter, you will know all the ins and outs of directives, from directive composition to creating directives with powerful selectors. </span><span class="koboSpan" id="kobo.3.5">You will also learn about making custom pipes and using the built-in pipes effectively. </span><span class="koboSpan" id="kobo.3.6">Lastly, we will explore how to build and reuse animations within applications built </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">using Angular.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Using and creating </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">Angular directives</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Transforming values using </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Angular pipes</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Creating and reusing </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">stunning animations</span></span></li>
</ul>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.13.1">Using and creating Angular directives</span></h1>
<p><span class="koboSpan" id="kobo.14.1">Directives come in two different types: </span><strong class="bold"><span class="koboSpan" id="kobo.15.1">attribute directives</span></strong><span class="koboSpan" id="kobo.16.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">structural directives</span></strong><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">Angular has a list of built-in directives</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.19.1"> and allows you to create your </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.20.1">own directive to cover your personal use cases. </span><span class="koboSpan" id="kobo.20.2">Since Angular 15, a new feature was introduced: </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">directive composition</span></strong><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">Directive </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.23.1">composition allows you to assign directives inside component decorators instead of their template. </span><span class="koboSpan" id="kobo.23.2">Directive composition can also be used to declare </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.24.1">directives inside the decorator of other directives, resulting in a directive that applies multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">directives simultaneously.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">When you want to use a directive in a standalone component, you need to add the directive to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">imports</span></strong><span class="koboSpan" id="kobo.28.1"> array of the component. </span><span class="koboSpan" id="kobo.28.2">If it’s a built-in directive, you can also import </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">CommonModule</span></strong><span class="koboSpan" id="kobo.30.1">, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">CommonModule</span></strong><span class="koboSpan" id="kobo.32.1"> contains all built-in directives. </span><span class="koboSpan" id="kobo.32.2">When you generate a component using the built-in Nx generator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">CommonModule</span></strong><span class="koboSpan" id="kobo.34.1"> is added by default. </span><span class="koboSpan" id="kobo.34.2">This section will </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.35.1">teach you everything about directives, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">attribute directives.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.37.1">Angular attribute directives</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.38.1">Attribute directives</span></strong><span class="koboSpan" id="kobo.39.1"> serve as tools for </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.40.1">modifying DOM elements’ attributes, behavior, or appearance. </span><span class="koboSpan" id="kobo.40.2">The directive makes modifications based on logic defined in a </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.41.1">class decorated with a directive decorator. </span><span class="koboSpan" id="kobo.41.2">Attribute directives are assigned by adding the selector of the attribute directive to the HTML tag </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.43.1">
&lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">appRedBackgroundHover</span></strong><span class="koboSpan" id="kobo.45.1">&gt;Highlight me!&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.46.1">In the preceding example, the selector of the directive selector is </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">appRedBackgroundHover</span></strong><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">When you use an attribute directive with an input, you use the square bracket syntax </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.50.1">
&lt;div [ngClass]="useRedStyles ? </span><span class="koboSpan" id="kobo.50.2">'red' : 'blue'"&gt;Click&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.51.1">In the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">ngClass</span></strong><span class="koboSpan" id="kobo.53.1"> is the attribute directive, and we add it between square brackets because it receives an input. </span><span class="koboSpan" id="kobo.53.2">Now that you know how to use attribute directives in HTML templates, let’s explore the most commonly used built-in attribute directives and, after that, create a custom </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">attribute directive.</span></span></p>
<h3><span class="koboSpan" id="kobo.55.1">Common built-in attribute directives</span></h3>
<p><span class="koboSpan" id="kobo.56.1">The most commonly used built-in attribute</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.57.1"> directives are </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">ngClass</span></strong><span class="koboSpan" id="kobo.60.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">class</span></strong><span class="koboSpan" id="kobo.62.1">: These directives are used to conditionally add </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">CSS classes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">ngStyle</span></strong><span class="koboSpan" id="kobo.65.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">style</span></strong><span class="koboSpan" id="kobo.67.1">: These directives are used to conditionally add </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">inline styling.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">ngModel</span></strong><span class="koboSpan" id="kobo.70.1">: This directive is used for two-way data binding on “</span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">from” elements.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.72.1">More built-in attribute directives exist, but these additional built-in directives belong to specific Angular packages, such </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.73.1">as </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">routerLink</span></strong><span class="koboSpan" id="kobo.75.1"> from</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.76.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">router</span></strong><span class="koboSpan" id="kobo.78.1"> package and </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">formGroup</span></strong><span class="koboSpan" id="kobo.80.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">forms</span></strong><span class="koboSpan" id="kobo.82.1"> package. </span><span class="koboSpan" id="kobo.82.2">We’ve seen </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">routerLink</span></strong><span class="koboSpan" id="kobo.84.1"> in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.85.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.86.1">, and we will learn more about directives from the </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.87.1">forms package in </span><a href="B21625_04.xhtml#_idTextAnchor072"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.88.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">Now, let us learn how to create custom </span><a id="_idIndexMarker288"/><span class="No-Break"><span class="koboSpan" id="kobo.90.1">attribute directives.</span></span></p>
<h3><span class="koboSpan" id="kobo.91.1">Creating custom attribute directives</span></h3>
<p><span class="koboSpan" id="kobo.92.1">We will start by creating a new</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.93.1"> library with our custom generator. </span><span class="koboSpan" id="kobo.93.2">Name the new library </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">common-directives</span></strong><span class="koboSpan" id="kobo.95.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">shared</span></strong><span class="koboSpan" id="kobo.97.1"> for the domain and </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">ui</span></strong><span class="koboSpan" id="kobo.99.1"> for the type. </span><span class="koboSpan" id="kobo.99.2">Next, we will use an Nx generator to create the directive for our new library. </span><span class="koboSpan" id="kobo.99.3">Go to </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">libs\shared\ui\common-directives\src\lib folder</span></strong><span class="koboSpan" id="kobo.101.1">, right-click, and select </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">Nx generate</span></strong><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">In the search bar, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">directive</span></strong><span class="koboSpan" id="kobo.105.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">@nx/angular – directive</span></strong><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">Now, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.109.1">Enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">highlight</span></strong><span class="koboSpan" id="kobo.111.1"> for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.112.1">name*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.113.1"> field.</span></span></li>
<li><span class="koboSpan" id="kobo.114.1">Click on </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">Show </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.116.1">all options</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.118.1">Check the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.119.1">standalone</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1"> checkbox.</span></span></li>
<li><span class="koboSpan" id="kobo.121.1">Click on </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">generate</span></strong><span class="koboSpan" id="kobo.123.1"> in the top right of </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">the window.</span></span></li>
<li><span class="koboSpan" id="kobo.125.1">When the directive is generated, export the directive in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">index.ts</span></strong><span class="koboSpan" id="kobo.127.1"> file of </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">the library:</span></span></li>
</ol>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
export * from './lib/highlight.directive';</span></pre> <p><span class="koboSpan" id="kobo.130.1">When you look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">highlight.directive.ts</span></strong><span class="koboSpan" id="kobo.132.1"> file, you will see an empty class with a directive decorator </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">above it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
@Directive({
  selector: ‹[btLibsUiHighlight]›,
  standalone: true,
}) export class HighlightDirective {}</span></pre> <p><span class="koboSpan" id="kobo.135.1">Inside the decorator, you’ll see the standalone flag set to true, indicating that the directive is standalone and doesn’t have to be included in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">NgModule</span></strong><span class="koboSpan" id="kobo.137.1">. </span><span class="koboSpan" id="kobo.137.2">Besides that, you’ll find the directive selector. </span><span class="koboSpan" id="kobo.137.3">The selector is used to apply </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">the directive.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Now, let’s add some logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">HighlightDirective</span></strong><span class="koboSpan" id="kobo.141.1"> class so that our directive does something. </span><span class="koboSpan" id="kobo.141.2">Start by injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">ElementRef</span></strong><span class="koboSpan" id="kobo.143.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">ElementRef</span></strong><span class="koboSpan" id="kobo.145.1"> gives you access to the host DOM element, the HTML elements applying the directive. </span><span class="koboSpan" id="kobo.145.2">After injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">ElementRef</span></strong><span class="koboSpan" id="kobo.147.1">, you need to</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.148.1"> use </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">ElementRef</span></strong><span class="koboSpan" id="kobo.150.1"> to adjust the host element that applies the directive. </span><span class="koboSpan" id="kobo.150.2">Here is an example highlighting the host element with a </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">background color:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
export class HighlightDirective implements OnInit {
  private </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">el = inject(ElementRef).nativeElement</span></strong><span class="koboSpan" id="kobo.154.1">;
  ngOnInit() { </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">this.el.style.backgroundColor = 'blue';</span></strong><span class="koboSpan" id="kobo.156.1">}}</span></pre> <p><span class="koboSpan" id="kobo.157.1">You can also inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">ElementRef</span></strong><span class="koboSpan" id="kobo.159.1"> by using constructor injection instead of the inject function and then add the background color and text color inside the function brackets of the constructor. </span><span class="koboSpan" id="kobo.159.2">Alternatively, if you only want to set a style, CSS class, or attribute on the host element, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">HostBinding()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.162.1"> decorator:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.163.1">@HostBinding</span></strong><span class="koboSpan" id="kobo.164.1">('style.backgroundColor') get color() { return 'red'; }</span></pre> <p><span class="koboSpan" id="kobo.165.1">Now, to apply this directive, you need to import it in a standalone component or NgModule and use the selector on an HTML element </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
&lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">btLibsUiHighlight</span></strong><span class="koboSpan" id="kobo.169.1">&gt;I'm highlighted&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.170.1">Let’s improve the directive and make it configurable with </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">@Input()</span></strong><span class="koboSpan" id="kobo.172.1"> decorators. </span><span class="koboSpan" id="kobo.172.2">The most common way to pass a value to a directive is to add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">@Input()</span></strong><span class="koboSpan" id="kobo.174.1"> with the same name as the directive selector. </span><span class="koboSpan" id="kobo.174.2">In our case, this would look </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
@Input() btLibsUiHighlight!: string;</span></pre> <p><span class="koboSpan" id="kobo.177.1">Now, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">btLibsUiHighlight</span></strong><span class="koboSpan" id="kobo.179.1"> property to assign the </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">background color:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
this.el.style.backgroundColor = this.btLibsUiHighlight;</span></pre> <p><span class="koboSpan" id="kobo.182.1">To give the directive input a value, you need to add square brackets around the directive when you declare it on an HTML element and give it the value </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">you want:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
&lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">[btLibsUiHighlight]="'orange'"</span></strong><span class="koboSpan" id="kobo.186.1">&gt;I'm highlighted&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.187.1">If you don’t like using the selector name in your TypeScript file but instead use a more descriptive property name, you can alias the input </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
@Input(</span><strong class="bold"><span class="koboSpan" id="kobo.190.1">'btLibsUiHighlight'</span></strong><span class="koboSpan" id="kobo.191.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">background</span></strong><span class="koboSpan" id="kobo.193.1">!: string;</span></pre> <p><span class="koboSpan" id="kobo.194.1">This will probably give you a lint error because aliasing inputs is not generally recommended. </span><span class="koboSpan" id="kobo.194.2">Still, you can disable the lint error in this scenario if you prefer a more descriptive </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">property name.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">If you also want to customize the text color, add another </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">@Input()</span></strong><span class="koboSpan" id="kobo.198.1"> property to the directive class. </span><span class="koboSpan" id="kobo.198.2">We will name the input property </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">textColor</span></strong><span class="koboSpan" id="kobo.200.1"> and assign it a default value </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">white</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
@Input() textColor = 'white';</span></pre> <p><span class="koboSpan" id="kobo.205.1">This is how you assign </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.206.1">additional inputs and their values in the </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
&lt;div [btLibsUiHighlight]="'orange'" </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">[textColor]="'blue'"</span></strong><span class="koboSpan" id="kobo.210.1">&gt; I'm Highlighted &lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.211.1">Declaring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">btLibsUiHighlight</span></strong><span class="koboSpan" id="kobo.213.1"> input is required; the additional inputs are optional, but remember to give them a default value; otherwise, you might run into errors or unwanted UI behavior. </span><span class="koboSpan" id="kobo.213.2">You can make both inputs optional with default values; you have to rename the inputs so that no input has the same name as the </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">directive selector:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
@Input() background = 'black';
@Input() textColor = 'white';</span></pre> <p><span class="koboSpan" id="kobo.216.1">Next, you change the directive on the HTML element by removing the square brackets and adding the additional inputs only if you want to overwrite the </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">default value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
&lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">btLibsUiHighlight</span></strong><span class="koboSpan" id="kobo.220.1"> [</span><strong class="bold"><span class="koboSpan" id="kobo.221.1">background</span></strong><span class="koboSpan" id="kobo.222.1">]="'orange'" [</span><strong class="bold"><span class="koboSpan" id="kobo.223.1">textColor</span></strong><span class="koboSpan" id="kobo.224.1">]="'blue'"&gt;I'm highlighted&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.225.1">Lastly, we will handle user events in our directive. </span><span class="koboSpan" id="kobo.225.2">When handling user events in a directive, you often want to listen to events on the host elements. </span><span class="koboSpan" id="kobo.225.3">You listen to host element events by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">@HostListner()</span></strong><span class="koboSpan" id="kobo.227.1"> directive. </span><span class="koboSpan" id="kobo.227.2">Inside the function brackets of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">@HostListner()</span></strong><span class="koboSpan" id="kobo.229.1"> directive, you need to add the browser event you want to listen for. </span><span class="koboSpan" id="kobo.229.2">This is how we can adjust our directive so it will apply the highlight for </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">mouseenter</span></strong><span class="koboSpan" id="kobo.231.1"> and restore the original text and background color </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">mouseleave</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
private el = inject(ElementRef).nativeElement;
private originalColor = 'black';
private originalBackground = 'white';
</span><strong class="bold"><span class="koboSpan" id="kobo.236.1">@HostListener('mouseenter')</span></strong><span class="koboSpan" id="kobo.237.1"> onMouseEnter() {
  this.originalColor = this.el.style.color;
  this.originalBackground = this.el.style.backgroundColor;
  this.el.style.backgroundColor = this.background;
  this.el.style.color = this.textColor;
}
</span><strong class="bold"><span class="koboSpan" id="kobo.238.1">@HostListener('mouseleave')</span></strong><span class="koboSpan" id="kobo.239.1"> onMouseLeave() {
  this.el.style.backgroundColor = this.originalBackground;
  this.el.style.color = this.originalColor;
}</span></pre> <p><span class="koboSpan" id="kobo.240.1">We’ve added a property to save the original background and text color to restore that for </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">mouseleave</span></strong><span class="koboSpan" id="kobo.242.1">. </span><span class="koboSpan" id="kobo.242.2">Lastly, we’ve added the host listeners so we can react to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">mouseenter</span></strong><span class="koboSpan" id="kobo.244.1"> and leave the events of the host element. </span><span class="koboSpan" id="kobo.244.2">We’ve added the logic to adjust the background and </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.245.1">text color inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">host listeners.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">Now that you know how to create custom attribute directives and enhance them with inputs and host listeners, let’s explore </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">structural directives.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.249.1">Angular structural directives</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.250.1">Structural directives</span></strong><span class="koboSpan" id="kobo.251.1"> represent a tool for </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.252.1">adding and removing DOM elements based on logic. </span><span class="koboSpan" id="kobo.252.2">The logic of when to add or </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.253.1">remove DOM elements is defined in the directive class. </span><span class="koboSpan" id="kobo.253.2">Defining structural directives in your HTML templates is achieved </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
&lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">*ngFor</span></strong><span class="koboSpan" id="kobo.257.1">="let item of list"&gt;{{item}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.258.1">In the preceding example, we applied the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">*ngFor</span></strong><span class="koboSpan" id="kobo.260.1"> directive; as you can see, it’s prefixed with an asterisk. </span><span class="koboSpan" id="kobo.260.2">This asterisk is typical for structural directives and helps you to distinguish them from attribute directives in your HTML templates. </span><span class="koboSpan" id="kobo.260.3">Another difference between structural and attribute directives is that you can declare multiple attribute directives on a DOM element but only one structural directive. </span><span class="koboSpan" id="kobo.260.4">If you want to apply multiple structural directives, you need to wrap the DOM element with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">ng-container</span></strong><span class="koboSpan" id="kobo.262.1"> tag and add the </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.263.1">additional directive to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ng-container</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.265.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
&lt;ng-container *ngIf="expression"&gt;
  &lt;div *ngFor=»let item of list»&gt;{{item}}&lt;/div&gt;
&lt;/ng-container&gt;</span></pre> <p><span class="koboSpan" id="kobo.267.1">Angular exposes built-in directives and allows you to create your own. </span><span class="koboSpan" id="kobo.267.2">First, let’s look at some common built-in </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">structural directives</span></span></p>
<h3><span class="koboSpan" id="kobo.269.1">Common built-in structural directives</span></h3>
<p><span class="koboSpan" id="kobo.270.1">The most commonly used built-in </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.271.1">structural directives </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.272.1">are </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">*ngIf</span></strong><span class="koboSpan" id="kobo.275.1">: This is used to conditionally show or hide DOM elements (alternatively (to the directive), you can use the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">@if</span></strong><span class="koboSpan" id="kobo.277.1"> control flow syntax, as shown in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.278.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.279.1">).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">*ngFor</span></strong><span class="koboSpan" id="kobo.281.1">: This is used to create a for loop in your HTML template and output a DOM element for each item in an array (alternatively (to the directive), you can use the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">@for</span></strong><span class="koboSpan" id="kobo.283.1"> control flow syntax, as shown in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.284.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.285.1">).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.287.1">: This is used to create a switch case in your HTML template and display the DOM elements for the matching switch case (alternatively (to the directive), you can use the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">@switch</span></strong><span class="koboSpan" id="kobo.289.1"> control flow syntax, as shown in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.290.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.291.1">).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.292.1">If you ever worked on an Angular application, you have most likely seen and used all of these structural directives before, as they are really common. </span><span class="koboSpan" id="kobo.292.2">Still, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">*ngIf</span></strong><span class="koboSpan" id="kobo.294.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">*ngFor</span></strong><span class="koboSpan" id="kobo.296.1"> directives have some additional, lesser-known properties that I want to explain and showcase. </span><span class="koboSpan" id="kobo.296.2">After that, we will create a custom </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">structural directive.</span></span></p>
<h4><span class="koboSpan" id="kobo.298.1">Using *ngIf to its fullest extent</span></h4>
<p><span class="koboSpan" id="kobo.299.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">*ngIf</span></strong><span class="koboSpan" id="kobo.301.1"> directive is used to display DOM elements conditionally. </span><span class="koboSpan" id="kobo.301.2">The DOM elements do not render unless the property or </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.302.1">statement is evaluated as </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">true</span></strong><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">Often, you need to</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.305.1"> display one block of HTML if the condition is </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">true</span></strong><span class="koboSpan" id="kobo.307.1"> and another if it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">false</span></strong><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">A common solution to this is to use two </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">*ngIf</span></strong><span class="koboSpan" id="kobo.311.1"> directives with an opposing statement </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
&lt;div *ngIf="showContent"&gt;Show if true&lt;/div&gt;
&lt;div *ngIf="!showContent"&gt;Show if false&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.314.1">This is perfectly valid and very readable syntax, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">*ngIf</span></strong><span class="koboSpan" id="kobo.316.1"> also allows you to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">if-else</span></strong><span class="koboSpan" id="kobo.318.1"> statement. </span><span class="koboSpan" id="kobo.318.2">You can do this with the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
&lt;div *ngIf="showContent; else elseBlock"&gt;Show if true&lt;/div&gt;
&lt;ng-template #elseBlock&gt;
  &lt;div&gt;Show if false&lt;/div&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.321.1">As you can see, this is a bit bulky in the HTML template because you need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">ng-template</span></strong><span class="koboSpan" id="kobo.323.1"> tag for the content shown when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">else</span></strong><span class="koboSpan" id="kobo.325.1"> statement is triggered. </span><span class="koboSpan" id="kobo.325.2">What syntax you want to use is up to you; there is no better or worse way; it’s more </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">about preference.</span></span></p>
<h4><span class="koboSpan" id="kobo.327.1">Using *ngFor effectively</span></h4>
<p><span class="koboSpan" id="kobo.328.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">*ngFor</span></strong><span class="koboSpan" id="kobo.330.1">, you can add many </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.331.1">properties to enhance the usage of the directive. </span><span class="koboSpan" id="kobo.331.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">*ngFor</span></strong><span class="koboSpan" id="kobo.333.1"> directive outputs DOM elements for each item in a list. </span><span class="koboSpan" id="kobo.333.2">Often, when</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.334.1"> you output DOM elements for a list, you want to know the current index, if something is the first or last element, or if it’s an odd or even index. </span><span class="koboSpan" id="kobo.334.2">Based on these values, you might want to add some styling classes or use specific properties in the template. </span><span class="koboSpan" id="kobo.334.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">*ngFor</span></strong><span class="koboSpan" id="kobo.336.1"> directive allows you to detect these values </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
&lt;div *ngFor="let item of list;
    let i = index; let isFirst = first;
    let isLast = last; let isEven = even; let isOdd = odd»
&gt;
  Item at index {{ i }}: {{ item }}
  Is first: {{ isFirst }} Is last: {{ isLast }}
  Is even: {{ isEven }} Is odd: {{ isOdd }}
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.339.1">As you can see, you can add variables to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">HTML</span></strong><span class="koboSpan" id="kobo.341.1"> tag that defines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">*ngFor</span></strong><span class="koboSpan" id="kobo.343.1"> directive to access values such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">index</span></strong><span class="koboSpan" id="kobo.345.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">first</span></strong><span class="koboSpan" id="kobo.347.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">last</span></strong><span class="koboSpan" id="kobo.349.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">odd</span></strong><span class="koboSpan" id="kobo.351.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">even</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">If our </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">list</span></strong><span class="koboSpan" id="kobo.355.1"> would be the</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.356.1"> following array: </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">[0, 1, 2, 3]</span></strong><span class="koboSpan" id="kobo.358.1">, then the preceding code </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.359.1">snippet would output the following result in </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">the browser:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
Item at index 0: 0 Is first: true Is last: false Is even: true Is odd: false
Item at index 1: 1 Is first: false Is last: false Is even: false Is odd: true
Item at index 2: 2 Is first: false Is last: false Is even: true Is odd: false
Item at index 3: 3 Is first: false Is last: true Is even: false Is odd: true</span></pre> <p><span class="koboSpan" id="kobo.362.1">Besides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">index</span></strong><span class="koboSpan" id="kobo.364.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">first</span></strong><span class="koboSpan" id="kobo.366.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">last</span></strong><span class="koboSpan" id="kobo.368.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">odd</span></strong><span class="koboSpan" id="kobo.370.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">even</span></strong><span class="koboSpan" id="kobo.372.1"> properties, </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">*ngFor</span></strong><span class="koboSpan" id="kobo.374.1"> also has something else to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">its performance.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">By default, when you render something with </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">*ngFor</span></strong><span class="koboSpan" id="kobo.378.1"> and something changes in the list, Angular will re-render the entire list. </span><span class="koboSpan" id="kobo.378.2">As you can imagine, this affects your performance negatively. </span><span class="koboSpan" id="kobo.378.3">You can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">trackBy</span></strong><span class="koboSpan" id="kobo.380.1"> function to improve this. </span><span class="koboSpan" id="kobo.380.2">When you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">trackBy</span></strong><span class="koboSpan" id="kobo.382.1"> function, Angular will identify each item by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">index</span></strong><span class="koboSpan" id="kobo.384.1"> or an </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">ID</span></strong><span class="koboSpan" id="kobo.386.1">. </span><span class="koboSpan" id="kobo.386.2">By doing so, it will only re-render things that change. </span><span class="koboSpan" id="kobo.386.3">It’s recommended that you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">trackBy</span></strong><span class="koboSpan" id="kobo.388.1"> function as much as possible. </span><span class="koboSpan" id="kobo.388.2">In the template, you can define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">trackBy</span></strong><span class="koboSpan" id="kobo.390.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
&lt;div *ngFor="let item of users; </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">trackBy: trackByFunction"&gt;</span></strong><span class="koboSpan" id="kobo.394.1">
{{ item }} &lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.395.1">In your component class, you can define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">trackBy</span></strong><span class="koboSpan" id="kobo.397.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
trackByFunction(index, user) { return user.id; }</span></pre> <p><span class="koboSpan" id="kobo.400.1">Now that you know about the</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.401.1"> hidden features of </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">*ngIf</span></strong><span class="koboSpan" id="kobo.403.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">*ngFor</span></strong><span class="koboSpan" id="kobo.405.1">, let’s see how you can create custom </span><a id="_idIndexMarker305"/><span class="No-Break"><span class="koboSpan" id="kobo.406.1">structural directives.</span></span></p>
<h3><span class="koboSpan" id="kobo.407.1">Creating custom structural directives</span></h3>
<p><span class="koboSpan" id="kobo.408.1">Creating your own structural directives is similar to creating attribute directives, but the directive class has some critical differences. </span><span class="koboSpan" id="kobo.408.2">In addition, the use cases are different. </span><span class="koboSpan" id="kobo.408.3">Custom attribute directives are </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.409.1">useful for things such as auto-focusing on elements, applying different themes to specific elements, highlights, text resizing, tooltips, and popovers, as well as adding CSS classes, aria attributes, or IDs. </span><span class="koboSpan" id="kobo.409.2">Custom structural directives are used to remove or add DOM elements; some good use cases are an </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">if false</span></strong><span class="koboSpan" id="kobo.411.1"> directive, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">"repeat x number of times"</span></strong><span class="koboSpan" id="kobo.413.1"> function, and showing or hiding elements based on permissions or specific </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">window sizes.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">We will create a custom directive that shows an element when a condition is false, which is basically the opposite of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">*ngIf</span></strong><span class="koboSpan" id="kobo.417.1"> directive. </span><span class="koboSpan" id="kobo.417.2">Start by generating the directive using the same steps we used for generating the custom attribute directive (see the </span><em class="italic"><span class="koboSpan" id="kobo.418.1">Creating custom attribute directives</span></em><span class="koboSpan" id="kobo.419.1"> section). </span><span class="koboSpan" id="kobo.419.2">The only difference will be the name; this time, name the </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">directive </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">ifFalse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">When your directive class is generated, you can start to add the logic for your structural directive. </span><span class="koboSpan" id="kobo.423.2">In the attribute directive, you injected </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">ElementRef</span></strong><span class="koboSpan" id="kobo.425.1">; for the structural directive, you must inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.427.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">ViewContainerRef</span></strong><span class="koboSpan" id="kobo.429.1">. </span><span class="koboSpan" id="kobo.429.2">When you add a structural directive to an HTML element, Angular will convert it into an embedded template using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">ng-template</span></strong><span class="koboSpan" id="kobo.431.1"> tags </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
&lt;ng-template [ ngIf ]="condition"&gt;
  &lt;div&gt;Shown when condition is true&lt;/div&gt;
&lt;/ng-template&gt;</span></pre> <p><span class="koboSpan" id="kobo.434.1">The embedded template created by Angular is what you access with </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">The embedded template is not rendered unless the structural directives adds it to the view container using </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">ViewContainerRef</span></strong><span class="koboSpan" id="kobo.438.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">ViewContainerRef</span></strong><span class="koboSpan" id="kobo.440.1"> gives you access to the view where the host element with the directive </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">is defined.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">Let’s start by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.444.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">ViewContainerRef</span></strong><span class="koboSpan" id="kobo.446.1"> to your directive class. </span><span class="koboSpan" id="kobo.446.2">You can inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.448.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">ViewContainerRef</span></strong><span class="koboSpan" id="kobo.450.1"> by using constructor injection or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">inject</span></strong><span class="koboSpan" id="kobo.452.1"> function; I will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">inject</span></strong><span class="koboSpan" id="kobo.454.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
private templateRef = inject(TemplateRef);
private viewContainer = inject(ViewContainerRef);</span></pre> <p><span class="koboSpan" id="kobo.457.1">We must also track if we already added the embedded view to the view container. </span><span class="koboSpan" id="kobo.457.2">To do this, add another private property to the </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">directive class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
private embeddedTemplateAdded = false;</span></pre> <p><span class="koboSpan" id="kobo.460.1">Next, we need an </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">@Input()</span></strong><span class="koboSpan" id="kobo.462.1"> for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">if false</span></strong><span class="koboSpan" id="kobo.464.1"> directive so we can give it a condition to assess. </span><span class="koboSpan" id="kobo.464.2">We will use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">@Input()</span></strong><span class="koboSpan" id="kobo.466.1"> setter, so each time, it receives a new value; we can perform the logic to</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.467.1"> add or remove the embedded template to the view when the condition is evaluated. </span><span class="koboSpan" id="kobo.467.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">@Input()</span></strong><span class="koboSpan" id="kobo.469.1"> setter needs to have the same name as the </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">directive selector:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
@Input() set btLibsUiIfFalse(condition: boolean) {}</span></pre> <p><span class="koboSpan" id="kobo.472.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">@Input()</span></strong><span class="koboSpan" id="kobo.474.1"> setter, we will add the embedded template as an embedded view of the view container if the condition evaluates as </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">false</span></strong><span class="koboSpan" id="kobo.476.1"> and if we have not already added it to the embedded template. </span><span class="koboSpan" id="kobo.476.2">In the case of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">if false</span></strong><span class="koboSpan" id="kobo.478.1"> directive, when the condition evaluates to true, and considering we have already added the embedded template, we want to clear the view container so that the previously added embedded view is removed and Angular renders the original HTML again without the additional embedded template added to it. </span><span class="koboSpan" id="kobo.478.2">To achieve this, you can change </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">@Input()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.480.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
@Input() set btLibsUiIfFalse(condition: boolean) {
 if (!condition &amp;&amp; !this.embeddedTemplateAdded) {
   this.viewContainer.createEmbeddedView(this.templateRef);
   this.embeddedTemplateAdded = true;
 } else if (condition &amp;&amp; this.embeddedTemplateAdded) {
   this.viewContainer.clear();
   this.embeddedTemplateAdded = false;
 }}</span></pre> <p><span class="koboSpan" id="kobo.482.1">As you can see, we add </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">TemplateRef</span></strong><span class="koboSpan" id="kobo.484.1"> as an embedded view when our check passes; otherwise, we clear the view container, given that we already </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">added </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">TemplateRef</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">We can now use our custom structural directive like any other directive by using the directive selector with an asterisk in front </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">of it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
&lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">*btLibsUiIfFalse</span></strong><span class="koboSpan" id="kobo.492.1">="condition"&gt;shown when false&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.493.1">Now that you know how to use built-in and create custom attribute and structural directives, let’s learn what </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.494.1">you can do with </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">directive selectors.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.496.1">Directive selectors</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.497.1">Directive selectors</span></strong><span class="koboSpan" id="kobo.498.1"> can be used to make your custom directives even more powerful. </span><span class="koboSpan" id="kobo.498.2">They allow you to automatically assign</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.499.1"> directives or limit the HTML elements that can use the directive. </span><span class="koboSpan" id="kobo.499.2">Let’s take our </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.500.1">custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">btLibsUiHighlight</span></strong><span class="koboSpan" id="kobo.502.1"> directive and change the selector so that it will be applied to all span elements </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">by default:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.504.1">
selector: 'span, [btLibsUiHighlight]',</span></pre> <p><span class="koboSpan" id="kobo.505.1">When you use the preceding example as a selector, the directive will automatically be applied to all span elements, and you can add it to other elements using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">btLibsUiHighlight</span></strong><span class="koboSpan" id="kobo.507.1"> selector. </span><span class="koboSpan" id="kobo.507.2">Now, let’s say you need an option to exclude some span elements, so by default, all span elements receive the highlight directive, but when you want to opt-out, you can. </span><span class="koboSpan" id="kobo.507.3">To achieve this, you can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">:not</span></strong><span class="koboSpan" id="kobo.509.1"> syntax to the selector </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
selector: 'span:not([noHighlight]), [btLibsUiHighlight]',</span></pre> <p><span class="koboSpan" id="kobo.512.1">Now, all span elements will have the highlight directive applied unless you add </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">noHighlight</span></strong><span class="koboSpan" id="kobo.514.1"> to a span element. </span><span class="koboSpan" id="kobo.514.2">For all other elements, you still need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">btLibsUiHighlight</span></strong><span class="koboSpan" id="kobo.516.1"> to apply </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">the directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.518.1">
&lt;span noHighlight&gt;Test&lt;/span&gt;</span></pre> <p><span class="koboSpan" id="kobo.519.1">If you want to exclude HTML elements, you can achieve this using your selector by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">:not</span></strong><span class="koboSpan" id="kobo.521.1"> syntax </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
selector: '[btLibsUiHighlight]:not(label)',</span></pre> <p><span class="koboSpan" id="kobo.524.1">When you use the preceding selector, you can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">btLibsUiHighlight</span></strong><span class="koboSpan" id="kobo.526.1"> directive to all elements but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">label</span></strong><span class="koboSpan" id="kobo.528.1"> element. </span><span class="koboSpan" id="kobo.528.2">When you try to add the directive to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">label</span></strong><span class="koboSpan" id="kobo.530.1"> element, the compiler will throw up </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">an error.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">You can also make</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.533.1"> selectors that apply directives to HTML elements with a specific ID, data attribute, or CSS class applied to the HTML element. </span><span class="koboSpan" id="kobo.533.2">Here is an example for all three of </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">these options:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1">
selector: '#someId, .someCssClass, [data-highlight="true"]'</span></pre> <p><span class="koboSpan" id="kobo.536.1">Now that you know everything you need to know about built-in directives, custom directives, and directive selectors, let’s move on and learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">directive composition.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.538.1">Angular directive composition</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.539.1">Directive composition</span></strong><span class="koboSpan" id="kobo.540.1"> is a relatively new concept that was introduced in Angular version 15. </span><span class="koboSpan" id="kobo.540.2">As the word indicates, directive </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.541.1">composition lets you compose different directives on components and directives. </span><span class="koboSpan" id="kobo.541.2">It lets you declare directives in component and directive class decorators instead of adding them using HTML templates. </span><span class="koboSpan" id="kobo.541.3">You</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.542.1"> can use directive composition to automatically apply directives to components, just like directive selectors. </span><span class="koboSpan" id="kobo.542.2">Directive composition can also be used to create directives that apply multiple directives using a </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">single selector.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">Let’s say we have a tag and button component and a type and size directive, allowing you to set a type (primary or secondary) and size (small, medium, or large), which applies a specific CSS class to the host element. </span><span class="koboSpan" id="kobo.544.2">If you want to automatically apply these two directives to all your buttons and tags, you can use directive composition to achieve this. </span><span class="koboSpan" id="kobo.544.3">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">hostDirectives</span></strong><span class="koboSpan" id="kobo.546.1"> array inside the component decorator to add the directives to the component. </span><span class="koboSpan" id="kobo.546.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">hostDirectives</span></strong><span class="koboSpan" id="kobo.548.1"> array, you can add objects with the directive and the inputs for the decorator. </span><span class="koboSpan" id="kobo.548.2">If the decorator has no inputs, you can add the decorator class to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">hostDirectives</span></strong><span class="koboSpan" id="kobo.550.1"> array. </span><span class="koboSpan" id="kobo.550.2">If you always want to use the input’s default value (given the input has a default value), you don’t have to declare the input in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">hostDirectives</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.552.1"> array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
@Component({ ………, hostDirectives: [
{directive: TypeDirective, inputs: ['btLibsUiType']},
{directive: SizeDirective, inputs: ['btLibsUiSizeType']}]})
export class ButtonComponent { }</span></pre> <p><span class="koboSpan" id="kobo.554.1">After defining the objects in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">hostDirectives</span></strong><span class="koboSpan" id="kobo.556.1"> array, the two directives will be applied automatically when you declare the button or tag component in a template. </span><span class="koboSpan" id="kobo.556.2">When using directive </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.557.1">composition, you can also alias the input values of </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">the directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
{directive: TypeDirective, inputs: ['btLibsUiType: style']}</span></pre> <p><span class="koboSpan" id="kobo.560.1">Now, in your HTML templates, if you want to supply a value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">btLibsUiType</span></strong><span class="koboSpan" id="kobo.562.1"> input of </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">TypeDirective</span></strong><span class="koboSpan" id="kobo.564.1">, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.566.1">
&lt;bt-libs-button [style]="'secondary'"&gt;XX&lt;/bt-libs-button&gt;</span></pre> <p><span class="koboSpan" id="kobo.567.1">Using directive composition inside directives works the same as in components. </span><span class="koboSpan" id="kobo.567.2">Let’s say we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">backgroundColorDirective</span></strong><span class="koboSpan" id="kobo.569.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">textColorDirective</span></strong><span class="koboSpan" id="kobo.571.1">; we can declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">textColorDirective</span></strong><span class="koboSpan" id="kobo.573.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">hostDirectives</span></strong><span class="koboSpan" id="kobo.575.1"> array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">backgroundColorDirective</span></strong><span class="koboSpan" id="kobo.577.1">. </span><span class="koboSpan" id="kobo.577.2">Now, when you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">backgroundColorDirective</span></strong><span class="koboSpan" id="kobo.579.1">, both directives will be applied, and the inputs of both directives will be exposed, given that you defined the inputs of </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">textColorDirective</span></strong><span class="koboSpan" id="kobo.581.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">hostDirectives</span></strong><span class="koboSpan" id="kobo.583.1"> array </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">backgroundColorDirective</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">When using directive </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.588.1">composition, you need to use standalone directives. </span><span class="koboSpan" id="kobo.588.2">Otherwise, it will not work. </span><span class="koboSpan" id="kobo.588.3">Also, each time a component is created, a new instance of all the directives declared in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">hostDirectives</span></strong><span class="koboSpan" id="kobo.590.1"> array will be created. </span><span class="koboSpan" id="kobo.590.2">Because a new instance of each directive is created for each instance of the host component, you must be careful when using directive composition. </span><span class="koboSpan" id="kobo.590.3">When you put too many directives inside commonly used components, your memory usage will blow up and negatively affect the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">In this section, you learned about attribute directives, structural directives, directive selectors, and directive composition. </span><span class="koboSpan" id="kobo.592.2">We will now move on to the next section of this chapter and start to learn more about transforming values by using </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">Angular pipes.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.594.1">Transforming values using Angular pipes</span></h1>
<p><span class="koboSpan" id="kobo.595.1">In Angular, </span><strong class="bold"><span class="koboSpan" id="kobo.596.1">pipes</span></strong><span class="koboSpan" id="kobo.597.1"> are used to transform </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.598.1">values. </span><span class="koboSpan" id="kobo.598.2">Angular offers a lot of useful built-in pipes and allows you to create your own. </span><span class="koboSpan" id="kobo.598.3">Let’s first list the most powerful and commonly used built-in pipes and briefly explain what they are </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">used for:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.601.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.603.1"> is used to handle asynchronous values in your templates. </span><span class="koboSpan" id="kobo.603.2">It automatically subscribes</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.604.1"> to an </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">observable</span></strong><span class="koboSpan" id="kobo.606.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">promise</span></strong><span class="koboSpan" id="kobo.608.1"> and returns the latest value emitted by the</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.609.1"> observable or promise. </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.611.1"> unsubscribe automatically because this prevents memory leaks. </span><span class="koboSpan" id="kobo.611.2">It’s recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.613.1"> as much </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">as possible.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">UpperCasePipe</span></strong><span class="koboSpan" id="kobo.616.1">: This </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.617.1">pipe is used to transform a text value into all </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">uppercase characters.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">LowerCasePipe</span></strong><span class="koboSpan" id="kobo.620.1">: This pipe is used to transform a text value into all </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">lowercase characters.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">TitleCasePipe</span></strong><span class="koboSpan" id="kobo.623.1">: This pipe is used to capitalize the first letter of </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">each word.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">CurrencyPipe</span></strong><span class="koboSpan" id="kobo.626.1">: This pipe is used to transform a number value into a currency value with a currency symbol. </span><span class="koboSpan" id="kobo.626.2">You can also control the </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">decimal formatting.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">DatePipe</span></strong><span class="koboSpan" id="kobo.629.1">: This is used to format date values based on the format </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">you specify.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.631.1">If you want to explore all the built-in pipes, you can find a complete list at this </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">URL: </span></span><a href="https://angular.io/guide/pipes"><span class="No-Break"><span class="koboSpan" id="kobo.633.1">https://angular.io/guide/pipes</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.634.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">Now that you know about the most commonly used built-in pipes, let’s see how you can </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">use pipes.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.637.1">Using pipes in HTML templates and TypeScript files</span></h2>
<p><span class="koboSpan" id="kobo.638.1">Pipes are commonly used in HTML templates, but you can also use them in your TypeScript files. </span><span class="koboSpan" id="kobo.638.2">To </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.639.1">use pipes in HTML</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.640.1"> templates, you </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.641.1">can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
&lt;div&gt;{{currentDate | date}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.644.1">On the left side, you have a property or value; then, you indicate that you’re going to use a pipe with the vertical bar (pipe symbol: </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">|</span></strong><span class="koboSpan" id="kobo.646.1">), and on the right side of the pipe symbol, you declare the name of the pipe you want to use; in our example, it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">date</span></strong><span class="koboSpan" id="kobo.648.1">. </span><span class="koboSpan" id="kobo.648.2">If your pipe takes a parameter, you supply the parameter by adding a colon and the value </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.650.1">
&lt;div&gt;{{currentDate | date: 'YYYY-MM-dd'}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.651.1">When a pipe takes more than</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.652.1"> one parameter, you can chain them </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.653.1">together by adding another colon and append the value after the colon </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.655.1">
&lt;div&gt;{{currentDate | date: 'YYYY-MM-dd':'GMT'}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.656.1">You can chain multiple</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.657.1"> pipes to a value if you need to apply them. </span><span class="koboSpan" id="kobo.657.2">When you chain pipes, they will be executed one by one, from left to right. </span><span class="koboSpan" id="kobo.657.3">Chaining pipes is done using the </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.659.1">
&lt;div&gt;{{currentDate | date: 'YYYY-MM-dd' | uppercase}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.660.1">As mentioned before, you can also use pipes inside your TypeScript files. </span><span class="koboSpan" id="kobo.660.2">Although pipes are mostly used inside HTML templates, they can also be useful inside your TypeScript files. </span><span class="koboSpan" id="kobo.660.3">You can add pipes to the providers array of your component and then inject the pipes using dependency injection. </span><span class="koboSpan" id="kobo.660.4">After injecting the pipe, you can use it in your component class by calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">transform</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.662.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
const formattedDate = this.datePipe.transform(this.currentDate, 'dd/MM/yyyy');</span></pre> <p><span class="koboSpan" id="kobo.664.1">When using standalone components (as we are doing), you need to import the pipe into the component before you can use the pipe. </span><span class="koboSpan" id="kobo.664.2">You can either import </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">CommonModule</span></strong><span class="koboSpan" id="kobo.666.1">, which contains all the pipes, or import the specific pipe if it’s a simple component and you don’t need </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">CommonModule</span></strong><span class="koboSpan" id="kobo.668.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">other purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Now that you know how to use pipes in your HTML templates and TypeScript files, let’s learn about pure and </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">impure pipes.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.672.1">Is it pure or impure?</span></h2>
<p><span class="koboSpan" id="kobo.673.1">Angular pipes come in two flavors: </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">pure</span></strong><span class="koboSpan" id="kobo.675.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">impure</span></strong><span class="koboSpan" id="kobo.677.1"> pipes. </span><span class="koboSpan" id="kobo.677.2">It’s important to understand the difference</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.678.1"> between the two because it can affect your application’s performance and</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.679.1"> expected behavior. </span><span class="koboSpan" id="kobo.679.2">By default, pipes are pure unless you add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">pure false</span></strong><span class="koboSpan" id="kobo.681.1"> flag. </span><span class="koboSpan" id="kobo.681.2">The difference between pure and impure pipes lies in their update behavior and how Angular runs change detection </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">on them.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">You need to use a pure transform function when creating a pure pipe. </span><span class="koboSpan" id="kobo.683.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.684.1">pure function</span></strong><span class="koboSpan" id="kobo.685.1"> is a function that always returns the same output when given the </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">same input.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">Angular only runs a pure pipe when a pure change in the input value is detected. </span><span class="koboSpan" id="kobo.687.2">Pure changes are changes to a primitive value (number, string, Boolean, bigint, symbol, undefined, and null) or when a new reference object is supplied (date, array, function, or object). </span><span class="koboSpan" id="kobo.687.3">Changes to a reference object are not seen as pure changes. </span><span class="koboSpan" id="kobo.687.4">So, if you have a pure pipe that takes an array as a value, updating the array will not trigger the pipe because this is an impure change. </span><span class="koboSpan" id="kobo.687.5">When </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.688.1">you assign the property using a new array, the pipe will run because it</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.689.1"> receives a new reference object instead, which is a </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">pure change.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">Angular skips updates of reference objects when running pure pipes because detecting pure changes is much faster than performing deep checks on objects; because of this, Angular can quickly determine if your pipes need to be executed again or if the pipe can be skipped. </span><span class="koboSpan" id="kobo.691.2">If Angular had to do a deep check or run your pipes on each change detection cycle, it would hugely impact the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">So, remember that when you use pure pipes with reference objects, you might not always get what you expect unless you know what you’re doing. </span><span class="koboSpan" id="kobo.693.2">For example, suppose that you have a dashboard array and a pipe that filters the array only to include active dashboards </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.695.1">
&lt;div *ngFor="let dashboard of dashboards | active"&gt;
    {{dashboard.name}}
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.696.1">Now, when updating the dashboard array with </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">push</span></strong><span class="koboSpan" id="kobo.698.1">, the pipe will not run because the reference of the dashboard array did not change. </span><span class="koboSpan" id="kobo.698.2">If you assign a dashboard’s property using a new array, the reference changes and Angular’s change detection will trigger the active pipe and filter the results </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">When using an impure pipe, Angular will execute the pipe each time it detects a change. </span><span class="koboSpan" id="kobo.700.2">This means Angular will run the pipe upon each keystroke or mouse movement. </span><span class="koboSpan" id="kobo.700.3">Impure pipes can be useful and will update reference objects as expected, but be careful when using impure pipes, as they can dramatically slow down your application. </span><span class="koboSpan" id="kobo.700.4">When you use impure pipes, you want to set the change detection strategy of your component to </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">OnPush</span></strong><span class="koboSpan" id="kobo.702.1"> so that your pipes will not be executed too often. </span><span class="koboSpan" id="kobo.702.2">When the component change detection is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">OnPush</span></strong><span class="koboSpan" id="kobo.704.1">, change detection will only run when the component receives new input values or when you trigger it manually. </span><span class="koboSpan" id="kobo.704.2">It’s good practice to set your change detection strategy to </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">OnPush</span></strong><span class="koboSpan" id="kobo.706.1"> as much as possible, as it will help improve your </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">application’s performance.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">Now that you understand the</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.709.1"> difference between pure and impure pipes, let’s learn more </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.710.1">about </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.712.1">, as it is the most important built-in pipe Angular provides us with. </span><span class="koboSpan" id="kobo.712.2">After learning about </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.714.1">, we will learn how to create </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">custom pipes.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.716.1">Using AsyncPipe</span></h2>
<p><span class="koboSpan" id="kobo.717.1">The most powerful built-in pipe is </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.719.1">. </span><span class="koboSpan" id="kobo.719.2">Even though </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.721.1"> is an impure pipe, it’s recommended to use it as </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.722.1">much as possible to handle the observable and promise results used in your templates. </span><span class="koboSpan" id="kobo.722.2">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.724.1"> offers advantages over handling observables with subscriptions in your </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">component class.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">First, </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.728.1"> subscribes and, more importantly, unsubscribes to observables automatically. </span><span class="koboSpan" id="kobo.728.2">This is very important because it prevents memory leaks. </span><span class="koboSpan" id="kobo.728.3">If you don’t clean up a subscription correctly, you will end up with memory leaks, and your application will start to slow down and show unexpected behavior up to the point </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">of crashing.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">To demonstrate </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.732.1">, we will create an observable in the component class using the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">interval</span></strong><span class="koboSpan" id="kobo.734.1"> operator </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.736.1">
timer: Observable&lt;number&gt; = interval(2000);</span></pre> <p><span class="koboSpan" id="kobo.737.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">interval</span></strong><span class="koboSpan" id="kobo.739.1"> observable will emit the next index every 2 seconds, starting at </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">0</span></strong><span class="koboSpan" id="kobo.741.1">. </span><span class="koboSpan" id="kobo.741.2">So, after 2 seconds, the observable emits </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">0</span></strong><span class="koboSpan" id="kobo.743.1">, and after another 2 seconds, the observable emits </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">1</span></strong><span class="koboSpan" id="kobo.745.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">We can subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">interval</span></strong><span class="koboSpan" id="kobo.749.1"> observable inside the component class and assign the result to a component property that we display inside </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
this.timer.subscribe((n) =&gt; { this.count = n; });</span></pre> <p><span class="koboSpan" id="kobo.752.1">Next, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">count</span></strong><span class="koboSpan" id="kobo.754.1"> property inside </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">your template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.756.1">
&lt;div&gt;{{count}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.757.1">If you’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">OnPush</span></strong><span class="koboSpan" id="kobo.759.1"> change detection for your component, you need to call a change detection manually each time the observable receives a new value. </span><span class="koboSpan" id="kobo.759.2">Otherwise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">count</span></strong><span class="koboSpan" id="kobo.761.1"> property will not be updated in your template. </span><span class="koboSpan" id="kobo.761.2">When using the aforementioned approach, you must also add logic to unsubscribe from your observable when the component is destroyed</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.762.1"> or when the observable property is assigned to another observable. </span><span class="koboSpan" id="kobo.762.2">Now, let’s see how we can use the interval observable in our HTML template </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">AsyncPipe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.766.1">
&lt;div&gt;{{timer | async}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.767.1">As you can see, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.769.1"> is simple. </span><span class="koboSpan" id="kobo.769.2">You declare the property assigned using the observable (in our case, it’s named </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">timer</span></strong><span class="koboSpan" id="kobo.771.1">) and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.773.1"> next to it. </span><span class="koboSpan" id="kobo.773.2">Each time the interval observable emits a new value, it will be reflected in our template. </span><span class="koboSpan" id="kobo.773.3">There is no need for an extra property to save the observable result, no need to unsubscribe, and there is no risk of memory leaks! </span><span class="koboSpan" id="kobo.773.4">Even when you assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">timer</span></strong><span class="koboSpan" id="kobo.775.1"> property using a new observable, the async pipe will automatically unsubscribe from the old observable and subscribe to the </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">new observable.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">When using the async pipe, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">OnPush</span></strong><span class="koboSpan" id="kobo.779.1"> change detection is recommended because </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.781.1"> is impure. </span><span class="koboSpan" id="kobo.781.2">Another advantage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.783.1"> is that it automatically marks the component template that needs to be checked for changes when the pipe receives a new value. </span><span class="koboSpan" id="kobo.783.2">This is useful when you set your change detection strategy to </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">OnPush</span></strong><span class="koboSpan" id="kobo.785.1">. </span><span class="koboSpan" id="kobo.785.2">When using a regular observable subscription, the HTML template is not marketed to be checked for changes if you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">OnPush</span></strong><span class="koboSpan" id="kobo.787.1"> strategy, meaning you have to trigger the change detection manually after your subscription receives a </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">new value.</span></span></p>
<p><span class="koboSpan" id="kobo.789.1">Now you know more about </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">AsyncPipe</span></strong><span class="koboSpan" id="kobo.791.1"> and why it’s such a powerful tool, let’s explore how you can create your </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">own pipes.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.793.1">Building your own pipes</span></h2>
<p><span class="koboSpan" id="kobo.794.1">When creating pipes in our Nx monorepo, we will do so in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">util</span></strong><span class="koboSpan" id="kobo.796.1"> library. </span><span class="koboSpan" id="kobo.796.2">For our example, we will create a </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.797.1">simple pipe that will multiply a number using a specified factor. </span><span class="koboSpan" id="kobo.797.2">The correct place to create this pipe is in a library under the shared domain and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">util</span></strong><span class="koboSpan" id="kobo.799.1"> type. </span><span class="koboSpan" id="kobo.799.2">Use our custom generator to create a new library with the name: </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">common-pipes</span></strong><span class="koboSpan" id="kobo.801.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.802.1">shared</span></strong><span class="koboSpan" id="kobo.803.1"> as its domain and </span><strong class="bold"><span class="koboSpan" id="kobo.804.1">util</span></strong><span class="koboSpan" id="kobo.805.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">its type.</span></span></p>
<p><span class="koboSpan" id="kobo.807.1">When your new library is generated, follow these steps to generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">custom pipe:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.809.1">Close and reopen VSCode so that your new library is included in the </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">Nx schematics.</span></span></li>
<li><span class="koboSpan" id="kobo.811.1">Right-click on the folder at this location: </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">libs\shared\util\common-pipes\src\lib</span></strong><span class="koboSpan" id="kobo.813.1">, and select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.814.1">Nx generate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.816.1">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">pipe</span></strong><span class="koboSpan" id="kobo.818.1"> and click on </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">@nx/angular – </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.820.1">pipe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.822.1">Enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">multiply</span></strong><span class="koboSpan" id="kobo.824.1"> for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.825.1">name*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.826.1"> field.</span></span></li>
<li><span class="koboSpan" id="kobo.827.1">Click on </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">Show </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.829.1">all options</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.831.1">Check the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.832.1">standalone</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.833.1"> checkbox.</span></span></li>
<li><span class="koboSpan" id="kobo.834.1">Click on </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">Generate</span></strong><span class="koboSpan" id="kobo.836.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">top right.</span></span></li>
<li><span class="koboSpan" id="kobo.838.1">After the component is</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.839.1"> generated, add the following to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">index.ts</span></strong><span class="koboSpan" id="kobo.841.1"> file in </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">the library:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.843.1">
export * from './lib/multiply.pipe';</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.844.1">After that, you can use your pipe, but before using it, let’s add </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">some logic.</span></span></p>
<p><span class="koboSpan" id="kobo.846.1">When you open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">multiply.pipe.ts</span></strong><span class="koboSpan" id="kobo.848.1"> file, you’ll see that Nx generated a </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">MultiplyPipe</span></strong><span class="koboSpan" id="kobo.850.1"> class, which implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">PipeTransform</span></strong><span class="koboSpan" id="kobo.852.1"> interface. </span><span class="koboSpan" id="kobo.852.2">The class is also decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">@Pipe()</span></strong><span class="koboSpan" id="kobo.854.1"> decorator, where the standalone flag is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">true</span></strong><span class="koboSpan" id="kobo.856.1"> and the pipe name </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">multiply</span></strong><span class="koboSpan" id="kobo.858.1"> is defined. </span><span class="koboSpan" id="kobo.858.2">Inside this decorator, you can add the pure flag; your pipe is pure by default. </span><span class="koboSpan" id="kobo.858.3">You only have to add the pure flag with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">false</span></strong><span class="koboSpan" id="kobo.860.1"> value when you want to create an impure pipe. </span><span class="koboSpan" id="kobo.860.2">In our example, we will create a simple, pure pipe, so there is no need to add the pure flag to </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">the decorator.</span></span></p>
<p><span class="koboSpan" id="kobo.862.1">Nx also added a transform function to the class to adhere to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">PipeTransform</span></strong><span class="koboSpan" id="kobo.864.1"> interface. </span><span class="koboSpan" id="kobo.864.2">The transform function is the “hard” of your pipe, where you add your transformation logic. </span><span class="koboSpan" id="kobo.864.3">You can adjust the transform function </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.866.1">
transform(value: number, multiplier = 2): number {
  return value * multiplier;
}</span></pre> <p><span class="koboSpan" id="kobo.867.1">As you can see, we have a value and a multiplier function parameter. </span><span class="koboSpan" id="kobo.867.2">The value parameter is what we declare on the left side of the pipe in our HTML templates. </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">multiplier</span></strong><span class="koboSpan" id="kobo.869.1"> is the parameter we supply after the colon. </span><span class="koboSpan" id="kobo.869.2">We gave </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">multiplier</span></strong><span class="koboSpan" id="kobo.871.1"> a default value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">2</span></strong><span class="koboSpan" id="kobo.873.1">, so it’s optional when declaring the pipe in </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">your templates.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">When you want to use the pipe, you first need to import it; if you work with NgModules, the pipe needs to be imported in</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.876.1"> an NgModules instance; if you work with standalone components, like we are doing here, you have to import the pipe into the components you want to use it in. </span><span class="koboSpan" id="kobo.876.2">After you import the pipe into a standalone component, you can use it in the template </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
&lt;div&gt;{{10 | multiply}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.879.1">If you want to supply the pipe with a custom multiplier value, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.881.1">
&lt;div&gt;{{10 | multiply: 5}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.882.1">If you want to add more parameters to your pipe, you can do so by adding more parameters inside your transform function. </span><span class="koboSpan" id="kobo.882.2">Let’s say you want another multiplier in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">multiply</span></strong><span class="koboSpan" id="kobo.884.1"> pipe. </span><span class="koboSpan" id="kobo.884.2">You can add it </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.886.1">
transform(value: number, multiplier = 2, additional = 1): number {
  return value * multiplier * additional;
}</span></pre> <p><span class="koboSpan" id="kobo.887.1">Now, you can use the following syntax inside your </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">HTML templates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.889.1">
&lt;div&gt;{{10 | multiply: 5: 10}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.890.1">Our example pipe is simple, but you can add any logic you want inside your transform function. </span><span class="koboSpan" id="kobo.890.2">Just make sure you use a pure function when creating a pure pipe, that is, a function that returns the same value when given the same input and doesn’t affect any other code. </span><span class="koboSpan" id="kobo.890.3">When you create an impure pipe, make sure not to add time-consuming or resource-intensive code, as it will impact the performance of your application negatively. </span><span class="koboSpan" id="kobo.890.4">Here is an example of how you make a </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">pipe impure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.892.1">
@Pipe({
  name: 'multiply',
  standalone: true,
  </span><strong class="bold"><span class="koboSpan" id="kobo.893.1">pure: false,</span></strong><span class="koboSpan" id="kobo.894.1">
})</span></pre> <p><span class="koboSpan" id="kobo.895.1">Now you know that pipes are used to transform values. </span><span class="koboSpan" id="kobo.895.2">Angular offers built-in pipes for common transformations and to handle asynchronous values. </span><span class="koboSpan" id="kobo.895.3">You know the difference between pure and impure </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.896.1">pipes, and you can create your own custom pipes. </span><span class="koboSpan" id="kobo.896.2">To finish this chapter, we will learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">Angular animations.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.898.1">Creating and reusing stunning animations</span></h1>
<p><span class="koboSpan" id="kobo.899.1">In the previous sections, you’ve seen how to manipulate DOM elements using directives and how to transform template</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.900.1"> values using pipes; in this section, you will learn how to </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.901.1">create animations for your HTML elements and components using the built-in </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">animation module.</span></span></p>
<p><span class="koboSpan" id="kobo.903.1">To start, you have to enable the animation module. </span><span class="koboSpan" id="kobo.903.2">To do this, go to </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">app.config.ts</span></strong><span class="koboSpan" id="kobo.905.1"> in your applications</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.906.1"> under the </span><em class="italic"><span class="koboSpan" id="kobo.907.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.908.1"> in your Nx monorepo. </span><span class="koboSpan" id="kobo.908.2">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">app.config.ts</span></strong><span class="koboSpan" id="kobo.910.1">, you’ll find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">appConfig</span></strong><span class="koboSpan" id="kobo.912.1"> object used in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">main.ts</span></strong><span class="koboSpan" id="kobo.914.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">bootstrapApplication</span></strong><span class="koboSpan" id="kobo.916.1"> function. </span><span class="koboSpan" id="kobo.916.2">To enable the animation module, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">provideAnimations()</span></strong><span class="koboSpan" id="kobo.918.1"> function inside the providers array of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">appConfig</span></strong><span class="koboSpan" id="kobo.920.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">
provideAnimations(),</span></pre> <p><span class="koboSpan" id="kobo.923.1">If you’re using an NgModule-based application, you need to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">BrowserAnimationsModule</span></strong><span class="koboSpan" id="kobo.925.1"> inside the NgModule where you want to use animations. </span><span class="koboSpan" id="kobo.925.2">After adding either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">provideAnimations</span></strong><span class="koboSpan" id="kobo.927.1"> function or </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">BrowserAnimationsModule</span></strong><span class="koboSpan" id="kobo.929.1">, you can start adding animations inside your components. </span><span class="koboSpan" id="kobo.929.2">To demonstrate animations, let’s create a selectable label component inside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">common-components</span></strong><span class="koboSpan" id="kobo.931.1"> library. </span><span class="koboSpan" id="kobo.931.2">Use the Nx generator to create a component, name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">selectable-label</span></strong><span class="koboSpan" id="kobo.933.1">, choose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">common-components</span></strong><span class="koboSpan" id="kobo.935.1"> library for the project, check the </span><strong class="bold"><span class="koboSpan" id="kobo.936.1">standalone</span></strong><span class="koboSpan" id="kobo.937.1"> checkbox, and set </span><strong class="bold"><span class="koboSpan" id="kobo.938.1">changeDetection</span></strong><span class="koboSpan" id="kobo.939.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">OnPush</span></strong><span class="koboSpan" id="kobo.941.1">. </span><span class="koboSpan" id="kobo.941.2">When the component is generated, add the following export in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">index.ts</span></strong><span class="koboSpan" id="kobo.943.1"> of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">common-components</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.945.1"> library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.946.1">
export * from './lib/selectable-label/selectable-label.component';</span></pre> <p><span class="koboSpan" id="kobo.947.1">Now, add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.949.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.950.1">
@Input() labelText!: string;
@Input() get selected() {
  return this._selected;
}
set selected(selected) {
  this._selected = selected;
  this.animationState = selected ? </span><span class="koboSpan" id="kobo.950.2">‹selected› : ‹deselected›;
}
@Output() selectedChange = new EventEmitter&lt;boolean&gt;();
private _selected = false;
animationState = 'deselected';
onSelectionChanged() {
  this.selected = !this.selected;
  this.selectedChange.emit(this.selected);
}</span></pre> <p><span class="koboSpan" id="kobo.951.1">Add the following</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.952.1"> CSS to the </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">SCSS file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.954.1">
span {
  color: white; background-color: #455b66;
  padding: 5px 15px; border-radius: 15px; cursor: pointer;
}</span></pre> <p><span class="koboSpan" id="kobo.955.1">Add the following HTML to</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.956.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">HTML file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.958.1">
&lt;span (click)="onSelectionChanged()"&gt;{{labelText}}&lt;/span&gt;</span></pre> <p><span class="koboSpan" id="kobo.959.1">Now that we have a simple label component, let’s create our animation. </span><span class="koboSpan" id="kobo.959.2">Start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">animations</span></strong><span class="koboSpan" id="kobo.961.1"> array inside </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.962.1">your component decorator </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.964.1">
@Component({ ………, animations: []})</span></pre> <p><span class="koboSpan" id="kobo.965.1">Animations for the component are added inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">animations</span></strong><span class="koboSpan" id="kobo.967.1"> array. </span><span class="koboSpan" id="kobo.967.2">Add the following animation inside </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">the array:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.969.1">trigger</span></strong><span class="koboSpan" id="kobo.970.1">('selectedState', [
  </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">state</span></strong><span class="koboSpan" id="kobo.972.1">('selected', style({ backgroundColor: '#382632' })),
  </span><strong class="bold"><span class="koboSpan" id="kobo.973.1">state</span></strong><span class="koboSpan" id="kobo.974.1">('deselected', style({ backgroundColor: '#455b66'})),
  </span><strong class="bold"><span class="koboSpan" id="kobo.975.1">transition</span></strong><span class="koboSpan" id="kobo.976.1">('selected &lt;=&gt; deselected', [animate('2s')])
])</span></pre> <p><span class="koboSpan" id="kobo.977.1">This is a simple animation that </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.978.1">changes the background color from the hex color </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">#382632</span></strong><span class="koboSpan" id="kobo.980.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">#455b66</span></strong><span class="koboSpan" id="kobo.982.1"> and takes 2 seconds to perform the transition. </span><span class="koboSpan" id="kobo.982.2">Now let’s examine what we added line </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">by line.</span></span></p>
<h3><span class="koboSpan" id="kobo.984.1">Animation trigger</span></h3>
<p><span class="koboSpan" id="kobo.985.1">Our animation starts with </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">a trigger:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.987.1">trigger</span></strong><span class="koboSpan" id="kobo.988.1">('selectedState', [])</span></pre> <p><span class="koboSpan" id="kobo.989.1">The trigger receives two arguments: the</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.990.1"> trigger name and an animation metadata array. </span><span class="koboSpan" id="kobo.990.2">The trigger name is used to identify the animation and apply it to the HTML elements in the template. </span><span class="koboSpan" id="kobo.990.3">The name can be anything you like, but it is recommended to make it descriptive in terms of what your animation does. </span><span class="koboSpan" id="kobo.990.4">In our example, we used the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">selectedState</span></strong><span class="koboSpan" id="kobo.992.1">. </span><span class="koboSpan" id="kobo.992.2">The animation metadata array contains state and transition functions that define the behavior of our animation. </span><span class="koboSpan" id="kobo.992.3">Let’s explore these functions in </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">more detail.</span></span></p>
<h3><span class="koboSpan" id="kobo.994.1">Animation state</span></h3>
<p><span class="koboSpan" id="kobo.995.1">Inside our animation metadata array, by using our </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">selectedState</span></strong><span class="koboSpan" id="kobo.997.1"> trigger, you’ll find the </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">state functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.999.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.1000.1">state</span></strong><span class="koboSpan" id="kobo.1001.1">('selected', style({ backgroundColor: '#382632' })),
  </span><strong class="bold"><span class="koboSpan" id="kobo.1002.1">state</span></strong><span class="koboSpan" id="kobo.1003.1">('deselected', style({ backgroundColor: '#455b66'})),</span></pre> <p><span class="koboSpan" id="kobo.1004.1">Your animation can have as many state functions as are needed. </span><span class="koboSpan" id="kobo.1004.2">You can define animations without a state or with many state functions. </span><span class="koboSpan" id="kobo.1004.3">Each state defines a state your animation can transition to. </span><span class="koboSpan" id="kobo.1004.4">If you have an animation without any state functions, you can define the style changes inside the transition functions, and the animation will still run, but after it finishes, the </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.1005.1">HTML element will be as it was before the animation started. </span><span class="koboSpan" id="kobo.1005.2">When you have a state, you can transition an element from one state to another. </span><span class="koboSpan" id="kobo.1005.3">When the animation transitions to a specific animation state, the HTML element will stay styled as the state defined it until the animation transitions the HTML element to another </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">animation state.</span></span></p>
<p><span class="koboSpan" id="kobo.1007.1">Each animation state receives a name to indicate the state and a style function to define the style properties with which to transition to for the specific animation state. </span><span class="koboSpan" id="kobo.1007.2">It is important to note that the styles are indicated with camel case, so no hyphens are used. </span><span class="koboSpan" id="kobo.1007.3">The background color CSS property </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">becomes </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">backgroundColor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1011.1">In our example, we have two states: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">selected</span></strong><span class="koboSpan" id="kobo.1013.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">deselected</span></strong><span class="koboSpan" id="kobo.1015.1">. </span><span class="koboSpan" id="kobo.1015.2">Inside the component class, we also have a property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">animationState</span></strong><span class="koboSpan" id="kobo.1017.1">, which holds the current state of our animation. </span><span class="koboSpan" id="kobo.1017.2">By default, it’s set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">deselected</span></strong><span class="koboSpan" id="kobo.1019.1">. </span><span class="koboSpan" id="kobo.1019.2">When we click on our label, we will set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">selected</span></strong><span class="koboSpan" id="kobo.1021.1"> property, and inside the setter of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">selected</span></strong><span class="koboSpan" id="kobo.1023.1"> property, we will set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">animationState</span></strong><span class="koboSpan" id="kobo.1025.1"> to its </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">proper value.</span></span></p>
<h3><span class="koboSpan" id="kobo.1027.1">Animation transition</span></h3>
<p><span class="koboSpan" id="kobo.1028.1">After our state functions, we define a</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.1029.1"> transition function inside the animation </span><a id="_idIndexMarker348"/><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">metadata array:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1031.1">transition</span></strong><span class="koboSpan" id="kobo.1032.1">('selected &lt;=&gt; deselected', [animate('2s')])</span></pre> <p><span class="koboSpan" id="kobo.1033.1">Transition functions specify how to transition from one animation state to another and they can take three parameters: the transition statement, an animation metadata array, and an object that can define a delay for </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">your transition.</span></span></p>
<h4><span class="koboSpan" id="kobo.1035.1">Transition expression</span></h4>
<p><span class="koboSpan" id="kobo.1036.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">transition</span></strong><span class="koboSpan" id="kobo.1038.1"> expression indicates </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.1039.1">what state transition to cover when using a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">transition</span></strong><span class="koboSpan" id="kobo.1041.1"> function. </span><span class="koboSpan" id="kobo.1041.2">The syntax of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">transition</span></strong><span class="koboSpan" id="kobo.1043.1"> expression reads from left to right and uses arrows to indicate the state transition. </span><span class="koboSpan" id="kobo.1043.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">selected =&gt; deselected</span></strong><span class="koboSpan" id="kobo.1045.1"> would target state transitions from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">selected</span></strong><span class="koboSpan" id="kobo.1047.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">deselected</span></strong><span class="koboSpan" id="kobo.1049.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">deselected =&gt; selected</span></strong><span class="koboSpan" id="kobo.1051.1"> would target state transitions from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">deselected</span></strong><span class="koboSpan" id="kobo.1053.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">selected</span></strong><span class="koboSpan" id="kobo.1055.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">selected &lt;=&gt; deselected</span></strong><span class="koboSpan" id="kobo.1057.1"> would target state transitions from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">selected</span></strong><span class="koboSpan" id="kobo.1059.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">deselected</span></strong><span class="koboSpan" id="kobo.1061.1"> and from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">deselected</span></strong><span class="koboSpan" id="kobo.1063.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">selected</span></strong><span class="koboSpan" id="kobo.1065.1">. </span><span class="koboSpan" id="kobo.1065.2">You can also use an asterisk inside your selection expression. </span><span class="koboSpan" id="kobo.1065.3">The asterisk symbol is a wildcard and stands for every state. </span><span class="koboSpan" id="kobo.1065.4">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">* =&gt; deselected</span></strong><span class="koboSpan" id="kobo.1067.1"> would trigger the transition if any state transfers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">deselected</span></strong><span class="koboSpan" id="kobo.1069.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">* =&gt; *</span></strong><span class="koboSpan" id="kobo.1071.1"> would trigger if any state transfers </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">to another.</span></span></p>
<p><span class="koboSpan" id="kobo.1073.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">transition</span></strong><span class="koboSpan" id="kobo.1075.1"> expression</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.1076.1"> has a few more special selectors that are similar to the asterisk. </span><span class="koboSpan" id="kobo.1076.2">For example, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">:enter</span></strong><span class="koboSpan" id="kobo.1078.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">:leave</span></strong><span class="koboSpan" id="kobo.1080.1"> as transition expressions. </span><span class="koboSpan" id="kobo.1080.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">:enter</span></strong><span class="koboSpan" id="kobo.1082.1"> expression will be applied to an element entering the DOM, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">:leave</span></strong><span class="koboSpan" id="kobo.1084.1"> targets elements that are removed from the DOM. </span><span class="koboSpan" id="kobo.1084.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">:enter</span></strong><span class="koboSpan" id="kobo.1086.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">:leave</span></strong><span class="koboSpan" id="kobo.1088.1"> expressions do not care about the animation state an HTML element currently has. </span><span class="koboSpan" id="kobo.1088.2">These two expressions are useful when combined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">*ngIf </span></strong><span class="koboSpan" id="kobo.1090.1">or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">*</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">ngFor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1"> directives.</span></span></p>
<p><span class="koboSpan" id="kobo.1094.1">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">:increment</span></strong><span class="koboSpan" id="kobo.1096.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">:decrement</span></strong><span class="koboSpan" id="kobo.1098.1"> as expressions. </span><span class="koboSpan" id="kobo.1098.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">:increment</span></strong><span class="koboSpan" id="kobo.1100.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">:decrement</span></strong><span class="koboSpan" id="kobo.1102.1"> expressions will trigger the animation when the value inside the HTML element is a number, and it gets incremented </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">or decremented.</span></span></p>
<h4><span class="koboSpan" id="kobo.1104.1">Animation metadata array</span></h4>
<p><span class="koboSpan" id="kobo.1105.1">After the transition expression, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">transition</span></strong><span class="koboSpan" id="kobo.1107.1"> function also takes an animation metadata array as input. </span><span class="koboSpan" id="kobo.1107.2">In our example, we only</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.1108.1"> declared an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">animate</span></strong><span class="koboSpan" id="kobo.1110.1"> function inside, which indicates how long the transition takes, which is 2 seconds in our case. </span><span class="koboSpan" id="kobo.1110.2">The animate function can also take a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">style</span></strong><span class="koboSpan" id="kobo.1112.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1114.1">
animate('2s', style({ color: 'red' })),</span></pre> <p><span class="koboSpan" id="kobo.1115.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">style</span></strong><span class="koboSpan" id="kobo.1117.1"> function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">animate</span></strong><span class="koboSpan" id="kobo.1119.1"> function is useful if you have no states for your animation or if you want to perform additional animations during the transition that will not last once the state transition </span><span class="No-Break"><span class="koboSpan" id="kobo.1120.1">is finished.</span></span></p>
<p><span class="koboSpan" id="kobo.1121.1">You can also define keyframes for your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">animate</span></strong><span class="koboSpan" id="kobo.1123.1"> function. </span><span class="koboSpan" id="kobo.1123.2">With keyframes, you can indicate different stages of the animation; the offset defines how far into the animation you are, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">0</span></strong><span class="koboSpan" id="kobo.1125.1"> defining the start and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">1</span></strong><span class="koboSpan" id="kobo.1127.1"> defining the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.1128.1">the animation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1129.1">
animate('2s', keyframes([
  style({ backgroundColor: ‹blue›, offset: 0}),
  style({ backgroundColor: ‹red›, offset: 0.8}),
  style({ backgroundColor: ‹#754600›, offset: 1.0})])),</span></pre> <p><span class="koboSpan" id="kobo.1130.1">Besides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">animate</span></strong><span class="koboSpan" id="kobo.1132.1"> function, the animation metadata array inside the transition function can take more</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.1133.1"> configurations. </span><span class="koboSpan" id="kobo.1133.2">The most commonly used are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">group</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1135.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">sequence</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1138.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">sequence</span></strong><span class="koboSpan" id="kobo.1140.1"> function is used to trigger multiple animate steps one after another. </span><span class="koboSpan" id="kobo.1140.2">These can be steps that lead to the result of the state you are transitioning to or just additional animation steps that are not included in your </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">animation state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1142.1">
sequence([
  animate(‹2s›, style({ backgroundColor: ‹#382632› })),
  animate(‹2s›, style({ color: ‹orange› }))
])</span></pre> <p><span class="koboSpan" id="kobo.1143.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">group</span></strong><span class="koboSpan" id="kobo.1145.1"> function is used to group different </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">animate</span></strong><span class="koboSpan" id="kobo.1147.1"> functions. </span><span class="koboSpan" id="kobo.1147.2">When you group </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">animate</span></strong><span class="koboSpan" id="kobo.1149.1"> functions, they will be executed simultaneously during the transition. </span><span class="koboSpan" id="kobo.1149.2">Each group is executed one </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">after another:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1151.1">
group([
  animate(‹2s›, style({ color: ‹white› })),
  animate(‹2s›, style({ backgroundColor: ‹#455b66› })),
])
group([
  animate(‹2s›, style({ fontSize: ‹24px› })),
  animate(‹2s›, style({ opacity: ‹0.5› })),
])</span></pre> <p><span class="koboSpan" id="kobo.1152.1">Now that you know how to define animations inside your component class, let’s examine how you can add those animations to HTML elements inside </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">your template.</span></span></p>
<h3><span class="koboSpan" id="kobo.1154.1">Adding animations to your template</span></h3>
<p><span class="koboSpan" id="kobo.1155.1">Adding animations inside your HTML template is pretty straightforward. </span><span class="koboSpan" id="kobo.1155.2">To add our animation to the selectable label, we need to add the following code line on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">span tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1157.1">
[@selectedState]="animationState"</span></pre> <p><span class="koboSpan" id="kobo.1158.1">On the left-hand side, you </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.1159.1">define the animation trigger, which is preceded by an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">@</span></strong><span class="koboSpan" id="kobo.1161.1"> sign and enclosed by square brackets. </span><span class="koboSpan" id="kobo.1161.2">On the right-hand side, you declare the animation state; in our case, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">animationState</span></strong><span class="koboSpan" id="kobo.1163.1"> property from our component class for this, but you can also add </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">ternary operations.</span></span></p>
<p><span class="koboSpan" id="kobo.1165.1">You can also trigger events when the animation starts or finishes by adding the following code to your HTML tag with the animation defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">on it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1167.1">
(@selectedState.start)="onAnimationEvent($event)"
(@selectedState.done)="onAnimationEvent($event)"</span></pre> <p><span class="koboSpan" id="kobo.1168.1">Lastly, you can disable an animation within HTML child elements based on a Boolean value and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">@.disabled</span></strong><span class="koboSpan" id="kobo.1170.1"> animation control binding </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1172.1">
&lt;div [@.disabled]="isDisabled"&gt; ……… &lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.1173.1">In the preceding example, all animations inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">div</span></strong><span class="koboSpan" id="kobo.1175.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">@.disabled</span></strong><span class="koboSpan" id="kobo.1177.1"> are disabled if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">isDisabled</span></strong><span class="koboSpan" id="kobo.1179.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1183.1">Now that you know how to create and use animations, let’s explore how you can </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">reuse animations.</span></span></p>
<h3><span class="koboSpan" id="kobo.1185.1">Reusing animations</span></h3>
<p><span class="koboSpan" id="kobo.1186.1">Creating animations, especially complex ones, can be a lot of work. </span><span class="koboSpan" id="kobo.1186.2">If you want to apply them within multiple components, you </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.1187.1">don’t want to add duplicated code and create the same animation multiple times. </span><span class="koboSpan" id="kobo.1187.2">To reuse animations, you can create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">animations.ts</span></strong><span class="koboSpan" id="kobo.1189.1"> file in your application or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">utils</span></strong><span class="koboSpan" id="kobo.1191.1"> library, depending on your use case. </span><span class="koboSpan" id="kobo.1191.2">You can create exported functions in this file. </span><span class="koboSpan" id="kobo.1191.3">Here is an example of our animation as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">reusable animation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1193.1">
export function selectedAnimation(): AnimationTriggerMetadata {
 return trigger('selectedState', [
 state(‹selected›, style({ backgroundColor: ‹#382632› })),
 state(‹deselected›, style({ backgroundColor: ‹#455b66›})),
 transition(‹selected &lt;=&gt; deselected›,[animate(‹2s›)]),])
}</span></pre> <p><span class="koboSpan" id="kobo.1194.1">Now, inside the component class, you </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.1195.1">can define the animation </span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1197.1">
@Component({
  ………
  animations: [selectedAnimation()],
})</span></pre> <p><span class="koboSpan" id="kobo.1198.1">This maintains readability in your component and allows you to use the animation inside multiple components without creating </span><span class="No-Break"><span class="koboSpan" id="kobo.1199.1">it again.</span></span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.1200.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1201.1">In this chapter, you learned the difference between structural and attribute directives. </span><span class="koboSpan" id="kobo.1201.2">You learned how to add and remove DOM elements using directives. </span><span class="koboSpan" id="kobo.1201.3">You’ve learned to change the styling and behavior of DOM elements using directives, and you now know how to listen out for the events of host elements. </span><span class="koboSpan" id="kobo.1201.4">You can use built-in directives and create your own. </span><span class="koboSpan" id="kobo.1201.5">Besides directives, you learned how to transform values using Angular pipes. </span><span class="koboSpan" id="kobo.1201.6">You learned about pure and impure pipes and how they can be made and impact your performance. </span><span class="koboSpan" id="kobo.1201.7">Lastly, you made your own Angular animation and learned about animation triggers, states, and transform functions. </span><span class="koboSpan" id="kobo.1201.8">Now, you know how to declare animations in your templates and how to reuse them throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">In the next chapter, you will learn about reactive and </span><span class="No-Break"><span class="koboSpan" id="kobo.1204.1">template-driven forms.</span></span></p>
</div>
</body></html>