<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Falcor Advanced Concepts</h1>
            

            <article>
                
<p class="calibre2">Currently, our app has the ability to add, edit, and delete articles, but only on the frontend with the help of Redux's reducers. We need to add some full-stack mechanism to make this able to perform CRUD operations on the database. We will also need to add some security features on the backend so non-authenticated users won't be able to perform CRUD operations on the MongoDB collections.</p>
<p class="calibre2">Let's pause coding for a moment. Before we start developing the full-stack Falcor mechanism, let's discuss our React, Node, and Falcor setup in more detail.</p>
<p class="calibre2">It's important to understand why we have chosen Falcor in our technical stack. In general, at the custom software development company where I work (you can find more at <a href="http://www.ReactPoland.com" class="calibre6">www.ReactPoland.com</a>), we use Falcor as it has many great advantages for our clients in terms of the productivity of developing full-stack mobile/web applications. Some of them are as follows:</p>
<ul class="calibre14">
<li class="calibre15">The simplicity of the concept</li>
<li class="calibre15">A speedup of over by 30 percent in development in comparison to a RESTful approach</li>
<li class="calibre15">Shallow learning curve, so a developer who learns Falcor can become effective very quickly</li>
<li class="calibre15">An effective way of fetching data (from backend to the client side) that is quite astounding</li>
</ul>
<p class="calibre2">I will keep these four points short and sweet, for now. Later in the chapter, you will learn more about problems that you may face when using Falcor and Node.</p>
<p class="calibre2">Currently, we have assembled a kind of full-stack starter kit with React, Redux, Falcor, Node, Express, and MongoDB. It's not perfect yet. We will make it our focus for this chapter, which will include the following topics:</p>
<ul class="calibre14">
<li class="calibre15">Better understanding the big picture of <em class="calibre21">RESTless data fetching</em> solutions and the similarities and differences between Falcor and Relay/GraphQL</li>
<li class="calibre15">How to secure routes in order to authenticate users on the backend</li>
<li class="calibre15">How to handle errors on the backend and send them seamlessly to the frontend with the help of errorSelectors</li>
<li class="calibre15">A detailed look at Falcor's sentinels and how exactly <kbd class="calibre11">$ref</kbd>, <kbd class="calibre11">$atom</kbd>, and <kbd class="calibre11">$error</kbd> work in Falcor</li>
<li class="calibre15">What a JSON graph is and how it works</li>
<li class="calibre15">What the virtual JSON concept is in Falcor</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The problem that Falcor aims to solve</h1>
            

            <article>
                
<p class="calibre2">Before the era of single-page applications, there weren't problems with fetching data on the client, as all of the data was always fetched on the server, and even then, the server would send the HTML markup to the client. Each time someone clicked on a URL (<kbd class="calibre11">href</kbd>), our browser requested totally new HTML markup from the server.</p>
<p class="calibre2">Based on the preceding principles of non-SPA applications, Ruby on Rails became the king of web development's technical stack, but later things changed. Since 2009-2010, we've been creating more and more JavaScript client applications, which are more likely fetched once from the backend as, for example, a <kbd class="calibre11">bundle.js</kbd> file. They're called SPAs.</p>
<p class="calibre2">Because of this SP Apps trend, some new problems emerged that weren't known to non-SP Apps developers, such as fetching data from the API endpoint on the backend in order to consume that JSON data on the client side.</p>
<p class="calibre2">In general, the old-fashioned workflow for RESTful applications was as follows:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Create endpoints on the backend.</li>
<li value="2" class="calibre15">Create the fetching mechanism on the frontend.</li>
<li value="3" class="calibre15">Fetch data from the backend by coding POST/GET requests on the frontend based on the API's specification.</li>
<li value="4" class="calibre15">When you fetch the JSON from the backend to the frontend, you can consume the data and use it in order to create the UI view based on a certain use case.</li>
</ol>
<p class="calibre2">This process is kind of frustrating if someone such as a client or boss changes their mind, because you were implementing the entire code on the backend and frontend. Later the backend API endpoints become irrelevant, so you need to start working on them from scratch based on the changed requirements.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Virtual JSON - one model everywhere</h1>
            

            <article>
                
<p class="calibre2">For Falcor, one model everywhere is the main tagline of this great library. In general, the main purpose of using it is to create a single JSON model that is exactly the same on the frontend and backend. What does this mean for us? It means that if anything changes, we need to change the model, which is exactly the same on the backend and frontend--so in case of any changes, we need to tweak our model without worrying about how the data is provided on the backend and fetched on the frontend.</p>
<p class="calibre2">Falcor's innovation is to introduce a new concept called virtual JSON (analogical to virtual DOM for React). This lets you represent all your remote data sources (for example, MongoDB in our case) as a single domain model. The whole idea is that you code the same way without caring where your data is: is it on the client-side memory cache or on the server? You don't need to care, as Falcor, with its innovative approach, does a lot of the job (for example, querying with <kbd class="calibre11">xhr</kbd> requests) for you.</p>
<p class="calibre2">Data fetching is a problem for developers. Falcor is here to help to make it simpler. You can fetch data from the backend to the frontend, writing fewer lines of code than ever!</p>
<p class="calibre2">It's May 2016, and the only viable competitors that I see on the horizon are the Facebook libraries called Relay (on the client side) and GraphQL (on the backend).</p>
<p class="calibre2">Let's try to compare both.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Falcor versus Relay/GraphQL</h1>
            

            <article>
                
<p class="calibre2">As with any tool, there are always pros and cons.</p>
<p class="calibre2">For certain, Falcor is always better than Relay/GraphQL in small/mid-sized projects, at least unless you have master developers (or you are a master yourself) who know Relay/GraphQL very well. Why is that?</p>
<p class="calibre2">In general, Relay (for the frontend) and GrapQL (for the backend) are two different tools and you must be efficient in order to use properly.</p>
<p class="calibre2">Very often in commercial environments, you don't have too much time to learn things from scratch. This is also a reason behind the success of React.</p>
<p class="calibre2">Why has React succeeded? React is much easier to grasp in order to be an efficient frontend developer. A CTO or technical director hires a newbie developer who knows jQuery (for example), and then the CTO can easily project that this junior developer will be effective in React in 7 to 14 days; I was teaching junior frontend developers with basic knowledge of JavaScript/jQuery, and I found out that they quite quickly become efficient in creating client-side apps with React.</p>
<p class="calibre2">We can find the same situation with Falcor. Falcor, in comparison to Relay + GraphQL, is like the simplicity of React compared to the monolithic framework of Angular.</p>
<p class="calibre2">This single factor described in the previous few paragraphs means that Falcor is better for small/mid-size projects with a limited budget.</p>
<p class="calibre2">You may find some opportunities to learn Relay/GraphQL in bigger companies with much bigger budgets, such as Facebook, when you have 6 months to master a technology.</p>
<p class="calibre2">FalcorJS can be mastered effectively in two weeks, but GraphQL + Relay cannot.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Big-picture similarities</h1>
            

            <article>
                
<p class="calibre2">Both these tools are trying to solve the same problem. They are efficient by design for both developers and the network (trying to optimize the number of queries in comparison to a RESTful approach).</p>
<p class="calibre2">They have the ability to query the backend server in order to fetch data and also have batching ability (so you can fetch more than two different sets of data with one network request). Both have some caching abilities.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Technical differences - overview</h1>
            

            <article>
                
<p class="calibre2">With a technical overview, we can find out that in general, Relay allows you to query an undefined number of items from the GraphQL server. In Falcor, for comparison, you need to first ask the backend how many items it has before being able to query for the collection objects' details (such as articles, in our book's case).</p>
<p class="calibre2">In general, the biggest difference here is that GraphQL/Relay is a query language tool and Falcor is not. What is a query language? It's one with which you can make queries from the frontend similar to SQL, like this:</p>
<pre class="calibre22">
post: () =&gt; Relay.QL <br class="title-page-name"/>  fragment on Articles { <br class="title-page-name"/>    title, <br class="title-page-name"/>    content <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">The preceding code can be made a query from the frontend via <kbd class="calibre11">Relay.QL</kbd>, and then GraphQL processes the query in the same way as SQL, like this:</p>
<pre class="calibre22">
SELECT title, content FROM Articles 
</pre>
<p class="calibre2">Things may get harder if there are, for example, a million articles in the DB and you didn't expect so many on the frontend.</p>
<p class="calibre2">In Falcor, you do it differently, as you've already learned:</p>
<pre class="calibre22">
const articlesLength = await falcorModel. <br class="title-page-name"/>  getValue('articles.length'). <br class="title-page-name"/>  then((length) =&gt; length); <br class="title-page-name"/><br class="title-page-name"/>const articles = await falcorModel. <br class="title-page-name"/>  get(['articles', {from: 0, to: articlesLength-1}, <br class="title-page-name"/>   ['_id','articleTitle', 'articleContent']]).  <br class="title-page-name"/>  then((articlesResponse) =&gt; articlesResponse.json.articles); 
</pre>
<p class="calibre2">In the preceding Falcor example, you must first know how many records there are in the MongoDB instance.</p>
<p class="calibre2">This is one of most important differences and creates some challenges for both sides.</p>
<p class="calibre2">For GraphQL and Relay, the question is whether the power of those query languages is worth the complexity created in the learning curve, because that complexity may not be worth it for small/mid-sized projects.</p>
<p class="calibre2">Now that the basic differences have been discussed, let's focus on Falcor and improving our current publishing app.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Improving our application and making it more reliable</h1>
            

            <article>
                
<p class="calibre2">We need to improve things such as the following:</p>
<ul class="calibre14">
<li class="calibre15">After a login, we shall send user details in each request (the token, username, and a role; you can find a screenshot later in the section <em class="calibre21">Improving our Falcor code on the frontend</em>)</li>
<li class="calibre15">The backend needs to be secured so that authorization is checked before running add/edit/delete operations on the backend</li>
<li class="calibre15">We need to provide the ability to catch errors on the backend and give a notification to the user on the frontend about something not working correctly</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Securing the auth required routes</h1>
            

            <article>
                
<p class="calibre2">Currently, our app has the ability to add/edit/delete a route. The problem with our current implementation is that we don't check whether a client making a CRUD operation has the privileges to do so.</p>
<p class="calibre2">The solution of securing Falcor routes requires some changes to our current implementation, so for each request, before performing the operation, we will check whether we have got the correct token from the client and whether the user making the call has the ability to edit (in our case, it means that if anyone has an editor role and is authenticated correctly with his username and password, then he can add/edit/delete an article).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">JSON Graph and JSON envelopes in Falcor</h1>
            

            <article>
                
<p class="calibre2">As the Falcor documentation states, "JSON Graph is a convention for modeling graph information as a JSON object. Applications that use Falcor represent all their domain data as a single JSON Graph object."</p>
<p class="calibre2">In general, JSON Graph in Falcor is valid JSON with some new features. To be more precise, JSON Graph introduces a new types of data besides strings, numbers, and Booleans. The new data type in Falcor is called a <strong class="calibre1">sentinel</strong>. I will try to explain it later in the chapter.</p>
<p class="calibre2">Generally, the second most important thing to understand in Falcor are JSON envelopes. The great thing is that they work out of the box, so you don't have to worry too much about them. But if you want to know what the short and sweet answer is, JSON envelopes help send JSON's model via HTTP's protocol. It's a way of transferring data from frontend to backend (with the <kbd class="calibre11">.call</kbd>, <kbd class="calibre11">.set</kbd>, and <kbd class="calibre11">.get</kbd> methods). In the same way, before the backend (after processing a request's details), before sending the improved model's details to the client side, Falcor puts it into an <em class="calibre21">envelope</em> so that it can be easily transferred via a network.</p>
<p class="calibre2">A good (but not perfect) analogy for JSON envelopes is that you put a written list into an envelope because you don't want to send some valuable information over from point <em class="calibre21">A</em> to point <em class="calibre21">B</em>; the network doesn't care what you send in that envelope. The most important thing is that the sender and the receiver know the context of the application model.</p>
<p class="calibre2">You can find more information about the JSON Graph and envelopes at <a href="http://netflix.github.io/falcor/documentation/jsongraph.html" class="calibre6"><span>http://netflix.github.io/falcor/documentation/jsongraph.html</span></a>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Improving our Falcor code on the frontend</h1>
            

            <article>
                
<p class="calibre2">Currently, after a user authorizes himself, all the data is saved into local storage. We need to close the loop by sending that data--token, username, and role--back to the backend with each request so we can check again whether a user is authenticated correctly. If not, then we need to send an authentication error with the request and show it back on the frontend.</p>
<p class="calibre2">The arrangement in the following screenshot is specifically important for security reasons so that no unauthorized user can add/edit/delete an article in our database:</p>
<div class="packt_figure"><img class="image-border42" src="../images/00047.jpeg"/></div>
<p class="calibre2">In the screenshot, you can find out where you can get information about the <kbd class="calibre11">localStorage</kbd> data.</p>
<p class="calibre2">The following is our current code in <kbd class="calibre11">src/falcorModel.js</kbd>:</p>
<pre class="calibre22">
// this code is already in the codebase <br class="title-page-name"/>const falcor = require('falcor'); <br class="title-page-name"/>const FalcorDataSource = require('falcor-http-datasource'); <br class="title-page-name"/><br class="title-page-name"/>const model = new falcor.Model({ <br class="title-page-name"/>  source: new FalcorDataSource('/model.json') <br class="title-page-name"/>}); <br class="title-page-name"/>export default model; 
</pre>
<p class="calibre2">We need to change this to a new, improved version:</p>
<pre class="calibre22">
import falcor from 'falcor'; <br class="title-page-name"/>import FalcorDataSource from 'falcor-http-datasource'; <br class="title-page-name"/><br class="title-page-name"/>class PublishingAppDataSource extends FalcorDataSource { <br class="title-page-name"/>  onBeforeRequest ( config ) { <br class="title-page-name"/>    const token = localStorage.token; <br class="title-page-name"/>    const username = localStorage.username; <br class="title-page-name"/>    const role = localStorage.role; <br class="title-page-name"/><br class="title-page-name"/>    if (token &amp;&amp; username &amp;&amp; role) { <br class="title-page-name"/>      config.headers['token'] = token; <br class="title-page-name"/>      config.headers['username'] = username; <br class="title-page-name"/>      config.headers['role'] = role; <br class="title-page-name"/>    } <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>const model = new falcor.Model({ <br class="title-page-name"/>  source: new PublishingAppDataSource('/model.json') <br class="title-page-name"/>}); <br class="title-page-name"/>export default model; 
</pre>
<p class="calibre2">What have we done in the previous code snippet? The <kbd class="calibre11">extends</kbd> keyword from ECMAScript6 shows an example of where the simplicity of the class syntax shines. Extending the <kbd class="calibre11">FalcorDataSource</kbd> means that <kbd class="calibre11">PublishingAppDataSource</kbd> inherits everything that the <kbd class="calibre11">FalcorDataSource</kbd> has and it makes the <kbd class="calibre11">onBeforeRequest</kbd> method have our custom behavior (by mutating <kbd class="calibre11">config.headers</kbd>). The <kbd class="calibre11">onBeforeRequest</kbd> method is checking the configuration mutated by us before our <kbd class="calibre11">xhr</kbd> instance is created. This helps us modify the <kbd class="calibre11">XMLHttpRequest</kbd> with a token, username, and role--in case our app's user logs out in the meantime, we can send that information to the backend.</p>
<p class="calibre2">After you implement the previous code in <kbd class="calibre11">falcorModel.js</kbd> and a user is logged, those variables will be added to each request:</p>
<div class="packt_figure"><img class="image-border43" src="../images/00048.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Improving server.js and routes.js</h1>
            

            <article>
                
<p class="calibre2">In general, we currently export an array of objects from the <kbd class="calibre11">server/routes.js</kbd> file. We need to improve it, so we will return a function that will modify our array of objects so we have control over which route is returned to which user, and in case a user does not have a valid token or enough privileges, we will return an error. This will improve the security of our whole app.</p>
<p class="calibre2">In the <kbd class="calibre11">server/server.js</kbd> file, find this old code:</p>
<pre class="calibre22">
// this shall be already in your codebase <br class="title-page-name"/>app.use('/model.json', falcorExpress.dataSourceRoute((req, res) <br class="title-page-name"/> =&gt; { <br class="title-page-name"/>  return new falcorRouter(routes); <br class="title-page-name"/>})); 
</pre>
<p class="calibre2">Replace it with this improved one:</p>
<pre class="calibre22">
app.use('/model.json', falcorExpress.dataSourceRoute((req, res) <br class="title-page-name"/> =&gt; { <br class="title-page-name"/>  return new falcorRouter( <br class="title-page-name"/>      [] <br class="title-page-name"/>        .concat(routes(req, res)) <br class="title-page-name"/>    ); <br class="title-page-name"/>})); 
</pre>
<p class="calibre2">In our new version, we assume that the <kbd class="calibre11">routes</kbd> variable is a function with the <kbd class="calibre11">req</kbd> and <kbd class="calibre11">res</kbd> variables.</p>
<p class="calibre2">Let's improve the routes itself so we won't return an array anymore, but a function that returns an array (so we end up with more flexibility).</p>
<p class="calibre2">The next step is to improve the <kbd class="calibre11">server/routes.js</kbd> file in order to make a function that receives the <kbd class="calibre11">currentSession</kbd> object, which stores all the information about a request. We need to change this in <kbd class="calibre11">routes.js</kbd>:</p>
<pre class="calibre22">
// this code is already in your codebase: <br class="title-page-name"/>const PublishingAppRoutes = [ <br class="title-page-name"/>    ...sessionRoutes, <br class="title-page-name"/>  { <br class="title-page-name"/>  route: 'articles.length', <br class="title-page-name"/>    get: () =&gt; { <br class="title-page-name"/>      return Article.count({}, function(err, count) { <br class="title-page-name"/>        return count; <br class="title-page-name"/>      }).then ((articlesCountInDB) =&gt; { <br class="title-page-name"/>        return { <br class="title-page-name"/>          path: ['articles', 'length'], <br class="title-page-name"/>          value: articlesCountInDB <br class="title-page-name"/>        } <br class="title-page-name"/>      }) <br class="title-page-name"/>  } <br class="title-page-name"/>}, <br class="title-page-name"/>//  <br class="title-page-name"/>// ...... There is more code between, it has been truncated in <br class="title-page-name"/> //order to save space <br class="title-page-name"/>// <br class="title-page-name"/>export default PublishingAppRoutes;  
</pre>
<p class="calibre2">Instead of exporting an array of routes, we need to export a function that will return routes based on a current request's header details.</p>
<p class="calibre2">The top part of the <kbd class="calibre11">server/routes.js</kbd> file (with imports) is as follows:</p>
<pre class="calibre22">
import configMongoose from './configMongoose'; <br class="title-page-name"/>import sessionRoutes from './routesSession'; <br class="title-page-name"/>import jsonGraph from 'falcor-json-graph'; <br class="title-page-name"/>import jwt from 'jsonwebtoken'; <br class="title-page-name"/>import jwtSecret from './configSecret'; <br class="title-page-name"/><br class="title-page-name"/>let $atom = jsonGraph.atom; // this will be explained later <br class="title-page-name"/>                            //in the chapter <br class="title-page-name"/>const Article = configMongoose.Article; 
</pre>
<p class="calibre2">Follow this by exporting a new function:</p>
<pre class="calibre22">
export default ( req, res ) =&gt; { <br class="title-page-name"/>  let { token, role, username } = req.headers; <br class="title-page-name"/>  let userDetailsToHash = username+role; <br class="title-page-name"/>  let authSignToken = jwt.sign(userDetailsToHash, <br class="title-page-name"/>   jwtSecret.secret); <br class="title-page-name"/>  let isAuthorized = authSignToken === token; <br class="title-page-name"/>  let sessionObject = {isAuthorized, role, username}; <br class="title-page-name"/><br class="title-page-name"/>  console.info(&amp;grave;The ${username} is authorized === &amp;grave;, <br class="title-page-name"/>   isAuthorized); <br class="title-page-name"/><br class="title-page-name"/>  const PublishingAppRoutes = [ <br class="title-page-name"/>      ...sessionRoutes, <br class="title-page-name"/>    { <br class="title-page-name"/>    route: 'articles.length', <br class="title-page-name"/>      get: () =&gt; { <br class="title-page-name"/>        return Article.count({}, function(err, count) { <br class="title-page-name"/>          return count; <br class="title-page-name"/>        }).then ((articlesCountInDB) =&gt; { <br class="title-page-name"/>          return { <br class="title-page-name"/>            path: ['articles', 'length'], <br class="title-page-name"/>            value: articlesCountInDB <br class="title-page-name"/>          } <br class="title-page-name"/>        }) <br class="title-page-name"/>    } <br class="title-page-name"/>  }]; <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>  return PublishingAppRoutes; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">First of all, we receive the <kbd class="calibre11">req</kbd> (request details) and <kbd class="calibre11">res</kbd> (object that represents the HTTP response) variables into the arrow functions. Based on the information provided by <kbd class="calibre11">req</kbd>, we get the header details (<kbd class="calibre11">let { token, role, username } = req.headers;</kbd>). Next, we have <kbd class="calibre11">userDetailsToHash</kbd> and then we check what will be the correct <kbd class="calibre11">authToken</kbd> with <kbd class="calibre11">let authSignToken = jwt.sign(userDetailsToHash, jwtSecret.secret)</kbd>. Afterward, we check whether the user is authorized with <kbd class="calibre11">let isAuthorized = authSign === token</kbd>. Then we create a <kbd class="calibre11">sessionObject</kbd>, which will be reused across all the Falcor routes later (<kbd class="calibre11">let sessionObject = {isAuthorized, role, username};</kbd>).</p>
<p class="calibre2">Currently, we have one route (<kbd class="calibre11">articles.length</kbd>), which was described in <a href="part0058.html#1NA0K0-7870c13caa1244daa9bd53ca5c1e1a42" class="calibre6"><span>Chapter 2</span></a>, <em class="calibre21">Full-Stack Login and Registration for Our Publishing App</em> (so there's nothing new so far).</p>
<p class="calibre2">As you can see in the previous code, instead of exporting <kbd class="calibre11">PublishingAppRoutes</kbd> directly, we are exporting with the arrow function <kbd class="calibre11">export default (req, res)</kbd>.</p>
<p class="calibre2">We need to re-add (under <kbd class="calibre11">articles.length</kbd>) the second route, called <kbd class="calibre11">articles[{integers}]["_id","articleTitle","articleContent"]</kbd>, with the following code in the <kbd class="calibre11">server/routes</kbd>:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>    route: <br class="title-page-name"/>     'articles[{integers}]["_id","articleTitle","articleContent"]', <br class="title-page-name"/>    get: (pathSet) =&gt; { <br class="title-page-name"/>      const articlesIndex = pathSet[1]; <br class="title-page-name"/><br class="title-page-name"/>      return Article.find({}, function(err, articlesDocs) { <br class="title-page-name"/>        return articlesDocs; <br class="title-page-name"/>      }).then ((articlesArrayFromDB) =&gt; { <br class="title-page-name"/>        let results = []; <br class="title-page-name"/>        articlesIndex.forEach((index) =&gt; { <br class="title-page-name"/>          const singleArticleObject = <br class="title-page-name"/>           articlesArrayFromDB[index].toObject(); <br class="title-page-name"/><br class="title-page-name"/>          const falcorSingleArticleResult = { <br class="title-page-name"/>            path: ['articles', index], <br class="title-page-name"/>            value: singleArticleObject <br class="title-page-name"/>          }; <br class="title-page-name"/><br class="title-page-name"/>          results.push(falcorSingleArticleResult); <br class="title-page-name"/>        }); <br class="title-page-name"/>        return results; <br class="title-page-name"/>      }) <br class="title-page-name"/>    } <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">This is the route that fetches articles from databases and returns <kbd class="calibre11">falcor-route</kbd> for it. It's exactly the same as introduced before; the only different is that now it's part of the function (<kbd class="calibre11">export default ( req, res ) =&gt; { ... }</kbd>).</p>
<p class="calibre2">Before we start to implement add/edit/delete on the backend with <kbd class="calibre11">falcor-router</kbd>, we need to introduce ourselves to the concept of sentinels, as it will be very important for the well-being of our full-stack application, the reason for which will be explained in a moment.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Falcor's sentinel implementation</h1>
            

            <article>
                
<p class="calibre2">Let's understand what sentinels are. They are required to make Fullstack's Falcor application work. It's a set of tools you have to learn.</p>
<p class="calibre2">They are new primitive value types created exclusively for making data transportation between the backend and client side much easier and out of the box (examples of new Falcor primitive values are <kbd class="calibre11">$error</kbd> and <kbd class="calibre11">$ref</kbd>). Here's an analogy: you have types in a regular JSON such as string, number, and object and. On the other hand, in Falcor's virtual JSON, you can additionally use sentinels such as <kbd class="calibre11">$error</kbd>, <kbd class="calibre11">$ref</kbd>, or <kbd class="calibre11">$atom</kbd> alongside the standard JSON types listed previously.</p>
<div class="packt_infobox">Additional information about sentinels is available at <a href="https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata" class="calibre27"><span class="packt_screen">https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata</span></a>.</div>
<p class="calibre2">At this stage, it's important to understand how Falcor's sentinels are working. The different types of sentinel in Falcor are explained in the following sections.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The $ref sentinel</h1>
            

            <article>
                
<p class="calibre2">According to the documentation, "a reference is a JSON object with a <kbd class="calibre11">$type</kbd> key that has a value of <kbd class="calibre11">ref</kbd> and a <kbd class="calibre11">value</kbd> key that has a <kbd class="calibre11">Path</kbd> array as its value."</p>
<p class="calibre2">"A reference is like a symbolic link in the UNIX filesystem," as the documentation states, and this comparison is very good.</p>
<p class="calibre2">An example of <kbd class="calibre11">$ref</kbd> is as a follows:</p>
<pre class="calibre22">
{ $type: 'ref', value: ['articlesById', 'STRING_ARTICLE_ID_HERE'] } 
</pre>
<div class="packt_infobox">If you use <kbd class="calibre23">$ref(['articlesById','STRING_ARTCILE_ID_HERE'])</kbd>, it's equal to the preceding example. The <kbd class="calibre23">$ref</kbd> sentinel is a function that changes the array's details into that <kbd class="calibre23">$type</kbd> and value's notation object.</div>
<p class="calibre2">You can find both approaches in order to deploy/use <kbd class="calibre11">$ref</kbd> in any Falcor-related project, but in our project, we will stick to the <kbd class="calibre11">$ref(['articlesById','STRING_ARTCILE_ID_HERE'])</kbd> convention.</p>
<p class="calibre2">Just to make it clear, this is how to import a <kbd class="calibre11">$ref</kbd> sentinel in our codebase:</p>
<pre class="calibre22">
// wait, this is just an example, don't code this here: <br class="title-page-name"/>import jsonGraph from 'falcor-json-graph'; <br class="title-page-name"/>let $ref = jsonGraph.ref; <br class="title-page-name"/>// now you can use $ref([x, y]) function 
</pre>
<p class="calibre2">After you import <kbd class="calibre11">falcor-json-graph</kbd>, you can use the <kbd class="calibre11">$ref</kbd> sentinel. You will already have installed the <kbd class="calibre11">falcor-json-graph</kbd> library as the installation has been described in the previous chapter; if not, use this:</p>
<pre class="calibre22">
<strong class="calibre1">npm i --save falcor-json-graph@1.1.7</strong> 
</pre>
<p class="calibre2">But what does <kbd class="calibre11">articlesById</kbd> mean in that whole <kbd class="calibre11">$ref</kbd> gig? And what does <kbd class="calibre11">STRING_ARTICLE_ID_HERE</kbd> mean in the preceding example? Let's look at an example from our project that might make it clearer for you.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Detailed example of the $ref sentinel</h1>
            

            <article>
                
<p class="calibre2">Let's assume that we have two articles in our MongoDB instance:</p>
<pre class="calibre22">
// this is just explanation example, don't write this here <br class="title-page-name"/>// we assume that _id comes from MongoDB <br class="title-page-name"/>[ <br class="title-page-name"/>  { <br class="title-page-name"/>    _id: '987654', <br class="title-page-name"/>    articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>    articleContent: 'Here goes the content of the article' <br class="title-page-name"/>  }, <br class="title-page-name"/>  { <br class="title-page-name"/>    _id: '123456', <br class="title-page-name"/>    articleTitle: 'Lorem ipsum - article two', <br class="title-page-name"/>    articleContent: 'Sky is the limit, the content goes here.' <br class="title-page-name"/>  } <br class="title-page-name"/>] 
</pre>
<p class="calibre2">So based on our array's example with mocked articles (IDs <kbd class="calibre11">987654</kbd> and <kbd class="calibre11">123456</kbd>), the <kbd class="calibre11">$ref</kbd> will look as follows:</p>
<pre class="calibre22">
// JSON envelope is an array of two $refs  <br class="title-page-name"/>// The following is an example, don't write it <br class="title-page-name"/>[ <br class="title-page-name"/>  $ref([ articlesById,'987654' ]), <br class="title-page-name"/>  $ref([ articlesById,'123456' ]) <br class="title-page-name"/>] 
</pre>
<p class="calibre2">An even more detailed answer is this one:</p>
<pre class="calibre22">
// JSON envelope is an array of two $refs (other notation than <br class="title-page-name"/> //above, but the same end effect) <br class="title-page-name"/>[ <br class="title-page-name"/>  { $type: 'ref', value: ['articlesById', '987654'] }, <br class="title-page-name"/>  { $type: 'ref', value: ['articlesById', '123456'] } <br class="title-page-name"/>] 
</pre>
<div class="packt_infobox">An important thing to note is that <kbd class="calibre23">articlesById</kbd> is a new route that hasn't been created yet (we will do so in a moment).</div>
<p class="calibre2">But why do we need those <kbd class="calibre11">$ref</kbd> in our articles?</p>
<p class="calibre2">In general, you can keep a reference (like a symbolic link in Unix) in many places to one object in the database. In our case, it's an article with a certain<kbd class="calibre11">_id</kbd> in the article's collection.</p>
<p class="calibre2">When do <kbd class="calibre11">$ref</kbd> sentinels come in handy? Imagine that in our publishing app's model, we add a <em class="calibre21">recently visited</em> articles feature and provide the ability to like an article (like on Facebook).</p>
<p class="calibre2">Based on these two new features, our new model will look as follows (this is just an example; don't code it):</p>
<pre class="calibre22">
// this is just explanatory example code: <br class="title-page-name"/>let cache = { <br class="title-page-name"/>  articles: [ <br class="title-page-name"/>    { <br class="title-page-name"/>        id: 987654, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>        articleContent: 'Here goes the content of the article' <br class="title-page-name"/>        numberOfLikes: 0 <br class="title-page-name"/>    }, <br class="title-page-name"/>    { <br class="title-page-name"/>        id: 123456, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article two from backend', <br class="title-page-name"/>        articleContent: 'Sky is the limit, the content goes <br class="title-page-name"/>         here.', <br class="title-page-name"/>        numberOfLikes: 0 <br class="title-page-name"/>    } <br class="title-page-name"/>  ], <br class="title-page-name"/>  recentlyVisitedArticles: [ <br class="title-page-name"/>    { <br class="title-page-name"/>        id: 123456, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article two from backend', <br class="title-page-name"/>        articleContent: 'Sky is the limit, the content goes <br class="title-page-name"/>         here.', <br class="title-page-name"/>        numberOfLikes: 0 <br class="title-page-name"/>    } <br class="title-page-name"/>  ] <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Based on our preceding example's model, if someone likes an article with ID <kbd class="calibre11">123456</kbd>, we will need to update the model in two places. That's exactly where <kbd class="calibre11">$ref</kbd> comes in handy.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Improving our articles' numberOfLikes with $ref</h1>
            

            <article>
                
<p class="calibre2">Let's improve our example to the following:</p>
<pre class="calibre22">
let cache = { <br class="title-page-name"/>  articlesById: { <br class="title-page-name"/>    987654: { <br class="title-page-name"/>        _id: 987654, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>        articleContent: 'Here goes the content of the article' <br class="title-page-name"/>        numberOfLikes: 0 <br class="title-page-name"/>    }, <br class="title-page-name"/>    123456: { <br class="title-page-name"/>        _id: 123456, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article two from backend', <br class="title-page-name"/>        articleContent: 'Sky is the limit, the content goes <br class="title-page-name"/>         here.', <br class="title-page-name"/>        numberOfLikes: 0 <br class="title-page-name"/>    } <br class="title-page-name"/>  }, <br class="title-page-name"/>  articles: [ <br class="title-page-name"/>    { $type: 'ref', value: ['articlesById', '987654'] }, <br class="title-page-name"/>    { $type: 'ref', value: ['articlesById', '123456'] } <br class="title-page-name"/>  ], <br class="title-page-name"/>  recentlyVisitedArticles: [ <br class="title-page-name"/>    { $type: 'ref', value: ['articlesById', '123456'] } <br class="title-page-name"/>  ] <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">In our new improved <kbd class="calibre11">$ref</kbd> example, you can find the notation where you need to tell Falcor the ID of the article you want to have in <kbd class="calibre11">articles</kbd> or <kbd class="calibre11">recentlyVisitedArticles</kbd>. Falcor on its own will follow the <kbd class="calibre11">$ref</kbd> sentinel, knowing the route name (the <kbd class="calibre11">articlesById</kbd> route in this case) and ID of the object we are looking for (in our example, <kbd class="calibre11">123456</kbd> or <kbd class="calibre11">987654</kbd>). We will use it in practice in a moment.</p>
<p class="calibre2">Understand that this is a simplified version of how it works, but the best analogy to use in order to understand <kbd class="calibre11">$ref</kbd> is UNIX's symbolic links.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Practical use of $ref in our project</h1>
            

            <article>
                
<p class="calibre2">Okay, that was a lot of theory--let's start coding! We will improve our Mongoose model.</p>
<p class="calibre2">Then we'll add the <kbd class="calibre11">$ref</kbd> sentinels described before into the <kbd class="calibre11">server/routes.js</kbd> file:</p>
<pre class="calibre22">
// example of ref, don't write it yet: <br class="title-page-name"/>let articleRef = $ref(['articlesById', currentMongoID]); 
</pre>
<p class="calibre2">We will also add two Falcor routes, <kbd class="calibre11">articlesById</kbd> and <kbd class="calibre11">articles.add</kbd>. On the frontend, we will make some improvements to <kbd class="calibre11">src/layouts/PublishingApp.js</kbd> and <kbd class="calibre11">src/views/articles/AddArticleView.js</kbd>.</p>
<p class="calibre2">Let's start the fun.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Mongoose config improvements</h1>
            

            <article>
                
<p class="calibre2">First thing we will do is open the Mongoose model at <kbd class="calibre11">server/configMongoose.js</kbd>:</p>
<pre class="calibre22">
// this is old codebase, you already shall have it: <br class="title-page-name"/>import mongoose from 'mongoose'; <br class="title-page-name"/><br class="title-page-name"/>const conf = { <br class="title-page-name"/>  hostname: process.env.MONGO_HOSTNAME || 'localhost', <br class="title-page-name"/>  port: process.env.MONGO_PORT || 27017, <br class="title-page-name"/>  env: process.env.MONGO_ENV || 'local', <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>mongoose.connect(&amp;grave;mongodb://${conf.hostname}:${conf.port}/ <br class="title-page-name"/> ${conf.env}&amp;grave;); <br class="title-page-name"/><br class="title-page-name"/>const articleSchema = { <br class="title-page-name"/>  articleTitle:String, <br class="title-page-name"/>  articleContent:String <br class="title-page-name"/>} 
</pre>
<p class="calibre2">We'll improve it to this version:</p>
<pre class="calibre22">
import mongoose from 'mongoose'; <br class="title-page-name"/>const Schema = mongoose.Schema; <br class="title-page-name"/><br class="title-page-name"/>const conf = { <br class="title-page-name"/>  hostname: process.env.MONGO_HOSTNAME || 'localhost', <br class="title-page-name"/>  port: process.env.MONGO_PORT || 27017, <br class="title-page-name"/>  env: process.env.MONGO_ENV || 'local', <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>mongoose.connect(&amp;grave;mongodb://${conf.hostname}:${conf.port}/ <br class="title-page-name"/> ${conf.env}&amp;grave;); <br class="title-page-name"/><br class="title-page-name"/>const articleSchema = new Schema({ <br class="title-page-name"/>    articleTitle:String, <br class="title-page-name"/>    articleContent:String, <br class="title-page-name"/>    articleContentJSON: Object <br class="title-page-name"/>  },  <br class="title-page-name"/>  {  <br class="title-page-name"/>    minimize: false  <br class="title-page-name"/>  } <br class="title-page-name"/>); 
</pre>
<p class="calibre2">In the preceding code, you'll find we import <kbd class="calibre11">new const Schema = mongoose.Schema</kbd>. Later, we improve our <kbd class="calibre11">articleSchema</kbd> with <kbd class="calibre11">articleContentJSON: Object</kbd>. This is required, because the state of draft-js will be kept in a JSON object. This will be useful if a user creates an article, saves it to the database, and later would like to edit the article. In such a case, we'll use this <kbd class="calibre11">articleContentJSON</kbd> in order to restore the content state of the draft-js editor.</p>
<p class="calibre2">The second thing is providing options with <kbd class="calibre11">{ minimize: false }</kbd>. This is required because by default Mongoose gets rid of all empty objects, such as <kbd class="calibre11">{ emptyObject: {}, nonEmptyObject: { test: true } }</kbd>, so if <kbd class="calibre11">minimize: false</kbd> isn't set up then we would get incomplete objects in our database (it's a very important step to have this flag here). There are some draft-js objects that are required, but by default are empty (specifically the <kbd class="calibre11">entityMap</kbd> property of a draft-js object).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The server/routes.js improvements</h1>
            

            <article>
                
<p class="calibre2">In the <kbd class="calibre11">server/routes.js</kbd> file, we need to start using the <kbd class="calibre11">$ref</kbd> sentinel. Your import in that file should look as follows:</p>
<pre class="calibre22">
import configMongoose from './configMongoose'; <br class="title-page-name"/>import sessionRoutes from './routesSession'; <br class="title-page-name"/>import jsonGraph from 'falcor-json-graph'; // this is new <br class="title-page-name"/>import jwt from 'jsonwebtoken'; <br class="title-page-name"/>import jwtSecret from './configSecret'; <br class="title-page-name"/><br class="title-page-name"/>let $ref = jsonGraph.ref; // this is new <br class="title-page-name"/>let $atom = jsonGraph.atom; // this is new <br class="title-page-name"/>const Article = configMongoose.Article; 
</pre>
<p class="calibre2">In the preceding code snippet, the only new thing is that we import <kbd class="calibre11">jsonGraph</kbd> from <kbd class="calibre11">'falcor-json-graph';</kbd> and then add <kbd class="calibre11">let $ref = jsonGraph.ref;</kbd> and <kbd class="calibre11">let</kbd> <kbd class="calibre11">$atom = jsonGraph.atom</kbd>.</p>
<p class="calibre2">We have added the <kbd class="calibre11">$ref</kbd> sentinel in our <kbd class="calibre11">routes.js</kbd> scope. We need to prepare a new route, <kbd class="calibre11">articlesById[{keys}]["_id","articleTitle","articleContent","articleContentJSON"]</kbd>, as follows:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>    route: 'articlesById[{keys}]["_id","articleTitle", <br class="title-page-name"/>     "articleContent","articleContentJSON"]', <br class="title-page-name"/>      get: function(pathSet) { <br class="title-page-name"/>      let articlesIDs = pathSet[1]; <br class="title-page-name"/>      return Article.find({ <br class="title-page-name"/>            '_id': { $in: articlesIDs} <br class="title-page-name"/>        }, function(err, articlesDocs) { <br class="title-page-name"/>          return articlesDocs; <br class="title-page-name"/>        }).then ((articlesArrayFromDB) =&gt; { <br class="title-page-name"/>          let results = []; <br class="title-page-name"/><br class="title-page-name"/>          articlesArrayFromDB.map((articleObject) =&gt; { <br class="title-page-name"/>            let articleResObj = articleObject.toObject(); <br class="title-page-name"/>            let currentIdString = String(articleResObj['_id']); <br class="title-page-name"/><br class="title-page-name"/>            if (typeof articleResObj.articleContentJSON !== <br class="title-page-name"/>             'undefined') { <br class="title-page-name"/>              articleResObj.articleContentJSON = <br class="title-page-name"/>               $atom(articleResObj.articleContentJSON); <br class="title-page-name"/>            } <br class="title-page-name"/><br class="title-page-name"/>            results.push({ <br class="title-page-name"/>              path: ['articlesById', currentIdString], <br class="title-page-name"/>              value: articleResObj <br class="title-page-name"/>            }); <br class="title-page-name"/>          }); <br class="title-page-name"/>          return results; <br class="title-page-name"/>        }); <br class="title-page-name"/>    } <br class="title-page-name"/>  }, 
</pre>
<p class="calibre2">The <kbd class="calibre11">articlesById[{keys}]</kbd> route is defined, and the keys are the IDs of the request URL that we need to return in the request, as you can see with <kbd class="calibre11">const articlesIDs = pathSet[1];</kbd>.</p>
<p class="calibre2">To be more specific regarding <kbd class="calibre11">pathSet</kbd>, check out this example:</p>
<pre class="calibre22">
// just an example: <br class="title-page-name"/>[ <br class="title-page-name"/>  { $type: 'ref', value: ['articlesById', '123456'] }, <br class="title-page-name"/>  { $type: 'ref', value: ['articlesById', '987654'] } <br class="title-page-name"/>] 
</pre>
<p class="calibre2">In this case, the <kbd class="calibre11">falcor-router</kbd> will follow <kbd class="calibre11">articlesById</kbd>, and in the <kbd class="calibre11">pathSet</kbd>, you will get this (you can see the exact value of the <kbd class="calibre11">pathSet</kbd>):</p>
<pre class="calibre22">
['articlesById', ['123456', '987654']] 
</pre>
<p class="calibre2">The value of the <kbd class="calibre11">articlesIDs</kbd> from <kbd class="calibre11">const articlesIDs = pathSet[1]</kbd><kbd class="calibre11">;</kbd> you can find here:</p>
<pre class="calibre22">
['123456', '987654'] 
</pre>
<p class="calibre2">As you will find later, we use this <kbd class="calibre11">articlesIDs</kbd> value next:</p>
<pre class="calibre22">
// this is already in your codebase: <br class="title-page-name"/>return Article.find({ <br class="title-page-name"/>            '_id': { $in: articlesIDs} <br class="title-page-name"/>        }, function(err, articlesDocs) { 
</pre>
<p class="calibre2">As you can see in <kbd class="calibre11">'_id': { $in: articlesIDs}</kbd>, we are passing an array of <kbd class="calibre11">articlesIDs</kbd>. Based on those IDs, we will receive an array of certain articles found by IDs (the SQL <kbd class="calibre11">WHERE</kbd> equivalent). The next step here is iterating over received articles:</p>
<pre class="calibre22">
// this already is in your codebase: <br class="title-page-name"/>articlesArrayFromDB.map((articleObject) =&gt; { 
</pre>
<p class="calibre2">Push the object into the <kbd class="calibre11">results</kbd> array:</p>
<pre class="calibre22">
// this already is in your codebase: <br class="title-page-name"/>let articleResObj = articleObject.toObject(); <br class="title-page-name"/>let currentIdString = String(articleResObj['_id']); <br class="title-page-name"/><br class="title-page-name"/>if (typeof articleResObj.articleContentJSON !== 'undefined') { <br class="title-page-name"/>  articleResObj.articleContentJSON = <br class="title-page-name"/>   $atom(articleResObj.articleContentJSON); <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>results.push({ <br class="title-page-name"/>  path: ['articlesById', currentIdString], <br class="title-page-name"/>  value: articleResObj <br class="title-page-name"/>}); 
</pre>
<p class="calibre2">Almost nothing is new in the preceding code snippet. The only new thing is this statement:</p>
<pre class="calibre22">
// this already is in your codebase: <br class="title-page-name"/>if (typeof articleResObj.articleContentJSON !== 'undefined') { <br class="title-page-name"/>  articleResObj.articleContentJSON = <br class="title-page-name"/>   $atom(articleResObj.articleContentJSON); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">We are explicitly using the <kbd class="calibre11">$atom</kbd> sentinel from Falcor here: <kbd class="calibre11">$atom(articleResObj.articleContentJSON);</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">JSON Graph atoms</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">$atom</kbd> sentinel is metadata attached to values, which has to be handled differently by the model. You can very simply return a value of a number type or a value of a string type with Falcor. It's more tricky for Falcor to return an object. Why?</p>
<p class="calibre2">Falcor is diffing with heavy usage of JavaScript's objects and arrays, and when we tell that an object/array is wrapped by an <kbd class="calibre11">$atom</kbd> sentinel (such as <kbd class="calibre11">$atom(articleResObj.articleContentJSON</kbd>) in our example), then Falcor knows that it shouldn't go deeper into that array/object. It's made that way by design for performance reasons.</p>
<p class="calibre2">What performance reasons? For example, if you return an array of 10,000 very deep objects without wrapping the array, it may take a very, very long time to build and diff the model. Generally, for performance reasons, any objects and arrays that you want to return via <kbd class="calibre11">falcor-router</kbd> to the frontend have to be wrapped by an <kbd class="calibre11">$atom</kbd> before doing so; otherwise, you will get an error like this (if you don't wrap by <kbd class="calibre11">$atom</kbd> this object):</p>
<pre class="calibre22">
Uncaught MaxRetryExceededError: The allowed number of retries <br class="title-page-name"/>have been exceeded. 
</pre>
<p class="calibre2">This error will be shown on the client side while Falcor tries to fetch those deeper objects without being wrapped by an <kbd class="calibre11">$atom</kbd> sentinel beforehand on the backend.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Improving the articles[{integers}] route</h1>
            

            <article>
                
<p class="calibre2">We now need to return a <kbd class="calibre11">$ref</kbd> sentinel to <kbd class="calibre11">articlesById</kbd> instead of all of the articles' details, so we need to change this old code:</p>
<pre class="calibre22">
// this already shall be in your codebase: <br class="title-page-name"/>  { <br class="title-page-name"/>    route: <br class="title-page-name"/>     'articles[{integers}]["_id","articleTitle","articleContent"]', <br class="title-page-name"/>    get: (pathSet) =&gt; { <br class="title-page-name"/>      const articlesIndex = pathSet[1]; <br class="title-page-name"/><br class="title-page-name"/>      return Article.find({}, function(err, articlesDocs) { <br class="title-page-name"/>        return articlesDocs; <br class="title-page-name"/>      }).then ((articlesArrayFromDB) =&gt; { <br class="title-page-name"/>        let results = []; <br class="title-page-name"/>        articlesIndex.forEach((index) =&gt; { <br class="title-page-name"/>          const singleArticleObject = <br class="title-page-name"/>           articlesArrayFromDB[index].toObject(); <br class="title-page-name"/><br class="title-page-name"/>          const falcorSingleArticleResult = { <br class="title-page-name"/>            path: ['articles', index], <br class="title-page-name"/>            value: singleArticleObject <br class="title-page-name"/>          }; <br class="title-page-name"/><br class="title-page-name"/>          results.push(falcorSingleArticleResult); <br class="title-page-name"/>        }); <br class="title-page-name"/>        return results; <br class="title-page-name"/>      }) <br class="title-page-name"/>    } <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">We'll improve that to this new code:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>    route: 'articles[{integers}]', <br class="title-page-name"/>    get: (pathSet) =&gt; { <br class="title-page-name"/>      const articlesIndex = pathSet[1]; <br class="title-page-name"/><br class="title-page-name"/>      return Article.find({}, '_id', function(err, articlesDocs) { <br class="title-page-name"/>        return articlesDocs; <br class="title-page-name"/>      }).then ((articlesArrayFromDB) =&gt; { <br class="title-page-name"/>        let results = []; <br class="title-page-name"/>        articlesIndex.forEach((index) =&gt; { <br class="title-page-name"/>          let currentMongoID = <br class="title-page-name"/>           String(articlesArrayFromDB[index]['_id']); <br class="title-page-name"/>          let articleRef = $ref(['articlesById', currentMongoID]); <br class="title-page-name"/><br class="title-page-name"/>          const falcorSingleArticleResult = { <br class="title-page-name"/>            path: ['articles', index], <br class="title-page-name"/>            value: articleRef <br class="title-page-name"/>          }; <br class="title-page-name"/><br class="title-page-name"/>          results.push(falcorSingleArticleResult); <br class="title-page-name"/>        }); <br class="title-page-name"/>        return results; <br class="title-page-name"/>      }) <br class="title-page-name"/>    } <br class="title-page-name"/>  }, 
</pre>
<p class="calibre2">What has been changed? Look at the route in the old codebase: <kbd class="calibre11">articles[{integers}]["_id","articleTitle","articleContent"]</kbd>. Currently, our <kbd class="calibre11">articles[{integers}]</kbd> route doesn't directly return (in the new version) the <kbd class="calibre11">for["_id","articleTitle","articleContent"]</kbd> data, so we had to delete it in order to get Falcor know about this fact (the <kbd class="calibre11">articlesById</kbd> is returning detailed information now).</p>
<p class="calibre2">The next thing that has been changed is that we create a new <kbd class="calibre11">$ref</kbd> sentinel with the following:</p>
<pre class="calibre22">
// this is already in your codebase: <br class="title-page-name"/>let currentMongoID = String(articlesArrayFromDB[index]['_id']); <br class="title-page-name"/>let articleRef = $ref(['articlesById', currentMongoID]); 
</pre>
<p class="calibre2">As you see, by doing this, we are informing (with <kbd class="calibre11">$ref</kbd>) <kbd class="calibre11">falcor-router</kbd> that if the frontend requests any more information about <kbd class="calibre11">article[{integers}]</kbd>, then the <kbd class="calibre11">falcor-router</kbd> should follow the <kbd class="calibre11">articlesById</kbd> route in order to retrieve that data from the database.</p>
<p class="calibre2">After this, look at this old path's value:</p>
<pre class="calibre22">
// old version <br class="title-page-name"/>const singleArticleObject = articlesArrayFromDB[index].toObject(); <br class="title-page-name"/><br class="title-page-name"/>const falcorSingleArticleResult = { <br class="title-page-name"/>  path: ['articles', index], <br class="title-page-name"/>  value: singleArticleObject <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">You'll find that it has been replaced by the value of <kbd class="calibre11">articleRef</kbd>:</p>
<pre class="calibre22">
// new improved version <br class="title-page-name"/>let articleRef = $ref(['articlesById', currentMongoID]); <br class="title-page-name"/><br class="title-page-name"/>const falcorSingleArticleResult = { <br class="title-page-name"/>  path: ['articles', index], <br class="title-page-name"/>  value: articleRef <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">As you can probably spot, in the old version we were returning all of the information about an article (the <kbd class="calibre11">singleArticleObject</kbd> variable), but in the new version we return only the <kbd class="calibre11">$ref</kbd> sentinel<kbd class="calibre11">(articleRef)</kbd>.</p>
<div class="packt_infobox">The <kbd class="calibre23">$ref</kbd> sentinels make <kbd class="calibre23">falcor-router</kbd> automatically follow on the backend, so if there are any refs in the first route, Falcor resolves all the <kbd class="calibre23">$ref</kbd> sentinels until it gets all the pending data; after that, it returns the data in a single request, which saves a lot of latency (instead of performing several HTTP requests, everything followed with <kbd class="calibre23">$refs</kbd> is fetched in one browser-to-backend call).</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">New route in server/routes.js: articles.add</h1>
            

            <article>
                
<p class="calibre2">The only thing left that we need to do is add into the router a new <kbd class="calibre11">articles.add</kbd> route:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>    route: 'articles.add', <br class="title-page-name"/>    call: (callPath, args) =&gt; { <br class="title-page-name"/>      const newArticleObj = args[0]; <br class="title-page-name"/>      var article = new Article(newArticleObj); <br class="title-page-name"/><br class="title-page-name"/>      return article.save(function (err, data) { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>        else { <br class="title-page-name"/>          return data; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then ((data) =&gt; { <br class="title-page-name"/>        return Article.count({}, function(err, count) { <br class="title-page-name"/>        }).then((count) =&gt; { <br class="title-page-name"/>          return { count, data }; <br class="title-page-name"/>        }); <br class="title-page-name"/>      }).then ((res) =&gt; { <br class="title-page-name"/>        // <br class="title-page-name"/>        // we will add more stuff here in a moment, below <br class="title-page-name"/>        // <br class="title-page-name"/>        return results; <br class="title-page-name"/>      }); <br class="title-page-name"/>    } <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">As you can see here, we receive from the frontend a new article's details with <kbd class="calibre11">const newArticleObj = args[0];</kbd>, and later we create a new <kbd class="calibre11">Article</kbd> model with <kbd class="calibre11">var article = new Article(newArticleObj);</kbd>. After that, the <kbd class="calibre11">article</kbd> variable has a <kbd class="calibre11">.save</kbd> method, which is called in the following query. We perform two queries that return a promise from Mongoose. Here's the first:</p>
<pre class="calibre22">
return article.save(function (err, data) { 
</pre>
<p class="calibre2">This <kbd class="calibre11">.save</kbd> method simply helps us insert the document into the database. After we have saved the article, we need to count how many there are in our database, so we run a second query:</p>
<pre class="calibre22">
return Article.count({}, function(err, count) { 
</pre>
<p class="calibre2">After we have saved the article and counted it, we return that information (<kbd class="calibre11">return { count, data };</kbd>). The last thing is to return the new article ID and the count number from the backend to the frontend with the help of <kbd class="calibre11">falcor-router</kbd>, so we replace this comment:</p>
<pre class="calibre22">
// <br class="title-page-name"/>// we will add more stuff here in a moment, below <br class="title-page-name"/>// 
</pre>
<p class="calibre2">In its place, we'll have this new code that helps us make things happen:</p>
<pre class="calibre22">
 let newArticleDetail = res.data.toObject(); <br class="title-page-name"/> let newArticleID = String(newArticleDetail['_id']); <br class="title-page-name"/> let NewArticleRef = $ref(['articlesById', newArticleID]); <br class="title-page-name"/> let results = [ <br class="title-page-name"/>   { <br class="title-page-name"/>     path: ['articles', res.count-1], <br class="title-page-name"/>     value: NewArticleRef <br class="title-page-name"/>   }, <br class="title-page-name"/>   { <br class="title-page-name"/>     path: ['articles', 'newArticleID'], <br class="title-page-name"/>     value: newArticleID <br class="title-page-name"/>   }, <br class="title-page-name"/>   { <br class="title-page-name"/>     path: ['articles', 'length'], <br class="title-page-name"/>     value: res.count <br class="title-page-name"/>   } <br class="title-page-name"/> ]; <br class="title-page-name"/> return results; 
</pre>
<p class="calibre2">As you can see in the preceding code snippet, we get the <kbd class="calibre11">newArticleDetail</kbd> details here. Next, we take the new ID with <kbd class="calibre11">newArticleID</kbd> and make sure that it's a string. After all that, we define a new <kbd class="calibre11">$ref</kbd> sentinel with <kbd class="calibre11">let NewArticleRef = $ref(['articlesById', newArticleID]);</kbd>.</p>
<p class="calibre2">In the <kbd class="calibre11">results</kbd> variable, you can find three new paths:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">path: ['articles', res.count-1]</kbd>: This path builds up the model, so we can have all the information in the Falcor model after we receive the response on the client side</li>
<li class="calibre15"><kbd class="calibre11">path: ['articles', 'newArticleID']</kbd>: This helps us quickly fetch the new ID on the frontend</li>
<li class="calibre15"><kbd class="calibre11">path: ['articles', 'length']</kbd>: This, of course, updates the length of our articles' collections, so the frontend's Falcor model can have up-to-date information after we have added a new article</li>
</ul>
<p class="calibre2">We just have made a backend route for adding an article. Let's now start working on the frontend so that we will be able to push all our new articles into the database.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Frontend changes in order to add articles</h1>
            

            <article>
                
<p class="calibre2">In the <kbd class="calibre11">src/layouts/PublishingApp.js</kbd> file, find this code:</p>
<pre class="calibre22">
get(['articles', {from: 0, to: articlesLength-1}, ['_id','articleTitle', 'articleContent']]). 
</pre>
<p class="calibre2">Change it to an improved version with <kbd class="calibre11">articleContentJSON</kbd>:</p>
<pre class="calibre22">
get(['articles', {from: 0, to: articlesLength-1}, ['_id','articleTitle', 'articleContent', 'articleContentJSON']]).  
</pre>
<p class="calibre2">The next step is to improve our <kbd class="calibre11">_submitArticle</kbd> function in <kbd class="calibre11">src/views/articles/AddArticleView.js</kbd> and add a <kbd class="calibre11">falcorModel</kbd> import:</p>
<pre class="calibre22">
// this is old function to replace: <br class="title-page-name"/>  _articleSubmit() { <br class="title-page-name"/>    let newArticle = { <br class="title-page-name"/>      articleTitle: this.state.title, <br class="title-page-name"/>      articleContent: this.state.htmlContent, <br class="title-page-name"/>      articleContentJSON: this.state.contentJSON <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    let newArticleID = 'MOCKEDRandomid' + Math.floor(Math.random() *    <br class="title-page-name"/>    10000); <br class="title-page-name"/><br class="title-page-name"/>    newArticle['_id'] = newArticleID; <br class="title-page-name"/>    this.props.articleActions.pushNewArticle(newArticle); <br class="title-page-name"/>    this.setState({ newArticleID: newArticleID}); <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">Replace this code with the following improved version:</p>
<pre class="calibre22">
 async _articleSubmit() { <br class="title-page-name"/>    let newArticle = { <br class="title-page-name"/>      articleTitle: this.state.title, <br class="title-page-name"/>      articleContent: this.state.htmlContent, <br class="title-page-name"/>      articleContentJSON: this.state.contentJSON <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    let newArticleID = await falcorModel <br class="title-page-name"/>      .call( <br class="title-page-name"/>            'articles.add', <br class="title-page-name"/>            [newArticle] <br class="title-page-name"/>          ). <br class="title-page-name"/>      then((result) =&gt; { <br class="title-page-name"/>        return falcorModel.getValue( <br class="title-page-name"/>            ['articles', 'newArticleID'] <br class="title-page-name"/>          ).then((articleID) =&gt; { <br class="title-page-name"/>            return articleID; <br class="title-page-name"/>          }); <br class="title-page-name"/>      }); <br class="title-page-name"/><br class="title-page-name"/>    newArticle['_id'] = newArticleID; <br class="title-page-name"/>    this.props.articleActions.pushNewArticle(newArticle); <br class="title-page-name"/>    this.setState({ newArticleID: newArticleID}); <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">Also, at the top of the <kbd class="calibre11">AddArticleView.js</kbd> file, add this import; otherwise, <kbd class="calibre11">async_articleSumbit</kbd> won't work:</p>
<pre class="calibre22">
import falcorModel from '../../falcorModel.js'; 
</pre>
<p class="calibre2">As you can see, we have added the <kbd class="calibre11">async</kbd> keyword before the function name (<kbd class="calibre11">async _articleSubmit()</kbd>). The new thing is this request:</p>
<pre class="calibre22">
// this already is in your codebase: <br class="title-page-name"/>let newArticleID = await falcorModel <br class="title-page-name"/>  .call( <br class="title-page-name"/>        'articles.add', <br class="title-page-name"/>        [newArticle] <br class="title-page-name"/>      ). <br class="title-page-name"/>  then((result) =&gt; { <br class="title-page-name"/>    return falcorModel.getValue( <br class="title-page-name"/>        ['articles', 'newArticleID'] <br class="title-page-name"/>      ).then((articleID) =&gt; { <br class="title-page-name"/>        return articleID; <br class="title-page-name"/>      }); <br class="title-page-name"/>  }); 
</pre>
<p class="calibre2">Here, we wait for <kbd class="calibre11">falcorModel.call</kbd>. In the <kbd class="calibre11">.call</kbd> arguments, we add <kbd class="calibre11">newArticle</kbd>. Then, after the promise is resolved, we check what the <kbd class="calibre11">newArticleID</kbd> is with the following:</p>
<pre class="calibre22">
// this already is in your codebase: <br class="title-page-name"/>return falcorModel.getValue( <br class="title-page-name"/>        ['articles', 'newArticleID'] <br class="title-page-name"/>      ).then((articleID) =&gt; { <br class="title-page-name"/>        return articleID; <br class="title-page-name"/>      }); 
</pre>
<p class="calibre2">Later, we simply use exactly the same stuff as in the old version:</p>
<pre class="calibre22">
newArticle['_id'] = newArticleID; <br class="title-page-name"/>this.props.articleActions.pushNewArticle(newArticle); <br class="title-page-name"/>this.setState({ newArticleID: newArticleID}); 
</pre>
<p class="calibre2">This simply pushes the updated <kbd class="calibre11">newArticle</kbd> with a real ID from MongoDB via the <kbd class="calibre11">articleActions</kbd> into the article's reducer. We also use <kbd class="calibre11">setState</kbd> with the <kbd class="calibre11">newArticleID</kbd> so you can see that the new article has been created correctly with a real Mongo ID.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Important note about route returns</h1>
            

            <article>
                
<p class="calibre2">You should be aware that in every route, we return an object or an array of an object; both approaches are fine even with one route to return. Take this, for example:</p>
<pre class="calibre22">
// this already is in your codebase (just an example) <br class="title-page-name"/>    { <br class="title-page-name"/>    route: 'articles.length', <br class="title-page-name"/>      get: () =&gt; { <br class="title-page-name"/>        return Article.count({}, function(err, count) { <br class="title-page-name"/>          return count; <br class="title-page-name"/>        }).then ((articlesCountInDB) =&gt; { <br class="title-page-name"/>          return { <br class="title-page-name"/>            path: ['articles', 'length'], <br class="title-page-name"/>            value: articlesCountInDB <br class="title-page-name"/>          } <br class="title-page-name"/>        }) <br class="title-page-name"/>    } <br class="title-page-name"/>  },  
</pre>
<p class="calibre2">This can also return an array with one object, as follows:</p>
<pre class="calibre22">
     get: () =&gt; { <br class="title-page-name"/>        return Article.count({}, function(err, count) { <br class="title-page-name"/>          return count; <br class="title-page-name"/>        }).then ((articlesCountInDB) =&gt; { <br class="title-page-name"/>          return [ <br class="title-page-name"/>            { <br class="title-page-name"/>              path: ['articles', 'length'], <br class="title-page-name"/>              value: articlesCountInDB <br class="title-page-name"/>            } <br class="title-page-name"/>          ] <br class="title-page-name"/>        }) <br class="title-page-name"/>    } 
</pre>
<p class="calibre2">As you can see, even with one <kbd class="calibre11">articles.length</kbd>, we are returning an array (instead of a single object), and this will also work.</p>
<p class="calibre2">For the same reason as described previously, this is why, in <kbd class="calibre11">articlesById</kbd>, we have pushed multiple routes into the array:</p>
<pre class="calibre22">
// this is already in your codebase <br class="title-page-name"/>let results = []; <br class="title-page-name"/><br class="title-page-name"/>articlesArrayFromDB.map((articleObject) =&gt; { <br class="title-page-name"/>  let articleResObj = articleObject.toObject(); <br class="title-page-name"/>  let currentIdString = String(articleResObj['_id']); <br class="title-page-name"/><br class="title-page-name"/>  if (typeof articleResObj.articleContentJSON !== 'undefined') { <br class="title-page-name"/>    articleResObj.articleContentJSON = <br class="title-page-name"/>     $atom(articleResObj.articleContentJSON); <br class="title-page-name"/>  } <br class="title-page-name"/>  // pushing multiple routes <br class="title-page-name"/>  results.push({ <br class="title-page-name"/>    path: ['articlesById', currentIdString], <br class="title-page-name"/>    value: articleResObj <br class="title-page-name"/>  }); <br class="title-page-name"/>}); <br class="title-page-name"/>return results; // returning array of routes' objects 
</pre>
<p class="calibre2">This is one thing that may be worth mentioning in the Falcor chapter.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Full-stack - editing and deleting an article</h1>
            

            <article>
                
<p class="calibre2">Let's create a route in the <kbd class="calibre11">server/routes.js</kbd> file for updating an existing document (edit feature):</p>
<pre class="calibre22">
 { <br class="title-page-name"/>  route: 'articles.update', <br class="title-page-name"/>  call: async (callPath, args) =&gt;  <br class="title-page-name"/>    { <br class="title-page-name"/>      let updatedArticle = args[0]; <br class="title-page-name"/>      let articleID = String(updatedArticle._id); <br class="title-page-name"/>      let article = new Article(updatedArticle); <br class="title-page-name"/>      article.isNew = false; <br class="title-page-name"/><br class="title-page-name"/>      return article.save(function (err, data) { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then ((res) =&gt; { <br class="title-page-name"/>        return [ <br class="title-page-name"/>          { <br class="title-page-name"/>            path: ['articlesById', articleID], <br class="title-page-name"/>            value: updatedArticle <br class="title-page-name"/>          }, <br class="title-page-name"/>          { <br class="title-page-name"/>            path: ['articlesById', articleID], <br class="title-page-name"/>            invalidate: true <br class="title-page-name"/>          } <br class="title-page-name"/>        ]; <br class="title-page-name"/>      }); <br class="title-page-name"/>    } <br class="title-page-name"/>  }, 
</pre>
<p class="calibre2">As you can see here, we still use the <kbd class="calibre11">article.save</kbd> approach similar to the <kbd class="calibre11">articles.add</kbd> route. The important thing to note is that Mongoose requires the <kbd class="calibre11">isNew</kbd> flag to be <kbd class="calibre11">false</kbd> (<kbd class="calibre11">article.isNew = false;</kbd>). If you don't give this flag, then you will get a Mongoose error similar to this:</p>
<pre class="calibre22">
{"error":{"name":"MongoError","code":11000,"err":"insertDocument <br class="title-page-name"/> :: caused by :: 11000 E11000 duplicate key error index: <br class="title-page-name"/> staging.articles.$_id _ dup key: { : <br class="title-page-name"/> ObjectId('1515b34ed65022ec234b5c5f') }"}} 
</pre>
<p class="calibre2">The rest of the code is quite simple; we save the article's model and then return the updated model via <kbd class="calibre11">falcor-router</kbd> with the following:</p>
<pre class="calibre22">
// this is already in your code base: <br class="title-page-name"/>return [ <br class="title-page-name"/>  { <br class="title-page-name"/>    path: ['articlesById', articleID], <br class="title-page-name"/>    value: updatedArticle <br class="title-page-name"/>  }, <br class="title-page-name"/>  { <br class="title-page-name"/>    path: ['articlesById', articleID], <br class="title-page-name"/>    invalidate: true <br class="title-page-name"/>  } <br class="title-page-name"/>]; 
</pre>
<p class="calibre2">The new thing is the <kbd class="calibre11">invalidate</kbd> flag. As it states in the documentation, "invalidate method synchronously removes several Paths or PathSets from a Model cache." In other words, you need to tell the Falcor model on the frontend that something has been changed in the <kbd class="calibre11">["articlesById", articleID]</kbd> path so that you will have synced data on both backend and frontend.</p>
<div class="packt_infobox">For more stuff about <kbd class="calibre23">invalidate</kbd> in Falcor, you can go to <a href="https://netflix.github.io/falcor/doc/Model.html#invalidate" class="calibre27"><span class="packt_screen">https://netflix.github.io/falcor/doc/Model.html#invalidate</span></a>.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Deleting an article</h1>
            

            <article>
                
<p class="calibre2">In order to implement the <kbd class="calibre11">delete</kbd> feature, we need to create a new route:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>  route: 'articles.delete', <br class="title-page-name"/>  call: (callPath, args) =&gt;  <br class="title-page-name"/>    { <br class="title-page-name"/>      const toDeleteArticleId = args[0]; <br class="title-page-name"/>      return Article.find({ _id: toDeleteArticleId }). <br class="title-page-name"/>       remove((err) =&gt; { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then((res) =&gt; { <br class="title-page-name"/>        return [ <br class="title-page-name"/>          { <br class="title-page-name"/>            path: ['articlesById', toDeleteArticleId], <br class="title-page-name"/>            invalidate: true <br class="title-page-name"/>          } <br class="title-page-name"/>        ] <br class="title-page-name"/>      }); <br class="title-page-name"/>    } <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">This also uses <kbd class="calibre11">invalidate</kbd>, but this time, this is the only thing that we return here, as the document has been deleted, so the only thing we need to do is to inform the browser's cache that the old article has been invalidated and there is nothing to replace it as in the update example.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Frontend - edit and delete</h1>
            

            <article>
                
<p class="calibre2">We have implemented the <kbd class="calibre11">update</kbd> and <kbd class="calibre11">delete</kbd> routes on the backend. Next, in the <kbd class="calibre11">src/views/articles/EditArticleView.js</kbd> file, you need to find this code:</p>
<pre class="calibre22">
// this is old already in your codebase: <br class="title-page-name"/>  _articleEditSubmit() { <br class="title-page-name"/>    let currentArticleID = this.state.editedArticleID; <br class="title-page-name"/>    let editedArticle = { <br class="title-page-name"/>      _id: currentArticleID, <br class="title-page-name"/>      articleTitle: this.state.title, <br class="title-page-name"/>      articleContent: this.state.htmlContent, <br class="title-page-name"/>      articleContentJSON: this.state.contentJSON <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    this.props.articleActions.editArticle(editedArticle); <br class="title-page-name"/>    this.setState({ articleEditSuccess: true }); <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">Replace it with this <kbd class="calibre11">async _articleEditSubmit</kbd> function:</p>
<pre class="calibre22">
 async _articleEditSubmit() { <br class="title-page-name"/>    let currentArticleID = this.state.editedArticleID; <br class="title-page-name"/>    let editedArticle = { <br class="title-page-name"/>      _id: currentArticleID, <br class="title-page-name"/>      articleTitle: this.state.title, <br class="title-page-name"/>      articleContent: this.state.htmlContent, <br class="title-page-name"/>      articleContentJSON: this.state.contentJSON <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    let editResults = await falcorModel <br class="title-page-name"/>      .call( <br class="title-page-name"/>            ['articles', 'update'], <br class="title-page-name"/>            [editedArticle] <br class="title-page-name"/>          ). <br class="title-page-name"/>      then((result) =&gt; { <br class="title-page-name"/>        return result; <br class="title-page-name"/>      }); <br class="title-page-name"/><br class="title-page-name"/>    this.props.articleActions.editArticle(editedArticle); <br class="title-page-name"/>    this.setState({ articleEditSuccess: true }); <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">As you can see here, the most important thing is that we implemented the <kbd class="calibre11">.call</kbd> function in the <kbd class="calibre11">_articleEditSubmit</kbd> function that sends details of an edited object with the <kbd class="calibre11">editedArticle</kbd> variable.</p>
<p class="calibre2">In the same file, find the <kbd class="calibre11">_handleDeletion</kbd> method:</p>
<pre class="calibre22">
// old version <br class="title-page-name"/>  _handleDeletion() { <br class="title-page-name"/>    let articleID = this.state.editedArticleID; <br class="title-page-name"/>    this.props.articleActions.deleteArticle(articleID); <br class="title-page-name"/><br class="title-page-name"/>    this.setState({ <br class="title-page-name"/>      openDelete: false <br class="title-page-name"/>    }); <br class="title-page-name"/>    this.props.history.pushState(null, '/dashboard'); <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">Change it to the new improved version:</p>
<pre class="calibre22">
 async _handleDeletion() { <br class="title-page-name"/>    let articleID = this.state.editedArticleID; <br class="title-page-name"/><br class="title-page-name"/>    let deletetionResults = await falcorModel <br class="title-page-name"/>      .call( <br class="title-page-name"/>            ['articles', 'delete'], <br class="title-page-name"/>            [articleID] <br class="title-page-name"/>          ). <br class="title-page-name"/>      then((result) =&gt; { <br class="title-page-name"/>        return result; <br class="title-page-name"/>      }); <br class="title-page-name"/><br class="title-page-name"/>    this.props.articleActions.deleteArticle(articleID); <br class="title-page-name"/>    this.setState({ <br class="title-page-name"/>      openDelete: false <br class="title-page-name"/>    }); <br class="title-page-name"/>    this.props.history.pushState(null, '/dashboard'); <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">Similar to the deletion, the only difference is that we only send <kbd class="calibre11">articleID</kbd> of a deleted article with <kbd class="calibre11">.call</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Securing the CRUD routes</h1>
            

            <article>
                
<p class="calibre2">We need to implement a way to secure all add/edit/delete routes and also make a universal <strong class="calibre1">DRY</strong> (<strong class="calibre1">don't repeat yourself</strong>) way of informing the user of errors that occurred on the backend. For example, errors that may occur on the frontend, and we need to inform the user with an error message in our React instance's client-side app:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Auth error</strong>: You are not authorized to perform the action</li>
<li class="calibre15"><strong class="calibre1">Timeout error</strong>: For example, you use an external API's service; we need to inform the user of any potential errors</li>
<li class="calibre15"><strong class="calibre1">Data doesn't exist</strong>: There may be a case where a user will call for the ID of an article that doesn't exist in our DB, so let's inform him</li>
</ul>
<p class="calibre2">In general, our goal for now is to create one universal way of moving all potential error messages on the backend to the client side so that we can improve the general experience of using our application.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The $error sentinel basics</h1>
            

            <article>
                
<p class="calibre2">There is the <kbd class="calibre11">$error</kbd> sentinel (variable type related to Falcor), which is generally an approach to returning errors.</p>
<p class="calibre2">Generally, as you should already know, Falcor batches requests. Thanks to them, you can fetch data from different falcor-routes in one HTTP request. The following example is what you can fetch in one go:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">One dataset</strong>: Complete and ready to retrieve</li>
<li class="calibre15"><strong class="calibre1">Second dataset</strong>: Second dataset, may contain an error</li>
</ul>
<p class="calibre2">We don't want to influence the fetching process of one dataset when there is an error in the second dataset (you need to remember that the two datasets from our example are fetched in one request).</p>
<div class="packt_infobox">Useful parts from the documentation that may help you understand error handling in Falcor are available here:<br class="calibre24"/>
<a href="https://netflix.github.io/falcor/doc/Model.html#~errorSelector" class="calibre27">https://netflix.github.io/falcor/doc/Model.html#~errorSelector</a><br class="calibre24"/>
<a href="https://netflix.github.io/falcor/documentation/model.html#error-handling" class="calibre27">https://netflix.github.io/falcor/documentation/model.html#error-handling</a><br class="calibre24"/>
<a href="http://netflix.github.io/falcor/documentation/router.html" class="calibre27"><span class="packt_screen">http://netflix.github.io/falcor/documentation/router.html</span></a> (search for <kbd class="calibre23">$error</kbd> on this page to find more examples from the documentation)</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">DRY error management on the client side</h1>
            

            <article>
                
<p class="calibre2">Let's start with improvements to the CoreLayout (<kbd class="calibre11">src/layouts/CoreLayout.js</kbd>). Under <kbd class="calibre11">AppBar</kbd>, import a new <kbd class="calibre11">snackbar</kbd> component with this:</p>
<pre class="calibre22">
import AppBar from 'material-ui/lib/app-bar'; <br class="title-page-name"/>import Snackbar from 'material-ui/lib/snackbar'; 
</pre>
<p class="calibre2">Then, under the imports, outside the CoreLayout, create a new function and export it:</p>
<pre class="calibre22">
let errorFuncUtil =  (errMsg, errPath) =&gt; { <br class="title-page-name"/>} <br class="title-page-name"/>export { errorFuncUtil as errorFunc }; 
</pre>
<p class="calibre2">Then find the <kbd class="calibre11">CoreLayout</kbd> constructor to change it to use the exported function called <kbd class="calibre11">errorFuncUtil</kbd> as a callback in the base in case of an error returned by the Falcor <kbd class="calibre11">$error</kbd> sentinel:</p>
<pre class="calibre22">
// old constructor <br class="title-page-name"/>constructor(props) { <br class="title-page-name"/>  super(props); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Here's the new one:</p>
<pre class="calibre22">
constructor(props) { <br class="title-page-name"/>  super(props); <br class="title-page-name"/>    this.state = { <br class="title-page-name"/>      errorValue: null <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>  if (typeof window !== 'undefined') { <br class="title-page-name"/>    errorFuncUtil = this.handleFalcorErrors.bind(this); <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>} 
</pre>
<p class="calibre2">As you can find here, we have introduced a new <kbd class="calibre11">errorValue</kbd> state (the default state is <kbd class="calibre11">null</kbd>). Then, on the frontend only (because of <kbd class="calibre11">if(typeof window !== 'undefined')</kbd>), we assign <kbd class="calibre11">this.handleErrors.bind(this)</kbd> to our <kbd class="calibre11">errorFuncUtil</kbd>.</p>
<p class="calibre2">As you will find in a moment, this is so because the exported <kbd class="calibre11">errorFuncUtil</kbd> will be imported in our <kbd class="calibre11">falcorModel.js</kbd>, where we will use the best possible DRY way to inform our CoreLayout about any error occurring on the backend with Falcor. The great thing about this is that we will implement it just once, but it will be a universal way of informing our client-side app users of any errors (and it will also save us development effort in the future, as any error will be handled by the approach that we are implementing now).</p>
<p class="calibre2">We need to add a new function to our CoreLayout called <kbd class="calibre11">handleFalcorErrors</kbd>:</p>
<pre class="calibre22">
handleFalcorErrors(errMsg, errPath) { <br class="title-page-name"/>  let errorValue = &amp;grave;Error: ${errMsg} (path ${JSON.stringify(errPath)})&amp;grave; <br class="title-page-name"/>  this.setState({errorValue}); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The <kbd class="calibre11">handleFalcorErrors</kbd> function is setting the new state of our error. We will compose our error for the user with an <kbd class="calibre11">errMsg</kbd> (we create this on the backend, as you will learn in a moment) and the <kbd class="calibre11">errPath</kbd> (optional, but this is the <kbd class="calibre11">falcor-route</kbd> path where the error has occurred).</p>
<p class="calibre2">Okay, we have everything in place; the only thing missing from the <kbd class="calibre11">CoreLayout</kbd> function is the improved render. The new render of the CoreLayout is as follows:</p>
<pre class="calibre22">
 render () { <br class="title-page-name"/>    let errorSnackbarJSX = null; <br class="title-page-name"/>    if (this.state.errorValue) { <br class="title-page-name"/>      errorSnackbarJSX = &lt;Snackbar <br class="title-page-name"/>        open={true} <br class="title-page-name"/>        message={this.state.errorValue} <br class="title-page-name"/>        autoHideDuration={8000} <br class="title-page-name"/>        onRequestClose={ () =&gt; console.log('You can add custom <br class="title-page-name"/>         onClose code') } /&gt;; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    const buttonStyle = { <br class="title-page-name"/>      margin: 5 <br class="title-page-name"/>    }; <br class="title-page-name"/>    const homeIconStyle = { <br class="title-page-name"/>      margin: 5, <br class="title-page-name"/>      paddingTop: 5 <br class="title-page-name"/>    }; <br class="title-page-name"/><br class="title-page-name"/>    let menuLinksJSX; <br class="title-page-name"/>    let userIsLoggedIn = typeof localStorage !== 'undefined' &amp;&amp; <br class="title-page-name"/>     localStorage.token &amp;&amp; this.props.routes[1].name !== 'logout'; <br class="title-page-name"/><br class="title-page-name"/>    if (userIsLoggedIn) { <br class="title-page-name"/>      menuLinksJSX = ( <br class="title-page-name"/>  &lt;span&gt; <br class="title-page-name"/>        &lt;Link to='/dashboard'&gt; <br class="title-page-name"/>     &lt;RaisedButton label='Dashboard' style={buttonStyle}  /&gt; <br class="title-page-name"/>  &lt;/Link&gt;  <br class="title-page-name"/>        &lt;Link to='/logout'&gt; <br class="title-page-name"/>     &lt;RaisedButton label='Logout' style={buttonStyle}  /&gt; <br class="title-page-name"/>  &lt;/Link&gt;  <br class="title-page-name"/>      &lt;/span&gt;); <br class="title-page-name"/>    } else { <br class="title-page-name"/>      menuLinksJSX = ( <br class="title-page-name"/>  &lt;span&gt; <br class="title-page-name"/>          &lt;Link to='/register'&gt; <br class="title-page-name"/>      &lt;RaisedButton label='Register' style={buttonStyle}  /&gt; <br class="title-page-name"/>  &lt;/Link&gt;  <br class="title-page-name"/>        &lt;Link to='/login'&gt; <br class="title-page-name"/>    &lt;RaisedButton label='Login' style={buttonStyle}  /&gt; <br class="title-page-name"/>  &lt;/Link&gt;  <br class="title-page-name"/>      &lt;/span&gt;); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    let homePageButtonJSX = ( <br class="title-page-name"/>    &lt;Link to='/'&gt; <br class="title-page-name"/>        &lt;RaisedButton label={&lt;ActionHome /&gt;} <br class="title-page-name"/>         style={homeIconStyle}  /&gt; <br class="title-page-name"/>      &lt;/Link&gt;); <br class="title-page-name"/>    return ( <br class="title-page-name"/><br class="title-page-name"/>        &lt;div&gt; <br class="title-page-name"/>          {errorSnackbarJSX} <br class="title-page-name"/>          &lt;AppBar <br class="title-page-name"/>            title='Publishing App' <br class="title-page-name"/>            iconElementLeft={homePageButtonJSX} <br class="title-page-name"/>            iconElementRight={menuLinksJSX} /&gt; <br class="title-page-name"/>            &lt;br/&gt; <br class="title-page-name"/>            {this.props.children} <br class="title-page-name"/>        &lt;/div&gt; <br class="title-page-name"/><br class="title-page-name"/>    ); <br class="title-page-name"/>  } 
</pre>
<p class="calibre2">As you can find here, the new parts are related to the Material-UI <kbd class="calibre11">snackbar</kbd> component. Take a look at this:</p>
<pre class="calibre22">
let errorSnackbarJSX = null; <br class="title-page-name"/>if (this.state.errorValue) { <br class="title-page-name"/>  errorSnackbarJSX = &lt;Snackbar <br class="title-page-name"/>    open={true} <br class="title-page-name"/>    message={this.state.errorValue} <br class="title-page-name"/>    autoHideDuration={8000} /&gt;; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">This code snippet is preparing our <kbd class="calibre11">erroSnackbarJSX</kbd> and the following:</p>
<pre class="calibre22">
  &lt;div&gt; <br class="title-page-name"/>    {errorSnackbarJSX} <br class="title-page-name"/>    &lt;AppBar <br class="title-page-name"/>      title='Publishing App' <br class="title-page-name"/>      iconElementLeft={homePageButtonJSX} <br class="title-page-name"/>      iconElementRight={menuLinksJSX} /&gt; <br class="title-page-name"/>      &lt;br/&gt; <br class="title-page-name"/>      {this.props.children} <br class="title-page-name"/>  &lt;/div&gt; 
</pre>
<p class="calibre2">Make sure <kbd class="calibre11">{errorSnackbarJSX}</kbd> is placed exactly the same way as in this example.  Otherwise, you may find some problems during the app's test run. You now have completed everything related to the CoreLayout improvements.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Tweaks - FalcorModel.js on the frontend</h1>
            

            <article>
                
<p class="calibre2">In the <kbd class="calibre11">src/falcorModel.js</kbd> file, identify the following code:</p>
<pre class="calibre22">
// already in your codebase, old code: <br class="title-page-name"/>import falcor from 'falcor'; <br class="title-page-name"/>import FalcorDataSource from 'falcor-http-datasource'; <br class="title-page-name"/><br class="title-page-name"/>class PublishingAppDataSource extends FalcorDataSource { <br class="title-page-name"/>  onBeforeRequest ( config ) { <br class="title-page-name"/>    const token = localStorage.token; <br class="title-page-name"/>    const username = localStorage.username; <br class="title-page-name"/>    const role = localStorage.role; <br class="title-page-name"/><br class="title-page-name"/>    if (token &amp;&amp; username &amp;&amp; role) { <br class="title-page-name"/>      config.headers['token'] = token; <br class="title-page-name"/>      config.headers['username'] = username; <br class="title-page-name"/>      config.headers['role'] = role; <br class="title-page-name"/>    } <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>const model = new falcor.Model({ <br class="title-page-name"/>  source: new PublishingAppDataSource('/model.json') <br class="title-page-name"/>}); <br class="title-page-name"/>export default model; 
</pre>
<p class="calibre2">This code has to be improved by adding a new option to the <kbd class="calibre11">falcor.Model</kbd>:</p>
<pre class="calibre22">
import falcor from 'falcor'; <br class="title-page-name"/>import FalcorDataSource from 'falcor-http-datasource'; <br class="title-page-name"/>import {errorFunc} from './layouts/CoreLayout'; <br class="title-page-name"/><br class="title-page-name"/>class PublishingAppDataSource extends FalcorDataSource { <br class="title-page-name"/>  onBeforeRequest ( config ) { <br class="title-page-name"/>    const token = localStorage.token; <br class="title-page-name"/>    const username = localStorage.username; <br class="title-page-name"/>    const role = localStorage.role; <br class="title-page-name"/><br class="title-page-name"/>    if (token &amp;&amp; username &amp;&amp; role) { <br class="title-page-name"/>      config.headers['token'] = token; <br class="title-page-name"/>      config.headers['username'] = username; <br class="title-page-name"/>      config.headers['role'] = role; <br class="title-page-name"/>    } <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>let falcorOptions = { <br class="title-page-name"/>  source: new PublishingAppDataSource('/model.json'),    <br class="title-page-name"/>  errorSelector: function(path, error) { <br class="title-page-name"/>    errorFunc(error.value, path); <br class="title-page-name"/>    error.$expires = -1000 * 60 * 2; <br class="title-page-name"/>    return error; <br class="title-page-name"/>  }  <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>const model = new falcor.Model(falcorOptions); <br class="title-page-name"/>export default model; 
</pre>
<p class="calibre2">The first thing we added is an import of <kbd class="calibre11">errorFunc</kbd> to the top of that file:</p>
<pre class="calibre22">
import {errorFunc} from './layouts/CoreLayout'; 
</pre>
<p class="calibre2">Besides <kbd class="calibre11">errorFunc</kbd>, we have introduced the <kbd class="calibre11">falcorOptions</kbd> variable. The source stays the same as in the previous version. We have added <kbd class="calibre11">errorSelector</kbd>, which is run every time the client side calls the backend and the <kbd class="calibre11">falcor-router</kbd> on the backend returns an <kbd class="calibre11">$error</kbd> sentinel.</p>
<p class="calibre2">More details on the error selector can be found at <a href="https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value" class="calibre6"><span>https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value</span></a>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Backend implementation of the $error sentinel</h1>
            

            <article>
                
<p class="calibre2">We will perform the backend implementation in two steps:</p>
<ol class="calibre17">
<li value="1" class="calibre15">An error example, just to test our client-side code.</li>
<li value="2" class="calibre15">After we are sure that the error handling is working correctly, we will secure the endpoints properly.</li>
</ol>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Testing our $error-related code</h1>
            

            <article>
                
<p class="calibre2">Let's start with imports in the <kbd class="calibre11">server/routes.js</kbd> file:</p>
<pre class="calibre22">
import configMongoose from './configMongoose'; <br class="title-page-name"/>import sessionRoutes from './routesSession'; <br class="title-page-name"/>import jsonGraph from 'falcor-json-graph'; <br class="title-page-name"/>import jwt from 'jsonwebtoken'; <br class="title-page-name"/>import jwtSecret from './configSecret'; <br class="title-page-name"/><br class="title-page-name"/>let $ref = jsonGraph.ref; <br class="title-page-name"/>let $atom = jsonGraph.atom; <br class="title-page-name"/>let $error = jsonGraph.error; <br class="title-page-name"/>const Article = configMongoose.Article; 
</pre>
<p class="calibre2">The only new thing is that you need to import the <kbd class="calibre11">$error</kbd> sentinel from <kbd class="calibre11">falcor-json-graph</kbd>.</p>
<div class="packt_infobox">The goal of our <kbd class="calibre23">$error</kbd> test is to replace a working route that is responsible for fetching articles <kbd class="calibre23">(articles[{integers}])</kbd>. After we break this route, we will be able to test whether our frontend and backend setup is working. After we test the errors (refer to the next screenshot), we will delete this breaking <kbd class="calibre23">$error</kbd> code from <kbd class="calibre23">articles[{integers}]</kbd>. Read on for details.</div>
<p class="calibre2">Test it with the <kbd class="calibre11">article</kbd> route:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>    route: 'articles[{integers}]', <br class="title-page-name"/>    get: (pathSet) =&gt; { <br class="title-page-name"/>      const articlesIndex = pathSet[1]; <br class="title-page-name"/><br class="title-page-name"/>      return { <br class="title-page-name"/>        path: ['articles'], <br class="title-page-name"/>        value: $error('auth error') <br class="title-page-name"/>      } <br class="title-page-name"/><br class="title-page-name"/>      return Article.find({}, '_id', function(err, articlesDocs) { <br class="title-page-name"/>        return articlesDocs; <br class="title-page-name"/>      }).then ((articlesArrayFromDB) =&gt; { <br class="title-page-name"/>        let results = []; <br class="title-page-name"/>        articlesIndex.forEach((index) =&gt; { <br class="title-page-name"/>          let currentMongoID = <br class="title-page-name"/>           String(articlesArrayFromDB[index]['_id']); <br class="title-page-name"/>          let articleRef = $ref(['articlesById', currentMongoID]); <br class="title-page-name"/><br class="title-page-name"/>          const falcorSingleArticleResult = { <br class="title-page-name"/>            path: ['articles', index], <br class="title-page-name"/>            value: articleRef <br class="title-page-name"/>          }; <br class="title-page-name"/><br class="title-page-name"/>          results.push(falcorSingleArticleResult); <br class="title-page-name"/>        }); <br class="title-page-name"/>        return results; <br class="title-page-name"/>      }) <br class="title-page-name"/>    } <br class="title-page-name"/>  }, 
</pre>
<p class="calibre2">As you can see, this is only a test. We will improve this code in a moment, but let's test whether the text in the <kbd class="calibre11">$error('auth error')</kbd> sentinel will be shown to the user.</p>
<p class="calibre2">Run MongoDB:</p>
<pre class="calibre22">
<strong class="calibre1">$ mongod </strong>  
</pre>
<p class="calibre2">Then, run the server in another terminal:</p>
<pre class="calibre22">
<strong class="calibre1">$ npm start</strong>  
</pre>
<p class="calibre2">After you run both these, point your browser to <kbd class="calibre11">http://localhost:3000</kbd>, and you will see for this error for 8 seconds:</p>
<div class="packt_figure"><img class="image-border44" src="../images/00049.jpeg"/></div>
<p class="calibre2">As you can see, there is white text on a black background in the bottom of the window:</p>
<div class="packt_figure"><img class="image-border45" src="../images/00050.jpeg"/></div>
<p class="calibre2">If you run the app, and on the main page you see the error message as on the screenshot, then it tells you that you are good!</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Cleaning up $error after a successful test</h1>
            

            <article>
                
<p class="calibre2">After you are sure that the error handling is working for you, you can replace the old code:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>    route: 'articles[{integers}]', <br class="title-page-name"/>    get: (pathSet) =&gt; { <br class="title-page-name"/>      const articlesIndex = pathSet[1]; <br class="title-page-name"/><br class="title-page-name"/>      return { <br class="title-page-name"/>        path: ['articles'], <br class="title-page-name"/>        value: $error('auth error') <br class="title-page-name"/>      } <br class="title-page-name"/>      return Article.find({}, '_id', function(err, articlesDocs) { 
</pre>
<p class="calibre2">Change it to the following, without error returning:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>    route: 'articles[{integers}]', <br class="title-page-name"/>    get: (pathSet) =&gt; { <br class="title-page-name"/>      const articlesIndex = pathSet[1]; <br class="title-page-name"/>      return Article.find({}, '_id', function(err, articlesDocs) { 
</pre>
<p class="calibre2">Now, the app will start working normally without throwing an error when you try to fetch an article from the backend.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Wrapping up the routes' security</h1>
            

            <article>
                
<p class="calibre2">We've already implemented some logic in <kbd class="calibre11">server/routes.js</kbd> that checks whether a user is authorized, with the following:</p>
<pre class="calibre22">
// this already is in your codebase: <br class="title-page-name"/>export default ( req, res ) =&gt; { <br class="title-page-name"/>  let { token, role, username } = req.headers; <br class="title-page-name"/>  let userDetailsToHash = username+role; <br class="title-page-name"/>  let authSignToken = jwt.sign(userDetailsToHash, jwtSecret.secret); <br class="title-page-name"/>  let isAuthorized = authSignToken === token; <br class="title-page-name"/>  let sessionObject = {isAuthorized, role, username}; <br class="title-page-name"/>  console.info(&amp;grave;The ${username} is authorized === &amp;grave;, isAuthorized); 
</pre>
<p class="calibre2">In this code, you will find that we can create the following logic in the beginning of each role that requires authorization and the editor role:</p>
<pre class="calibre22">
// this is example of falcor-router $errors, don't write it: <br class="title-page-name"/>if (isAuthorized === false) { <br class="title-page-name"/>  return { <br class="title-page-name"/>    path: ['HERE_GOES_THE_REAL_FALCOR_PATH'], <br class="title-page-name"/>    value: $error('auth error') <br class="title-page-name"/>  } <br class="title-page-name"/>} elseif(role !== 'editor') { <br class="title-page-name"/>  return { <br class="title-page-name"/>    path: ['HERE_GOES_THE_REAL_FALCOR_PATH'], <br class="title-page-name"/>    value: $error('you must be an editor in order <br class="title-page-name"/>     to perform this action') <br class="title-page-name"/>  } <br class="title-page-name"/>} 
</pre>
<p class="calibre2">As you can see here, this is only an example (don't change it yet; we will implement it in a moment), with <kbd class="calibre11">path['HERE_GOES_THE_REAL_FALCOR_PATH']</kbd>.</p>
<p class="calibre2">First, we check whether a user is authorized at all with <kbd class="calibre11">isAuthorized === false</kbd>; if not authorized, he will see an error (with the universal error mechanism that we just implemented):</p>
<div class="packt_figure"><img class="image-border46" src="../images/00051.jpeg"/></div>
<p class="calibre2">In future, we may have more roles in our publishing app, so in case someone isn't an editor, then he will see the following in the error:</p>
<div class="packt_figure"><img class="image-border47" src="../images/00052.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">What routes to secure</h1>
            

            <article>
                
<p class="calibre2">For routes (<kbd class="calibre11">server/routes.js</kbd>) that require authorization in our application's articles, add the following:</p>
<pre class="calibre22">
route: 'articles.add', 
</pre>
<p class="calibre2">Here's the old code:</p>
<pre class="calibre22">
// this is already in your codebase, old code: <br class="title-page-name"/>  { <br class="title-page-name"/>    route: 'articles.add', <br class="title-page-name"/>    call: (callPath, args) =&gt; { <br class="title-page-name"/>      const newArticleObj = args[0]; <br class="title-page-name"/>      var article = new Article(newArticleObj); <br class="title-page-name"/><br class="title-page-name"/>      return article.save(function (err, data) { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>        else { <br class="title-page-name"/>          return data; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then ((data) =&gt; { <br class="title-page-name"/>// code has been striped out from here for the sake of brevity, <br class="title-page-name"/> nothing changes below 
</pre>
<p class="calibre2">The new code with <kbd class="calibre11">auth</kbd> checks is as follows:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>    route: 'articles.add', <br class="title-page-name"/>    call: (callPath, args) =&gt; { <br class="title-page-name"/>      if (sessionObject.isAuthorized === false) { <br class="title-page-name"/>        return { <br class="title-page-name"/>          path: ['articles'], <br class="title-page-name"/>          value: $error('auth error') <br class="title-page-name"/>        } <br class="title-page-name"/>      } else if(sessionObject.role !== 'editor' &amp;&amp; <br class="title-page-name"/>       sessionObject.role !== 'admin') { <br class="title-page-name"/>        return { <br class="title-page-name"/>          path: ['articles'], <br class="title-page-name"/>          value: $error('you must be an editor <br class="title-page-name"/>           in order to perform this action') <br class="title-page-name"/>        } <br class="title-page-name"/>      } <br class="title-page-name"/><br class="title-page-name"/>      const newArticleObj = args[0]; <br class="title-page-name"/>      var article = new Article(newArticleObj); <br class="title-page-name"/><br class="title-page-name"/>      return article.save(function (err, data) { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>        else { <br class="title-page-name"/>          return data; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then ((data) =&gt; { <br class="title-page-name"/>// code has been striped out from here for <br class="title-page-name"/> //the sake of brevity, nothing changes below 
</pre>
<p class="calibre2">As you can find here, we have added two checks with <kbd class="calibre11">isAuthorized === false</kbd> and role <kbd class="calibre11">!== 'editor'</kbd>. The following routes content will be almost the same (just the path changes a little).</p>
<p class="calibre2">Here is the <kbd class="calibre11">articles</kbd> update:</p>
<pre class="calibre22">
route: 'articles.update', 
</pre>
<p class="calibre2">This is the old code:</p>
<pre class="calibre22">
// this is already in your codebase, old code: <br class="title-page-name"/>  { <br class="title-page-name"/>  route: 'articles.update', <br class="title-page-name"/>  call: async (callPath, args) =&gt;  <br class="title-page-name"/>    { <br class="title-page-name"/>      const updatedArticle = args[0]; <br class="title-page-name"/>      let articleID = String(updatedArticle._id); <br class="title-page-name"/>      let article = new Article(updatedArticle); <br class="title-page-name"/>      article.isNew = false; <br class="title-page-name"/><br class="title-page-name"/>      return article.save(function (err, data) { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then ((res) =&gt; { <br class="title-page-name"/>// code has been striped out from here for the <br class="title-page-name"/> //sake of brevity, nothing changes below 
</pre>
<p class="calibre2">The new code with the <kbd class="calibre11">auth</kbd> checks is as follows:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>  route: 'articles.update', <br class="title-page-name"/>  call: async (callPath, args) =&gt;  <br class="title-page-name"/>    { <br class="title-page-name"/>      if (sessionObject.isAuthorized === false) { <br class="title-page-name"/>        return { <br class="title-page-name"/>          path: ['articles'], <br class="title-page-name"/>          value: $error('auth error') <br class="title-page-name"/>        } <br class="title-page-name"/>      } else if(sessionObject.role !== 'editor' &amp;&amp; <br class="title-page-name"/>       sessionObject.role !== 'admin') { <br class="title-page-name"/>        return { <br class="title-page-name"/>          path: ['articles'], <br class="title-page-name"/>          value: $error('you must be an editor <br class="title-page-name"/>           in order to perform this action') <br class="title-page-name"/>        } <br class="title-page-name"/>      } <br class="title-page-name"/><br class="title-page-name"/>      const updatedArticle = args[0]; <br class="title-page-name"/>      let articleID = String(updatedArticle._id); <br class="title-page-name"/>      let article = new Article(updatedArticle); <br class="title-page-name"/>      article.isNew = false; <br class="title-page-name"/><br class="title-page-name"/>      return article.save(function (err, data) { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then ((res) =&gt; { <br class="title-page-name"/>// code has been striped out from here <br class="title-page-name"/> //for the sake of brevity, nothing changes below <br class="title-page-name"/><br class="title-page-name"/>articles delete: <br class="title-page-name"/>route: 'articles.delete', 
</pre>
<p class="calibre2">Find this old code:</p>
<pre class="calibre22">
// this is already in your codebase, old code: <br class="title-page-name"/><br class="title-page-name"/>  { <br class="title-page-name"/>  route: 'articles.delete', <br class="title-page-name"/>  call: (callPath, args) =&gt;  <br class="title-page-name"/>    { <br class="title-page-name"/>      let toDeleteArticleId = args[0]; <br class="title-page-name"/>      return Article.find({ _id: toDeleteArticleId }).remove((err) =&gt; { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then((res) =&gt; { <br class="title-page-name"/>// code has been striped out from here <br class="title-page-name"/> //for the sake of brevity, nothing changes below 
</pre>
<p class="calibre2">Replace it with this new code with the <kbd class="calibre11">auth</kbd> checks:</p>
<pre class="calibre22">
 { <br class="title-page-name"/>  route: 'articles.delete', <br class="title-page-name"/>  call: (callPath, args) =&gt;  <br class="title-page-name"/>    { <br class="title-page-name"/><br class="title-page-name"/>      if (sessionObject.isAuthorized === false) { <br class="title-page-name"/>        return { <br class="title-page-name"/>          path: ['articles'], <br class="title-page-name"/>          value: $error('auth error') <br class="title-page-name"/>        } <br class="title-page-name"/>      } else if(sessionObject.role !== 'editor' &amp;&amp; <br class="title-page-name"/>       sessionObject.role !== 'admin') { <br class="title-page-name"/>        return { <br class="title-page-name"/>          path: ['articles'], <br class="title-page-name"/>          value: $error('you must be an <br class="title-page-name"/>           editor in order to perform this action') <br class="title-page-name"/>        } <br class="title-page-name"/>      } <br class="title-page-name"/><br class="title-page-name"/>      let toDeleteArticleId = args[0]; <br class="title-page-name"/>      return Article.find({ _id: toDeleteArticleId }).remove((err) =&gt; { <br class="title-page-name"/>        if (err) { <br class="title-page-name"/>          console.info('ERROR', err); <br class="title-page-name"/>          return err; <br class="title-page-name"/>        } <br class="title-page-name"/>      }).then((res) =&gt; { <br class="title-page-name"/>// code has been striped out from here <br class="title-page-name"/> //for the sake of brevity, nothing below changes 
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">As you can see, the returns are almost the same--we can lower the code duplication. We can make a helper function for them so there will be less code, but you need to remember that you need to set a path similar to the one that you request when returning an error. For example, if you are on <kbd class="calibre11">articles.update</kbd>, then you need return an error in the article's path (or if you are on <kbd class="calibre11">XYZ.update</kbd>, then the error goes to the <kbd class="calibre11">XYZ</kbd> path).</p>
<p class="calibre2">In the next chapter, we will implement AWS S3 in order to have the ability to upload articles' cover photos. Besides that, we will generally improve our publishing application with new features.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>