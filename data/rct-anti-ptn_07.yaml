- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Introducing Test-Driven Development with React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍使用React的测试驱动开发
- en: Welcome to a chapter that could potentially revolutionize your approach to React
    development – **test-driven development** (or **TDD** for short). If you’ve been
    building React applications, you know how complex and intricate they can get.
    With various states to manage, components to juggle, and user interactions to
    facilitate, ensuring the reliability of your code base can be challenging. That’s
    where TDD comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到一个可能彻底改变你对React开发方法的章节——**测试驱动开发**（或简称**TDD**）。如果你一直在构建React应用程序，你知道它们可以多么复杂和错综复杂。要管理各种状态、处理组件和促进用户交互，确保代码库的可靠性可能具有挑战性。这就是TDD发挥作用的地方。
- en: In the ever-changing landscape of software development, where features are continuously
    added or modified, TDD serves as a lighthouse that guides you safely through the
    rough seas of bugs and regressions. By writing tests before your actual code,
    you not only confirm that your code does what it’s supposed to, but you also create
    a safety net that makes future changes less risky.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的不断变化环境中，功能持续添加或修改，TDD（测试驱动开发）就像一座灯塔，引导你安全地穿越充满错误和回归的险恶海域。通过在编写实际代码之前编写测试，你不仅确认了你的代码做了它应该做的事情，而且还创建了一个安全网，使得未来的变更风险降低。
- en: This chapter aims to deepen your understanding of TDD and how to implement it
    effectively in React applications. We’ll introduce the core principles of TDD,
    explore various styles, including unit test-driven development, **acceptance test-driven
    development** (**ATDD**), and **behavior-driven development** (**BDD**), and even
    examine the nuanced differences between the Chicago and London styles of TDD.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在加深你对TDD的理解，以及如何在React应用程序中有效地实施它。我们将介绍TDD的核心原则，探讨各种风格，包括单元测试驱动开发、**验收测试驱动开发**（**ATDD**）、**行为驱动开发**（**BDD**），甚至检查芝加哥和伦敦风格TDD的细微差别。
- en: But we won’t stop at theory – to make these concepts come alive, we’ll walk
    you through a practical example of creating a pizza store menu page. From setting
    up the initial structure to managing complex features, we’ll guide you through
    each step with the TDD approach. By the end of this chapter, you’ll have a firm
    grasp of TDD’s capabilities, and you’ll be well equipped to start writing more
    reliable, robust React applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不会止步于理论——为了使这些概念生动起来，我们将通过创建比萨店菜单页面的实际示例来引导你。从设置初始结构到管理复杂功能，我们将使用TDD方法指导你每一步。到本章结束时，你将牢固掌握TDD的能力，并准备好开始编写更可靠、更健壮的React应用程序。
- en: So, get ready to dive into a world where tests lead the way and code follows,
    creating a harmonious balance that results in better, more reliable software.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，准备好进入一个测试引领方向、代码跟随的世界，创造出一个和谐平衡，从而产生更好、更可靠的软件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding TDD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试驱动开发（TDD）
- en: Introducing tasking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍任务管理
- en: Introducing the online pizza store application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍在线比萨店应用程序
- en: Breaking down the application requirements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分应用程序需求
- en: Implementing the application headline
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应用程序标题
- en: Implementing the menu list
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现菜单列表
- en: Creating the shopping cart
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建购物车
- en: Adding items to the shopping cart
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向购物车添加商品
- en: Refactoring the shopping cart
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构购物车
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch7](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch7).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个GitHub仓库来托管本书中讨论的所有代码。对于本章，你可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch7](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch7)找到推荐的结构。
- en: Understanding TDD
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试驱动开发（TDD）
- en: TDD isn’t exactly a new kid on the block. Originating from **Extreme Programming**
    (**XP**), a software development methodology that encourages frequent releases
    in short cycles, TDD has roots going back to the late 1990s. It was Kent Beck,
    one of the original signatories of the Agile Manifesto, who popularized this practice
    as a core part of XP. The practice has since grown beyond the realm of XP and
    is now commonly utilized in various methodologies and frameworks, React included.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TDD并不是一个新出现的概念。它起源于**极限编程**（**XP**），这是一种鼓励在短周期内频繁发布的软件开发方法，TDD的根源可以追溯到20世纪90年代末。是敏捷宣言的原始签署人之一，肯特·贝克，将这一实践普及为XP的核心部分。自那时起，这一实践已经超越了XP的领域，现在在包括React在内的各种方法和框架中普遍使用。
- en: 'At the heart of TDD is a very simple, yet profoundly effective cycle known
    as the **Red-Green-Refactor loop**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的核心是一个简单而效果显著的循环，被称为**红-绿-重构循环**：
- en: '![Figure 7.1: The Red-Green-Refactor loop](img/B31103_07_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：红-绿-重构循环](img/B31103_07_01.jpg)'
- en: 'Figure 7.1: The Red-Green-Refactor loop'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：红-绿-重构循环
- en: 'As you can see, there are essentially three steps when practicing TDD:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在实践TDD时，本质上有三个步骤：
- en: '**Red**: At this stage, you write a test that defines a function or improvements
    of a function. This test should initially fail because the function isn’t implemented
    yet. In most test frameworks (for example, Jest), there will be some red text
    to indicate the failure.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红**：在这个阶段，你编写一个定义函数或函数改进的测试。这个测试最初应该失败，因为函数尚未实现。在大多数测试框架（例如，Jest）中，将有一些红色文本来指示失败。'
- en: '**Green**: At this stage, you write the minimum amount of code necessary to
    pass the test. The key here is to write as little code as possible to make the
    test pass and make the text turn green – no more than that.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿**：在这个阶段，你编写通过测试所需的最少代码。关键在于编写尽可能少的代码来使测试通过，使文本变为绿色——不多于此。'
- en: '**Refactor**: Finally, you need to clean up the code while keeping it functional.
    The refactor phase is about making the code efficient, readable, and understandable
    without changing its behavior. The tests that are written should still pass after
    the refactoring.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：最后，你需要保持代码的功能性，同时对其进行清理。重构阶段是关于使代码高效、可读和易于理解，而不改变其行为。重构后编写的测试应该仍然通过。'
- en: 'When developers first encounter TDD, it often feels counter-intuitive, as the
    practice of writing tests before the actual code contradicts traditional development
    instincts. However, once you get past the initial discomfort, the advantages of
    TDD become hard to ignore:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者第一次接触TDD时，它往往感觉不合直觉，因为编写测试在编写实际代码之前与传统的开发直觉相矛盾。然而，一旦你克服了最初的不适，TDD的优势就很难忽视了：
- en: '**Focused problem-solving**: By writing a test for a specific functionality
    first, you focus your attention solely on solving one problem at a time, making
    the development process less overwhelming.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专注的问题解决**：通过首先编写一个针对特定功能的测试，你将注意力集中在一次解决一个问题，使开发过程不那么令人压倒。'
- en: '**Predictable next steps**: When you follow a test-driven approach, you always
    know what to do next: make the test pass. This reduces the cognitive load, making
    it easier to focus on the task at hand.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测的下一步行动**：当你遵循测试驱动的方法时，你总是知道下一步该做什么：使测试通过。这减少了认知负荷，使你更容易专注于手头的任务。'
- en: '**Simple, maintainable design**: The process naturally encourages the simplest
    code necessary to pass tests, resulting in a design that is as minimal as possible,
    and thereby easier to understand and maintain.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单、可维护的设计**：这个过程自然鼓励编写通过测试所需的最简单代码，从而产生尽可能最小化的设计，因此更容易理解和维护。'
- en: '**Facilitates mental flow**: The loop provides a structured approach to coding
    that helps maintain a “mental flow,” helping you stay focused on tasks by reducing
    the constant context-switching that interrupts a productive coding session.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进思维流畅性**：这个循环提供了一个结构化的编码方法，有助于保持“思维流畅性”，通过减少打断高效编码会话的持续上下文切换，帮助你保持对任务的专注。'
- en: '**Automatic test coverage**: TDD ensures that your application has robust test
    coverage by default. You’re not adding tests as an afterthought; they’re integral
    to the development process, ensuring a more stable codebase.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动测试覆盖率**：TDD默认确保你的应用程序具有强大的测试覆盖率。你并不是在事后添加测试；它们是开发过程的一部分，确保代码库更加稳定。'
- en: TDD is a practice deeply rooted in the principles of Agile and XP but has found
    relevance far beyond those methodologies. With its structured Red-Green-Refactor
    loop, TDD provides a solid framework for writing high-quality code. Although it
    may appear counter-intuitive initially, adopting TDD can result in more focused
    problem-solving, predictable development, simpler design, enhanced productivity,
    and robust test coverage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种深深植根于敏捷和XP原则的实践，但它已经超越了这些方法论的相关性。凭借其结构化的红-绿-重构循环，TDD为编写高质量代码提供了一个坚实的框架。尽管最初可能看起来有些反直觉，但采用TDD可以导致更专注的问题解决、可预测的开发、更简单的设计、提高的生产力和稳健的测试覆盖率。
- en: Different styles of TDD
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD的不同风格
- en: The core principles of TDD have been adapted and extended into various styles,
    each offering different perspectives on how best to approach testing and development.
    Let’s explore some of these styles to understand how they can be applied to React
    development.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的核心原则已经被适应和扩展到各种风格中，每种风格都提供了对如何最好地处理测试和开发的不同视角。让我们探索一些这些风格，了解它们如何应用于React开发。
- en: The original form of TDD, simply referred to as TDD, mainly focuses on unit
    tests. In this style, you write tests for the smallest pieces of your code – often
    individual methods or functions. The aim is to ensure that each part of your code
    base works as expected in isolation. While this is powerful for testing logic
    and algorithms, it may not fully capture how various parts interact, especially
    in a complex UI framework such as React.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的原始形式，简单地称为TDD，主要关注单元测试。在这种风格中，你为代码的最小部分编写测试——通常是单个方法或函数。目标是确保代码库的每个部分在独立的情况下都能按预期工作。虽然这对于测试逻辑和算法来说很强大，但它可能无法完全捕捉到各个部分之间的交互，尤其是在像React这样的复杂UI框架中。
- en: 'ATDD extends TDD by beginning the development process with user acceptance
    tests. This means that before writing any code, you define what “done” looks like
    from a user’s perspective, often in collaboration with stakeholders. These acceptance
    tests are then used as the foundation for developing features. ATDD is particularly
    useful for ensuring that you’re building what the user needs and wants:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ATDD通过在开发过程开始时使用用户验收测试来扩展TDD。这意味着在编写任何代码之前，你需要从用户的角度定义“完成”的样子，这通常与利益相关者合作完成。然后，这些验收测试被用作开发特性的基础。ATDD特别有助于确保你正在构建用户需要和想要的东西：
- en: '![Figure 7.2: The ATDD loop](img/B31103_07_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：ATDD循环](img/B31103_07_02.jpg)'
- en: 'Figure 7.2: The ATDD loop'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：ATDD循环
- en: Note that when you write an acceptance test, it can usually be broken down into
    smaller unit tests. For example, a user logging into the system can be an acceptance
    test, but there will be forgotten passwords, incorrect passwords or usernames,
    remember me functions, and more to cover in the lower-level unit tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你编写一个验收测试时，它通常可以被分解成更小的单元测试。例如，用户登录系统可以是一个验收测试，但还需要考虑忘记密码、密码或用户名错误、记住我功能等情况，这些都需要在更底层的单元测试中涵盖。
- en: BDD is a further refinement of TDD and ATDD, focusing on the behavior of an
    application for a given input. Rather than writing tests that check if a particular
    method returns an expected value, BDD tests check if a system behaves as expected
    when subjected to certain conditions. BDD often uses more descriptive language
    to define tests, making it easier for non-technical stakeholders to understand
    what is being tested.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: BDD是TDD和ATDD的进一步细化，专注于给定输入的应用程序行为。而不是编写检查特定方法是否返回预期值的测试，BDD测试检查系统在受到某些条件影响时是否按预期行为。BDD经常使用更描述性的语言来定义测试，这使得非技术利益相关者更容易理解正在测试的内容。
- en: 'BDD often makes use of tools such as **Cucumber** to define behavior specifications
    in a human-readable format. In a Cucumber test, you specify behavior using a plaintext
    language called **Gherkin**. Here’s a simple example of a BDD test case using
    Cucumber for a pizza ordering feature (we will continue working on this pizza
    example later in this chapter):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: BDD经常使用诸如**Cucumber**之类的工具，以人类可读的格式定义行为规范。在Cucumber测试中，你使用一种名为**Gherkin**的纯文本语言来指定行为。以下是一个使用Cucumber进行比萨订购功能BDD测试用例的简单示例（我们将在本章后面继续探讨这个比萨示例）：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This Gherkin file defines the expected behavior of the pizza ordering functionality.
    Each line is called a step and can be interpreted as a statement in the test.
    The scenarios describe the test’s behavior in terms of the steps to be performed
    and the expected outcomes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此Gherkin文件定义了比萨订购功能的预期行为。每一行被称为一个步骤，可以解释为测试中的一个语句。场景描述了测试的行为，包括要执行的步骤和预期的结果。
- en: Gherkin syntax is more than just readable documentation – it’s executable. Tools
    such as Cucumber can parse the Gherkin files and execute tests based on them –
    for example, `cypress.visit("`[http://pizzashop.com](http://pizzashop.com)"`)`.
    This ensures that the software behaves exactly as described in the feature files,
    making it a source of truth that evolves along with the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 语法不仅仅是可读的文档，它还是可执行的。例如，Cucumber 这样的工具可以解析 Gherkin 文件并根据它们执行测试——例如，`cypress.visit("`[http://pizzashop.com](http://pizzashop.com)"`)`。这确保了软件的行为与特性文件中描述的完全一致，使其成为随着应用程序发展而演变的真相来源。
- en: BDD feature files (Gherkin) serve as a form of living documentation that gets
    updated as the application changes. This makes them incredibly valuable for new
    team members, or even for seasoned developers, to understand the expected behavior
    of the application quickly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 特性文件（Gherkin）作为活文档的一种形式，随着应用程序的变化而更新。这使得它们对于新团队成员，甚至对于经验丰富的开发者来说，快速理解应用程序的预期行为非常有价值。
- en: Focusing on user value
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注用户价值
- en: Regardless of the style you choose, when working with React, it’s crucial to
    focus on the user’s perspective. React components are pieces of UI that users
    interact with, so your tests should reflect that interaction. The user doesn’t
    care about how your state is managed or how efficient your life cycle methods
    are; they care about whether clicking a button shows a dropdown, or whether a
    form submission produces the expected result.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种风格，当与 React 一起工作时，关注用户的视角至关重要。React 组件是用户与之交互的 UI 部分，因此你的测试应该反映这种交互。用户不关心你的状态是如何管理的，或者你的生命周期方法有多高效；他们关心的是点击按钮是否会显示下拉菜单，或者表单提交是否会产生预期的结果。
- en: Kent C. Dodds, the creator of the React Testing Library, said “*The more your
    tests resemble the way your software is used, the more confidence they can give
    you.*” This principle is universally applicable, irrespective of the framework
    or library you’re using. The focus should always be on the user’s experience.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: React Testing Library 的创造者 Kent C. Dodds 说：“*你的测试越接近你的软件的使用方式，它们就能给你带来越多的信心。*”这个原则适用于所有框架或库，无论你使用什么。始终应该关注用户体验。
- en: This user-centric approach aligns well with BDD and ATDD, where the focus is
    on the result of an interaction, not the minutiae of the implementation. By adhering
    to these principles, you can ensure your React components not only work well but
    also deliver the user experience you aim to achieve.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种以用户为中心的方法与 BDD 和 ATDD 非常吻合，其中关注的是交互的结果，而不是实现的细节。通过遵循这些原则，你可以确保你的 React 组件不仅工作良好，而且能够提供你希望实现的用户体验。
- en: 'Now that we’ve understood what TDD is and how its various styles can aid in
    delivering value to our customers, the next question to tackle is: how do we go
    about implementing it?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 TDD 是什么以及它的各种风格如何帮助向我们的客户提供价值，接下来要解决的问题是如何实施它？
- en: Introducing tasking
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍任务分配
- en: '**Tasking** is an essential step in the TDD process that involves breaking
    down a feature or user story into small, manageable tasks, which then serve as
    the basis for your test cases. The goal of tasking is to create a clear roadmap
    for what you’re going to code, how you’ll test it, and in what order you’ll proceed.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务分配**是 TDD 流程中的一个重要步骤，涉及将特性或用户故事分解为小而可管理的任务，这些任务随后成为你的测试用例的基础。任务分配的目标是为你将要编写的代码、如何测试它以及你将如何按顺序进行提供一个清晰的路线图。'
- en: 'Breaking the big requirement into smaller chunks has a lot of benefits:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将大需求分解成更小的块有很多好处：
- en: '**It clarifies scope**: Breaking down a feature into tasks helps establish
    a better understanding of what needs to be done and how to approach it'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它明确了范围**：将特性分解为任务有助于更好地理解需要做什么以及如何着手'
- en: '**It simplifies the problem**: By dissecting a complex problem into smaller
    tasks, you make it easier to tackle'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它简化了问题**：通过将复杂问题分解成更小的任务，你使它更容易解决'
- en: '**It prioritizes work**: Once the tasks have been laid out, they can be prioritized
    to deliver the most value first or to build logically upon one another'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它优先处理工作**：一旦任务被列出，它们可以被优先处理，以首先提供最大的价值，或者按逻辑顺序构建。'
- en: '**It focuses effort**: Tasking ensures that each test you write serves a clear,
    immediate purpose, making your TDD cycle more efficient'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它集中精力**：任务分配确保你写的每个测试都有一个明确、直接的目的，使你的 TDD 循环更加高效'
- en: '**It facilitates collaboration**: Team members can pick up individual tasks,
    safe in the knowledge that they are all contributing to a cohesive whole'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进协作**：团队成员可以挑选个别任务，因为他们知道他们都在为整体贡献。'
- en: 'Now, you might be wondering, if it is so good and helpful, how can we do tasking?
    It’s not anything fancy – you might have already done it without noticing. You
    just follow these steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道，既然它如此好且有用，我们该如何进行任务分配？这并不复杂——你可能已经不知不觉中做过。你只需遵循以下步骤：
- en: '**Review the user story or requirement**: Understand the user story or feature
    you are supposed to implement.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回顾用户故事或需求**：理解你要实现的用户故事或功能。'
- en: '**Identify logical components**: Break the story down into its logical components,
    which often correspond to domain concepts, business rules, or individual steps
    in a user workflow.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**识别逻辑组件**：将故事分解为其逻辑组件，这些组件通常对应于领域概念、业务规则或用户工作流程中的单个步骤。'
- en: '**Create a task list**: Write down a list of tasks. These tasks should be small
    enough that you can write a few test cases and the corresponding implementation
    code in a short amount of time (say, 15 to 30 minutes).'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建任务列表**：写下任务列表。这些任务应该足够小，以至于你可以在短时间内编写一些测试用例和相应的实现代码（比如，15到30分钟）。'
- en: '**Sequence the tasks**: Determine the most logical order for completing these
    tasks, often starting with the “happy path” – the default scenario where everything
    goes as expected, without encountering any errors – and then moving on to edge
    cases and error handling.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安排任务顺序**：确定完成这些任务的最合理顺序，通常从“正常路径”开始——即一切按预期进行，没有遇到任何错误的默认场景——然后转向边缘情况和错误处理。'
- en: '**Map the tasks to tests**: For each task, identify the tests that will verify
    that part of the functionality. You don’t need to write the tests at this stage;
    you’re simply identifying what they’ll be.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将任务映射到测试上**：对于每个任务，确定将验证该功能部分的测试。在这个阶段，你不需要编写测试；你只是在识别它们。'
- en: Tasking might be a part of your daily workflow without you even realizing it.
    It’s a systematic approach to problem-solving that involves breaking down a requirement
    into manageable, sequential tasks. These tasks should ideally be completable within
    a few minutes to an hour.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任务分配可能是你日常工作中的一部分，即使你没有意识到。这是一种系统化的解决问题的方法，涉及将需求分解成可管理的、顺序化的任务。这些任务理想情况下应该在几分钟到一小时内完成。
- en: The process of TDD is akin to the art of painting. You begin with a sketch or
    draft, outlining basic shapes and lines with a pencil, much like framing the initial
    structure of your code. In the beginning, the vision might be vague, a mere idea
    or concept in your mind. But as you draw – or write tests and code – the image
    begins to take shape. More elements are added, details emerge, and adjustments
    are made, allowing for continuous refinement. With each layer or iteration, clarity
    emerges, yet the exact final appearance remains a mystery until the very last
    stages. Just as an artist crafts a masterpiece through gradual development, TDD
    shapes a robust and elegant piece of software.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的过程类似于绘画艺术。你从一个草图或草案开始，用铅笔勾勒出基本形状和线条，就像为你的代码构建初始结构。一开始，愿景可能很模糊，只是你心中的一个想法或概念。但随着你的绘制——或编写测试和代码——图像开始成形。更多的元素被添加，细节出现，并进行调整，允许持续优化。每一层或迭代，清晰度出现，但确切的最终外观直到最后阶段仍然是个谜。就像艺术家通过逐步发展创作出杰作一样，TDD塑造了一个强大而优雅的软件作品。
- en: All right, we have covered a lot of theory so far. Let’s look into a concrete
    example to fully understand how to do tasking and use tasks as a guideline for
    applying the Red-Green-Refactor loop.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，到目前为止我们已经讨论了很多理论。让我们通过一个具体的例子来深入了解如何进行任务分配，并使用任务作为应用红-绿-重构循环的指南。
- en: Introducing the online pizza store application
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍在线披萨店应用程序
- en: 'In this section, we’ll be diving into the TDD process through a deliciously
    practical example: *The Code Oven*, an online pizza store. Named to celebrate
    the fusion of coding and culinary arts, The Code Oven aims to serve both your
    appetite and your intellectual curiosity. This digital storefront will offer us
    a comprehensive sandbox where we can apply all the TDD principles and techniques
    we discuss.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个美味实用的例子深入探讨TDD过程：*代码烤箱*，一个在线披萨店。这个名字是为了庆祝编码和烹饪艺术的融合，代码烤箱旨在满足你的食欲和智力好奇心。这个数字店面将为我们提供一个全面的沙盒，我们可以在这里应用我们讨论的所有TDD原则和技术。
- en: 'Here’s what you can expect to see in The Code Oven:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码烤箱中，你可以期待看到以下内容：
- en: '**Pizza menu**: At the heart of The Code Oven is an appetizing menu of eight
    delectable pizzas. Each pizza is presented with its name and cost, designed to
    whet your appetite and inform your choice.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**披萨菜单**：Code Oven 的核心是一个令人垂涎的八种美味披萨菜单。每个披萨都附有它的名称和价格，旨在刺激您的食欲并指导您的选择。'
- en: '**An Add button**: Beside each mouth-watering option is an **Add** button.
    This enables users to start the ordering process by adding their chosen pizzas
    to a virtual shopping cart.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加按钮**：在每个令人垂涎的选择旁边都有一个“添加”按钮。这使用户能够通过将所选披萨添加到虚拟购物车中来开始订购过程。'
- en: '**Shopping cart**: A designated section on the screen shows users their current
    shopping cart, complete with the names and prices of each selected pizza.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**购物车**：屏幕上的一个指定区域显示了用户的当前购物车，包括每个所选披萨的名称和价格。'
- en: '**Modify cart**: Should you get second thoughts or just want more pizza, The
    Code Oven allows you to modify your cart by adding or removing items dynamically.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改购物车**：如果您改变主意或只是想要更多的披萨，Code Oven 允许您通过动态添加或删除项目来修改您的购物车。'
- en: '**Order total**: There’s no need for manual calculations – The Code Oven’s
    cart automatically computes and displays the total price of your chosen items.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单总额**：无需手动计算 – Code Oven 的购物车会自动计算并显示您所选商品的总价。'
- en: '**A Place my order button**: A prominent **Place my order** button serves as
    the final step, which would, in a real-world application, process the order for
    delivery or pick-up:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下单按钮**：一个显眼的“下单”按钮是最终步骤，在现实世界的应用程序中，这将处理订单以进行配送或自取：'
- en: '![Figure 7.3: The Code Oven](img/B31103_07_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：The Code Oven](img/B31103_07_03.jpg)'
- en: 'Figure 7.3: The Code Oven'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：The Code Oven
- en: As we build out The Code Oven, we’ll be applying TDD at every stage to ensure
    that our virtual pizzeria is not just functional but robust and easily maintainable.
    Get ready to roll up your sleeves, both for coding and for some virtual pizza-making!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建 The Code Oven，我们将在每个阶段应用 TDD，以确保我们的虚拟比萨店不仅功能齐全，而且稳健且易于维护。准备好卷起袖子，无论是编码还是进行一些虚拟比萨制作！
- en: Breaking down the application requirements
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解应用程序需求。
- en: There isn’t a universal right way to break down the requirements of the application
    you are making; however, there are typically two different styles – the bottom-up
    style and the top-down style.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 制作应用程序的需求分解并没有一个通用的正确方法；然而，通常有两种不同的风格 – 自下而上的风格和自上而下的风格。
- en: In the **bottom-up** style of TDD, developers start by writing tests and implementing
    functionality for the smallest and most fundamental components of the system.
    This approach emphasizes the construction of individual units or classes, thoroughly
    testing them before integrating them into higher-level components. It provides
    strong validation for the underlying parts of the system and helps in creating
    a robust foundation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 的自下而上风格中，开发者从编写测试和实现系统中最小和最基本组件的功能开始。这种方法强调构建单个单元或类，在将它们集成到更高层次的组件之前，对它们进行彻底测试。它为系统的底层部分提供了强大的验证，并有助于创建一个稳健的基础。
- en: However, this style might lead to challenges in integrating the components if
    the bigger picture and interactions between the units are not carefully considered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果未仔细考虑整体图景和单元之间的交互，这种风格可能会导致组件集成的挑战。
- en: 'Back to the online pizza store, we can break the whole page down into the following
    tasks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回到在线披萨店，我们可以将整个页面分解为以下任务：
- en: Implement a single `PizzaItem` component with a pizza name
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个带有披萨名称的单一 `PizzaItem` 组件。
- en: Add a price to `PizzaItem`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `PizzaItem` 添加价格。
- en: Add a button to `PizzaItem`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `PizzaItem` 添加一个按钮。
- en: Implement a `PizzaList` component (render three items in a row, for example)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个 `PizzaList` 组件（例如，一行显示三个项目）。
- en: Implement a simple `ShoppingCart` component with a button
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个简单的带有按钮的 `ShoppingCart` 组件。
- en: Support the ability to add/remove items to the `ShoppingCart` component
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持向 `ShoppingCart` 组件添加/删除项目的能力。
- en: Add a calculation for the total number of pizzas
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加计算总披萨数量的计算。
- en: Implement the whole application with these individual standalone components
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些独立的独立组件实现整个应用程序。
- en: As you can see, each task focuses on an individual component at a time. The
    components start simple, with only the minimal function; then, we incrementally
    add more features to them, including test cases to cover the functionality required,
    as well as other reasonable edge cases.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个任务都专注于一次一个组件。组件从简单的最小功能开始；然后，我们逐步向它们添加更多功能，包括测试用例以覆盖所需的功能，以及其他合理的边缘情况。
- en: So, we start from a single `PizzaItem` component (which only has a name in it)
    and then give it a price, and then a button. After the individual items are built,
    we start to implement `PizzaList`, and then `ShoppingCart`. Then, once `PizzaList`
    and `ShoppingCart` are done, we integrate them and test a few overall functions
    from the user’s perspective.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从单个`PizzaItem`组件（其中只包含名称）开始，然后给它一个价格，然后是一个按钮。一旦构建了单个项目，我们就开始实现`PizzaList`，然后是`ShoppingCart`。然后，一旦`PizzaList`和`ShoppingCart`完成，我们就将它们集成起来，并从用户的角度测试几个整体功能。
- en: 'For example, as demonstrated in the following screenshot, we might start with
    a `PizzaItem` component, implementing the component gradually without worrying
    about anything else in the application. Once we have a full implementation of
    `PizzaItem` (with an image, name, price and `ShoppingCart`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如以下截图所示，我们可能从一个`PizzaItem`组件开始，逐步实现组件，而不必担心应用程序中的其他任何事情。一旦我们有了`PizzaItem`的完整实现（包括图片、名称、价格和`ShoppingCart`）：
- en: "![Figu\uFEFFre 7.4: The bottom-up style](img/B31103_07_04.jpg)"
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：自底向上的风格](img/B31103_07_04.jpg)'
- en: 'Figure 7.4: The bottom-up style'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：自底向上的风格
- en: The **top-down** style of TDD takes the opposite approach, beginning with the
    high-level architecture and overall functionality of the system. Developers first
    write tests and implement features for the main components and then gradually
    work their way down to the more detailed and specific functionalities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的自顶向下风格采取相反的方法，从系统的高层架构和整体功能开始。开发者首先编写测试并为主要组件实现功能，然后逐步向下到更详细和具体的功能。
- en: 'This style helps ensure that the system’s primary objectives and workflow are
    established early on, providing a clear roadmap for the development process. It
    can foster better integration and alignment with the overall goals but may sometimes
    require the use of temporary “stubs” or “mocks” to simulate lower-level components
    before they are developed. For instance, we could break the feature down into
    the following list:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格有助于确保系统的主要目标和工作流程在早期就确立，为开发过程提供清晰的路线图。它可以促进更好的集成和与整体目标的对齐，但有时可能需要使用临时的“占位符”或“模拟”来在开发之前模拟低级组件。例如，我们可以将功能分解为以下列表：
- en: Implement the page title
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现页面标题
- en: Implement a menu list containing the pizza names
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个包含披萨名称的菜单列表
- en: Implement a `ShoppingCart` component with only a button (disabled by default)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个只有按钮的`ShoppingCart`组件（默认禁用）
- en: Add an item to `ShoppingCart` when the button is clicked, after which the `ShoppingCart`
    button is enabled
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，将项目添加到`ShoppingCart`中，之后`ShoppingCart`按钮被启用
- en: Add a price to the `ShoppingCart` component
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`ShoppingCart`组件添加价格
- en: Add a total number of selected items to `ShoppingCart`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`ShoppingCart`添加所选项目的总数
- en: Remove an item from `ShoppingCart`, with the total number changing accordingly
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`ShoppingCart`中移除项目，总数量相应变化
- en: For the top-down approach, we don’t have a clear picture of the individual units
    but the working application as a whole – so we see the application from outside
    without knowing the implementation details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自顶向下的方法，我们没有一个清晰的各个单元的图片，只有一个整体工作的应用程序——因此我们是从外部看到应用程序，而不了解实现细节。
- en: For example, there isn’t a `PizzaItem` component at the beginning, and the smaller
    components are gradually extracted from the bigger component when we find that
    the component is too big. This means we will always have functional software running
    (even if we don’t have the small well-designed components up-front), allowing
    us to stop at any time without breaking the functionality.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一开始并没有`PizzaItem`组件，当我们发现组件太大时，较小的组件会逐渐从较大的组件中提取出来。这意味着我们始终会有功能性的软件在运行（即使我们一开始没有小而精良的组件），这样我们就可以在任何时候停止，而不会破坏功能。
- en: 'A possible breakdown with the top-down approach is shown in the following diagram.
    We start with an empty list, then a list with pizza names, and then a shopping
    cart that allows users to add items and proceed to the next step:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自顶向下的方法可能出现的分解情况如下所示。我们从一个空列表开始，然后是一个包含披萨名称的列表，接着是一个允许用户添加项目并进入下一步的购物车：
- en: '![Figure 7.5: The top-down style](img/B31103_07_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：自顶向下的风格](img/B31103_07_05.jpg)'
- en: 'Figure 7.5: The top-down style'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：自顶向下的风格
- en: (The textual detail in the previous figure is minimized and is not directly
    relevant to your understanding of it. If you would like to see the textual detail,
    please refer to the free downloadable eBook.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: （前一个图中的文本细节已被最小化，并且与您理解它不直接相关。如果您想查看文本细节，请参阅免费可下载的电子书。）
- en: Both styles have contributed to the rich variety of methodologies in modern
    software development, and neither is definitively “right” or “wrong.” Instead,
    they offer different perspectives and tools that developers can choose from based
    on their particular needs and preferences.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种风格都为现代软件开发中的丰富方法论做出了贡献，并且它们都不是绝对“正确”或“错误”的。相反，它们提供了不同的视角和工具，开发者可以根据自己的特定需求和偏好进行选择。
- en: In the following parts of this chapter, we are going to use the top-down style
    as it forces us to think from the user’s perspective. We’ll explore the bottom-up
    approach in more detail in the following chapters when we introduce other design
    patterns.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将使用自顶向下的风格，因为它迫使我们从用户的角度思考。我们将在介绍其他设计模式时，在下一章中更详细地探讨自底向上的方法。
- en: Implementing the application headline
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现应用程序标题
- en: Let’s start with the implementation of the pizza store application. If you have
    cloned the repository mentioned in the *Technical requirements* section, simply
    go to the `react-anti-patterns-code/src/ch7` folder.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现披萨店应用程序开始。如果您已经克隆了*技术要求*部分中提到的仓库，只需转到`react-anti-patterns-code/src/ch7`文件夹。
- en: 'As we’re applying TDD, the first thing to do here is to write a test that fails.
    In the previous section, we mentioned what we want to test: implement the page
    title.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在应用TDD，这里的第一件事是编写一个失败的测试。在上一节中，我们提到了我们想要测试的内容：实现页面标题。
- en: 'So, let’s create a file called `App.test.tsx` with the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们创建一个名为`App.test.tsx`的文件，并包含以下代码：
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’re writing a test for the yet-to-be-created `PizzaShopApp` React component.
    Using the React Testing Library, we will render this component and verify whether
    it includes a heading labeled `expect(heading).toBeInTheDocument();` assertion
    confirms that the heading is successfully rendered.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为尚未创建的`PizzaShopApp` React组件编写测试。使用React Testing Library，我们将渲染此组件并验证它是否包含一个标记为`expect(heading).toBeInTheDocument();`的断言，这确认了标题已成功渲染。
- en: 'Now, let’s run the test with the following command in your terminal window:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在终端窗口中运行以下命令来运行测试：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An error will appear in the terminal saying `ReferenceError: PizzaShopApp is
    not defined`, like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '终端将显示一个错误，说`ReferenceError: PizzaShopApp is not defined`，如下所示：'
- en: '![Figure 7.6: The failed test](img/B31103_07_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：失败的测试](img/B31103_07_06.jpg)'
- en: 'Figure 7.6: The failed test'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：失败的测试
- en: 'We’re in the red stage of the Red-Green-Refactor loop now, so we need to make
    the code pass using the simplest code possible. A static component that returns
    `PizzaShopApp`, in the test file that returns just the string:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们处于红-绿-重构循环的红阶段，因此我们需要使用尽可能简单的代码使代码通过。一个静态组件返回`PizzaShopApp`，在测试文件中返回仅包含字符串的代码：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we re-run the test, it passes since `PizzaShopApp` does exactly the thing
    the test expects – it shows **The Code Oven**. Now, we’re at the green stage of
    the Red-Green-Refactor loop. Next, we can look into opportunities for improvement.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新运行测试时，它通过了，因为`PizzaShopApp`确实做了测试所期望的事情——它显示了**The Code Oven**。现在，我们处于红-绿-重构循环的绿阶段。接下来，我们可以探讨改进的机会。
- en: 'We don’t want to write all our code inside the test file – instead, we can
    use the `PizzaShopApp` into a separate file called `App.tsx`. Now, the implementation
    lives in its own file, allowing us to change the test and the component separately:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在测试文件中编写所有代码——相反，我们可以将`PizzaShopApp`放入一个名为`App.tsx`的单独文件中。现在，实现部分位于自己的文件中，这使我们能够分别更改测试和组件：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Awesome! With that, we have done a complete Red-Green-Refactor loop. We can
    now remove that task from our task list and move on to the next one.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这样一来，我们就完成了一个完整的红-绿-重构循环。现在我们可以从任务列表中移除这个任务，继续下一个任务。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code doesn’t have to be perfect at the beginning as we know TDD is an iterative
    process; we always have a chance to make the code better as we have good tests
    protecting us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道TDD是一个迭代过程，因此代码在开始时不必完美；我们总有改进代码的机会，因为我们有良好的测试来保护我们。
- en: Implementing the menu list
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现菜单列表
- en: Even a basic menu list featuring just the names of pizzas can be valuable for
    customers who are looking to browse and decide what to eat. While The Code Oven
    may not be set up for online ordering yet, it serves as a useful starting point.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一个只显示比萨名称的基本菜单列表，对于想要浏览和决定吃什么顾客来说也是有价值的。虽然《代码烤箱》还没有设置好在线订购，但它是一个有用的起点。
- en: 'Looking at the second task on our list, we can write our second test like so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们列表上的第二个任务，我们可以这样编写我们的第二个测试：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This test starts by rendering the component. Then, it identifies the HTML element
    tagged with the `list` role from the rendered component. Using the `within` function,
    it narrows down the search to only that list and locates all items within it tagged
    with `listitem`. Finally, it asserts that the number of such items should be equal
    to `8` (the number of items the pizza shop has to offer). Essentially, we want
    eight list items to show up on the page.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试首先渲染组件。然后，它从渲染的组件中识别带有`list`角色的HTML元素。使用`within`函数，它将搜索范围缩小到仅限于该列表，并定位其中所有带有`listitem`标签的项目。最后，它断言这些项目的数量应该等于`8`（比萨店提供的项目数量）。本质上，我们希望在页面上显示八个列表项。
- en: 'Now, the test has failed. To make the test pass easily, we can hard-code eight
    empty list items on the page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试失败了。为了使测试容易通过，我们可以在页面上硬编码八个空列表项：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It doesn’t look too good, but it makes the test pass all the same. This is important
    to remember – during TDD, we always want to make the test pass first and then
    look for opportunities to improve afterward. The advantage of this mindset forces
    us to think about delivery and production readiness; we should be able to stop
    coding at any point and release the app to production – even if the code isn’t
    perfect yet.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来不太好，但测试仍然通过了。这一点很重要要记住——在TDD（测试驱动开发）过程中，我们总是希望首先让测试通过，然后再寻找改进的机会。这种思维方式的优点迫使我们考虑交付和生产准备；我们应该能够在任何时刻停止编码并将应用程序发布到生产环境——即使代码还不是完美的。
- en: 'Now, re-run the test to see if it passes; if so, we can start refactoring it.
    To reduce the long hard-coded `<li>` (the list item tag in HTML), we can use an
    array with eight elements and use `map` to generate the `<li>` dynamically inside
    an ordered list (`<ol>`):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行测试以查看它是否通过；如果通过了，我们就可以开始重构它。为了减少长硬编码的`<li>`（HTML中的列表项标签），我们可以使用一个包含八个元素的数组，并使用`map`在有序列表（`<ol>`）中动态生成`<li>`。
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inside this list, an array with eight elements (all initialized to 0) is mapped
    over, generating eight empty list items (`<li>`). This matches the test criteria
    of having a menu list with eight items and the tests pass with the new structure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，一个包含八个元素（所有初始化为0）的数组被映射，生成八个空列表项（`<li>`）。这符合测试标准，即有一个包含八个项目的菜单列表，并且测试在新结构下通过。
- en: 'With that, we’ve done another Red-Green-Refactor loop. Now, we can verify that
    the pizza names are displayed correctly. Let’s add a few more lines to the second
    test case:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们又完成了一个红-绿-重构循环。现在，我们可以验证比萨名称是否正确显示。让我们为第二个测试案例添加几行代码：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To make all the newly added lines pass, we’ll need to define a list of pizza
    names in `PizzaShopApp`, and then use the `map` function in the `pizzas` array
    to map through these names into list items:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有新添加的行通过，我们需要在`PizzaShopApp`中定义一个比萨名称列表，然后使用`pizzas`数组中的`map`函数将这些名称映射到列表项中：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The tests are now successfully passing. While the code may be overly simplified,
    the passing tests give us the confidence to make further changes without having
    to worry about any accidental feature breaks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在成功通过了。虽然代码可能过于简化，但通过测试让我们有信心进行进一步的更改，而不用担心任何意外的功能损坏。
- en: It’s great to have a menu list, but the purpose of The Code Oven is to help
    users order online. So, let’s look into how we can create a shopping cart.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个菜单列表是很好的，但《代码烤箱》的目的在于帮助用户在线订购。所以，让我们看看我们如何创建一个购物车。
- en: Creating the shopping cart
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建购物车
- en: To develop a `ShoppingCart` component, we will start with a simple test that
    expects an empty container to show on the page. Inside the container, there should
    be a button for the user to place their order.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发`ShoppingCart`组件，我们将从一个简单的测试开始，该测试期望在页面上显示一个空的容器。在这个容器内部，应该有一个按钮供用户下单。
- en: 'To do this, we will start with a test that simply checks that the container
    and button are present:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将从一个简单的测试开始，该测试仅检查容器和按钮是否存在：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Jest test renders the `PizzaShopApp` component and then locates a shopping
    cart container by its `data-testid`. Within this container, it looks for a button
    element by its role. The test concludes by using the `toBeInTheDocument()` matcher
    to verify that this button is present in the rendered output.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Jest测试渲染`PizzaShopApp`组件，然后通过`data-testid`定位购物车容器。在这个容器中，它通过其角色查找按钮元素。测试通过使用`toBeInTheDocument()`匹配器来验证这个按钮是否存在于渲染输出中。
- en: 'To make this test pass, we can add an empty `div` as a container with `data-testid`,
    and put an empty button inside it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们可以在一个带有`data-testid`的空`div`容器中添加一个空按钮：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As the tests pass, we can add more details to the test, checking if the button
    is disabled by default.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试通过，我们可以添加更多细节到测试中，检查按钮是否默认禁用。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Observe how we oscillate between the test code and the actual implementation,
    especially in the beginning. As you become more accustomed to the Red-Green-Refactor
    cycle, you’ll be able to write increasingly complex tests and adjust your code
    to pass them. The key objective initially is to establish this rapid feedback
    loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们如何在测试代码和实际实现之间来回切换，尤其是在开始时。随着你对红-绿-重构循环越来越熟悉，你将能够编写越来越复杂的测试，并调整你的代码以通过它们。最初的关键目标是建立这个快速反馈循环。
- en: 'We should now add a few more details to the test, to check the button text
    and the disabled status by default – we want to make sure users cannot interact
    with the button:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该给测试添加更多细节，以检查按钮文本和默认禁用状态——我们想要确保用户不能与按钮交互：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the new assertions added, the test failed again, waiting for us to add
    more details to the implementation. It’s straightforward to make the test pass
    by adding the text and `disabled` status:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了新的断言后，测试再次失败，等待我们添加更多实现细节。通过添加文本和`disabled`状态，使测试通过是直接的：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The tests are all passing again, so that’s another task to tick off (note how
    maintaining a task list can help us focus and gradually shape our application
    code).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 测试再次全部通过，所以这是另一个完成的任务（注意如何维护任务列表可以帮助我们集中精力，并逐步塑造我们的应用程序代码）。
- en: Next, we will look at the next task – adding items from the menu to the shopping
    cart.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看下一个任务——将菜单中的项目添加到购物车中。
- en: Adding items to the shopping cart
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加购物车项目
- en: 'Once we have the basic structure of the `ShoppingCart` component, we need to
    add a few more assertions to verify it works. We will start by adding one item
    to the cart, which can be done with the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有`ShoppingCart`组件的基本结构，我们需要添加更多断言来验证它是否正常工作。我们将从添加一个项目到购物车开始，可以使用以下代码完成：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This test renders the `PizzaShopApp` component, fetches the menu list, and
    grabs all the list items within it. Then, it simulates a user clicking the **Add**
    button of the first menu item. Next, it locates the shopping cart container and
    checks two things:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试渲染了`PizzaShopApp`组件，获取菜单列表，并获取其中的所有列表项。然后，它模拟用户点击第一个菜单项的**添加**按钮。接下来，它定位购物车容器并检查两件事：
- en: The added item, **Margherita Pizza**, appears in the cart
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加的项目，**玛格丽塔披萨**，出现在购物车中
- en: The **Place My Order** button is enabled
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下订单**按钮已启用'
- en: 'Let’s add the button to a menu item first, and then add a state to manage the
    user selection and enable the **Place My Order** button according to the selection:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先给菜单项添加按钮，然后添加一个状态来管理用户选择，并根据选择启用**下订单**按钮：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `PizzaShopApp` function component uses React’s `useState` Hook to manage
    an array of `cartItems`. It defines a function, `addItem`, to add items to this
    cart. The component renders a list of pizzas, each with an `addItem` function,
    adding the corresponding pizza to the `cartItems` array.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`PizzaShopApp`函数组件使用React的`useState`钩子来管理`cartItems`数组。它定义了一个函数`addItem`，用于向购物车添加项目。组件渲染一个披萨列表，每个披萨都有一个`addItem`函数，将相应的披萨添加到`cartItems`数组中。'
- en: The shopping cart displays the items in `cartItems` in a list. The `cartItems`
    array. Specifically, the button is disabled when the cart is empty – `(cartItems.length
    ===` `0)`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车以列表形式显示`cartItems`中的商品。`cartItems`数组。具体来说，当购物车为空时，按钮被禁用 – `(cartItems.length
    === 0)`。
- en: 'The implementation looks great, but if we run the tests, something weird happens.
    The test failed in the terminal with the following error message: `TestingLibraryElementError:
    Found multiple elements with the role "list"`. This is because we have two lists
    (one in the menu and the other in the shopping cart) on the screen now, and the
    React Testing Library is confused about which one should look for the `data-testid`
    to the menu list and modifying the test accordingly.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '实现看起来很棒，但如果我们运行测试，会发生一些奇怪的事情。测试在终端中失败，并显示以下错误消息：`TestingLibraryElementError:
    Found multiple elements with the role "list"`。这是因为现在屏幕上有两个列表（一个在菜单中，另一个在购物车中），React
    Testing Library对此感到困惑，不知道应该寻找哪个列表的`data-testid`来修改测试。'
- en: 'Firstly, let’s change our `PizzaShopApp` component and move the first `<ol>`
    (the ordered list tag) into a `div` element attributed with `data-testid="menu-list"`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更改我们的`PizzaShopApp`组件，并将第一个`<ol>`（有序列表标签）移动到一个带有`data-testid="menu-list"`属性的`div`元素中：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we must modify the test so that it looks as follows (note that we explicitly
    ask the React Testing Library to search inside `menu-list` for all list items):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须修改测试，使其看起来如下（注意，我们明确要求React Testing Library在`menu-list`内部搜索所有列表项）：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we re-run the test, it fails again with this message: `TestingLibraryElementError:
    Unable to find an element with the text: Margherita Pizza`. This could be because
    the text is broken up by multiple elements. In this case, you can provide a function
    for your text matcher to make your matcher more flexible.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们再次运行测试时，它再次失败，并显示以下消息：`TestingLibraryElementError: Unable to find an element
    with the text: Margherita Pizza`。这可能是因为文本被多个元素分割。在这种情况下，你可以为你的文本匹配器提供一个函数，使你的匹配器更加灵活。'
- en: 'The expected `cartItems` state. But when React detects the state change and
    re-renders, the test isn’t waiting for that to happen. In other words, it’s too
    early for the test to see the updated `cartItems`. We need to give React a bit
    of time to digest the change and re-render. We can mark the test case as `async`
    and wait for `userEvent.click` to make the state change:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的`cartItems`状态。但是当React检测到状态变化并重新渲染时，测试并没有等待这一发生。换句话说，测试看到更新的`cartItems`还为时过早。我们需要给React一点时间来消化变化并重新渲染。我们可以将测试用例标记为`async`并等待`userEvent.click`使状态发生变化：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this code snippet, the use of `async` and `await` ensures that the asynchronous
    operations are completed before they move on to the next step in the test. The
    test function itself is marked as async, making it return a Promise, which Jest
    will wait for before considering the test complete.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`async`和`await`的使用确保了异步操作在测试的下一步之前完成。测试函数本身被标记为`async`，使其返回一个Promise，Jest将在测试完成之前等待这个Promise。
- en: The `await userEvent.click(addButton);` line is particularly important here.
    `userEvent.click` simulates a real user clicking a button and might trigger state
    updates or effects in your React component. Using `await` ensures that all associated
    updates and effects are fully completed before moving on to the subsequent lines
    of the test.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`await userEvent.click(addButton);`行尤其重要。`userEvent.click`模拟了真实用户点击按钮，可能会触发React组件中的状态更新或效果。使用`await`确保在继续测试的后续行之前，所有相关的更新和效果都已完全完成。
- en: By ensuring that `userEvent.click` has been fully processed, the test will then
    safely proceed to query and assert against the updated DOM or state. This is crucial
    for preventing false negatives, where the test might fail not because the code
    is incorrect, but because the test is checking the DOM before all updates have
    occurred.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保`userEvent.click`已被完全处理，测试将安全地继续查询并断言更新后的DOM或状态。这对于防止假阴性至关重要，在这种情况下，测试可能失败并不是因为代码错误，而是因为测试在所有更新发生之前检查了DOM。
- en: Since all the tests are passing again, it’s time to look into other opportunities
    for improvement.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有测试都通过了，现在是时候考虑其他改进的机会了。
- en: Refactoring the code
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码重构
- en: 'The code we have now isn’t too hard to understand, but it has some room for
    improvement. Let’s quickly look at what we have got so far:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码并不难理解，但还有一些改进的空间。让我们快速看一下我们已经取得的成果：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let’s make some changes. Firstly, we could use the `x` to `item`, to make
    it a bit more meaningful. Also, there is a warning in the terminal now, saying
    `Warning: Each child in a list should have a unique "key" prop` – as React expects
    a unique key for each item it renders, we need to have a key for each `<li>` element.
    For now, we can use the item (the pizza name) as the key to fix this issue:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们做一些更改。首先，我们可以将 `x` 改为 `item`，使其更具意义。此外，现在终端中有一个警告，说 `Warning: Each child
    in a list should have a unique "key" prop` —— 因为 React 期望为它渲染的每个项目都有一个唯一的键，所以我们需要为每个
    `<li>` 元素提供一个键。目前，我们可以使用项目（披萨名称）作为键来解决这个问题：'
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As another change, the menu item list looks pretty self-contained and doesn’t
    depend on anything out of the context it lives in, so we can extract a new component
    here to encapsulate that logic:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个更改，菜单项列表看起来相当独立，不依赖于它所在上下文之外的内容，因此我们可以在这里提取一个新的组件来封装这个逻辑：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `MenuList` component takes a single prop, `onAddMenuItem`, which is a function
    that accepts a string argument representing a menu item. The component renders
    a list of pizzas, which presumably is an array of strings. For each pizza, it
    creates a list item and an `onAddMenuItem` function is called with the corresponding
    pizza name as an argument. The component uses the `data-testid="menu-list"` attribute
    to make it easier to query this section during testing. Overall, this is a presentational
    component that’s designed to display a list of pizzas and handle the addition
    of menu items through the provided callback.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuList` 组件接受一个名为 `onAddMenuItem` 的单一属性，这是一个接受代表菜单项的字符串参数的函数。该组件渲染一个披萨列表，这大概是一个字符串数组。对于每一款披萨，它创建一个列表项，并使用相应的披萨名称作为参数调用
    `onAddMenuItem` 函数。该组件使用 `data-testid="menu-list"` 属性，以便在测试期间更容易查询此部分。总的来说，这是一个用于显示披萨列表并通过提供的回调处理菜单项添加的展示性组件。'
- en: 'Similarly, we can extract a new component for the shopping cart, like so:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以提取一个新的组件用于购物车，如下所示：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ShoppingCart` component takes an array of `cartItems` as its prop. This
    array holds the names of the items that have been added to the shopping cart.
    The component renders an ordered list (`<ol>`) where each list item (`<li>`) corresponds
    to an item in the cart. It uses the `data-testid="shopping-cart"` attribute to
    make it easier to identify this component in tests. Additionally, a `cartItems`
    array is empty, meaning there are no items in the cart. Overall, this component
    is designed to display the items in the shopping cart and provide an option to
    place an order.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 组件接受一个名为 `cartItems` 的数组属性。这个数组包含已添加到购物车的项目名称。该组件渲染一个有序列表 (`<ol>`)，其中每个列表项
    (`<li>`) 对应购物车中的一个项目。它使用 `data-testid="shopping-cart"` 属性，以便在测试中更容易识别此组件。此外，一个空的
    `cartItems` 数组意味着购物车中没有项目。总的来说，这个组件旨在显示购物车中的项目，并提供一个下单选项。'
- en: 'After these extractions, we can use these components in the main component,
    `PizzaShopApp`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些提取之后，我们可以在主组件 `PizzaShopApp` 中使用这些组件：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: During these relatively big changes, our tests always stay in the green state
    – meaning no functions are broken. We haven’t implemented all the tasks we have
    broken down, but I believe you have got the idea of the Red-Green-Refactor loop.
    You can use the remaining tasks as exercises, making sure you always write the
    test first, with only the minimal code, and looking for improvements after the
    test passes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些相对较大的变更期间，我们的测试始终保持在绿色状态——这意味着没有函数被破坏。我们还没有实施我们分解的所有任务，但我相信你已经理解了红-绿-重构循环。你可以使用剩余的任务作为练习，确保你总是先编写测试，只编写最少的代码，并在测试通过后寻找改进。
- en: You may initially find this coding approach challenging as it requires you to
    resist the temptation to immediately delve into implementation. Instead, take
    incremental steps and savor the journey. You’ll soon discover the strength that
    lies in taking small steps, as well as how maintaining a steady rhythm can enhance
    your focus and productivity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能一开始会觉得这种编码方法具有挑战性，因为它要求你抵制立即深入实现的诱惑。相反，采取逐步的方法，享受这个过程。很快你就会发现，逐步前进的力量，以及保持稳定节奏如何提高你的专注力和生产力。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter on TDD, we’ve explored various forms of TDD, emphasizing the
    importance of breaking down complex problems into manageable tasks through tasking.
    We delved into two key approaches – top-down and bottom-up, each with its distinct
    merits and use cases. To illustrate these concepts, we used a practical example
    of building a pizza shop application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章关于TDD的讨论中，我们探讨了TDD的各种形式，强调了通过任务分解将复杂问题分解为可管理任务的重要性。我们深入探讨了两种关键方法——自顶向下和自底向上，每种方法都有其独特的优点和应用场景。为了说明这些概念，我们使用了构建比萨店应用程序的实际示例。
- en: This hands-on example helped solidify the theories and methodologies we discussed,
    providing a comprehensive understanding of how TDD can be employed effectively
    in different scenarios.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动手实践示例帮助我们巩固了所讨论的理论和方法，提供了对如何在不同场景下有效应用测试驱动开发（TDD）的全面理解。
- en: In the upcoming chapter, we’ll delve deeper into the intricate world of data
    management in React applications. Specifically, we’ll explore various design patterns
    that are commonly adopted for efficient data access and manipulation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨React应用程序中数据管理的复杂世界。具体来说，我们将探索各种常见的设计模式，这些模式被广泛采用以实现高效的数据访问和处理。
- en: 'Part 3: Unveiling Business Logic and Design Patterns'
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：揭示业务逻辑和设计模式
- en: This part looks at business logic and design patterns, which are essential in
    tackling common challenges in state management and adhering to principles, such
    as the single responsibility principle, in order to maintain a clean and efficient
    code base.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分探讨业务逻辑和设计模式，这在应对状态管理中的常见挑战和遵循原则（如单一职责原则）以保持代码库的整洁和高效方面至关重要。
- en: 'This part contains the following chapters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B21103_08.xhtml#_idTextAnchor212), *Exploring Data Management
    in React*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21103_08.xhtml#_idTextAnchor212)，*探索React中的数据管理*'
- en: '[*Chapter 9*](B21103_09.xhtml#_idTextAnchor227), *Applying Design Principles
    in React*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21103_09.xhtml#_idTextAnchor227)，*在React中应用设计原则*'
- en: '[*Chapter 10*](B21103_10.xhtml#_idTextAnchor251), *Diving Deep into Composition
    Patterns*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21103_10.xhtml#_idTextAnchor251)，*深入探索组合模式*'
