- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Rendering Lists and Conditional Content
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染列表和条件内容
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几件事情：
- en: Output dynamic content conditionally
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件输出动态内容
- en: Render lists of data and map list items to JSX elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染数据列表并将列表项映射到JSX元素
- en: Optimize lists such that React is able to efficiently update the user interface
    when needed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化列表，以便React在需要时能够高效地更新用户界面
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: By this point in the book, you are already familiar with several key concepts,
    including components, props, state, and events, with which you have all the core
    tools you need to build all kinds of different React apps and websites. You have
    also learned how to output dynamic values and results as part of the user interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，你已经熟悉了几个关键概念，包括组件、属性、状态和事件，这些是构建各种不同React应用和网站所需的所有核心工具。你也已经学会了如何将动态值和结果作为用户界面的一部分输出。
- en: 'However, there are two topics related to outputting dynamic data that have
    not yet been discussed in depth: outputting content conditionally and rendering
    list data. Since most (if not all) websites and web apps you build will require
    at least one of these two concepts, it is crucial to know how to work with conditional
    content and list data.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有两个与输出动态数据相关的话题尚未深入讨论：条件输出内容和渲染列表数据。由于你构建的大多数（如果不是所有）网站和Web应用都将需要这两个概念中的至少一个，因此了解如何处理条件内容和列表数据至关重要。
- en: In this chapter, you will therefore learn how to render and display different
    user interface elements (and even entire user interface sections), based on dynamic
    conditions. In addition, you will learn how to output lists of data (such as a
    to-do list with its items) and render JSX elements dynamically for the items that
    make up a list. This chapter will also explore important best practices related
    to outputting lists and conditional content.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，你将学习如何根据动态条件渲染和显示不同的用户界面元素（甚至整个用户界面部分）。此外，你还将学习如何输出数据列表（如待办事项列表及其条目）并动态渲染构成列表的JSX元素。本章还将探讨与输出列表和条件内容相关的重要最佳实践。
- en: What Are Conditional Content and List Data?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件内容和列表数据是什么？
- en: Before diving into the techniques for outputting conditional content or list
    data, it is important to understand what exactly is meant by those terms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究输出条件内容或列表数据的技巧之前，了解这些术语的确切含义非常重要。
- en: 'Conditional content simply means any kind of content that should only be displayed
    under certain circumstances. Some examples are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 条件内容简单来说就是任何只在特定情况下应该显示的内容。以下是一些示例：
- en: Error overlays that should only show up if a user submits incorrect data in
    a form
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在用户在表单中提交错误数据时显示的错误覆盖层
- en: Additional form input fields that appear once the user chooses to enter extra
    details (such as business details)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户选择输入额外详细信息（如业务详情）时出现的附加表单输入字段
- en: A loading spinner that is displayed while data is sent or fetched to or from
    a backend server
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向或从后端服务器发送或获取数据时显示的加载旋转器
- en: A side navigation menu that slides into view when the user clicks on a menu
    button
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击菜单按钮时滑入视图的侧导航菜单
- en: 'This is just a very short list of a few examples. You could, of course, come
    up with hundreds of additional examples. But it should be clear what all these
    examples are about in the end: visual elements or entire sections of the user
    interface that are only shown if certain conditions are met.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个包含几个示例的非常简短的列表。当然，你可以想出数百个额外的例子。但最终应该清楚所有这些示例都是关于什么的：仅在满足某些条件时才显示的视觉元素或用户界面的整个部分。
- en: In the first example (an error overlay), the condition would be that a user
    entered incorrect data into a form. The conditionally shown content would then
    be the error overlay.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例（错误覆盖层）中，条件是用户在表单中输入了错误数据。然后，条件显示的内容将是错误覆盖层。
- en: Conditional content is extremely common since virtually all websites and web
    apps have some content that is similar or comparable to the preceding examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 条件内容非常常见，因为几乎所有的网站和Web应用都有一些与前面示例相似或可比的内容。
- en: 'In addition to conditional content, many websites also output lists of data.
    It might not always be immediately obvious, but if you think about it, there is
    virtually no website that does not display some kind of list data. Again, here
    are some examples of list data that may be outputted on a site:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了条件性内容外，许多网站还会输出数据列表。这不一定总是立即明显，但如果你仔细想想，几乎没有任何网站不显示某种类型的列表数据。再次，这里有一些可能在网站上输出的列表数据的例子：
- en: An online shop displaying a grid or list of products
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示产品网格或列表的在线商店
- en: An event booking site displaying a list of events
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示活动列表的活动预订网站
- en: A shopping cart displaying a list of cart items
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示购物车中商品列表的购物车
- en: An orders page displaying a list of orders
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示订单列表的订单页面
- en: A blog displaying a list of blog posts—and maybe a list of comments below a
    blog post
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示博客文章列表——以及可能位于博客文章下方的评论列表
- en: A list of navigation items in the header
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页眉中的导航项列表
- en: An endless list (no pun intended) of examples could be created here. Lists are
    everywhere on the web. As the preceding examples show, many (probably even most)
    websites have multiple lists with various kinds of data on the same site.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有恶意的无尽列表（例子）可以在这里创建。列表在网络上无处不在。正如前面的例子所示，许多（可能甚至大多数）网站在同一网站上都有多个列表，包含各种类型的数据。
- en: Take an online shop, for example. Here, you would have a list (or a grid, which
    is really just another kind of list) of products, a list of shopping cart items,
    a list of orders, a list of navigation items in the header, and certainly a lot
    of other lists as well. This is why it is important that you know how to output
    any kind of list with any kind of data in React-driven user interfaces.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个在线商店为例。在这里，你会有一个产品列表（或者一个网格，实际上它只是另一种列表形式），购物车商品列表，订单列表，页眉中的导航项列表，以及当然还有很多其他的列表。这就是为什么了解如何在React驱动的用户界面中输出任何类型的数据的任何类型的列表变得非常重要。
- en: Rendering Content Conditionally
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件性渲染内容
- en: 'Imagine the following scenario. You have a button that, when clicked, should
    result in the display of an extra text box, as shown here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想象以下场景。你有一个按钮，点击后应该显示一个额外的文本框，如下所示：
- en: '![A black and white rectangular sign  Description automatically generated](img/B31339_05_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![一个黑白矩形标志 自动生成的描述](img/B31339_05_01.png)'
- en: 'Figure 5.1: Initially, nothing but the button shows up on the screen'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：最初，屏幕上只显示按钮
- en: 'After a click on the button, another box is shown:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，另一个框被显示：
- en: '![A screen shot of a computer  Description automatically generated](img/B31339_05_02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成的描述](img/B31339_05_02.png)'
- en: 'Figure 5.2: After clicking the button, the info box is revealed'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：点击按钮后，信息框被显示
- en: This is a very simple example, but not an unrealistic one. Many websites have
    parts of the user interface that work like this. Showing extra information upon
    a button click (or some similar interaction) is a common pattern. Just think of
    nutrition information below a meal on a food order site or an FAQ section where
    answers are shown after selecting a question.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但并非不切实际。许多网站的用户界面部分都像这样工作。在按钮点击（或类似交互）时显示额外信息是一种常见模式。只需想想食品订单网站上餐点下方的营养成分信息或是在选择问题后显示答案的常见问题解答部分。
- en: So, how could this scenario be implemented in a React app?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个场景如何在React应用中实现呢？
- en: 'If you ignore the requirement of rendering some of the content conditionally,
    the overall React component could look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忽略了渲染某些内容条件性的要求，整个React组件可能看起来像这样：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This component has absolutely no conditional code in it and, therefore, both
    the button and the extra information box are shown all the time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件中完全没有条件性代码，因此按钮和额外的信息框总是显示出来。
- en: In this example, how could the paragraph with the terms-of-use summary text
    be shown conditionally (that is, only after the button is clicked)?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如何有条件地显示包含使用条款摘要文本的段落（即，仅在按钮点击后显示）？
- en: 'With the knowledge gained throughout the previous chapters, especially *Chapter
    4* , *Working with Events and State* , you already have the skills needed to only
    show the text after the button is clicked. The following code shows how the component
    could be rewritten to show the full text only after the button is clicked:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面章节中获得的知识，特别是*第4章*，*处理事件和状态*，你已经拥有了在按钮点击后仅显示文本所需的所有技能。以下代码显示了组件如何被重写，以便仅在按钮点击后显示完整文本：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Parts of the code shown in this snippet already qualify as conditional content.
    The `paragraphText` value is set conditionally, with the help of an `if` statement
    based on the value stored in the `showTerms` state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中显示的代码部分已经符合条件内容的资格。`paragraphText`值是根据存储在`showTerms`状态中的值有条件地设置的，借助一个`if`语句。
- en: 'However, the `<p>` element itself is actually **not** conditional. It is always
    there, regardless of whether it contains a full sentence or an empty string. If
    you were to open the browser developer tools and inspect that area of the page,
    an empty paragraph element would be visible, as shown in the following figure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`<p>`元素本身实际上**不是**条件性的。它始终存在，无论它包含一个完整的句子还是一个空字符串。如果你打开浏览器开发者工具并检查该页面的该区域，你会看到一个空的段落元素，如下面的图所示：
- en: '![img](img/B31339_05_03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_05_03.png)'
- en: 'Figure 5.3: An empty paragraph element is rendered as part of the DOM'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：一个空的段落元素作为 DOM 的一部分被渲染
- en: Having that empty `<p>` element in the DOM is not ideal. While it’s invisible
    to the user, it’s an extra element that needs to be rendered by the browser. The
    performance impact will very likely be negligible but it’s still something you
    should avoid. A web page doesn’t benefit from having empty elements that contain
    no content.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DOM 中保留那个空的`<p>`元素并不是理想的做法。虽然它对用户来说是不可见的，但它是一个需要浏览器渲染的额外元素。性能影响可能非常小，但仍然是你应该避免的事情。网页不会从包含无内容的空元素中受益。
- en: You can translate your knowledge about conditional values (such as the paragraph
    text) to conditional elements, however. Besides storing standard values such as
    text or numbers in variables, you can also store JSX elements in variables. This
    is possible because, as mentioned in *Chapter 1* , *React – What and Why* , JSX
    is just syntactic sugar. Behind the scenes, a JSX element is a standard JavaScript
    function that is executed by React. Also, of course, the return value of a function
    call can be stored in a variable or constant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将关于条件值（例如段落文本）的知识翻译成条件元素。除了在变量中存储标准值，如文本或数字外，您还可以在变量中存储 JSX 元素。这是因为，如*第一章*，*React
    – What and Why*中提到的，JSX 只是一种语法糖。在幕后，一个 JSX 元素是一个由 React 执行的标准 JavaScript 函数。当然，函数调用的返回值也可以存储在变量或常量中。
- en: 'With that in mind, the following code could be used to render the entire paragraph
    conditionally:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，以下代码可以用来有条件地渲染整个段落：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, if `showTerms` is `true` , the `paragraph` variable does not
    store text but instead an entire JSX element (the `<p>` element). In the returned
    JSX code, the value stored in the `paragraph` variable is outputted dynamically
    via `{paragraph}` . If `showTerms` is `false` , `paragraph` stores the value `undefined`
    and nothing is rendered to the DOM. Therefore, inserting `null` or `undefined`
    in JSX code leads to nothing being outputted by React. But if `showTerms` is `true`
    , the complete paragraph is saved as a value and outputted in the DOM.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`showTerms`为`true`，`paragraph`变量不存储文本，而是存储一个完整的 JSX 元素（`<p>`元素）。在返回的
    JSX 代码中，存储在`paragraph`变量中的值通过`{paragraph}`动态输出。如果`showTerms`为`false`，`paragraph`存储的值为`undefined`，并且不会将任何内容渲染到
    DOM 中。因此，在 JSX 代码中插入`null`或`undefined`会导致 React 不输出任何内容。但如果`showTerms`为`true`，整个段落作为一个值保存并输出到
    DOM 中。
- en: This is how entire JSX elements can be rendered dynamically. Of course, you
    are not limited to single elements. You could store entire JSX tree structures
    (such as multiple, nested, or sibling JSX elements) inside variables or constants.
    As a simple rule, anything that can be returned by a component function can be
    stored in a variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何动态渲染整个 JSX 元素的方法。当然，你不仅限于单个元素。你可以在变量或常量中存储整个 JSX 树结构（如多个、嵌套或兄弟 JSX 元素）。作为一个简单的规则，任何可以由组件函数返回的内容都可以存储在变量中。
- en: Different Ways of Rendering Content Conditionally
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有条件地渲染内容的不同方式
- en: In the example shown previously, content is rendered conditionally by using
    a variable, which is set with the help of an `if` statement and then outputted
    dynamically in JSX code. This is a common (and perfectly fine) technique of rendering
    content conditionally, but it is not the only approach you can use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面显示的示例中，内容是通过使用变量有条件地渲染的，该变量通过`if`语句设置，然后在 JSX 代码中动态输出。这是一种常见的（并且完全可行的）有条件渲染内容的技术，但并不是你唯一可以使用的方案。
- en: 'Alternatively, you could also do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以这样做：
- en: Utilize ternary expressions.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用三元表达式。
- en: '*Abuse* JavaScript logical operators.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*滥用* JavaScript 逻辑运算符。'
- en: Use any other valid JavaScript way of selecting values conditionally.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任何其他有效的 JavaScript 条件选择值的方式。
- en: The following sections will explore each approach in detail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将详细探讨每种方法。
- en: Utilizing Ternary Expressions
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用三元表达式
- en: In JavaScript (and many other programming languages), you can use **ternary
    expressions** (also referred to as **conditional ternary operators** ) as alternatives
    to `if` statements. Ternary expressions can save you lines of code, especially
    with simple conditions where the main goal is to assign some variable value conditionally.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript（以及许多其他编程语言）中，你可以使用 **三元表达式**（也称为 **条件三元运算符**）作为 `if` 语句的替代。三元表达式可以节省代码行数，尤其是在简单条件中，主要目标是条件性地分配一些变量值。
- en: 'Here is a direct comparison—first starting with a regular `if` statement:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个直接的比较——首先从一个普通的 `if` 语句开始：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the same logic, implemented with a ternary expression:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的逻辑，使用三元表达式实现：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is standard JavaScript code, not specific to React. However, it is important
    to understand this core JavaScript feature in order to understand how it can be
    used in React apps.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是标准的 JavaScript 代码，并非特定于 React。然而，理解这个核心 JavaScript 功能对于理解如何在 React 应用程序中使用它非常重要。
- en: 'Translated to the previous React example, the paragraph content could be set
    and outputted conditionally with the help of ternary expressions like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将其翻译到先前的 React 示例中，段落内容可以通过以下三元表达式有条件地设置和输出：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the overall code is a bit shorter than before, when an `if`
    statement was used. The paragraph constant contains either the paragraph (including
    the text content) or `null` . `null` is used as an alternative value because `null`
    can safely be inserted into JSX code as it simply leads to nothing being rendered
    in its place.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，整体代码比之前使用 `if` 语句时更短。段落常量包含段落（包括文本内容）或 `null`。`null` 被用作替代值，因为 `null`
    可以安全地插入到 JSX 代码中，它只会导致在该位置不渲染任何内容。
- en: 'A disadvantage of ternary expressions is that readability and understandability
    may suffer—especially when using nested ternary expressions, like in the following
    example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 三元表达式的一个缺点是可读性和可理解性可能会受到影响——尤其是在使用嵌套的三元表达式时，如下面的例子所示：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is difficult to read and even more difficult to understand. For this
    reason, you should typically avoid writing nested ternary expressions and fall
    back to `if` statements in such situations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码难以阅读，甚至更难以理解。因此，通常你应该避免编写嵌套的三元表达式，并在这种情况下回退到 `if` 语句。
- en: 'However, despite these potential disadvantages, ternary expressions can help
    you write less code in React apps, especially when using them inline, directly
    inside some JSX code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管存在这些潜在的缺点，三元表达式可以帮助你在 React 应用程序中编写更少的代码，尤其是在内联使用时，直接在某个 JSX 代码内部：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the same example as before, only now it’s even shorter since here you
    avoid using the `paragraph` constant by utilizing the ternary expression directly
    inside of the JSX snippet. This allows for relatively lean component code, so
    it is quite common to use ternary expressions in JSX code in React apps to take
    advantage of this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的例子相同，但现在它更短，因为在这里你通过在 JSX 片段中直接使用三元表达式来避免使用 `paragraph` 常量。这使得组件代码相对简洁，因此在
    React 应用程序中，在 JSX 代码中使用三元表达式以利用这一点是非常常见的。
- en: Abusing JavaScript Logical Operators
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滥用 JavaScript 逻辑运算符
- en: Ternary expressions are popular because they enable you to write less code,
    which, when used in the right places (and avoiding nesting multiple ternary expressions),
    can help with overall readability.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 三元表达式之所以受欢迎，是因为它们允许你编写更少的代码，当在正确的地方使用（并避免嵌套多个三元表达式）时，可以帮助提高整体的可读性。
- en: 'Especially in React apps, in JSX code you will often write ternary expressions
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在 React 应用程序中，在 JSX 代码中你经常会写出类似这样的三元表达式：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，像这样：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What do these two snippets have in common?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段有什么共同之处？
- en: 'They are unnecessarily long because, in both examples, the else case ( `: null`
    ) must be specified, even though it adds nothing to the final user interface.
    After all, the primary purpose of these ternary expressions is to render JSX elements
    ( `<h1>` and `<p>` , in the preceding examples). The `else` case ( `: null` )
    simply means nothing is rendered if the conditions ( `showDetails` and `showTerms`
    ) are not met.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '它们是不必要的长，因为在两个例子中，即使它对最终用户界面没有任何贡献，也必须指定 else 情况（`: null`）。毕竟，这些三元表达式的首要目的是渲染
    JSX 元素（在先前的例子中是 `<h1>` 和 `<p>`）。else 情况（`: null`）仅仅意味着如果条件（`showDetails` 和 `showTerms`）不满足，则不渲染任何内容。'
- en: 'This is why a different pattern is popular among React developers:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在React开发者中流行另一种模式：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the shortest possible way of achieving the intended result, rendering
    only the `<h1>` element and its content if `showDetails` is `true` .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现预期结果的最短方式，如果`showDetails`是`true`，则仅渲染`<h1>`元素及其内容。
- en: This code uses (or abuses) an interesting behavior of JavaScript’s logical operators,
    specifically of the `&&` (logical `and` ) operator. In JavaScript, the `&&` operator
    returns the second value (that is, the value after `&&` ) if the first value (that
    is, the value before `&&` ) is `true` or truthy (that is, not `false` , `undefined`
    , `null` , `0` , and so on). Normally, you’d use the `&&` operator in `if` statements
    or ternary expressions. However, when working with React and JSX, you can take
    advantage of the behavior described previously to output truthy values conditionally.
    This technique is also called **short-circuiting** .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用（或滥用）了JavaScript逻辑运算符的一个有趣的行为，特别是`&&`（逻辑与）运算符。在JavaScript中，如果第一个值（即`&&`前面的值）是`true`或真值（即不是`false`、`undefined`、`null`、`0`等），则`&&`运算符返回第二个值（即`&&`后面的值）。通常，你会在`if`语句或三元表达式中使用`&&`运算符。然而，当与React和JSX一起工作时，你可以利用前面描述的行为有条件地输出真值。这种技术也称为**短路**。
- en: 'For example, the following code would output `''` `Hello''` :'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将输出`'Hello'`：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This behavior can be used to write very short expressions that check a condition
    and then output another value, as shown in the preceding example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可以用来编写非常短的检查条件并输出另一个值的表达式，如前例所示。
- en: '**Note**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It is worth noting that using `&&` can lead to unexpected results if you’re
    using it with non-Boolean condition values (that is, if the value in front of
    `&&` holds a non-Boolean value). If `showDetails` were `0` instead of `false`
    (for whatever reason), the number `0` would be displayed on the screen. You should
    therefore ensure that the value acting as a condition yields `null` or `false`
    instead of arbitrary falsy values. You could, for example, force a conversion
    to a Boolean by adding `!!` (for example, `!!showDetails` ). That is not required
    if your condition value already holds `null` or `false` .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果你使用非布尔条件值（即`&&`前面的值持有非布尔值）与`&&`一起使用，可能会导致意外结果。如果`showDetails`是`0`而不是`false`（无论什么原因），屏幕上会显示数字`0`。因此，你应该确保作为条件的值产生`null`或`false`而不是任意假值。例如，你可以通过添加`!!`（例如，`!!showDetails`）强制转换为布尔值。如果你的条件值已经持有`null`或`false`，则不需要这样做。
- en: Get Creative!
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发挥创意！
- en: At this point, you have learned about three different ways of defining and outputting
    content conditionally (regular `if` statements, ternary expressions, and using
    the `&&` operator). However, the most important point is that React code is ultimately
    just regular JavaScript code. Hence, any approach that selects values conditionally
    will work.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了三种不同的定义和有条件输出内容的方法（常规`if`语句、三元表达式和使用`&&`运算符）。然而，最重要的观点是React代码最终只是常规JavaScript代码。因此，任何选择条件值的方案都将有效。
- en: 'If it makes sense in your specific use case and React app, you could also have
    a component that selects and outputs content conditionally like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在你的特定用例和React应用中合理，你也可以有一个组件，它像这样有条件地选择和输出内容：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This component outputs either `'de-DE'` , `'en-US'` , or `'` `en-GB'` based
    on the value of the `country` prop. This result is achieved by using JavaScript’s
    dynamic property selection syntax. Instead of selecting a specific property via
    the dot notation (such as `person.name` ), you can select property values via
    the bracket notation. With that notation, you can either pass a specific property
    name ( `languages['de-DE']` ) or an expression that yields a property name ( `languages[country]`
    ).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件根据`country`属性的值输出`'de-DE'`、`'en-US'`或`'en-GB'`。这个结果是通过使用JavaScript的动态属性选择语法实现的。你不需要通过点符号选择特定的属性（例如`person.name`），而是可以通过括号符号选择属性值。使用这种符号，你可以传递一个特定的属性名（`languages['de-DE']`）或者一个产生属性名的表达式（`languages[country]`）。
- en: Selecting property values dynamically like this is another common pattern for
    picking values from a map of values. It is therefore an alternative to specifying
    multiple `if` statements or ternary expressions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式动态选择属性值是选择值从值映射中的另一种常见模式。因此，它是指定多个`if`语句或三元表达式的替代方案。
- en: Also, in general, you can use any approach that works in standard JavaScript—because
    React is, after all, just standard JavaScript at its core.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常你可以使用任何在标准JavaScript中有效的方法——因为毕竟React在其核心上只是标准JavaScript。
- en: Which Approach is Best?
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哪种方法最好？
- en: Various ways of setting and outputting content conditionally have been discussed,
    but which approach is best?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 已经讨论了各种设置和有条件输出内容的方法，但哪种方法最好？
- en: That really is up to you (and, if applicable, your team). The most important
    advantages and disadvantages have been highlighted, but ultimately, it is your
    decision. If you prefer ternary expressions, there’s nothing wrong with choosing
    them over the logical `&&` operator, for example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全取决于你（如果适用，还有你的团队）。最重要的优缺点已经突出显示，但最终，这是你的决定。如果你更喜欢三元表达式，选择它们而不是逻辑`&&`运算符也没有什么不妥。
- en: It will also depend on the exact problem you are trying to solve. If you have
    a map of values (such as a list of countries and their country language codes),
    going for dynamic property selection instead of multiple `if` statements might
    be preferable. On the other hand, if you have a single `true` / `false` condition
    (such as `age > 18` ), using a standard `if` statement or the logical `&&` operator
    might be best.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将取决于你试图解决的特定问题。如果你有一个值的映射（例如国家列表及其国家语言代码），选择动态属性选择而不是多个`if`语句可能更可取。另一方面，如果你有一个单一的`true`/`false`条件（例如`age
    > 18`），使用标准的`if`语句或逻辑`&&`运算符可能最好。
- en: Setting Element Tags Conditionally
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有条件地设置元素标签
- en: Outputting content conditionally is a very common scenario. But sometimes, you
    will also want to choose the type of HTML tag that will be outputted conditionally.
    Typically, this will be the case when you build components whose main task is
    to wrap and enhance built-in components.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有条件地输出内容是一个非常常见的场景。但有时，你也会想要选择将要输出的HTML标签的类型。通常情况下，这会在你构建主要任务是对内置组件进行包装和增强的组件时发生。
- en: 'Here’s an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `Button` component checks whether the `isButton` prop value is truthy and,
    if that is the case, returns a `<button>` element. The `config` prop is expected
    to be a JavaScript object, and the standard JavaScript spread operator ( `...`
    ) is used to then add all key-value pairs of the `config` object as props to the
    `<button>` element. If `isButton` is not truthy (maybe because no value was provided
    for `isButton` , or because the value is `false` ), the `else` condition becomes
    active. Instead of a `<button>` element, an `<a>` element is returned.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Button`组件检查`isButton`属性值是否为真值，如果是这样，就返回一个`<button>`元素。`config`属性预期是一个JavaScript对象，并且使用标准的JavaScript扩展运算符（`...`）将`config`对象的所有键值对作为属性添加到`<button>`元素。如果`isButton`不是真值（可能是因为没有为`isButton`提供值，或者值是`false`），则`else`条件变为活动状态。而不是`<button>`元素，返回一个`<a>`元素。
- en: '**Note**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Using the spread operator ( `...` ) to translate an object’s properties (key-value
    pairs) into component props is another common React pattern (and was introduced
    in *Chapter 3* , *Components and Props* ). The spread operator is not a React-specific
    operator but using it for this special purpose *is* .
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展运算符（`...`）将对象的属性（键值对）转换为组件属性是另一个常见的React模式（并在*第3章*，*组件和属性*中介绍）。扩展运算符不是一个React特定的运算符，但用于这个特殊目的*是*。
- en: 'When spreading an object such as `{link: ''https://some-url.com'', isButton:
    false}` onto an `<a>` element (via `<a {...obj}>` ), the result would be the same
    as if all props had been set individually (that is, `<a link="https://some-url.com"
    isButton={false}>` ).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '当将类似于`{link: ''https://some-url.com'', isButton: false}`的对象扩展到`<a>`元素上（通过`<a
    {...obj}>`），结果将与所有属性单独设置时相同（即`<a link="https://some-url.com" isButton={false}>`）。'
- en: This pattern is particularly popular in situations where you build custom *wrapper
    components* that wrap a common core component (e.g., `<button>` , `<input>` ,
    or `<a>` ) to add certain styles or behaviors, while still allowing the component
    to be used in the same way as the built-in component (that is, you can set all
    the default props).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在构建自定义*包装组件*的情况下特别受欢迎，这些组件包装一个常见的核心组件（例如`<button>`、`<input>`或`<a>`）以添加某些样式或行为，同时仍然允许组件以与内置组件相同的方式使用（即，你可以设置所有默认属性）。
- en: The `Button` component from the preceding example returns two totally different
    JSX elements, depending on the `isButton` prop value. This is a great way of checking
    a condition and returning different content (that is, conditional content).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上一示例中的`Button`组件根据`isButton`属性值的差异返回两个完全不同的JSX元素。这是一种检查条件并返回不同内容（即条件内容）的好方法。
- en: 'However, by using a special React behavior, this component could be written
    with even less code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过使用特殊的React行为，这个组件可以用更少的代码编写：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The special behavior is that tag names can be stored (as string values) in variables
    or constants, and that those variables or constants can then be used like JSX
    elements in JSX code (as long as the variable or constant name starts with an
    uppercase character, like all your custom components).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊行为在于可以将标签名（作为字符串值）存储在变量或常量中，然后这些变量或常量可以在JSX代码中用作JSX元素（只要变量或常量的名称以大写字母开头，就像所有你的自定义组件一样）。
- en: 'The `Tag` constant in the preceding example stores either the `''button''`
    or `''a''` string. Since it starts with an uppercase character ( `Tag` , instead
    of `tag` ), it can then be used like a custom component inside of JSX code snippets.
    React accepts this as a component, even though it isn’t a component function.
    This is because a standard HTML element tag name is stored, so React can render
    the appropriate built-in component. The same pattern could also be used with custom
    components. Instead of storing string values, you would store pointers to your
    custom component functions through the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上一示例中的`Tag`常量存储的是`'button'`或`'a'`字符串。由于它以大写字母开头（`Tag`，而不是`tag`），因此它可以在JSX代码片段中用作自定义组件。React将其接受为一个组件，即使它不是一个组件函数。这是因为存储了一个标准的HTML元素标签名，所以React可以渲染相应的内置组件。相同的模式也可以用于自定义组件。不是存储字符串值，而是通过以下方式存储指向你的自定义组件函数的指针：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is another useful pattern that can help save code and hence leads to leaner
    components.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常有用的模式，可以帮助节省代码，从而使得组件更加精简。
- en: Outputting List Data
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出列表数据
- en: Besides outputting conditional data, you will often work with list data that
    should be outputted on a page. As mentioned earlier in this chapter, some examples
    are lists of products, transactions, and navigation items.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输出条件数据外，你还会经常处理需要在页面上输出的列表数据。如本章前面所述，一些例子包括产品列表、交易和导航项。
- en: 'Typically, in React apps, such list data is received as an array of values.
    For example, a component might receive an array of products via props (passed
    into the component from inside another component that might be getting that data
    from some backend API):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在React应用中，此类列表数据以值的数组形式接收。例如，一个组件可能通过props（从可能从后端API获取数据的另一个组件内部传递到组件中）接收产品数组：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, the products array could look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，产品数组可能看起来像这样：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This data can’t be outputted like this, though. Instead, the goal is typically
    to translate it into a list of JSX elements that fits. For example, the desired
    result could be the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据不能这样输出。相反，通常的目标是将它转换成适合的JSX元素列表。例如，期望的结果可能是以下这样：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How can this transformation be achieved?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现这种转换？
- en: 'Again, it’s a good idea to ignore React and find a way to transform list data
    with standard JavaScript. One possible way to achieve this would be to use a `for…of`
    loop, as shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，忽略React并找到一种使用标准JavaScript转换列表数据的方法是个好主意。实现这一目标的一种可能方式是使用`for...of`循环，如下所示：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the list of product objects ( `products` ) is transformed into
    a list of product titles (that is, a list of string values). This is achieved
    by looping through all product items in `products` and extracting only the `title`
    property from each product. This `title` property value is then pushed into the
    new `transformedProducts` array.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，产品对象列表（`products`）被转换成产品标题列表（即字符串值的列表）。这是通过遍历`products`中的所有产品项并从每个产品中提取`title`属性来实现的。然后，这个`title`属性值被推入新的`transformedProducts`数组中。
- en: 'A similar approach can be used to transform the list of objects into a list
    of JSX elements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似的方法将对象列表转换成JSX元素列表：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first time you see code like this, it might look a bit strange. But keep
    in mind that JSX code can be used anywhere where regular JavaScript values (that
    is, numbers, strings, objects, and so on) can be used. Therefore, you can also
    `push` a JSX value onto an array of values. Since it’s JSX code, you can also
    output content dynamically in those JSX elements (such as `<h2>{product.title}</h2>`
    ).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次看到这样的代码时，可能会觉得有点奇怪。但请记住，JSX 代码可以在任何可以使用常规 JavaScript 值（即数字、字符串、对象等）的地方使用。因此，你也可以将
    JSX 值 `push` 到一个值数组中。由于它是 JSX 代码，你还可以在那些 JSX 元素中动态输出内容（例如 `<h2>{product.title}</h2>`）。
- en: This code is valid and is an important first step toward outputting list data.
    But it is only the first step, since the current data was transformed but still
    isn’t returned by a component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是有效的，并且是输出列表数据的重要第一步。但这是第一步，因为当前的数据已经进行了转换，但还没有通过组件返回。
- en: How can such an array of JSX elements be returned then?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这样的 JSX 元素数组是如何返回的呢？
- en: The answer is that it can be returned without any special tricks or code. JSX
    actually accepts array values as dynamically outputted values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是它可以不使用任何特殊技巧或代码而返回。实际上，JSX 接受数组值作为动态输出的值。
- en: 'You can output the `productElements` array like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样输出 `productElements` 数组：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When inserting an array of JSX elements into JSX code, all JSX elements inside
    that array are outputted next to each other. So, the following two snippets would
    produce the same output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 JSX 元素数组插入到 JSX 代码中时，该数组内的所有 JSX 元素都会相邻输出。因此，以下两个代码片段会产生相同的输出：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this in mind, the `ProductsList` component could be written like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，`ProductsList` 组件可以写成这样：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is one possible approach for outputting list data. As explained earlier
    in this chapter, it’s all about using standard JavaScript features and combining
    those features with JSX.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出列表数据的一种可能方法。正如本章前面所解释的，这完全关于使用标准的 JavaScript 功能，并将这些功能与 JSX 结合起来。
- en: However, it’s not necessarily the most common way of outputting list data in
    React apps. In most projects, you’ll encounter a different solution.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不一定是 React 应用中输出列表数据最常见的方式。在大多数项目中，你会遇到不同的解决方案。
- en: Mapping List Data
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射列表数据
- en: Outputting list data with `for` loops works, as you can see in the preceding
    examples. However, just as with `if` statements and ternary expressions, you can
    replace `for` loops with an alternative syntax to write less code and improve
    component readability.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环输出列表数据是可行的，正如前面示例中所见。然而，就像 `if` 语句和三元表达式一样，你可以用替代语法替换 `for` 循环，以编写更少的代码并提高组件的可读性。
- en: 'JavaScript offers a built-in array method that can be used to transform array
    items: the `map()` method. `map()` is a default method that can be called on any
    JavaScript array. It accepts a function as a parameter and executes that function
    for every array item. The return value of this function should be the transformed
    value. `map()` then combines all these returned, transformed values into a new
    array that is then returned by `map()` .'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了一个内置的数组方法，可以用来转换数组项：`map()` 方法。`map()` 是一个默认方法，可以在任何 JavaScript
    数组上调用。它接受一个函数作为参数，并为每个数组项执行该函数。该函数的返回值应该是转换后的值。`map()` 然后将所有这些返回的转换值组合成一个新的数组，然后由
    `map()` 返回这个新数组。
- en: 'You could use `map()` like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用 `map()`：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, `map()` is used to transform the array of user objects into
    an array of usernames (that is, an array of string values).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`map()` 被用来将用户对象数组转换成用户名数组（即字符串值数组）。
- en: The `map()` method is often able to produce the same result as that of a `for`
    loop but with less code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 方法通常可以用更少的代码产生与 `for` 循环相同的结果。'
- en: 'Therefore, `map()` can also be used to generate an array of JSX elements and
    the `ProductsList` component from before could be rewritten like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`map()` 也可以用来生成一个 JSX 元素数组，以及之前提到的 `ProductsList` 组件，可以重写如下：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is already shorter than the earlier `for` loop example. However, just
    as with ternary expressions, the code can be shortened even more by moving the
    logic directly into the JSX code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经比之前的 `for` 循环示例更短了。然而，就像三元表达式一样，代码可以通过将逻辑直接移动到 JSX 代码中来进一步缩短：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Depending on the complexity of the transformation (that is, the complexity of
    the code executed inside the inner function, which is passed to the `map()` method),
    for readability reasons, you might want to consider not using this *inline* approach
    (such as when mapping array elements to some complex JSX structure or when performing
    extra calculations as part of the mapping process). Ultimately, this comes down
    to personal preference and judgment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 根据转换的复杂性（即传递给 `map()` 方法的内部函数中执行的代码的复杂性），出于可读性的原因，你可能想要考虑不使用这种 *内联* 方法（例如，当将数组元素映射到某些复杂的JSX结构或在进行映射过程中的额外计算时）。最终，这取决于个人偏好和判断。
- en: Because it’s very concise, using the `map()` method (either with the help of
    an extra variable or constant, or directly *inline* in the JSX code) is the de
    facto standard approach for outputting list data in React apps and JSX in general.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它非常简洁，使用 `map()` 方法（无论是通过额外的变量或常量，还是直接在JSX代码中 *内联*）是React应用和JSX中输出列表数据的既定标准方法。
- en: Updating Lists
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新列表
- en: Imagine you have a list of data mapped to JSX elements and a new list item is
    added at some point. Or, consider a scenario in which you have a list wherein
    two list items swap places (that is, the list is reordered). How can such updates
    be reflected in the DOM?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个数据列表映射到JSX元素，并在某个时刻添加了一个新的列表项。或者，考虑一个场景，其中你有一个列表，其中两个列表项交换了位置（即列表被重新排序）。如何将这些更新反映在DOM中？
- en: The good news is that React will take care of that for you if the update is
    performed in a stateful way (that is, by using React’s state concept, as explained
    in *Chapter 4* , *Working with Events and State* ).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果你以有状态的方式（即使用React的状态概念，如第4章中解释的 *工作与事件和状态*）执行更新，React会为你处理这些。
- en: However, there are a couple of important aspects to updating (stateful) lists
    you should be aware of.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更新（有状态的）列表时，有几个重要的方面你应该注意。
- en: 'Here’s a simple example that would **not** work as intended:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，它**不会**按预期工作：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Initially, two to-do items would be displayed on the screen ( `<li>Learn React</li>`
    and `<li>Recommend this book</li>` ). But once the button is clicked and `handleAddTodo`
    is executed, the expected result of another to-do item being displayed will not
    materialize.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，屏幕上会显示两个待办事项（`<li>学习React</li>` 和 `<li>推荐这本书</li>`）。但是一旦点击按钮并执行 `handleAddTodo`，预期显示另一个待办事项的结果将不会实现。
- en: This is because executing `todos.push('A new todo')` will update the `todos`
    array, but React won’t notice it. Keep in mind that you must only update the state
    via the state updating function returned by `useState()` ; otherwise, React will
    not re-evaluate the component function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为执行 `todos.push('一个新的待办事项')` 会更新 `todos` 数组，但React不会注意到这一点。请记住，你必须只通过 `useState()`
    返回的状态更新函数来更新状态；否则，React不会重新评估组件函数。
- en: 'So, how about this code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个代码怎么样：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is also incorrect because the state updating function ( `setTodos` , in
    this case) should receive the new state (that is, the state that should be set)
    as an argument. However, the `push()` method doesn’t return the updated array.
    Instead, it mutates the existing array in place. Even if `push()` were to return
    the updated array, it would still be wrong to use the preceding code, because
    the data would be changed (mutated) behind the scenes before the state updating
    function would be executed. Since arrays are objects, and therefore reference
    data types, technically, data would be changed before informing React about that
    change. Following the React best practices, this should be avoided.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是不正确的，因为状态更新函数（在这个例子中是 `setTodos`）应该接收新的状态（即应该设置的状态）作为参数。然而，`push()` 方法不会返回更新后的数组。相反，它会原地修改现有的数组。即使
    `push()` 会返回更新后的数组，使用前面的代码仍然是不正确的，因为状态更新函数执行之前，数据（在幕后）已经被改变（修改）。由于数组是对象，因此是引用数据类型，技术上，数据会在通知React之前被改变。遵循React的最佳实践，应该避免这种情况。
- en: Therefore, when updating an array (or, as a side note, an object in general),
    you should perform this update in an **immutable** way (i.e., without changing
    the original array or object). Instead, a new array or object should be created.
    This new array can be based on the old array and contain all the old data, as
    well as any new or updated data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在更新数组（或者，作为一个旁注，一般对象）时，你应该以**不可变**的方式（即不改变原始数组或对象）进行更新。相反，应该创建一个新的数组或对象。这个新数组可以基于旧数组，并包含所有旧数据，以及任何新的或更新的数据。
- en: 'Therefore, the `todos` array should be updated like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`todos`数组应该这样更新：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By using `concat()` or a new array, combined with the spread operator, a brand-new
    array is provided to the state updating function. Note also that a function is
    passed to the state updating function since the new state depends on the previous
    state.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`concat()`或新数组，结合扩展运算符，可以为状态更新函数提供一个全新的数组。注意，由于新状态依赖于前一个状态，因此将函数传递给状态更新函数。
- en: When updating an array (or any object) state value like this, React is able
    to pick up those changes. Therefore, React will re-evaluate the component function
    and apply any required changes to the DOM.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新数组（或任何对象）状态值时，React能够检测到这些变化。因此，React将重新评估组件函数，并将任何必要的更改应用到DOM上。
- en: '**Note**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Immutability is not a React-specific concept, but it’s a key one in React apps
    nonetheless. When working with state and reference values (that is, objects and
    arrays), immutability is extremely important to ensure that React is able to pick
    up changes and no “invisible” (that is, not recognized by React) state changes
    are performed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性不是一个React特有的概念，但在React应用中它仍然是一个关键概念。当与状态和引用值（即对象和数组）一起工作时，不变性对于确保React能够检测到变化以及没有“不可见”的（即不被React识别）状态变化执行至关重要。
- en: There are different ways of updating objects and arrays immutably, but a popular
    approach is to create new objects or arrays and then use the spread operator (
    `...` ) to merge existing data into those new arrays or objects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更新对象和数组的不变性的方法有很多，但一种流行的方法是创建新的对象或数组，然后使用扩展运算符（`...`）将现有数据合并到这些新的数组或对象中。
- en: A Problem with List Items
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表项的问题
- en: 'If you’re following along with your own code, and you output list data as described
    in the previous sections, you might’ve noticed that React actually shows a warning
    in the browser developer tools console, as shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随自己的代码，并且按照前几节所述输出列表数据，你可能已经注意到React实际上在浏览器开发者工具控制台中显示了一个警告，如下面的截图所示：
- en: '![img](img/B31339_05_04.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_05_04.png)'
- en: 'Figure 5.4: React sometimes generates a warning regarding missing unique keys'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：React有时会生成关于缺少唯一键的警告
- en: React is complaining about missing keys.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: React正在抱怨缺少键。
- en: To understand this warning and the idea behind keys, it’s helpful to explore
    a specific use case and a potential problem with that scenario. Assume that you
    have a React component that is responsible for displaying a list of items—maybe
    a list of to-do items. In addition, assume that those list items can be reordered
    and that the list can be edited in other ways (for example, new items can be added,
    existing items can be updated or deleted, and so on). In other words, the list
    is not static.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个警告和键背后的理念，探索一个特定的用例和该场景的潜在问题是有帮助的。假设你有一个负责显示项目列表的React组件——可能是一个待办事项列表。此外，假设这些列表项可以重新排序，并且列表可以通过其他方式编辑（例如，可以添加新项，更新或删除现有项等）。换句话说，列表不是静态的。
- en: 'Consider this example user interface, in which a new item is added to a list
    of to-do items:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个示例用户界面，其中向待办事项列表中添加了一个新项：
- en: '![img](img/B31339_05_05.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_05_05.png)'
- en: 'Figure 5.5: A list gets updated by inserting a new item at the top'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：通过在顶部插入新项来更新列表
- en: In the preceding figure, you can see the initially rendered list ( *1* ), which
    is then updated after a user enters and submits a new to-do value ( *2* ). A new
    to-do item is added to the top of the list (that is, as the first item of the
    list) ( *3* ).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到最初渲染的列表（*1*），然后在用户输入并提交新的待办事项值后更新（*2*）。一个新的待办事项被添加到列表的顶部（即列表的第一个项目）(*3*)。
- en: '**Note**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The example source code for this demo app can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/examples/02-keys](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/examples/02-keys)
    .
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示应用的示例源代码可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/examples/02-keys](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/examples/02-keys)找到。
- en: If you work on this app and open the browser developer tools (and then the JavaScript
    console), you will see the “missing keys” warning that has been mentioned before.
    This app also helps with understanding where this warning is coming from.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个应用上工作并打开浏览器开发者工具（然后是JavaScript控制台），你会看到之前提到的“缺少键”警告。这个应用也有助于理解这个警告的来源。
- en: 'In the Chrome DevTools, navigate to the **Elements** tab and select one of
    the to-do items or the empty to-do list (that is, the `<ul>` element). Once you
    add a new to-do item, any DOM elements that were inserted or updated are highlighted
    by Chrome in the **Elements** tab (by flashing briefly). Refer to the following
    screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome DevTools中，导航到**元素**选项卡并选择一个待办项或空待办列表（即`<ul>`元素）。一旦添加一个新的待办项，任何插入或更新的DOM元素都会在**元素**选项卡中由Chrome突出显示（通过短暂闪烁）。参考以下截图：
- en: '![img](img/B31339_05_06.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_05_06.png)'
- en: 'Figure 5.6: Updated DOM items are highlighted in the Chrome DevTools'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：更新的DOM项在Chrome DevTools中被突出显示
- en: The interesting part is that not only the newly added to-do element (that is,
    the newly inserted `<li>` element) is flashing. Instead, **all** existing `<li>`
    elements, which reflect existing to-do items that were not changed, are highlighted
    by Chrome. This implies that all these other `<li>` elements were also updated
    in the DOM—even though there was no need for that update. The items existed before,
    and their content (the to-do text) didn’t change.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，不仅新添加的待办元素（即新插入的`<li>`元素）会闪烁。相反，**所有**现有的`<li>`元素，即使它们反映的待办项没有变化，也会被Chrome突出显示。这表明所有这些其他的`<li>`元素在DOM中也被更新了——尽管没有必要进行这种更新。这些项之前就存在，它们的内容（待办文本）并没有改变。
- en: For some reason, React seems to destroy the existing DOM nodes (that is, the
    existing `<li>` items), just to then recreate them immediately. This happens for
    every new to-do item that is added to the list. As you might imagine, this is
    not very efficient and can cause performance problems for more complex apps that
    might be rendering dozens or hundreds of items across multiple lists.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，React似乎会销毁现有的DOM节点（即现有的`<li>`项），然后立即重新创建它们。这发生在列表中添加的每个新待办项上。正如你可能想象的那样，这并不非常高效，可能会为渲染多个列表中数十或数百项的更复杂的应用程序造成性能问题。
- en: 'This happens because React has no way of knowing that only one DOM node should
    be inserted. It cannot tell that all other DOM nodes should stay untouched because
    React only received a brand-new state value: a new array, filled with new JavaScript
    objects. Even if the content of those objects didn’t change, they are technically
    still new objects (new values in memory).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为React无法知道只有一个DOM节点应该被插入。它无法判断所有其他DOM节点是否应该保持不变，因为React只收到了一个新的状态值：一个新的数组，其中填充了新的JavaScript对象。即使这些对象的内容没有改变，它们在技术上仍然是新的对象（内存中的新值）。
- en: As the developer, you know how your app works and that the content of the to-do
    array didn’t actually change that much. But React doesn’t know that. Therefore,
    React determines that all existing list items ( `<li>` items) must be discarded
    and replaced by new items that reflect the new data that was provided as part
    of the state update. That is why **all** list-related DOM nodes are updated (that
    is, destroyed and recreated) for every state update.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你知道你的应用是如何工作的，以及待办数组的内容实际上并没有发生太多变化。但是React并不知道这一点。因此，React确定所有现有的列表项（`<li>`元素）都必须被丢弃，并由反映新提供的数据（作为状态更新的部分）的新项所替换。这就是为什么每次状态更新时，所有与列表相关的DOM节点都会被更新（即销毁并重新创建）。
- en: Keys to the Rescue!
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键的拯救！
- en: The problem outlined previously is an extremely common one. Most list updates
    are incremental updates, not bulk changes. But React can’t tell whether that is
    the case for your use case and your list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之前概述的问题是一个非常常见的问题。大多数列表更新都是增量更新，而不是批量更改。但是React无法判断你的用例和你的列表是否属于这种情况。
- en: That’s why React uses the concept of **keys** when working with list data and
    rendering list items. Keys are simply unique identifier values that can (and should)
    be attached to JSX elements when rendering list data. Keys help React identify
    elements that were rendered before and didn’t change. By allowing the unique identification
    of all list elements, keys also help React to move (list item) DOM elements around
    efficiently.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么React在处理列表数据和渲染列表项时使用**键**的概念。键只是可以（并且应该）在渲染列表数据时附加到JSX元素上的唯一标识符值。键帮助React识别之前渲染且未更改的元素。通过允许对所有列表元素进行唯一标识，键还帮助React有效地移动（列表项）DOM元素。
- en: 'Keys are added to JSX elements via the special built-in `key` prop that is
    accepted by every component:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过特殊的内置`key`属性将键添加到JSX元素中，该属性被每个组件接受：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This special prop can be added to all components, be they built-in or custom.
    You don’t need to accept or handle the `key` prop in any way on your custom components;
    React will do that for you automatically.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的属性可以添加到所有组件中，无论是内置的还是自定义的。你不需要在你的自定义组件中以任何方式接受或处理 `key` 属性；React 会自动为你处理。
- en: The `key` prop requires a value that is unique for every list item. No two list
    items should have the same key. In addition, good keys are directly attached to
    the underlying data that makes up the list item. Therefore, list item indexes
    are poor keys because the index isn’t attached to the list item data. If you reorder
    items in a list, the indexes stay the same (an array always starts with index
    `0` , followed by `1` , and so on) but the data is changed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`key` 属性需要一个对每个列表项都是唯一的值。没有任何两个列表项应该有相同的键。此外，良好的键直接附加到构成列表项的底层数据。因此，列表项索引是较差的键，因为索引没有附加到列表项数据。如果你在列表中重新排列项目，索引将保持不变（数组始终从索引
    `0` 开始，然后是 `1`，依此类推），但数据会发生变化。'
- en: 'Consider the following example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, `'Sports'` has the index `0` in the `hobbies` array. In the
    `reversed` array, its index would be `1` (because it’s the second item now). In
    this case, if the index were used as a key, the data would not be attached to
    it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`'Sports'` 在 `hobbies` 数组中的索引是 `0`。在 `reversed` 数组中，它的索引将是 `1`（因为它现在是第二个项目）。在这种情况下，如果使用索引作为键，数据将不会附加到它上。
- en: Good keys are unique `id` values, such that every `id` belongs to exactly one
    value. If that value moves or is removed, its `id` should move or disappear with
    that value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的键是唯一的 `id` 值，每个 `id` 只对应一个值。如果该值移动或被删除，其 `id` 应该随之移动或消失。
- en: Finding good `id` values typically isn’t a huge problem since most list data
    is fetched from databases anyway. No matter whether you’re dealing with products,
    orders, users, or shopping cart items, it’s all data that would typically be stored
    in a database. This kind of data already has unique `id` values since you always
    have some kind of unique identification criteria when storing data in databases.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通常找到良好的 `id` 值并不是一个大问题，因为大多数列表数据都是从数据库中获取的。无论你是在处理产品、订单、用户还是购物车项，这些数据通常都会存储在数据库中。这种数据已经具有唯一的
    `id` 值，因为你在将数据存储在数据库中时始终有一些唯一的识别标准。
- en: 'Sometimes, even the values themselves can be used as keys. Consider the following
    example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，值本身也可以用作键。考虑以下示例：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Hobbies are `string` values, and there is no unique `id` value attached to
    individual hobbies. Every hobby is a primitive value (a `string` ). However, in
    cases like this, you typically won’t have duplicate values as it doesn’t make
    sense for a hobby to be listed more than once in an array like this. Therefore,
    the values themselves qualify as good keys:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 爱好是 `string` 类型的值，并且没有唯一的 `id` 值附加到个别爱好上。每个爱好都是一个原始值（一个 `string`）。然而，在这种情况下，你通常不会有重复的值，因为在这个数组中列出爱好一次以上是没有意义的。因此，这些值本身就符合良好的键的条件：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In cases where you can’t use the values themselves and there is no other possible
    key value, you can generate unique `id` values directly in your React app code.
    As a last resort, you can also fall back to using indexes; but be aware that this
    can lead to unexpected bugs and side effects if you reorder list items.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法使用值本身且没有其他可能的键值的情况下，你可以在你的 React 应用代码中直接生成唯一的 `id` 值。作为最后的手段，你也可以回退到使用索引；但请注意，如果你重新排列列表项，这可能会导致意外的错误和副作用。
- en: With keys added to list item elements, React is able to identify all items correctly.
    When the component state changes, it can identify JSX elements that were rendered
    before already. Those elements are therefore not destroyed or recreated anymore.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表项元素中添加键后，React 能够正确地识别所有项目。当组件状态发生变化时，它能够识别之前已经渲染的 JSX 元素。因此，这些元素不再被销毁或重新创建。
- en: 'You can confirm this by again opening the browser DevTools to check which DOM
    elements are updated upon changes to the underlying list data:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过再次打开浏览器 DevTools 来确认，检查在底层列表数据发生变化时哪些 DOM 元素被更新：
- en: '![img](img/B31339_05_07.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_05_07.png)'
- en: 'Figure 5.7: From multiple list items, only one DOM element gets updated'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：从多个列表项中，只有一个是 DOM 元素被更新
- en: After adding keys, when updating the list state, only the new DOM item is highlighted
    in the Chrome DevTools. The other items are (correctly) ignored by React.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 添加键后，在更新列表状态时，只有新的 DOM 项在 Chrome DevTools 中被突出显示。其他项被 React （正确地）忽略。
- en: Summary and Key Takeaways
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: Like any other JavaScript value, JSX elements can be set and changed dynamically,
    based on different conditions.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与任何其他JavaScript值一样，JSX元素可以根据不同的条件动态设置和更改。
- en: Content can be set conditionally via `if` statements, ternary expressions, the
    logical “and” operator ( `&&` ), or in any other way that works in JavaScript.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容可以通过`if`语句、三元表达式、逻辑“与”运算符（`&&`）或任何在JavaScript中可行的其他方式来设置条件。
- en: There are multiple ways to handle conditional content—any approach that would
    work in vanilla JavaScript can also be used in React apps.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理条件内容有多种方法——任何在纯JavaScript中可行的方案也可以在React应用中使用。
- en: Arrays with JSX elements can be inserted into JSX code and will lead to the
    array elements being outputted as sibling DOM elements.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX元素数组可以被插入到JSX代码中，这将导致数组元素作为同级DOM元素被输出。
- en: List data can be converted into JSX element arrays via `for` loops, the `map()`
    method, or any other JavaScript approach that leads to a similar conversion.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表数据可以通过`for`循环、`map()`方法或任何其他导致类似转换的JavaScript方法转换为JSX元素数组。
- en: Using the `map()` method is the most common way of converting list data to JSX
    element lists.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`map()`方法是将列表数据转换为JSX元素列表的最常见方式。
- en: Keys (via the `key` prop) should be added to the list JSX elements to help React
    update the DOM efficiently.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （通过`key`属性）应该将键添加到列表JSX元素中，以帮助React高效地更新DOM。
- en: What’s Next?
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: With conditional content and lists, you now have all the key tools needed to
    build both simple and more complex user interfaces with React. You can hide and
    show elements or groups of elements as needed, and you can dynamically render
    and update lists of elements to output lists of products, orders, or users.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过条件内容和列表，你现在拥有了构建简单和更复杂用户界面所需的所有关键工具，使用React你可以根据需要隐藏和显示元素或元素组，并且可以动态渲染和更新元素列表以输出产品列表、订单或用户列表。
- en: Of course, that’s not all that’s needed to build realistic user interfaces.
    Adding logic for changing content dynamically is one thing, but most web apps
    also need CSS styling that should be applied to various DOM elements. This book
    is not about CSS, but the next chapter will still explore how React apps can be
    styled. Especially when it comes to setting and changing styles dynamically or
    scoping styles to specific components, there are various React-specific concepts
    that should be familiar to every React developer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是构建真实用户界面所需的所有内容。添加动态更改内容的逻辑是一回事，但大多数Web应用还需要应用于各种DOM元素的CSS样式。本书不涉及CSS，但下一章仍将探讨React应用如何被样式化。特别是当涉及到动态设置和更改样式或将样式范围限定到特定组件时，有各种React特定的概念，每个React开发者都应该熟悉。
- en: Test Your Knowledge!
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge about the concepts covered in this chapter by answering
    the following questions. You can then compare your answers to examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/05-lists-conditional-code/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/05-lists-conditional-code/exercises/questions-answers.md)
    :'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后你可以将你的答案与可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/05-lists-conditional-code/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/05-lists-conditional-code/exercises/questions-answers.md)找到的示例进行比较。：
- en: What is “conditional content”?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “条件内容”是什么？
- en: Name at least two different ways of rendering JSX elements conditionally.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少列举两种渲染JSX元素的条件方式。
- en: Which elegant approach can be used to define element tags conditionally?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种优雅的方法可以用来条件性地定义元素标签？
- en: What’s a potential downside of using only ternary expressions (for conditional
    content)?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用三元表达式（对于条件内容）的潜在缺点是什么？
- en: How can lists of data be rendered as JSX elements?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将数据列表渲染为JSX元素？
- en: Why should keys be added to rendered list items?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该在渲染的列表项中添加键？
- en: Give one example each for a good and a bad key.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别给出一个良好和不良键的示例。
- en: Apply What You Learned
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用你所学的知识
- en: You are now able to use your React knowledge to change dynamic user interfaces
    in a variety of ways. Besides being able to change displayed text values and numbers,
    you can now also hide or show entire elements (or chunks of elements) and display
    lists of data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在能够使用你的React知识以各种方式改变动态用户界面。除了能够更改显示的文本值和数字之外，你现在也可以隐藏或显示整个元素（或元素块）并显示数据列表。
- en: In the following sections, you will find two activities that allow you to apply
    your newly gained knowledge (combined with the knowledge gained in the other book
    chapters).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，你将找到两个活动，这些活动允许你应用你新获得的知识（结合在其他书籍章节中获得的知识）。
- en: 'Activity 5.1: Showing a Conditional Error Message'
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.1：显示条件错误消息
- en: In this activity, you’ll build a basic form that allows users to enter their
    email address. Upon form submission, the user input should be validated and invalid
    email addresses (for simplicity, here email addresses that contain no `@` sign
    are being referred to) should lead to an error message being shown below the form.
    When invalid email addresses are made valid, potentially visible error messages
    should be removed again.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将构建一个基本表单，允许用户输入他们的电子邮件地址。在表单提交后，用户输入应该被验证，无效的电子邮件地址（为了简单起见，这里指的是不包含`@`符号的电子邮件地址）应该导致在表单下方显示错误消息。当无效的电子邮件地址变为有效时，可能可见的错误消息应该再次被移除。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Build a user interface that contains a form with a label, an input field (of
    the text type—to make entering incorrect email addresses easier for demo purposes),
    and a submit button that leads to the form being submitted.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个包含标签、输入字段（文本类型——为了演示目的，使输入错误的电子邮件地址更容易）和提交按钮的用户界面，该按钮会导致表单提交。
- en: Collect the entered email address and show an error message below the form if
    the email address contains no `@` sign.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集输入的电子邮件地址，如果电子邮件地址不包含`@`符号，则在表单下方显示错误消息。
- en: 'The final user interface should look and work as shown here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户界面应该看起来和工作方式如下所示：
- en: '![img](img/B31339_05_08.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_05_08.png)'
- en: 'Figure 5.8: The final user interface of this activity'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：此活动的最终用户界面
- en: '**Note**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Styling will, of course, differ. To get the same styling as shown in the screenshot,
    use my prepared starting project, which you can find here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1-start)
    .'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 样式当然会有所不同。要获得截图中所显示的相同样式，请使用我准备的起始项目，你可以在这里找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1-start)。
- en: Analyze the `index.css` file in that project to determine how to structure your
    JSX code to apply the styles.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 分析该项目的`index.css`文件，以确定如何结构化你的JSX代码以应用样式。
- en: '**Note**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find the full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1)
    .'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1)。
- en: 'Activity 5.2: Outputting a List of Products'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.2：输出产品列表
- en: In this activity, you will build a user interface where a list of (dummy) products
    is displayed on the screen. The interface should also contain a button that, when
    clicked, adds another new (dummy) item to the existing list of products.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将构建一个用户界面，其中在屏幕上显示产品列表（（虚拟）产品）。界面还应包含一个按钮，当点击时，将另一个新的（虚拟）项目添加到现有的产品列表中。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Add a list of dummy product objects (every object should have an ID, title,
    and price) to a React component and add code to output these product items as
    JSX elements.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一组虚拟产品对象（每个对象应具有ID、标题和价格）添加到React组件中，并添加代码以输出这些产品项作为JSX元素。
- en: Add a button to the user interface. When clicked, the button should add a new
    product object to the product data list. This should then cause the user interface
    to update and display an updated list of product elements.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户界面添加一个按钮。当按钮被点击时，应该向产品数据列表中添加一个新的产品对象。这应该导致用户界面更新并显示更新后的产品元素列表。
- en: 'The final user interface should look and work as shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户界面应该看起来和工作方式如下所示：
- en: '![img](img/B31339_05_09.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_05_09.png)'
- en: 'Figure 5.9: The final user interface of this activity'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：此活动的最终用户界面
- en: '**Note**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Styling will, of course, differ. To get the same styling as shown in the screenshot,
    use my prepared starting project, which you can find here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2-start)
    .'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，样式会有所不同。要获得与截图相同的样式，请使用我准备的起始项目，您可以在以下链接找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2-start)
    .
- en: Analyze the `index.css` file in that project to determine how to structure your
    JSX code to apply the styles.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 分析该项目中的`index.css`文件，以确定如何构建您的JSX代码以应用样式。
- en: '**Note**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find the full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2)
    .'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到完整的示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2)
    .
