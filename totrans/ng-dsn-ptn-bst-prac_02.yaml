- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A messed-up project is a bug’s nest waiting to spoil your user experience. In
    addition to quality, good organization of your project from the beginning will
    give your team productivity and, in the case of Angular, potential improvement
    in the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the function of Angular modules, the difference
    between these and JavaScript modules, and how to use them in the best way for
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about the single module app anti-pattern and how and why to avoid
    it. You will also use Angular modules to optimize the import of common components
    to your application using the `SharedModule` pattern. Finally, you will understand
    how to use lazy loading to optimize your application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the application with Angular modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first module: `AppModule`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoiding anti-pattern: single module app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optimizing the usage of common modules: the `SharedModule` pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Improving the size of your app: lazy loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to organize your Angular application
    into functional and optimized modules.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch2](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch2).
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the application with Angular modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basis for organizing the components of an application using the framework
    is the Angular modules, more recognized in the documentation and the community
    by the name **NgModules**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Angular module is a TypeScript class marked with the `@NgModule` decorator
    that contains metadata, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s detail each of these types of metadata in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This metadata contains an array of components, directives, and pipes that make
    up the module. These components must belong to only one module, otherwise, the
    Angular compiler will throw an error, as shown in *Figure 2**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.1 – Error message when declaring a component in more than one modu\uFEFF\
    le](img/B19562_02_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Error message when declaring a component in more than one module
  prefs: []
  type: TYPE_NORMAL
- en: providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this attribute, we can register the classes we want to inject using Angular’s
    dependency injector system, normally used for services (which will be detailed
    in [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163), *Angular Services and the*
    *Singleton Pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this metadata, we inform the modules that we want to import and use their
    components and services. For example, if we want to use Angular’s HTTP request
    services, we must declare the `HttpClientModule` module here.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that, here, we should not import components or services,
    only Ngmodules.
  prefs: []
  type: TYPE_NORMAL
- en: exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, all items in the `declarations` attribute are private. This means
    that if a module contains the `StateSelectorComponent` component and another module,
    for example, importing the module to use this component will cause the following
    error to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Error message when using a component not exported correctly](img/B19562_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Error message when using a component not exported correctly
  prefs: []
  type: TYPE_NORMAL
- en: To inform Angular that the component can be used, it is necessary to declare
    it in the `exports` metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `imports` metadata, here, you can declare components, pipes, directives,
    and other modules (as we’ll see in the *Optimizing the usage of common modules
    – the SharedModule* *pattern* section).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to declare a module, let’s study the module that is generated
    when creating an Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: The first module – AppModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modules in Angular are so important to the framework that when you start
    a project, it automatically creates a module called **AppModule**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module contains all the parameters we studied in the previous section
    (`declarations`, `providers`, `imports`, and `exports`), plus one additional parameter:
    `bootstrap`. This module contains the first component to be injected into the
    application’s `index.html` file and will be the root of your Angular application’s
    component tree.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering which `index.html` file and which tree this is.
  prefs: []
  type: TYPE_NORMAL
- en: As we described in [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017), *Starting
    Projects the Right Way*, Angular is a framework for `index.html` file is in fact
    the only *page* delivered by the web server to its user.
  prefs: []
  type: TYPE_NORMAL
- en: All interfaces rendered by the Angular engine (called `index.html` file and
    the first component is described in the `bootstrap` metadata. This rendering obeys
    a data structure of the logical tree type, and the root of this tree is this first
    component.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between Angular and JavaScript modules?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost all programming languages offer a way for their developers to organize
    functions, classes, and variables in one or more files, allowing greater maintainability
    and separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, sometime after its creation and several proposals, the concept
    of language modules was consolidated. The best way to explain this concept is
    to demonstrate it with an example. First, we create a `sum.mjs` file – the `sum`
    function that receives two numbers and returns their sum. The important thing
    here is that we use the `export` keyword to indicate that we want to use it in
    a scope outside of its source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `index.mjs` file, we will use the created function and, for that, we
    make the declaration in the first line of the file. Using the reserved word `import`,
    we indicate which function and which file it is from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why the `.mjs` extension is used. It’s because, in the
    example, we are using Node.js to execute, and this type of module – **ECMAScript
    modules** (**ESM**), as the official name of the Javascript language is ECMAScript
    – was introduced in version 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular, as well as all other SPA frameworks, uses JavaScript modules in its
    development, and we can notice in any Angular component or service that we export
    the classes and import using the ESM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we are importing the `Component` decorator from
    the `@angular/core` library and exporting the `HomeComponent` class to use in
    other parts of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Modules type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand and have reinforced the concept of modules in the Angular
    framework, let’s divide our application and make better use of this feature. There
    is no fixed rule for organizing the modules of an application, but the Angular
    team and the community suggest the separation of modules based on the grouping
    of functionalities with common characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this thought, we can have the following types of Angular modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Business domain modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business domain modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application will serve one or more user workflows. This type of module aims
    to group these flows based on the affinity of the interfaces that compose them.
    For example, in an application for resource management, we can have the accounting
    module and the inventory module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the application available in the `ch2` folder, there is the *talktalk* application
    that we will use in this and other chapters to put our knowledge into practice.
    In the project folder, let’s create the `home` module with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this command, we use the Angular CLI, `ng`, and the abbreviations `g` for
    `m` for `home`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `Page` component that will represent the application’s home
    page and, since we are using Angular material, we will use the Angular CLI to
    generate a page with a side menu using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Angular CLI, besides creating the component, also edited the `home.module.ts`
    file by adding it to the `declarations` attribute. Change this file as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this module, we will export the `HomeComponent` component to use in the
    application’s route. In the `app.module.ts` file, import the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the module in the `import` attribute of the `NgModule` metadata, we can
    change the route in the `app-routing.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `routes` component is also `NgModule`, however, it is specialized in organizing
    routes, and imports and exports only `RouterModule` from Angular. Here, in the
    `routes` array, we create the direction for `HomeComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `ng serve --o` command, we get the application’s home page:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.3 – talktalk sample a\uFEFFpplication menu page](img/B19562_02_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – talktalk sample application menu page
  prefs: []
  type: TYPE_NORMAL
- en: Component modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of this module is to group directive components and pipes that will
    be reused by business domain components and even other components. Even using
    a component library such as Angular Material, your system will need custom components
    according to the business rules of your business domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of component has components, directives, and pipes declared in the
    `declaration` attribute and exported in the `exports` attribute, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Separating the project into business domain modules and components will organize
    your code and improve its maintainability. Let’s analyze a common anti-pattern
    in Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding anti-pattern – single module app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are starting to study and develop with Angular, it is very common not
    to pay much attention to the organization and use of the application modules.
    As we studied at the beginning of this chapter, NgModules are so fundamental to
    Angular that as soon as we start a project, the Angular CLI creates the first
    module for the project, `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, only this module is necessary for your application to work. From
    there, we can declare all the components and directives, and import all the libraries
    that the project might need, as we can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This approach has some problems and is an anti-pattern that we’ll call a single-module
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problems we have here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disorganized folder structure**: The team will soon not know which components
    belong to which area of the project. As the project grows, this file will get
    bigger and more confusing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bundle size and build time**: Angular has several build and bundle optimizations
    that depend on the definition of application modules. Staying in just one module,
    these optimizations are not very effective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component maintainability and update issues**: As this file grows, the team
    will have difficulties deprecating no longer used components or updating those
    components where the Angular CLI is unable to update automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The solution to this anti-pattern is to apply what we learned in this chapter:
    separating modules into business domain (or feature) and component modules.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `NgModel` to reduce the repetition of importing common components
    in the application, as we will see in the next section about the `SharedModule`
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the usage of common modules – the SharedModule pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look at Angular projects, we will see patterns of use of modules such
    as `HttpModule`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To avoid code duplication and also make it easier for new team members, don’t
    forget to add an important module to the project; we can create the `SharedModule`
    call to centralize the common dependencies of an Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do this in our project using the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the newly generated file, we will place the Angular Material dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this module, we are importing Angular Material’s dependencies and exporting
    the same dependencies, without declaring any component, directive, or pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `home.module.ts` file, we can refactor to use `SharedModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the file has become much more succinct and easier to read using `SharedModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: The modules present in `SharedModule` must be modules common to the majority
    of modules in your project, as this can increase the size of the module’s bundle.
    If the module needs some specific dependency, you must declare it in that dependency
    and not in `SharedModule`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we’ll see a feature that will improve your user’s experience
    and is based on organizing the application into modules.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the size of your app – lazy loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good strategy for separating modules from your Angular application will increase
    your team’s productivity and improve code organization. But another advantage
    that will impact the quality for your user is the use of the lazy loading technique
    for modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the build process of the sample application using the `ng build`
    command, we can see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Sample application bundle size](img/B19562_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Sample application bundle size
  prefs: []
  type: TYPE_NORMAL
- en: The size of our application’s initial bundle (the `main.ts` file) is 94.73 kB,
    which may seem small, but for the size of our application with few features, it
    is a considerable size.
  prefs: []
  type: TYPE_NORMAL
- en: As the project has more features, the tendency is for this initial bundle to
    increase considerably, harming our users’ experience as they will initially need
    to download a larger file. This problem particularly manifests itself in environments
    where the internet is not very good, such as 3G networks.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce this file and consequently improve our user experience, the ideal
    is to have smaller packages and for these packages to be loaded only when necessary
    – that is, in a lazy way.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to refactor our project, and the first step we have already taken
    is to separate the functionalities into feature modules (in the *Avoiding anti-pattern
    – single module app* section, we explained the danger of not separating the application
    modules, and without a doubt, the size of the bundle is the most impactful for
    the user).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a route file for the `Home` module. As the module already
    exists, let’s manually create the `home-routing.module.ts` file in the same folder
    as the `home.module.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This route file is similar to the application’s main route file, with the difference
    that `@NgModule`’s import uses the `forChild` method instead of `forRoot`. This
    is because this module is a subroute of the main route.
  prefs: []
  type: TYPE_NORMAL
- en: Another important detail to note is that the chosen path for the `HomeComponent`
    component is empty. We can explain this because the main route file that defines
    the `/home` route and how this module represents the `/home` component is already
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `home.module.ts` file, let’s change it to import the route file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we also removed the export of the `HomeComponent` component because
    the `Home` module route file will load it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project’s main route file, `app-routing.module.ts`, let’s refactor it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the most important part is the `loadChildren` attribute. This
    is where we configure the lazy load, as we pass to Angular’s route mechanism a
    function that returns an `import` promise.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `import` function is not an Angular function, but a standard JavaScript
    function that allows dynamic loading of code. Angular’s route engine uses this
    language feature to bring this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the main module, `AppModule`, let’s remove the `HomeModule` import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our application with the `ng serve` command, we didn’t notice any difference.
    However, when executing the `ng build` command, we can notice the following diagnosis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Application bundle size after refactoring with lazy loading](img/B19562_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Application bundle size after refactoring with lazy loading
  prefs: []
  type: TYPE_NORMAL
- en: The Angular build process has separated the `Home` module into its own bundle
    and the `main.ts` bundle has been made smaller. The difference may seem small
    but note that, this way, our application can scale and grow in complexity and
    the initial bundle will remain small or grow very little.
  prefs: []
  type: TYPE_NORMAL
- en: The new features continue to exist and be loaded by the application, but the
    initial loading will be faster, and these new features will be downloaded on demand
    only when the user accesses the route they want, giving a very positive fluidity
    and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied the Angular modules in detail and how we can use
    them for the organization and performance of our applications. We learned the
    difference between Angular modules and JavaScript modules, and we saw each attribute
    of a module definition and the types that we can create in the project. Finally,
    we learned how to avoid the single module app anti-pattern and how to create the
    `SharedModule`.
  prefs: []
  type: TYPE_NORMAL
- en: We reiterated our example application to use lazy loading of bundles, which
    demonstrates that good module organization reflects performance and fluidity for
    our users. Now, you are able to organize your application in such a way that it
    can scale and increase in complexity and features without compromising the maintainability
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use TypeScript effectively and productively
    for our Angular projects.
  prefs: []
  type: TYPE_NORMAL
