- en: Additional React Native Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他React Native组件
- en: Throughout the book, we touched on a lot of React Native SDKs. However, there
    were some components where their additions didn't fit with the apps we built.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们提到了许多React Native SDK。然而，有些组件的添加并不适合我们构建的应用程序。
- en: 'In this chapter, we will cover some of them so that you will gain some extended
    practice with the React Native framework. You will learn to do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍其中的一些，以便你能够在React Native框架中获得一些扩展实践。你将学习以下内容：
- en: Write a playground application where we will add components and parts of the
    React Native API that we did not get to work with in the prior projects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个游乐场应用程序，我们将添加在先前项目中没有使用过的React Native API组件和部分
- en: Use the Fetch API to make network calls to a third-party resource
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fetch API对第三方资源进行网络调用
- en: Utilize the Vibration API to physically vibrate the user's phone
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Vibration API使用户的手机产生物理振动
- en: Make use of the Linking API have your app open a third-party app with a registered
    link
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Linking API让您的应用通过已注册的链接打开第三方应用
- en: Build a slider that can slide around to set a value between a defined minimum
    and maximum number
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个可以滑动以在定义的最小值和最大值之间设置值的滑块
- en: Learn how to use the Action sheet and Share sheet in iOS to share details from
    your app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在iOS中使用Action sheet和Share sheet来分享应用中的详细信息
- en: Obtain a user's location data with the Geolocation polyfill
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Geolocation polyfill获取用户的位置数据
- en: Additionally, the end of this chapter includes a tutorial on how we would build
    `Expenses` in [Chapter 4](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml), *Advanced
    Functionality with the Expenses App* for Android.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章末尾还包括一个教程，介绍我们如何在[第4章](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml)中构建`Expenses`，即使用Android的**高级功能**。
- en: Setting up a boilerplate project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置样板项目
- en: Using the React Native command-line tools, I created a project titled `AdditionalComponents`.
    In it, the structure is a lot more simplified than our previous projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Native命令行工具，我创建了一个名为`AdditionalComponents`的项目。在其中，结构比我们之前的项目简化得多。
- en: 'In each platform-specific index file at the root of the project, it imports
    an `App` component from our `app` folder and registers it to `AppRegistry`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下的每个特定平台的索引文件中，它从我们的`app`文件夹导入一个`App`组件并将其注册到`AppRegistry`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will be using the `index.js` file found in the `app` folder to contain the
    code for the examples that we'll be building.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用位于`app`文件夹中的`index.js`文件来存放我们将要构建的示例代码。
- en: 'At the end of this step, we have an `index.js` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步骤结束时，我们有一个`index.js`文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, we have a file that holds our styling:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有一个包含我们样式的文件：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Making Fetch happen
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让Fetch发生
- en: The first thing we will do is make a request to a third-party API during the
    `componentDidMount` life cycle. Our intention is to grab a set of JSON data from
    that API and use it to populate the `Picker` component that we'll be creating
    in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是在`componentDidMount`生命周期中对第三方API发起请求。我们的目的是从该API获取一组JSON数据，并将其用于填充我们将在下一节中创建的`Picker`组件。
- en: The third-party API that I will be using is a nifty one that produces JSON placeholder
    data--[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要使用的第三方API是一个很酷的API，它产生JSON占位符数据--[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)。
- en: 'To grab data from this third-party API, we''ll be using the `fetch` API. `fetch`
    is a JavaScript API that does not need to be specifically imported into our file.
    It returns a promise that contains a response. If we want to use promises, we
    can call `fetch` like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从这个第三方API获取数据，我们将使用`fetch` API。`fetch`是一个JavaScript API，不需要特别导入到我们的文件中。它返回一个包含响应的promise。如果我们想使用promises，我们可以像这样调用`fetch`：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also call `fetch` using the `async`/`await` keywords:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`async`/`await`关键字调用`fetch`：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first argument that `fetch` accepts is the API `endpoint`. The second is
    an optional `object`. By default, `fetch` assumes that you are making a `GET`
    request. In order to make a `POST`, you will have to pass in this object with
    the `POST` property as a string to a key titled `method`. This object can also
    accept any headers you wish to include along with all other parameters to be sent
    in your request.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`接受的第一个参数是API的`endpoint`。第二个是一个可选的`object`。默认情况下，`fetch`假设你正在发起一个`GET`请求。为了发起一个`POST`请求，你必须传递一个包含`POST`属性作为字符串的`object`到名为`method`的键。此`object`还可以接受你希望包含的任何头信息以及所有其他要发送的请求参数。'
- en: 'For example, an object can look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个对象可以看起来像这样：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In your `App` component, let''s create a `componentDidMount` life cycle event
    to fetch data from our `JSONPlaceholder` API using the following `endpoint`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `App` 组件中，让我们创建一个 `componentDidMount` 生命周期事件，使用以下 `endpoint` 从我们的 `JSONPlaceholder`
    API 获取数据：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When data is fetched, go ahead and save it to your component''s `state` and
    log it in the `console` to show that it''s been populated. The code you write
    may end up looking like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被获取时，将其保存到组件的 `state` 中，并在 `console` 中记录以显示它已被填充。你编写的代码可能看起来像以下这样：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is all you need to do to make a `GET` request from an `endpoint` using
    `fetch` in your React Native apps! Next up, we will use the `Vibration` API to
    send a vibration to the user's device whenever our `fetch` function successfully
    resolves.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的所有事情，在 React Native 应用程序中使用 `fetch` 从 `endpoint` 发起 `GET` 请求！接下来，我们将使用
    `Vibration` API 在我们的 `fetch` 函数成功解析时向用户的设备发送振动。
- en: Vibration
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 振动
- en: The `Vibration` API allows us to tap into the vibration motor for our user's
    mobile devices and send a vibration to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vibration` API 允许我们访问用户移动设备的振动电机并向其发送振动。'
- en: This demo will require the use of actual hardware to test, but it is worth the
    setup if you have one to play with. On devices that don't support vibration, including
    the simulator, there will be no effect.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示将需要使用实际硬件进行测试，但如果你有可用的硬件进行实验，那么设置过程是值得的。在不支持振动的设备上，包括模拟器，将不会有任何效果。
- en: There are a couple of caveats to using the Vibration API that you should be
    aware of.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vibration API 有一些需要注意的注意事项。
- en: From a user experience standpoint, the use of vibration in your apps should
    be as a feedback mechanism to let your users know that some sort of interaction
    has occurred.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户体验的角度来看，在你的应用程序中使用振动应该作为一种反馈机制，让用户知道发生了某种交互。
- en: Additionally, extended use of the vibration motor on a user's phone will lead
    to larger stress on their device's battery performance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在用户的手机上长时间使用振动电机会导致设备电池性能承受更大的压力。
- en: It's very easy to abuse this API and include vibrations on all aspects of your
    app, but I would heavily recommend that this feature is reserved to acknowledge
    key interactions that a user may have with your app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易滥用这个 API 并在你的应用程序的所有方面都包含振动，但我强烈建议将此功能保留用于确认用户可能与你的应用程序进行的键交互。
- en: 'It also has access to two methods:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了两种方法：
- en: 'The first method is `Vibration.vibrate()`, which accepts two arguments:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是 `Vibration.vibrate()`，它接受两个参数：
- en: The first is either a number or an array of numbers. The number (or numbers)
    is considered the pattern for which vibrations occur.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种是一个数字或者数字数组。这个数字（或数字）被认为是振动发生的模式。
- en: If a number is passed, an Android device will behave by vibrating for that number
    of milliseconds. On iOS, it will always result in a 1 vibration.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递一个数字，Android 设备将根据这个数字的毫秒数振动。在 iOS 上，它将始终导致 1 次振动。
- en: If an array of numbers is passed to this function, the vibration motor will
    follow a different pattern. An Android device will wait the number of milliseconds
    equal to the first index, and then vibrate a number of milliseconds equal to the
    second index. This pattern where the vibration motor switches between wait and
    vibrate continues for the length of the array.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递一个数字数组给这个函数，振动电机将遵循不同的模式。Android 设备将等待等于第一个索引的毫秒数，然后振动等于第二个索引的毫秒数。这种振动电机在等待和振动之间切换的模式将延续到数组的长度。
- en: For example, an array of `[100, 200, 300, 400]` means that the Android device
    will wait for `100` milliseconds, then vibrate for `200` milliseconds, followed
    by waiting `300` milliseconds before finally vibrating for `400` milliseconds.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一个 `[100, 200, 300, 400]` 的数组意味着 Android 设备将等待 `100` 毫秒，然后振动 `200` 毫秒，然后等待
    `300` 毫秒，最后振动 `400` 毫秒。
- en: The vibration motor's behavior on iOS is different. Rather than alternating
    between waiting and vibrating based on each index, the iOS functionality will
    always vibrate for a fixed one-second interval and wait between vibrations based
    on the next number in the array. Additionally, iOS ignores the first index of
    the array if it is set to zero.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 上振动电机的行为不同。而不是根据每个索引交替等待和振动，iOS 功能将始终在固定的 1 秒间隔内振动，并在振动之间根据数组中的下一个数字等待。此外，如果数组中的第一个索引设置为
    0，iOS 将忽略它。
- en: For example, an array of `[0, 100, 200, 300]` means that the iOS device will
    skip that first index and vibrate for 1 second, then wait `100` milliseconds before
    vibrating for another second. After that, it waits `200` milliseconds and then
    vibrates for 1 second again. Finally, it waits `300` milliseconds after that vibration
    and then vibrates one final time for 1 second.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一个 `[0, 100, 200, 300]` 的数组意味着 iOS 设备将跳过第一个索引，振动 1 秒，然后等待 `100` 毫秒再次振动 1
    秒。之后，它等待 `200` 毫秒再次振动 1 秒。最后，在最后一次振动后等待 `300` 毫秒，然后再次振动 1 秒。
- en: The second argument that `Vibration.vibrate()` accepts is a Boolean that tells
    the motor whether to restart the vibration pattern once it completes (indefinitely)
    or to stop after one iteration.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vibration.vibrate()` 接受的第二个参数是一个布尔值，它告诉电机在完成振动模式后是否重新启动振动（无限期地）或停止一次迭代后停止。'
- en: The second method is `Vibration.cancel()`, which cancels the vibration that
    is currently in place. This is important to build in if you're setting the repeat
    Boolean to `true` in your `vibrate` method.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是 `Vibration.cancel()`，它用于取消当前正在进行的振动。如果你在 `vibrate` 方法中将重复布尔值设置为 `true`，这一点很重要。
- en: 'Additionally, for Android devices, you will need to add the following line
    to your `AndroidManifest.xml` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于 Android 设备，你需要在你的 `AndroidManifest.xml` 文件中添加以下行：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this section, let''s create a callback that is fired when data becomes available
    for the `Picker` to access and vibrates the device a few times. This is the code
    that I came up with; yours may be similar:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们创建一个回调，当 `Picker` 可访问数据时触发，并使设备振动几次。这是我想到的代码；你的可能与此类似：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is simple and straightforward! In the next section, we will look at how to
    open a link to another installed app on the device.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！在下一节中，我们将探讨如何打开设备上另一个已安装应用的链接。
- en: Linking apps with a button
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮链接应用
- en: Deep linking allows us to interact with incoming and outgoing links to and from
    other apps. By creating a deep link for your app, you can enable other apps to
    talk to it directly and pass arguments to it, if desired.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 深链接允许我们与其他应用之间的传入和传出链接进行交互。通过为你的应用创建一个深链接，你可以使其他应用能够直接与之通信，并传递参数给它，如果需要的话。
- en: You can also access other apps' deep links, opening them with custom arguments.
    In this chapter, we will learn how to access other apps using their deep links.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以访问其他应用的深链接，使用自定义参数打开它们。在本章中，我们将学习如何使用深链接访问其他应用。
- en: We will create a `Button` component that, on press, finds out whether Facebook
    is installed on the user's device and if it is, launches the app and tells it
    to open the Notifications page. If Facebook is not installed, it will open the
    React Native documentation on the device's default browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `Button` 组件，当按下时，会检查用户设备上是否安装了 Facebook，如果安装了，则启动应用并告诉它打开通知页面。如果没有安装
    Facebook，它将在设备的默认浏览器中打开 React Native 文档。
- en: It's important to note that you can call Linking as part of any callback you
    wish. It does not have to be tied to the `Button` component at all!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，你可以将 Linking 作为任何你希望的回调的一部分来调用。它根本不需要与 `Button` 组件绑定！
- en: 'Here are the two methods that we will use with `Linking`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将与 `Linking` 一起使用的两种方法：
- en: '`canOpenURL`: This is a function that accepts a URL as an argument. It returns
    a promise containing a Boolean as its result, stating whether or not the URL you
    provided can be opened. This URL can either be a deep link to another application
    or a web-based URL to open a web page.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canOpenURL`：这是一个接受 URL 作为参数的函数。它返回一个包含布尔值的承诺，表示提供的 URL 是否可以打开。这个 URL 可以是另一个应用的深链接，或者是一个用于打开网页的基于
    Web 的 URL。'
- en: '`openURL`: This is a method that also accepts a URL as an argument and attempts
    to open it with an installed app. This method fails if your user''s device does
    not know how to open the URL passed, which is why it''s best to use `canOpenURL`
    to first check for the ability to open it.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openURL`：这是一个也接受 URL 作为参数的方法，并尝试使用已安装的应用打开它。如果用户的设备不知道如何打开传递的 URL，则此方法会失败，这就是为什么最好先使用
    `canOpenURL` 检查是否可以打开它的原因。'
- en: 'On iOS devices, we need to tweak the Xcode project file a bit to allow `Linking`
    to open custom URL schemes. First, we need to link the React Native `Linking`
    binary with our project. Open your project in Xcode and then, in the left-hand
    navigator, expand the `Libraries` folder, then `RCTLinking.xcodeproj` within it,
    followed by the `Products` folder within that:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS设备上，我们需要稍微调整Xcode项目文件，以便允许`Linking`打开自定义URL方案。首先，我们需要将React Native的`Linking`二进制文件链接到我们的项目中。在Xcode中打开您的项目，然后在左侧导航器中展开`Libraries`文件夹，然后是其中的`RCTLinking.xcodeproj`，接着是那个`Products`文件夹：
- en: '![](img/image_09_001-1.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_001-1.png)'
- en: 'Go back to the root project file for `AdditionalComponents`, into Build Phases,
    and drag the libRCTLinking.a file under Link Binary With Libraries:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`AdditionalComponents`的根项目文件，进入构建阶段，并将`libRCTLinking.a`文件拖到`Link Binary With
    Libraries`下：
- en: '![](img/image_09_002-1.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_002-1.png)'
- en: Afterward, head over to the Build Settings tab and add an entry to the Header
    Search Paths array pointing to the `Linking` library. For this specific project,
    the path is `$(SRCROOT)/../node_modules/react-native/Linking`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，转到构建设置选项卡，并将一个条目添加到头文件搜索路径数组中，指向`Linking`库。对于这个特定的项目，路径是`$(SRCROOT)/../node_modules/react-native/Linking`。
- en: 'You can keep the search non-recursive:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以保持搜索非递归：
- en: '![](img/image_09_003.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_003.png)'
- en: There's one last step to perform. As of iOS 9, we have to register our intent
    to access Facebook's URL scheme within the app.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有最后一步要执行。从iOS 9开始，我们必须在应用内注册访问Facebook URL方案的意图。
- en: 'Open up the `Info.plist` file in the sidebar and create an array entry called
    `LSApplicationQueriesSchemes`. Add a string to this array with the value of the
    URL scheme you wish to access. Facebook''s URL scheme is simply `fb`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在侧边栏中打开`Info.plist`文件，并创建一个名为`LSApplicationQueriesSchemes`的数组条目。向此数组添加一个字符串，其值为您希望访问的URL方案。Facebook的URL方案很简单，就是`fb`：
- en: '![](img/image_09_004.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_004.png)'
- en: Once you have completed this, your app should be linked to iOS!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您的应用应该已经链接到iOS！
- en: On Android, no further action is necessary; you should already have access to
    other URL schemes by default.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，不需要采取任何进一步的操作；您应该默认已经可以访问其他URL方案。
- en: 'Using this knowledge, let''s create a `Button` component that launches either
    the Facebook app, if installed, or links to the React Native documentation on
    the user''s device, if it isn''t. Here''s how I wrote it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些知识，让我们创建一个`Button`组件，该组件可以启动已安装的Facebook应用，如果没有安装，则链接到用户设备上的React Native文档。以下是我如何编写的：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Button` component in our `render` method fires the `_onButtonPress` callback
    when pressed. It checks the `Linking` API to check whether the Facebook app can
    be opened on the device, and if so, opens it. If not, it will open a link to the
    React Native documentation website in the device's default browser.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`render`方法中的`Button`组件在按下时会触发`_onButtonPress`回调。它检查`Linking` API以确定设备上是否可以打开Facebook应用，如果可以，则打开它。如果不能，它将在设备的默认浏览器中打开一个链接到React
    Native文档网站。
- en: Slider
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑块
- en: Sliders are common UI components found on the Web. In this section, you will
    see how easy it is to create one in your React Native applications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块是Web上常见的UI组件。在本节中，您将看到在React Native应用程序中创建一个滑块是多么容易。
- en: 'While `Slider` has access to at least nine different props, we will use just
    the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Slider`至少有九个不同的属性，但我们只会使用以下属性：
- en: '`maximumValue`: This is a number that sets the starting maximum value of the
    `Slider`. It defaults to `1`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maximumValue`：这是一个设置`Slider`起始最大值的数字。它默认为`1`。'
- en: '`minimumValue`: This is a number that sets the starting minimum value of the
    `Slider`. It defaults to `0`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minimumValue`：这是一个设置`Slider`起始最小值的数字。它默认为`0`。'
- en: '`onSlidingComplete`: This is a callback that is fired when the user finishes
    interacting with the `Slider`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSlidingComplete`：这是一个在用户完成与`Slider`交互时触发的回调。'
- en: '`onValueChange`: This is a callback that is fired continuously as the user
    is dragging the `Slider`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onValueChange`：这是一个在用户拖动`Slider`时连续触发的回调。'
- en: '`step`: This is a number that sets the step value of the slider. Each tick
    of the `Slider` moves it by this number of steps. It defaults to `0` and ranges
    between `0` and the difference between the maximum value and minimum value.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`：这是一个设置滑块步进值的数字。每次`Slider`的点击都会移动这个数字的步数。它默认为`0`，范围在`0`和最大值与最小值之间的差值之间。'
- en: 'Take a moment to create a `Slider` component. Give it any minimum and maximum
    values you like, any step count, and create some text that shows the current value
    of the slider whenever either movement happens or interaction stops. This is how
    I implemented it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间创建一个`Slider`组件。给它任何你喜欢的最小和最大值，任何步数，并创建一些文本，显示当滑动条移动或交互停止时滑动条的当前值。这是我实现它的方法：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This renders a new `Slider` component on the page with a value range from `0`
    to `100`. It changes the value of the `Slider` whenever the user is either in
    the process of dragging the slider or has completed the dragging action. Each
    movement of the slider increases the value by `3`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这在页面上渲染了一个新的`Slider`组件，其值范围从`0`到`100`。当用户正在拖动滑动条或完成拖动操作时，它会改变滑动条的价值。每次滑动条的移动都会增加`3`的值。
- en: 'This callback handles setting the `sliderValue` property in state. The code
    for the `sliderValue` property is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调处理在状态中设置`sliderValue`属性。`sliderValue`属性的代码如下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using ActionSheetIOS
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ActionSheetIOS
- en: The `ActionSheetIOS` API lets us display either an action sheet or share sheet
    for the user to interact with.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionSheetIOS` API让我们能够显示一个动作表单或分享表单供用户交互。'
- en: The action sheet is an overlay of options that the user can interact with in
    the app.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 动作表单是用户可以在应用中交互的选项覆盖层。
- en: The Share sheet allows the user to share almost anything, anywhere, using the
    built-in sharing system. This could mean sending content in the form of a text
    message, e-mail, or to a third-party app.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 分享表单允许用户使用内置的分享系统几乎在任何地方分享任何内容。这可能意味着以短信、电子邮件或第三方应用的形式发送内容。
- en: Creating an action sheet
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个动作表单
- en: The two methods that `ActionSheetIOS` makes available are `showActionSheetWithOptions`
    and `showShareActionSheetWithOptions`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionSheetIOS`提供的两个方法是`showActionSheetWithOptions`和`showShareActionSheetWithOptions`。'
- en: 'The first method, `showActionSheetWithOptions`, accepts two arguments: an `options`
    object and a `callback` function.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`showActionSheetWithOptions`接受两个参数：一个`options`对象和一个`callback`函数。
- en: 'The `options` object must contain at least one of the following properties.
    We use all five in this example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`对象必须包含以下属性之一。在这个例子中，我们使用了所有五个属性：'
- en: '`options`: This is an array of strings that map to the multiple options that
    appear in the overlay.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这是一个字符串数组，映射到覆盖层中出现的多个选项。'
- en: '`cancelButtonIndex`: This is a number that points to the `index` where the
    Cancel button, if it exists, is located in the `options` array. This sends the
    Cancel button to the very bottom of the overlay.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancelButtonIndex`：这是一个指向`options`数组中取消按钮（如果存在）位置的索引的数字。这会将取消按钮发送到覆盖层的底部。'
- en: '`destructiveButtonIndex`: This is a number that points to the `index` where
    a destructive button, if it exists, is located in the `options` array. This turns
    the color of the destructive option''s text to red.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destructiveButtonIndex`：这是一个指向`options`数组中破坏性按钮（如果存在）位置的索引的数字。这会将破坏性选项的文本颜色变为红色。'
- en: '`title`: This is a string that shows above the action sheet.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是一个显示在动作表单上方的字符串。'
- en: '`message`: This is a string that shows right below the title.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：这是一个显示在标题下方的字符串。'
- en: 'The callback that `showActionSheetWithOptions` takes in will have one argument
    passed to it, which is the index of the option that is selected by the user when
    the action sheet is interacted with. If the user taps outside the action sheet
    in order to hide it, it has the exact same effect as if the Cancel button''s index
    were selected:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`showActionSheetWithOptions`方法接受的回调将传递一个参数给它，这个参数是用户在交互动作表单时选择的选项索引。如果用户点击动作表单外部以隐藏它，这具有与选择取消按钮索引完全相同的效果：'
- en: '![](img/image_09_005.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_005.png)'
- en: Try creating an action sheet of your own. Have some sort of interaction to toggle
    it, followed by any sort of interaction you can think of when an index is selected.
    Make sure to give your action sheet a `title`, `message`, some `options`, a `cancel`
    index, and a `destructive` index.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个自己的动作表单。有一个某种交互来切换它，然后是当索引被选中时你可以想到的任何类型的交互。确保给你的动作表单一个`title`、`message`、一些`options`、一个`cancel`索引和一个`destructive`索引。
- en: 'This is the code I came up with. Call a function to render the `ActionSheetIOS`
    and `ShareSheetIOS` components. I added the reference to `ShareSheetIOS` in the
    function name in anticipation of the next section:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我想出来的代码。调用一个函数来渲染`ActionSheetIOS`和`ShareSheetIOS`组件。我在函数名中添加了对`ShareSheetIOS`的引用，以期待下一节：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alert the selected index of the `ActionSheetIOS` component to the user:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ActionSheetIOS` 组件选择的索引通知用户：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open `ActionSheetIOS` and add the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `ActionSheetIOS` 并添加以下代码：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Don''t render anything if the user is on an Android device, since these components
    are iOS-exclusive:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在 Android 设备上，不要渲染任何内容，因为这些组件是 iOS 独有的：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Return a `Button` that calls `_openActionSheet` when pressed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个在按下时调用 `_openActionSheet` 的 `Button`：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sharing content with ShareSheetIOS
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ShareSheetIOS 分享内容
- en: 'The share sheet, on the other hand, is a different type of interaction. As
    I mentioned earlier, the Share sheet lets our app share content with it. To open
    it, we call `showShareActionSheetWithOptions`. It accepts three arguments: an
    `options` object, a `failureCallback` function, and a `successCallback` function.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，分享表单是一种不同类型的交互。正如我之前提到的，分享表单允许我们的应用与它共享内容。要打开它，我们调用 `showShareActionSheetWithOptions`
    方法。它接受三个参数：一个 `options` 对象、一个 `failureCallback` 函数和一个 `successCallback` 函数。
- en: 'The Share sheet''s `options` object is different from the one that the action
    sheet accepted. It can contain the following properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 分享表单的 `options` 对象与动作表单接受的 `options` 对象不同。它可以包含以下属性：
- en: '`url`: This is a stringified URL to share. The `url` property is required if
    the message property is not available. The url can point to a local file or base-64
    encoded `url`; it can share images, videos, PDFs, and other types of files this
    way.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：这是一个要分享的字符串化 URL。如果 `message` 属性不可用，则 `url` 属性是必需的。URL 可以指向本地文件或 base-64
    编码的 `url`；可以通过这种方式分享图片、视频、PDF 等其他类型的文件。'
- en: '`message`: This is a string that contains a message for the user to share.
    The message property is required if the `url` property is not available.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：这是一个包含用户要分享的消息的字符串。如果 `url` 属性不可用，则 `message` 属性是必需的。'
- en: '`subject`: This is a string that contains a subject for the message.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subject`：这是一个包含消息主题的字符串。'
- en: The `failureCallback` is fired when a Share sheet action fails or is canceled
    by the user, while the `successCallback` is fired when a Share sheet action is
    successfully carried through by the user.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当分享表单操作失败或被用户取消时，`failureCallback` 被触发，而当用户成功执行分享表单操作时，`successCallback` 被触发。
- en: '![](img/image_09_006.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_006.png)'
- en: 'Let''s modify the index file to do the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改索引文件以执行以下操作：
- en: Modify `_renderActionAndShareSheets` to return a second button, directly underneath
    the first, that will open the ShareSheet when tapped on
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `_renderActionAndShareSheets` 以返回一个位于第一个按钮正下方的第二个按钮，当点击时将打开 ShareSheet
- en: Create a function, called `_openShareSheet`, to handle the opening of that Share
    sheet
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `_openShareSheet` 的函数来处理打开该分享表单的操作
- en: 'This is how my version came about. Call the `showShareActionSheetWithOptions`
    method of `ActionSheetIOS`, giving it a link to open and a message to share, along
    with a `subject` and `error`/`success` callbacks:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我的版本是如何产生的。调用 `ActionSheetIOS` 的 `showShareActionSheetWithOptions` 方法，给它一个打开的链接和一个要分享的消息，以及一个
    `subject` 和 `error`/`success` 回调：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Take a look at the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Grabbing user geolocation data
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户地理位置数据
- en: The `Geolocation` API for React Native is an extension of the `Web Geolocation`
    API. It's available by calling `navigator.geolocation` and does not need to be
    imported.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 的 `Geolocation` API 是 `Web Geolocation` API 的扩展。它可以通过调用 `navigator.geolocation`
    来使用，不需要导入。
- en: Location data is a very important part of the mobile experience and as a best
    practice, this data should not be requested from your users until there is an
    explicit benefit for the user to provide the said information.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 位置数据是移动体验的重要组成部分，并且作为最佳实践，在用户提供这些信息有明确好处之前，不应从用户那里请求这些数据。
- en: As location data is private until the user consents to share it with you, treat
    the sharing of this information as a bond of trust between the user and your app.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于位置数据在用户同意与您分享之前是私密的，因此将此信息的共享视为用户与您的应用程序之间的信任纽带。
- en: Always make the assumption that your users will select No when asked to share
    their location, and devise a strategy for how to handle that rejection when it
    inevitably happens.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总是假设当用户被要求分享他们的位置时，他们会选择“否”，并制定一个策略来处理这种不可避免的拒绝。
- en: On iOS, if you created your project using React Native in it, Geolocation will
    be enabled by default. If not, you will need to go to your `Info.plist` file and
    add the `NSLocationWhenInUsageDescription` key to it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 上，如果您使用 React Native 创建了项目，地理位置将默认启用。如果没有，您需要前往您的 `Info.plist` 文件，并向其中添加
    `NSLocationWhenInUsageDescription` 键。
- en: 'On Android devices, you will need to add the following line to the `AndroidManifest.xml`
    file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓设备上，您需要在`AndroidManifest.xml`文件中添加以下行：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Geolocation` API has access to four different methods. These are the three
    we will be covering in our example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Geolocation` API 有四个不同的方法。以下是我们将在示例中介绍的三种方法：'
- en: '`getCurrentPosition`: This is a function that gets the current location of
    the device. It accepts up to three arguments:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCurrentPosition`: 这是一个获取设备当前位置的函数。它最多接受三个参数：'
- en: The first, a `success` callback, is mandatory and is called with the current
    location information.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个，一个`success`回调，是必须的，并带有当前位置信息调用。
- en: The second, an `error` callback, is optional.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个，一个`error`回调，是可选的。
- en: 'The third is an optional options array that can contain the following supported
    options: `timeout` (in milliseconds), `maximumAge` (in milliseconds), and `enableHighAccuracy`
    (a Boolean).'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是一个可选的选项数组，可以包含以下受支持选项：`timeout`（以毫秒为单位），`maximumAge`（以毫秒为单位），以及`enableHighAccuracy`（一个布尔值）。
- en: '`watchPosition`: This is a function that watches the device''s location and
    returns a watch ID number. It accepts up to three arguments:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watchPosition`: 这是一个监视设备位置并返回一个监视ID号的函数。它最多接受三个参数：'
- en: The first is a mandatory `success` callback that is fired whenever the location
    changes.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是必须的`success`回调，每当位置发生变化时都会触发。
- en: The second is an optional callback to handle errors.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是可选的回调，用于处理错误。
- en: The third is another optional options object that can contain the `timeout`,
    `maximumAge`, and `enableHighAccuracy` properties with the same types as the options
    object of `getCurrentPosition` as well as a `distanceFilter` property that accepts
    a number in meters.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是另一个可选的选项对象，可以包含与`getCurrentPosition`选项对象相同类型的`timeout`、`maximumAge`和`enableHighAccuracy`属性，以及一个接受以米为单位的数字的`distanceFilter`属性。
- en: '`clearWatch`: This is a function that accepts a watch ID number and stops watching
    that position.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearWatch`: 这是一个接受一个手表ID号并停止监视该位置的函数。'
- en: 'Here is a sample of the current location object that the `Geolocation` API
    returns:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Geolocation` API返回的当前位置对象的示例：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the `Geolocation` API, let''s modify the index file so that we can do
    the following things:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Geolocation` API，让我们修改索引文件，以便我们可以做以下事情：
- en: Grab the user's location during the `componentDidMount` life cycle
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`componentDidMount`生命周期中获取用户的位置
- en: Show their latitude and longitude on the screen
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示它们的纬度和经度
- en: Additionally, create a button that watches the device's location and updates
    it whenever it changes on press
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，创建一个按钮来监视设备的地理位置，并在按下时更新它：
- en: Then, create a button that clears it
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，创建一个按钮来清除它
- en: 'Here is the code that I wrote for this section. Make a call to the `getCurrentPosition`
    method of the `Geolocation` API during the `componentDidMount` life cycle, saving
    the location to state:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我为这一节编写的代码。在`componentDidMount`生命周期中调用`Geolocation` API的`getCurrentPosition`方法，并将位置保存到状态中：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Render the latitude and longitude of the user in `Text` components:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Text`组件中渲染用户的纬度和经度：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Render one button to start and another to stop the watch process:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染一个按钮以启动监视过程，另一个按钮以停止监视过程：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Set the location of the user when they begin watching their position:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户开始监视他们的位置时设置用户的位置：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Save the ID of the `watchPosition` call to state:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将`watchPosition`调用的ID保存到状态中：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Call `clearWatch` when the user presses the Cancel Watching Position button
    and erase the `watchID` in state:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下取消监视位置按钮时调用`clearWatch`，并在状态中擦除`watchID`：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Great job! You finished the playground section of this chapter. In the next
    section, we will switch gears and revisit the `Expenses` app from [Chapter 4](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml),
    *Advanced Functionality with the Expenses App*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你已经完成了本章的游乐场部分。在下一节中，我们将转换方向，重新审视第4章中的`Expenses`应用，*使用Expenses应用的扩展功能*。
- en: Expenses for Android
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓设备费用
- en: In [*Chapter 4*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml), *Advanced Functionality
    with the Expenses App*, we completed building the iOS version of Expenses, our
    budget tracking application. Due to the page count of the chapter, I thought it
    would be best to place the Android portion at the end of this chapter instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml)，*使用Expenses应用的扩展功能*中，我们完成了Expenses应用（我们的预算跟踪应用）的iOS版本的建设。由于章节的页数，我认为将安卓部分放在本章的末尾会更好。
- en: This section picks up immediately from where we left off at the end of [*Chapter
    4*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml), *Advanced Functionality with
    the Expenses App*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节立即从[*第4章*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml)，“使用Expenses应用的高级功能”的结尾继续。
- en: An example code for the Android version of Expenses can still be found in the
    code repository for [*Chapter 4*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml),
    *Advanced Functionality with the Expenses App*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml)，“使用Expenses应用的高级功能”的代码库中，仍可以找到Expenses的Android版本示例代码。
- en: Android modifications
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android修改
- en: 'For Android support, we want to do the following things to our code base:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持Android，我们想要对我们的代码库做以下事情：
- en: Import the `react-native-vector-icons` library via Gradle
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Gradle导入`react-native-vector-icons`库
- en: Swap out the `TabBarIOS` component for an Android-based solution using the `DrawerLayoutAndroid`
    and `ToolbarAndroid` components to create a navigation bar that contains a drawer
    that slides out to toggle between the current and previous months' expenses
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用基于Android的解决方案替换`TabBarIOS`组件，使用`DrawerLayoutAndroid`和`ToolbarAndroid`组件创建一个包含可以滑动以在当前月份和上个月份的支出之间切换的抽屉的导航栏
- en: Replace any `NavigatorIOS` instances with `Navigator`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`Navigator`替换任何`NavigatorIOS`实例
- en: Remove `ProgressViewIOS`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除`ProgressViewIOS`
- en: Remove the `ExpandableCell` components in `AddExpensesModal` and replace `DatePickerIOS`
    with `DatePickerAndroid`
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AddExpensesModal`中移除`ExpandableCell`组件，并用`DatePickerAndroid`替换`DatePickerIOS`
- en: Add any Android-specific files to components that require them
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任何需要Android特定文件的组件添加到其中
- en: Installing the vector icon library
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装矢量图标库
- en: You should not need to do anything extra to have the `react-native-vector-icons`
    library installed for Android since React Native link should have taken care of
    the entire process for you.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，您不需要做任何额外的事情来安装`react-native-vector-icons`库，因为React Native链接应该已经为您处理了整个过程。
- en: However, if you decided to link the library manually for iOS, the readme file
    for `react-native-vector-icons` has the latest, up-to-date instructions for importing
    the library manually for Android devices. As these instructions can change with
    newer releases to the library, I heavily recommend you follow them directly from
    the `README` file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您决定手动为iOS链接库，`react-native-vector-icons`的readme文件有导入Android设备库的最新、最新的手动导入说明。由于这些说明可能会随着库的新版本而更改，我强烈建议您直接从`README`文件中遵循它们。
- en: If you already have the package installed in your project's `node_modules` folder,
    you can read the instructions from there without requiring further Internet access.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在项目的`node_modules`文件夹中安装了该包，您可以直接从那里阅读说明，无需进一步的网络访问。
- en: The instructions on importing with Gradle are very straightforward. You will
    also want to follow the instructions for integrating the library for `getImageSource`
    and `ToolbarAndroid` support.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle导入的说明非常直接。您还希望遵循用于集成`getImageSource`和`ToolbarAndroid`支持的库的说明。
- en: ToolbarAndroid
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ToolbarAndroid
- en: On Android, the preferred way to navigate the UI is through its top-placement
    toolbar. This differs from the iOS experience because rather than having all the
    available tabs at the bottom of the screen, navigation is hidden inside a drawer
    that the user taps to expose.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，导航UI的首选方式是通过其顶部放置的工具栏。这与iOS体验不同，因为不是所有可用的标签都位于屏幕底部，而是导航隐藏在一个用户点击以展开的抽屉中。
- en: '`ToolbarAndroid` is a React Native, Android-specific component that wraps around
    the Android SDK''s native toolbar widget. Like `TabBarIOS`, we have access to
    a `react-native-vector-icons`-specific version of the component that we render
    by calling `<Icon.ToolbarAndroid />`. We will be using the following props when
    using `Icon.ToolbarAndroid` in our app:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolbarAndroid`是一个React Native，特定于Android的组件，它围绕Android SDK的本地工具栏小部件包装。像`TabBarIOS`一样，我们可以访问一个通过调用`<Icon.ToolbarAndroid
    />`渲染的`react-native-vector-icons`特定版本的组件。当我们在应用中使用`Icon.ToolbarAndroid`时，我们将使用以下属性：'
- en: '`title`: This is a string that is displayed at the top of the toolbar showing
    the name of the app'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是一个显示在工具栏顶部的字符串，显示应用名称'
- en: '`titleColor`: This sets the color of the `title` string'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`titleColor`：这设置了`title`字符串的颜色'
- en: '`navIconName`: This is a string that sets the icon of the navigation menu in
    the toolbar'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navIconName`：这是一个设置工具栏中导航菜单图标的字符串'
- en: '`height`: This is a number to set the height of the toolbar'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`：这是一个设置工具栏高度的数字'
- en: '`backgroundColor`: This sets the background color of the toolbar'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backgroundColor`：这设置了工具栏的背景颜色'
- en: '`onIconClicked`: This is a callback that is executed when the navigation icon
    is tapped on by the user'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, you may have noted that there's no room for the actual `Navigation`
    drawer that this Navigation icon traditionally opens. That's because we will use
    `Icon.ToolbarAndroid` in conjunction with `DrawerLayoutAndroid`, the component
    that handles the actual navigation drawer.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: DrawerLayoutAndroid
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This component is typically used for navigation. Think of this as the place
    where the tabs in TabBarIOS will be made available.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The `DrawerLayoutAndroid` component has access to the `openDrawer` and `closeDrawer`
    methods responsible for its visibility. To use it, pass a ref to the component
    and use it to call either method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'While this component has many props available to it, we will be using just
    the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`drawerLockMode`: This is one of the three strings that determine whether the
    drawer responds to touch gestures, such as sliding the drawer open/closed. This
    does not disable the toolbar''s navigation icon from opening and closing the drawer:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unlocked`: the drawer responds to touch gestures'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locked-closed`: the drawer stays closed and does not respond to touch gestures'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locked-open`: the drawer stays open and does not respond to touch gestures'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref`: This is a reference string to pass to the drawer. This is so that we
    can reference the drawer within its child components, which will be necessary
    to open and close it.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderNavigationView`: This is a function responsible for the rendering of
    your drawer.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting ToolbarAndroid and DrawerLayoutAndroid
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way we connect these two components together is to start by writing an
    `Icon.ToolbarAndroid` component:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, create a `DrawerLayoutAndroid` component and wrap it around two children:
    the `Icon.ToolbarAndroid` component you just created along with the `Navigator`
    following it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When integrating the three components, we want to ensure that the following
    is always true:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '`DrawerLayoutAndroid` is always positioned above everything else so that the
    drawer doesn''t get tucked underneath `Icon.ToolbarAndroid`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the options of `DrawerLayoutAndroid` to navigate from one view to
    another, the same instance of `Icon.ToolbarAndroid` should be present so that
    we are not rendering a whole new `Icon.ToolbarAndroid` component every single
    time, nor will it contain an animation of the said toolbar ever *leaving* the
    screen to be replaced by *another*
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we'll do here is nest `Icon.ToolbarAndroid` and `Navigator` within `DrawerLayoutAndroid`,
    and set a `ref` for `Navigator` so that we can use that `Navigator` to push new
    scenes into the app, as needed within our root file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have implemented both the `Icon.ToolbarAndroid` and `DrawerLayoutAndroid`
    components, you will be able to have in-app navigation that looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_007-1.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Here is how the big picture looks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These are the four components that this index file will work with. The `App`,
    `EnterBudget`, and `PreviousMonthsList` components will be part of our navigation
    routes. The `Drawer` component is used to render the navigation view for `DrawerLayoutAndroid`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是这个索引文件将与之工作的四个组件。`App`、`EnterBudget`和`PreviousMonthsList`组件将是我们导航路由的一部分。`Drawer`组件用于渲染`DrawerLayoutAndroid`的导航视图。
- en: 'As Android software has a different design language from iOS apps, I imported
    the `MaterialIcons` pack instead of `FontAwesome` since it''s built with Google''s
    Material Design guidelines in mind:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android软件的设计语言与iOS应用不同，我选择了导入`MaterialIcons`包而不是`FontAwesome`，因为它是根据谷歌的Material
    Design指南构建的：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A property titled `expenses` is set to be undefined. This is to pass over to
    `PreviousMonthsList` since it expects the list of expenses as a prop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了一个名为`expenses`的属性为未定义。这是为了传递给`PreviousMonthsList`，因为它期望作为属性传递的支出列表。
- en: Visible routes are passed to the `Drawer` component. I purposefully omit the
    route that handles entering a budget for the month because it isn't one that the
    user should be able to manually navigate to.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可见路由传递给`Drawer`组件。我故意省略了处理输入月度预算的路由，因为这个路由用户不应该能够手动导航到。
- en: 'In the `WillMount` component life cycle, I call the `_updateExpenses` method
    to set the `expenses` key in state to the expenses object. Check out the code
    for the explanation given here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WillMount`组件生命周期中，我调用`_updateExpenses`方法来设置状态中的`expenses`键为支出对象。查看以下代码以了解这里给出的解释：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Within the `DrawerLayoutAndroid` component, I am nesting both `Icon.ToolbarAndroid`
    and `Navigator`. Like I mentioned earlier, this is to physically place the drawer
    on a layer above the rest of the app. Check out the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DrawerLayoutAndroid`组件内部，我嵌套了`Icon.ToolbarAndroid`和`Navigator`。正如我之前提到的，这是为了将抽屉物理地放置在应用程序其他部分的上方。查看以下代码：
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Having given `DrawerLayoutAndroid` a ref of `drawer` earlier, I can use it to
    open the drawer when the navigation icon is tapped on by the user. I also gave
    `Navigator` a ref of `navigator` so that I can push to it at the root `index.android.js`
    level.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前给`DrawerLayoutAndroid`分配了一个`drawer`引用，我可以在用户点击导航图标时使用它来打开抽屉。我还给`Navigator`分配了一个`navigator`引用，这样我就可以在根`index.android.js`级别上推送它。
- en: 'The `DrawerLayoutAndroid` component''s `render` method returns this `Drawer`
    component that I import from a custom component I wrote. I pass it a callback
    under the prop name of `navigateTo`, whose function pushes the index of the `navigator`
    and closes `DrawerLayoutAndroid`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawerLayoutAndroid`组件的`render`方法返回我从我编写的自定义组件导入的这个`Drawer`组件。我通过`navigateTo`属性名传递一个回调函数，该函数推送`navigator`的索引并关闭`DrawerLayoutAndroid`：'
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The rendering of `PreviousMonthsList` with `_renderScene` is configured to pass
    in the `expenses` object and `updateExpenses` function.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`_renderScene`配置的`PreviousMonthsList`的渲染将传入`expenses`对象和`updateExpenses`函数。
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `_updateExpenses` function passed into `PreviousMonthsList` as the prop
    titled `updateExpenses` is a modified version of the `_updateExpenses` function
    found in the `App` component. We only care about the `expenses` object in this
    component, so we will not bother setting any other data:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`PreviousMonthsList`作为名为`updateExpenses`的属性的`_updateExpenses`函数是`App`组件中找到的`_updateExpenses`函数的修改版本。我们只关心这个组件中的`expenses`对象，所以我们不会设置任何其他数据：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, I built the `Drawer` component:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我构建了`Drawer`组件：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `DrawerRow` component that `Drawer` imports is responsible for rendering
    individual rows of data for the `ListView` component of  `Drawer`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drawer`导入的`DrawerRow`组件负责为`Drawer`的`ListView`组件渲染单个数据行。'
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `render` method of `Drawer` returns a simple `ListView` that uses the routes
    array passed to it as a prop to generate each row of data.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drawer`的`render`方法返回一个简单的`ListView`，它使用传递给它的作为属性的routes数组来生成每一行数据。'
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, I created a basic `StyleSheet` for this component:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我为这个组件创建了一个基本的`StyleSheet`：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, I wrote the `DrawerRow` component:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我编写了`DrawerRow`组件：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since `DrawerRow` is a custom component and the `TouchableHighlight` component
    that wraps around it from the `_renderDrawerRow` method of the `Drawer` component
    does not call `setNativeProps` for user-created components automatically, I manually
    called it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`DrawerRow`是一个自定义组件，并且包裹在`Drawer`组件的`_renderDrawerRow`方法中的`TouchableHighlight`组件没有自动调用`setNativeProps`为用户创建的组件，所以我手动调用了它：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `DrawerRow` component also has its own `StyleSheet`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawerRow`组件也有自己的`StyleSheet`：'
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Android-specific app component
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android特定的应用组件
- en: 'Next, I created an Android-specific version of `App.js`, renaming the original
    `App.ios.js`. Only two components are imported to `App.android.js` because any
    components being navigated to are handled in the root `index.android.js` file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我创建了一个针对 Android 的 `App.js` 的特定版本，将原始的 `App.ios.js` 重命名。`App.android.js`
    中只导入了两个组件，因为任何要导航到的组件都在根 `index.android.js` 文件中处理：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The state of the `App` component does not need a `selectedTab` property since
    we are not using tabbed navigation on Android:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件的状态不需要 `selectedTab` 属性，因为我们没有在 Android 上使用标签导航：'
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There are no changes to `componentWillMount` from its iOS counterpart:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 与其 iOS 对应版本相比，`componentWillMount` 没有发生变化：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As a result of removing tabbed navigation, the `render` method of this component
    has been simplified to just render the `CurrentMonthExpenses` and `AddExpenses`
    components:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于移除了标签导航，该组件的 `render` 方法已简化为仅渲染 `CurrentMonthExpenses` 和 `AddExpenses` 组件：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Like `componentWillMount`, `_renderCurrentMonthExpenses` has retained the exact
    same logic from the iOS version of the `App` component:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `componentWillMount` 一样，`_renderCurrentMonthExpenses` 保留了 `App` 组件 iOS 版本的完全相同的逻辑：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `_renderEditBudgetComponent` method has been changed to account for how
    `Navigator` handles its `push` method differently from the `push` method of `NavigatorIOS`
    as mentioned in the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`_renderEditBudgetComponent` 方法已经更改，以考虑 `Navigator` 如何与 `push` 方法不同，正如以下代码中提到的
    `NavigatorIOS` 的 `push` 方法：'
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'While the iOS App component''s `_renderPreviousMonthsList` method has been
    removed on Android, the logic for `_saveAndUpdateBudget`, `_updateBudget`, and
    `_updateExpenses` remains the same, as mentioned in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 iOS 应用组件的 `_renderPreviousMonthsList` 方法在 Android 上已被删除，但 `_saveAndUpdateBudget`、`_updateBudget`
    和 `_updateExpenses` 的逻辑保持不变，正如以下代码中提到的：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, I added a simple `flex` container style for the `App` component:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我为 `App` 组件添加了一个简单的 `flex` 容器样式：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: EnterBudget styling changes
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`EnterBudget` 样式更改'
- en: 'Since Android text fields normally do not contain a border, I used some conditional
    logic with the `Platform` API to remove it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Android 文本字段通常不包含边框，我使用了一些条件逻辑与 `Platform` API 来移除它：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The styling for the `TextInput` component in the `render` method of `EnterBudget`
    now checks to see whether the user's operating system is iOS or Android. If it
    is iOS, it keeps the original `textInput` style from before; if it is Android,
    it sets it to a new `androidTextInput` style.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `EnterBudget` 的 `render` 方法中，`TextInput` 组件的样式现在检查用户的操作系统是否为 iOS 或 Android。如果是
    iOS，则保留之前的原始 `textInput` 样式；如果是 Android，则将其设置为新的 `androidTextInput` 样式。
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next up, we will make some changes to `CurrentMonthExpenses`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对 `CurrentMonthExpenses` 进行一些更改。
- en: CurrentMonthExpenses for Android
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 的 `CurrentMonthExpenses`
- en: In the `CurrentMonthExpenses` component, I am rendering a `ProgressViewIOS`
    component that visually tracks the amount spent by the user using a colored, horizontal
    bar.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CurrentMonthExpenses` 组件中，我渲染了一个 `ProgressViewIOS` 组件，该组件通过一个彩色水平条以视觉方式跟踪用户花费的金额。
- en: The React Native SDK for Android has a similar component, `ProgressBarAndroid`,
    and we will swap out `ProgressViewIOS` for it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的 React Native SDK 有一个类似的组件 `ProgressBarAndroid`，我们将用 `ProgressViewIOS`
    交换它。
- en: Additionally, we want to add a back button event listener for this component
    that is only fired when the user navigates to `CurrentMonthExpenses` by way of
    `PreviousMonthsList` with `BackAndroid`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想为这个组件添加一个返回按钮事件监听器，该监听器仅在用户通过 `PreviousMonthsList` 使用 `BackAndroid` 导航到
    `CurrentMonthExpenses` 时触发。
- en: 'The `ProgressBarAndroid` component is similar to `ProgressViewIOS`. I''m using
    the following props in mine:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressBarAndroid` 组件与 `ProgressViewIOS` 类似。我在我的组件中使用了以下属性：'
- en: '`color`: This determines the color of `ProgressBarAndroid`.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：这决定了 `ProgressBarAndroid` 的颜色。'
- en: '`indeterminate`: This is a Boolean that, when set to true, keeps the progress
    bar animated indefinitely.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indeterminate`：这是一个布尔值，当设置为 true 时，将无限期地保持进度条动画。'
- en: '`progress`: Just like `ProgressViewIOS`, this determines how far along the
    progress bar should move.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`progress`：就像 `ProgressViewIOS` 一样，这决定了进度条应该移动多远。'
- en: '`styleAttr`: This is a string to tell how `ProgressBarAndroid` should be rendered.
    For mine, I used `horizontal`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styleAttr`：这是一个字符串，用于告诉 `ProgressBarAndroid` 应该如何渲染。对于我来说，我使用了 `horizontal`。'
- en: 'The `render` method for `CurrentMonthExpenses` now calls a `_renderProgressIndicator`
    method to determine which progress indicator to render: `ProgressViewIOS` is to
    be rendered for iOS devices, and `ProgressBarAndroid` for Android ones.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentMonthExpenses` 的 `render` 方法现在调用 `_renderProgressIndicator` 方法来确定要渲染哪个进度指示器：对于
    iOS 设备，将渲染 `ProgressViewIOS`，而对于 Android 设备，则渲染 `ProgressBarAndroid`。'
- en: 'The `ListView` is now wrapped around a `View` to give it some separation from
    the progress indicator:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `ListView` 被包裹在一个 `View` 中，以便与进度指示器保持一定的距离：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'I am only calling `pop` on the `navigator` if it is a previous month''s data
    the user is looking at. Otherwise, they will run into an error when attempting
    to call `pop` without any other routes visited:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当用户查看的是前一个月的数据时，我才会调用 `navigator` 上的 `pop`。否则，在尝试调用 `pop` 而没有访问其他路由时，他们将会遇到错误：
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'There have been no changes to the iOS progress indicator logic:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 进度指示器逻辑没有发生变化：
- en: '[PRE56]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The Android progress indicator is returned at the end of the function. I am
    reusing the `_getProgressViewAmount` method here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Android 进度指示器在函数末尾返回。我在这里重用了 `_getProgressViewAmount` 方法：
- en: '[PRE57]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: No other code for this component was changed, and its Android-specific version
    was not necessary because of the minimal changes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件没有其他代码更改，并且由于其更改量最小，因此不需要 Android 特定版本。
- en: 'The styling for `CurrentMonthExpenses` has been changed to add the `listViewContainer`
    property:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentMonthExpenses` 的样式已更改，以添加 `listViewContainer` 属性：'
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Removing ExpandableCell from AddExpensesModal
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 `AddExpensesModal` 中移除 ExpandableCell：
- en: As the `DatePickerAndroid` and `Picker` components render as a modal on an Android
    device, I made some modifications to the `AddExpensesModal` component to remove
    the instances of `ExpandableCell`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `DatePickerAndroid` 和 `Picker` 组件在 Android 设备上渲染为模态，我对 `AddExpensesModal`
    组件进行了修改，以移除 `ExpandableCell` 的实例：
- en: 'This resulted in a new Android-specific file because of the large number of
    changes. I removed the `categoryPickerExpanded` and `datePickerExpanded` properties
    in state, as well as the importing of `DatePickerIOS` and `ExpandableCell`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了由于大量更改而产生了一个新的 Android 特定文件。我在状态中移除了 `categoryPickerExpanded` 和 `datePickerExpanded`
    属性，以及 `DatePickerIOS` 和 `ExpandableCell` 的导入：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'These two constants previously started with the prefix of `expandableCell`,
    but that prefix has been removed since the `ExpandableCell` component is not being
    used in the Android version of this component:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个常量之前以 `expandableCell` 为前缀，但由于 `ExpandableCell` 组件在此组件的 Android 版本中不再使用，因此已移除该前缀：
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `onRequestClose` callback is a required prop for `Modal` components on
    Android. The callback is executed when the user presses the back button on an
    Android device while the modal is open. In this case, I perform the same action
    as if the user pressed the Cancel button:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRequestClose` 回调是 Android 上 `Modal` 组件的必需属性。当用户在模态打开时按下 Android 设备上的返回按钮时，将执行此回调。在这种情况下，我执行的操作与用户按下取消按钮时的操作相同：'
- en: '[PRE61]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Android-specific styles for the two `TextInput` components were made to accommodate
    stylistic differences between Android and iOS applications:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为适应 Android 和 iOS 应用之间的样式差异，为两个 `TextInput` 组件创建了 Android 特定的样式：
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `View` that was previously styled to `expandableCellContainer` have been
    changed to `androidPickerContainers`. The preceding `Button` component calls `_renderDatePicker`
    when pressed, which handles the rendering of `DatePickerAndroid`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 之前被样式设置为 `expandableCellContainer` 的 `View` 已更改为 `androidPickerContainers`。前面的
    `Button` 组件在按下时会调用 `_renderDatePicker`，该函数处理 `DatePickerAndroid` 的渲染：
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Since the regular `Picker` component is not opened with an asynchronous function
    like `DatePickerAndroid`, I kept its logic intact:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于常规的 `Picker` 组件不是通过异步函数如 `DatePickerAndroid` 打开的，我保留了其逻辑不变：
- en: '[PRE64]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `_clearFieldsAndCloseModal` method was modified to remove the setting of
    the now-removed `ExpandableCell`-specific properties in state:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`_clearFieldsAndCloseModal` 方法被修改，以移除在状态中设置现在已删除的 `ExpandableCell` 特定属性：'
- en: '[PRE65]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Finally, `_renderDatePicker` was created to handle the asynchronous nature of
    the `DatePickerAndroid` component.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建了 `_renderDatePicker` 来处理 `DatePickerAndroid` 组件的异步特性。
- en: 'In the Android version of the `AddExpensesModal` component, none of the iOS
    version''s methods were removed:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AddExpensesModal` 组件的 Android 版本中，没有移除 iOS 版本的任何方法：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Modifying Navigation for PreviousMonthsList
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 `PreviousMonthsList` 的导航：
- en: 'The next thing to do is modify the `push` method of `navigator` for Android:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是修改 Android 的 `navigator` 的 `push` 方法：
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: I made a styling adjustment for the `View` container that wraps around the rest
    of `PreviousMonthsList` for Android devices to keep the `ListView` just below
    the navigation bar on Android.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我对围绕 `PreviousMonthsList` 的 `View` 容器进行了样式调整，以保持 `ListView` 在 Android 设备上紧挨着导航栏。
- en: 'There have been no changes to the original rendering method if on iOS:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 iOS 上，原始渲染方法没有发生变化：
- en: '[PRE68]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The Android method pushes to an `index` instead of a component, and the props
    passed to it are the exact same ones:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Android方法将内容推送到`index`而不是组件，传递给它的属性完全相同：
- en: '[PRE69]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After this section, we have successfully converted `Expenses` into an Android
    app that looks, feels, and behaves just like one!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之后，我们已经成功地将`Expenses`转换为了一个看起来、感觉和表现都像Android应用程序的Android应用程序！
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! You've finished the final chapter of *React Native by Example*.
    In this chapter, you learned to use more of the React Native library by working
    on components and APIs that we did not fit into previous apps in the book.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了《React Native by Example》的最后一章。在本章中，你通过在组件和API上工作，学习了更多React Native库的使用，这些组件和API我们没有在书中的前几个应用程序中介绍。
- en: Specifically, you built a playground app where you learned how to use the `fetch`
    API to make requests to external resources for data and gained control of the
    `Vibration` API to control the vibration motor of a user's device.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你构建了一个游乐场应用程序，在那里你学习了如何使用`fetch` API对外部资源进行数据请求，并掌握了控制用户设备振动马达的`Vibration`
    API。
- en: Afterward, you used the `Linking` API to open third-party applications on both
    iOS and Android, which allowed your app to talk to others. Then, you built a `Slider`
    component that lets users select a value between two predetermined ones.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你使用了`Linking` API在iOS和Android上打开第三方应用程序，这使得你的应用程序能够与其他应用程序通信。然后，你构建了一个`Slider`组件，允许用户在两个预定的值之间选择一个值。
- en: Finishing the playground app, you created `Buttons` to open an `ActionSheetIOS`
    overlay that presents options for your users to interact with and allowed your
    users to share content from your app using the Share sheet. As a finishing touch,
    you made use of the `Geolocation` API to grab your user's location data.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 完成游乐场应用程序后，你创建了`Buttons`来打开一个`ActionSheetIOS`覆盖层，向用户提供交互选项，并允许用户通过共享表单从你的应用程序中分享内容。作为最后的润色，你使用了`Geolocation`
    API来获取用户的位置数据。
- en: In the last section, we converted the app to Android. We started by ensuring
    that the vector icon library was imported via Gradle, swapped out the iOS-specific
    tabbed navigation for Android's drawer and toolbar combination, replaced `NavigatorIOS`-specific
    logic with `Navigator`, replaced the progress indicator with an Android-specific
    one, and then tweaked the rest of our components to have the look and feel of
    an Android app.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将应用程序转换为Android版本。我们首先确保通过Gradle导入矢量图标库，用Android的抽屉和工具栏组合替换了iOS特定的标签导航，用`Navigator`替换了`NavigatorIOS`特定的逻辑，用Android特定的进度指示器替换了进度指示器，然后调整了其余组件以具有Android应用程序的外观和感觉。
