- en: '*Chapter 4*: Building a Server-Side-Rendered Community Feed Using Next.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：使用Next.js构建服务器端渲染的社区信息流'
- en: So far, you've learned how React applications are typically **Single-Page Applications**
    (**SPAs**) and can be kickstarted using Create React App. This means the application
    is rendered on the client side, making it load in the browser when the user visits
    your application. But did you know React also supports **Server-Side Rendering**
    (**SSR**), as you might remember from back in the old days when code only rendered
    from a server?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了React应用程序通常是**单页应用程序**（**SPAs**），并且可以使用Create React App启动。这意味着应用程序在客户端渲染，当用户访问你的应用程序时在浏览器中加载。但你是否知道React也支持**服务器端渲染**（**SSR**），就像你可能记得的那样，在代码仅从服务器渲染的旧日子里？
- en: In this chapter, you'll learn how to create an application that has components
    dynamically loaded from the server instead of the browser. To enable SSR, we'll
    be using Next.js instead of Create React App. Next.js is a framework for React
    applications and adds additional features to React. If you're interested in **Search
    Engine Optimization** (**SEO**), SSR comes with the advantage that we can add
    metadata to the application so it can be better indexed by search engines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何创建一个从服务器动态加载组件的应用程序，而不是从浏览器加载。为了启用SSR（服务器端渲染），我们将使用Next.js而不是Create
    React App。Next.js是一个用于React应用程序的框架，并为React添加了额外的功能。如果你对**搜索引擎优化**（**SEO**）感兴趣，SSR具有以下优势：我们可以向应用程序添加元数据，使其能够被搜索引擎更好地索引。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up Next.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Next.js
- en: Server-side rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: SEO in React
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的SEO
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a community feed application using Next.js that
    supports SSR and therefore is loaded from the server rather than the browser.
    Also, the application is optimized for search engines.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Next.js创建一个支持SSR的社区信息流应用程序，因此它从服务器加载而不是从浏览器加载。此外，该应用程序针对搜索引擎进行了优化。
- en: The build time is 2 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为2小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter04).
    Also, this project uses the publicly available Stack Overflow API to fill the
    application with data. This is done by fetching questions that are posted to Stack
    Overflow. More information about this API can be found at: [https://api.stackexchange.com/docs/](https://api.stackexchange.com/docs/).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码也可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter04)。此外，该项目使用公开可用的Stack
    Overflow API来填充应用程序的数据。这是通过获取发布到Stack Overflow的问题来完成的。有关此API的更多信息，请参阅：[https://api.stackexchange.com/docs/](https://api.stackexchange.com/docs/)。
- en: Community feed application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区信息流应用程序
- en: In this section, you'll build a community feed application with Next.js that
    supports SSR. Next.js goes beyond the functionalities of Create React App, by
    delivering a framework to build React applications quickly. It has built-in features
    for routing, SEO, SSR, and much more, as you'll learn in this chapter. In this
    community feed, you can see an overview of recent questions on Stack Overflow
    that have the `reactjs` tag, and you can click on them to see more information
    and the answers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用Next.js构建一个支持SSR的社区信息流应用程序。Next.js超越了Create React App的功能，提供了一个快速构建React应用程序的框架。它内置了路由、SEO、SSR等功能，你将在本章中了解到。在这个社区信息流中，你可以看到带有`reactjs`标签的最近问题的概述，你可以点击它们来查看更多信息以及答案。
- en: Setting up Next.js
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Next.js
- en: In previous chapters, we used Create React App to run a React application. Although
    Create React App is a good starting point for most React applications, it doesn't
    support SSR. Luckily, Next.js does offer this feature as it's considered a framework
    for React. In this chapter, we'll be using the latest stable version of Next.js,
    which is version 12.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了Create React App来运行React应用程序。虽然Create React App是大多数React应用程序的一个很好的起点，但它不支持SSR。幸运的是，Next.js确实提供了这个功能，因为它被认为是一个React框架。在本章中，我们将使用Next.js的最新稳定版本，即版本12。
- en: Installing Next.js
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Next.js
- en: 'To set up Next.js, we run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Next.js，我们运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll be asked to select a template, which is either the default starter app
    or a template that is created by the community. After selecting the default template,
    the `react`, `react-dom`, and `next` libraries will be installed, among others.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求选择一个模板，这可以是默认的启动应用程序或由社区创建的模板。在选择默认模板后，将安装 `react`、`react-dom` 和 `next`
    库等。
- en: 'After the installation is finished, we can move into the new `chapter-4` directory
    and run the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以进入新的 `chapter-4` 目录并运行以下命令：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will start the new Next.js application that will become available at `http://localhost:3000`.
    The default starter app will look something like the following application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个新的 Next.js 应用程序，该应用程序将在 `http://localhost:3000` 上可用。默认的启动应用程序将类似于以下应用程序：
- en: '![Figure 4.1 – The initial Next.js application](img/Figure_4.1_B17390.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 初始 Next.js 应用程序](img/Figure_4.1_B17390.jpg)'
- en: Figure 4.1 – The initial Next.js application
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 初始 Next.js 应用程序
- en: In this application, you can not only see what a Next.js application looks like
    but also find useful links to more sources to learn about Next.js and examples
    of how to deploy it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，您不仅可以看到 Next.js 应用程序的外观，还可以找到更多有用的链接，以了解 Next.js 以及如何部署它的示例。
- en: 'The application structure for a Next.js project is slightly different from
    how we structured our Create React App in the preceding chapters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 项目的应用程序结构与我们前面章节中创建的 Create React App 的结构略有不同：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding structure, you can see that there is again a directory called
    `pages` that will contain React components that will serve as a page. But different
    from Create React App, we don't need to set up `react-router` to serve the pages.
    Instead, Next.js automatically renders every component in that directory as a
    page. In this directory, we also find the `hello.js` file in the `api` directory.
    Next.js can also be used to create API endpoints, which we'll explore more in
    [*Chapter 7*](B17390_07_Final_NM_ePub.xhtml#_idTextAnchor090), *Build a Full Stack
    E-Commerce Application with Next.js and GraphQL*. Also, the CSS files for our
    components are put in the `styles` directory, where you'll find the `globals.css`
    file with global styling and `Home.module.css` with styling for a specific component.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，您可以再次看到一个名为 `pages` 的目录，该目录将包含作为页面的 React 组件。但与 Create React App 不同，我们不需要设置
    `react-router` 来服务页面。相反，Next.js 自动将此目录中的每个组件渲染为页面。在这个目录中，我们还在 `api` 目录中找到了 `hello.js`
    文件。Next.js 还可以用来创建 API 端点，我们将在 [*第 7 章*](B17390_07_Final_NM_ePub.xhtml#_idTextAnchor090)
    中进一步探讨，即使用 Next.js 和 GraphQL 构建全栈电子商务应用程序。此外，我们的组件的 CSS 文件放在 `styles` 目录中，您将找到具有全局样式的
    `globals.css` 文件以及具有特定组件样式的 `Home.module.css`。
- en: Adding styled-components
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 styled-components
- en: 'Before we set up the routing, let''s add `styled-components` to the project,
    which we''ve also used in the previous chapters. For this, we need to install
    `styled-components` by running the following commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置路由之前，让我们将 `styled-components` 添加到项目中，我们也在前面的章节中使用过它。为此，我们需要通过运行以下命令来安装
    `styled-components`：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will add the packages to our project so we can use them to create and style
    reusable components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加包到我们的项目中，我们可以使用它们来创建和样式化可重用组件。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Next.js uses the `styles` directory to store global and component-specific CSS
    files for styling. As we're using `styled-components` for styling instead, we
    don't have to add any new CSS files to this directory. If you're not using a library
    for styling with CSS-in-JS, you can place both global and component-level styling
    files in the `styles` directory instead.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 使用 `styles` 目录来存储全局和组件特定的 CSS 文件以进行样式化。由于我们使用 `styled-components` 进行样式化，因此我们不需要向此目录添加任何新的
    CSS 文件。如果您不使用 CSS-in-JS 的库进行样式化，则可以将全局和组件级别的样式文件放置在 `styles` 目录中。
- en: 'Setting up `styled-components` in Next.js is done slightly differently in comparison
    to Create React App:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 中设置 `styled-components` 与 Create React App 相比略有不同：
- en: 'In Next.js, a `Document` component wraps the `html`, `body`, and `head` tags
    and runs them through a so-called `renderPage` method to allow for SSR. We need
    to overwrite this `Document` component from a new file called `_document.js` in
    the `pages` folder:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Next.js 中，一个 `Document` 组件包裹 `html`、`body` 和 `head` 标签，并通过所谓的 `renderPage`
    方法运行它们，以允许进行 SSR。我们需要在 `pages` 文件夹中的新文件 `_document.js` 中重写这个 `Document` 组件：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code creates an instance of `ServerStyleSheet`, which `styled-components`
    uses to retrieve any styles found in all the components in our application. This
    is needed to create a stylesheet that can be injected into our server-side-rendered
    application later on. The `sheets.collectStyles` method collects all of the styles
    from our components, while `sheets.getElement()` generates the `style` tag, which
    we'll need to return as a prop called `styles`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个 `ServerStyleSheet` 实例，`styled-components` 使用它来检索我们应用程序中所有组件中找到的任何样式。这需要创建一个可以稍后注入到我们的服务器端渲染应用程序中的样式表。`sheets.collectStyles`
    方法收集我们组件中的所有样式，而 `sheets.getElement()` 生成 `style` 标签，我们需要将其作为名为 `styles` 的属性返回。
- en: 'To support SSR for `styled-components`, we also need to configure the `next.config.json`
    file in the root of the project. This file needs to hold the following configuration:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了支持 `styled-components` 的 SSR，我们还需要在项目根目录中配置 `next.config.json` 文件。此文件需要包含以下配置：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As with Next.js, we don''t have a global entry file for the application. We
    need a different place to add our global styling and components that we want to
    display on all pages, such as a header. These styling and component must be added
    to `_app.js` in our `pages` directory, which returns the component for the page
    that we''re currently visiting and any other component or styling that we return:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 Next.js 一样，我们没有为应用程序设置全局入口文件。我们需要一个不同的地方来添加我们想要在所有页面上显示的全局样式和组件，例如标题。这些样式和组件必须添加到
    `pages` 目录中的 `_app.js` 中，它返回我们当前访问的页面组件以及我们返回的任何其他组件或样式：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding file, we've deleted the line that imports the `styles/globals.css`
    file and replaced it with styling in `styled-components`. This means you can also
    safely delete the `globals.css` file from the `styles` directory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中，我们删除了导入 `styles/globals.css` 文件的行，并用 `styled-components` 中的样式替换了它。这意味着你也可以安全地从
    `styles` 目录中删除 `globals.css` 文件。
- en: 'This global styling is now present on all pages that we''ll create later in
    this Next.js application. But for starters, let''s create a `Header` component
    by adding a file called `Header.js` in a new directory called `components`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种全局样式现在将出现在我们将在 Next.js 应用程序中创建的所有页面上。但首先，让我们通过在名为 `components` 的新目录中添加一个名为
    `Header.js` 的文件来创建一个 `Header` 组件：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This component will return a header that will be used on every page, but we
    also need to add it to `_app.js` to be effective:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此组件将返回一个将在每个页面上使用的标题，但我们还需要将其添加到 `_app.js` 中才能生效：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You'll see what the headers look like in the next section when we add our first
    route to the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中添加第一个路由时，你将在下一节中看到标题的样式。
- en: We've added multiple new files that have global styling with `styled-components`,
    which supports SSR, and also a directory that holds reusable components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了多个新的文件，这些文件使用 `styled-components` 具有全局样式，支持 SSR，并且还有一个包含可重用组件的目录。
- en: With both Next.js and `styled-components` set up, we are ready to start developing
    with Next.js in the next section of this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 和 `styled-components` 设置完成后，我们就可以开始在本章下一节中使用 Next.js 进行开发了。
- en: Routing with Next.js
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Next.js 进行路由
- en: With the `react-router` package, we can add declarative routing to any React
    application, but you need to set up components that define which routes you want
    to add. With Next.js, the filesystem is being used for routing, starting at the
    `pages` directory. Every file and directory in `pages` can represent a route.
    You can check this by visiting the project at `http://localhost:3000`, where the
    contents of `index.js` are being rendered.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `react-router` 包，我们可以为任何 React 应用程序添加声明式路由，但你需要设置定义你想要添加的路由的组件。使用 Next.js，路由是通过文件系统实现的，从
    `pages` 目录开始。`pages` 目录中的每个文件和目录都可以代表一个路由。你可以通过访问项目在 `http://localhost:3000` 来检查这一点，其中
    `index.js` 的内容正在被渲染。
- en: 'If we, for example, wanted to add the new `/questions` route to the application,
    we''d need to create either a new file called `questions.js` or a directory called
    `questions` with an `index.js` file in `pages`. Let''s go with the second option
    and add the following code to this file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将新的 `/questions` 路由添加到应用程序中，我们需要创建一个名为 `questions.js` 的新文件或一个名为 `questions`
    的目录，并在 `pages` 中包含一个 `index.js` 文件。让我们选择第二种方案，并将以下代码添加到该文件中：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This new route has now become available at `http://localhost:3000/questions`
    where only a title is being rendered. As mentioned in the introduction of this
    chapter, we'll be using the Stack Overflow API to get the data for this application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这条新路由现在已在 `http://localhost:3000/questions` 上可用，此处只渲染标题。正如本章引言中提到的，我们将使用 Stack
    Overflow API 来获取此应用程序的数据。
- en: 'Before retrieving the data from the endpoint, we also need to create a component
    to render this data in. To do so, we need to create a new component that will
    be used to display a question. This new component can be created in a file called
    `Card.js` in the `components` directory with the following contents:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在从端点检索数据之前，我们还需要创建一个组件来渲染这些数据。为此，我们需要创建一个新的组件，该组件将用于显示问题。这个新组件可以创建在 `components`
    目录下的 `Card.js` 文件中，内容如下：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this component in place, let''s retrieve the data from the Stack Overflow
    API. From this API, we want to retrieve all the questions that are posted with
    the `reactjs` tag, using the following endpoint:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件就位后，让我们从 Stack Overflow API 获取数据。从这个 API 中，我们想要检索带有 `reactjs` 标签的所有问题，使用以下端点：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can find more information on this at [https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true](https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true](https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true)
    找到更多相关信息。
- en: This returns an array of objects under the `items` field, and from every object,
    we can get information about a question, such as the title and the number of answers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个在 `items` 字段下的对象数组，并且从每个对象中，我们可以获取有关问题的信息，例如标题和答案数量。
- en: 'We can retrieve the data from this endpoint and display it on the `/questions`
    route by making some additions to the `index.js` file in the `questions` directory
    in `pages`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对 `pages` 目录中 `questions` 目录下的 `index.js` 文件进行一些修改，从该端点检索数据并在 `/questions`
    路由上显示它：
- en: 'First, we need to add local state variables to the `Questions` component and
    add a `useEffect` Hook to fetch the data from the Stack Overflow API:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `Questions` 组件中添加本地状态变量，并添加一个 `useEffect` Hook 来从 Stack Overflow API
    获取数据：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After adding the data fetching logic, we need to add some more code to display
    the fields from the API on our page. We''re passing this data to our `Card` component
    to render it on the page:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加数据获取逻辑后，我们还需要添加一些代码来在页面上显示来自 API 的字段。我们将此数据传递给我们的 `Card` 组件以在页面上渲染它：
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you now visit the `/questions` route on `http://localhost:3000/questions`,
    you can see that a list of questions is being rendered together with the Header
    component, as you can see in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在访问 `http://localhost:3000/questions` 上的 `/questions` 路由，你可以看到问题列表正在与 Header
    组件一起渲染，如下面的截图所示：
- en: '![Figure 4.2 – Our application with Stack Overflow data](img/Figure_4.2_B17390.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 我们的带有 Stack Overflow 数据的应用程序](img/Figure_4.2_B17390.jpg)'
- en: Figure 4.2 – Our application with Stack Overflow data
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 我们的带有 Stack Overflow 数据的应用程序
- en: 'We''ll be handling SSR later, but before that, we need to add routes that support
    parameters. To create a route that supports a parameter, we need to create a file
    created in the same manner as the Questions component. The new route will display
    a specific question, information that we can also get from the Stack Overflow
    API. Again, the filesystem will be leading in creating the route:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后处理 SSR，但在那之前，我们需要添加支持参数的路由。要创建一个支持参数的路由，我们需要以与 Questions 组件相同的方式创建一个文件。新路由将显示特定问题，这些信息我们也可以从
    Stack Overflow API 获取。同样，文件系统将在创建路由时起主导作用：
- en: 'To create a new route with a parameter, we need to create a file called `[id].js`
    inside the `questions` directory. This file has the parameter name inside square
    brackets, and in this file, we can use a Hook from the Next.js routing library
    to get this parameter value:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个带有参数的新路由，我们需要在 `questions` 目录内创建一个名为 `[id].js` 的文件。此文件包含参数名称，方括号内，并且在此文件中，我们可以使用
    Next.js 路由库中的 Hook 来获取此参数值：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By visiting `http://localhost:3000/questions/123`, you can see that the parameter
    that we've added has become visible on the screen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问 `http://localhost:3000/questions/123`，你可以看到我们添加的参数已经显示在屏幕上。
- en: 'In the `QuestionDetail` component, we can import the `Card` component and we
    can use the Stack Overflow API to fetch data for a specific question. For this,
    we need to add both data fetching logic and elements to render the data to the
    `[id].js` file in the `questions` directory that we created in the previous step:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `QuestionDetail` 组件中，我们可以导入 `Card` 组件，并可以使用 Stack Overflow API 获取特定问题的数据。为此，我们需要在之前步骤中创建的
    `questions` 目录下的 `[id].js` 文件中添加数据获取逻辑和渲染数据的元素：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After adding the data fetching logic, the `Card` component can be returned
    with the question information passed to it as props:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加数据获取逻辑后，我们可以将 `Card` 组件返回，并将作为 props 传递给它的问题信息：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The API endpoint that gets a question by its identifier returns an array, as
    it expects multiple IDs at once. Therefore, we need to get the first item that's
    returned by the endpoint as we only provide one ID.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其标识符获取问题的 API 端点返回一个数组，因为它期望一次性提供多个 ID。因此，我们需要获取端点返回的第一个项目，因为我们只提供了一个 ID。
- en: 'To get to a specific question, you need to have the ID of the question. This
    is best done from the `Questions` component where we can import a `Link` component
    from the routing library of Next.js. Every `Link` component needs to wrap a component
    that''s able to do routing, so we''ll add a styled `a` element inside it. Also,
    the elements used to display the questions will be replaced by the `Card` component
    that we created before:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问特定问题，你需要有该问题的 ID。这最好从 `Questions` 组件中完成，我们可以从 Next.js 的路由库中导入一个 `Link` 组件。每个
    `Link` 组件都需要包裹一个能够进行路由的组件，因此我们将在其中添加一个样式化的 `a` 元素。此外，用于显示问题的元素将被我们之前创建的 `Card`
    组件所替换：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you might notice when visiting `http://localhost:3000/questions`, the `Card`
    components are now clickable and link to a new page showing the question you've
    just clicked on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问 `http://localhost:3000/questions` 时，你可能会注意到 `Card` 组件现在是可点击的，并且会链接到一个新页面，显示你刚刚点击的问题。
- en: 'Finally, we want the basic `/` route to also show the `Questions` component.
    We can do this by importing this component inside `/pages/index.js` and having
    it returned from there:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望基本的 `/` 路由也能显示 `Questions` 组件。我们可以通过在 `/pages/index.js` 中导入这个组件并从那里返回它来实现这一点：
- en: '[PRE18]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The application will now return a list of questions on both the `/` and `/questions`
    routes, and is able to display a specific question when you click on any of the
    questions from these routes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在将在 `/` 和 `/questions` 路由上返回问题列表，并且能够在你点击这些路由中的任何问题时代码显示特定问题：
- en: '![Figure 4.3 – Our application with basic styling and dynamic routes'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 带有基本样式和动态路由的应用程序'
- en: '](img/Figure_4.3_B17390.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B17390.jpg)'
- en: Figure 4.3 – Our application with basic styling and dynamic routes
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 带有基本样式和动态路由的应用程序
- en: Besides routing using parameters, we can also add routing using a query string
    for features such as pagination. This will be shown in the next part of this section,
    about routing with Next.js.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用参数进行路由外，我们还可以添加使用查询字符串的路由，例如分页功能。这将在本节下一部分中展示，关于使用 Next.js 的路由。
- en: Handling query strings
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理查询字符串
- en: Being able to navigate to individual questions is only one piece of the cake
    when you want to add routing to a project, and pagination could be another one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在项目中添加路由时，能够导航到单个问题只是其中的一部分，分页可能是另一部分。
- en: The Stack Overflow API already has support for pagination, which you can see
    if you look at the API response. The object that is being returned when you call
    the endpoint that is described on https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true
    has a field called `has_more`. If this field has the `true` value, you can request
    more questions by adding the `page` query string to the API request.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Stack Overflow API 已经支持分页，如果你查看 API 响应，就可以看到这一点。当你调用描述在 https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true
    的端点时返回的对象有一个名为 `has_more` 的字段。如果这个字段有 `true` 值，你可以在 API 请求中添加 `page` 查询字符串来请求更多问题。
- en: 'Just as we got the parameters from the URL with the `useRouter` Hook from Next.js,
    we can also get the query strings with this Hook. To add pagination to the `Questions`
    component, we need to make the following changes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们从 Next.js 的 `useRouter` 钩子中获取 URL 参数一样，我们也可以使用这个钩子来获取查询字符串。为了给 `Questions`
    组件添加分页功能，我们需要进行以下修改：
- en: 'In the `Questions` page component in `pages/questions/index.js`, we need to
    import the `useRouter` Hook and get the query strings from the URL:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pages/questions/index.js`中的`Questions`页面组件中，我们需要导入`useRouter`钩子并从URL中获取查询字符串：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `page` constant can then be appended to the endpoint to retrieve the questions
    from the Stack Overflow API:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，可以将`page`常量附加到端点以从Stack Overflow API获取问题：
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can test whether this is working by changing the query string for `page`
    to different numbers, such as `http://localhost:3000/questions?page=1` or `http://localhost:3000/questions?page=3`.
    To make the application more user-friendly, let's add pagination buttons to the
    bottom of the page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改`page`查询字符串为不同的数字来测试这是否正常工作，例如`http://localhost:3000/questions?page=1`或`http://localhost:3000/questions?page=3`。为了使应用程序更友好，让我们在页面底部添加分页按钮。
- en: 'Create the `Pagination` component inside the `components` directory, which
    holds two `Link` components from Next.js. The component will display a link to
    the previous page if the current page number is above 1 and will also show a link
    to the next page if more pages are available:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`目录内创建`Pagination`组件，该目录包含两个来自Next.js的`Link`组件。该组件将在当前页码大于1时显示上一页的链接，如果还有更多页面，也会显示下一页的链接：
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We need to import this new `Pagination` component inside the `Questions` page
    component, but we also need to retrieve the value for `hasMore` from the Stack
    Overflow API:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`Questions`页面组件中导入这个新的`Pagination`组件，同时还需要从Stack Overflow API获取`hasMore`的值：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, the `Pagination` component must be rendered at the end of the `Questions`
    component. Make sure to also pass the `currentPage` and `hasMore` props to the
    component:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，`Pagination`组件必须在`Questions`组件的末尾渲染。请确保也将`currentPage`和`hasMore`属性传递给组件：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we want the user to not be able to navigate to a page that doesn''t
    exist. So, in the `Pagination` component, make the following changes to disable
    the previous or next button if there is no page available:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望用户无法导航到不存在的页面。因此，在`Pagination`组件中，如果没有页面可用，请禁用上一页或下一页按钮：
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You have now implemented the parsing of the query string to dynamically change
    the route for your application. With the addition of the `Pagination` component,
    both the `/` and `/questions` routes will look something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经实现了查询字符串的解析，以便动态更改应用程序的路由。随着`Pagination`组件的添加，`/`和`/questions`路由将看起来像这样：
- en: '![Figure 4.4 – The application after adding pagination'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 添加分页后的应用程序'
- en: '](img/Figure_4.4_B17390.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B17390.jpg)'
- en: Figure 4.4 – The application after adding pagination
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 添加分页后的应用程序
- en: In the next section, you'll explore another thing you can do with React in combination
    with Next.js, SRR, which enables you to serve your application from the server
    instead of rendering it at runtime.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将探索你可以使用React结合Next.js和SRR（服务器端渲染）一起做的另一件事，这使你能够从服务器而不是在运行时渲染你的应用程序。
- en: Enabling SSR
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用SSR
- en: Using SSR can be helpful if you're building an application that needs to render
    very quickly or when you want certain information to be loaded before the web
    page is visible. Although most search engines are now able to render SPAs, this
    can still be an improvement, for example, if you want users to share your page
    on social media or when you want to enhance the performance of your application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个需要非常快速渲染或希望在网页可见之前加载某些信息的应用程序，使用SSR可能会有所帮助。尽管现在大多数搜索引擎都能够渲染SPA，但这仍然是一个改进，例如，如果你想用户在社交媒体上分享你的页面，或者你想提高应用程序的性能。
- en: Fetching data server side with Next.js
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Next.js在服务器端获取数据
- en: There is no standard pattern to enable SSR for your React application, but luckily,
    Next.js supports multiple ways to do data fetching, such as dynamically from the
    client, server side on every request, or statically during build time. The first
    way is what we've done in this chapter so far and in this section, we'll be requesting
    our data server side on every request. For this, the Next.js `getServerSideProps`
    method will be used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的React应用程序启用SSR没有标准模式，但幸运的是，Next.js支持多种数据获取方式，例如从客户端动态获取，在每个请求的服务器端获取，或在构建时静态获取。我们到目前为止已经使用第一种方式，在本节中，我们将请求在每个请求的服务器端获取数据。为此，将使用Next.js的`getServerSideProps`方法。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Next.js also offers the `getStaticProps` and `getStaticPaths` methods to generate
    the content of your application statically at build time. This is especially useful
    if your content doesn't change that often and you want to serve your website as
    fast as possible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 还提供了 `getStaticProps` 和 `getStaticPaths` 方法，在构建时生成应用程序的内容。如果你的内容不经常更改，并且你希望尽可能快地提供你的网站，这特别有用。
- en: 'At the beginning of this chapter, we already set up `styled-components` in
    such a way that it will support SSR, so we just have to alter how we do data fetching
    to enable it for the entire application. Therefore, we need to refactor our `Questions`
    component so that it will get the data from the Stack Overflow API on the server
    side instead of dynamically from the client:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们已经以支持 SSR 的方式设置了 `styled-components`，所以我们只需要改变我们进行数据获取的方式，以便在整个应用程序中启用它。因此，我们需要重构我们的
    `Questions` 组件，使其能够在服务器端从 Stack Overflow API 获取数据，而不是从客户端动态获取：
- en: 'In the `Questions` page component, we no longer have to import the `useState`
    and `useEffect` Hooks to set up state management and data fetching, so these can
    be removed. The `useRouter` Hook from Next.js can also be deleted:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Questions` 页面组件中，我们不再需要导入 `useState` 和 `useEffect` 钩子来设置状态管理和数据获取，因此这些可以删除。Next.js
    的 `useRouter` 钩子也可以删除：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead, the `getServerSideProps` method needs to be used to do the data fetching
    on the server side. As the data is then not retrieved by the client, we no longer
    need to set local state variables or life cycles to keep track of changes in the
    data. The data will already be there once we load our React application in the
    browser:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，需要使用 `getServerSideProps` 方法在服务器端进行数据获取。由于数据不是由客户端检索，我们不再需要设置本地状态变量或生命周期来跟踪数据的变化。一旦我们在浏览器中加载我们的
    React 应用程序，数据就已经准备好了：
- en: '[PRE26]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this method, the value for `page` is retrieved from a constant called `context`,
    which is passed to `getServerSideProps` by Next.js and gets the page from the
    router. Using this value, we can do the data fetching in the same way as we did
    before in the life cycle. Instead of storing the data in local state variables,
    we're now passing it as props to the `Questions` component by returning it from
    the method we created.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，`page` 的值是从一个名为 `context` 的常量中检索的，这个常量是通过 Next.js 传递给 `getServerSideProps`
    的，并从路由器中获取页面。使用这个值，我们可以像之前在生命周期中做的那样进行数据获取。现在，我们不是将数据存储在本地状态变量中，而是通过从我们创建的方法返回它，将其作为属性传递给
    `Questions` 组件。
- en: 'Our `Questions` page component can use these props to render our list of questions
    in the browser. As the data is retrieved from the server side before passing the
    application to the client, we no longer have to set a loading indicator to wait
    for the data to be fetched:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `Questions` 页面组件可以使用这些属性在浏览器中渲染我们的问题列表。由于数据是在将应用程序传递给客户端之前从服务器端检索的，我们不再需要设置一个加载指示器来等待数据被检索：
- en: '[PRE27]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can check this by going to `http://localhost:3000/questions` and seeing
    that the questions are no longer being retrieved on the client side but on the
    server side. In the **Network** tab, there''s no request made to the Stack Overflow
    API, while the questions are being rendered in the browsers. You can also verify
    this by inspecting the page source:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 `http://localhost:3000/questions` 来检查这一点，你会看到问题不再是在客户端检索，而是在服务器端检索。在
    **网络** 选项卡中，没有对 Stack Overflow API 的请求，而问题正在浏览器中渲染。你还可以通过检查页面源代码来验证这一点：
- en: '![Figure 4.5 – SSR application using Next.js'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 使用 Next.js 的 SSR 应用程序'
- en: '](img/Figure_4.5_B17390.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.5_B17390.jpg)'
- en: Figure 4.5 – SSR application using Next.js
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 使用 Next.js 的 SSR 应用程序
- en: 'However, the `Questions` page component is also imported in `pages/index.js`
    and returned there. But opening our main `/` route at `http://localhost:3000/`
    doesn''t show any questions. This is because this file doesn''t have a `getServerSideProps`
    to get the data. Therefore, we need to create this method in `pages/index.js`
    as well and have it return the method that we can import from `pages/questions/index.js`
    so that we don''t have to duplicate the data fetching logic. The `Home` component
    in this file can then get the data from the props and pass it to the `Questions`
    component:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Questions` 页面组件也被导入到 `pages/index.js` 中，并在那里返回。但是，在 `http://localhost:3000/`
    打开我们的主要 `/` 路由时，并没有显示任何问题。这是因为这个文件没有 `getServerSideProps` 来获取数据。因此，我们还需要在 `pages/index.js`
    中创建这个方法，并让它返回我们可以从 `pages/questions/index.js` 导入的方法，这样我们就不必重复数据获取逻辑。这个文件中的 `Home`
    组件可以从此处获取数据，并将其传递给 `Questions` 组件：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After making this change, both the `/` and `/questions` routes will have SSR
    enabled. Another advantage of SSR is that your application can be discovered by
    search engines more effectively. In the next part of this section, you'll add
    the tags that make your application discoverable by these engines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此更改后，`/` 和 `/questions` 路由都将启用SSR。SSR的另一个优点是您的应用程序可以更有效地被搜索引擎发现。在本节的下一部分，您将添加使您的应用程序可以被这些引擎发现的标签。
- en: Adding head tags for SEO
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标题标签以进行SEO
- en: Assuming you want your application to be indexed by search engines, you need
    to set head tags for the crawlers to identify the content on your page. This is
    something you want to do dynamically for each route, as each route will have different
    content.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望您的应用程序被搜索引擎索引，您需要为爬虫设置标题标签以识别您页面上的内容。这是您希望为每个路由动态执行的事情，因为每个路由将具有不同的内容。
- en: 'Next.js can define the head tags in any component that is rendered by your
    application by importing `Head` from `next/head`. If nested, the lowest definition
    of a `Head` component in the component tree will be used. That''s why we can create
    a `Head` component in our `Header` component for all routes and in each of the
    components that is being rendered on a route:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js可以通过从`next/head`导入`Head`来定义任何由您的应用程序渲染的组件中的标题标签。如果嵌套，组件树中`Head`组件的最低定义将被使用。这就是为什么我们可以在`Header`组件中为所有路由以及在每个路由上被渲染的组件创建一个`Head`组件：
- en: 'Import the `Head` component in the `components/Header.js` file, and create
    a `Head` component that sets `title` and a meta description:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components/Header.js`文件中导入`Head`组件，并创建一个设置`title`和元描述的`Head`组件：
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, create a `Head` component in `pages/questions/index.js` that only sets
    a title for this route, so it will use the meta description of the `Header` component:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还在`pages/questions/index.js`中创建一个`Head`组件，只为该路由设置标题，因此它将使用`Header`组件的元描述：
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Do the same for the `pages/questions/[id].js` file, where you can also take
    the title of the question to make the page title more dynamic:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`pages/questions/[id].js`文件，您也可以使用问题的标题来使页面标题更加动态：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These head tags will now be used when you're running your application on both
    the server and the client side, making your application more suitable for being
    indexed by search engines, which improves your SEO.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标题标签现在将在您在服务器和客户端上运行应用程序时使用，使您的应用程序更适合被搜索引擎索引，从而提高您的SEO。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've learned how to use Next.js as an alternative to Create
    React App. Next.js is a framework to create React applications, without having
    to add configuration for compiling and building your code or to handle features
    such as routing and data fetching. The project you created in this chapter supports
    SSR, as this is built in by Next.js. Also, we've added dynamic head tags to the
    application for SEO purposes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了如何将Next.js作为Create React App的替代品使用。Next.js是一个用于创建React应用程序的框架，无需添加编译和构建代码的配置，也无需处理诸如路由和数据获取等功能。您在本章中创建的项目支持SSR，因为这是Next.js内置的。此外，我们还为应用程序添加了动态标题标签，以提高SEO。
- en: After completing this chapter, you must already feel like an expert with React!
    The next chapter will take your skill to the next level as you'll learn how to
    handle state management using the context API. With the context API, you can share
    the state and data between multiple components in your application, no matter
    whether they're direct children of the parent component or not.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您应该已经感觉自己像一名React专家！下一章将把您的技能提升到新的水平，因为您将学习如何使用上下文API来处理状态管理。使用上下文API，您可以在您的应用程序中共享状态和数据，无论这些组件是否是父组件的直接子组件。
- en: Further reading
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information on Next.js, you can refer to [https://nextjs.org/docs/](https://nextjs.org/docs/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Next.js的更多信息，您可以参考[https://nextjs.org/docs/](https://nextjs.org/docs/)。
