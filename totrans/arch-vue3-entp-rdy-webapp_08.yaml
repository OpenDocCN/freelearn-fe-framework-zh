- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and What to Test in Vue.js 3
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned the nitty-gritty details of the steps involved
    in dockerizing your Vue.js 3 project. In addition, you learned about the best
    practices and industry standards to dockerize an enterprise Vue.js 3 web application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will explore the concept of software testing. You will
    learn what to test from an array of available components and methods. In addition,
    you will learn about best practices and industry standards related to testing
    libraries and how to integrate them with Vue.js 3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Overview of testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in software engineering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a basic Vue.js 3 app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component testing in Vue.js 3
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this chapter, I recommend you read through [*Chapter 7*](B17237_07.xhtml#_idTextAnchor230),
    *Dockerizing a Vue 3 App*, first, where we took a more practical approach by dockerizing
    a full stack web application using Docker Compose. We will be using the application
    a lot in this chapter to learn about Vue.js 3 enterprise testing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: All the code files for this chapter can be found at [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Overview of testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anyone who has studied computer science should be familiar with the concept
    of SDLC. If you are not aware, **SDLC** stands for **software development** **life
    cycle**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Synopsys ([https://www.synopsys.com/glossary/what-is-sdlc.html](https://www.synopsys.com/glossary/what-is-sdlc.html))
    provides the following definition:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Software Development Life Cycle (SDLC) is a structured process that enables
    the production of high-quality, low-cost software, in the shortest possible production
    time. The goal of the SDLC is to produce superior software that meets and exceeds
    all customer expectations and demands.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: If you explore the SDLC further, you’ll see that it defines and outlines eight
    detailed plans with stages or phases that quality and enterprise-level software
    must pass through to produce software that meets and exceeds all customer expectations
    and demands.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Each stage is crucial, including planning, coding, building, and testing. However,
    the testing phase is particularly important, especially when you need to build
    a bug- or defect-free enterprise-level application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate further, the testing phase evaluates the created software against
    any bugs, any potential errors, and the requirements of the software from the
    planning phase.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see what we mean by software testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: What is software testing?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software testing is the method of checking whether the software in production
    matches the expected requirements and, most importantly, whether it is defect
    free. The method used to carry out software testing differs depending on the organization.
    However, the method is divided into manual and automated processes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Individuals and organizations will have different names for software testing.
    It can also be categorized as whitebox or blackbox testing. However, the end result
    of any approach is always the same, which is identifying errors, gaps, or missing
    requirements in contrast to actual requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Blackbox testing involves testing a system without knowing the internal workings
    of the system, while whitebox testing is an approach of testing that allows the
    tester to inspect and verify the internal workings of the system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the names, terms, or categories used when referring to software
    testing, in simple terms, software testing means the verification of the **Application
    Under Test** (**AUT**), and it’s a critical and crucial stage in producing high-quality
    enterprise-level software.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go through the importance of software testing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Why software testing is important
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The need to incorporate software testing into your application development pipeline
    cannot be overemphasized. It is as important as the planning and development phases
    in the SDLC. In fact, without a proper software testing strategy, it is likely
    that the end product of the software under development will be filled with bugs,
    errors, and unmet software requirements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Software testing is important because software bugs could be expensive and also
    very dangerous to businesses, and organizations at large. Over the years, there
    have been numerous examples of potential software bugs and monetary losses.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in April 2015, the Bloomberg terminal in London crashed due to
    a software glitch that affected more than 300,000 traders in financial markets.
    It forced the UK government to postpone a 3 billion pound debt sale, according
    to The Guardian ([https://www.theguardian.com/business/2015/apr/17/uk-halts-bond-sale-bloomberg-terminals-crash-worldwide](https://www.theguardian.com/business/2015/apr/17/uk-halts-bond-sale-bloomberg-terminals-crash-worldwide)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Also, according to Windows Report ([https://windowsreport.com/windows-10-vulnerability/](https://windowsreport.com/windows-10-vulnerability/)),
    there was a vulnerability in Windows 10 that enabled users to escape from security
    sandboxes through a flaw in the win32k system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: There have been many vulnerability reports on different malicious attempts on
    businesses that have impacted revenue or monetary value, of which some could be
    avoided with proper software testing. This indicates that software testing is
    a very important stage in the SDLC.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Though software testing costs money, I’m sure you will agree with me that the
    cost is nothing compared to the millions per year in development and support companies
    would have to spend if they don’t have a good testing technique and QA processes
    in place.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然软件测试需要资金，但我相信您会同意我的观点，与如果没有良好的测试技术和QA流程，开发和支持公司每年要花费的数百万美元相比，这个成本微不足道。
- en: 'In addition, having early software testing in place uncovers problems before
    the products go to market. Early testing also uncovers different defects, including
    but not limited to the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在产品上市之前进行早期软件测试可以揭示问题。早期测试还可以揭示不同的缺陷，包括但不限于以下内容：
- en: Architectural flaws
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构缺陷
- en: Poor design decisions
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计决策不当
- en: Invalid or incorrect functionality
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效或不正确的功能
- en: Security vulnerabilities
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全漏洞
- en: Scalability issues
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性问题
- en: Having proper testing processes in place along the software development pipeline
    improves software reliability and means high-quality applications are delivered
    with few errors. In the next section, we will further explore the benefits of
    software testing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发流程中实施适当的测试流程可以提高软件可靠性，意味着高质量的应用程序在错误很少的情况下交付。在下一节中，我们将进一步探讨软件测试的好处。
- en: The benefits of software testing
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件测试的好处
- en: 'In the previous section, we explained why enterprise applications need to include
    testing in their development pipeline. In this section, we will explore the benefits
    of having a proper software testing process. We will go through the following
    points in detail:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们解释了为什么企业应用需要在他们的开发流程中包含测试。在本节中，我们将探讨拥有适当的软件测试流程的好处。我们将详细讨论以下点：
- en: Helps in saving money
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助节省资金
- en: Satisfaction of customers
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足客户需求
- en: Enhancing the development pipeline
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强开发流程
- en: Quality of product
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品质量
- en: Security
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Helps in saving money
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帮助节省资金
- en: Launching buggy software to market can end up being more expensive than creating
    the entire software. As stated previously, there have been many cases of company’s
    monetary value reducing due to software defects and error-prone software.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将有缺陷的软件推向市场可能比创建整个软件更昂贵。如前所述，由于软件缺陷和易出错的软件，许多公司的货币价值已经减少。
- en: This problem can be curtailed to some extent if there is a proper software testing
    process built into the development pipeline to detect and rectify these errors
    before moving on to the next stage of the pipeline.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在开发流程中构建适当的软件测试过程来检测和纠正这些错误，那么这个问题可以在一定程度上得到缓解。
- en: Satisfaction of customers
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 满足客户需求
- en: For users of your enterprise application to be satisfied, the software must
    work properly and in accordance with the requirements.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您的企业应用用户满意，软件必须正常工作，并符合要求。
- en: Therefore, before launching the software to market, an acceptance test must
    be conducted to ensure that the product works in accordance with the requirements
    and also to get a sense of how users will access and use the product day to day.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在将软件推向市场之前，必须进行验收测试，以确保产品符合要求，并了解用户将如何日常访问和使用产品。
- en: While in the testing phase, if any issues or bugs are detected, the software
    under test can easily be moved back to the development stage instead of finding
    out about the problems in the production stage where real users are interacting
    with the application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试阶段，如果发现任何问题或错误，测试中的软件可以轻松地退回到开发阶段，而不是在生产阶段发现问题，那时真实用户正在与应用程序交互。
- en: Enhancing the development pipeline
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强开发流程
- en: Including software testing in the development pipeline creates an enhanced development
    pipeline. Also, it is an industry-standard practice to include software testing.
    In addition, it is simpler for developers to fix errors in the development stage
    than in the production stage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件测试纳入开发流程可以创建一个增强的开发流程。此外，将软件测试纳入流程是行业标准做法。另外，开发者修复开发阶段的错误比在生产阶段修复要简单。
- en: Thus, incorporating the software testing process in the development pipeline
    reduces the risk of launching error-prone software to market and enhances the
    development pipeline.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将软件测试过程纳入开发流程可以降低将存在缺陷的软件推向市场的风险，并增强开发流程。
- en: Quality of product
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品质量
- en: When the quality of the product drops, the company might lose customers, resulting
    in a loss of revenue. However, one of the attributes of low-quality software is
    an untested and error-prone software application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if there is a proper software testing process built into the development
    pipeline, most errors, bugs, and defects will be detected and fixed before production,
    thereby producing quality software.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to OWASP ([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)),
    security should be an integral part of every software. Not considering it could
    result in a reduction in the monetary value of the business.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Software testing is one way to detect security loopholes and fix them in the
    development stage. If a product has undergone testing, the user can be assured
    that they are receiving a reliable product. They will be assured that their personal
    details are safe. Users can receive products that are more likely to be free from
    vulnerabilities with the aid of software testing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we covered some benefits you can derive from implementing
    software testing into your pipeline when building enterprise-ready applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the different types of testing and different
    strategies you can integrate into your development pipeline.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Testing in software engineering
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the previous section, software testing is an integral part of the
    SDLC, and therefore, according to ANSI/IEEE 1059, testing in software engineering
    is a method of evaluating the software under test to discover whether it meets
    the requirements, as well as whether it is error, bug, and defect free.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The process involves evaluating the features of the software under test for
    requirements in terms of any missing requirements, bugs or errors, security, reliability,
    and performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the benefits of testing and why software testing
    is important, and in the next section, we will understand different types of software
    testing. We will explore what to test and how to write basic unit and integration
    tests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Types of software testing
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software testing has been given different names. There are over 150 types of
    software testing according to Guru99 ([https://www.guru99.com/types-of-software-testing.html](https://www.guru99.com/types-of-software-testing.html)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we are going to classify software testing into two main categories
    and then explore each of the categories and the different types within them. The
    following are the two main categories:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Functional software testing
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance software testing (non-functional)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the high-level classification of software testing
    types:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A high-level classification of software testing (source: softwaretestinghelp)](img/Figure_8.01_B17237.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1 – A high-level classification of software testing (source: softwaretestinghelp)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore more about the different categories of software testing on
    Youtube. However, we will only focus on three main categories of functional software
    testing, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This basic approach to software testing is carried out by a programmer to test
    the unit or smallest part of the program. It helps developers to know whether
    individual units of code are working properly or not.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of testing focuses on the construction and design of the software.
    You need to see whether the integrated units are working without errors or not.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: End-to-end testing is a methodology that assesses the working order of a complex
    product in a start-to-finish process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, we will focus on exploring these different types of
    testing individually. Nevertheless, you can explore more than 150 different types
    of software testing from Guru99 ([https://www.guru99.com/types-of-software-testing.html](https://www.guru99.com/types-of-software-testing.html)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: In summary, now that we know how important software testing is and the different
    types of software testing, how do we know what to test in a large enterprise application?
    In the next section, we are going to explore what to test and how to integrate
    a testing pipeline into the development workflow.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular question among software teams is *what should we test and what should
    we not test?* In this section, we will explore the different things you should
    and shouldn’t test when considering software tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: We will first explore different test strategies to employ when integrating software
    testing into your development workflow.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Testing strategy
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best testing strategy to implement in your enterprise application is the
    combination of normal (manual) testing and automated testing. In addition, normal
    testing should be done more extensively by the **Quality Assurance** (**QA**)
    team.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: To explain this further, when automated testing is written and implemented successfully,
    we usually program it to look for fundamental errors and edge cases that may not
    properly assimilate how a real customer will interact with the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: What you should test
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As much as software testing is important to the efficiency of an enterprise-ready
    application, knowing what to test is paramount so that developers don’t waste
    time testing the wrong things.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of some of the things you can look for when testing
    your enterprise project for errors, bugs, and defects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**Passed parameters**: The collection of parameters or arguments passed into
    the method or function to make sure that it has not changed. In some cases, the
    data type of the parameter remains the same.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithm engines**: Every method has a purpose, and the purpose is implemented
    using logic or an algorithm. Your test case should test the algorithm to make
    sure it’s correct and it results in the right output based on the input into the
    method.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple database queries checking predicates**: If your job as a developer
    is related to queries and manipulating databases, you really want to test your
    database queries to make sure it performs the right manipulation and queries.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility methods**: Utility methods are helpers in your project that are created
    for a specific task. They are usually used when you need to do stuff that does
    not need an instance of a class. This set of methods needs to be tested properly
    to ensure it produces the correct output when used.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing less critical codes:** Test the edge cases of a few unusually complex
    pieces of code that you think will probably have errors. Additionally, carry out
    edge-case tests of less critical code whenever someone has time to kill.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding are a few things you can consider for your test cases. However,
    it is important to note that writing tests and having 100% code coverage do not
    necessarily mean that your code is bug free. In the next section, we will explore
    things you should not test in your project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: What you should not test
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the things that you should not be testing in your project:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Constructors or properties (if they just return variables). Test them only if
    they contain validations.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that call another public method.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the code needs to interact with other deployed systems, then an integration
    test should be used.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations such as constants, read-only fields, configs, and enumerations.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should not test POJO classes or models; rather, you can test each of the
    methods inside the class.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, we have explored the software testing strategy, what to test, and
    what you should not test to help you understand the relevance of software testing
    in your enterprise application. In the next section, we will explore how to test
    a basic Vue.js application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Testing a basic Vue.js 3 app
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a Pinterest application using Strapi for
    the backend and Vue.js 3 for the frontend.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we added internationalization, structured the project, and built
    out a complete Pinterest clone. In this section, we will continue by using the
    official project we created for this book to set up software testing, resulting
    in a full-blown enterprise-ready Pinterest clone application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: You can clone the project from this repository, [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications),
    to jump right in.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test folder
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is always confusing knowing where to add your test files and folder when
    it comes to creating enterprise applications. There are two methods for structuring
    your test files depending on the approach you used for your enterprise project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Method 1 – adding test files inside each component
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you can create a specific test file inside each of the `component` folders.
    For instance, inside the `component` folder in our Vue.js 3 project, we will create
    a folder for each component and move the files of each component into the folder,
    including the test file for each component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows an example of how we could arrange our component
    folder to accommodate our testing files and other files related to a particular
    component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – A screenshot showing our component structure](img/Figure_8.02_B17237.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – A screenshot showing our component structure
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see how you can add any files related to any
    of the components. For example, if you want to add an end-to-end testing or integration
    testing file for each component, you just create the file within each specific
    component folder.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Also, because of the structure of our practice project and the introduction
    of the atomic pattern, we can easily see how many files will be created in each
    component. The same goes for different areas we will be testing throughout the
    project.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: However, we can use the next method to arrange everything related to testing
    in a separate folder and create all the files and folders inside the specific
    `tests` folder.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Method 2 – creating a tests folder
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will create a folder inside the `src` folder called `tests`,
    which will contain every file and folder related to testing and test configurations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the folder structure for implementing testing with
    this method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – A screenshot of the folder structure](img/Figure_8.03_B17237.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – A screenshot of the folder structure
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This method has a single folder that contains all the files and folders related
    to testing, including all the configurations. It is a central place and single
    point of truth for all your software testing files and folders. You can arrange
    this folder in a different structure as per your use case.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the method of structuring your test folder or files and folders
    related to testing does not matter. What matters the most is implementing software
    testing properly and knowing exactly what to test to avoid production bugs and
    errors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: We will use the second method in this demo in writing some basic unit tests
    to demonstrate. This is because we don’t want the testing files to be scattered
    across different folders since we are using the atomic pattern.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic unit test
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will start by installing the new testing library for Vue.js 3\. Since
    we are using Vite in the project, we will also install the Vitest library for
    our test runner. You can read more about the new Vue.js 3 test library at [https://vitest.dev/guide/](https://vitest.dev/guide/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Installing the test library
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vitest is a blazing-fast unit test framework powered by Vite. Install the library
    by using any of these commands:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]bash'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: with npm
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm install -D vitest
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: or with yarn
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: yarn add -D vitest
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: or with pnpm
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pnpm add -D vitest
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have our testing library set up, let’s create a simple helper file
    to test our configuration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Creating a helper file
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our demonstration, we will create a helper file inside the `src/helpers`
    folder and add a simple function to increment a value. The following snippet shows
    the code example we have added to the newly created file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The increment function written previously increments a value by `1` until the
    max value is reached. If the max value is reached, it simply returns the current
    value. Next, let’s write a basic unit test for it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic test
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will write a simple unit test for this function. You can
    follow this by writing unit tests for all the functions and methods of your enterprise
    project:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will explore unit testing in depth in the next chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the preceding code together and understand the nitty-gritty
    details of it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Adding the** **required packages**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we need the `vitest` package and the `helper` file to test. Next, we
    use the exported functions to create a `describe` block, and so on:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `describe` block is used to group related test cases, as demonstrated in
    the preceding code snippet.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Using the** **it function**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we use the `it` function to test specific use cases of our function.
    For instance, we test to make sure the number actually increases by `1` each time
    the function is called:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Step 3: Using the** **except function**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the `expect` function is used to test the use case. You pass in a value
    and expect the value to be equal to another value, as shown in the example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You can access different methods ([https://vitest.dev/api/#expect](https://vitest.dev/api/#expect))
    from the `expect` object aside from the `toBe()` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover the process of running your test with Vitest
    and creating your first component/integration testing examples.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Running a test with Vitest
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now run the test to see whether it passes or not. Type the following
    command into your root terminal:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If your test is successful, you should see that the three cases passed, as
    shown in the following figure:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – A screenshot showing the test result](img/Figure_8.04_B17237.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – A screenshot showing the test result
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have demonstrated how to configure and structure software
    testing with Vue.js 3 using the latest Vitest testing library for Vue.js 3\. We
    have also learned how to write a basic unit test. In the next section, we will
    learn how to create basic component-based testing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Component testing in Vue.js 3
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vue.js, components are the main building block of the UI and refer to a single
    unit of the application that is shareable, testable, and reusable. Therefore,
    component testing sits between unit testing and end-to-end testing. It can also
    be referred to as integration testing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, where we integrated atomic patterns using Storybook,
    we discussed creating component stories and how to create them. If you created
    stories for all your components and configured them to work properly as demonstrated,
    then you will have already implemented component testing using Storybook stories.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: However, [*Chapter 10*](B17237_10.xhtml#_idTextAnchor363), *Integrating Testing
    in Vue.js 3* is dedicated to exploring component testing. Nevertheless, we will
    briefly illustrate in this chapter how to implement simple component-based testing
    to aid our understanding of the next chapters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic component test
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by installing the new testing library for Vue.js 3\. Since we
    are using Vite in the project, we will also install the Vitest library for our
    test runner. You can read more about the new Vue.js 3 test library ([https://vuejs.org/guide/scaling-up/testing.html](https://vuejs.org/guide/scaling-up/testing.html)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Installing the test library
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of the time of writing, `@testing-library/vue` ([https://github.com/testing-library/vue-testing-library](https://github.com/testing-library/vue-testing-library))
    is recommended for component testing, and we will install it in our example. Run
    the following command to install it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]bash'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: npm install -D vitest happy-dom @testing-library/vue
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, open the `vite.config.js` file and add the following configuration:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This configuration should allow us to run both unit and component tests at the
    same time. Next, let’s create a simple component test.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic component test
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a simple component test snippet to demonstrate the process:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The test simply renders `Button` with a custom label value and also checks whether
    we can retrieve the custom label added during the rendering process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Running the test
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running the test will result in four passed test cases, including the unit
    test we created earlier:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A screenshot showing the final test result with integration
    testing](img/Figure_8.05_B17237.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – A screenshot showing the final test result with integration testing
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have demonstrated how to configure and structure component
    testing, also known as integration testing, with Vue.js 3 using the latest Vitest
    testing library for Vue.js 3\. We have also written basic component tests to help
    us understand the process. In the next chapters, we will look in-depth at the
    different types of testing we can perform when building enterprise projects with
    Vue.js 3.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'You can clone the latest repository for this chapter here: [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter dove deeper into the concept of software testing to deliver scalable,
    high-performing, and bug-free applications. We also explored what to test from
    an array of available components and methods. In addition, we utilized our knowledge
    of software testing to create basic unit and component test cases in Vue.js 3
    using Vitest.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore everything related to unit testing. We
    will learn how to unit test a Vue.js 3 component and the component and page methods.
    We will also learn about unit testing tools such as Vitest and use them to effectively
    unit test an enterprise project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
