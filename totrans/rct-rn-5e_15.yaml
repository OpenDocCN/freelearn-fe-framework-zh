- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Unit Testing in React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 的单元测试
- en: Although testing is an integral part of the software development process, developers
    and companies often pay surprisingly little attention to it in reality, especially
    to automated testing. In this chapter, we will try to understand why it is important
    to pay attention to testing and what advantages it gives. We will also explore
    the basics of unit testing in ReactJS, including general testing theory, tools,
    and methods, as well as specific aspects of testing ReactJS components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试是软件开发过程的一个组成部分，但在现实中，开发人员和公司往往对它投入的关注出奇地少，尤其是对自动化测试。在本章中，我们将试图了解为什么关注测试很重要以及它带来的优势。我们还将探讨
    ReactJS 中单元测试的基础，包括一般测试理论、工具和方法，以及测试 ReactJS 组件的特定方面。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Testing in general
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般测试
- en: Unit testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Testing ReactJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 ReactJS
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files of this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter14](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter14).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，地址为 [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter14](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter14)。
- en: Testing in general
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般测试
- en: '**Software testing** is a process aimed at identifying errors and verifying
    the functionality of a product to ensure its quality. Testing also allows developers
    and testers to assess the system’s behavior under various conditions and to ensure
    that new changes have not led to regression, meaning they have not disrupted existing
    functionality.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件测试**是一个旨在识别错误和验证产品功能的过程，以确保其质量。测试还允许开发人员和测试人员评估系统在各种条件下的行为，并确保新的更改没有导致回归，即它们没有破坏现有的功能。'
- en: The testing process includes a series of actions conducted to detect and identify
    any aspects that do not meet requirements or expectations. One example of such
    an action could be **manual testing**, where a developer or tester manually checks
    the application. However, this approach is time-consuming and provides little
    guarantee that the application is secure and free of critical errors in operation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试过程包括一系列执行的动作，旨在检测和识别任何不符合要求或预期的方面。这样的动作的一个例子可能是**手动测试**，其中开发人员或测试人员手动检查应用。然而，这种方法耗时且几乎不能保证应用在操作上安全且没有关键错误。
- en: To ensure a higher level of application reliability while saving time on testing,
    there are **automated tests**. They allow the functionality of the application
    to be verified without human intervention.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在测试上节省时间的同时提高应用的可靠性，存在**自动化测试**。它们允许在无需人工干预的情况下验证应用的功能。
- en: An automated test typically consists of a set of predefined tests and a software
    product, often referred to as a **runner**, which launches these tests and analyzes
    the results to determine the success or failure of each test. In addition to this,
    automated tests can be used to check performance, stability, security, availability,
    and compatibility, allowing you to write truly stable, large, and successful projects.
    That’s why it’s never a good idea to avoid tests; on the contrary, it’s worth
    getting to know them better and trying to use them in all possible projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试通常由一系列预定义的测试和一个软件产品组成，通常被称为**运行器**，它启动这些测试并分析结果以确定每个测试的成功或失败。除此之外，自动化测试还可以用于检查性能、稳定性、安全性、可用性和兼容性，使您能够编写真正稳定、大型和成功的项目。这就是为什么避免测试从来都不是一个好主意；相反，了解它们并尝试在所有可能的项目中使用它们是值得的。
- en: As developers, we are obviously more interested in automated testing than manual
    testing, so this chapter will focus on that. But before that, let’s briefly look
    at the approaches to testing and the types of tests that exist.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们显然对自动化测试比对手动测试更感兴趣，因此本章将专注于这一点。但在那之前，让我们简要地看看测试的方法和存在的测试类型。
- en: Test types and approaches
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类型和方法
- en: Software testing can be classified by various criteria, including the level
    of testing and the objectives it pursues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试可以根据各种标准进行分类，包括测试的级别和它追求的目标。
- en: 'Typically, the following types of tests are distinguished:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，以下类型的测试被区分出来：
- en: '**Unit testing**: Testing individual modules or components of the program for
    correct operation. Unit tests are usually written and executed by developers to
    check specific functions or methods. Such tests are generally quick to write and
    can be executed quickly, but they do not test the final application for critical
    bugs, as the tested and stable components themselves may have problems when interacting
    with each other. An example of a unit test would be checking the functionality
    of a single function, React component, or Hook.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：对程序的单个模块或组件进行正确操作的测试。单元测试通常由开发者编写和执行，以检查特定的函数或方法。这类测试通常编写快速，执行也快，但它们并不测试最终应用程序的临界错误，因为被测试和稳定的组件在相互交互时可能存在问题。一个单元测试的例子是检查单个函数、React
    组件或 Hook 的功能。'
- en: '**Integration testing**: Testing in which we check the interaction between
    various modules or system components. The goal is to detect defects in the interfaces
    and interactions between integrated components. This type of testing is usually
    conducted on the server side to ensure that all systems work smoothly together
    and that the business logic meets the specified requirements.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这种测试是在各种模块或系统组件之间检查交互的测试。目标是检测集成组件之间的接口和交互中的缺陷。这类测试通常在服务器端进行，以确保所有系统协同工作，并且业务逻辑符合指定的要求。'
- en: For example, an integration test would be one that checks that user registration
    works by making real calls to REST API endpoints and checking the returned data.
    Such a test depends less on the application’s implementation and code and more
    on checking behavior and business logic.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，一个集成测试可能是一个检查用户注册是否正常工作的测试，通过向 REST API 端点发出真实调用并检查返回的数据。这种测试对应用程序的实现和代码的依赖性较小，更多地是检查行为和业务逻辑。
- en: '**End-to-end (E2E) testing**: Testing a complete and integrated software system
    to ensure that it meets specified requirements. E2E testing evaluates the program
    as a whole. This type of testing is the most reliable, as it completely abstracts
    from the application’s implementation and checks the final behavior by interacting
    directly with the application itself. In the process of such testing, for example,
    in a web application, a real browser is launched in a special environment, in
    which a script performs real actions with the application like clicking buttons,
    filling out forms, and navigating through pages.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端（E2E）测试**：测试一个完整且集成的软件系统，以确保它符合指定的要求。端到端测试评估整个程序。这种测试是最可靠的，因为它完全抽象了应用程序的实现，并通过直接与应用程序交互来检查最终行为。在测试过程中，例如，在一个网络应用程序中，在一个特殊环境中启动一个真实浏览器，其中脚本执行与应用程序的真实操作，如点击按钮、填写表单和浏览页面。'
- en: 'Although test types such as integration and E2E testing provide greater confidence
    in verifying the quality of an application, they come with drawbacks such as complexity
    and speed of test development, execution speed, and consequently, their costliness.
    Therefore, it is considered good practice to maintain a balance where preference
    is given to unit tests, as they are easier to maintain and faster to run. Then,
    all main business processes and logic are verified using integration tests, and
    E2E tests cover only the most critical business cases. This approach can be depicted
    in the form of a pyramid:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管集成和端到端测试等测试类型在验证应用程序质量方面提供了更大的信心，但它们也伴随着复杂性和测试开发速度、执行速度等缺点，从而增加了成本。因此，被认为是一种良好的实践，在保持平衡的同时，优先考虑单元测试，因为它们更容易维护且运行速度更快。然后，所有主要业务流程和逻辑都通过集成测试进行验证，而端到端测试仅覆盖最关键的业务案例。这种方法可以用金字塔的形式表示：
- en: '![Picture 1](img/B19636_14_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](img/B19636_14_01.png)'
- en: 'Figure 14.1: Test pyramid'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：测试金字塔
- en: The pyramid perfectly describes the approach we have discussed above. At its
    base lies **unit** testing, which should cover the application’s source code as
    extensively as possible. It has the lowest cost of development and maintenance,
    as well as the highest test execution performance. In the middle are the **integration**
    tests, which are quite fast but more expensive to develop. At the very top, we
    have the **E2E** tests, which take the longest to execute and are the most expensive
    to develop, but they provide the maximum confidence in the quality of the product
    being tested.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔完美地描述了我们上面讨论的方法。其底部是**单元**测试，应该尽可能全面地覆盖应用程序的源代码。它具有最低的开发和维护成本，以及最高的测试执行性能。中间是**集成**测试，执行速度快，但开发成本较高。在最顶部，我们有**端到端**测试，执行时间最长，开发成本最高，但它们提供了对正在测试的产品质量的最高信心。
- en: Since integration and E2E tests abstract away from the implementation, and thus
    from the programming language or libraries used in the application, we are not
    going to cover those types of testing. Therefore, let’s focus in more detail on
    unit testing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集成测试和端到端测试抽象了实现，以及应用程序中使用的编程语言或库，我们不会涉及这些类型的测试。因此，让我们更详细地关注单元测试。
- en: Unit testing
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'We already know that unit testing is the process of verifying the correctness
    of individual “**units**” of code: namely, **functions** and **methods**. The
    goal of unit testing is to ensure that each separate unit performs its task correctly,
    which, in turn, increases confidence in the reliability of the entire application.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，单元测试是验证代码单个“**单元**”正确性的过程：即，**函数**和**方法**。单元测试的目标是确保每个单独的单元能够正确执行其任务，这反过来又增加了对整个应用程序可靠性的信心。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above represents the most basic and simplest test of a function that adds
    two values. The test code itself is a function that calls a special method, `expect`,
    which takes a value and then has a series of methods allowing for the checking
    and comparing of results.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子代表了添加两个值的最基本和最简单的函数测试。测试代码本身是一个函数，它调用一个特殊的方法，`expect`，该方法接受一个值，然后有一系列方法允许检查和比较结果。
- en: Looking at this code, the first question that might come to mind is, is it really
    necessary to write another three lines of tests for such a simple three-line function?
    And why test such a function at all? I would answer with a definitive *yes*. It
    often happens that a function can be covered by a test that is larger in volume
    than the function itself, and there is nothing wrong with that. Let’s understand
    why.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这段代码，可能会产生的第一个问题是，真的有必要为这么简单的三行函数再写三条测试代码吗？为什么要测试这样的函数呢？我会明确地回答：是的。经常会出现这样的情况，一个函数可以被一个比它本身更大的测试覆盖，而这并没有什么问题。让我们来理解一下原因。
- en: Unit testing is most useful and effective when you are testing **pure functions**,
    which have no side effects and do not depend on external state. Conversely, unit
    testing is useless when the function being tested can change its behavior due
    to external factors or simply because that’s how the function was designed. For
    example, functions for requesting data from the server, getting data from `localStorage`,
    or relying on global variables might return different results for the same input.
    From this, we can conclude that in an application development approach that requires
    code coverage with tests, you will automatically strive to write **testable code**,
    meaning more modular, independent, clean, and scalable code. This becomes especially
    noticeable on large projects. If tests were written from the start, such projects
    could continue to grow without the need for major refactoring or rewriting functionality
    from scratch. Also, in projects with tests, it is easier for newcomers to understand,
    as tests can serve as additional documentation for modules, reading which one
    can understand what the module is responsible for and what behavior it possesses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在测试**纯函数**时最有用和有效，这些函数没有副作用且不依赖于外部状态。相反，当被测试的函数由于外部因素或仅仅是因为函数的设计方式而改变其行为时，单元测试就毫无用处。例如，从服务器请求数据、从`localStorage`获取数据或依赖于全局变量的函数可能会对相同的输入返回不同的结果。由此我们可以得出结论，在需要通过测试实现代码覆盖率的应用程序开发方法中，你将自动努力编写**可测试的代码**，这意味着更加模块化、独立、清洁和可扩展的代码。这在大型项目中尤其明显。如果从一开始就编写了测试，这样的项目可以继续增长而无需进行大规模的重构或从头开始重写功能。此外，在带有测试的项目中，新来者更容易理解，因为测试可以作为模块的额外文档，通过阅读测试可以了解模块负责的内容以及它具有的行为。
- en: For writing unit tests, there are entire concepts and methodologies. The main
    and most popular one is the traditional coverage of tests after code development.
    The advantage of this approach is the speed of development of the main functionality,
    as tests are usually dealt with later. Hence, the problem with this approach lies
    in delaying testing, which poses a risk of accumulating code that is not covered
    by tests. Later, when writing tests, it often becomes necessary to correct the
    main code, making it more modular and cleaner, which takes additional time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编写单元测试来说，存在一系列的概念和方法。其中最主要和最受欢迎的是在代码开发之后的传统测试覆盖率。这种方法的优点是主要功能开发的速度快，因为测试通常是在之后处理的。因此，这种方法的问题在于延迟测试，这可能导致积累未经过测试的代码。后来，在编写测试时，通常需要修正主要代码，使其更加模块化和清洁，这需要额外的时间。
- en: There is also a methodology directly aimed at writing tests, called **test-driven
    development** (**TDD**). This is a software development methodology in which tests
    are written before the code itself. The benefit of this approach is that your
    code will be immediately covered by tests, meaning it will be cleaner and more
    reliable. However, this approach may not be suitable for prototyping or for projects
    where requirements often change.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种直接针对编写测试的方法，称为**测试驱动开发**（**TDD**）。这是一种软件开发方法，其中测试是在代码本身之前编写的。这种方法的优点是代码将立即被测试覆盖，这意味着代码将更加清洁和可靠。然而，这种方法可能不适合原型设计或需求经常变化的项目。
- en: The choice between TDD and testing after development depends on many factors,
    including the team’s culture, project requirements, and developers’ preferences.
    It is important to understand that neither approach is a universal solution, and
    different choices may be justified in different situations. Most importantly,
    understand the importance of testing and that one should avoid an approach in
    work where tests are not written at all as, in most cases, such code is doomed
    to be rewritten from scratch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD（测试驱动开发）和开发后测试之间的选择取决于许多因素，包括团队文化、项目需求和开发者的偏好。重要的是要理解，这两种方法都不是万能的解决方案，不同的情境下可能会有不同的合理选择。最重要的是，要理解测试的重要性，并且应该避免那种完全不编写测试的工作方法，因为在大多数情况下，这样的代码注定要完全重写。
- en: Now that we understand what unit tests are and their importance, let’s take
    a closer look at them. Before writing tests, we should set up the environment
    in which we will run our tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单元测试及其重要性，让我们更深入地了解一下。在编写测试之前，我们应该设置我们将要运行测试的环境。
- en: Setting up the test environment
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: 'The most popular framework for writing and running unit tests is **Jest**.
    However, we will look at its more performant alternative, which is fully compatible
    with **Vite**, called **Vitest**. To install Vitest in your project, you need
    to execute this command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和运行单元测试最流行的框架是 **Jest**。然而，我们将探讨其性能更优的替代方案，它与 **Vite** 完全兼容，被称为 **Vitest**。要在你的项目中安装
    Vitest，你需要执行以下命令：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For basic operation, Vitest does not require any configuration, as it is fully
    compatible with the Vite configuration file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本操作，Vitest 不需要任何配置，因为它与 Vite 配置文件完全兼容。
- en: Next, to get started, we need to create a file with the extension `*.test.ts`.
    The location of the file is not critical; the main thing is that the file is inside
    your project. Usually, test files are associated with the files of the functions
    being tested and are placed in the same directory; for example, for the `sum`
    function located in the `sum.ts` file, a file with a test named `sum.test.ts`
    is created and located in the same folder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了开始，我们需要创建一个扩展名为 `*.test.ts` 的文件。文件的位置不是关键；最重要的是文件要在你的项目内部。通常，测试文件与被测试的函数文件相关联，并放置在同一目录下；例如，对于位于
    `sum.ts` 文件中的 `sum` 函数，会创建一个名为 `sum.test.ts` 的测试文件，并将其放置在同一文件夹中。
- en: 'To run the tests, we need to add a launch script to the `package.json` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们需要在 `package.json` 文件中添加一个启动脚本：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, to call it, just execute the command in the terminal:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要调用它，只需在终端中执行命令：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will start the Vitest process, which will scan the project for
    files with the `.test`. extension and then execute all the tests in each such
    file. Once all tests are completed, you will see the result in the terminal window,
    and then the process will wait for changes in the test files to rerun them. This
    is specifically designed as a mode for developing tests, where you do not need
    to constantly run the test command. For a one-time test run, you can add another
    command that will close the process upon completion of testing:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将启动 Vitest 进程，它会扫描项目中的 `.test` 扩展名的文件，然后执行每个这样的文件中的所有测试。一旦所有测试完成，你将在终端窗口中看到结果，然后进程将等待测试文件的变化以重新运行它们。这特别设计为开发测试的模式，其中你不需要不断运行测试命令。对于一次性测试运行，你可以添加另一个命令，在测试完成后关闭进程：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `run` parameter is precisely for telling Vitest that you want to run the
    tests only once.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 参数正是用来告诉 Vitest 你只想运行一次测试。'
- en: Vitest features
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vitest 特性
- en: 'Let’s now look at the main features of Vitest and the types of tests we can
    write. Let’s start with a simple function, `squared`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Vitest 的主要特性和我们可以编写的测试类型。让我们从一个简单的函数 `squared` 开始：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function returns the square of a number. Here is what the test for this
    function would look like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个数字的平方。以下是这个函数的测试示例：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `test` and `expect` functions are part of the Vitest package. The test function
    takes the name of the test as its first argument and the test function itself
    as its second argument. The `expect` method serves as the basis for checking the
    expected result from the function being tested. Calling the `expect` method creates
    an object that contains a large number of methods, allowing for different ways
    to check the execution result. In our example, we explicitly compare the result
    of executing the `squared` function with the expected value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 和 `expect` 函数是 Vitest 包的一部分。`test` 函数将其名称作为第一个参数，将测试函数本身作为第二个参数。`expect`
    方法作为检查被测试函数期望结果的基础。调用 `expect` 方法会创建一个包含大量方法的对象，允许以不同的方式检查执行结果。在我们的例子中，我们明确比较了执行
    `squared` 函数的结果与期望值。'
- en: 'By running this test, in the terminal window, we will see the following message:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试后，在终端窗口中，我们会看到以下信息：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To check that the tests are working correctly, let’s change the expected value
    from `4` and see what result we get:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查测试是否正确工作，让我们将期望值从 `4` 改变，看看我们会得到什么结果：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When a test fails, we can see directly in the results where the error occurred,
    what result we received, and what we expected.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，我们可以在结果中直接看到错误发生的位置，我们得到了什么结果，以及我们期望的是什么。
- en: 'The `toBe` method is very useful for direct comparison of results, but what
    about objects and arrays? Let’s consider this test example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBe` 方法对于直接比较结果非常有用，但对于对象和数组呢？让我们考虑这个测试示例：'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this test, we created two identical objects, which will not be equal as variables.
    To expect the opposite assertion, we use the additional `.not.` key, which ultimately
    gives us the statement that the two variables are not equal to each other. If
    we still want to check that the objects have the same structure, there is a method
    called `toEqual`, which recursively compares objects. This method also works similarly
    with arrays.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们创建了两个相同的对象，但作为变量它们不会相等。为了期望相反的断言，我们使用额外的`.not.`键，这最终给出了两个变量不相等的陈述。如果我们仍然想检查对象具有相同的结构，有一个名为`toEqual`的方法，它可以递归地比较对象。这个方法也与数组类似工作。
- en: 'For arrays, there are also additional methods that allow checking for the presence
    of an element, which is often very useful:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，也有一些额外的方法可以用来检查元素是否存在，这通常非常有用：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `toContain` method can also work with strings and even DOM elements, checking
    for the presence of a class in `classList`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`toContain`方法也可以与字符串和DOM元素一起工作，检查`classList`中是否存在类。'
- en: 'The next big part of unit testing is working with functions. Vitest allows
    you to create **spyable fake functions**, which lets you check how and with what
    parameters this function was called. Let’s look at an example function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的下一个重要部分是处理函数。Vitest 允许你创建**可模拟的假函数**，这让你可以检查这个函数是如何以及使用什么参数被调用的。让我们看看一个示例函数：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function is created just for demonstration, but we can easily imagine
    some module or selector component that takes the `onSelect` callback, which will
    be called under some condition: in our case, three times in a row. Now let’s see
    how we can test using observable functions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是为了演示，但我们很容易想象一些模块或选择器组件，它接受`onSelect`回调函数，该函数将在某些条件下被调用：在我们的例子中，连续调用三次。现在让我们看看我们如何使用可观察的函数进行测试：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the test, we created the `onSelect` function using the `vi` module from
    the `Vitest` package. This function now allows us to check how many times it was
    called and with what arguments. For this, we used the methods `toBeCalledTimes`
    and `toHaveBeenLastCalledWith`. There is also a method called `toHaveBeenCalledWith`,
    which can step-by-step check which arguments were used on each call of the observed
    function. In our case, the valid checks would be these three lines:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们使用`Vitest`包中的`vi`模块创建了`onSelect`函数。现在这个函数允许我们检查它被调用了多少次以及使用了什么参数。为此，我们使用了`toBeCalledTimes`和`toHaveBeenLastCalledWith`方法。还有一个名为`toHaveBeenCalledWith`的方法，它可以逐步检查在观察函数的每次调用中使用了哪些参数。在我们的例子中，有效的检查会是这三行：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Vitest also allows you to spy a real function, for which you need to use the
    `vi.spyOn` method. However, for this, the function must be accessible from an
    object. Let’s look at an example of spying on a real function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 还允许你模拟一个真实函数，你需要使用`vi.spyOn`方法。然而，为了做到这一点，函数必须可以从一个对象中访问。让我们看看模拟一个真实函数的示例：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To create an observation for a function, we call `vi.spyOn` and pass it the
    object as the first argument and the name of the method as the second. Then, we
    can work with the original function and, later, make the necessary checks working
    with the `spy` variable. In the example above, you can also notice the new method
    `toHaveReturnedWith`, which allows you to check what the observed function returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数创建一个观察，我们调用`vi.spyOn`并传递对象作为第一个参数以及方法的名称作为第二个参数。然后，我们可以处理原始函数，稍后通过使用`spy`变量进行必要的检查。在上面的例子中，你还可以注意到新的方法`toHaveReturnedWith`，它允许你检查观察到的函数返回了什么。
- en: Mocking
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟
- en: 'Moving on, I’d like to mention one of the most challenging parts of unit testing:
    namely, working with functions that have side effects or depend on external data
    or libraries. Earlier, I mentioned that testing is useless in functions with side
    effects, like calling something under the hood. Actually, that’s not entirely
    true. In some cases, it’s simply impossible to write a pure function, but that
    doesn’t mean it can’t be tested. To write tests for such functions, we can use
    **mocking**: namely, emulating external behavior or simply replacing the implementation
    of some modules or libraries.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我想提到单元测试中最具挑战性的部分之一：即处理具有副作用或依赖于外部数据或库的函数。之前，我提到在具有副作用的函数中进行测试是无用的，比如在底层调用某些东西。实际上，这并不完全正确。在某些情况下，编写一个纯函数可能是不可能的，但这并不意味着它不能被测试。为了测试这样的函数，我们可以使用**模拟**：即模拟外部行为或简单地替换某些模块或库的实现。
- en: An example could be a function that depends on the system time of the computer,
    or a function that returns data from a server. In such cases, we can apply a fake
    instruction that can change the current date of the computer specifically for
    this test, to have a clean result that is easier to test. Similarly, it is possible
    to create a fake implementation of a network request, which will ultimately be
    executed locally with the return of predetermined values. Let’s discuss some of
    these scenarios in this section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是一个依赖于计算机系统时间的函数，或者一个从服务器返回数据的函数。在这种情况下，我们可以应用一个特定的模拟指令来更改计算机的当前日期，以便为这个测试创建一个干净的结果，这样更容易进行测试。同样，也可以创建一个网络请求的模拟实现，它最终将在本地执行并返回预定的值。让我们在本节中讨论一些这些场景。
- en: 'Consider the example of testing and using **timers**. In the testing environment,
    we can avoid waiting for timers and manually control them to more thoroughly test
    the behavior of the function. Let’s look at an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到测试和使用**计时器**的例子。在测试环境中，我们可以避免等待计时器，并手动控制它们，以便更彻底地测试函数的行为。让我们看看一个例子：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We created the `executeInMinute` and `executeEveryMinute` functions for delaying
    the call of a function by one minute and for cyclic execution every minute, respectively.
    We also created a mock function that we will subsequently spy on. Here’s what
    the test will look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`executeInMinute`和`executeEveryMinute`函数，分别用于延迟函数调用一分钟和每分钟循环执行。我们还创建了一个模拟函数，我们将随后对其进行监视。以下是测试将呈现的样子：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, there’s a lot to discuss but let’s start with the fact that
    we didn’t use the `test` function; instead, we used `describe` and `it`. The `describe`
    function allows us to create a test suite that can have its own context and lifecycle.
    In the test suite, we can set initial parameters or mock some behavior so that
    our test cases can reuse this context and these parameters later on. In our example,
    we use the `beforeEach` and `afterEach` methods, which set up fake timers before
    each test and then restore everything back to its original state after each test.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有很多东西可以讨论，但让我们从我们没有使用`test`函数这个事实开始；相反，我们使用了`describe`和`it`。`describe`函数允许我们创建一个可以有自己的上下文和生命周期的测试套件。在测试套件中，我们可以设置初始参数或模拟某些行为，以便我们的测试用例可以在以后重用这个上下文和这些参数。在我们的例子中，我们使用了`beforeEach`和`afterEach`方法，这些方法在每个测试之前设置模拟计时器，然后在每个测试之后将一切恢复到原始状态。
- en: 'The `it` method is an alias for the `test` method and does not differ functionally
    from it. It’s only there to make the test case more readable in the results. For
    example, `describe` with ‘`delayed execution`'' and `it` with ‘`should execute
    the function`'' in the results would look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`it`方法是对`test`方法的别名，在功能上与它没有区别。它只是为了让测试用例在结果中更易于阅读。例如，在结果中使用`describe`的`delayed
    execution`和`it`的`should execute the function`将看起来像这样：'
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, using `test`, we would see the result as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`test`，我们会看到的结果是：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let’s look at the tests themselves. The first test uses the `executeInMinute`
    function, which, in reality, would call our observed method only after a minute,
    but in the test, we can control time. By using `vi.runAllTimers()`, we force the
    environment to start and skip all timers and immediately check the result. In
    the next test, we move time forward by 2 milliseconds using `vi.advanceTimersByTime(2)`,
    which already allows us to ensure that the original function will not be called.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看测试本身。第一个测试使用`executeInMinute`函数，实际上，它将在一分钟后才调用我们观察的方法，但在测试中，我们可以控制时间。通过使用`vi.runAllTimers()`，我们强制环境启动并跳过所有计时器，并立即检查结果。在下一个测试中，我们使用`vi.advanceTimersByTime(2)`将时间向前推进2毫秒，这已经允许我们确保原始函数不会被调用。
- en: Next, let’s discuss the `executeEveryMinute` method, which should start a timer
    with a call to an argument every minute. In this case, we can step through each
    iteration of this timer using `advanceTimersToNextTimer`, giving us precise control
    over time without having to wait in real time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论`executeEveryMinute`方法，它应该每分钟通过调用一个参数来启动一个计时器。在这种情况下，我们可以通过使用`advanceTimersToNextTimer`逐步遍历这个计时器的每个迭代，这样我们就可以在不等待真实时间的情况下精确控制时间。
- en: When writing unit tests, we will often encounter that the function being tested
    will depend on some library or even a package.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试时，我们经常会遇到被测试的函数依赖于某些库甚至是一个包。
- en: Most often, you will encounter this in React Native, if a library or some method
    uses the device’s native functions. In such a case, to write a test, we need to
    create a mock version of this logic that will be called during the test.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会在React Native中遇到这种情况，如果某个库或某些方法使用了设备的原生功能。在这种情况下，为了编写测试，我们需要创建一个模拟版本的逻辑，该逻辑将在测试期间被调用。
- en: 'Let’s consider a simple example where we imagine that we have a package that
    can interact with the device and get the current number of steps. To obtain the
    steps, we’ll use the `getSteps` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子，我们假设我们有一个可以与设备交互并获取当前步数的包。为了获取步数，我们将使用`getSteps`函数：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As an example, the function itself will be very simple and will just return
    the value of `100`. However, in reality, such a function would interact with a
    smartphone API, which would be impossible to invoke within the scope of testing.
    Next, let’s look at what we can do when writing a test:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，这个函数本身将非常简单，它只会返回`100`的值。然而，在现实中，这样的函数将与智能手机API交互，这在测试范围内是无法调用的。接下来，让我们看看在编写测试时我们可以做什么：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The test and the entire example are quite primitive but they will give you
    an understanding of how mocking works. At the beginning of the file, we import
    our original package, `ios-health-kit`, then using the `beforeAll` method, we
    call `vi.mock`, passing it the path to the package as the first argument and a
    function that will return the implementation of the original file: namely, creating
    an object with the `getSteps` method as a fake function with an implementation
    that will return the value of `2000`. Then, in the test, we check that it indeed
    returns this value.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和整个例子相当简单，但它们将帮助你理解模拟是如何工作的。在文件的开头，我们导入我们的原始包`ios-health-kit`，然后使用`beforeAll`方法调用`vi.mock`，将包的路径作为第一个参数传递，并传递一个函数，该函数将返回原始文件的实现：即创建一个具有`getSteps`方法作为假函数的对象，其实施将返回`2000`的值。然后，在测试中，我们检查它确实返回了这个值。
- en: In this test, the `vi.mock` function creates a mock of the imported package
    and replaces the original import with it, which allows us to successfully test
    this functionality.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，`vi.mock`函数创建了一个导入包的模拟，并用它替换了原始导入，这使得我们能够成功测试这个功能。
- en: In fact, this example, in essence, does not test anything but merely demonstrates
    the possibility of mocking. In a real project, you will likely need to test functions
    that somewhere inside may use libraries that are important to mock. For this,
    it may be inconvenient to constantly manually write mocks before the actual test;
    to solve this, you can mock libraries and APIs at a global level. For this, you
    will need to create a configuration file or use `vi.stubGlobal`. I do not recommend
    diving so deeply right away without understanding and learning the basics, so
    let’s move on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个例子本质上并没有测试任何东西，只是展示了模拟的可能性。在实际项目中，你可能会需要测试一些函数，这些函数内部可能使用了需要模拟的重要库。为此，在真正的测试之前不断手动编写模拟可能不太方便；为了解决这个问题，你可以在全局级别模拟库和API。为此，你需要创建一个配置文件或使用`vi.stubGlobal`。我不建议在没有理解和学习基础知识的情况下立即深入下去，所以让我们继续。
- en: More information about dependency mocking via configuration can be found at
    [https://vitest.dev/guide/mocking](https://vitest.dev/guide/mocking).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于通过配置进行依赖项模拟的信息可以在[https://vitest.dev/guide/mocking](https://vitest.dev/guide/mocking)找到。
- en: 'The last but not least important example I’d like to discuss is mocking **network
    requests**. Almost any application you’ll be developing will work with data that
    needs to be fetched from a server. For a unit test, this can be a problem, as
    it’s important to test the unit abstracted from the external environment. Therefore,
    in unit tests, you should always mock server requests and provide the data necessary
    for the current test case. There’s a library called `Mock Service Worker` for
    mocking server requests. It allows you to mock REST and GraphQL requests very
    flexibly. Let’s look at an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我想讨论的例子是模拟**网络请求**。你将要开发的任何应用程序几乎都会与需要从服务器获取的数据交互。对于单元测试来说，这可能是一个问题，因为测试单元时，重要的是要测试与外部环境抽象的单元。因此，在单元测试中，你应该始终模拟服务器请求并提供当前测试用例所需的数据。有一个名为`Mock
    Service Worker`的库用于模拟服务器请求。它允许你非常灵活地模拟REST和GraphQL请求。让我们看一个例子：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this test, we created a mock network request for the path `https://api.github.com/users`,
    which returns the data we need. For this, we used the `setupServer` function from
    the `Mock Service Worker` package. Next, in the lifecycle methods, we set up the
    mock server to listen to server requests and then implemented a standard test
    where data is requested using the regular Fetch API. As you can see in the results,
    we can check the status code and the returned data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们为路径 `https://api.github.com/users` 创建了一个模拟网络请求，它返回我们需要的数据。为此，我们使用了来自
    `Mock Service Worker` 包的 `setupServer` 函数。接下来，在生命周期方法中，我们设置了模拟服务器以监听服务器请求，然后实现了一个标准测试，其中使用常规
    Fetch API 请求数据。正如您在结果中可以看到的，我们可以检查状态码和返回的数据。
- en: With such a mocking approach, we truly have vast possibilities for testing different
    logic depending on the data returned from the server, status codes, errors, and
    so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模拟方法，我们确实有广泛的测试不同逻辑的可能性，这取决于从服务器返回的数据、状态码、错误等。
- en: 'In this section, we’ve introduced the basics of unit tests: namely, what they
    are and why we need to write them. We’ve learned how to set up the testing environment
    and write basic tests for our future projects. Next, let’s move on to the main
    topic of our chapter, testing ReactJS compaonents.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了单元测试的基础：即它们是什么以及为什么我们需要编写它们。我们学习了如何设置测试环境并为我们的未来项目编写基本测试。接下来，让我们继续本章的主要主题，即测试
    ReactJS 组件。
- en: Testing ReactJS
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 ReactJS
- en: We already know that unit testing involves checking small units, and most often,
    just functions, which perform some logic and return a result. To understand how
    testing in ReactJS works, the concept and idea remain the same. We know that at
    their core, React components are actually `createElement` functions that return
    a node, which, as a result of the `render` function, is displayed on the browser
    screen as HTML elements. In unit testing, we don’t have a browser, but this is
    not a problem for us since we know that the render target in React can be almost
    anything. As you may have already guessed, in the unit tests of ReactJS components,
    we will be rendering components into a specially created **JSDOM** format, which
    is fully identical to the DOM, and the **React Testing Library** will help us
    with this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道单元测试涉及检查小的单元，通常是函数，这些函数执行一些逻辑并返回一个结果。为了理解 ReactJS 中的测试是如何工作的，概念和想法是相同的。我们知道在核心上，React
    组件实际上是返回节点的 `createElement` 函数，这些节点作为 `render` 函数的结果，在浏览器屏幕上以 HTML 元素的形式显示。在单元测试中，我们没有浏览器，但这对我们来说不是问题，因为我们知道
    React 的渲染目标几乎可以是任何东西。正如您可能已经猜到的，在 ReactJS 组件的单元测试中，我们将渲染组件到专门创建的 **JSDOM** 格式，它与
    DOM 完全相同，**React Testing Library** 将帮助我们完成这项工作。
- en: This library contains a set of tools that allow rendering components, simulating
    events, and then checking the results in various ways.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库包含一套工具，允许渲染组件、模拟事件，并以各种方式检查结果。
- en: 'Before we start, let’s set up the environment for testing React components.
    To do this, in a fresh Vite project, execute this command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们设置测试 React 组件的环境。为此，在一个新的 Vite 项目中，执行以下命令：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command will install all the dependencies we need. Next, we need to create
    a `tests/setup.ts` file to integrate Vitest and the React Testing Library:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装我们需要的所有依赖项。接下来，我们需要创建一个 `tests/setup.ts` 文件，以集成 Vitest 和 React Testing
    Library：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we need to update the `vite.config.ts` configuration file and add the
    following code there:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新 `vite.config.ts` 配置文件，并在其中添加以下代码：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These parameters tell Vitest to use an additional environment and execute our
    setup script before starting the tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数告诉 Vitest 在开始测试之前使用一个额外的环境和执行我们的设置脚本。
- en: 'The last step is to configure TypeScript typing, where we will specify that
    the `expect` function will now have additional methods to work with React components.
    To do this, we need to add the following code to the `src/vite-env.d.ts` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是配置 TypeScript 类型，我们将指定 `expect` 函数现在将具有与 React 组件一起工作的额外方法。为此，我们需要将以下代码添加到
    `src/vite-env.d.ts` 文件中：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This construction adds types for all the new methods provided by the React Testing
    Library. With this, the environment setup is complete, and we can proceed to writing
    tests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构为 React Testing Library 提供的所有新方法添加了类型。有了这个，环境设置就完成了，我们可以继续编写测试。
- en: 'First, let’s consider the most basic check that a component has successfully
    rendered and is present in the document. For this, we’ll create an `App` component
    that returns a title with the `Hello world` text:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一个最基础的检查，即组件是否已成功渲染并存在于文档中。为此，我们将创建一个返回带有`Hello world`文本的标题的`App`组件：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The test for such a component would look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个组件的测试看起来会是这样：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The structure of the test itself is the same as before and is already familiar
    to us. The main thing to note is that at the beginning of the test, we render
    the component using the `render` function from `testing-library`, and after that,
    we can perform checks. To work with the rendering result, we use the `screen`
    module. It allows us to interact with our virtual DOM tree, and search for necessary
    elements in various ways.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身的架构与之前相同，并且我们已经非常熟悉。需要注意的是，在测试开始时，我们使用来自`testing-library`的`render`函数来渲染组件，之后我们就可以执行检查。为了处理渲染结果，我们使用`screen`模块。它允许我们以各种方式与我们的虚拟DOM树进行交互，并搜索必要的元素。
- en: 'We will cover the main ones later, but in this example, we used the `getByText`
    method, which queries for an element containing the text “`Hello World`". To check
    whether this element is present in the document, we use the `toBeInTheDocument`
    method. This is how the output looks when you run the test:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后介绍主要的方法，但在本例中，我们使用了`getByText`方法，它查询包含文本“`Hello World`”的元素。为了检查该元素是否存在于文档中，我们使用`toBeInTheDocument`方法。这是运行测试时的输出：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let’s consider a more complex example, where we need to check that clicking
    a button adds a new `className` property to the component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个更复杂的例子，其中我们需要检查点击按钮会给组件添加一个新的`className`属性：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By clicking the button, we update the state, which updates the component and
    adds an `active` class to it. Now, let’s write a test for this component:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击按钮，我们更新了状态，这更新了组件并给它添加了一个`active`类。现在，让我们为这个组件编写一个测试：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this test, you first render the `ClassCheck` component, then we need to find
    the button element, and for this, we use the `screen` module with the `getByRole`
    method. This is the next method that allows query elements in the document, but
    it’s important to understand that if there is more than one `button` in the document,
    this test will produce an error. Therefore, it’s necessary to apply suitable query
    methods in different situations. Now that the button is accessible, we first ensure
    that the component does not contain the `active` class using the `toHaveClass`
    method with the `not` prefix.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，你首先渲染`ClassCheck`组件，然后我们需要找到按钮元素，为此，我们使用带有`getByRole`方法的`screen`模块。这是下一个允许在文档中查询元素的方法，但重要的是要理解，如果文档中存在多个`button`元素，这个测试将产生错误。因此，在不同情况下应用合适的查询方法是必要的。现在按钮是可访问的，我们首先使用带有`not`前缀的`toHaveClass`方法确保组件不包含`active`类。
- en: To click on this button, the React Testing Library provides the `fireEvent`
    module, which allows generating click events. After clicking the button, we check
    that the required class is present in the element.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要点击这个按钮，React Testing Library提供了`fireEvent`模块，它允许生成点击事件。点击按钮后，我们检查元素中是否存在所需的类。
- en: 'With `fireEvent`, it’s possible to generate all possible events such as click,
    drag, play, focus, blur, and many others. A very common event that is also important
    to test is the `change` event in an input element. Let’s discuss this using the
    `Input` component as an example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fireEvent`，可以生成所有可能的事件，如点击、拖动、播放、聚焦、失焦等。一个非常重要且需要测试的常见事件是输入元素中的`change`事件。让我们以`Input`组件为例来讨论这个问题：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This component simply returns an `input` element, but in this example, I’ve
    also added a special attribute, `data-testid`. This is used for more convenient
    searching of elements in the document, as this attribute abstracts you from working
    with the content of the component or the role of the element. During the development
    of the project, you will often update your components, and the `data-testid` attribute
    will help you less frequently fix broken tests due to content updates or changes,
    say from `h1` to `h2` or `div` to a more semantic element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件简单地返回一个`input`元素，但在这个例子中，我还添加了一个特殊的属性，`data-testid`。这个属性用于在文档中更方便地搜索元素，因为它抽象了你对组件内容或元素角色的操作。在项目开发过程中，你经常会更新你的组件，而`data-testid`属性将帮助你更频繁地修复由于内容更新或更改（例如从`h1`到`h2`或`div`到更语义化的元素）而导致的损坏的测试。
- en: 'Now let’s write a test for this component:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为这个组件编写一个测试：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this test, as usual, we render the component, and then we find our element
    using the more convenient method, `getByTestId`. Next, we simulate the `change`
    event on `input` using the `fireEvent.change` method, which takes the event object,
    and at the end of the test, we assert the entered value in the expected one. In
    this way, we can now test large forms with various logic for formatting, validation,
    and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，像往常一样，我们渲染组件，然后使用更方便的方法 `getByTestId` 找到我们的元素。接下来，我们使用 `fireEvent.change`
    方法在 `input` 上模拟 `change` 事件，该方法接受事件对象，并在测试结束时断言输入的值与预期的值相符。这样，我们现在可以测试具有各种逻辑的大型表单，例如格式化、验证等。
- en: 'Just like testing components, the React Testing Library can also test Hooks.
    This allows testing only the custom logic and abstracting away from the components.
    Let’s write a small `useCounter` Hook, which will return the current `counter`
    value and the `increment` and `decrement` functions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像测试组件一样，React 测试库也可以测试 Hooks。这允许我们只测试自定义逻辑，并从组件中抽象出来。让我们编写一个小的 `useCounter`
    Hook，它将返回当前的 `counter` 值和 `increment` 及 `decrement` 函数：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In order to test this Hook, instead of using the `render` function, the React
    Testing Library has a `renderHook` method. This is what a test of this Hook would
    look like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个 Hook，而不是使用 `render` 函数，React 测试库有一个 `renderHook` 方法。这就是这个 Hook 的测试看起来像：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Initially, we render the Hook itself and check that the initial value is zero.
    The `renderHook` method returns the `result` object, through which we can read
    the data returned from the Hook. Next, we need to test the `increment` and `decrement`
    methods. To do this, it is not enough to simply call them, as Hooks are not pure
    functions by nature and contain a lot of logic under the hood. Therefore, we need
    to call those methods wrapped in the `act` method, which will synchronously wait
    for the method to execute and the Hook to re-render. After that, we can assert
    the expectations in the usual way. The output will look the same as we saw in
    the previous example, but let’s now try to update the test to make failed results.
    Updating the first assertion from `.toBe(0)` to `.toBe(10)` will look like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们渲染 Hook 本身并检查初始值是否为零。`renderHook` 方法返回 `result` 对象，通过它我们可以读取 Hook 返回的数据。接下来，我们需要测试
    `increment` 和 `decrement` 方法。为此，仅仅调用它们是不够的，因为 Hooks 本质上不是纯函数，并且在其内部包含大量逻辑。因此，我们需要将这些方法包裹在
    `act` 方法中调用，这将同步等待方法执行和 Hook 重新渲染。之后，我们可以以通常的方式断言期望。输出将看起来与我们在上一个示例中看到的一样，但现在让我们尝试更新测试以使结果失败。将第一个断言从
    `.toBe(0)` 更新到 `.toBe(10)` 将看起来像：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You will notice how Vitest highlights the part of the code where we got a failed
    assertion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你将注意到 Vitest 如何突出显示我们得到失败断言的代码部分。
- en: In this section, we have learned how we can test components and Hooks using
    the React Testing Library.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 React 测试库测试组件和 Hooks。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the broad and extensive topic of testing. We became
    acquainted with the concept itself, testing types, and various approaches. Then,
    we delved into unit testing and learned what it is, and what possibilities this
    type of testing offers. After that, we learned how to set up the environment and
    write tests for regular functions and logic. At the end of the chapter, we examined
    the basic capabilities of testing React components and Hooks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了广泛的测试主题。我们熟悉了测试的概念、测试类型和不同的方法。然后，我们深入研究了单元测试，学习了它是什么，以及这种测试类型提供了哪些可能性。之后，我们学习了如何设置环境并为常规函数和逻辑编写测试。在本章结束时，我们检查了测试
    React 组件和 Hooks 的基本功能。
- en: With this chapter, we conclude our acquaintance with the amazing ReactJS library
    and will next dive deeper into the React ecosystem with the incredible opportunity
    to create mobile applications based on React Native.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们结束了与惊人的 ReactJS 库的相识，并将深入探索 React 生态系统，利用创建基于 React Native 的移动应用程序的惊人机会。
- en: Join us on Discord!
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社群！
- en: Read this book alongside other users and the authors themselves. Ask questions,
    provide solutions to other readers, chat with the authors, and more. Scan the
    QR code or visit the link to join the community.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户和作者一起阅读这本书。提出问题，为其他读者提供解决方案，与作者聊天，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/ReactAndReactNative5e](Chapter_14.xhtml)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/ReactAndReactNative5e](Chapter_14.xhtml)'
- en: '![](img/QR_Code196803360665486921.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code196803360665486921.png)'
