- en: 10\. Working with Vuex – Fetching Remote Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 使用Vuex – 获取远程数据
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to work with remote APIs using the `Axios`
    library. You will make network calls and store results using Vuex. You will also
    see an example of how to store authentication tokens with Vuex and use it for
    further API calls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用`Axios`库与远程API一起工作。您将进行网络调用并使用Vuex存储结果。您还将看到一个如何使用Vuex存储身份验证令牌并用于后续API调用的示例。
- en: By the end of this chapter, you will have a good idea of how Vuex can help abstract
    and create a wrapper for remote APIs, and ease their integration into a Vue application.
    This abstraction makes it easier to migrate to other APIs in the future, ensuring
    that the rest of your applications continue to work properly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解Vuex如何帮助抽象并创建远程API的包装器，并简化它们集成到Vue应用程序中的过程。这种抽象使得将来迁移到其他API变得更容易，确保您的应用程序的其他部分继续正常工作。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In *Chapter 9*, *Working with Vuex – State, Getters, Actions, and Mutations*,
    you were introduced to Vuex and saw multiple examples of how to work with it to
    both read data from and write data to a store. We saw how multiple components
    could work with the store and all be kept in sync with little to no work at our
    end. In this chapter, we are going to expand our Vuex usage by integrating it
    with remote data by using `Axios`, a popular open source library that makes it
    easy to use network resources. Let's start off with a deeper look at `Axios`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*使用Vuex – 状态、获取器、动作和突变*中，您被介绍了Vuex，并看到了多个如何与之交互的示例，以从存储中读取数据并向存储写入数据。我们看到了多个组件如何与存储一起工作，并且在我们这边几乎不需要做任何工作就能保持同步。在本章中，我们将通过使用`Axios`（一个流行的开源库，使使用网络资源变得容易）将Vuex与远程数据集成来扩展我们的Vuex使用。让我们从对`Axios`的深入了解开始。
- en: '`Axios` ([https://github.com/axios/axios](https://github.com/axios/axios))
    is a JavaScript library with both `async` and `await` if you wish. Other features
    include supporting default parameters (handy for APIs that require a key for every
    call) and the ability to transform your input and output data. We will not be
    covering every use case in this chapter, but you will get a good idea of how to
    work with `Axios` for your future projects.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Axios`([https://github.com/axios/axios](https://github.com/axios/axios))是一个具有`async`和`await`功能的JavaScript库。其他功能包括支持默认参数（对于每个调用都需要键的API很有用）以及转换您的输入和输出数据的能力。在本章中，我们不会涵盖每个用例，但您将了解如何为未来的项目使用`Axios`。'
- en: To be clear, you need not use `Axios` if you do not like it. You can use any
    other library or no library at all. The Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))
    is a modern browser API for working with network requests that, while not as powerful
    as `Axios`, doesn't require an additional library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，如果您不喜欢`Axios`，您不必使用它。您可以使用任何其他库，或者根本不使用库。Fetch API([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))是一个现代浏览器API，用于处理网络请求，虽然不如`Axios`强大，但不需要额外的库。
- en: In the next section, we will look at how to install `Axios`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何安装`Axios`。
- en: Installation of Axios
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Axios的安装
- en: 'Much like Vuex, you have multiple ways of including `Axios` in your project.
    The simplest is pasting in a `<script>` tag pointing to the **Content Delivery
    Network** (**CDN**) for the library:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与Vuex类似，您有多种方法可以将`Axios`包含到项目中。最简单的方法是将指向库的**内容分发网络**（**CDN**）的`<script>`标签粘贴到项目中：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The other option is to use the `npm`. Within an existing Vue application, you
    can install `Axios` as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用`npm`。在现有的Vue应用程序中，您可以按照以下方式安装`Axios`：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you have done this, your Vue components can then import the library as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此操作，您的Vue组件就可以按照以下方式导入库：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'How you use `Axios` will depend on the API you are interacting with. Here is
    a simple example of hitting an imaginary API:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何使用`Axios`将取决于您交互的API。以下是一个简单的示例，用于调用一个假想的API：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we are performing a `GET` request (`GET` is the default)
    against an imaginary API, *https://www.raymondcamden.com/api/cats*. `Axios` returns
    promises, which means we can chain results and errors with `then` and `catch`.
    The resulting JSON (again, this is an imaginary API) is automatically parsed so
    all that is left is to assign the result to a value, in this case, a value named
    `cats` used in my Vue application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在对一个虚构的API执行`GET`请求（`GET`是默认值），即*https://www.raymondcamden.com/api/cats*。`Axios`返回promises，这意味着我们可以使用`then`和`catch`链式处理结果和错误。结果JSON（再次强调，这是一个虚构的API）会自动解析，所以剩下的只是将结果分配给一个值，在这个例子中，是一个名为`cats`的值，用于我的Vue应用程序。
- en: Let's now look at a step-by-step process of using `Axios` to load the data from
    an API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用`Axios`从API加载数据的逐步过程。
- en: 'Exercise 10.01: Using Axios to Load Data from an API'
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.01：使用Axios从API加载数据
- en: Let's look at a complex example using `Axios`. This example will make two different
    API calls against the Star Wars API and return two lists of information. For now,
    we will skip using Vuex to make this introduction a bit simpler.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用`Axios`的复杂示例。此示例将对星球大战API进行两次不同的API调用，并返回两个信息列表。目前，我们将跳过使用Vuex，以使这个介绍更简单。
- en: To access the code files for this exercise, refer to [https://packt.live/3kbn1x1](https://packt.live/3kbn1x1).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/3kbn1x1](https://packt.live/3kbn1x1)。
- en: 'Generate a new Vue application and, after the CLI has completed, add `Axios`
    as an `npm` dependency:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Vue应用程序，CLI完成之后，将`Axios`添加为`npm`依赖项：
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Open the `App.vue` page and add the import for `axios`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.vue`页面并添加对`axios`的导入：
- en: '[PRE5]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open the `App.vue` page and add the data values for the `films` and `ships` arrays:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.vue`页面并为`films`和`ships`数组添加数据值：
- en: '[PRE6]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open `App.vue` and use the created method to load in `films` and `starships`
    from the API:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.vue`并使用`created`方法从API加载`films`和`starships`：
- en: '[PRE7]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, edit the template to iterate over the values and display them:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑模板以迭代值并显示它们：
- en: '[PRE8]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Error handling is done using the catch handler but is just sent to the browser
    console. It would be better to tell the user something if the remote data did
    not load, but for now, this is acceptable. Another suggestion would be to handle
    a **loading** state, which you will see an example of later in this chapter.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误处理是通过catch处理程序完成的，但只是发送到浏览器控制台。如果远程数据没有加载，最好告诉用户一些信息，但到目前为止，这是可以接受的。另一个建议是处理**加载**状态，您将在本章后面的示例中看到。
- en: 'Start the application with the following command:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动应用程序：
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Opening the URL in your browser will generate the following output:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开URL将生成以下输出：
- en: '![Figure 10.1: Results of the API calls rendered in the browser'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.1：浏览器中渲染的API调用结果'
- en: '](img/B15218_10_01.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_10_01.jpg)'
- en: 'Figure 10.1: Results of the API calls rendered in the browser'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：浏览器中渲染的API调用结果
- en: This simple example shows how easy it is to add `Axios` to a Vue application.
    Remember that `Axios` is not required for Vue and you're welcome to use any library
    you want, or simply use the browser's native Fetch API.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例展示了将`Axios`添加到Vue应用程序是多么容易。请记住，`Axios`不是Vue的必需品，您可以使用任何您想要的库，或者简单地使用浏览器本地的Fetch
    API。
- en: 'Now that you have seen how to get `Axios` into a project, let''s look at one
    of the cooler features of `Axios`: specifying default values.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何将`Axios`引入项目，让我们看看`Axios`的一个更酷的特性：指定默认值。
- en: Using Defaults with Axios
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Axios的默认值
- en: 'While the code in *Exercise 10.01*, *Using Axios to Load Data from an API*
    works well, let''s consider a slightly more advanced example. One of the features
    of `Axios` is the ability to set up defaults that are used in future calls. If
    you look at the two calls made in the preceding code, you can see they are similar.
    You can update the `created` method to make use of this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*练习10.01*中的*使用Axios从API加载数据*代码运行良好，但让我们考虑一个稍微复杂一点的例子。`Axios`的一个特性是能够设置在后续调用中使用的默认值。如果您查看前面代码中进行的两个调用，您可以看到它们是相似的。您可以更新`created`方法来利用这一点：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this updated version, we switch to an instance of `Axios`. A default `baseURL`
    value is specified that saves on typing later. Next, the `transformResponse` feature
    is used to, well, transform the response. This lets us modify data before it is
    sent to the handler of our calls later. Since all the API calls return a results
    value and that is the only thing we are concerned with, we simplify things a bit
    by returning that instead of the rest of the result. Note that `Axios` lets you
    use an array of functions in `transformResponse` if you want to build a complex
    set of transformations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新版本中，我们切换到`Axios`的一个实例。指定了一个默认的`baseURL`值，这样在后续操作中可以节省输入。接下来，使用`transformResponse`功能来转换响应。这让我们可以在数据发送到后续调用处理程序之前对其进行修改。由于所有API调用都返回一个结果值，而我们只关心这个值，所以我们通过只返回这个值而不是整个结果来简化事情。请注意，如果你想要构建一个复杂的转换集，`Axios`允许你在`transformResponse`中使用一个函数数组。
- en: In the next section, we will learn how to use `Axios` with Vuex.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节，我们将学习如何使用`Axios`与Vuex结合。
- en: Using Axios with Vuex
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuex与Axios结合
- en: Now that you have seen the basics of working with `Axios`, it is time to consider
    how you could use it with Vuex. One way to do this simply is to just use Vuex
    to handle wrapping calls to the API, using `Axios` to perform the HTTP calls.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了使用`Axios`的基本方法，是时候考虑如何将它与Vuex结合使用了。一种简单的方法是直接使用Vuex来处理对API的调用封装，使用`Axios`来执行HTTP调用。
- en: 'Exercise 10.02: Working with Axios in Vuex'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.02：在Vuex中使用Axios
- en: We are going to take the previous functionality (loading the `films` and `ships`
    arrays) and rebuild it within the context of a Vuex store instead. As before,
    you will need to use the CLI to scaffold a new application and ensure you ask
    for Vuex to be included. When the CLI is done, you can then use the `npm` command
    to add `Axios` as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前的功能（加载`films`和`ships`数组）并在Vuex存储的上下文中重新构建它。和之前一样，你需要使用CLI来搭建一个新的应用，并确保你要求包含Vuex。CLI完成后，你可以使用`npm`命令添加`Axios`。
- en: 'This exercise will be pretty much like the first application that we built
    in *Exercise 10.01,* *Using Axios to Load Data from an API*, but with some slight
    differences. Let''s look at the UI first. On the initial load, both `Films` and
    `Ships` are empty:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将与我们在*练习10.01*中构建的第一个应用非常相似，即*使用Axios从API加载数据*，但有一些细微的差别。让我们首先看看UI。在初始加载时，`Films`和`Ships`都是空的：
- en: '![Figure 10.2: Initial application UI'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2：初始应用UI'
- en: '](img/B15218_10_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_10_02.jpg)'
- en: 'Figure 10.2: Initial application UI'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：初始应用UI
- en: 'Notice that the `Films` portion has a loading message. As soon as the application
    loads, we will fire off a request to get that data. For `Ships`, though, we wait
    for the user to specifically request they want that data. Here is how it looks
    after the `films` array loads:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Films`部分有一个加载信息。一旦应用加载，我们将发起一个请求来获取这些数据。对于`Ships`，我们则等待用户明确请求他们想要这些数据。以下是`films`数组加载后的样子：
- en: '![Figure 10.3: The application''s rendered films'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：应用的渲染电影'
- en: '](img/B15218_10_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_10_03.jpg)'
- en: 'Figure 10.3: The application''s rendered films'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：应用的渲染电影
- en: 'Finally, after clicking the `Load Ships` button, the button will disable (to
    prevent the user from requesting the data multiple times) and then the entire
    button is removed after the data is loaded:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在点击`Load Ships`按钮后，按钮将禁用（以防止用户多次请求数据），然后在数据加载完成后，整个按钮将被移除：
- en: '![Figure 10.4: The final view after everything is loaded'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4：所有内容加载完成后的最终视图'
- en: '](img/B15218_10_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_10_04.jpg)'
- en: 'Figure 10.4: The final view after everything is loaded'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：所有内容加载完成后的最终视图
- en: To access the code files for this exercise, refer to [https://packt.live/32pUsWy](https://packt.live/32pUsWy).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这个练习的代码文件，请参考[https://packt.live/32pUsWy](https://packt.live/32pUsWy)。
- en: 'Start with the first component, `App.vue`. Write the HTML. Remember that the
    `films` are displayed in the component, but `ships` will be in their own component.
    Make use of `v-else` to add a loading message that will be shown while `Axios`
    makes the HTTP request:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第一个组件`App.vue`开始，编写HTML。记住，`films`在组件中显示，但`ships`将在自己的组件中。使用`v-else`添加一个加载信息，这个信息将在`Axios`进行HTTP请求时显示：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now add the code necessary to load and register the `Ships` component:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加必要的代码来加载和注册`Ships`组件：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Import `mapState` as well:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时导入`mapState`：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, add code to map the `films` array from our store to a local computed
    value. Remember to import `mapState`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加代码将我们的存储中的`films`数组映射到一个本地的计算值。记住要导入`mapState`：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, the `created` method is used to fire off an action in our store:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`created`方法在我们的存储器中触发一个动作：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, build the `Ships` component in `components/Ship.vue`. The `Ships` component
    also contains a list of data but uses a button so that the user can request the
    data to be loaded. The button should automatically be dismissed when done and
    be disabled during the loading process:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`components/Ship.vue`中构建`Ships`组件。`Ships`组件也包含数据列表，但使用按钮让用户可以请求加载数据。按钮在完成时应该自动消失，并在加载过程中禁用：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the code to handle mapping the `ships` state and fire off the action to
    Vuex to load the `ships`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理`ships`状态映射的代码，并触发Vuex中的动作来加载`ships`：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, build the store. First, define the `state` to hold both the `films` and
    `ships` arrays:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建存储器。首先，定义`state`来保存`films`和`ships`数组：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add the actions to load `ships` and `films` data. They should both use
    `mutations` to assign values to the `state`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加加载`ships`和`films`数据的动作。它们都应该使用`mutations`来将值赋给`state`：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run your application using the following command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行您的应用程序：
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Your output will be as follows:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的输出将是以下内容：
- en: '![Figure 10.5: The final output'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图10.5：最终输出'
- en: '](img/B15218_10_05.jpg)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_10_05.jpg)'
- en: 'Figure 10.5: The final output'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：最终输出
- en: All in all, this is not a huge change from the initial version without Vuex
    (if we ignore the UI changes), but now all our API usage is handled by the store.
    If for some reason we decide to stop using `Axios` and switch to Fetch, it can
    be done here. Whether we decide to add a caching system or store the data for
    offline use, it can all be done in the store. Test this version yourself by running
    `npm run serve` and opening the URL in your browser.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这并不是与没有Vuex的初始版本有巨大变化（如果我们忽略UI变化），但现在我们所有的API使用都由存储器处理。如果我们决定停止使用`Axios`并切换到Fetch，这可以在这里完成。无论我们决定添加缓存系统还是存储数据以供离线使用，都可以在存储器中完成。通过运行`npm
    run serve`并在浏览器中打开URL来自行测试这个版本。
- en: Now it is time to put what you have learned into action with the next activity!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将您所学到的知识应用到下一个活动上了！
- en: 'Activity 10.01: Using Axios and Vuex with Authentication'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十.01：使用Axios和Vuex进行身份验证
- en: One of the more interesting things you can do with Vuex is manage authentication.
    What do we mean by that? In many APIs, authentication is required before the service
    can be used. After the user authenticates, they are given a token. On future calls
    to the API, the token is passed along, typically as a header, which lets the remote
    service know this is an authorized user. Vuex can handle all of this for you,
    and `Axios` makes it easy to work with headers, so let's consider an example of
    this in action.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex的一个更有趣的功能是管理身份验证。我们这是什么意思？在许多API中，在使用服务之前需要身份验证。用户验证后，他们会被分配一个令牌。在未来的API调用中，令牌会随请求一起传递，通常作为头部信息，这会让远程服务知道这是一个授权用户。Vuex可以为您处理所有这些，而`Axios`使得处理头部信息变得容易，所以让我们考虑一个实际操作的例子。
- en: 'Building a server with authentication and authorization is way outside the
    scope of this book, so instead, we are going to *fake* it. We will have two `JSONBin.io`,
    a service we used in *Chapter 9, Working with Vuex – State, Getters, Actions,
    and Mutations*. The first endpoint will return a token:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中构建具有身份验证和授权的服务器远远超出了本书的范围，因此，我们将采取*模拟*的方式。我们将使用两个`JSONBin.io`，这是我们曾在*第9章，使用Vuex
    – 状态、获取器、动作和突变*中使用的服务。第一个端点将返回一个令牌：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second endpoint will return an array of `cats`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个端点将返回一个`cats`数组：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this activity, we will use Vue Router to handle representing two **views**
    of the application, the login screen and the cat display screen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用Vue Router来处理表示应用程序的两个**视图**，即登录界面和猫展示界面。
- en: '**Steps**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤**：'
- en: Present a login screen for the initial view of the application. It should prompt
    for a username and password.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序的初始视图提供一个登录界面。它应该提示用户名和密码。
- en: Pass the login credentials to an endpoint and get a token. This part will be
    faked as we are not building a full, real authentication system.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将登录凭证传递给端点并获取一个令牌。这部分将进行模拟，因为我们不是在构建一个完整的、真实的身份验证系统。
- en: Load the cats from a remote endpoint and pass the token as an authentication header.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从远程端点加载猫，并将令牌作为身份验证头部传递。
- en: 'You should get the following output initially:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初始输出应该是以下内容：
- en: '![Figure 10.6: Initial login screen'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6：初始登录界面'
- en: '](img/B15218_10_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_10_06.jpg)'
- en: 'Figure 10.6: Initial login screen'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：初始登录界面
- en: 'After logging in, you will then see the data, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您将看到以下数据：
- en: '![Figure 10.7: Successfully displaying the data after login'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7：登录后成功显示数据](img/B15218_10_07.jpg)'
- en: '](img/B15218_10_07.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_10_07.jpg)'
- en: 'Figure 10.7: Successfully displaying the data after login'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：登录后成功显示数据
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor401).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以通过[此链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor401)找到。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a pretty important use case for Vuex—working with
    remote APIs. Remote APIs can provide an incredible amount of additional functionality
    to your applications, sometimes for little to no additional cost to the developer.
    You saw how to use `Axios` to make network calls easier and how to combine that
    with the state management features of Vuex. Finally, you put it together with
    Vue Router to create a simple login/authorization demo.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Vuex的一个重要用例——与远程API协同工作。远程API可以为你的应用程序提供大量的额外功能，有时对开发者的额外成本几乎为零。你看到了如何使用`Axios`使网络调用更简单，以及如何将Vuex的状态管理功能与之结合。最后，你将其与Vue
    Router结合，创建了一个简单的登录/授权演示。
- en: In the next chapter, we are going to discuss how to build more complex Vuex
    stores using modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何使用模块构建更复杂的Vuex存储。
