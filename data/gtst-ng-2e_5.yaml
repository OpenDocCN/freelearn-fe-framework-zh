- en: Chapter 5. Dependency Injection in Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Angular中的依赖注入
- en: In this chapter, we'll explain how to take advantage of the **dependency injection**
    (**DI**) mechanism of the framework, with all its various features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何利用框架的**依赖注入**（**DI**）机制及其所有各种功能。
- en: 'We will explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下主题：
- en: Configuring and creating injectors.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和创建注入器。
- en: Instantiating objects using injectors.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注入器实例化对象。
- en: Injecting dependencies into directives and components-this way, we will be able
    to reuse the business logic defined within the services and wire it up with the
    UI logic.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将依赖项注入到指令和组件中——这样，我们就能重用服务中定义的业务逻辑，并将其与UI逻辑连接起来。
- en: Annotating ES5 code in order to get the exact same result we get when we use
    the TypeScript syntax.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为ES5代码添加注解，以获得与使用TypeScript语法时相同的结果。
- en: Why do I need DI?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我需要DI？
- en: 'Let''s suppose that we have a `Car` class that depends on `Engine` and `Transmission`
    classes. How can we implement this system? Let''s take a look:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个依赖于`Engine`和`Transmission`类的`Car`类。我们如何实现这个系统？让我们看看：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, we create the dependencies of the `Car` class inside
    its constructor. Although it looks simple, it is far from being flexible. Each
    time we create an instance of the `Car` class, in its constructor, instances of
    the same `Engine` and `Transmission` classes will be created. This may be problematic
    because of the following reasons:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在`Car`类的构造函数内部创建了其依赖项。虽然看起来很简单，但它远非灵活。每次我们创建`Car`类的实例时，在其构造函数中，都会创建相同`Engine`和`Transmission`类的实例。这可能会因为以下原因而成为问题：
- en: The `Car` class gets less testable because we can't test it independently of its
    `engine` and `transmission` dependencies.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们无法独立于`engine`和`transmission`依赖项测试`Car`类，因此`Car`类变得难以测试。
- en: We couple the `Car` class with the logic used for the instantiation of its dependencies.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`Car`类与其依赖项的实例化逻辑耦合起来。
- en: DI in Angular
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的DI
- en: 'Another way we can approach this is by taking advantage of the DI pattern.
    We''re already familiar with it from AngularJS; let''s demonstrate how we can
    refactor the preceding code using DI in the context of Angular:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种处理方式是利用DI模式。我们已经在AngularJS中熟悉它了；让我们演示一下如何在Angular的上下文中使用DI重构前面的代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All we did in the preceding snippet was add the `@Injectable` class decorator
    on top of the definition of the `Car` class and provide type annotations for the
    parameters of its constructor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们只是在`Car`类的定义上方添加了`@Injectable`类装饰器，并为构造函数的参数提供了类型注解。
- en: Benefits of DI
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DI的好处
- en: 'There is one more step left, which we''ll take a look at in the next section.
    Before that, let''s take a look at what the benefits of the mentioned approach
    are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个步骤，我们将在下一节中探讨。在此之前，让我们看看这种方法的优点：
- en: We can easily pass different versions of the dependencies of the `Car` class
    for a testing environment, or for instantiating different `Car` models.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松地传递`Car`类依赖项的不同版本，用于测试环境或实例化不同的`Car`车型。
- en: We're not coupled with the logic around the dependencies' instantiation.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有与依赖项实例化的逻辑耦合。
- en: The `Car` class is only responsible for implementing its own domain-specific
    logic instead of being coupled with additional functionalities, such as the management
    of its dependencies. Our code also got more declarative and easier to read.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`类只负责实现其自身的领域特定逻辑，而不是与额外的功能耦合，例如其依赖项的管理。我们的代码也更加声明式和易于阅读。'
- en: Now, that we've realized some of the benefits of DI, let's take a look at the
    missing pieces in order to make this code work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经意识到DI的一些好处，让我们看看为了使代码工作所缺少的部分。
- en: Configuring an injector
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置注入器
- en: The primitive used for the instantiation of the individual dependencies in our
    Angular applications via the DI mechanism of the framework is called the **injector**.
    The injector contains a set of **providers** that encapsulate the logic for the
    instantiation of registered dependencies associated with **tokens**. We can think
    of tokens as identifiers of the different providers registered within the injector.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Angular应用程序中，通过框架的DI机制实例化个体依赖项所使用的原始类型被称为**注入器**。注入器包含一组**提供者**，这些提供者封装了与**令牌**关联的已注册依赖项的实例化逻辑。我们可以将令牌视为注入器内注册的不同提供者的标识符。
- en: 'Let''s take a look at the following snippet, which is located at `ch5/ts/injector-basics/injector.ts`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段，它位于 `ch5/ts/injector-basics/injector.ts`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can run the file using the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令运行文件：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you haven't installed `ts-node` yet, take a look at [Chapter 3](ch03.html
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*, which explains
    how you can proceed in order to have it up and running on your computer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 `ts-node`，请参阅 [第 3 章](ch03.html "第 3 章。TypeScript 快速入门")，*TypeScript
    快速入门*，其中解释了如何进行操作，以便在您的计算机上运行。
- en: We then import `ReflectiveInjector`, `Injectable`, `Inject`, `OpaqueToken`,
    and `provide`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导入 `ReflectiveInjector`、`Injectable`、`Inject`、`OpaqueToken` 和 `provide`。
- en: Injector represents an abstract **container** used for the instantiation of
    the different dependencies; `ReflectiveInjector` is a concrete class, which implements
    this abstraction. Using rules like the one declared, with the object literal passed
    as first argument to `resolveAndCreate` and the metadata generated by the TypeScript
    compiler, `ReflectiveInjector` knows how to create the different dependencies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注入器代表一个用于不同依赖项实例化的抽象 **容器**；`ReflectiveInjector` 是一个具体类，它实现了这个抽象。使用声明的规则，将对象字面量作为
    `resolveAndCreate` 的第一个参数传递，以及 TypeScript 编译器生成的元数据，`ReflectiveInjector` 就知道如何创建不同的依赖项。
- en: In the preceding snippet, we initially define the `BUFFER_SIZE` constant and
    set it to the `new OpaqueToken('buffer-size')` value. We can think of the value
    of `BUFFER_SIZE` as a unique value that cannot be duplicated in the application
    (`OpaqueToken` is an alternative of the `Symbol` class from ES2015, since at the
    time of writing this book, it is not supported by TypeScript).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们最初定义了 `BUFFER_SIZE` 常量，并将其设置为 `new OpaqueToken('buffer-size')` 的值。我们可以将
    `BUFFER_SIZE` 的值视为一个在应用程序中不能重复的唯一值（`OpaqueToken` 是 ES2015 中 `Symbol` 类的替代品，因为在编写这本书的时候，TypeScript
    还不支持它）。
- en: 'We defined two classes: `Buffer` and `Socket`. The `Buffer` class has a constructor
    that accepts only a single dependency called `size`, which is of the type `Number`.
    In order to add additional metadata for the process of dependency resolution,
    we use the `@Inject` parameter decorator. This decorator accepts an identifier
    (also known as **token**) for the dependency we want to inject. Usually, it is
    the type of the dependency (that is, a reference of a class), but in some cases,
    it can be a different type of value. For example, in our case, we used the instance
    of the `OpaqueToken` class.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个类：`Buffer` 和 `Socket`。`Buffer` 类有一个只接受一个名为 `size` 的依赖项的构造函数，其类型为 `Number`。为了在依赖项解析过程中添加额外的元数据，我们使用
    `@Inject` 参数装饰器。这个装饰器接受一个标识符（也称为 **标记**）作为我们想要注入的依赖项。通常，它是依赖项的类型（即类的引用），但在某些情况下，它可以是不同类型的值。例如，在我们的情况下，我们使用了
    `OpaqueToken` 类的实例。
- en: Dependency resolution with generated metadata
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于生成元数据的依赖解析
- en: Now, let's take a look at the `Socket` class. We decorate it with the `@Injectable`
    decorator. This decorator is supposed to be used by any class that accepts dependencies
    that should be injected via the DI mechanism of Angular.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Socket` 类。我们用 `@Injectable` 装饰器来装饰它。这个装饰器应该被任何接受依赖并通过 Angular 的依赖注入机制注入的类使用。
- en: The `@Injectable` decorator forces the TypeScript compiler to generate additional
    metadata for the types of dependencies that a given class accepts. This means
    that, if we omit the `@Injectable` decorator, Angular's DI mechanism will not
    be aware of the tokens associated with the dependencies it needs to resolve.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Injectable` 装饰器强制 TypeScript 编译器为给定类接受的依赖类型生成额外的元数据。这意味着，如果我们省略 `@Injectable`
    装饰器，Angular 的依赖注入机制将不会意识到它需要解析的依赖项关联的标记。'
- en: TypeScript doesn't generate any metadata if no decorator is used on top of a
    class, mostly for performance concerns. Imagine, if such metadata was generated
    for each individual class that accepts dependencies-in this case, the output would
    be bloated with an additional type metadata that would be unused.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在类上没有使用任何装饰器，TypeScript 不会生成任何元数据，这主要是出于性能考虑。想象一下，如果为每个接受依赖的单独类生成这样的元数据——在这种情况下，输出将会因为额外的未使用类型元数据而变得臃肿。
- en: 'An alternative to using `@Injectable` is to explicitly declare the tokens of
    the dependencies using the `@Inject` decorator. Take a look at the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Injectable` 的一个替代方案是使用 `@Inject` 装饰器显式声明依赖项的标记。看看下面的例子：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that the preceding code has equivalent semantics to the code that
    uses `@Injectable`, as mentioned earlier. The only difference is that Angular
    will get the type of dependency (that is, the token associated with it) explicitly
    (directly from the metadata added by the `@Inject` decorator) as compared to the
    case where `@Injectable` is used, when it will look at the metadata generated
    by the compiler.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着前面的代码与之前提到的使用`@Injectable`的代码具有等效的语义。唯一的区别是，与使用`@Injectable`的情况相比，Angular将明确（直接从`@Inject`装饰器添加的元数据）获取依赖项的类型（即与之关联的令牌），而在使用`@Injectable`的情况下，它将查看编译器生成的元数据。
- en: Instantiating an injector
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化注入器
- en: 'Now, let''s create an instance of an injector in order to use it for the instantiation
    of registered tokens:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个注入器的实例，以便使用它来实例化已注册的令牌：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We create an instance of the `ReflectiveInjector` using its static method called
    `resolveAndCreate`. This is a factory method that accepts an array of providers
    as argument and returns a new `ReflectiveInjector`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ReflectiveInjector`的静态方法`resolveAndCreate`创建其实例。这是一个接受提供者数组作为参数并返回一个新的`ReflectiveInjector`的工厂方法。
- en: '`resolve` means that the providers will go through a resolution process, which
    includes some internal processing (flattening multiple nested arrays and converting
    individual providers into an array). Later, the injector can instantiate any of
    the dependencies for which we have registered providers based on the rules the
    providers encapsulate.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`意味着提供者将经历一个解决过程，这包括一些内部处理（展平多个嵌套数组并将单个提供者转换为数组）。随后，注入器可以根据提供者封装的规则实例化我们已注册提供者的任何依赖项。'
- en: In our case, with the provider's declaration we explicitly tell the Angular's
    DI mechanism to use the value `42` when the `BUFFER_SIZE` token is required. The
    other two providers are implicit. Angular will instantiate them by invoking the
    provided class with the `new` operator once all of their dependencies are resolved.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，通过提供者的声明，我们明确告诉Angular的DI机制，当需要`BUFFER_SIZE`令牌时，使用值`42`。其他两个提供者是隐式的。Angular将在所有依赖项都解决后，通过使用`new`运算符调用提供的类来实例化它们。
- en: 'We request the `BUFFER_SIZE` value in the constructor of the `Buffer` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Buffer`类的构造函数中请求`BUFFER_SIZE`值：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we use the `@Inject` parameter decorator. It hints
    the DI mechanism that the first argument of the constructor of the `Buffer` class
    should be instantiated with the provider associated with the `BUFFER_SIZE` token
    passed to the injector.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`@Inject`参数装饰器。它暗示了DI机制，即`Buffer`类构造函数的第一个参数应该使用与注入器传递的`BUFFER_SIZE`令牌关联的提供者进行实例化。
- en: Introducing forward references
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入前向引用
- en: 'Angular introduced the concept of **forward references**. It is required due
    to the following reasons:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 引入了**前向引用**的概念。这是由于以下原因所必需的：
- en: ES2015 classes are not hoisted.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES2015类不是提升的。
- en: Allowing resolution of the dependencies that are declared after the declaration
    of the dependent providers.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在依赖提供者声明之后解决声明的依赖项。
- en: In this section, we will explain the problem that forward references solve and
    the way we can take advantage of them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释前向引用解决的问题以及我们可以如何利用它们。
- en: 'Now, let''s suppose that we have defined the `Buffer` and `Socket` classes
    in the opposite order:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们以相反的顺序定义了`Buffer`和`Socket`类：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have the exact same dependencies as the ones in the previous example
    but, in this case, the `Socket` class definition precedes the definition of the
    `Buffer` class. Note that the value of the `Buffer` identifier will equal `undefined`
    until the JavaScript virtual machine evaluates the declaration of the `Buffer`
    class. However, the metadata for the types of dependencies that `Socket` accepts
    will be generated and placed right after the `Socket` class definition. This means
    that, during the interpretation of the generated JavaScript, the value of the
    `Buffer` identifier will equal `undefined`-that is, as a type of dependency (or
    in the context of the DI mechanism of Angular, its token), the framework will
    get an invalid value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们具有与上一个示例中完全相同的依赖项，但在这个情况下，`Socket`类的定义先于`Buffer`类的定义。请注意，`Buffer`标识符的值将在JavaScript虚拟机评估`Buffer`类的声明之前等于`undefined`。然而，`Socket`接受的依赖项类型的元数据将被生成并放置在`Socket`类定义之后。这意味着，在解释生成的JavaScript代码期间，`Buffer`标识符的值将等于`undefined`——也就是说，作为一个依赖项的类型（或在Angular的DI机制中，其token），框架将获得一个无效的值。
- en: 'Running the preceding snippet will result in a runtime error of the following
    form:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段将导致以下形式的运行时错误：
- en: '****Error: Cannot resolve all parameters for Socket(undefined). Make sure they
    all have valid type or annotations.****'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '****错误：无法解析`Socket(undefined)`的所有参数。请确保它们都具有有效的类型或注解。****'
- en: 'The best way to resolve this issue is by swapping the definitions with their
    proper order. Another way we can proceed is to take advantage of a solution that
    Angular provides-a forward reference:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的最佳方式是通过交换定义的正确顺序。另一种我们可以采取的方法是利用Angular提供的解决方案——前向引用：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding snippet demonstrates how we can take advantage of forward references.
    All we need to do is invoke the `@Inject` parameter decorator with argument the
    result of the invocation of the `forwardRef` function. The `forwardRef` function
    is a higher-order function that accepts a single argument-another function that
    is responsible for returning the token associated with the dependency (or more
    precisely associated with its provider) that needs to be injected. This way, the
    framework provides a way to defer the process of resolving the types (tokens)
    of dependencies.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了我们如何利用前向引用的优势。我们只需要使用带有`forwardRef`函数调用结果的`@Inject`参数装饰器即可。`forwardRef`函数是一个高阶函数，它接受一个单一参数——另一个负责返回需要注入的依赖项（或更精确地说，其提供者）所关联的标记（token）的函数。这样，框架提供了一种延迟解析依赖项（token）类型的过程的方法。
- en: The token of the dependency will be resolved the first time `Socket` needs to
    be instantiated, unlike the default behavior in which the token is required at
    the time of the declaration of the given class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的标记将在第一次需要实例化`Socket`时解析，这与默认行为不同，在默认行为中，标记在给定类的声明时就需要。
- en: Configuring providers
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置提供者
- en: 'Now, let''s take a look at an example similar to the one used earlier, but
    with a different configuration of the injector:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个与之前使用的示例类似，但具有不同注入器配置的例子：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, inside the provider, we explicitly declared that we want the `Buffer`
    class to be used for the construction of the dependency with a token equal to
    the reference of the `Buffer` class. We do the exact same thing for the dependency
    associated with the `Socket` token; but, this time, we provided the `Socket` class
    instead. This is how Angular will proceed when we omit the explicit provider declaration and
    pass only a reference to a class instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在提供者内部，我们明确声明我们希望使用`Buffer`类来构建具有与`Buffer`类引用相等的token的依赖项。我们对与`Socket`token关联的依赖项做完全相同的事情；但这次，我们提供了`Socket`类。这就是Angular在省略显式提供者声明并仅传递类引用时将如何操作。
- en: Explicitly declaring the class used for the creation of an instance of the same
    class may seem quite worthless, and given the examples we have looked at so far,
    that'd be completely correct. In some cases, however, we might want to provide
    a different class for the instantiation of a dependency associated with a given
    class token.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 明确声明用于创建同一类实例的类可能看起来毫无价值，并且鉴于我们迄今为止看到的示例，这将是完全正确的。然而，在某些情况下，我们可能希望为与给定类token关联的依赖项实例化提供不同的类。
- en: 'For example, let''s suppose we have the `Http` service that is used in a service
    called `UserService`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个名为`UserService`的服务中使用的`Http`服务：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `UserService` service uses `Http` for communication with a RESTful service.
    We can instantiate `UserService` using `injector.get(UserService)`. This way,
    the constructor of `UserService` invoked by the injector''s `get` method will
    accept an instance of the `Http` service as an argument. However, if we want to
    test `UserService`, we don''t really need to make HTTP calls to the RESTful service.
    In the case of unit testing, we can provide a dummy implementation that will only
    fake these HTTP calls. In order to inject an instance of a different class to
    the `UserService` service, we can change the configuration of the injector to
    the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService` 服务使用 `Http` 与 RESTful 服务进行通信。我们可以使用 `injector.get(UserService)`
    来实例化 `UserService`。这样，由注入器的 `get` 方法调用的 `UserService` 的构造函数将接受一个 `Http` 服务实例作为参数。然而，如果我们想测试
    `UserService`，我们实际上并不需要向 RESTful 服务发起 HTTP 请求。在单元测试的情况下，我们可以提供一个模拟实现，它只会模拟这些 HTTP
    请求。为了将不同类的实例注入到 `UserService` 服务中，我们可以更改注入器的配置如下：'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, when we instantiate `UserService`, its constructor will receive a reference
    to an instance of the `DummyHttp` service. This code is available at `ch5/ts/configuring-providers/dummy-http.ts`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们实例化 `UserService` 时，它的构造函数将接收一个 `DummyHttp` 服务实例的引用。此代码位于 `ch5/ts/configuring-providers/dummy-http.ts`。
- en: Using existing providers
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用现有提供者
- en: 'Another way to proceed is by using the `useExisting` property of the provider''s
    configuration object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种进行的方式是使用提供者配置对象的 `useExisting` 属性：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding snippet, we register three tokens: `DummyService`, `UserService`,
    and `Http`. We declare that we want to bind the `Http` token to the existing token,
    `DummyService`. This means that, when the `Http` service is requested, the injector
    will find the provider for the token used as the value of the `useExisting` property
    and instantiate it or get the value associated with it. We can think of `useExisting`
    as creating an alias of the given token:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们注册了三个令牌：`DummyService`、`UserService` 和 `Http`。我们声明我们希望将 `Http` 令牌绑定到现有的
    `DummyService` 令牌。这意味着当请求 `Http` 服务时，注入器将找到作为 `useExisting` 属性值的令牌的提供者，并实例化它或获取与之关联的值。我们可以将
    `useExisting` 视为为给定令牌创建一个别名：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding snippet will create an alias of the `Http` token to the `DummyHttp`
    token. This means that once the `Http` token is requested, the call will be forwarded
    to the provider associated with the `DummyHttp` token, which will be resolved
    to the value of `dummyHttp`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将为 `Http` 令牌创建一个 `DummyHttp` 令牌的别名。这意味着一旦请求 `Http` 令牌，调用将被转发到与 `DummyHttp`
    令牌关联的提供者，它将被解析为 `dummyHttp` 的值。
- en: Defining factories for instantiating services
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用于实例化服务的工厂
- en: Now, let's suppose that we want to create a complex object, for example, one
    that represents a **Transport Layer Security** (**TLS**) connection. A few of
    the properties of such an object are a socket, a set of crypto protocols, and
    a certificate. In the context of this problem, the features of the DI mechanism
    of Angular we have looked at so far might seem a bit limited.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要创建一个复杂对象，例如，代表传输层安全性（**TLS**）连接的对象。此类对象的一些属性包括套接字、一组加密协议和证书。在这个问题的背景下，我们迄今为止所查看的
    Angular 的依赖注入（DI）机制的功能可能看起来有些有限。
- en: For example, we might need to configure some of the properties of the `TLSConnection`
    class without coupling the process of its instantiation with all the configuration
    details (choose appropriate crypto algorithms, open the TCP socket over which
    we will establish the secure connection, and so on).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能需要配置 `TLSConnection` 类的一些属性，而不将其实例化过程与所有配置细节耦合（选择合适的加密算法，打开我们将通过它建立安全连接的
    TCP 套接字等）。
- en: 'In this case, we can take advantage of the `useFactory` property of the provider''s
    configuration object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以利用提供者配置对象的 `useFactory` 属性：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The snippet above seems a bit complex at first, but let''s take a look at it
    step-by-step. We can start with the parts we''re already familiar with:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段一开始可能看起来有些复杂，但让我们一步一步地来看。我们可以从我们已经熟悉的部分开始：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Initially, we register a number of providers: `Buffer`, `Socket`, `Certificate`,
    and `Crypto`. Just like in the preceding example, we also register the `BUFFER_SIZE`
    token and associated it with the value `42`. This means that we can already create
    objects of the `Buffer`, `Socket`, `Certificate`, and `Crypto` types, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们注册了多个提供者：`Buffer`、`Socket`、`Certificate`和`Crypto`。就像前面的例子一样，我们也注册了`BUFFER_SIZE`令牌并将其与值`42`关联。这意味着我们已经可以创建`Buffer`、`Socket`、`Certificate`和`Crypto`类型的对象，如下所示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can create and configure an instance of the `TLSConnection` object in the
    following way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式创建和配置`TLSConnection`对象的一个实例：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, if we register a provider that has the `TLSConnection` token as a dependency,
    we will prevent the DI mechanism of Angular from taking care of the dependency
    resolution process. In order to handle this problem, we can use the `useFactory`
    property of the provider''s configuration object. This way, we can specify a function
    in which we can manually create the instance of the object associated with the
    provider''s token. We can use the `useFactory` property together with the `deps`
    property in order to specify the dependencies to be passed to the factory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们注册一个具有`TLSConnection`令牌作为依赖项的提供者，我们将阻止Angular的依赖注入机制处理依赖项解析过程。为了解决这个问题，我们可以使用提供者配置对象的`useFactory`属性。这样，我们可以指定一个函数，在其中我们可以手动创建与提供者令牌关联的对象的实例。我们可以使用`useFactory`属性与`deps`属性一起使用，以指定要传递给工厂的依赖项：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding snippet, we define the factory function used for the instantiation
    of `TLSConnection`. As dependencies, we declare `Socket`, `Certificate`, and `Crypto`.
    These dependencies are resolved by the DI mechanism of Angular and injected into
    the factory function. You can take a look at the entire implementation and play
    with it at `ch5/ts/configuring-providers/factory.ts`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了用于`TLSConnection`实例化的工厂函数。作为依赖项，我们声明了`Socket`、`Certificate`和`Crypto`。这些依赖项由Angular的依赖注入机制解析并注入到工厂函数中。您可以查看整个实现并在`ch5/ts/configuring-providers/factory.ts`中尝试它。
- en: Child injectors and visibility
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子注入器和可见性
- en: In this section, we will take a look at how we can build a hierarchy of injectors.
    This is a completely new concept in the framework introduced by Angular 2\. Each
    injector can have either zero or one parent injectors, and each parent injector
    can have zero or more children. In contrast to AngularJS where all the registered
    providers are stored in a flat structure, in Angular 2 and later versions, they
    are stored in a tree. The flat structure is more limited; for instance, it doesn't
    support the namespacing of tokens; we cannot declare different providers for the
    same token, which might be required in some cases. So far, we have looked at an
    example of an injector that doesn't have any children or a parent. Now, let's
    build a hierarchy of injectors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何构建注入器的层次结构。这是Angular 2框架中引入的一个全新的概念。每个注入器可以有一个或没有父注入器，每个父注入器可以有零个或多个子注入器。与AngularJS中所有注册的提供者都存储在扁平结构中不同，在Angular
    2及以后的版本中，它们被存储在树中。扁平结构更为有限；例如，它不支持令牌的命名空间；我们无法为相同的令牌声明不同的提供者，这在某些情况下可能是必需的。到目前为止，我们已经查看了一个没有子注入器或父注入器的注入器示例。现在，让我们构建一个注入器的层次结构。
- en: 'In order to gain a better understanding of this hierarchical structure of injectors,
    let''s take a look at the following diagram:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解注入器的这种层次结构，让我们看一下以下图表：
- en: '![Child injectors and visibility](img/5081_05_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![子注入器和可见性](img/5081_05_01.jpg)'
- en: Figure 1
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: 'Here, we see a tree where each node is an injector, and each of these injectors
    keeps a reference to its parent. The injector **House** has three child injectors:
    **Bathroom**, **Kitchen**, and **Garage**.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个树，每个节点都是一个注入器，这些注入器中的每一个都保留对其父注入器的引用。注入器**房屋**有三个子注入器：**浴室**、**厨房**和**车库**。
- en: '**Garage** has two child injectors: **Car** and **Storage**. We can think of
    these injectors as containers with registered providers inside of them.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**车库**有两个子注入器：**汽车**和**储藏室**。我们可以将这些注入器视为内部注册有提供者的容器。'
- en: Let's suppose that we want to get the value of the provider associated with
    the token **Tire**. If we use the injector **Car**, this means that Angular's
    DI mechanism will try to find the provider associated with this token in **Car**
    and all of its parents, **Garage** and **House**, until it finds it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取与令牌 **Tire** 关联的提供者的值。如果我们使用注入器 **Car**，这意味着 Angular 的 DI 机制将尝试在 **Car**
    及其所有父级 **Garage** 和 **House** 中找到与该令牌关联的提供者，直到找到为止。
- en: Building a hierarchy of injectors
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建注入器层次结构
- en: 'In order to gain a better understanding of the paragraph, let''s take a look
    at this simple example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解段落，让我们看看这个简单的例子：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The imports are omitted since they are not essential to explain the code. We
    have two services, `Http` and `UserService`, where `UserService` depends on the
    `Http` service.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 省略了导入，因为它们对于解释代码不是必要的。我们有两个服务，`Http` 和 `UserService`，其中 `UserService` 依赖于 `Http`
    服务。
- en: Initially, we create an injector using the `resolveAndCreate` static method
    of the `ReflectiveInjector` class. We pass an implicit provider to this injector,
    which will later be resolved to a provider with an `Http` token. Using `resolveAndCreateChild`,
    we resolve the passed providers and instantiate an injector, which points to `parentInjector`
    (so, we get the same relation as the one between **Garage** and **House** shown
    in the previous diagram).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们使用 `ReflectiveInjector` 类的 `resolveAndCreate` 静态方法创建一个注入器。我们向这个注入器传递一个隐式提供者，该提供者稍后将解析为一个具有
    `Http` 令牌的提供者。使用 `resolveAndCreateChild`，我们解析传递的提供者并实例化一个注入器，该注入器指向 `parentInjector`（因此，我们得到与之前图中
    **Garage** 和 **House** 之间的相同关系）。
- en: Now, using `childInjector.get(UserService)`, we are able to get the value associated
    with the `UserService` token. Similarly, using `childInjector.get(Http)` and `parentInjector.get(Http)`,
    we get the same value associated with the `Http` token. This means that `childInjector`
    asks its parent for the value associated with the requested token.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `childInjector.get(UserService)`，我们能够获取与 `UserService` 令牌关联的值。同样，使用 `childInjector.get(Http)`
    和 `parentInjector.get(Http)`，我们获取与 `Http` 令牌关联的相同值。这意味着 `childInjector` 向其父级请求与请求的令牌关联的值。
- en: However, if we try to use `parentInjector.get(UserService)`, we won't be able
    to get the value associated with the token, since its provider is registered in
    `childInjector`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试使用 `parentInjector.get(UserService)`，我们将无法获取与令牌关联的值，因为它的提供者已在 `childInjector`
    中注册。
- en: Configuring dependencies
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置依赖项
- en: Now that we're familiar with the injectors' hierarchy, let's see how we can
    get the dependencies from the appropriate injectors in it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了注入器的层次结构，让我们看看我们如何从其中的适当注入器获取依赖项。
- en: Using the @Self decorator
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 @Self 装饰器
- en: 'Now, let''s suppose that we have the following configuration:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有以下配置：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can instantiate the `UserService` token using:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式实例化 `UserService` 令牌：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `UserService`, we can declare that we want to get the `Channel` dependency
    from the current injector (that is, `childInjector`) using the `@Self` decorator:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UserService` 中，我们可以声明我们想要从当前注入器（即 `childInjector`）使用 `@Self` 装饰器获取 `Channel`
    依赖项：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Although this will be the default behavior during the instantiation of the
    `UserService`, using `@Self`, we can be more explicit. Let''s suppose that we
    change the configuration of `childInjector` to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这将是 `UserService` 实例化期间的默认行为，但使用 `@Self`，我们可以更加明确。假设我们更改 `childInjector` 的配置如下：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we keep the `@Self` decorator in the `UserService` constructor and try to
    instantiate `UserService` using `childInjector`, we will get a runtime error because
    of the missing provider for `Channel`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `UserService` 构造函数中保留 `@Self` 装饰器，并尝试使用 `childInjector` 实例化 `UserService`，我们将因为缺少
    `Channel` 提供者而得到一个运行时错误。
- en: Skipping the self injector
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过自身注入器
- en: 'In some cases, we may want to use the provider registered in the parent injector
    instead of the one registered in the current injector. We can achieve this behavior
    by taking advantage of the `@SkipSelf` decorator. For instance, let''s suppose
    that we have the following definition of the `Context` class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能想要使用父注入器中注册的提供者，而不是当前注入器中注册的提供者。我们可以通过利用 `@SkipSelf` 装饰器来实现这种行为。例如，假设我们有以下
    `Context` 类的定义：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each instance of the `Context` class has a parent. Now, let''s build a hierarchy
    of two injectors, which will allow us to create a context with a parent context:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context` 类的每个实例都有一个父级。现在，让我们构建一个包含两个注入器的层次结构，这将允许我们创建一个具有父上下文的上下文：'
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since the root context doesn't have a parent, we will set the value of its provider
    to be `new Context(null)`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于根上下文没有父上下文，我们将其提供者的值设置为`new Context(null)`。
- en: 'If we want to instantiate the child context, we can use:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想实例化子上下文，我们可以使用：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For the instantiation of the child, `Context` will be used by the provider registered
    within the `childInjector`. However, as a dependency, it accepts an object that
    is an instance of the `Context` class. Such classes exist in the same injector,
    which means that Angular will try to instantiate it, but it has a dependency of
    the `Context` type. This process will lead to an infinite loop that will cause
    a runtime error.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于子实例的创建，`Context`将由在`childInjector`中注册的提供者使用。然而，作为一个依赖项，它接受一个`Context`类的实例对象。这样的类存在于同一个注入器中，这意味着Angular将尝试实例化它，但它有一个`Context`类型的依赖项。这个过程将导致一个无限循环，这将导致运行时错误。
- en: 'In order to prevent it from happening, we can change the definition of `Context`
    in the following way:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们可以按以下方式更改`Context`的定义：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The only change that we introduced is the addition of the parameter decorator
    `@SkipSelf`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入的唯一更改是添加了参数装饰器`@SkipSelf`。
- en: Having optional dependencies
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有可选依赖项
- en: Angular 2 introduced the `@Optional` decorator, which allows us to deal with
    dependencies that don't have a registered provider associated with them. Let's
    suppose that a dependency of a provider is not available in any of the target
    injectors responsible for its instantiation. If we use the `@Optional` decorator,
    during the instantiation of the dependent provider the value of the missing dependency
    will be passed `null`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2引入了`@Optional`装饰器，它允许我们处理没有与它们关联的注册提供者的依赖项。假设一个提供者的依赖项在任何负责其实例化的目标注入器中都不可用。如果我们使用`@Optional`装饰器，在依赖提供者的实例化过程中，缺失的依赖项的值将被传递为`null`。
- en: 'Now, let''s take a look at the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下示例：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, we defined an abstract class called `SortingAlgorithm` and a class
    called `Collection`, which accepts an instance of a concrete class as a dependency
    that extends `SortingAlgorithm`. Inside the `Collection` constructor, we set the
    `sort` instance property to the passed dependency of the `SortingAlgorithm` type
    or a default sorting algorithm implementation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们定义了一个名为`SortingAlgorithm`的抽象类和一个名为`Collection`的类，它接受一个扩展`SortingAlgorithm`的具体类实例作为依赖项。在`Collection`构造函数中，我们将`sort`实例属性设置为传递的`SortingAlgorithm`类型依赖项或默认排序算法实现。
- en: We didn't define any providers for the `SortingAlgorithm` token in the injector
    we configured. So, if we want to get an instance of the `Collection` class using
    `injector.get(Collection)`, we'll get a runtime error. This means that if we want
    to get an instance of the `Collection` class using the DI mechanism of the framework,
    we must register a provider for the `SortingAlgorithm` token, although we may
    want to fall back to a default sorting algorithm, returned by the `getDefaultSort`
    method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置的注入器中没有为`SortingAlgorithm`令牌定义任何提供者。因此，如果我们想使用`injector.get(Collection)`获取`Collection`类的实例，我们将得到一个运行时错误。这意味着如果我们想通过框架的DI机制获取`Collection`类的实例，我们必须为`SortingAlgorithm`令牌注册一个提供者，尽管我们可能希望回退到由`getDefaultSort`方法返回的默认排序算法。
- en: 'Angular provides a solution to this problem with the `@Optional` decorator.
    This is how we can approach the problem using it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过`@Optional`装饰器提供了这个问题的解决方案。这就是我们如何使用它来解决这个问题：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding snippet, we declare the `sort` dependency as optional, which
    means that if Angular doesn't find any provider for its token, it will pass the
    `null` value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将`sort`依赖项声明为可选的，这意味着如果Angular找不到任何提供者来处理其令牌，它将传递`null`值。
- en: Using multiproviders
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多提供者
- en: Multiproviders are another new concept introduced to the DI mechanism of Angular
    in version 2\. They allow us to associate multiple providers with the same token.
    This can be quite useful if we're developing a third-party library that comes
    with some default implementations of different services, but you want to allow
    the users to extend it with custom ones. They are also exclusively used to declare
    multiple validations over a single control in the Angular's form module. We will
    explain this module in [Chapter 6](ch06.html "Chapter 6. Working with the Angular
    Router and Forms"), *Working with the Angular Router and Forms*, and [Chapter
    7](ch07.html "Chapter 7. Explaining Pipes and Communicating with RESTful Services"),
    *Explaining Pipes and Communicating with RESTful Services*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 多提供者（Multiproviders）是Angular在版本2中引入的另一个新概念。它们允许我们将多个提供者与同一个令牌（token）关联起来。如果我们正在开发一个带有一些默认服务实现的第三方库，但希望用户能够用自定义实现来扩展它，这将非常有用。它们还专门用于在Angular表单模块中声明对单个控件的多重验证。我们将在[第6章](ch06.html
    "第6章。使用Angular路由和表单")*使用Angular路由和表单*和[第7章](ch07.html "第7章。解释管道和与RESTful服务通信")*解释管道和与RESTful服务通信*中解释这个模块。
- en: Another sample of an applicable use case of multiproviders is what Angular uses
    for event management in its Web Workers implementation. They create multiproviders
    for event management plugins. Each of the providers return a different strategy,
    which supports a different set of events (touch events, keyboard events, and so
    on). Once a given event occurs, they can choose the appropriate plugin that handles
    it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个多提供者（multiproviders）的适用用例是Angular在其Web Workers实现中用于事件管理。他们为事件管理插件创建了多提供者。每个提供者返回不同的策略，支持不同的事件集（触摸事件、键盘事件等）。一旦发生特定事件，他们可以选择处理该事件的适当插件。
- en: 'Let''s take a look at an example that illustrates a typical usage of multiproviders:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，它说明了多提供者（multiproviders）的典型用法：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding snippet, we declare a constant called `VALIDATOR` and as its
    value we set a new instance of `OpaqueToken`. We also create an injector where
    we register three providers-two of them provide functions that, based on different
    criteria, validate instances of the class `Employee`. These functions are of the
    type `EmployeeValidator`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为`VALIDATOR`的常量，并将其值设置为`OpaqueToken`的新实例。我们还创建了一个注入器，在其中注册了三个提供者——其中两个提供基于不同标准的函数，这些函数用于验证`Employee`类的实例。这些函数的类型是`EmployeeValidator`。
- en: 'In order to declare that we want the injector to pass all the registered validators
    to the constructor of the `Employee` class, we need to use the following constructor
    definition:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明我们希望注入器将所有注册的验证器传递给`Employee`类的构造函数，我们需要使用以下构造函数定义：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the example, we declare a class `Employee` that accepts a single dependency:
    an array of `EmployeeValidator`s. In the method `validate`, we apply the individual
    validators over the current class instance and filter the results in order to
    get only the ones that have returned an error message.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们声明了一个名为`Employee`的类，它接受一个依赖项：一个`EmployeeValidator`数组。在`validate`方法中，我们对当前类的实例应用单个验证器，并过滤结果以仅获取返回错误消息的验证器。
- en: Note that the constructor argument `validators` is of the `EmployeeValidator[]`
    type. Since we can't use the type "array of objects" as a token for a provider,
    because it is not a valid value in JavaScript and can't be used as a token, we
    will need to use the `@Inject` parameter decorator.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构造函数参数`validators`的类型是`EmployeeValidator[]`。由于我们不能使用“对象数组”作为提供者的令牌，因为它在JavaScript中不是一个有效的值，也不能用作令牌，因此我们需要使用`@Inject`参数装饰器。
- en: Using DI with components and directives
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DI（依赖注入）与组件和指令
- en: In [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*, when
    we developed our first Angular directive, we saw how we can take advantage of
    the DI mechanism to inject services into our UI-related components (that is, directives
    and components).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。开始使用Angular组件和指令")*开始使用Angular组件和指令*中，当我们开发我们的第一个Angular指令时，我们看到了如何利用DI机制将服务注入到我们的UI相关组件（即指令和组件）中。
- en: 'Let''s take a quick look at what we did earlier, but from a DI perspective:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下之前所做的工作，但这次是从DI（依赖注入）的角度来看：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Most of the code from the earlier implementation is omitted because it is not
    directly related to our current focus.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与我们的当前焦点无直接关系，因此省略了早期实现中的大部分代码。
- en: 'Note that the constructor of `Tooltip` accepts two dependencies:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Tooltip` 的构造函数接受两个依赖项：
- en: An instance of the `ElementRef` class.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementRef` 类的一个实例。'
- en: An instance of the `Overlay` class.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Overlay` 类的一个实例。'
- en: The types of dependencies are the tokens associated with their providers and
    the corresponding values obtained from the providers will be injected with the
    DI mechanism of Angular.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的类型是与它们的提供者关联的令牌，以及从提供者获得的相应值，这些值将通过 Angular 的依赖注入机制进行注入。
- en: Although the declaration of the dependencies of the `Tooltip` class looks exactly
    the same as what we did in the previous sections, there's neither any explicit
    configuration nor any instantiation of an injector. In this case, Angular internally
    creates and configures the so called **element injector**. We'll explain it a
    little bit later, but before that, lets take a look at how we can configure the
    DI mechanism using NgModules.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Tooltip` 类的依赖项声明看起来与我们在前面的章节中做的完全一样，但既没有显式的配置，也没有注入器的实例化。在这种情况下，Angular
    内部创建并配置了所谓的 **元素注入器**。我们稍后会稍作解释，但在那之前，让我们看看我们如何使用 NgModules 配置 DI 机制。
- en: Configuring DI with NgModules
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NgModules 配置 DI
- en: We have already talked about NgModules in [Chapter 2](ch02.html "Chapter 2. The
    Building Blocks of an Angular Application"), *The Building Blocks of an Angular
    Application* and [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular
    Components and Directives"), *Getting Started with Angular Components and Directives*.
    We mentioned that they help us to divide our application into logical parts; we
    also discussed how to use NgModules' imports and exports. In this section, we'll
    look at a brief overview of how we can use them to configure the providers of
    our application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第二章](ch02.html "第二章。Angular 应用程序的构建块")、*Angular 应用程序的构建块* 和 [第四章](ch04.html
    "第四章。开始使用 Angular 组件和指令")、*开始使用 Angular 组件和指令* 中讨论了 NgModules。我们提到它们帮助我们将应用程序划分为逻辑部分；我们还讨论了如何使用
    NgModules 的导入和导出。在本节中，我们将简要概述我们如何使用它们来配置应用程序的提供者。
- en: 'Based on the providers declared in a given NgModule, Angular will instantiate
    an injector. This injector will manage all the providers that are listed in the
    `providers` property of the object literal we pass to the `@NgModule` decorator:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Angular 在给定 NgModule 中声明的提供者，Angular 将实例化一个注入器。这个注入器将管理我们传递给 `@NgModule`
    装饰器的对象字面量中 `providers` 属性列出的所有提供者：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, we declare a single provider for the `Markdown` service.
    It will be available in all the components and directives listed in the `declarations`
    array because the injectors used by the top-level components will get the one
    configured through the NgModule as their parent injector.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为 `Markdown` 服务声明了一个单独的提供者。因为它将可用于在 `declarations` 数组中列出的所有组件和指令，因为顶级组件使用的注入器将获得通过
    NgModule 配置的注入器作为其父注入器。
- en: 'Now, let''s suppose that our module imports another module that has a declaration
    of providers:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的模块导入另一个模块，该模块有提供者的声明：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the example, we have two modules – the `AppModule` we previously saw and
    `ButtonModule`. In the snippet `AppModule` imports `ButtonModule`, which means
    that all the exports of `ButtonModule` will be available as declarations in `AppModule`.
    On top of that, the providers declared in `ButtonModule` will be merged with the
    providers of `AppModule`. Based on all these providers, Angular will instantiate an
    injector and set it as a parent injector to the injector used by the bootstrap
    component - `App`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个模块——我们之前看到的 `AppModule` 和 `ButtonModule`。在 `AppModule` 导入 `ButtonModule`
    的片段中，这意味着 `ButtonModule` 的所有导出都将作为 `AppModule` 中的声明可用。除此之外，`ButtonModule` 中声明的提供者将与
    `AppModule` 的提供者合并。基于所有这些提供者，Angular 将实例化一个注入器，并将其设置为启动组件 `App` 使用的注入器的父注入器。
- en: Now, let's discuss the element injector that each component and directive has
    associated to it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论每个组件和指令关联的元素注入器。
- en: Introducing the element injectors
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍元素注入器
- en: 'Under the hood, Angular will create injectors for all the directives and components,
    and add a default set of providers to them. These are the so-called **element
    injectors** and are something the framework takes care of itself. The injectors
    associated with the components are called **host injectors**. One of the providers
    in each element injector is associated with the `ElementRef` token; it will return
    a reference to the host element of the directive. However, where is the provider
    for the `Overlay` class declared? Let''s take a look at the implementation of
    the top-level component:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Angular将为所有指令和组件创建注入器，并将一组默认的提供者添加到它们中。这些被称为**元素注入器**，是框架自己处理的事情。与组件关联的注入器称为**宿主注入器**。每个元素注入器中的一个提供者与`ElementRef`令牌相关联；它将返回指令的主元素引用。然而，`Overlay`类的提供者在哪里声明呢？让我们看看顶级组件的实现：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We configure the element injector for the `App` component by declaring the `providers`
    property inside the `@Component` decorator. At this point, the registered providers
    will be visible by the directive or the component associated with the corresponding
    element injector and the component's entire component subtree, unless they are overridden
    somewhere in the hierarchy.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`@Component`装饰器内部声明`providers`属性来配置`App`组件的元素注入器。在这个阶段，注册的提供者将由指令或与相应元素注入器关联的组件以及组件的整个组件子树可见，除非它们在层次结构中的某个地方被覆盖。
- en: Declaring providers for the element injectors
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明元素注入器的提供者
- en: Having the declaration of all the providers in the same place might be quite
    inconvenient. For example, imagine we're developing a large-scale application
    that has hundreds of components depending on thousands of services. In this case,
    configuring all the providers in the root component is not a practical solution.
    There will be name collisions when two or more providers are associated with the
    same token. The configuration will be huge, and it will be hard to trace where
    the different dependencies need to be injected.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有提供者的声明放在同一个地方可能相当不方便。例如，想象一下我们正在开发一个大型应用程序，该应用程序有数百个组件依赖于数千个服务。在这种情况下，在根组件中配置所有提供者不是一个实际的解决方案。当两个或多个提供者与同一个令牌相关联时，将发生名称冲突。配置将非常大，并且很难追踪不同的依赖项需要注入的位置。
- en: 'As we mentioned, Angular''s `@Directive` (and `@Component`) decorator allows
    us to introduce directive-specific providers using the `providers` property. Here
    is how we can approach this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，Angular的`@Directive`（以及`@Component`）装饰器允许我们使用`providers`属性引入特定于指令的提供者。以下是我们可以如何接近这个问题的方法：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding example overrides the provider for the `Overlay` token in the
    `Tooltip` directive's declaration. This way, Angular will inject an instance of
    `OverlayMock` instead of `Overlay` during the instantiation of the tooltip.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例覆盖了`Tooltip`指令声明中的`Overlay`令牌的提供者。这样，Angular在提示框实例化期间将注入`OverlayMock`实例而不是`Overlay`。
- en: Exploring DI with components
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用组件探索依赖注入
- en: Since components are generally directives with views, everything we've seen
    so far regarding how the DI mechanism works with directives is valid for components
    as well. However, because of the extra features that the components provide, we're
    allowed to have further control over their providers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件通常是具有视图的指令，因此我们迄今为止所看到的所有关于DI机制如何与指令一起工作的内容也适用于组件。然而，由于组件提供的额外功能，我们允许对它们的提供者有更多的控制。
- en: As we said, the injector associated with each component will be marked as a
    **host** injector. There's a parameter decorator called `@Host`, which allows
    us to retrieve a given dependency from any injector until it reaches the closest
    host injector. This means that, using the `@Host` decorator in a directive, we
    can declare that we want to retrieve the given dependency from the current injector
    or any parent injector until we reach the injector of the closest parent component.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，与每个组件关联的注入器将被标记为**宿主注入器**。有一个名为`@Host`的参数装饰器，它允许我们从任何注入器中检索给定的依赖项，直到它达到最近的宿主注入器。这意味着，在指令中使用`@Host`装饰器，我们可以声明我们想要从当前注入器或任何父注入器中检索给定的依赖项，直到我们达到最近父组件的注入器。
- en: The `viewProviders` property added to the `@Component` decorator is in charge
    of achieving even more control.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`@Component`装饰器中的`viewProviders`属性负责实现更多的控制。
- en: viewProviders versus providers
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: viewProviders与providers的比较
- en: 'Let''s take a look at an example of a component called `MarkdownPanel`. This
    component will be used in the following way:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个名为 `MarkdownPanel` 的组件的例子。这个组件将以下这种方式使用：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The content of each section of the panel will be translated from markdown to
    HTML. We can delegate this functionality to a service called `Markdown`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 面板每个部分的内文将是从 markdown 转换为 HTML。我们可以将此功能委托给一个名为 `Markdown` 的服务：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Markdown` service wraps the `markdown` module in order to make it injectable
    through the DI mechanism.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Markdown` 服务将 `markdown` 模块包装起来，以便通过 DI 机制进行注入。'
- en: Now let's implement `MarkdownPanel`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现 `MarkdownPanel`。
- en: 'In the following snippet, we can find all the important details from the component''s
    implementation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们可以找到组件实现的所有重要细节：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `@Component` decorator, we use the `markdown-panel` selector and set
    the `viewProviders` property. In this case, there''s only a single view provider:
    the one for the `Markdown` service. By setting this property, we declare that
    all the providers declared in it will be accessible from the component itself
    and all of its **view children**.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `@Component` 装饰器中，我们使用 `markdown-panel` 选择器并设置 `viewProviders` 属性。在这种情况下，只有一个视图提供者：为
    `Markdown` 服务提供的那个。通过设置此属性，我们声明其中声明的所有提供者都将从组件本身及其所有 **视图子组件** 中可访问。
- en: 'Now, let''s suppose we have a component called `MarkdownButton` and we want
    to add it to our template in the following way:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个名为 `MarkdownButton` 的组件，并且我们想以下这种方式将其添加到我们的模板中：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Markdown` service will not be accessible by the `MarkdownButton` used
    below the `panel-content` element; however, it''ll be accessible if we use the
    button in the component''s template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `panel-content` 元素中使用的 `MarkdownButton` 无法访问 `Markdown` 服务；然而，如果我们在这个组件的模板中使用按钮，它将是可访问的：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If we need the provider to be visible in all the content and view children,
    all we should do is change the name of the property `viewProviders` to `providers`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要提供者在所有内容和视图子组件中可见，我们只需将属性 `viewProviders` 的名称更改为 `providers`。
- en: You can find this example in the examples directory at `ch5/ts/directives/app.ts`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `ch5/ts/directives/app.ts` 目录下的示例目录中找到这个例子。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, for any component or directive, we can override an existing provider
    declared in a NgModule using the `providers` properties of the object literal
    we pass to the `@Component` or the `@Directive` decorators. If we want to override
    a specific provider only for the view children of a given component, we can use
    `viewProviders`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于任何组件或指令，我们可以使用传递给 `@Component` 或 `@Directive` 装饰器的对象字面量的 `providers` 属性覆盖在
    NgModule 中声明的现有提供者。如果我们只想为给定组件的视图子组件覆盖特定提供者，我们可以使用 `viewProviders`。
- en: Using Angular's DI with ES5
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ES5 的 Angular DI
- en: We are already proficient in using the DI of Angular with TypeScript! As we
    know, we are not limited to TypeScript for the development of Angular applications;
    we can also use ES5, ES2015, and ES2016 (as well as Dart, but that is outside
    the scope of this book).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟练地使用 TypeScript 的 Angular DI！正如我们所知，我们不仅限于 TypeScript 来开发 Angular 应用程序；我们还可以使用
    ES5、ES2015 和 ES2016（以及 Dart，但这本书的范围之外）。
- en: 'So far, we declared the dependencies of the different classes in their constructor
    using standard TypeScript type annotations. All such classes are supposed to be
    decorated with the `@Injectable` decorator. Unfortunately, some of the other languages
    supported by Angular miss a few of these features. In the following table, we
    can see that ES5 doesn''t support type annotations, classes, and decorators:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在它们的构造函数中使用标准的 TypeScript 类型注解声明了不同类的依赖关系。所有这些类都应该用 `@Injectable`
    装饰器进行装饰。不幸的是，Angular 支持的其他一些语言缺少这些功能中的几个。在下面的表中，我们可以看到 ES5 不支持类型注解、类和装饰器：
- en: '|  | **ES5** | **ES2015** | **ES2016** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  | **ES5** | **ES2015** | **ES2016** |'
- en: '| **Classes** | No | Yes | Yes |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **类** | No | Yes | Yes |'
- en: '| **Decorators** | No | No | Yes (no parameter decorators) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **装饰器** | No | No | Yes (no parameter decorators) |'
- en: '| **Type annotations** | No | No | No |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **类型注解** | No | No | No |'
- en: How can we take advantage of the DI mechanism in these languages? Angular provides
    an internal JavaScript **domain-specific language** (**DSL**), which allows us
    to take advantage of the entire functionalities of the framework using ES5.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何利用这些语言的 DI 机制？Angular 提供了一个内部 JavaScript **领域特定语言**（**DSL**），它允许我们利用框架的全部功能，使用
    ES5。
- en: 'Now, let''s translate the `MarkdownPanel` example we took a look at in the
    previous section from TypeScript to ES5\. First, let''s start with the `Markdown`
    service:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们在上一节中查看的`MarkdownPanel`示例从TypeScript转换为ES5。首先，让我们从`Markdown`服务开始：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We defined a variable called `Markdown` and set its value to the returned result
    from the invocation of `ng.core.Class`. This construct allows us to emulate ES2015
    classes using ES5\. The argument of the `ng.core.Class` method is an object literal,
    which must have the definition of a `constructor` function. As a result, `ng.core.Class`
    will return a JavaScript constructor function with the body of `constructor` from
    the object literal. All the other methods defined within the boundaries of the
    passed parameter will be added to the function's prototype.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Markdown`的变量，并将其值设置为通过调用`ng.core.Class`返回的结果。这个结构允许我们使用ES5来模拟ES2015类。`ng.core.Class`方法的参数是一个对象字面量，它必须包含一个`constructor`函数的定义。因此，`ng.core.Class`将返回一个具有对象字面量中`constructor`体部的JavaScript构造函数。所有在传递参数的边界内定义的其他方法都将添加到该函数的原型中。
- en: 'One problem is solved: we can now emulate classes in ES5; there are two more
    problems left!'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题得到了解决：我们现在可以模拟ES5中的类；还有两个问题待解决！
- en: 'Now, let''s take a look at how we can define the `MarkdownPanel` component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何定义`MarkdownPanel`组件：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*, we
    are already familiar with the ES5 syntax used to define components. Now, let's
    take a look at the constructor function of `MarkdownPanel`, in order to check how
    we can declare the dependencies of our components and classes in general.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第4章](ch04.html "第4章。开始使用Angular组件和指令")，*开始使用Angular组件和指令*，我们已经熟悉了用于定义组件的ES5语法。现在，让我们看看`MarkdownPanel`的构造函数，以检查我们如何声明组件和类的一般依赖项。
- en: 'From the preceding snippet, we should notice that the value of the constructor
    is not a function this time, but an array instead. This might seem familiar to
    you from AngularJS, where we are able to declare the dependencies of the given
    service by listing their names:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们应该注意到这次构造函数的值不是一个函数，而是一个数组。这可能会让你想起AngularJS，在那里我们能够通过列出它们的名称来声明给定服务的依赖项：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although the new syntax looks similar, it brings some improvements. For instance,
    we're no longer limited to using strings for the dependencies' tokens.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然新语法看起来相似，但它带来了一些改进。例如，我们不再局限于使用字符串作为依赖项的令牌。
- en: 'Now, let''s suppose we want to make the `Markdown` service an optional dependency.
    In this case, we can approach this by passing an array of decorators:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要将`Markdown`服务作为一个可选依赖项。在这种情况下，我们可以通过传递一个装饰器数组来解决这个问题：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This way, by nesting arrays, we can apply a sequence of decorators: `[[ng.core.Optional(),
    ng.core.Self(), Markdown], ...]`. In this example, the `@Optional` and `@Self`
    decorators will add the associated metadata to the class in the specified order.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过嵌套数组，我们可以应用一系列装饰器：`[[ng.core.Optional(), ng.core.Self(), Markdown], ...]`。在这个例子中，`@Optional`和`@Self`装饰器将按指定顺序将相关元数据添加到类中。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although using ES5 makes our build simpler and allows us to skip the intermediate
    step of transpilation, which can be tempting, Google's recommendation is to take
    advantage of static typing using TypeScript. This way, we have a much clearer
    syntax, which carries better semantics with less typing and provides us with great
    tooling, including the straightforward process of AoT compilation (we'll explore
    the Angular's AoT in the final chapter of the book).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用ES5可以使我们的构建更简单，并允许我们跳过中间步骤的转译，这可能很有吸引力，但谷歌的建议是利用TypeScript的静态类型。这样，我们拥有更清晰的语法，通过更少的输入获得更好的语义，并为我们提供强大的工具，包括直接的AoT编译过程（我们将在本书的最后一章探讨Angular的AoT）。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the DI mechanism of Angular. We briefly discussed
    the positives of using DI in our projects by introducing it in the context of
    the framework. The second step in our journey was how to instantiate and configure
    injectors; we also explained the injectors' hierarchy and the visibility of the
    registered providers. In order to enforce a better separation of concerns, we
    mentioned how we can inject services carrying the business logic of our application
    in our directives and components. The last point we took a look at was how we
    can use the DI mechanism with the ES5 syntax.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Angular 的依赖注入（DI）机制。我们通过在框架的上下文中介绍 DI，简要讨论了在我们的项目中使用 DI 的优点。我们旅程的第二步是如何实例化和配置注入器；我们还解释了注入器的层次结构和已注册提供者的可见性。为了强制实现更好的关注点分离，我们提到了如何在我们的指令和组件中注入携带我们应用业务逻辑的服务。我们最后探讨的是如何使用
    ES5 语法与 DI 机制结合使用。
- en: In the next chapter, we'll introduce the new routing mechanism of the framework.
    We'll explain how we can configure the component-based router and add multiple
    views to our application. Another important topic we will cover is the new form
    module. By building a simple application, we will demonstrate how we can create
    and manage forms.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍框架的新路由机制。我们将解释如何配置基于组件的路由器并为我们应用添加多个视图。我们还将探讨另一个重要主题——新的表单模块。通过构建一个简单的应用，我们将演示如何创建和管理表单。
