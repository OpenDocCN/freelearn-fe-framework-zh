- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Managing Microfrontends in Production
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产环境中管理微前端
- en: Being able to develop and test web applications on your local computer is great;
    however, deploying them them to production, maintaining them, and releasing new
    features while your applications are being visited by hundreds and thousands of
    visitors takes your software development skills to the next level. This chapter
    will cover some of the key concepts around deploying and maintaining your microfrontends
    in production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在你的本地计算机上开发和测试 Web 应用程序是很好的；然而，当你的应用程序被成百上千的访客访问时，将它们部署到生产环境、维护它们并发布新功能，这需要你的软件开发技能提升到下一个层次。本章将涵盖围绕在生产环境中部署和维护你的微前端的一些关键概念。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Branching strategies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支策略
- en: Versioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Rollback strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚策略
- en: Feature toggles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能开关
- en: By the end of this chapter, you will have taken the first steps toward reliably
    maintaining your microfrontend applications in production.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将迈出可靠维护你的微前端应用在生产环境中的第一步。
- en: Foundational components for a strong software delivery model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大软件交付模型的基础组件
- en: When it comes to deploying and maintaining applications in production, I recommend
    using **DevOps Research and Assessment’s** (**DORA’s**) software delivery maturity
    model to help prioritize areas to focus on and aspects of your production deployment
    processes you should optimize.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在生产环境中部署和维护应用程序时，我建议使用 **DevOps 研究和评估的**（**DORA**）软件交付成熟度模型来帮助确定重点关注的领域和你的生产部署流程中应该优化的方面。
- en: Important note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The software delivery maturity model talks about four key areas—namely, *Deployment
    frequency*, *Lead time for changes*, *Time to restore service*, and *Change failure
    rate*, and these are categorized as *Elite*, *High*, *Medium*, and *Low*. You
    can read more about this in detail here in the *State of DevOps 2021* report:
    [https://dora.dev/publications/pdf/state-of-devops-2021.pdf](https://dora.dev/publications/pdf/state-of-devops-2021.pdf).
    You can also register and view the rest of the reports at [https://dora.dev/publications/](https://dora.dev/publications/)
    and [https://cloud.google.com/devops/state-of-devops](https://cloud.google.com/devops/state-of-devops).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 软件交付成熟度模型讨论了四个关键领域——即 *部署频率*、*变更的领先时间*、*恢复服务的时间* 和 *变更失败率*，这些被分类为 *精英*、*高*、*中*
    和 *低*。你可以在 *DevOps 2021 状态报告* 中了解更多详细信息：[https://dora.dev/publications/pdf/state-of-devops-2021.pdf](https://dora.dev/publications/pdf/state-of-devops-2021.pdf)。你还可以在
    [https://dora.dev/publications/](https://dora.dev/publications/) 和 [https://cloud.google.com/devops/state-of-devops](https://cloud.google.com/devops/state-of-devops)
    注册并查看其他报告。
- en: We will look at a couple of key components that help you create the right foundation
    to ensure you are able to move up the maturity model as your team gains more confidence
    in deploying and managing microfrontends in production.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨几个关键组件，这些组件有助于你创建正确的基石，确保随着你的团队在部署和管理微前端方面获得更多信心，你能够提升成熟度模型。
- en: Branching strategies
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略
- en: In my opinion, the branching strategy is the most critical component that helps
    you improve the *Deployment frequency* and *Lead time for* *changes* metrics.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，分支策略是帮助你提高 *部署频率* 和 *变更的领先时间* 这两个关键指标的最重要组成部分。
- en: GitFlow and GitHub Flow are two popular branching strategies for Git-based version
    control systems, each with its strengths and weaknesses.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow 和 GitHub Flow 是两种基于 Git 的版本控制系统流行的分支策略，每种策略都有其优势和劣势。
- en: GitFlow is a branching model that uses two long-lived branches, `main` and `develop`,
    as well as feature, release, and hotfix branches.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow 是一种分支模型，使用两个长期存在的分支，`main` 和 `develop`，以及功能、发布和热修复分支。
- en: GitHub Flow, on the other hand, is a simpler and more flexible branching strategy
    that is suitable for smaller teams and projects. It revolves around a single main
    branch, typically `master` or `main`, and encourages developers to make changes
    in feature branches that are then merged into the `main` branch through pull requests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，GitHub Flow 是一种更简单、更灵活的分支策略，适用于较小的团队和项目。它围绕一个单一的 `main` 分支，通常是 `master`
    或 `main`，并鼓励开发者在功能分支中进行更改，然后通过拉取请求合并到 `main` 分支。
- en: 'In our opinion, when working with microfrontends and monorepos, GitHub Flow
    is the only viable branching strategy. This is primarily because of the following
    reasons:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看来，当与微前端和单仓库一起工作时，GitHub Flow 是唯一可行的分支策略。这主要是因为以下原因：
- en: '**Simplicity**: GitHub Flow simplifies the development process by enforcing
    a single, linear history on the **main** branch. Every feature, bug fix, or improvement
    is developed on a separate branch created from **main**, and once ready, it’s
    merged back into **main**. There are no long-lived branches apart from **main**,
    avoiding the complications of managing, syncing, and maintaining multiple long-term
    branches.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：GitHub Flow通过在**main**分支上强制执行单一、线性的历史记录来简化开发过程。每个功能、错误修复或改进都是在从**main**创建的单独分支上开发的，一旦准备就绪，就将其合并回**main**。除了**main**之外，没有长期存在的分支，避免了管理、同步和维护多个长期分支的复杂性。'
- en: '**Isolation of changes**: In a monorepo, it’s crucial to ensure changes to
    one project don’t unintentionally impact another. GitHub Flow’s practice of isolated
    branches for each new feature or bug fix aids in containing the scope of changes,
    reducing the risk of cross-project interference.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改隔离**：在单仓库中，确保对某个项目的更改不会无意中影响另一个项目至关重要。GitHub Flow为每个新功能或错误修复使用隔离分支的做法有助于限制更改的范围，减少跨项目干扰的风险。'
- en: '**Continuous Integration/Continuous Deployment** (**CI/CD**): GitHub Flow is
    designed with CD in mind. In monorepos, this can be even more beneficial. Since
    all projects live within the same repository, it’s easier to ensure that all changes
    are tested and deployed consistently.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成/持续部署**（**CI/CD**）：GitHub Flow的设计考虑了持续部署（CD）。在单仓库（monorepos）中，这可以带来更大的益处。由于所有项目都生活在同一个仓库中，因此更容易确保所有更改都经过测试并一致部署。'
- en: '**Reduced merge conflicts**: With a strategy such as Git Flow, where changes
    are often merged into **develop** or **release** branches before **main**, there
    can be significant delays between when code is written and when it’s deployed.
    In a fast-paced monorepo, this can lead to complex merge conflicts. GitHub Flow
    mitigates this by encouraging frequent merges directly into **main**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少合并冲突**：在Git Flow这样的策略中，更改通常在合并到`main`之前先合并到`develop`或`release`分支，这可能导致代码编写和部署之间的显著延迟。在快速发展的单仓库中，这可能导致复杂的合并冲突。GitHub
    Flow通过鼓励频繁直接合并到`main`来减轻这一点。'
- en: While working with GitFlow we’ve also seen that it is beneficial to slightly
    switch how code is merged to `main` based on whether you are in active development
    or post your first production deployment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用GitFlow工作时，我们也看到，根据你是在积极开发还是发布第一次生产部署后，稍微改变代码合并到`main`的方式是有益的。
- en: During active development
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在积极开发期间
- en: During the active development phase of a project, team members diligently generate
    feature branches, merging them back into the `main` branch only after the pull
    requests have received the necessary approvals. It’s common practice, and possibly
    part of your CI builds, to initiate an array of automated unit tests on each pull
    request prior to merging into the `main` branch. Additionally, a suite of integration
    and end-to-end tests are preferably executed on the `main` branch each night.
    This routine helps ensure that any disruptions in the `main` branch are identified
    and rectified promptly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的积极开发阶段，团队成员勤奋地生成功能分支，只有在拉取请求（pull requests）获得必要的批准后，才将它们合并回`main`分支。在合并到`main`分支之前，对每个拉取请求启动一系列自动单元测试是常见做法，这可能是CI构建的一部分。此外，每晚在`main`分支上执行一系列集成和端到端测试也是首选的做法。这种常规做法有助于确保`main`分支上的任何中断都能被及时识别和纠正。
- en: 'Let us look at the branching and merging workflow with GitHub Flow during active
    development:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看GitHub Flow在积极开发期间的分支和合并工作流程：
- en: '![Figure 9.1 – Branching and merging strategy during active development](img/Figure_9.01_B18987.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 积极开发期间的分支和合并策略](img/Figure_9.01_B18987.jpg)'
- en: Figure 9.1 – Branching and merging strategy during active development
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 积极开发期间的分支和合并策略
- en: As you can see, with GitHub Flow, branching and merging is quite straightforward.
    Developers branch off the `main` branch and merge back into `main`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用GitHub Flow，分支和合并相当直接。开发者从`main`分支分叉，然后合并回`main`。
- en: After the first release to production
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在第一次发布到生产后
- en: Subsequent to your inaugural production release, the merging strategy undergoes
    a subtle evolution. The teams continue to create feature branches off the `main`
    branch as before; however, the process diverges post-feature testing and approval.
    The tested feature release is rebased with `main`, tagged and deployed directly
    from the feature branch into production. It is only once stability in production
    is confirmed that the feature branch is merged into the `main` branch.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在您首次生产版本发布之后，合并策略经历了一种微妙的变化。团队继续从`main`分支创建功能分支，就像以前一样；然而，在功能测试和批准之后，过程发生了分歧。经过测试的功能版本与`main`分支进行rebase，打上标签并直接从功能分支部署到生产环境中。只有当生产环境中的稳定性得到确认后，功能分支才会合并到`main`分支。
- en: 'The following workflow will help illustrate the process:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工作流程将有助于说明这个过程：
- en: '![Figure 9.2 – Branching and releasing after the first release](img/Figure_9.02_B18987.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 首次发布后的分支和发布](img/Figure_9.02_B18987.jpg)'
- en: Figure 9.2 – Branching and releasing after the first release
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 首次发布后的分支和发布
- en: As you can see in *Figure 9**.2*, the process to deploy a feature, bug, or hotfix
    is the same, keeping things simple. A key step here is to rebase the `main` branch
    before you deploy your feature or bug.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*图9.2*中可以看到的，部署功能、错误修复或热补丁的过程是相同的，保持了简单性。这里的一个关键步骤是在您部署功能或错误之前重新base`main`分支。
- en: 'Although this may sound unconventional, adhering to this approach has several
    benefits, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能听起来不寻常，但坚持这种方法有几个好处，如下所示：
- en: The **main** branch perpetually mirrors the stable, current version in production.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**main**分支始终反映生产环境中的稳定、当前版本。'
- en: The team is given the opportunity to swiftly address and resolve any minor issues
    encountered during feature deployment, stabilizing the release prior to its merge
    into the **main** branch.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队有机会迅速解决和解决在功能部署期间遇到的任何小问题，在将其合并到**main**分支之前稳定发布。
- en: It eliminates the necessity of prohibiting commits to the **main** branch until
    the release stabilizes, an impractical strategy when executing multiple daily
    deployments.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这消除了在发布稳定之前禁止向**main**分支提交的必要性，这在执行多个每日部署时是一种不切实际的战略。
- en: As the **main** branch is always in alignment with the current production version,
    the process of deploying a feature or hotfix remains consistent.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于**main**分支始终与当前生产版本保持一致，因此部署功能或热补丁的过程保持一致。
- en: Since all merges into the **main** branch are post-release, the likelihood of
    a disrupted **main** branch is significantly reduced. Such disruptions can impede
    a large development team and halt further production deployments until the issue
    is resolved.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于所有合并到**main**分支的操作都是在发布之后，因此破坏**main**分支的可能性显著降低。这种中断可能会阻碍大型开发团队，并停止进一步的部署，直到问题得到解决。
- en: 'In the context of GitHub Flow, it is vital to note the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub Flow的背景下，重要的是要注意以下几点：
- en: Prior to deploying your feature branch, ensure a final rebase from the **main**
    branch. This ensures that your feature branch encompasses all previous deployments
    executed while your feature was in development.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部署您的功能分支之前，请确保从**main**分支进行最终的rebase。这确保了您的功能分支包含了在您的功能开发期间执行的所有先前部署。
- en: Contrary to popular belief, GitHub Flow development is not exclusive to small
    2-3-member teams. It is, in fact, notably advantageous for large teams operating
    in small, focused squads or pods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与公众的看法相反，GitHub Flow开发并不仅限于小型2-3人团队。实际上，对于在小型、专注的小队或pod中运作的大型团队来说，它具有明显的优势。
- en: Versioning micro apps
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微应用的版本控制
- en: The versioning of applications being deployed to production is standard practice,
    and there are different ways of defining versioning strategies. Versioning is
    important from many aspects; it helps in managing changelogs and mapping the different
    features and bugs to a build. It also helps with rollback strategies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到生产环境的版本控制是标准做法，并且有不同方式来定义版本控制策略。版本控制从许多方面都很重要；它有助于管理变更日志并将不同的功能和错误映射到构建中。它还有助于回滚策略。
- en: '`MAJOR.MINOR.PATCH`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAJOR.MINOR.PATCH`。'
- en: This structure not only helps users to understand the nature of changes in the
    new release but also helps with dependency management in software systems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构不仅帮助用户理解新发布中变化的本性，还有助于软件系统中的依赖关系管理。
- en: 'Our recommended strategy is to use SemVer as a guide. Each micro app should
    adhere to its own versioning rules, ensuring that any changes to the application’s
    public features are reflected in its version number. A micro app can increment
    its version number following the `MAJOR.MINOR.PATCH` pattern each time there’s
    a major feature release, minor feature release, or a bug fix change. We recommend
    prefixing the app name to the semantic version—for example, `catalog-2.8.3` would
    mean the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐的战略是使用 SemVer 作为指南。每个微应用都应该遵守自己的版本规则，确保任何对应用程序公共特性的更改都反映在其版本号中。微应用可以在每次有重大功能发布、小功能发布或错误修复更改时，按照
    `MAJOR.MINOR.PATCH` 模式增加其版本号。我们建议在语义版本前加上应用程序名称——例如，`catalog-2.8.3` 将意味着以下内容：
- en: '**Micro app** **name**: **catalog**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微应用名称**：**catalog**'
- en: '**Major** **version**: 2'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主版本号**：2'
- en: '**Minor** **version**: 8'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次版本号**：8'
- en: '**Path/bug fix** **version**: 3'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径/错误修复版本号**：3'
- en: For a simple way to manage tagging, whenever you are working on a release, we
    recommend creating a release branch such as `releases/catalog-2.0.1`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理标签的简单方法，每次你在处理一个发布版本时，我们建议创建一个发布分支，例如 `releases/catalog-2.0.1`。
- en: 'Once the release is tested and ready to deploy, we tag it like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布经过测试并准备部署，我们可以这样标记它：
- en: '**git** **tag catalog-2.0.0**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**git** **tag catalog-2.0.0**'
- en: '**git push** **origin catalog-2****.0.0**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**git push** **origin catalog-2****.0.0**'
- en: With a CI/CD pipeline, we can set it to automatically trigger a deployment to
    the test environments whenever a new tag is detected.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CI/CD 管道，我们可以设置它在新标签检测到时自动触发测试环境的部署。
- en: Note that while SemVer’s official definition uses the term *breaking changes*
    to define a major version, with microfrontends and module federation we can’t
    really have a breaking change. Hence for us, a micro app containing a major feature
    release would warrant a major version number increment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然 SemVer 的官方定义使用术语 *重大变更* 来定义主版本号，但在微前端和模块联邦中，我们实际上无法有重大变更。因此，对于我们来说，包含重大功能发布的微应用将需要增加主版本号。
- en: A common scenario with multiple micro apps and multiple frequent releases is
    that it becomes challenging for everybody in the team to know which version of
    which micro app is currently in production. A simple way to solve this is to have
    a `/versions` route in every micro app that will display information such as the
    current version number, the date of release, the branch it was released from,
    and so on. This can be super helpful for developers trying to debug issues in
    production.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个微应用和频繁发布的常见场景中，团队中的每个人都知道哪个微应用的哪个版本目前在生产中可能会变得具有挑战性。一个简单的解决方案是在每个微应用中有一个
    `/versions` 路由，它会显示当前版本号、发布日期、发布分支等信息。这对于试图在生产环境中调试问题的开发者来说非常有帮助。
- en: 'Here is an example of information we had on a `/``versions` route:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 `/versions` 路由上的信息示例：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For a large number of micro apps or frequent releases, manually tagging every
    version might become tedious. You might want to consider automating this using
    a script. Here is an example of a `bash` script:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大量微应用或频繁发布，手动标记每个版本可能会变得繁琐。你可能想要考虑使用脚本来自动化这个过程。以下是一个 `bash` 脚本的示例：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, you will notice that the script loops through each micro
    app in the `apps` folder, fetches the latest tags from `git` using the `git describe`
    and `git rev-list` commands, runs the `npm version` command to update the version
    numbers, and then commits and pushes the updated tags back to `git`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你会注意到脚本会遍历 `apps` 文件夹中的每个微应用，使用 `git describe` 和 `git rev-list` 命令从
    `git` 中获取最新的标签，运行 `npm version` 命令来更新版本号，然后将更新的标签提交并推送到 `git`。
- en: We can also use tools such as `semantic-release` or `standard-version`. These
    tools automate version management and changelog generation based on commit messages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `semantic-release` 或 `standard-version` 等工具。这些工具根据提交信息自动化版本管理和变更日志的生成。
- en: Versioning and tagging micro apps is critical to ensure that there is clarity
    with all stakeholders on the current status of which version of each micro app
    is currently in production. As we will see in the next section, it also plays
    a critical role in rollback strategies.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制和标记微应用对于确保所有利益相关者对当前生产中每个微应用的版本状态有清晰的认识至关重要。正如我们将在下一节中看到的，它在回滚策略中也发挥着关键作用。
- en: Rolling back a micro app
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回滚微应用
- en: A rollback strategy is a key component to managing any production software.
    This impacts the *Time to restore* *service* metric.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚策略是管理任何生产软件的关键组成部分。这影响了*恢复服务时间*指标。
- en: Rollback strategies for microfrontends center on the ability to revert a specific
    micro app or the entire system to a previous stable state when issues arise during
    or post-deployment. *Thanks to the independence of microfrontends, a rollback
    doesn’t necessarily affect the entire application but can be targeted to the problematic
    component, reducing overall* *system disruption*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端的回滚策略集中在当部署期间或部署后出现问题时，能够将特定的微应用或整个系统回滚到之前稳定状态的能力。*得益于微前端的独立性，回滚不一定影响整个应用程序，但可以针对有问题的组件，从而减少整体*
    *系统中断*。
- en: The simplest rollback strategy involves utilizing version control systems such
    as Git along with CI/CD pipelines. In this setup, each microfrontend has specific
    tagged releases, which are stored and can be redeployed if required. For instance,
    if the current version of a microfrontend is `catalog-1.2.3` and an issue is detected,
    you can quickly revert to the previous stable version, `catalog-1.2.2`, by triggering
    the corresponding deployment in your CI/CD pipeline.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的回滚策略涉及利用版本控制系统，如Git，以及CI/CD管道。在这种配置中，每个微前端都有特定的标记版本，这些版本被存储起来，如果需要可以重新部署。例如，如果当前版本的微前端是`catalog-1.2.3`，并且检测到问题，您可以通过触发CI/CD管道中的相应部署，快速回滚到之前的稳定版本`catalog-1.2.2`。
- en: Additionally, leveraging a blue-green deployment strategy can be effective.
    In this approach, two environments—blue and green—are maintained. While one serves
    live traffic (blue), the other (green) is idle or being prepared for the next
    release. If something goes wrong with the green environment post-deployment, you
    can quickly switch back to the blue environment, effectively rolling back the
    changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，利用蓝绿部署策略可能也很有效。在这种方法中，维护两个环境——蓝色和绿色。当其中一个环境（蓝色）服务于实时流量时，另一个环境（绿色）处于空闲状态或正在为下一个发布做准备。如果绿色环境在部署后出现问题，您可以快速切换回蓝色环境，有效地回滚更改。
- en: Rollbacks in Kubernetes are straightforward thanks to its declarative nature
    and built-in versioning mechanism. When a new deployment is created, Kubernetes
    automatically versions it and stores its details. If an issue arises with a new
    release, you can quickly roll back to a previous version using the `kubectl rollout
    undo` command. For instance, if you find a problem with a deployment named `deployment/catalog`,
    you can roll back using the `kubectl rollout undo deployment/catalog` command.
    Kubernetes will revert the deployment to the previous stable version gracefully
    without any downtime, making it a powerful tool for managing rollbacks in microfrontend
    architectures.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes声明式特性和内置的版本控制机制，Kubernetes中的回滚非常简单。当创建新的部署时，Kubernetes会自动为其版本化并存储其详细信息。如果新版本出现问题时，您可以使用`kubectl
    rollout undo`命令快速回滚到之前的版本。例如，如果您发现名为`deployment/catalog`的部署存在问题，您可以使用`kubectl
    rollout undo deployment/catalog`命令进行回滚。Kubernetes将优雅地回滚部署到之前的稳定版本，而无需停机，使其成为管理微前端架构中回滚的强大工具。
- en: When rolling back a micro app, it is important to be aware of any incompatibilities
    with backend APIs and whether the corresponding backend API also needs to be rolled
    back.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在回滚微应用时，重要的是要意识到与后端API的任何不兼容性，以及相应的后端API是否也需要回滚。
- en: Rollbacks at times can be painful, and the need for rollbacks can be mitigated
    by releasing new features or versions of micro apps using feature toggles, which
    we will see in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时回滚可能会很痛苦，而通过发布新功能或微应用的版本，并使用功能开关来减轻回滚的需求，这将在下一节中介绍。
- en: Deploying micro apps with feature toggles
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有功能开关的微应用部署
- en: Feature toggling, also known as feature flagging, is a powerful technique that
    allows individual features to be turned on or off at runtime without requiring
    a redeployment. This is particularly useful in a microfrontend architecture, as
    it enables the independent release and control of micro apps across multiple micro
    applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 功能开关，也称为功能标志，是一种强大的技术，允许在运行时打开或关闭单个功能，而无需重新部署。这在微前端架构中尤其有用，因为它使得可以在多个微应用之间独立发布和控制微应用。
- en: With feature toggling, teams can deploy new features to production but have
    them “hidden” behind a toggle until they’re ready to be released. This allows
    for extensive testing in the live environment and enables progressive delivery
    techniques such as canary releases or A/B testing. If any issues arise with the
    new feature, it can be quickly “switched off” via the feature toggle, effectively
    mitigating the impact without requiring a full rollback or redeployment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用功能开关，团队可以将新功能部署到生产环境中，但它们在准备好发布之前“隐藏”在开关后面。这允许在实时环境中进行广泛的测试，并启用渐进式交付技术，如金丝雀发布或A/B测试。如果新功能出现任何问题，可以通过功能开关快速“关闭”，有效地减轻影响，而无需进行全面回滚或重新部署。
- en: Unleash ([https://www.getunleash.io/](https://www.getunleash.io/)) is a popular
    open source tool for feature toggles.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Unleash ([https://www.getunleash.io/](https://www.getunleash.io/)) 是一个流行的开源功能开关工具。
- en: Feature toggles can be used to provide different experiences for different users.
    For instance, you can use them to selectively enable features for specific user
    groups, such as beta testers or premium users.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 功能开关可用于为不同用户提供不同的体验。例如，您可以使用它们有选择地启用特定用户组的特征，如测试人员或付费用户。
- en: However, feature toggling needs to be managed carefully to avoid an accumulation
    of outdated toggles, which can lead to code complexity and technical debt. Regular
    audits and cleanup of feature toggles should be part of the development process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，功能开关需要谨慎管理，以避免过时开关的积累，这可能导致代码复杂性和技术债务。定期审计和清理功能开关应成为开发过程的一部分。
- en: With this, we come to the end of this section, which covered some of the foundational
    elements of managing your microfrontends in production. This goes in conjunction
    with everything we saw in the previous chapters about deploying microfrontends
    to the cloud and eventually helping reduce the overall stress involved with deploying
    and maintaining applications in production.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们来到了本节的结尾，它涵盖了管理生产中微前端的一些基础元素。这与其他章节中我们看到的内容相辅相成，关于将微前端部署到云中，并最终帮助减少在生产中部署和维护应用程序的整体压力。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'As we conclude this chapter, let us quickly summarize what we’ve learned so
    far. We learned about DORA’s software delivery performance metrics: *Deployment
    frequency*, *Lead time for changes*, *Time to restore service*, and *Change failure
    rate*. We then had a look at some of the foundational elements that teams need
    to focus on to ensure they are set up for success.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们快速总结一下到目前为止我们所学的知识。我们学习了DORA的软件交付性能指标：*部署频率*、*变更的领先时间*、*恢复服务的时间*和*变更失败率*。然后我们查看了一些团队需要关注的基础元素，以确保他们为成功做好准备。
- en: We learned about branching strategies and that GitHub Flow is the preferred
    branching strategy. We also learned about the nuances of workflows when software
    is being built versus when it’s deployed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了分支策略，并了解到GitHub Flow是首选的分支策略。我们还了解了在软件构建时与部署时的流程细微差别。
- en: We learned about the right way to version our micro apps. We also learned about
    the importance of rollback strategies and how microfrontends help minimize the
    blast radius. And finally, we learned about feature toggles and how we can gradually
    release new micro apps into production via feature toggles and, more importantly,
    if there are any problems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了正确版本化我们的微应用的方法。我们还学习了回滚策略的重要性以及微前端如何帮助最小化爆炸半径。最后，我们学习了功能开关以及我们如何可以通过功能开关逐步将新微应用发布到生产环境中，更重要的是，如果存在问题。
- en: In the next chapter, we will look at some common pitfalls to avoid when building
    microfrontends.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在构建微前端时需要避免的一些常见陷阱。
