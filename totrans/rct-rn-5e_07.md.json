["```js\nconst MyList = ({ list }) => (\n  <ul>\n    {list.map((user) => (\n      <li key={user.name}>\n        {user.name} ({user.email})\n      </li>\n    ))}\n  </ul>\n); \n```", "```js\nimport PropTypes from 'prop-types';\nconst MyList = ({ list }) => (\n  <ul>\n    {list.map((user) => (\n      <li key={user.name}>\n        {user.name} ({user.email})\n      </li>\n    ))}\n  </ul>\n);\nMyList.propTypes = {\n  list: PropTypes.arrayOf(\n    PropTypes.shape({\n      name: PropTypes.string.isRequired,\n      email: PropTypes.string.isRequired,\n    })\n  ).isRequired,\n}; \n```", "```js\ntype User = {\n  name: string;\n  email: string;\n};\ntype MyListProps = {\n  list: User[];\n};\nconst MyList = ({ list }: MyListProps) => (\n  <ul>\n    {list.map((user) => (\n      <li key={user.name}>\n        {user.name} ({user.email})\n      </li>\n    ))}\n  </ul>\n); \n```", "```js\nfunction greet(name) {\n  return \"Hello, \" + name;\n}\nconsole.log(greet(\"Mike\")); // \"Hello, Mike\"\nconsole.log(greet(32)); // \"Hello, 32\" \n```", "```js\nfunction greet(name: string) {\n  return \"Hello, \" + name;\n}\nconsole.log(greet(\"Mike\")); // \"Hello, Mike\"\nconsole.log(greet(32)); // Error: Argument of type 'number' is not assignable to parameter of type 'string'. \n```", "```js\nnpm create vite@latest my-react-app -- --template react-ts \n```", "```js\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"esnext\",\n    \"jsx\": \"react-jsx\",\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true\n  }\n} \n```", "```js\ntype AppProps = {\n  message: string;\n};\nfunction App({ message }: AppProps) {\n  return <div>{message}</div>;\n} \n```", "```js\nnpm run dev \n```", "```js\n    let isDone: boolean = false; \n    ```", "```js\n    let age: number = 32; \n    ```", "```js\n    let color: string = \"blue\"; \n    ```", "```js\n    let list: number[] = [1, 2, 3]; \n    ```", "```js\n    let list: Array<number> = [1, 2, 3]; \n    ```", "```js\n    let x: [string, number];\n    x = [\"hello\", 10]; // OK \n    ```", "```js\n    enum Color {\n      Red,\n      Green,\n      Blue,\n    }\n    let c: Color = Color.Green; \n    ```", "```js\n    let notSure: any = 4;\n    notSure = \"maybe a string instead\";\n    notSure = false; // okay, definitely a Boolean \n    ```", "```js\n    let notSure: unknown = 4;\n    notSure = \"maybe a string instead\";\n    // OK, because of structural typing\n    notSure = false; \n    let surelyNotAString: string = notSure; // Error, 'unknown' is not assignable to 'string' \n    ```", "```js\n    try {\n      // some operation that might throw\n    } catch (error: unknown) {\n      if (error instanceof Error) {\n        console.log(error.message);\n      }\n    } \n    ```", "```js\n    function warnUser(): void {\n      console.log(\"This is my warning message\");\n    } \n    ```", "```js\n    let u: undefined = undefined;\n    let n: null = null; \n    ```", "```js\n    function greet(name?: string) {\n      return 'Hello ${name}';\n    }\n    greet(\"Mike\");\n    greet(undefined); // OK\n    greet(); // Also OK \n    ```", "```js\n    function throwError(errorMsg: string): never {\n        throw new Error(errorMsg);\n    }\n    function infiniteLoop(): never {\n        while (true) {\n        }\n    } \n    ```", "```js\ninterface User {\n  name: string;\n  email: string;\n} \n```", "```js\nconst user: User = {\n  name: \"Alice\",\n  email: \"alice@example.com\",\n}; \n```", "```js\ntype Point = {\n  x: number;\n  y: number;\n};\ntype ID = number | string; \n```", "```js\nconst point: Point = {\n  x: 10,\n  y: 20,\n};\nconst id: ID = 100; \n```", "```js\ntype GreetingProps = {\n  name: string;\n};\nconst Greeting = ({ name }: GreetingProps) => {\n  return <h1>Hello, {name}!</h1>;\n}; \n```", "```js\ntype UserProps = {\n  user: {\n    name: string;\n    email: string;\n  };\n};\nconst UserCard = ({ user }: UserProps) => {\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}; \n```", "```js\ntype ButtonProps = {\n  children: React.ReactNode;\n  disabled?: boolean;\n};\nconst Button = ({ children, disabled = false }: ButtonProps) => {\n  return <button disabled={disabled}>{children}</button>;\n}; \n```", "```js\n<Button>Click me!</Button> // OK\n<Button disabled>Don't click me!</Button> // OK \n```", "```js\nconst Counter = () => {\n  const [count, setCount] = React.useState<number>(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        Increment\n      </button>\n    </div>\n  );\n}; \n```", "```js\nconst InputField = () => {\n  const [value, setValue] = React.useState(\"\");\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setValue(event.target.value);\n  };\n  return <input value={value} onChange={handleChange} />;\n}; \n```", "```js\ntype ThemeContextType = {\n  theme: string;\n  setTheme: (theme: string) => void;\n};\nconst ThemeContext = React.createContext<ThemeContextType | null>(null);\nconst ThemeProvider = ({ children }: { children: React.ReactNode }) => {\n  const [theme, setTheme] = React.useState('light');\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\nconst useTheme = () => {\n  const context = React.useContext(ThemeContext);\n  if (context === null) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n}; \n```", "```js\nconst InputWithRef = () => {\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const focusInput = () => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  };\n  return (\n    <div>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={focusInput}>Focus the input</button>\n    </div>\n  );\n}; \n```"]