- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Improving the Load Time Using Server-Side Rendering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器端渲染提高加载时间
- en: After implementing authentication using JWTs, let’s focus on optimizing the
    performance of our blog app. We are going to start by benchmarking the current
    load time of our application and learn about various metrics to consider. Then,
    we are going to learn how to render React components and fetch data on the server.
    At the end of this chapter, we are going to briefly cover advanced server-side
    rendering concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JWT实现身份验证后，让我们专注于优化我们的博客应用程序的性能。我们将从基准测试我们应用程序当前的加载时间开始，并了解需要考虑的各种指标。然后，我们将学习如何在服务器上渲染React组件和获取数据。在本章的结尾，我们将简要介绍高级服务器端渲染的概念。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Benchmarking the load time of our application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试我们的应用程序加载时间
- en: Rendering React components on the server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上渲染React组件
- en: Server-side data fetching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端数据获取
- en: Advanced server-side rendering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级服务器端渲染
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all requirements mentioned in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing For Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请安装*第1章*（[B19385_01.xhtml#_idTextAnchor016](B19385_01.xhtml#_idTextAnchor016)，“为全栈开发做准备”）和*第2章*（[B19385_02.xhtml#_idTextAnchor028](B19385_02.xhtml#_idTextAnchor028)，“了解Node.js和MongoDB”）中提到的所有要求。
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in *Chapters 1*
    and *2*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在使用本书提供的代码和步骤时遇到问题，请尝试使用*第1章*和*第2章*中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch7](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch7).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此GitHub上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch7](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch7)。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/0OlmicibYWQ](https://youtu.be/0OlmicibYWQ)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下网址找到：[https://youtu.be/0OlmicibYWQ](https://youtu.be/0OlmicibYWQ)
- en: Benchmarking the load time of our application
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试我们的应用程序加载时间
- en: 'Before we can get started improving the load time, we first must learn about
    the metrics to benchmark the performance of our application. The main metrics
    for measuring the performance of web applications are called **Core Web Vitals**,
    and they are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始提高加载时间之前，我们首先必须了解用于衡量我们应用程序性能的指标。衡量Web应用程序性能的主要指标被称为**核心Web指标**，具体如下：
- en: '**First Contentful Paint (FCP)**: This measures the loading performance of
    an app by reporting the time until the first image or text block is rendered on
    the page. A good target would be to get this metric below 1.8 seconds.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首次内容渲染时间（FCP）**：通过报告直到页面上第一个图像或文本块被渲染的时间来衡量应用程序的加载性能。一个好的目标是将此指标低于1.8秒。'
- en: '**Largest Contentful Paint (LCP)**: This measures the loading performance of
    an app by reporting the time until the largest image or text block is visible
    within the viewport. A good target would be to get this metric below 2.5 seconds.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大内容渲染时间（LCP）**：通过报告直到最大的图像或文本块在视口中可见的时间来衡量应用程序的加载性能。一个好的目标是将此指标低于2.5秒。'
- en: '**Total Blocking Time (TBT)**: This measures the interactivity of an app by
    reporting the time between the FCP and a user being able to interact with the
    page. A good target would be to get this metric below 200 milliseconds.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总阻塞时间（TBT）**：通过报告FCP和用户能够与页面交互之间的时间来衡量应用程序的交互性。一个好的目标是将此指标低于200毫秒。'
- en: '**Cumulative Layout Shift (CLS)**: This measures the visual stability of an
    app by reporting unexpected movement on the page during loading, such as a link
    first being loaded on the top of the page, but then getting pushed further down
    to the bottom when other elements load. While this metric does not directly measure
    the actual performance of the app, it is still an important metric to consider,
    as it can lead to annoying the users when they attempt to click on something,
    but the layout shifts.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**累积布局偏移（CLS）**：此指标通过报告在加载过程中页面上意外的移动来衡量应用的视觉稳定性，例如，一个链接最初在页面顶部加载，但在其他元素加载时被推得更低。虽然这个指标并没有直接衡量应用的性能，但它仍然是一个重要的指标，因为它可能导致用户在尝试点击某个东西时感到烦恼，但布局发生了偏移。'
- en: 'All these metrics can be measured by using the open-source **Lighthouse** tool,
    which is also available from the Google Chrome DevTools under the **Lighthouse**
    panel. Let’s get started benchmarking our app now:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些指标都可以通过使用开源的**Lighthouse**工具来衡量，该工具也可在Google Chrome开发者工具的**Lighthouse**面板下找到。现在让我们开始基准测试我们的应用：
- en: 'Copy the **ch6** folder to a new **ch7** folder, as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ch6**文件夹复制到一个新的**ch7**文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the **ch7** folder in VS Code, open a Terminal, and run the frontend with
    the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开**ch7**文件夹，打开终端，并使用以下命令运行前端：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure the **dbserver** container is running in Docker.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Docker中的**dbserver**容器正在运行。
- en: 'Open a new Terminal and run the backend with the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端，并使用以下命令运行后端：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Go to **http://localhost:5173** in Google Chrome and open the inspector (right-click
    and then press **Inspect**).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome中转到**http://localhost:5173**并打开检查器（右键单击然后按**检查**）。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It would be best to do this in an incognito tab so that extensions do not interfere
    with the measurements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在隐身标签页中这样做，这样扩展程序就不会干扰测量。
- en: 'Open the **Lighthouse** tab (it might be hidden by the **>>** menu). It should
    look as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Lighthouse**标签页（它可能被**>>**菜单隐藏）。它应该看起来如下所示：
- en: '![Figure 7.1 – The Lighthouse tab in Google Chrome DevTools](img/B19385_07_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – Google Chrome开发者工具中的Lighthouse标签页](img/B19385_07_1.jpg)'
- en: Figure 7.1 – The Lighthouse tab in Google Chrome DevTools
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – Google Chrome开发者工具中的Lighthouse标签页
- en: In the **Lighthouse** tab, leave all options as their default settings and click
    on the **Analyze page** **load** button.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**灯塔**标签页中，保留所有选项的默认设置，然后点击**分析页面**的**加载**按钮。
- en: 'Lighthouse will start analyzing the website and give a report with metrics
    such as **First Contentful Paint**, **Largest Contentful Paint**, **Total Blocking
    Time**, and **Cumulative Layout Shift**. As we can see, our app already performs
    quite well in terms of TBT and CLS but performs particularly badly in terms of
    FCP and LCP. See the following screenshot for reference:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Lighthouse将开始分析网站，并给出包含**首次内容渲染**、**最大内容渲染**、**总阻塞时间**和**累积布局偏移**等指标的报告。正如我们所见，我们的应用在TBT和CLS方面表现相当不错，但在FCP和LCP方面表现特别糟糕。请参考以下截图：
- en: '![Figure 7.2 – Lighthouse results when analyzing our app in development mode
    (while hovering the cursor over the performance score)](img/B19385_07_2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 在开发模式下分析我们的应用时的Lighthouse结果（当鼠标悬停在性能分数上时）](img/B19385_07_2.jpg)'
- en: Figure 7.2 – Lighthouse results when analyzing our app in development mode (while
    hovering the cursor over the performance score)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 在开发模式下分析我们的应用时的Lighthouse结果（当鼠标悬停在性能分数上时）
- en: 'There are two reasons why the paint takes so long. Firstly, we are running
    the server in dev mode, which generally makes everything slower. Additionally,
    we are rendering everything on the client side, which means that the browser first
    must download and execute our JavaScript code before it can start rendering the
    interface. Let’s statically build our frontend and benchmark again now:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 画图花费如此长时间有两个原因。首先，我们正在以开发模式运行服务器，这通常会使一切变慢。此外，我们正在客户端渲染一切，这意味着浏览器必须首先下载并执行我们的JavaScript代码，然后才能开始渲染界面。现在让我们静态构建前端并再次基准测试：
- en: 'Install the **serve** tool globally with the following command, which is a
    tool that runs a simple web server:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令全局安装**serve**工具，这是一个运行简单Web服务器的工具：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Build the frontend with this command (execute it in the root of our project):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建前端（在项目根目录下执行）：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Statically serve our app by running the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令静态地提供我们的应用：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open **http://localhost:3000** in Google Chrome and run Lighthouse again (you
    may have to clear the old reports or click the list in the top left and select
    **(new report)** to analyze again).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome中打开**http://localhost:3000**并再次运行Lighthouse（你可能需要清除旧报告或点击左上角的列表并选择**（新报告**）以再次分析）。
- en: 'You should see the results of the new benchmark on the statically served frontend,
    which is closer to how it would be served in production. You can see an example
    of the results in the following screenshot:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在静态提供的前端上看到新的基准测试结果，这更接近于在生产中提供的方式。你可以在下面的屏幕截图中看到结果示例：
- en: '![Figure 7.3 – Lighthouse report results on our statically built app](img/B19385_07_3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – Lighthouse报告结果在我们的静态构建应用上](img/B19385_07_3.jpg)'
- en: Figure 7.3 – Lighthouse report results on our statically built app
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – Lighthouse报告结果在我们的静态构建应用上
- en: 'Now, the results are pretty good! However, it could still be improved further.
    Additionally, **Core Web Vitals** do not take into account the cascading requests
    to get the author usernames. While the first and largest contentful paints are
    fast in our app, the author names are not even loaded yet at that point. In addition
    to the Lighthouse report, we can also take a look at the **Network** tab to further
    debug the performance of our app, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果相当不错！然而，它还可以进一步改进。此外，**核心Web Vitals**并没有考虑到获取作者用户名的级联请求。虽然在我们应用中，第一次和最大的内容渲染很快，但作者名称在那个点还没有加载。除了Lighthouse报告外，我们还可以查看**网络**标签页来进一步调试我们应用的性能，如下所示：
- en: In DevTools, go to the **Network** tab.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DevTools中，转到**网络**标签页。
- en: 'Refresh the page while the tab is open. You will see a waterfall diagram and
    the measured time to make requests, as shown in the following screenshot:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签页打开时刷新页面。你会看到一个瀑布图和请求的测量时间，如下面的屏幕截图所示：
- en: '![Figure 7.4 – The waterfall diagram on the Network tab](img/B19385_07_4.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 网络标签页上的瀑布图](img/B19385_07_4.jpg)'
- en: Figure 7.4 – The waterfall diagram on the Network tab
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 网络标签页上的瀑布图
- en: 'But the times are extremely low (all below 10 ms). This is because our backend
    is running locally, so there is no network delay. This is not a realistic scenario.
    In production, we would have latency on every request that we make, so we would
    first have to wait for the blog posts to be pulled, then fetch the names of authors
    for each author separately. We can use the DevTools to simulate a slower network
    connection; let’s do that now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但时间极低（所有都在10毫秒以下）。这是因为我们的后端在本地上运行，所以没有网络延迟。这不是一个现实场景。在生产中，我们发出的每个请求都会有延迟，因此我们首先必须等待拉取博客文章，然后分别获取每个作者的名称。我们可以使用DevTools来模拟更慢的网络连接；现在就让我们来做这件事：
- en: At the top of the **Network** tab, click on the **No** **throttling** dropdown.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**网络**标签页的顶部，点击**无** **限速**下拉菜单。
- en: 'Select the **Slow 3G** preset. See the following screenshot for reference:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**慢速3G**预设。以下截图供参考：
- en: '![Figure 7.5 – Simulating slow networks in Google Chrome DevTools](img/B19385_07_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 在Google Chrome DevTools中模拟慢速网络](img/B19385_07_5.jpg)'
- en: Figure 7.5 – Simulating slow networks in Google Chrome DevTools
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 在Google Chrome DevTools中模拟慢速网络
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Lighthouse has a form of throttling built in, which is like the network throttling
    we are using here, but not the same. While the network throttling in DevTools
    is a fixed delay added to all requests, the throttling in Lighthouse attempts
    to simulate a more realistic scenario by adjusting the throttling based on the
    data observed in the initial unthrottled load.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse内置了一种限速形式，类似于我们在这里使用的网络限速，但并不相同。虽然DevTools中的网络限速是添加到所有请求的固定延迟，但Lighthouse的限速尝试通过根据初始未限速加载中观察到的数据调整限速来模拟更真实的场景。
- en: Refresh the page. You will now see the app slowly loading the main layout, then
    a list of all posts, and finally resolving the author IDs to usernames.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面。你现在会看到应用正在缓慢加载主布局，然后是所有帖子的列表，最后解析作者ID到用户名。
- en: 'This is how our page would load on slow networks. Now, the overall time to
    finish loading our app is almost nine seconds! You can look at the waterfall diagram
    to see why this is happening:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们页面在慢速网络上的加载方式。现在，加载我们应用的总体时间几乎接近九秒！你可以查看瀑布图来了解为什么会这样：
- en: '![Figure 7.6 – Checking the waterfall diagram with Slow 3G throttling on](img/B19385_07_6.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 在开启Slow 3G限速的情况下检查瀑布图](img/B19385_07_6.jpg)'
- en: Figure 7.6 – Checking the waterfall diagram with Slow 3G throttling on
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 在开启Slow 3G限速的情况下检查瀑布图
- en: The issue in our app is that the requests are cascading. First, the HTML document
    loads, which then loads the JavaScript file for our app. This JavaScript file
    is then executed and starts rendering the layout and fetching the list of posts.
    After the posts are loaded, multiple requests are made in parallel to resolve
    the author names. As each request takes a bit over two seconds on our simulated
    slow network, we end up with a total load time of over eight seconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，问题在于请求是级联的。首先，HTML文档加载，然后加载我们应用的JavaScript文件。这个JavaScript文件随后被执行并开始渲染布局和获取帖子列表。帖子加载后，会并行发出多个请求以解析作者名称。由于每个请求在我们的模拟慢速网络中需要超过两秒钟，我们最终的总加载时间超过八秒钟。
- en: Now that we have learned how to benchmark a web application and found a performance
    bottleneck in our app (the cascading requests), let’s learn how to improve the
    performance!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何基准测试Web应用，并发现了我们应用中的性能瓶颈（级联请求），让我们学习如何提高性能！
- en: Rendering React components on the server
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上渲染React组件
- en: 'In the previous section, we identified cascading requests as the problem for
    our bad performance on slow connections. Possible solutions to this problem are
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将级联请求识别为在慢速连接上表现不佳的问题。以下是一些可能的解决方案：
- en: '**Bundled requests**: Fetch everything on the server and then serve everything
    at once to the client in a single request. This would solve the cascading requests
    when fetching author names, but not the initial waiting time between the HTML
    page being loaded and the JavaScript executing to start fetching the data. With
    a latency of two seconds per request, that’s still four seconds added (two seconds
    for loading the JavaScript and two seconds for making the request) after the HTML
    is fetched.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捆绑请求**：在服务器上获取所有内容，然后通过单个请求一次性将所有内容提供给客户端。这将解决获取作者名称时的级联请求问题，但不会解决HTML页面加载和JavaScript执行以开始获取数据之间的初始等待时间。每个请求的延迟为两秒钟，这意味着在HTML获取后仍然增加了四秒钟（两秒钟用于加载JavaScript和两秒钟用于发出请求）。'
- en: '**Server-side rendering**: Render the initial user interface with all data
    on the server and serve it instead of the initial HTML that just contains a URL
    to the JavaScript file. This would mean that no additional requests are needed
    to fetch the data or JavaScript and we can show the blog posts right away. Another
    advantage of this approach is that it allows for caching the results, so, we only
    need to regenerate the page on the server when a blog post gets added. A downside
    of this approach is that it puts more strain on the server, especially when the
    pages are complex to render.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**：在服务器上渲染包含所有数据的初始用户界面，并代替仅包含指向JavaScript文件的URL的初始HTML提供它。这意味着不需要额外的请求来获取数据或JavaScript，我们可以立即显示博客文章。这种方法的优势之一是允许缓存结果，因此，只有当添加博客文章时，我们才需要在服务器上重新生成页面。这种方法的一个缺点是它会给服务器带来更大的压力，尤其是在页面复杂且难以渲染时。'
- en: In cases where data does not change so frequently or the same data is accessed
    by all users, server-side rendering is beneficial. In cases where data frequently
    changes or is personalized to each user, it might make more sense to bundle the
    requests into one by making a new route or using a system that can aggregate requests,
    such as GraphQL, which we will learn more about later in this book, in [*Chapter
    11*](B19385_11.xhtml#_idTextAnchor213), *Building a Backend With a GraphQL API*.
    In this chapter, however, we will focus on the server-side rendering approach.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据变化不频繁或所有用户访问相同数据的情况下，服务器端渲染是有益的。在数据频繁变化或针对每个用户进行个性化处理的情况下，通过创建新的路由或使用能够聚合请求的系统（例如GraphQL），将请求捆绑在一起可能更有意义。我们将在本书稍后的[*第11章*](B19385_11.xhtml#_idTextAnchor213)“使用GraphQL
    API构建后端”中了解更多关于GraphQL的内容。然而，在本章中，我们将专注于服务器端渲染方法。
- en: 'Let’s have a look at the differences between server-side rendering as opposed
    to client-side rendering:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看服务器端渲染与客户端渲染之间的区别：
- en: In **client-side rendering**, the browser downloads a minimal HTML page, which,
    most of the time, only contains information on where to download a JavaScript
    bundle, which contains all the code that will render the app.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**客户端渲染**中，浏览器下载一个最小的HTML页面，通常只包含有关下载包含所有将渲染应用代码的JavaScript包的信息。
- en: In **server-side rendering**, the React components are rendered on the server
    and served as HTML to the browser. This ensures that the app can be rendered immediately.
    The JavaScript bundle can be loaded later.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **服务器端渲染** 中，React 组件在服务器上渲染，并以 HTML 的形式提供给浏览器。这确保了应用可以立即渲染。JavaScript 包可以在稍后加载。
- en: '![Figure 7.7 – The differences between client-side rendering and server-side
    rendering](img/B19385_07_7.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 客户端渲染和服务器端渲染之间的区别](img/B19385_07_7.jpg)'
- en: Figure 7.7 – The differences between client-side rendering and server-side rendering
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 客户端渲染和服务器端渲染之间的区别
- en: It is also possible to combine the two into **isomorphic rendering**. This involves
    rendering the initial page on the server side, and then continuing to render changes
    on the client side. Isomorphic rendering combines the best of both worlds.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将这两个结合到 **同构渲染** 中。这涉及到在服务器端渲染初始页面，然后继续在客户端渲染更改。同构渲染结合了两个世界的最佳之处。
- en: In addition to the performance improvements, server-side rendering is also good
    for **search engine optimization** (**SEO**), because search engine crawlers do
    not need to run JavaScript to see the page. We are going to learn more about SEO
    in the next chapter, [*Chapter 8*](B19385_08.xhtml#_idTextAnchor162), *Making
    Sure Customers Find You With Search* *Engine Optimization*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能改进之外，服务器端渲染对 **搜索引擎优化**（**SEO**）也有好处，因为搜索引擎爬虫不需要运行 JavaScript 就能看到页面。我们将在下一章中了解更多关于
    SEO 的内容，[*第 8 章*](B19385_08.xhtml#_idTextAnchor162)，*确保客户通过搜索引擎优化找到你*。
- en: 'Now that we have learned about server-side rendering, let’s get started implementing
    it in our frontend, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了服务器端渲染，让我们开始在前端实现它，如下所示：
- en: Setting up the server
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置服务器
- en: Defining the server-side entry point
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义服务器端入口点
- en: Defining the client-side entry point
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义客户端入口点
- en: Updating **index.html** and **package.json**
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 **index.html** 和 **package.json**
- en: Making React Router work with server-side rendering
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 React Router 与服务器端渲染一起工作
- en: Let’s start by setting up the server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置服务器。
- en: Setting up the server
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置服务器
- en: 'Before we can get started with server-side rendering, we need to set up some
    boilerplate for running an Express server in tandem with Vite, so that we do not
    lose the benefits of Vite, such as hot reloading. Let’s follow these steps to
    set up the server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始进行服务器端渲染之前，我们需要设置一些样板代码来同时运行 Express 服务器和 Vite，这样我们就不丢失 Vite 的好处，例如热重载。让我们按照以下步骤设置服务器：
- en: 'Install the **express** and **dotenv** dependencies in the root of our project
    (the frontend); we are going to use them to create a small web server to serve
    our server-side rendered page:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录（前端）中安装 **express** 和 **dotenv** 依赖项；我们将使用它们创建一个小型网络服务器来服务我们的服务器端渲染页面：
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Edit **.eslintrc.json** and add the **node** env, as we are going to add server-side
    code to our frontend now:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **.eslintrc.json** 并添加 **node** 环境，因为我们现在要向我们的前端添加服务器端代码：
- en: '[PRE7]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a new **server.js** file in the **ch7** folder, and import the **fs**,
    **path**, **url**, **express**, and **dotenv** dependencies:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **ch7** 文件夹中创建一个新的 **server.js** 文件，并导入 **fs**、**path**、**url**、**express**
    和 **dotenv** 依赖项：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save the current path in a variable to be used later to reference other files
    in our project, using the ESM-compatible **import.meta.url** variable, which contains
    a **file://** URL to our project:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前路径保存在一个变量中，稍后用于引用我们项目中的其他文件，使用与 ESM 兼容的 **import.meta.url** 变量，它包含一个 **file://**
    URL 到我们的项目：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We convert this URL to a regular path here.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里将此 URL 转换为常规路径。
- en: 'Define a new **createDevServer** function, where we will create a Vite dev
    server with hot reloading and server-side rendering:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的 **createDevServer** 函数，我们将创建一个带有热重载和服务器端渲染的 Vite 开发服务器：
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside this function, we first define the Express app:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们首先定义 Express 应用程序：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, import and create a Vite dev server. We use the dynamic **import** syntax
    here so that we don’t need to import Vite when we define the production server
    later:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导入并创建一个 Vite 开发服务器。我们在这里使用动态 **import** 语法，这样我们就不需要在定义生产服务器时导入 Vite：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Middleware mode runs Vite as a middleware in an existing Express server. Setting
    `appType` as `custom` disables Vite’s own serving logic so that we can control
    which HTML will be served.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 中间件模式将 Vite 作为中间件运行在现有的 Express 服务器中。将 `appType` 设置为 `custom` 将禁用 Vite 的自有服务逻辑，这样我们就可以控制要服务的
    HTML。
- en: 'Now, define a route that matches all paths and start by loading the **index.html**
    file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个匹配所有路径的路由，并开始加载 **index.html** 文件：
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make sure to load it in UTF-8 mode to support various languages and emojis in
    `index.html`.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保在`index.html`中以UTF-8模式加载，以支持各种语言和表情符号。
- en: 'Next, inject the Vite hot-module-replacement client to allow for hot reloading:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，注入Vite热模块替换客户端以允许热重载：
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Load the entry point file for our server-side rendered app, which we will define
    in the next step:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载我们将在下一步定义的服务器端渲染应用程序的入口点文件：
- en: '[PRE15]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `ssrLoadModule` function in Vite automatically transforms the ESM source
    code so that it is usable in Node.js. This means we can hot-reload the entry point
    file without having to run a manual build.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Vite中的`ssrLoadModule`函数自动转换ESM源代码，使其在Node.js中可用。这意味着我们可以不运行手动构建就热重载入口点文件。
- en: 'Render the app using React. We will define the **render** function later in
    the server-side entry point. For now, we just call the function:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用React渲染应用程序。我们将在服务器端入口点中稍后定义`render`函数。现在，我们只需调用该函数：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Insert the rendered HTML from our app into the HTML template by matching a
    placeholder string, which we will define later in the **index.html** file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过匹配占位符字符串将我们的应用程序渲染的HTML插入到HTML模板中，该占位符字符串我们将在**index.html**文件中稍后定义：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Return a **200 OK** response with the final HTML contents:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回包含最终HTML内容的**200 OK**响应：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To wrap up the server creation, catch all errors and let Vite fix the stack
    trace, mapping source files in the stack trace back to the actual source code.
    Then, return the created Express app:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成服务器创建，捕获所有错误并让Vite修复堆栈跟踪，将堆栈跟踪中的源文件映射回实际源代码。然后，返回创建的Express应用程序：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, execute the **createDevServer** function and make the app listen on
    a defined port:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行**createDevServer**函数并使应用程序监听定义的端口：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s not forget to define the **PORT** environment variable in the **.env**
    file. Edit the **.env** file and add the **PORT** environment variable, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在**.env**文件中定义**PORT**环境变量。编辑**.env**文件并添加**PORT**环境变量，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have successfully created the Express server with Vite integration,
    we continue by implementing the server-side entry point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了与Vite集成的Express服务器，我们继续实现服务器端入口点。
- en: Defining the server-side entry point
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义服务器端入口点
- en: The server-side entry point will use `ReactDOMServer` to render our React components
    on the server. We need to distinguish this entry point from the client-side entry
    point because not everything React can do is supported on the server side. Specifically,
    some hooks such as effect hooks will not run on the server side. Also, we will
    have to handle the router differently on the server side, but more on that later.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端入口点将使用`ReactDOMServer`在服务器上渲染我们的React组件。我们需要区分这个入口点和客户端入口点，因为并非React能做的所有事情都在服务器端受支持。具体来说，一些钩子，如effect钩子，在服务器端不会运行。此外，我们将在服务器端以不同的方式处理路由，但关于这一点稍后讨论。
- en: 'Now, let’s get started defining the server-side entry point:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始定义服务器端入口点：
- en: 'First, create a new **src/entry-server.jsx** file and import **ReactDOMServer**
    and the **App** component:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的**src/entry-server.jsx**文件，并导入**ReactDOMServer**和**App**组件：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define and export the render function, which returns the **App** component
    using the **ReactDOMServer.renderToString** function:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并导出`render`函数，该函数使用**ReactDOMServer.renderToString**函数返回**App**组件：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After defining the server-side entry point, we are going to continue by defining
    the client-side entry point.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义服务器端入口点后，我们将继续定义客户端入口点。
- en: Defining the client-side entry point
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义客户端入口点
- en: The client-side entry point uses regular `ReactDOM` to render our React components.
    However, we need to let React know to make use of the already server-side rendered
    DOM. Instead of rendering, we **hydrate** the existing DOM. Like when adding water
    to plants, hydration makes the DOM “come alive” by adding all React functionality
    to the server-side rendered static DOM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端入口点使用常规`ReactDOM`来渲染我们的React组件。然而，我们需要让React知道要利用已经服务器端渲染的DOM。而不是渲染，我们**激活**现有的DOM。就像给植物加水一样，激活通过向服务器端渲染的静态DOM添加所有React功能，使DOM“活跃”起来。
- en: 'Follow these steps to define the client-side entry point:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤定义客户端入口点：
- en: Rename the existing **src/main.jsx** file to **src/entry-client.jsx**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的**src/main.jsx**文件重命名为**src/entry-client.jsx**。
- en: 'Replace the **createRoot** function with the **hydrateRoot** function, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`createRoot`函数替换为`hydrateRoot`函数，如下所示：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `hydrateRoot` function accepts the component as a second argument, and does
    not require us to call `.render()`.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hydrateRoot` 函数接受组件作为第二个参数，并且不需要我们调用 `.render()`。'
- en: Now that we have defined both entry points, let’s update `index.html` and `package.json`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了两个入口点，让我们更新 `index.html` 和 `package.json`。
- en: Updating index.html and package.json
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 index.html 和 package.json
- en: 'We still need to add the placeholder string to the `index.html` file and adjust
    `package.json` to execute our custom server instead of the `vite` command directly.
    Let’s do that now:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要在 `index.html` 文件中添加占位符字符串，并调整 `package.json` 以执行我们的自定义服务器而不是直接执行 `vite`
    命令。现在让我们来做这件事：
- en: 'Edit **index.html** and add a placeholder where the server-rendered HTML will
    be injected:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **index.html** 并添加一个占位符，其中将注入服务器渲染的 HTML：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Adjust the module import to point to the client-side entry point:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整模块导入以指向客户端入口点：
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, edit **package.json** and replace the dev script with the following:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑 **package.json** 并将开发脚本替换为以下内容：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Additionally, replace the **build** command with commands to build the server
    and client:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将 **build** 命令替换为构建服务器和客户端的命令：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our setup is now ready for server-side rendering. However, when you start the
    server, you will immediately notice that React Router does not work with our current
    setup. Let’s fix that now.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的设置已经准备好进行服务器端渲染。然而，当你启动服务器时，你会立即注意到 React Router 并没有与我们的当前设置一起工作。现在让我们修复这个问题。
- en: Making React Router work with server-side rendering
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使 React Router 与服务器端渲染一起工作
- en: 'To make React Router work with server-side rendering, we need to use `StaticRouter`
    on the server side and `BrowserRouter` on the client side. We can reuse the same
    route definitions for both sides. Let’s get started refactoring our code to make
    React Router work on the server side:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 React Router 与服务器端渲染一起工作，我们需要在服务器端使用 `StaticRouter`，在客户端使用 `BrowserRouter`。我们可以为两边复用相同的路由定义。让我们开始重构代码，使
    React Router 在服务器端工作：
- en: 'Edit **src/App.jsx** and *remove* the router-related imports (the highlighted
    lines) from it:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/App.jsx** 并从其中 *移除* 与路由器相关的导入（高亮行）：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Import **PropTypes**, as we will need it later:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 **PropTypes**，因为我们稍后会用到它：
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, *remove* the following route definitions from it; we will put them in
    a new file soon:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从其中 *移除* 以下路由定义；我们很快会将它们放入一个新文件中：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Adjust the function to accept **children** and replace **RouterProvider** with
    **{children}**:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整函数以接受 **children** 并将 **RouterProvider** 替换为 **{children}**：
- en: '[PRE32]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We also need to add the **propTypes** definitions for the **App** component
    now:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还需要为 **App** 组件添加 **propTypes** 定义：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new **src/routes.jsx** file and import the previously removed imports
    there:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/routes.jsx** 文件并将之前移除的导入放在那里：
- en: '[PRE34]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, add the route definitions and export them:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加路由定义并导出它们：
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we have refactored our app structure in a way where we can reuse the
    routes on the client-side and server-side entry points, let’s redefine the router
    in the client entry point.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以可以复用客户端和服务器端入口点路由的方式重构了我们的应用结构，让我们在客户端入口点重新定义路由器。
- en: Defining the client-side router
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义客户端路由器
- en: 'Follow these steps to re-define the router in the client entry point:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在客户端入口点重新定义路由器：
- en: 'Edit **src/entry-client.jsx** and import **RouterProvider**, the **createBrowserRouter**
    function, and **routes**:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/entry-client.jsx** 并导入 **RouterProvider**、**createBrowserRouter** 函数和
    **routes**：
- en: '[PRE36]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, create a new browser router based on the **routes** definition:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，基于 **routes** 定义创建一个新的浏览器路由器：
- en: '[PRE37]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Adjust the **render** function to render **App** with **RouterProvider**:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 **render** 函数以使用 **RouterProvider** 渲染 **App**：
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, let’s define the **server-side router**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义 **服务器端路由器**。
- en: Mapping the Express request to a Fetch request
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Express 请求映射到 Fetch 请求
- en: 'On the server side, we will get an Express request, which we first need to
    convert to a Fetch request, so that React Router can understand it. Let’s do that
    now:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们将得到一个 Express 请求，我们首先需要将其转换为 Fetch 请求，以便 React Router 能够理解它。现在让我们来做这件事：
- en: 'Create a new **src/request.js** file and define a **createFetchRequest** function
    there, which takes an Express request as an argument:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **src/request.js** 文件中创建一个新的文件并定义一个 **createFetchRequest** 函数，该函数接受一个 Express
    请求作为参数：
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First, define the **origin** for the request and build the URL:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义请求的 **origin** 并构建 URL：
- en: '[PRE40]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We need to use `req.originalUrl` first (if available), to take into account
    the Vite middleware potentially changing the URL.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要首先使用 `req.originalUrl`（如果可用），以考虑到 Vite 中间件可能会更改 URL。
- en: 'Then, we define a new **AbortController** to handle when the request is closed:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个新的 **AbortController** 来处理请求关闭的情况：
- en: '[PRE41]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we map the Express request **headers** to Fetch headers:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 Express 请求 **头部**映射到 Fetch 头部：
- en: '[PRE42]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we can build the **init** object for the Fetch request, which consists
    of **method**, **headers**, and **AbortController**:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为 Fetch 请求构建 **init** 对象，它由 **method**、**headers** 和 **AbortController**
    组成：
- en: '[PRE43]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If our request was not a **GET** or **HEAD** request, we also get **body**,
    so, let’s add that to the Fetch request, too:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的请求不是 **GET** 或 **HEAD** 请求，我们也会得到 **body**，所以，让我们也将它添加到 Fetch 请求中：
- en: '[PRE44]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, let’s create the Fetch **Request** object from our extracted information:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们从我们的提取信息中创建 Fetch **请求**对象：
- en: '[PRE45]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that we have a utility function to convert an Express request to a Fetch
    request, we can make use of it to define the server-side router.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个将 Express 请求转换为 Fetch 请求的实用函数，我们可以利用它来定义服务器端路由器。
- en: Defining the server-side router
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义服务器端路由器
- en: 'The server-side router works very similarly to the client-side router, except
    that we are getting the request info from Express instead of the page, and using
    `StaticRouter`, because the route cannot change on the server side. Follow these
    steps to define the server-side router:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端路由器的工作方式与客户端路由器非常相似，只是我们是从 Express 而不是从页面获取请求信息，并使用 `StaticRouter`，因为服务器端的路由不能改变。按照以下步骤定义服务器端路由器：
- en: 'Edit **src/entry-server.jsx** and import **StaticRouterProvider** and the **createStaticHandler**
    and **createStaticRouter** functions. Also, import the **routes** definition and
    the **createFetchRequest** function we just defined:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/entry-server.jsx** 并导入 **StaticRouterProvider** 和 **createStaticHandler**
    以及 **createStaticRouter** 函数。还要导入 **routes** 定义和刚刚定义的 **createFetchRequest** 函数：
- en: '[PRE46]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Define a static handler for the routes:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义路由的静态处理器：
- en: '[PRE47]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Adjust the **render** function to accept an Express request object and then
    create a Fetch request from it using our previously defined function:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 **render** 函数以接受 Express 请求对象，然后使用我们之前定义的函数从它创建一个 Fetch 请求：
- en: '[PRE48]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now use this converted request to pass it to our static handler, which
    creates **context** for the route, allowing React Router to see which route we
    are trying to access and with which parameters:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个转换后的请求传递给我们的静态处理器，它为路由创建**上下文**，允许 React Router 看到我们正在尝试访问哪个路由以及使用哪些参数：
- en: '[PRE49]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'From the routes defined by the handler and the context, we can create a static
    router:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从处理器定义的路由和上下文中，我们可以创建一个静态路由器：
- en: '[PRE50]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we can adjust the rendering to render the static router and our refactored
    **App** structure:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以调整渲染以渲染静态路由器和我们的重构 **App** 结构：
- en: '[PRE51]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There’s still one more thing left to do. We need to pass the Express request
    to the **render()** function of the server-side entry point. Edit the following
    line in the **server.js** file:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有另一件事要做。我们需要将 Express 请求传递到服务器端入口点的 **render()** 函数。编辑 **server.js** 文件中的以下行：
- en: '[PRE52]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the frontend and backend are already running, make sure to quit them.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前端和后端已经运行，请确保退出它们。
- en: 'Start the frontend, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤启动前端：
- en: '[PRE53]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Also, start the backend in a separate Terminal:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在单独的终端中启动后端：
- en: '[PRE54]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The frontend will now output `ssr dev server running on http://localhost:5173`
    and successfully server-side render all our pages! You can verify that it is server-side
    rendered by opening the DevTools, clicking on the cog icon in the top right, scrolling
    down in the **Settings** | **Preferences** pane to the **Debugger** section, and
    checking the box for **Disable JavaScript**, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前端现在将输出 `ssr dev server running on http://localhost:5173` 并成功在服务器端渲染所有页面！你可以通过打开
    DevTools，点击右上角的齿轮图标，在 **设置** | **首选项** 面板中向下滚动到 **调试器** 部分，并勾选 **禁用 JavaScript**
    来验证它是服务器端渲染的，如下所示：
- en: '![Figure 7.8 – Disabling JavaScript in the DevTools](img/B19385_07_8.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 在 DevTools 中禁用 JavaScript](img/B19385_07_8.jpg)'
- en: Figure 7.8 – Disabling JavaScript in the DevTools
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 在 DevTools 中禁用 JavaScript
- en: Now, refresh the page, and you will see that part of the app still gets rendered.
    Only the top part of the app is fully rendered by the server side right now. The
    posts list is not rendered on the server side yet. This is because the `useQuery`
    hooks internally use an effect hook to fetch data after the component has mounted.
    As such, they do not work with server-side rendering. However, we can still get
    data fetching working with server-side rendering. Let’s learn about that in the
    next section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新页面，你会看到应用的一部分仍然被渲染。目前只有应用的上半部分是通过服务器端完全渲染的。文章列表尚未在服务器端渲染。这是因为`useQuery`钩子内部使用了一个effect钩子，在组件挂载后获取数据。因此，它们不适用于服务器端渲染。然而，我们仍然可以使数据获取与服务器端渲染一起工作。我们将在下一节中学习这一点。
- en: Server-side data fetching
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端数据获取
- en: 'As we have seen, data fetching does not work out of the box on the server side.
    There are two approaches for server-side data fetching with React Query:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，数据获取在服务器端不是即时的。对于React Query的服务器端数据获取有两种方法：
- en: '**Initial data approach**: Use the **initialData** option in the **useQuery**
    hook to pass prefetched data in. This approach is enough for fetching a list of
    posts but would be tricky for fetching deeply nested data, such as the usernames
    of each author.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始数据方法**：在`useQuery`钩子中使用**initialData**选项来传递预取数据。这种方法足够用于获取文章列表，但对于获取深层嵌套数据，例如每个作者的昵称，可能会很棘手。'
- en: '**Hydration approach**: This allows us to prefetch any requests and store the
    result by their query key and prefetch any request on the server side, even if
    it is deeply nested within the app, without having to pass the prefetched data
    down using props or a context.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据同步方法**：这允许我们预取任何请求并按查询键存储结果，甚至在服务器端预取任何请求，即使它深深嵌套在应用中，也不需要通过属性或上下文传递预取数据。'
- en: We are first going to use the `initialData` option to fetch the list of blog
    posts, and then extend our solution to the hydration approach so that we can get
    a feeling for how both approaches work and what their pros and cons are.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用`initialData`选项来获取博客文章列表，然后扩展我们的解决方案以采用数据同步方法，以便我们可以了解这两种方法的工作原理以及它们的优缺点。
- en: Using initial data
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用初始数据
- en: 'React Router allows us to define `Blog` component and the `useQuery` hook via
    the `initialData` option. Let’s do that now:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 允许我们通过`initialData`选项定义`Blog`组件和`useQuery`钩子。现在让我们来做这件事：
- en: 'Edit **src/routes.jsx** and import the **useLoaderData** hook from **react-router-dom**
    and the **getPosts** function:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/routes.jsx**并从**react-router-dom**导入**useLoaderData**钩子和**getPosts**函数：
- en: '[PRE55]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Adjust the route to define a **loader** function, in which we simply call the
    **getPosts** function. We can then define a **Component()** method in which we
    use the **useLoaderData** hook to get the data from the loader, and pass it into
    the **Blog** component, as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整路由以定义一个**loader**函数，其中我们简单地调用**getPosts**函数。然后我们可以在**Component()**方法中使用**useLoaderData**钩子从loader获取数据，并将其传递给**Blog**组件，如下所示：
- en: '[PRE56]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Edit **src/pages/Blog.jsx** and import **PropTypes** there, so that we can
    define a new prop for the component later:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/pages/Blog.jsx**并在其中导入**PropTypes**，这样我们就可以在稍后为组件定义一个新的属性：
- en: '[PRE57]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, add the **initialData** prop to the **Blog** component:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将**initialData**属性添加到**Blog**组件中：
- en: '[PRE58]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Pass the **initialData** prop into the **useQuery** hook, as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**initialData**属性传递给**useQuery**钩子，如下所示：
- en: '[PRE59]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Lastly, define **propTypes** for the **Blog** component:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为**Blog**组件定义**propTypes**：
- en: '[PRE60]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Refresh the frontend page (with JavaScript disabled) and it will now show the
    post list, but without resolving the author usernames. As we can see, the initial
    data approach is quite simple. However, if we wanted to fetch the usernames of
    all authors, we would have to store them somewhere and then pass them down into
    the user components using either props or a context, both of which would be quite
    tedious and would not scale well if we need to make more requests later. Thankfully,
    there is another, more advanced approach, which we are going to learn about now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新前端页面（禁用JavaScript）后，现在将显示文章列表，但不会解析作者昵称。正如我们所见，初始数据方法相当简单。然而，如果我们想获取所有作者的昵称，我们可能需要将它们存储在某个地方，然后通过属性或上下文将它们传递到用户组件中，这两种方法都相当繁琐，而且如果我们需要稍后进行更多请求，扩展性不会很好。幸运的是，还有一种更高级的方法，我们现在将要学习。
- en: Using hydration
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据同步
- en: 'With the hydration approach, we create a query client to prefetch any requests
    we want to make, and then dehydrate it, pass it to the component using a loader,
    and hydrate it again there. Using this approach, we can simply make any query
    and store it using a query key. If a component uses the same query key, it will
    be able to render the results on the server side. Let’s implement the hydration
    approach now:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用水合方法，我们创建一个查询客户端来预取我们想要进行的任何请求，然后将其脱水，通过加载器将其传递给组件，并在那里再次水合。使用这种方法，我们可以简单地执行任何查询并使用查询键存储它。如果一个组件使用相同的查询键，它将能够在服务器端渲染结果。现在让我们实现水合方法：
- en: 'Edit **src/routes.jsx** and import **QueryClient**, the **dehydrate** function,
    and the **Hydrate** component from React Query:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/routes.jsx**并从React Query导入**QueryClient**、**dehydrate**函数和**Hydrate**组件：
- en: '[PRE61]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, import the **getUserInfo** function, as we are going to fetch usernames
    too now:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还需要导入**getUserInfo**函数，因为我们现在也将获取用户名：
- en: '[PRE62]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Adjust the loader; we are now going to create a query client there:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整加载器；我们现在将在那里创建一个查询客户端：
- en: '[PRE63]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, we simulate the **getPosts** request from the **Blog** component by passing
    in the same default arguments to it as the component would:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过传递与组件相同的默认参数来模拟**Blog**组件的**getPosts**请求：
- en: '[PRE64]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This duplication of default arguments is a bit problematic. However, with our
    current server-side rendering solution, the data fetching and component rendering
    are too separated to properly share the code between them. A more sophisticated
    server-side rendering solution, such as Next.js or Remix, can deal with this pattern
    better.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种默认参数的重复有点问题。然而，根据我们当前的服务器端渲染解决方案，数据获取和组件渲染过于分离，无法在它们之间正确共享代码。一个更复杂的服务器端渲染解决方案，如Next.js或Remix，可以更好地处理这种模式。
- en: 'Now, we can call **queryClient.prefetchQuery**, with the same query key as
    the one that will be used by the **useQuery** hook in the component, to prefetch
    the results of the query:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以调用**queryClient.prefetchQuery**，使用与组件中**useQuery**钩子将使用的相同查询键来预取查询的结果：
- en: '[PRE65]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we use the fetched posts array to get a unique list of author IDs from
    them:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用获取到的帖子数组来从它们中获取唯一的作者ID列表：
- en: '[PRE66]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We now loop through all author IDs and prefetch their information:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在遍历所有作者ID并预取它们的信息：
- en: '[PRE67]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that we have prefetched all the necessary data, we need to call **dehydrate**
    on **queryClient** to return it in a serializable format:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经预取了所有必要的数据，我们需要在**queryClient**上调用**dehydrate**以返回可序列化的格式：
- en: '[PRE68]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the **Component()** method, we get this dehydrated state and use the **Hydrate**
    component to hydrate it again. This hydration process makes the data accessible
    to the server-side rendered query client:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Component()**方法中，我们获取这个脱水状态并使用**Hydrate**组件再次水合。这个过程使得数据对服务器端渲染的查询客户端可访问：
- en: '[PRE69]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, we can revert the **src/pages/Blog.jsx** component to the previous
    state. We start by *removing* the **PropTypes** import:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将**src/pages/Blog.jsx**组件恢复到之前的状态。我们首先**移除**了**PropTypes**导入：
- en: '[PRE70]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, we *remove* the **initialData** prop:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们**移除**了**initialData**属性：
- en: '[PRE71]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We also *remove* it in the **useQuery** hook:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在**useQuery**钩子中**移除**了它：
- en: '[PRE72]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Lastly, we *remove* the **propTypes** definition:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们**移除**了**propTypes**定义：
- en: '[PRE73]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Quit the frontend via *Ctrl* + *C*, then restart it as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*Ctrl* + *C*退出前端，然后按照以下方式重新启动它：
- en: '[PRE74]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Refresh the page and you will see that the full blog post list, including all
    author names, is properly rendered on the server side now, even with JavaScript
    disabled!
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面，你现在会看到完整的博客文章列表，包括所有作者名称，现在已经在服务器端正确渲染，即使禁用了JavaScript！
- en: 'Let’s do another benchmark to see how the performance has improved:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再进行一次基准测试，看看性能是如何提高的：
- en: Open the Chrome DevTools.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Chrome开发者工具。
- en: Enable JavaScript again by going to the cog wheel, **Settings** | **Preferences**,
    and unchecking **Disable JavaScript**.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到齿轮图标，**设置** | **首选项**，取消选中**禁用JavaScript**来再次启用JavaScript。
- en: Go to the **Lighthouse** tab. Click on **Analyze page load** to generate a new
    report.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Lighthouse**标签页。点击**分析页面加载**以生成新的报告。
- en: '![Figure 7.9 – The Lighthouse Performance score of the server-side rendered
    app with the dev server](img/B19385_07_9.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 服务器端渲染应用与开发服务器的Lighthouse性能分数](img/B19385_07_9.jpg)'
- en: Figure 7.9 – The Lighthouse Performance score of the server-side rendered app
    with the dev server
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 服务器端渲染应用与开发服务器的Lighthouse性能分数
- en: The FCP and LCP times are almost half of the previously reported times from
    client-side rendering in production mode. Looking at the waterfall diagram in
    the **Network** tab, we can now see that there is only one request to fetch the
    initial page.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首屏加载时间（FCP）和最大内容渲染时间（LCP）几乎比之前在生产模式下客户端渲染报告的时间减少了一半。查看 **网络** 选项卡中的瀑布图，我们现在可以看到只有一个请求用于获取初始页面。
- en: Let’s now wrap up the chapter by learning about advanced server-side rendering.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过学习高级服务器端渲染来结束本章内容。
- en: Advanced server-side rendering
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级服务器端渲染
- en: 'In the previous sections, we have successfully created a server that can do
    server-side rendering with hot reloading, which is very useful for development
    but will worsen the performance in production. Let’s create another server function
    for a production server now, which will build files, use compression, and not
    load Vite middleware for hot reloading. Follow these steps to create the production
    server:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经成功创建了一个可以进行服务器端渲染并具有热重载功能的服务器，这对于开发非常有用，但会在生产中降低性能。现在，让我们为生产服务器创建另一个服务器函数，该函数将构建文件，使用压缩，并且不加载
    Vite 中间件进行热重载。按照以下步骤创建生产服务器：
- en: 'In the root of our project, install the **compression** dependency with the
    following command:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们项目的根目录下，使用以下命令安装 **compression** 依赖项：
- en: '[PRE75]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Edit **server.js** and define a new function for the production server, above
    the **createDevServer** function:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **server.js** 并在 **createDevServer** 函数之上定义一个新的用于生产服务器的函数：
- en: '[PRE76]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In this function, we define a new Express app and use the **compression** package
    and the **serve-static** package to serve our client:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们定义了一个新的 Express 应用，并使用 **compression** 包和 **serve-static** 包来服务我们的客户端：
- en: '[PRE77]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, we define a route that catches all paths again, this time loading the
    template from the built files in the **dist/** folder:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个捕获所有路径的路由，这次是从 **dist/** 文件夹中加载的模板：
- en: '[PRE78]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We also directly import and render the server-side entry point now:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们直接导入并渲染服务器端入口点：
- en: '[PRE79]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As before, we render the React app, replace the placeholder in **index.html**
    with the rendered app, and return the resulting HTML:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们渲染 React 应用，将 **index.html** 中的占位符替换为渲染的应用，并返回生成的 HTML：
- en: '[PRE80]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For the error handling, we simply pass it on to the next middleware now and
    return the app:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于错误处理，我们现在简单地将其传递给下一个中间件并返回应用：
- en: '[PRE81]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'At the bottom of the **server.js** file, where we created the dev server, we
    now do a check for the **NODE_ENV** environment variable and use it to decide
    whether to start the production server or the development server:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **server.js** 文件底部，我们创建开发服务器的地方，现在我们检查 **NODE_ENV** 环境变量，并使用它来决定是启动生产服务器还是开发服务器：
- en: '[PRE82]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Install the **cross-env** package, as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤安装 **cross-env** 包：
- en: '[PRE83]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Edit **package.json** and add a **start** script, which starts the server in
    production mode:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **package.json** 并添加一个 **start** 脚本，该脚本以生产模式启动服务器：
- en: '[PRE84]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Quit the frontend dev server, build, and start the production server:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭前端开发服务器，构建并启动生产服务器：
- en: '[PRE85]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As we can see, our server still serves the app just fine, but now we are not
    in development mode anymore, so we do not have hot reloading available. This wraps
    up our implementation of server-side rendering! As you can imagine, the server-side
    rendering implementation in this chapter is somewhat basic, and there are still
    multiple things we would need to handle:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的服务器仍然可以很好地提供服务应用，但现在我们不再处于开发模式，因此没有热重载可用。这标志着我们服务器端渲染实现的完成！正如你所想象的那样，本章中服务器端渲染的实现相对基础，我们还需要处理多个问题：
- en: Redirects and proper HTTP status codes
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向和适当的 HTTP 状态码
- en: Static-site generation (caching resulting HTML pages so we don’t have to server-side
    render them again every time)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态站点生成（缓存生成的 HTML 页面，这样我们就不必每次都进行服务器端渲染）
- en: Better data fetching functionality
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的数据获取功能
- en: Better code splitting between the server and client
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器和客户端之间更好地进行代码拆分
- en: Better handling of environment variables between the server and client
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器和客户端之间更好地处理环境变量
- en: To solve these issues, it is better to use a fully-fledged server-side rendering
    implementation in a web framework, such as Next.js or Remix. These frameworks
    already provide ways to do server-side rendering, data fetching, and routing out
    of the box, and do not require us to manually get everything to work in tandem.
    We are going to learn more about Next.js in [*Chapter 16*](B19385_16.xhtml#_idTextAnchor291),
    *Getting Started* *with Next.js*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，最好在Web框架中使用一个完整的后端渲染实现，例如Next.js或Remix。这些框架已经提供了进行后端渲染、数据获取和路由的现成方法，并且不需要我们手动使所有这些协同工作。我们将在[*第16章*](B19385_16.xhtml#_idTextAnchor291)，*Next.js入门*中了解更多关于Next.js的内容。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned how to benchmark web applications using Lighthouse
    and Chrome DevTools. We also learned about useful metrics for such benchmarks,
    called Core Web Vitals. Then, we learned about rendering React components on the
    server and the differences between client-side rendering and server-side rendering.
    Next, we implemented server-side rendering for our app using Vite and React Router.
    Then, we implemented server-side data fetching using React Query. We then benchmarked
    our app again and saw an improvement in the performance of more than 40%. Lastly,
    we learned about getting our server-side rendering server ready for production
    and concepts that a more sophisticated server-side rendering framework needs to
    deal with.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何使用Lighthouse和Chrome DevTools对Web应用进行基准测试。我们还了解了此类基准测试的有用指标，称为核心Web指标。然后，我们学习了在服务器上渲染React组件以及客户端渲染和服务器端渲染之间的区别。接下来，我们使用Vite和React
    Router为我们应用实现了服务器端渲染。然后，我们使用React Query实现了服务器端数据获取。然后，我们再次对应用进行了基准测试，并看到了超过40%的性能提升。最后，我们学习了如何让我们的服务器端渲染服务器为生产做好准备，以及一个更复杂的后端渲染框架需要处理的概念。
- en: In the next chapter, [*Chapter 8*](B19385_08.xhtml#_idTextAnchor162), *Making
    Sure Customers Find You with Search Engine Optimization*, we are going to learn
    how to make our web app more accessible to search engine crawlers, increasing
    the SEO score that we saw in the Lighthouse report. We are going to add meta tags
    to have more information about our web app and add integrations for various social
    media sites.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[*第8章*](B19385_08.xhtml#_idTextAnchor162)，*确保客户通过搜索引擎优化找到您*，我们将学习如何使我们的Web应用更容易被搜索引擎爬虫访问，从而提高我们在Lighthouse报告中看到的SEO评分。我们将添加元标签以获取更多关于我们的Web应用的信息，并为各种社交媒体网站添加集成。
