<html><head></head><body>
<div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-175"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.2.1">Advanced Concepts of ReactJS</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Every web developer should have in-depth knowledge of React fundamentals, core concepts, Hooks, and router navigations to build a successful career in the React technology stack. </span><span class="koboSpan" id="kobo.3.2">But if you want to elevate your React skills to the next level, you should be able to build production-level apps by applying advanced React concepts such as portals, error boundaries, concurrent rendering features, profilers, and more. </span><span class="koboSpan" id="kobo.3.3">While some of these concepts were introduced a long time ago and improved with new features in each major release, other advanced concepts have only been introduced in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">recent releases.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, you will understand the advanced concepts of ReactJS so that you can use them in various real-time use cases. </span><span class="koboSpan" id="kobo.5.2">Advanced concepts such as error boundaries, portals, concurrent rendering, and suspense, as well as code quality and performance optimization-related features such as strict mode, static type checking, and profilers, will be discussed to cover the interview questions for mid-level to senior developer candidates. </span><span class="koboSpan" id="kobo.5.3">At the end, we will quickly explore some questions related to React Native that are meant for mobile environments such as iOS </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">and Android.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1"> In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Exploring portals</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">error boundaries</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Managing asynchronous actions with the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Suspense API</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Optimizing rendering performance using </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">concurrent rendering</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Debugging React applications with the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Profiler API</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Strict mode</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Static </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">type checking</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">React in mobile environments and </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">its features</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">The main objective of this chapter is to give you a clear understanding of React’s advanced concepts and tackle interview questions that are asked to test the advanced skill levels of any </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">job aspirant.</span></span></p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.25.1">Exploring portals</span></h1>
<p><span class="koboSpan" id="kobo.26.1">Nowadays, it is </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.27.1">quite common to use model windows or popups on web pages to quickly grab the user’s attention. </span><span class="koboSpan" id="kobo.27.2">They help notify the user of some important information or ask the user to enter their input. </span><span class="koboSpan" id="kobo.27.3">But the implementation of these widgets is challenging in large apps since it involves writing complex CSS code and handling the DOM hierarchy. </span><span class="koboSpan" id="kobo.27.4">Fortunately, React provides the portals feature to solve these kinds of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">Portals were introduced in 2017 and were first seen in React version 16. </span><span class="koboSpan" id="kobo.29.2">They are used to render React components outside of the DOM hierarchy. </span><span class="koboSpan" id="kobo.29.3">The usage of portals is not typical, but they are helpful in specific use cases, as you will see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">following subsections.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.31.1">What are portals? </span><span class="koboSpan" id="kobo.31.2">How do you create them?</span></h2>
<p><span class="koboSpan" id="kobo.32.1">React portals allow </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.33.1">you to render children into a DOM node that exists outside of the parent DOM hierarchy. </span><span class="koboSpan" id="kobo.33.2">Even though you render a child component outside the parent, the parent-child relationship still exists between </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">the components.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">A React portal can be created by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">createPortal</span></strong><span class="koboSpan" id="kobo.37.1"> function, which is imported from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">react-dom</span></strong><span class="koboSpan" id="kobo.39.1"> package. </span><span class="koboSpan" id="kobo.39.2">This function accepts two mandatory arguments and one </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">optional argument:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">Children</span></strong><span class="koboSpan" id="kobo.42.1">: Any JSX code that can be rendered </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">with React.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">DOMNode</span></strong><span class="koboSpan" id="kobo.45.1">: The DOM node where you need to render the </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">portal’s content.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">Key</span></strong><span class="koboSpan" id="kobo.48.1">: A unique identifier to distinguish the portal inside the component tree. </span><span class="koboSpan" id="kobo.48.2">This </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">is optional.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.50.1">The following example of a modal window shows how a portal is created at a particular DOM node outside the root </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">tree hierarchy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
import { createPortal } from 'react-dom';
const ModalWindow =({ description, isOpen, onClose })=&gt; {
  if (!isOpen) return null;
  return createPortal(
     &lt;div className="modal"&gt;
      &lt;span&gt;{description}&lt;/span&gt;
      &lt;button onClick={onClose}&gt;Close&lt;/button&gt;
     &lt;/div&gt;
    ,document.body);
}</span></pre> <p><span class="koboSpan" id="kobo.53.1">In the preceding code, the portal returns a React node that can be rendered anywhere in the component tree. </span><span class="koboSpan" id="kobo.53.2">In this example, the returned node is going to be a modal widget. </span><span class="koboSpan" id="kobo.53.3">This modal has been appended to the document body and is available at the same level as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">root</span></strong><span class="koboSpan" id="kobo.55.1"> node </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.56.1">in </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">the HTML.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.58.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.59.1">It is common practice to name the top-level node </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">root</span></strong><span class="koboSpan" id="kobo.61.1"> because everything inside it will be managed by React. </span><span class="koboSpan" id="kobo.61.2">Applications built with React alone usually have a single root node. </span><span class="koboSpan" id="kobo.61.3">But if you are integrating React into an existing application, you might have many isolated root </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">DOM nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Any React component can use the preceding portal as a </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">child component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.65.1">
function ParentComponent() {
  const [open, setOpen] = useState(false);
  return (
    &lt;div className="container"&gt;
      &lt;button onClick={() =&gt; setOpen(true)}&gt;Open Modal&lt;/button&gt;
      &lt;Modal
        message="This is a portal modal!"
</span><span class="koboSpan" id="kobo.65.2">        isOpen={open}
        onClose={() =&gt; setOpen(false)}
      /&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.66.1">There is no restriction on the number of portals that can be used in a particular component or an application. </span><span class="koboSpan" id="kobo.66.2">Using portals, you can also render React components into non-React server markup such</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.67.1"> as static or server-rendered pages and non-React DOM nodes that are managed outside </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">of React.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.69.1">What are the common use cases of portals?</span></h2>
<p><span class="koboSpan" id="kobo.70.1">In applications where</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.71.1"> you can see the child components visually breaking off of the parent container, portals can be useful. </span><span class="koboSpan" id="kobo.71.2">The most common use cases are </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">listed here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Modal windows or dialogue components</span></strong><span class="koboSpan" id="kobo.74.1">: Portals can be used to create large dialogues or modal windows that float over the rest of the web page without you having to worry about the </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">parent component.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Tooltips</span></strong><span class="koboSpan" id="kobo.77.1">: Tooltip text can be placed outside of the DOM hierarchy without it affecting the page layout. </span><span class="koboSpan" id="kobo.77.2">For example, if the parent component has </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">overflow:hidden</span></strong><span class="koboSpan" id="kobo.79.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">z-index</span></strong><span class="koboSpan" id="kobo.81.1"> styling, then tooltips created inside the portal won’t be cut off from their </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">parent container.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.83.1">Loaders</span></strong><span class="koboSpan" id="kobo.84.1">: When a background task such as fetching data from a database is in progress, it is sensible to show a loading screen on the modern web. </span><span class="koboSpan" id="kobo.84.2">This helps block the user from interacting with the application until the background task has </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">been completed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.86.1">Popovers</span></strong><span class="koboSpan" id="kobo.87.1">: Popovers are useful for quickly providing context information to the user. </span><span class="koboSpan" id="kobo.87.2">For example, profile cards can be used to display user profile information without the need to click and visit the profile itself. </span><span class="koboSpan" id="kobo.87.3">You can just read the details by hovering over the icon or </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">button elements.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Cookie alerts</span></strong><span class="koboSpan" id="kobo.90.1">: It is possible to create cookie alerts (or banners) so that visitors can choose what cookies are allowed to track while they’re visiting </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">the website.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.92.1">Drop-down menus</span></strong><span class="koboSpan" id="kobo.93.1">: If the drop-down menus are displayed inside a parent component that has hidden overflow styling, it can be created as </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">a portal.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.95.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.96.1">By moving the child </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.97.1">components outside the main component tree, the rendering performance will be optimized as the components aren’t re-rendering for each state update. </span><span class="koboSpan" id="kobo.97.2">Moreover, it provides the flexibility </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">of abstraction.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.99.1">How does event bubbling work inside portals?</span></h2>
<p><span class="koboSpan" id="kobo.100.1">Even though a</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.101.1"> portal exists somewhere in the DOM tree, the portal retains its position in the React component tree by supporting all component features, such as accessing props, state, context, and event propagation. </span><span class="koboSpan" id="kobo.101.2">This means event bubbling also works </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">with portals.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">The behavior of event bubbling in portals is similar to how a React child component fires events inside the component tree. </span><span class="koboSpan" id="kobo.103.2">The events that are fired from a portal will propagate upwards to ancestors in the containing React tree, even though those elements are not ancestors in the DOM tree. </span><span class="koboSpan" id="kobo.103.3">For example, in the following HTML code, the parent component under the main root (</span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">#main-root</span></strong><span class="koboSpan" id="kobo.105.1">) can catch an uncaught bubbling event from a sibling node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">#dialog-root</span></strong><span class="koboSpan" id="kobo.107.1">) that’s been implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">using portals:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.109.1">
&lt;html&gt;
  &lt;body&gt;
    &lt;div id="main-root"&gt;&lt;/div&gt;
    &lt;div id="dialog-root"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.110.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.111.1">Event bubbling in </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.112.1">portals follows the React tree but not the </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">DOM tree.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.114.1">What accessibility precautions are taken care of in portals?</span></h2>
<p><span class="koboSpan" id="kobo.115.1">You need to ensure </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.116.1">that React applications built with portals are accessible, even for people with disabilities. </span><span class="koboSpan" id="kobo.116.2">For example, keyboard focus should work naturally when you move the focus between the modal window and the parent web page. </span><span class="koboSpan" id="kobo.116.3">The modal dialogues that are created as part of portals should follow the WAI-ARIA modal authoring </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">practices (</span></span><a href="https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/"><span class="No-Break"><span class="koboSpan" id="kobo.118.1">https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.119.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">Some of the guidelines for achieving keyboard accessibility are </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.122.1">When the dialog or modal is open, the focus moves to an element inside </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the dialog.</span></span></li>
<li><span class="koboSpan" id="kobo.124.1">Tabbing the focusable elements should only cycle through the dialog elements. </span><span class="koboSpan" id="kobo.124.2">The focus should not skip the dialog that has </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">been opened.</span></span></li>
<li><span class="koboSpan" id="kobo.126.1">After pressing the </span><em class="italic"><span class="koboSpan" id="kobo.127.1">Esc</span></em><span class="koboSpan" id="kobo.128.1"> key, the dialog </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">should close.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.130.1">If you are going to use a third-party library to create the modals, you need to make sure that the package follows the required </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">accessibility guidelines.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">You will always encounter unexpected errors while building applications. </span><span class="koboSpan" id="kobo.132.2">These errors can occur in several ways, such as via network requests, invoking third-party APIs, accessing nested object properties that don’t exist, and so on. </span><span class="koboSpan" id="kobo.132.3">Error boundaries are mainly used in React applications to handle these kinds </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">of errors.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.134.1">Understanding error boundaries</span></h1>
<p><span class="koboSpan" id="kobo.135.1">In React applications, you </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.136.1">can handle errors in two possible ways. </span><span class="koboSpan" id="kobo.136.2">The first approach is using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">try..catch</span></strong><span class="koboSpan" id="kobo.138.1"> block to handle the errors in an imperative code block, similar to regular event handlers. </span><span class="koboSpan" id="kobo.138.2">The second approach is to use </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">error boundaries</span></strong><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">These are used to deal with declarative component code that will render on </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">The React team introduced error boundaries as part of React version 16. </span><span class="koboSpan" id="kobo.142.2">No official component has been created for error boundaries in the React library, so you need to create the error boundary component on </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">your own.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.144.1">What are error boundaries?</span></h2>
<p><span class="koboSpan" id="kobo.145.1">Error boundaries are just React components with a certain list of tasks. </span><span class="koboSpan" id="kobo.145.2">They are used to catch JavaScript errors that can occur in their child component tree, log those specific errors, and redirect the screen to the fallback UI to recover from the error state. </span><span class="koboSpan" id="kobo.145.3">This component helps prevent the entire component tree from crashing just because of an error that happened somewhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">the tree.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Error boundaries catch errors during rendering, in life cycle methods, and in the constructors of the entire component tree below them. </span><span class="koboSpan" id="kobo.147.2">An error boundary can be created with a class component by defining either or both of the following life </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">cycle methods:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">static getDerivedStateFromError</span></strong><span class="koboSpan" id="kobo.150.1">: This method is used to render a fallback UI after an error has </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">been thrown</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">componentDidCatch</span></strong><span class="koboSpan" id="kobo.153.1">: This method is used to log </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">error information</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.155.1">An error boundary</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.156.1"> can be created using these two methods to protect the application from crashing. </span><span class="koboSpan" id="kobo.156.2">This is how it </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">is done:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
class MyErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { isErrorThrown: false };
  }
  static getDerivedStateFromError(error) {
    return { isErrorThrown: true };
  }
  componentDidCatch(error, errorInfo) {
    logErrorToReportingService(error, errorInfo);
  }
  render() {
    if (this.state.isErrorThrown) {
      return &lt;h1&gt;Oops, the application is unavaialble.&lt;/h1&gt;;
    }
    return this.props.children;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.159.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">getDerivedStateFromError</span></strong><span class="koboSpan" id="kobo.161.1"> method will be invoked if an error occurs in the rendering phase of any life cycle method. </span><span class="koboSpan" id="kobo.161.2">In this method, you can update the error state flag variable’s value to reflect the fallback UI in the next render. </span><span class="koboSpan" id="kobo.161.3">Based on the error state variable, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">render</span></strong><span class="koboSpan" id="kobo.163.1"> method will update the UI on the screen. </span><span class="koboSpan" id="kobo.163.2">At the same time, the same error can be reported to the logging service for debugging purposes using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">componentDidCatch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Once the error</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.167.1"> boundary has been created, it can be used as a regular React component. </span><span class="koboSpan" id="kobo.167.2">The error boundary component needs to be wrapped around the top-level React component where you suspect any kind of possible bugs. </span><span class="koboSpan" id="kobo.167.3">The usage of the component looks </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
&lt;MyErrorBoundary&gt;
  &lt;MyComponent /&gt;
&lt;/MyErrorBoundary&gt;</span></pre> <p><span class="koboSpan" id="kobo.170.1">The preceding error boundary catches any error thrown within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">MyComponent</span></strong><span class="koboSpan" id="kobo.172.1"> component tree and prevents the application </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">from crashing.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.174.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.175.1">You can also wrap error boundaries for individual components with a different set of error messages to prevent them from breaking other parts of the page. </span><span class="koboSpan" id="kobo.175.2">The decision of error boundary design depends on the business requirements and </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">UX design.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">If the enclosed error boundary failed to catch the error, the error will propagate to the next closest error boundary around it. </span><span class="koboSpan" id="kobo.177.2">This behavior is similar to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">catch()</span></strong><span class="koboSpan" id="kobo.179.1"> block, which propagates an error to the next nearest </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">catch block.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">Popular testing frameworks such as Jest can be used to write unit tests for error boundaries similar to any other React component. </span><span class="koboSpan" id="kobo.181.2">The unit test should simulate the error in the React component (to which the error boundary is wrapped) and verify that the error boundary can catch errors and renders the fallback UI properly or not. </span><span class="koboSpan" id="kobo.181.3">It is also possible to verify the error boundary using React DevTools by forcing the selected component into </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.182.1">an error (red </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">button) state.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.184.1">Is it possible to create an error boundary as a function component?</span></h2>
<p><span class="koboSpan" id="kobo.185.1">At the time</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.186.1"> of writing, it is not possible to create an error boundary as a function component using the latest React version – that is, you can only create an error boundary using a class component. </span><span class="koboSpan" id="kobo.186.2">Moreover, you can avoid writing an error boundary class altogether by reusing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">react-error-boundary</span></strong><span class="koboSpan" id="kobo.188.1"> (</span><a href="https://github.com/bvaughn/react-error-boundary"><span class="koboSpan" id="kobo.189.1">https://github.com/bvaughn/react-error-boundary</span></a><span class="koboSpan" id="kobo.190.1">) package from </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">the community.</span></span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.192.1">When do error boundaries not work?</span></h2>
<p><span class="koboSpan" id="kobo.193.1">Error boundaries do </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.194.1">not catch errors in the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">following scenarios:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.196.1">Event handlers</span></strong><span class="koboSpan" id="kobo.197.1">: Since event handlers (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">onClick</span></strong><span class="koboSpan" id="kobo.199.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">onChange</span></strong><span class="koboSpan" id="kobo.201.1">, and others) aren’t used during the rendering phase, error boundaries won’t be required to recover the UI </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">from errors</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.203.1">Asynchronous code</span></strong><span class="koboSpan" id="kobo.204.1">: Error boundaries cannot catch errors inside asynchronous callbacks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">setTimeout</span></strong><span class="koboSpan" id="kobo.206.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">requestAnimationFrame</span></strong><span class="koboSpan" id="kobo.208.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">and others</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.210.1">Server-side rendering</span></strong><span class="koboSpan" id="kobo.211.1">: React doesn’t support error boundaries on </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">a server</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.213.1">When there’s an error inside the error boundary</span></strong><span class="koboSpan" id="kobo.214.1">: React cannot catch errors thrown in the error </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">boundary itself</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.216.1">You may need to opt for a regular JavaScript </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">try..catch</span></strong><span class="koboSpan" id="kobo.218.1"> statement or </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">promise#catch()</span></strong><span class="koboSpan" id="kobo.220.1"> block to handle errors for the aforementioned cases except for the last one, where you need to make sure no errors occur in the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">error boundary.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Just like error boundaries are used to display a fallback UI for any error caught in the application, the </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.223.1">Suspense API is used to display a fallback UI until its children have </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">finished loading.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.225.1">Managing asynchronous actions with the Suspense API</span></h1>
<p><span class="koboSpan" id="kobo.226.1">The Suspense</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.227.1"> feature was introduced in React version 16, alongside error boundaries. </span><span class="koboSpan" id="kobo.227.2">Initially, it was only meant to be used with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">lazy</span></strong><span class="koboSpan" id="kobo.229.1"> API for code splitting and could not be used for server-side rendering. </span><span class="koboSpan" id="kobo.229.2">React18 improved the Suspense API so that it can support many use cases, including server-side rendering and asynchronous operations such as </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">data fetching.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.231.1">What is the Suspense API? </span><span class="koboSpan" id="kobo.231.2">How do you use it?</span></h2>
<p><span class="koboSpan" id="kobo.232.1">The Suspense API is </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.233.1">used to display a fallback UI such as a loading indicator until its children are ready to render. </span><span class="koboSpan" id="kobo.233.2">The suspense component accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">fallback</span></strong><span class="koboSpan" id="kobo.235.1"> prop to render an alternative UI if its children have not finished rendering. </span><span class="koboSpan" id="kobo.235.2">You can wrap your application with a suspense component either at the top level or individual sections of </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">Let’s learn how to use the Suspense feature by looking at the </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">following example.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Consider a simple use case of loading blog posts from a specific author. </span><span class="koboSpan" id="kobo.239.2">Here, the blog posts component (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">&lt;Posts/&gt;)</span></strong><span class="koboSpan" id="kobo.241.1"> suspends while fetching the list of posts. </span><span class="koboSpan" id="kobo.241.2">Before the content is ready to be displayed, React switches to the closest suspense boundary to display the fallback loading indicator (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">&lt;Loading /&gt;</span></strong><span class="koboSpan" id="kobo.243.1">) in place of displaying the list </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">of posts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
import { Suspense } from "react";
import Posts from "./posts.js";
export default function Author({ author }) {
  return (
    &lt;&gt;
      &lt;h1&gt;{author.name}&lt;/h1&gt;
      &lt;span&gt;{author.age}&lt;/span&gt;
      &lt;Suspense fallback={&lt;Loading /&gt;}&gt;
        &lt;Posts authorId={author.id} /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}
function Loading() {
  return &lt;h2&gt;Loading...&lt;/h2&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.246.1">Once the blog post </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.247.1">data has been fetched, React switches back to displaying the actual blog </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">post data.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">You can also defer updating the list and display state content until the new results are ready. </span><span class="koboSpan" id="kobo.249.2">This alternative UI pattern is possible by passing a query to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">useDeferredValue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.251.1"> Hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
const deferredAuthorDetails = useDeferredValue(author);</span></pre> <p><span class="koboSpan" id="kobo.253.1">In traditional applications, you need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">isLoading</span></strong><span class="koboSpan" id="kobo.255.1"> data flag variable to indicate whether data fetching has finished or not and display the respective content on the screen. </span><span class="koboSpan" id="kobo.255.2">However, if you use the Suspense feature, React automatically determines whether to display the fallback UI or component data, without depending on any </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">additional flag.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.257.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.258.1">Only suspense-enabled frameworks have integrations with the Suspense feature to communicate loading</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.259.1"> states </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">to React.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.261.1">Can I use the suspense component for any kind of data fetching?</span></h2>
<p><span class="koboSpan" id="kobo.262.1">The suspense</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.263.1"> component cannot detect data fetching inside an effect or event handler. </span><span class="koboSpan" id="kobo.263.2">It can only be used for the following suspense-enabled </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">data sources:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.265.1">Data fetching with suspense-enabled opinionated frameworks such as Relay, Next.js, Remix, </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">and Hydrogen</span></span></li>
<li><span class="koboSpan" id="kobo.267.1">Lazy-loading component code with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">lazy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1"> API</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.270.1">Using the Suspense feature without a framework is not supported at the time of writing. </span><span class="koboSpan" id="kobo.270.2">However, there is a plan from the React team to provide an official API to integrate data sources with the suspense component in </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">future versions.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.272.1">How do you prevent unnecessary fallbacks during an update?</span></h2>
<p><span class="koboSpan" id="kobo.273.1">If the visible UI is </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.274.1">replaced with a fallback, there will be a flashing user experience. </span><span class="koboSpan" id="kobo.274.2">This is not a good UX experience. </span><span class="koboSpan" id="kobo.274.3">This situation happens when a state update causes a component to suspend, but the nearest suspense boundary is already showing some fallback content to the user. </span><span class="koboSpan" id="kobo.274.4">You can avoid these unnecessary fallbacks by marking the state updates as non-urgent using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">startTransition</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1"> API.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Consider an example of navigating pages in an application and applying a transition for the page update to prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">unnecessary fallbacks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
  function navigate(url) {
    startTransition(() =&gt; {
      setPage(url);
    });
  }</span></pre> <p><span class="koboSpan" id="kobo.280.1">During the transition, React will wait for the content to be loaded without retriggering the suspense fallback UI to hide the already </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">revealed content.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.282.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.283.1">React only prevents unnecessary fallbacks for non-urgent updates. </span><span class="koboSpan" id="kobo.283.2">It will not delay the render for any </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">urgent updates.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">In the past, React was only able to handle one task at a time and the render process was synchronous. </span><span class="koboSpan" id="kobo.285.2">Once the task had been started, it could not be interrupted. </span><span class="koboSpan" id="kobo.285.3">This is called blocking rendering. </span><span class="koboSpan" id="kobo.285.4">Later, this issue was fixed by introducing concurrent mode, which can interrupt the task if there is another urgent task. </span><span class="koboSpan" id="kobo.285.5">Concurrent mode was introduced as an experimental </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.286.1">feature and replaced by the concurrent rendering feature in React </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">version 18.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.288.1">Optimizing rendering performance using concurrent rendering</span></h1>
<p><span class="koboSpan" id="kobo.289.1">React 18 introduced </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.290.1">the</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.291.1"> concurrent renderer, which makes the rendering process asynchronous and ensures it can be interrupted, paused, resumed, and even abandoned. </span><span class="koboSpan" id="kobo.291.2">As a result, React can respond to user interactions quickly, even if it is in the middle of a heavy </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">rendering task.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">New features such as suspense, streaming server rendering, and transitions are powered by </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">concurrent rendering.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.295.1">How do you enable concurrent rendering in React?</span></h2>
<p><span class="koboSpan" id="kobo.296.1">First, you</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.297.1"> need to update both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">react</span></strong><span class="koboSpan" id="kobo.299.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">react-dom</span></strong><span class="koboSpan" id="kobo.301.1"> packages</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.302.1"> to version 18. </span><span class="koboSpan" id="kobo.302.2">After that, you need to replace the deprecated </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">ReactDOM.render</span></strong><span class="koboSpan" id="kobo.304.1"> method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">ReactDOM.createRoot</span></strong><span class="koboSpan" id="kobo.306.1"> method. </span><span class="koboSpan" id="kobo.306.2">Concurrent rendering will be enabled automatically in whichever parts of your application you use concurrent features such as suspense, streaming server rendering, </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">and transitions.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">As the application becomes complex, you need to spend a significant amount of time analyzing the application’s performance. </span><span class="koboSpan" id="kobo.308.2">It is especially crucial to measure the application performance’s characteristics before delivering it to customers. </span><span class="koboSpan" id="kobo.308.3">Even though you can use the browser’s User Timing API (Web API) to measure the rendering cost of your components, there are better alternatives that have been created by the React team. </span><span class="koboSpan" id="kobo.308.4">The</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.309.1"> Profiler </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.310.1">API, for example, helps identify performance bottlenecks in </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">React applications.</span></span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.312.1">Debugging React applications with the Profiler API</span></h1>
<p><span class="koboSpan" id="kobo.313.1">If you are </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.314.1">benchmarking a React application’s </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.315.1">performance, then tracking how many times your components are re-rendered and the cost of each re-rendering will help you identify the defecting areas or parts in the application. </span><span class="koboSpan" id="kobo.315.2">React provides two different ways to measure the application’s rendering performance: the </span><strong class="bold"><span class="koboSpan" id="kobo.316.1">React Profiler API</span></strong><span class="koboSpan" id="kobo.317.1"> and</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.318.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">React DevTools</span></strong><span class="koboSpan" id="kobo.320.1"> profiler tab. </span><span class="koboSpan" id="kobo.320.2">The React Profiler API is</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.321.1"> recommended considering that it supports the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">Suspense feature.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.323.1">How do you measure rendering performance?</span></h2>
<p><span class="koboSpan" id="kobo.324.1">React provides the </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.325.1">Profiler API to measure the rendering performance of a component tree programmatically. </span><span class="koboSpan" id="kobo.325.2">The component has two props: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">id</span></strong><span class="koboSpan" id="kobo.327.1"> prop, which is used to identify the part of the UI being measured, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">onRender</span></strong><span class="koboSpan" id="kobo.329.1"> callback, which is called every time the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">tree updates.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">The callback receives arguments such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">id</span></strong><span class="koboSpan" id="kobo.333.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">phase</span></strong><span class="koboSpan" id="kobo.335.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">actualDuration</span></strong><span class="koboSpan" id="kobo.337.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">baseDuration</span></strong><span class="koboSpan" id="kobo.339.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">startTime</span></strong><span class="koboSpan" id="kobo.341.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">commitTime</span></strong><span class="koboSpan" id="kobo.343.1">, which are used to log the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">rendering time.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Imagine you are suspicious of the rendering performance of an author biography component that exists inside an online bookstore application, and you would like to profile the component. </span><span class="koboSpan" id="kobo.345.2">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">AuthorBio</span></strong><span class="koboSpan" id="kobo.347.1"> component needs to be wrapped with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Profiler</span></strong><span class="koboSpan" id="kobo.349.1"> component, along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">onRender</span></strong><span class="koboSpan" id="kobo.351.1"> callback. </span><span class="koboSpan" id="kobo.351.2">This will look </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
&lt;App&gt;
  &lt;Profiler id="bio" onRender={onRender}&gt;
    &lt;AuthorBio /&gt;
  &lt;/Profiler&gt;
  &lt;Posts /&gt;
&lt;/App&gt;</span></pre> <p><span class="koboSpan" id="kobo.354.1">You can also use multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">Profiler</span></strong><span class="koboSpan" id="kobo.356.1"> components to measure the different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">JavaScript provided strict mode as a new feature in ECMAScript5 to enforce the restricted version of JavaScript. </span><span class="koboSpan" id="kobo.358.2">This feature brings stricter rules when you write code and throws errors if you violate them. </span><span class="koboSpan" id="kobo.358.3">Strict mode can be enabled by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">use strict</span></strong><span class="koboSpan" id="kobo.360.1"> line at the top of your file. </span><span class="koboSpan" id="kobo.360.2">Similarly, React provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">StrictMode</span></strong><span class="koboSpan" id="kobo.362.1"> component as a development-only</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.363.1"> tool, which is used to enforce stricter warnings and checks while writing </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">React code.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.365.1">Strict mode</span></h1>
<p><span class="koboSpan" id="kobo.366.1">The React team introduced</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.367.1"> strict mode as a debugging tool to identify potential bugs or issues in a web application. </span><span class="koboSpan" id="kobo.367.2">This tool is available as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">StrictMode</span></strong><span class="koboSpan" id="kobo.369.1"> component in the React API. </span><span class="koboSpan" id="kobo.369.2">It doesn’t render any UI that is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">Fragment</span></strong><span class="koboSpan" id="kobo.371.1"> component. </span><span class="koboSpan" id="kobo.371.2">This feature is only applicable to development mode – it won’t impact behavior in production. </span><span class="koboSpan" id="kobo.371.3">This section focuses on the important strict mode concepts and questions that might be asked in </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">the interview.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.373.1">How do you enable strict mode?</span></h2>
<p><span class="koboSpan" id="kobo.374.1">You can enable </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.375.1">strict mode for an entire app by wrapping it around the root component, </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
const root = createRoot(document.getElementById("root"));
root.render(
  &lt;StrictMode&gt;
    &lt;App /&gt;
  &lt;/StrictMode&gt;
);</span></pre> <p><span class="koboSpan" id="kobo.378.1">You can also only use strict mode in certain parts of the application (that is, not the entire application) where you think there is a high possibility of bugs. </span><span class="koboSpan" id="kobo.378.2">Consider strict mode for the main </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.379.1">body of the page of an application. </span><span class="koboSpan" id="kobo.379.2">It should look something </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.381.1">
&lt;&gt;
  &lt;Navigation&gt;
    &lt;Details&gt;
      &lt;StrictMode&gt;
        &lt;Services /&gt;
        &lt;Support /&gt;
      &lt;/StrictMode&gt;
    &lt;/Details&gt;
    &lt;Footer /&gt;
  &lt;/Navigation&gt;
&lt;/&gt;;</span></pre> <p><span class="koboSpan" id="kobo.382.1">Most of the time, React developers face issues with improper logic in the rendering section, as well as issues with missing cleanup code inside effects Hooks. </span><span class="koboSpan" id="kobo.382.2">These types of bugs can </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.383.1">easily be identified with </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">strict mode.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.385.1">Can you describe the list of development-only checks enabled by strict mode?</span></h2>
<p><span class="koboSpan" id="kobo.386.1">Strict mode enables the </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.387.1">following list of development-only checks to find commonly occurring bugs during </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">early development:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.389.1">Components will re-render one more time to find the bugs that were caused by </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">impure rendering</span></span></li>
<li><span class="koboSpan" id="kobo.391.1">Components will rerun effects one more time to find the bugs that were caused by missing cleanup for </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">the effect</span></span></li>
<li><span class="koboSpan" id="kobo.393.1">Components will be verified for the usage of deprecated APIs and will notify the users </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">with warnings</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.395.1">These checks are</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.396.1"> applicable for development purposes only. </span><span class="koboSpan" id="kobo.396.2">They won’t have any impact on the </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">production builds.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.398.1">What functions are called twice in the double rendering process of strict mode?</span></h2>
<p><span class="koboSpan" id="kobo.399.1">Strict mode calls </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.400.1">the following list of functions twice in </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">development mode:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.402.1">The function’s component body, excluding code inside </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">event handlers</span></span></li>
<li><span class="koboSpan" id="kobo.404.1">The functions that are passed to Hook, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">useState</span></strong><span class="koboSpan" id="kobo.406.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">useReducer</span></strong><span class="koboSpan" id="kobo.408.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">useMemo</span></strong></span></li>
<li><span class="koboSpan" id="kobo.411.1">State </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">updater functions</span></span></li>
<li><span class="koboSpan" id="kobo.413.1">Class component methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">constructor</span></strong><span class="koboSpan" id="kobo.415.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">render</span></strong><span class="koboSpan" id="kobo.417.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">shouldComponentUpdate</span></strong><span class="koboSpan" id="kobo.419.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">getDerivedStateFromProps</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.422.1">If your function is impure, running it twice in development mode will impact the expected output. </span><span class="koboSpan" id="kobo.422.2">This result helps you identify any bugs in your code as early </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">Apart from strict mode, you can also use static type checking in React applications to avoid bugs and errors that appear at runtime. </span><span class="koboSpan" id="kobo.424.2">As your application grows, you can catch many bugs using </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">type checking.</span></span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.426.1">Static type checking</span></h1>
<p><span class="koboSpan" id="kobo.427.1">React is based on</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.428.1"> JavaScript and JavaScript is a loosely typed language. </span><span class="koboSpan" id="kobo.428.2">So, we don’t get the default static type-checking feature </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">in React.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">In its older versions (&lt;15.5), React had </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">PropTypes</span></strong><span class="koboSpan" id="kobo.432.1"> validators so that it could perform simple type checking in applications. </span><span class="koboSpan" id="kobo.432.2">Post that, this library was moved out from React’s core module and created as a separate library, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">prop-types</span></strong><span class="koboSpan" id="kobo.434.1"> (</span><a href="https://www.npmjs.com/package/prop-types"><span class="koboSpan" id="kobo.435.1">https://www.npmjs.com/package/prop-types</span></a><span class="koboSpan" id="kobo.436.1">). </span><span class="koboSpan" id="kobo.436.2">Nowadays, </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">PropTypes</span></strong><span class="koboSpan" id="kobo.438.1"> are not commonly used in modern React applications. </span><span class="koboSpan" id="kobo.438.2">Even though static type checking is not mandatory in React, you </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.439.1">might encounter some questions related to static type checking in </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the interview.</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.441.1">What are the benefits of static type checking?</span></h2>
<p><span class="koboSpan" id="kobo.442.1">There are many </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.443.1">benefits of static type checking in JavaScript applications. </span><span class="koboSpan" id="kobo.443.2">Some of these are </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">listed here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.445.1">Can identify type errors before runtime (that is, errors at </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">compile time)</span></span></li>
<li><span class="koboSpan" id="kobo.447.1">Can detect bugs and errors in the </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">early stages</span></span></li>
<li><span class="koboSpan" id="kobo.449.1">Optimized and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">to read</span></span></li>
<li><span class="koboSpan" id="kobo.451.1">Better </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">IDE support</span></span></li>
<li><span class="koboSpan" id="kobo.453.1">Can </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">generate documentation</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.455.1">It is cheaper to fix bugs if you identify them as early </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">as possible.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.457.1">How do you implement static type checking in React applications?</span></h2>
<p><span class="koboSpan" id="kobo.458.1">In React, there </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.459.1">are multiple ways</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.460.1"> to implement static type checking, but the following two ways are </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">the best:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.462.1">TypeScript</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.463.1">Flow</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.464.1">These two static type checkers help identify certain types of errors, even before you run your code. </span><span class="koboSpan" id="kobo.464.2">Since TypeScript is robust and has the most community support, let’s see how it can be implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">in React.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">TypeScript was created by Microsoft and is considered a typed superset of JavaScript. </span><span class="koboSpan" id="kobo.466.2">It comes with its own compiler and can catch errors and bugs at build time. </span><span class="koboSpan" id="kobo.466.3">It supports JSX and can use React hooks without any problems. </span><span class="koboSpan" id="kobo.466.4">Nowadays, TypeScript can be supported by major frameworks just by appending various options, as </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">listed here:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.468.1">Next.js:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.469.1"> npx create-next-app@latest --ts</span></strong></pre></li> <li><span class="No-Break"><span class="koboSpan" id="kobo.470.1">Remix:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.471.1">npx create-remix@latest</span></strong></pre></li> <li><span class="No-Break"><span class="koboSpan" id="kobo.472.1">Gatsby:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.473.1"> npm init gatsby –ts</span></strong></pre></li> <li><span class="No-Break"><span class="koboSpan" id="kobo.474.1">Expo:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.475.1">npx create-expo-app -t expo-template-blank-typescript</span></strong></pre></li> </ul>
<p><span class="koboSpan" id="kobo.476.1">If you are not using</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.477.1"> any </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.478.1">of these frameworks, you need to follow the following manual steps to set up TypeScript in </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">React applications:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.480.1">Add TypeScript as a dependency to your project</span></strong><span class="koboSpan" id="kobo.481.1">: You need to install the latest version of TypeScript using </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">npm</span></strong><span class="koboSpan" id="kobo.483.1"> or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">yarn</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.485.1">package manager:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.486.1">npm install --save-dev typescript</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.487.1">This dependency will give you access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">tsc</span></strong><span class="koboSpan" id="kobo.489.1"> compiler (that is, the TypeScript compiler) so that you can build </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the application.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.491.1">Configure the TypeScript compiler’s options</span></strong><span class="koboSpan" id="kobo.492.1">: A set of rules can be defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.494.1"> by generating the file using the </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.496.1">npx tsc --init</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.497.1">The frequently used options are the source directory for TypeScript files and generated JavaScript files for the output folder. </span><span class="koboSpan" id="kobo.497.2">The configuration looks </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">like this:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.499.1">//tsconfig.json
{
  "compilerOptions": {
    // ...
</span><span class="koboSpan" id="kobo.499.2">    "rootDir": "src",
    "outDir": "dist"
    // ...
</span><span class="koboSpan" id="kobo.499.3">  },
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.500.1">You can add more configuration options, as described here: </span><a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html"><span class="koboSpan" id="kobo.501.1">https://www.typescriptlang.org/docs/handbook/tsconfig-json.html</span></a><span class="koboSpan" id="kobo.502.1">. </span><span class="koboSpan" id="kobo.502.2">TypeScript’s React starter provides this configuration file with a good set </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">of rules.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.504.1">Choose the file extension</span></strong><span class="koboSpan" id="kobo.505.1">: You can use the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">.ts</span></strong><span class="koboSpan" id="kobo.507.1"> extension or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">.tsx</span></strong><span class="koboSpan" id="kobo.509.1"> extension for files that contain </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">JSX code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.511.1">Add type definitions for libraries</span></strong><span class="koboSpan" id="kobo.512.1">: It is possible to use external JavaScript packages in TypeScript by including either a bundled declaration file or getting one from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">DefinitelyTyped</span></strong><span class="koboSpan" id="kobo.514.1"> (</span><a href="https://github.com/DefinitelyTyped/DefinitelyTyped"><span class="koboSpan" id="kobo.515.1">https://github.com/DefinitelyTyped/DefinitelyTyped</span></a><span class="koboSpan" id="kobo.516.1">) repository or creating a local </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">declaration file.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.518.1">Now, you can build your TypeScript project with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">tsc</span></strong><span class="koboSpan" id="kobo.520.1"> command, which is available through the </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">TypeScript package.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">Initially, React was mainly used for web development. </span><span class="koboSpan" id="kobo.522.2">Nowadays, it can be used for mobile, desktop, and </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.523.1">VR apps too. </span><span class="koboSpan" id="kobo.523.2">React </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.524.1">Native is a separate library that was created to support mobile devices. </span><span class="koboSpan" id="kobo.524.2">It is based on the same concepts as React but uses native components instead of web components to render on </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">the screen.</span></span></p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.526.1">React in mobile environments and its features</span></h1>
<p><span class="koboSpan" id="kobo.527.1">When Facebook </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.528.1">initially chose to make its services available on mobile </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.529.1">devices, it decided to run mobile pages based on HTML5 instead of building native apps, which was preferred by many tech giants at that time. </span><span class="koboSpan" id="kobo.529.2">However, it ended up with UX and performance </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">overhead issues.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">In 2013, the Facebook team found a method of generating UI elements for iOS apps by using JavaScript. </span><span class="koboSpan" id="kobo.531.2">This idea was successful for mobile applications and later, React Native was supported for Android </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">devices too.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">This section will focus on React Native, so that we can go beyond ReactJS concepts and cover important topics related to architecture, navigation, and its differences from ReactJS, which </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.534.1">might be </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.535.1">expected in </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">React interviews.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.537.1">What is React Native?</span></h2>
<p><span class="koboSpan" id="kobo.538.1">React Native is a </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.539.1">popular JavaScript-based mobile app framework for building natively rendered mobile applications for iOS, Android, and Windows. </span><span class="koboSpan" id="kobo.539.2">The main advantage of this library is that you can use one code base that runs on </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">multiple platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">The Facebook team open sourced React Native in 2015. </span><span class="koboSpan" id="kobo.541.2">After only a few years, this library became one of the top solutions for mobile development and is now used in popular mobile apps such as Facebook, Instagram, Skype, Uber, </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">and others.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.543.1">What are the differences between React and React Native?</span></h2>
<p><span class="koboSpan" id="kobo.544.1">React Native is based on </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.545.1">the React library and they share many concepts. </span><span class="koboSpan" id="kobo.545.2">But there are a few major differences, as </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">shown here:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.547.1">React</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.548.1">React Native</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.549.1">It is used to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">web applications</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.551.1">It is used to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">mobile applications</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.553.1">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">react-router</span></strong><span class="koboSpan" id="kobo.555.1"> library to </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">navigate pages</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.557.1">It uses an in-built navigator library to </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">navigate pages</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.559.1">A virtual DOM is used to render the </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">web pages</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.561.1">A native API is used to render </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">the pages</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.563.1">React uses HTML, CSS, and JavaScript to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">user interface</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.565.1">React Native uses native components and APIs to </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">build apps</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.567.1">It uses JavaScript and CSS libraries </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">for animation</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.569.1">It comes with built-in </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">animation libraries</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.571.1">Table 5.1: React versus React Native</span></p>
<p><span class="koboSpan" id="kobo.572.1">So, React Native is an additional library built on top of React library to create native apps and this native</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.573.1"> library has its </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">own architecture.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.575.1">Can you describe the React Native architecture based on the threading model?</span></h2>
<p><span class="koboSpan" id="kobo.576.1">Fabric is the new </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.577.1">rendering architecture that was created by the Facebook team and even their app is backed by this renderer. </span><span class="koboSpan" id="kobo.577.2">The core principles of this architecture are unifying the renderer logic in C++ and optimizing the interoperability between host platforms. </span><span class="koboSpan" id="kobo.577.3">It is based on the threading model, similar to the old architecture, but it functions differently to optimize the user experience better than </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">native apps.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">In the old architecture, React Native bridge was used to communicate between JavaScript and native modules. </span><span class="koboSpan" id="kobo.579.2">But it has its limitations – for example, communication can only happen through asynchronous operations and it is required to serialize or deserialize the data as JSON. </span><span class="koboSpan" id="kobo.579.3">This bridge component was replaced with </span><strong class="bold"><span class="koboSpan" id="kobo.580.1">JavaScript Interface</span></strong><span class="koboSpan" id="kobo.581.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.582.1">JSI</span></strong><span class="koboSpan" id="kobo.583.1">) in the</span><a id="_idIndexMarker465"/> <span class="No-Break"><span class="koboSpan" id="kobo.584.1">new architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">Let’s take a look at how the various components communicate in the new </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">rendering architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.587.1"><img alt="Figure 5.1: Fabric rendering architecture" src="image/Figure_05.01_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.588.1">Figure 5.1: Fabric rendering architecture</span></p>
<p><span class="koboSpan" id="kobo.589.1">Three parallel threads run in every React app, irrespective of whether the old or new renderer </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">is used:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.591.1">UI thread or main thread</span></strong><span class="koboSpan" id="kobo.592.1">: This thread is responsible for handling iOS and Android host views. </span><span class="koboSpan" id="kobo.592.2">It handles some native interactions, such as tapping on a button, user gesture events, scrolling, </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">and others.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.594.1">JS thread</span></strong><span class="koboSpan" id="kobo.595.1">: This thread is responsible for handling all the logic of your React Native application. </span><span class="koboSpan" id="kobo.595.2">It takes care of all the DOM hierarchy operations written in the code and executes them. </span><span class="koboSpan" id="kobo.595.3">After that, the code is sent to the native module thread </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">for optimizations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.597.1">Shadow or background thread</span></strong><span class="koboSpan" id="kobo.598.1">: This thread is responsible for layout calculations such as positions and the height and width of elements and then transforming them into </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">native elements.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.600.1">In the old architecture, the bridge component was used to communicate between the JS thread and the UI thread asynchronously by serializing and deserializing the data. </span><span class="koboSpan" id="kobo.600.2">As a result, memory management and application performance became overloaded. </span><span class="koboSpan" id="kobo.600.3">In the new architecture, the bridge component has been replaced with JSI for efficient communication</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.601.1"> between native and JavaScript code. </span><span class="koboSpan" id="kobo.601.2">JSI is a lightweight layer where methods written in C++ can be used by the JavaScript engine, such as </span><strong class="bold"><span class="koboSpan" id="kobo.602.1">JavaScript Core</span></strong><span class="koboSpan" id="kobo.603.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.604.1">JSC</span></strong><span class="koboSpan" id="kobo.605.1">) or Hermes, to directly invoke or call </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.606.1">methods in the </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">native code.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">The workflow of the new architecture is </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.610.1">When the user clicks an app icon of a mobile application, the Fabric rendering system directly loads the native side instead of opening </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">native modules.</span></span></li>
<li><span class="koboSpan" id="kobo.612.1">The rendering system notifies the JS thread once it is ready. </span><span class="koboSpan" id="kobo.612.2">After that, the JS thread loads the final bundle, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">main.bundle.js</span></strong><span class="koboSpan" id="kobo.614.1">, which consists of JavaScript code, React logic, and </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">its components.</span></span></li>
<li><span class="koboSpan" id="kobo.616.1">The JS code is invoked through the ref native function, which has been exposed as an object using the JSI API </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">to Fabric.</span></span></li>
<li><span class="koboSpan" id="kobo.618.1">The yoga engine inside the shadow thread performs layout calculations, converting from the Flexbox-based style into the host layout, and </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">so on.</span></span></li>
<li><span class="koboSpan" id="kobo.620.1">Finally, the components are rendered on </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">the screen.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.622.1">Additionally, two new components have been added to the new architecture: </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Turbo module</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.624.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">CodeGen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">Turbo module</span></strong><span class="koboSpan" id="kobo.628.1"> is an improved version of the native module (it exists in the old architecture) that communicates between JavaScript and platform-native code by lazily loading the modules to improve the startup performance. </span><span class="koboSpan" id="kobo.628.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">CodeGen</span></strong><span class="koboSpan" id="kobo.630.1"> static type checker helps </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.631.1">communicate dynamic JavaScript code and JSI code written as statically </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">typed C++.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.633.1">How do you perform navigations in React Native?</span></h2>
<p><span class="koboSpan" id="kobo.634.1">React Native </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.635.1">uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">react-navigation</span></strong><span class="koboSpan" id="kobo.637.1"> library to navigate between pages in native applications. </span><span class="koboSpan" id="kobo.637.2">The transition between multiple screens is managed by various kinds of navigators, such as stack navigators, drawer navigators, and tab navigators. </span><span class="koboSpan" id="kobo.637.3">While navigating between multiple screens, you can also pass data </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">between them.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">React Navigation is made up of core utilities that are used by navigators to create the navigation structure in your app. </span><span class="koboSpan" id="kobo.639.2">The package can be installed using the </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.641.1">
npm install @react-navigation/native</span></pre> <p><span class="koboSpan" id="kobo.642.1">Each navigator in React Navigation lives in its own library. </span><span class="koboSpan" id="kobo.642.2">For example, if you want to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">native-stack</span></strong><span class="koboSpan" id="kobo.644.1"> navigator, it should be installed separately using the </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.646.1">
npm install @react-navigation/native-stack</span></pre> <p><span class="koboSpan" id="kobo.647.1">The stack navigator provides a way for your app to transition between screens and manage navigation history. </span><span class="koboSpan" id="kobo.647.2">This behavior is similar to how a web browser handles navigation history. </span><span class="koboSpan" id="kobo.647.3">It also provides gestures and animations that you might expect in Android and iOS devices while navigating the pages within </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">the stack.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Here is an example of an organization’s website navigation menu items that have been created based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">stack navigator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.651.1">
import * as React from "react";
import { View, Text } from "react-native";
import { NavigationContainer } from "@react-navigation/native";
import { createNativeStackNavigator } from "@react-navigation/native-stack";
import HomeScreen from "components/HomeScreen";
import ServicesScreen from "components/ServicesScreen";
const Stack = createNativeStackNavigator();
function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;Stack.Navigator&gt;
        &lt;Stack.Screen name="Home" component={HomeScreen} /&gt;
        &lt;Stack.Screen name="Services" component={ServicesScreen} /&gt;
      &lt;/Stack.Navigator&gt;
    &lt;/NavigationContainer&gt;
  );
}
export default App;</span></pre> <p><span class="koboSpan" id="kobo.652.1">In the preceding</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.653.1"> code, we created a stacked navigation menu to redirect users to important screens of the website, such as the home and </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">services pages.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">Additionally, you can nest navigators using the </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">Navigation API.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.657.1">What are the benefits of the new architecture?</span></h2>
<p><span class="koboSpan" id="kobo.658.1">The new architecture of</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.659.1"> React Native brings several benefits in terms of user experience, code quality, performance, and extensibility. </span><span class="koboSpan" id="kobo.659.2">We have compiled a few of </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">them here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.661.1">Better interoperability</span></strong><span class="koboSpan" id="kobo.662.1">: In the old architecture, there was a layout jump issue when you try to embed a React view into the host view. </span><span class="koboSpan" id="kobo.662.2">This was because the React Native layout was asynchronous. </span><span class="koboSpan" id="kobo.662.3">The new renderer provides improved interoperability by rendering React </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">pages synchronously.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.664.1">Better data fetching behavior</span></strong><span class="koboSpan" id="kobo.665.1">: The data fetching user experience has been improved with the integration of React’s </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">Suspense feature.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.667.1">Type safety</span></strong><span class="koboSpan" id="kobo.668.1">: Code generation ensures type safety between the JS and platform layers. </span><span class="koboSpan" id="kobo.668.2">It uses JavaScript component declarations to generate C++ structs to hold the props. </span><span class="koboSpan" id="kobo.668.3">The code generated from the JS specification must be typed through Flow </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">or TypeScript.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.670.1">Synchronous execution</span></strong><span class="koboSpan" id="kobo.671.1">: This improves the user experience. </span><span class="koboSpan" id="kobo.671.2">Now, it is possible to execute the functions synchronously rather </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">than asynchronously.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.673.1">Concurrency</span></strong><span class="koboSpan" id="kobo.674.1">: JavaScript can invoke functions that are executed on </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">different threads.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.676.1">Shared C++ code</span></strong><span class="koboSpan" id="kobo.677.1">: The new renderer is implemented in C++. </span><span class="koboSpan" id="kobo.677.2">As a result, it is possible to write platform-agnostic code and share it </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">between platforms.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.679.1">Improved performance</span></strong><span class="koboSpan" id="kobo.680.1">: In the new rendering architecture, all the limitations of a particular platform can be identified, and solutions have been provided for working with both iOS and Android. </span><span class="koboSpan" id="kobo.680.2">Initially, the view flattening solution was only available on Android, but it is now available by default for </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">both platforms.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.682.1">Faster startup</span></strong><span class="koboSpan" id="kobo.683.1">: Since the host components are lazily initialized by default, there will be a faster </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">startup time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.685.1">Consistency</span></strong><span class="koboSpan" id="kobo.686.1">: The component’s behavior is consistent across platforms because the new render system </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">is cross-platform.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.688.1">Less overhead</span></strong><span class="koboSpan" id="kobo.689.1">: You don’t need to perform serialization or deserialization between JavaScript and the UI </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">layer anymore.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.691.1">You cannot </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.692.1">achieve these benefits with the </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">old architecture.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.694.1">What is view flattening?</span></h2>
<p><span class="koboSpan" id="kobo.695.1">The declarative and</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.696.1"> composition characteristics of the React API allow you to create deep React Element Trees, where most of the nodes only affect the layout of a screen instead of rendering on the screen. </span><span class="koboSpan" id="kobo.696.2">These nodes are called </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">layout-only</span></strong><span class="koboSpan" id="kobo.698.1"> nodes. </span><span class="koboSpan" id="kobo.698.2">Large </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.699.1">amounts of layout-only nodes lead to poor performance </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">during rendering.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">The renderer implements the view flattening algorithm to improve performance. </span><span class="koboSpan" id="kobo.701.2">View flattening is an optimization algorithm that’s used by the React Native renderer to avoid deep layout trees. </span><span class="koboSpan" id="kobo.701.3">This mechanism merges or flattens these types of layout-only nodes and reduces the depth of the host view hierarchy displayed on </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.703.1">This process can be explained with </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">MyLogoComponent</span></strong><span class="koboSpan" id="kobo.705.1">, which contains view container components with margin and </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">padding styling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.707.1">
function MyLogoComponent() {
  return (
    &lt;View&gt;
      &lt;View style={{margin: 10}} &gt;
        &lt;View style={{padding: 20}}&gt;
          &lt;Image {...} /&gt;
          &lt;Text {...}&gt;This is a caption&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.708.1">In the preceding code, two host views (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">&lt;View style={..}&gt;</span></strong><span class="koboSpan" id="kobo.710.1">) have been added between the container and the actual content of the component to apply structural styling for the </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">inner content.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">The view flattening algorithm is integrated as </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.713.1">a part of the </span><strong class="bold"><span class="koboSpan" id="kobo.714.1">diffing</span></strong><span class="koboSpan" id="kobo.715.1"> stage of the renderer and merges the styling of the second and third views into the first view. </span><span class="koboSpan" id="kobo.715.2">This way, it avoids the need to create and render two extra </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">host views.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">The following </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.718.1">diagram shows how the native screen appeared without deep layout trees using </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">this mechanism:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.720.1"><img alt="Figure 5.2: Native screen with merged views" src="image/Figure_05.02_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.721.1">Figure 5.2: Native screen with merged views</span></p>
<p><span class="koboSpan" id="kobo.722.1">There won’t be any visible changes after this view flattening algorithm has </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">been applied.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">In this section, we covered some of the important fundamental concepts of React Native that you might encounter in React job interviews. </span><span class="koboSpan" id="kobo.724.2">You might be asked about these to test your knowledge of the React technology stack. </span><span class="koboSpan" id="kobo.724.3">This section also brings you to the end of this chapter, where </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.725.1">we covered a wide range of advanced topics in the </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">React ecosystem.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.727.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.728.1">This chapter covered a list of advanced concepts that you might encounter in a ReactJS interview. </span><span class="koboSpan" id="kobo.728.2">We began by covering new features such as portals, which handle modal windows, error boundaries, which prevent the app from crashing due to errors, and the Suspense feature, which displays an alternative UI for heavily time-consuming background tasks. </span><span class="koboSpan" id="kobo.728.3">After that, we covered topics related to concurrent rendering, which supports features that improve the rendering performance, followed by the Profiler API, which can be used to detect the rendering cost of specific parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">an application.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">Then, we discussed development-only features such as strict mode and static types, which help us avoid any possible bugs and errors encountered in the code. </span><span class="koboSpan" id="kobo.730.2">Finally, we introduced React in mobile environments and React Native and its differences with ReactJS, as well as its internals and </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">rendering architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">Throughout this chapter, we have helped you learn advanced concepts, their significance, and their best practices in React development. </span><span class="koboSpan" id="kobo.732.2">As a result, this book will improve your React skill set so that you become an expert and stand out in the competitive </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">job market.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">In the next chapter, we will understand popular state management solutions in React. </span><span class="koboSpan" id="kobo.734.2">We will start by looking at Flux patterns and the Redux architecture so that you understand the foundation of Redux. </span><span class="koboSpan" id="kobo.734.3">After that, we will cover important topics such as core principles, various components, handling asynchronous requests, middleware, and debugging </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">Redux applications.</span></span></p>
</div>


<div class="Content" id="_idContainer033">
<h1 id="_idParaDest-209" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.1.1">Part 3: Going Beyond React and Advanced Topics</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will learn about the popular React.js state library Redux and why having a global state store in our projects can be extremely beneficial, compared to using a local state. </span><span class="koboSpan" id="kobo.2.2">We will also take a look at the numerous ways to use CSS within a React.js application and how each method has its pros </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">and cons.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">Then, we will be testing and debugging as we learn of the different ways we can use testing to make our code more reliable. </span><span class="koboSpan" id="kobo.4.2">Finally, we will learn about the React.js libraries Next.js, Gatsby, and Remix, seeing how they can help us to build </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">React.js applications.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li><a href="B18603_06.xhtml#_idTextAnchor209"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Redux: The Best State Management Solution</span></em></li>
<li><a href="B18603_07.xhtml#_idTextAnchor239"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Different Approaches to Apply CSS in React.js</span></em></li>
<li><a href="B18603_08.xhtml#_idTextAnchor257"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Testing and Debugging the React Application</span></em></li>
<li><a href="B18603_09.xhtml#_idTextAnchor276"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.18.1">, </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Rapid Development with the Next.js, Gatsby, and Remix Frameworks</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer034">
</div>
</div>
</body></html>