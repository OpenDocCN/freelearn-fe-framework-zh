<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Components for User Experience"><div class="titlepage" id="aid-1ENBI2"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Components for User Experience</h1></div></div></div><p>User experience is a core concern for developers building today's applications. We are no longer living in a world where users are contented with an application that just works. The expectations are much higher. Now, an application needs to be highly usable and should provide an efficient workflow; users also expect it to bring them pleasure while performing tasks.</p><p>In this chapter, we're going to look at building some components that will increase the overall usability of our task management system. These features will enrich the current functionality and provide more efficient workflows.</p><p>We will develop the following three technical features and embed them into our current application, wherever applicable:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Tag management</strong></span>: We'll <a id="id282" class="indexterm"/>enable the use of tags within generated content, such as comments, activities, and other areas where they can be of any use. Tags will help users build links between content and navigation shortcuts.</li><li class="listitem"><span class="strong"><strong>Drag and drop</strong></span>: We'll build <a id="id283" class="indexterm"/>generic components that will make use of drag and drop features a breeze. By enabling drag and drop features, we'll allow users to fulfill certain tasks with much higher efficiency.</li><li class="listitem"><span class="strong"><strong>Infinite scrolling</strong></span>: We'll build a <a id="id284" class="indexterm"/>component that will reveal the content of lists while scrolling. This feature is not going to directly increase the workflow performance, but it will help us increase the overall application performance. It will also narrow down the user's context by only showing relevant information.</li></ul></div><p>We'll cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creating a tag management system to enter and display tags</li><li class="listitem">Creating a stateful pipe to render tags using a service</li><li class="listitem">Using the <code class="literal">sanitize-html</code> module to sanitize potentially unsafe content</li><li class="listitem">Creating a component to autocomplete tags during user input</li><li class="listitem">Going through the basics of the HTML5 drag and drop API</li><li class="listitem">Creating directives for draggable elements and drop targets</li><li class="listitem">Using <code class="literal">dataTransfer</code> objects and a custom attribute to enable selective drop targets</li><li class="listitem">Creating a custom <code class="literal">ForOf</code> repeater using the asterisk template syntax to enable infinite scrolling</li><li class="listitem">Implementing custom change detection using the <code class="literal">DoCheck</code> lifecycle hook, and using <code class="literal">IterableDiffer</code> to apply DOM changes</li><li class="listitem">Performing dynamic view instantiation using <code class="literal">ViewContainer</code></li></ul></div><div class="section" title="Tag management"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Tag management</h1></div></div></div><p>The classical form of <a id="id285" class="indexterm"/>tagging enables you to associate a taxonomy with elements within a system and helps you organize your project. It allows you to have a many-to-many association that can be quickly managed, and you can use it later to filter relevant information.</p><p>In our task management system, we're going to use a slightly different version of tags. Our goal is to provide a way to have semantic shortcuts within the application. With the help of tags, a user should be able to cross-reference information between different parts of the data, providing a summary of the referenced entity as well as a navigation shortcut for the entity.</p><p>For example, we can include a <code class="literal">project</code> tag within a user comment. A user can enter the tag by simply typing in the project ID. When a comment is displayed, we see the title of the project and the number of open tasks within the project. But when we click on the tag, we directly reach the project detail page where the task is located.</p><p>In this section, we'll develop the required elements to provide a way to use <code class="literal">project</code> tags that will enable the user to cross-reference other projects within comments. We'll also use tag management in our activities, which we created in the previous chapter.</p><div class="section" title="Tag data entity"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec42"/>Tag data entity</h2></div></div></div><p>Let's start with the tag <a id="id286" class="indexterm"/>entity that shows how we can represent tags within our system. We'll create a new <code class="literal">Tag</code> class in a file under <code class="literal">tags/tag.js</code>:</p><div class="informalexample"><pre class="programlisting">// Class that represents a tag
export class Tag {
  constructor(textTag, title, link, type) {
    // The textTag property is the text representation of the tag
<span class="strong"><strong>    this.textTag = textTag;</strong></span>
<span class="strong"><strong>    this.title = title;</strong></span>
<span class="strong"><strong>    this.link = link;</strong></span>
<span class="strong"><strong>    this.type = type;</strong></span>
  }
}</pre></div><p>This class represents tags; whenever we store tag information, we'll use this entity as a data vehicle. Let's look at the <a id="id287" class="indexterm"/>individual fields and elaborate on their use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">textTag</code>: This is the text representation of a tag. All our tags need to be identified uniquely using this text representation. We can define the text representation of tags as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Text tags always start with a hash symbol (<code class="literal">#</code>)</li><li class="listitem">Text tags only contain word characters or the minus symbol (<code class="literal">-</code>)</li><li class="listitem">All the innards of a tag, defined by other properties (<code class="literal">title</code>, <code class="literal">link</code>, and <code class="literal">type</code>), can be extrapolated from the <code class="literal">textTag</code> property. It can therefore be considered an ID.</li></ul></div></li><li class="listitem"><code class="literal">title</code>: This is a comparatively longer text representation of a tag. It should contain as much detail about the subject as possible. In the case of project tags, this could mean the project title, open tags count, assignee, and other important information. Since this is the field that will be rendered if a tag is parsed, it'll be beneficial if the content stays relatively condensed.</li><li class="listitem"><code class="literal">link</code>: A valid URL, which will be used when the tag is rendered. This URL will make links clickable and enable the shortcut navigation. In the case of the projects tags we're going to create, this will be a URL fragment identifier that will link to the given project page.</li><li class="listitem"><code class="literal">type</code>: This is used to distinguish between different tags and provide us a way to organize tags at a higher granularity level.</li></ul></div><p>So far, so good. We now have a data vehicle we can easily construct to transfer information about tags.</p></div><div class="section" title="Generating tags"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec43"/>Generating tags</h2></div></div></div><p>Our next step is to create a <a id="id288" class="indexterm"/>factory that will generate tags for us. All we'd like to pass to the factory is a subject, which can be basically anything. The factory will then determine the type of the subject and execute the necessary logic to generate a tag from it. This might sound a bit abstract at first, but let's look at the code of the <code class="literal">generateTag</code> function we'll create in a module under <code class="literal">tags/generate-tag.js</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import {Tag} from './tag';</strong></span>
import {limitWithEllipsis} from '../utilities/string-utilities';
<span class="strong"><strong>export const TAG_TYPE_PROJECT = 'project';</strong></span>

// The generateTag function is responsible for generating new tag 
// objects depending on the passed subject
<span class="strong"><strong>export function generateTag(subject) {</strong></span>
  if (<span class="strong"><strong>subject.type === TAG_TYPE_PROJECT</strong></span>) {
    // If we're dealing with a project here, we generate the 
    // according tag object
    const openTaskCount = subject.tasks.filter((task) =&gt; !task.done).length;
    <span class="strong"><strong>return new Tag(</strong></span>
<span class="strong"><strong>      `#${subject._id}`,</strong></span>
<span class="strong"><strong>      `${limitWithEllipsis(subject.title, 20)} (${openTaskCount} open tasks)`,</strong></span>
<span class="strong"><strong>      `#/projects/${subject._id}/tasks`,</strong></span>
<span class="strong"><strong>      TAG_TYPE_PROJECT</strong></span>
<span class="strong"><strong>    );</strong></span>
  }
<span class="strong"><strong>}</strong></span>
</pre></div><p>Let's examine the <code class="literal">generateTag</code> function and what we're trying to achieve here.</p><p>First, we determined the <a id="id289" class="indexterm"/>subject type by checking the type attribute of the <code class="literal">subject</code> object. In the case of project data objects, we know that the type will be set to <code class="literal">"project"</code>. The following three points succinctly explain what we've done:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Since we were sure that we were dealing with a project here, we generated a new tag. In the future, we'll deal with other subject types as well, so this check will be required.</li><li class="listitem">We wanted to use an indicator for all the open tasks in the tag title. For this reason, we did a quick filtering of open tasks within the project and stored the length of the filtered array in the <code class="literal">openTaskCount</code> constant.</li><li class="listitem">Now we can instantiate a new <code class="literal">Tag</code> object using the project ID as <code class="literal">textTag</code>. For the <code class="literal">title</code> field, we used a helper function, <code class="literal">limitWithElipsis</code>, which truncates project titles that are longer than 20 characters. We also appended the open tasks count to the tag title. For the <code class="literal">link</code> field of the <code class="literal">Tag</code> instance, we specify a URL that will navigate to the project details view. Finally, we used the <code class="literal">TAG_TYPE_PROJECT</code> constant to define the tag <code class="literal">type</code> field.</li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="Creating a tags service"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec44"/>Creating a tags service</h2></div></div></div><p>Okay, we're done with <a id="id290" class="indexterm"/>setting up all the supporting structures we need; we can now move forward to create a tags service. A tags service will have the following <a id="id291" class="indexterm"/>responsibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Generating and caching tags</strong></span>: We won't create tags in our system ad hoc if we only want to render them. The mechanics of a tags service is more like generated cache. Initially, a tags service gathers all the required information to generate all the possible tags within the system. It also reacts to changes and updates the list of tags if required. With this, we'll not only save on some processing needs, but we'll also have a readily available list to search for existing tags. This will be particularly useful if we like to present the available tags to the user so they can choose from them.</li><li class="listitem"><span class="strong"><strong>Rendering tags</strong></span>: A tags service is also responsible for turning tags into HTML. It uses the <code class="literal">title</code> and <code class="literal">link</code> fields of the <code class="literal">Tag</code> instances to generate their HTML representation.</li><li class="listitem"><span class="strong"><strong>Parsing text content</strong></span>: The parsing functionality of the tags service is responsible for finding text representations of tags within a string. It then uses the rendering function to render these tags into HTML.</li></ul></div><p>Let's create a module for our tags service in a new file under <code class="literal">tags/tags-service.js</code>.</p><p>First, we need to create two utility functions that will help us process tags and strings containing the textual representations of tags.</p><p>The <code class="literal">replaceAll</code> function is a simple substitute for a missing JavaScript function to replace multiple text occurrences within a string without using regular expressions:</p><div class="informalexample"><pre class="programlisting">// Utility function to replace all text occurrences in a string
function replaceAll(target, search, replacement) {
  return target.split(search).join(replacement);
}</pre></div><p>The <code class="literal">findTags</code> function will extract any possible tag from a text string. It does this by applying a regular expression that will find matches for tags in the format discussed at the beginning of the topic. This format assumes that our tags always start with a hash symbol, followed by any word character or dash symbols. This function returns a list of all the possible text tags:</p><div class="informalexample"><pre class="programlisting">// Function to find any tags within a string and return an array 
// of discovered tags
function findTags(str) {
  const result = [];
<span class="strong"><strong>  const regex = /#[\w\/-]+/g;</strong></span>
  let match;
<span class="strong"><strong>  while (match = regex.exec(str)) {</strong></span>
<span class="strong"><strong>    result.push(match[0]);</strong></span>
<span class="strong"><strong>  }</strong></span>
  return result;
}</pre></div><p>For our tags service, we will now define a new class that will be annotated with <code class="literal">@Injectable</code> so we can <a id="id292" class="indexterm"/>use it as a provider in our components:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Injectable()</strong></span>
export class TagsService {
...
}</pre></div><p>Let's look at the <a id="id293" class="indexterm"/>constructor of our <code class="literal">TagsService</code> class:</p><div class="informalexample"><pre class="programlisting">constructor(@Inject(ProjectService) projectService) {
  // If the available tags within the system changes, we will 
  // emit this event
<span class="strong"><strong>  this.change = new ReplaySubject(1);</strong></span>
  // In order to generate project tags, we're making use of the 
  // ProjectService
  this.projectService = projectService;
<span class="strong"><strong>  this.projectService.change.subscribe((projects) =&gt; {</strong></span>
    // On project changes we store the new project list and re-
    // initialize our tags
    this.projects = projects;
<span class="strong"><strong>    this.initializeTags();</strong></span>
<span class="strong"><strong>  });</strong></span>
}</pre></div><p>In order to generate and cache project tags, we obviously need <code class="literal">ProjectService</code>, which provides us with a list of all the projects. Instead of grabbing the list data from <code class="literal">ProjectService</code> once, we're observing the list for changes. This brings us the advantage that we'll not only get the initial list of projects, but we'll also be made aware of any changes made in the project list.</p><p>We subscribed to <code class="literal">ProjectService</code> using the <code class="literal">change</code> field. This exposes <code class="literal">ReplaySubject</code>, which emits the project list. After storing the current project list as a member field, we need to call the <code class="literal">initializeTags</code> method:</p><div class="informalexample"><pre class="programlisting">// This method is used internally to initialize all available tags
initializeTags() {
  // We're creating tags from all projects using the generateTag 
  // function
  <span class="strong"><strong>this.tags = this.projects.map(generateTag);</strong></span>
  // Since we've updated the list of available tags we need to 
  // emit a change event
<span class="strong"><strong>  this.change.next(this.tags);</strong></span>
}</pre></div><p>As we only support project tags currently, the only thing we need to consider while generating tags is the projects we have stored in our service. We can simply map the project list we have stored <a id="id294" class="indexterm"/>in the <code class="literal">projects</code> member field using our <code class="literal">generateTag</code> function. The <code class="literal">Array.prototype.map</code> function will return a new array <a id="id295" class="indexterm"/>that is already a list of generated tasks for the projects.</p></div><div class="section" title="Rendering tags"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>Rendering tags</h2></div></div></div><p>Okay, we now have a <a id="id296" class="indexterm"/>service that uses a reactive approach to generate tags from the available projects. This is already addressing the first concern of our service. Let's look at its other responsibilities, which are parsing text content for tags and rendering HTML.</p><p>Rendering tags is not a big deal since we have already abstracted the data model of tags in a clean way. We need to write a method for rendering tags that will act as a pass-through function if the argument is not a valid <code class="literal">Tag</code> instance. This way, we can pass unrecognized text representations of tags as strings, and it will just return us the string.</p><p>Since tags have URLs that point to a location, we're going to use anchor HTML elements to represent our tags. These elements also have classes that will help us style tags differently than regular content. Let's create another method within the tags service that can be used to render tag objects into HTML:</p><div class="informalexample"><pre class="programlisting">renderTag(tag) {
<span class="strong"><strong>  if (tag instanceof Tag) {</strong></span>
<span class="strong"><strong>    return `&lt;a class="tags__tag tags__tag--${tag.type}" href="${tag.link}"&gt;${tag.title}&lt;/a&gt;`;</strong></span>
<span class="strong"><strong>  } else {</strong></span>
<span class="strong"><strong>    return tag;</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The following method can be used to find a tag by its textual representation. This function will try to find the tag within our generated cache, and if unsuccessful, will return the <code class="literal">textTag</code> argument. This is also a pass-through mechanism that simplifies the handling when we parse a whole piece of text for tags:</p><div class="informalexample"><pre class="programlisting">// This method will lookup a tag via its text representation or 
// return the input argument if not found
parseTag(textTag) {
<span class="strong"><strong>     return this.tags.find(</strong></span>
<span class="strong"><strong>    (tag) =&gt; tag.textTag === textTag</strong></span>
<span class="strong"><strong>  ) || textTag;</strong></span>
}</pre></div><p>Last but not least, let's implement the main method of the service. The parse function scans the whole text for <a id="id297" class="indexterm"/>tags and replaces them with their HTML representation:</p><div class="informalexample"><pre class="programlisting">// This method takes some text input and replaces any found and 
// valid text representations of tags with the generated HTML 
// representation of those tags
parse(value) {
  // First we find all possible tags within the text
<span class="strong"><strong>  const tags = findTags(value);</strong></span>
  // For each found text tag, we're parsing and rendering them 
  // while replacing the text tag with the HTML representation 
  // if applicable
<span class="strong"><strong>  tags.forEach(</strong></span>
<span class="strong"><strong>    (tag) =&gt; value = replaceAll(value, tag, </strong></span>
<span class="strong"><strong>                          this.renderTag(this.parseTag(tag))));</strong></span>
<span class="strong"><strong>  );</strong></span>
  // After all tags have been rendered, we're using a sanitizer 
  // to ensure some basic security
<span class="strong"><strong>  return value;</strong></span>
}</pre></div><p>First, we need to use the <code class="literal">findTags</code> utility function; this will return a list of all the text tags that it would find in the string content passed to the <code class="literal">parse</code> function. Using this text tag list, we can then iterate through the list and successively replace all the text tags in the content with the generated HTML using the <code class="literal">renderTag</code> method.</p></div><div class="section" title="Integrating the task service"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>Integrating the task service</h2></div></div></div><p>All the concerns of our <a id="id298" class="indexterm"/>task service have now been taken care of, and it is already storing tags for the available projects. We can now go ahead and integrate our service into the application.</p><p>Since our tags service turns text with simple hash tags into HTML with links, a pipe would be a perfect helper to integrate the functionality within our components.</p><p>Let's create a <code class="literal">tags.js</code> file in our <code class="literal">pipes</code> folder and create a new pipe class, namely, <code class="literal">Tags</code>:</p><div class="informalexample"><pre class="programlisting">import {Pipe, Inject} from '@angular/core';
<span class="strong"><strong>import {TagsService} from '../tags/tags-service';</strong></span>

@Pipe({
  name: 'tags',
  // Since our pipe is depending on services, we're dealing with a 
  // stateful pipe and therefore set the pure flag to false
<span class="strong"><strong>  pure: false</strong></span>
})
export class TagsPipe {
  constructor(<span class="strong"><strong>@Inject(TagsService) tagsService</strong></span>) {
<span class="strong"><strong>    this.tagsService = tagsService;</strong></span>
  }
  // The transform method will be called when the pipe is used within a template
  transform(value) {
    if (typeof value !== 'string') {
      return value;
    }
    // The pipe is using the TagsService to parse the entire text
<span class="strong"><strong>    return this.tagsService.parse(value);</strong></span>
  }
}</pre></div><p>We have already created a <a id="id299" class="indexterm"/>few pipes so far. However, this pipe is a bit different in that it isn't a pure pipe. Pipes are considered pure if their transform function always returns the same output for a given input. This implies that the transform function should not be dependent on any other external source that can influence the outcome of the transform, and the only dependencies are the input values. This is not true for our <code class="literal">Tags</code> pipe though. It depends on <code class="literal">TagsService</code> to transform the input, and new tags can be stored in the tags service at any time. Successive transformations can successfully render tags that were not existent just a moment ago.</p><p>By telling Angular that our pipe is not pure, we can disable the optimization it performs on pure pipes. This also means that Angular will need to revalidate the output of the pipe on every change detection. This can lead to performance issues; therefore, the pure flag should be used with caution.</p><p>All right, as far as rendering tags is concerned, we are all set. Let's integrate our tags functionality into our <code class="literal">Editor</code> component so we can make use of them within the commenting system.</p><p>Let's start by editing the <code class="literal">Editor</code> module located under <code class="literal">ui/editor/editor.js</code>:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {TagsPipe} from '../../pipes/tags';</strong></span>

@Component({
  selector: 'ngc-editor',
  ...
<span class="strong"><strong>  pipes: [TagsPipe]</strong></span>
})
export class Editor {
  ...
<span class="strong"><strong>  @Input() enableTags;</strong></span>
  ...
}</pre></div><p>First, we imported the <code class="literal">TagsPipe</code> class and referenced it to the <code class="literal">pipes</code> configuration of the <code class="literal">@Component</code> annotation.</p><p>We've also added a new input to the <code class="literal">enableTags</code> component, which will allow us to control whether we should handle tags within the content of the editor or ignore them.</p><p>That's it, as far as changes to the component file is concerned. Let's apply some changes to the template of the component by editing the <code class="literal">ui/editor/editor.html</code> file:</p><div class="informalexample"><pre class="programlisting">...
&lt;div <span class="strong"><strong>*ngIf="enableTags" </strong></span>class="editor__output" 
<span class="strong"><strong>     [innerHtml]="(content || '-') | tags"</strong></span>&gt;&lt;/div&gt;
&lt;div <span class="strong"><strong>*ngIf="!enableTags"</strong></span> class="editor__output"&gt;
  {{content || '-'}}
&lt;/div&gt;
...</pre></div><p>The only change we've <a id="id300" class="indexterm"/>made in the template is where we display the editor content. We've used two template elements by employing the <code class="literal">NgIf</code> asterisk template syntax. The latter one, if tags are disabled, renders the content as before. If tags are enabled, we'll be using a property binding to the <code class="literal">innerHTML</code> property of our editor's output HTML element. This allows us to render the HTML content. In the binding, we've used our <code class="literal">Tags</code> pipe that will parse the content for tags using <code class="literal">TagService</code>.</p></div><div class="section" title="Completion of the tags service"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>Completion of the tags service</h2></div></div></div><p>Let's digress for a <a id="id301" class="indexterm"/>moment at this point. We've already created a tagging system, and we just integrated it into our <code class="literal">Editor</code> component by using the <a id="id302" class="indexterm"/>
<code class="literal">Tags</code> pipe. If a user writes project tags in any comment now, they will be rendered by <code class="literal">TagsService</code>. This is fantastic! Users can now establish cross-links to other projects within comments, which will be automatically rendered as links showing the project title and open tasks. All a user needs to do is add the text representations of project tags to a comment. In the default data set of the book, this could be the <code class="literal">#project-1</code> string.</p><p>The following two images show you an example of the commenting system. The first image is an example of an editor in edit mode, under the commenting system, where a text tag is entered:</p><div class="mediaobject"><img src="../Images/image00329.jpeg" alt="Completion of the tags service"/><div class="caption"><p>An example where a text tag is entered</p></div></div><p style="clear:both; height: 1em;"> </p><p>The second image is an <a id="id303" class="indexterm"/>example of a rendered tag enabled in <a id="id304" class="indexterm"/>the commenting system through our editor integration:</p><div class="mediaobject"><img src="../Images/image00330.jpeg" alt="Completion of the tags service"/><div class="caption"><p>An example of rendered tag through editor integration</p></div></div><p style="clear:both; height: 1em;"> </p><p>We're not done yet when it comes to entering tags. We cannot expect our users to know all the available tags within the system and then enter them manually within comments. Let's look at how we can improve this in the next section:</p><p>In this section, we looked at the following concepts:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We built a tags service that generates, caches, and renders tags.</li><li class="listitem">We built a stateful pipe using the <code class="literal">pure</code> flag.</li><li class="listitem">We used the <code class="literal">[innerHTML]</code> property binding to render HTML content into an element.</li></ol><div style="height:10px; width: 1px"/></div></div></div></div>
<div class="section" title="Supporting tag input"><div class="titlepage" id="aid-1FLS42"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Supporting tag input</h1></div></div></div><p>Here, we're going to build a <a id="id305" class="indexterm"/>component and its supporting structures to make the process of entering tags a smooth experience for our users. So far, they can write project tags, but it requires them to know the project IDs, which makes our tag management quite useless. What we'd like to do is provide the user with some choices when they are about to write a tag. Ideally, we show them the available tags, as soon as they start writing a tag by typing the hash (<span class="emphasis"><em>#</em></span>) symbol.</p><p>What sounds simple in the first place is actually quite a tricky thing to implement. Our tag input needs to deal with the following challenges:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Handling input events to monitor tag creation. Somehow, we need to know when a user starts writing a tag, and we need to know when the typed tag name is updated or <a id="id306" class="indexterm"/>canceled by using an invalid tag character.</li><li class="listitem">Calculating the position of the input caret of the user. Yeah, I know this sounds pretty simple, but it actually isn't. Calculating the viewport offset position of a user's input caret requires the use of the browser's Selection API, which is quite low-level and needs some abstraction.</li></ul></div><p>In order to tackle these challenges, we are going to introduce a utility class we can delegate the user input to. It will help us figure out the details we're interested in and deal with low-level APIs.</p><div class="section" title="Creating a tag input manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>Creating a tag input manager</h2></div></div></div><p>Create a module in a <a id="id307" class="indexterm"/>new file under <code class="literal">tags/tag-input-manager.js</code>. The first bit of code is a function that will help us figure out the position of the user input caret when the user starts typing a tag:</p><div class="informalexample"><pre class="programlisting">// This function can be used to find the screen coordinates of the 
// input cursor position
function getRangeBoundlingClientRect() {
  const selection = window.getSelection();
  if (!selection.rangeCount) return;

  const range = selection.getRangeAt(0);

  if (!range.collapsed) {
    return range.getBoundingClientRect();
  }

  const dummy = document.createElement('span');
  range.insertNode(dummy);
  const pos = dummy.getBoundingClientRect();
  dummy.parentNode.removeChild(dummy);
  return pos;
}</pre></div><p>Let's not go into too much detail here. What this code basically does is that it tries to find the bounding box <code class="literal">DOMRect</code> object, which describes the <code class="literal">top</code>, <code class="literal">right</code>, <code class="literal">bottom</code>, and <code class="literal">left</code> offsets of the caret position relative to the viewport. The problem is that the Selection API does not allow us to get the position of the caret directly; it only allows us to get the position of the current selection. In case the caret is not placed correctly, we will need to insert a dummy element at the location of the caret and return the bounding box <code class="literal">DOMRect</code> object of the dummy element. Of course, we'd need to remove the dummy element again before we return the <code class="literal">DOMRect</code> object.</p><p>Now let's create a new <a id="id308" class="indexterm"/>class, <code class="literal">TagInputManager</code>, under <code class="literal">lib/tags/tag-input-manager.js</code>, which will deal with the user input handling for tag creation:</p><div class="informalexample"><pre class="programlisting">export class TagInputManager {
  constructor() {
    this.reset();
  }
  ...</pre></div><p>In the constructor, we need to call an internal <code class="literal">reset</code> method. This <code class="literal">reset</code> method will reset the two member fields that <code class="literal">TagInputManager</code> will expose. The <code class="literal">position</code> member will store the position of the latest caret, where the user had started writing a tag. The <code class="literal">textTag</code> member will store the current tag, which is recognized by <code class="literal">TagInputManager</code>:</p><div class="informalexample"><pre class="programlisting">reset() {
  this.textTag = '';
  this.position = null;
}</pre></div><p>Now let's create a method to determine if a user is in the progress of entering a tag. If the <code class="literal">textTag</code> member contains a hash symbol at the beginning, we can assume that there is a tag entering in progress:</p><div class="informalexample"><pre class="programlisting">hasTextTag() {
  return this.textTag[0] === '#';
}</pre></div><p>We also need a method that will allow us to update both the current text tag, which is entered, as well as the updated caret position:</p><div class="informalexample"><pre class="programlisting">updateTextTag(textTag, position = this.position) {
  this.textTag = textTag;
  this.position = position;
}</pre></div><p>Within the <code class="literal">onKeyDown</code> method, we expect to receive delegated <code class="literal">keydown</code> events. We are concerned about the backspace, which should also remove the last character of the tag that is currently entered.</p><div class="informalexample"><pre class="programlisting">onKeyDown(event) {
  // If we receive a backspace (key code is 8), we need to 
  // remove the last character from the text tag
  if (event.which === 8 &amp;&amp; this.hasTextTag()) {
    this.updateTextTag(this.textTag.slice(0, -1));
  }
}</pre></div><p>In the <code class="literal">onKeyPress</code> method, we expect to receive delegated key press events. This is where the main logic of this supporting class lies. Here, we handle two different cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">If the pressed key is a hash symbol, we will start over with a new tag.</li><li class="listitem">If the pressed key is <a id="id309" class="indexterm"/>not a valid word character or a hash symbol, we will reset it to its initial state, which will cancel the tag entry. Otherwise, it'd mean that we are dealing with a valid tag character, and we'll add it to the current text tag string.</li></ul></div><p>The code for this is as follows:</p><div class="informalexample"><pre class="programlisting">onKeyPress(event) {
  const char = String.fromCharCode(event.which);
  if (char === '#') {
    // If the current character from user input is a hash symbol 
    // we can initiate a new text tag and set the current 
    // position
    this.updateTextTag('#', getRangeBoundlingClientRect());
  } else if ((/[\w-]/i).test(this.textTag[0])) {
    // If the current character is not a valid tag character we 
    // reset our state and assume the tag entry was canceled
    this.reset();
  } else if (this.hasTextTag()) {
    // If we have any other valid tag character input, we're 
    // updating our text tag
    this.updateTextTag(this.textTag + char);
  }
}</pre></div><p>Okay, so now we have all the support we need to handle tag input. However, we still need a way to show the available tags from <code class="literal">TagsService</code> to the user. For this purpose, we'll create a new <code class="literal">TagsSelect</code> component.</p></div><div class="section" title="Creating a tags select component"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Creating a tags select component</h2></div></div></div><p>To support the user in <a id="id310" class="indexterm"/>finding the right tag, we'll provide <a id="id311" class="indexterm"/>them with a dropdown with the available tags. To do this, we need to use our <code class="literal">TagInputManager</code> class to recognize tags within user input as well as filter the available tags with user input. Let's briefly look at the requirements of this component:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Display the available tags gathered from <code class="literal">TagsService</code> in a tooltip/callout box</li><li class="listitem">It should support a limitation of displayed tags</li><li class="listitem">It should support an input to filter the available tags</li><li class="listitem">The component should accept an input parameter to position the callout box</li><li class="listitem">It should emit an event once the user clicks on a tag in the listed tags</li><li class="listitem">The component should hide itself if the filter is invalid or if there are no elements <a id="id312" class="indexterm"/>matching the filter:<div class="mediaobject"><img src="../Images/image00331.jpeg" alt="Creating a tags select component"/><div class="caption"><p>Finished tags select component filtered with user input</p></div></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>Let's start with the component class and see how we fulfill these requirements. First, create a new file called <a id="id313" class="indexterm"/>
<code class="literal">tags-select.js</code> under <code class="literal">tags/tags-select</code>:</p><div class="informalexample"><pre class="programlisting">...
@Component({
  selector: 'ngc-tags-select',
  ...
})
export class TagsSelect {
  ...
}</pre></div><p>We have no specialties to deal with in our <code class="literal">@Component</code> annotation. Let's start with implementing the innards of our component. First, we'll define the following input in the component:</p><div class="informalexample"><pre class="programlisting">@Input() filter;</pre></div><p>Using the <code class="literal">filter</code> input, we can pass a filter tag to the <code class="literal">TagsSelect</code> component. This means that we'll use the <code class="literal">filter</code> input to filter the available tags by <code class="literal">title</code> and <code class="literal">text</code> tags.</p><p>The <code class="literal">limit</code> input can be set to any number. This input is used to limit the number of filtered tags that could be displayed within the component:</p><div class="informalexample"><pre class="programlisting">@Input() limit;</pre></div><p>The <code class="literal">position</code> input should be set to a valid <code class="literal">DOMRect</code> object that contains the top and left properties. They will be used to position our component:</p><div class="informalexample"><pre class="programlisting">@Input() position;</pre></div><p>The <code class="literal">tagSelected</code> output <a id="id314" class="indexterm"/>property is used to emit an event <a id="id315" class="indexterm"/>once the user has clicked on a tag within the list of tags:</p><div class="informalexample"><pre class="programlisting">@Output() tagSelected = new EventEmitter();</pre></div><p>The following accessor property is bound to the host element's display style property. It will control whether the component is displayed or hidden. We only display the component if the filter is valid and the filtered tags contain at least one tag:</p><div class="informalexample"><pre class="programlisting">@HostBinding('style.display')
get isVisible() {
  if (<span class="strong"><strong>this.filter[0] === '#' &amp;&amp; this.filteredTags.length &gt; 0</strong></span>) {
    return 'block';
  } else {
    return 'none';
  }
}</pre></div><p>The following two accessor properties use host bindings to set the <code class="literal">top</code> and <code class="literal">left</code> styles of our host element based on the <code class="literal">position</code> input of the component:</p><div class="informalexample"><pre class="programlisting">@HostBinding('style.top')
get topPosition() {
  return this.position ? `${this.position.top}px` : 0;
}

@HostBinding('style.left')
get leftPosition() {
  return this.position ? `${this.position.left}px` : 0;
}</pre></div><p>Let's inject <code class="literal">TagsService</code> into our component so we can access the list of available tags:</p><div class="informalexample"><pre class="programlisting">constructor(@Inject(TagsService) tagsService) {
  this.tagsService = tagsService;
  // This member is storing the filtered tag list
  this.filteredTags = [];
  this.filter = '';
}</pre></div><p>We need to use the <code class="literal">OnInit</code> life cycle hook to set up a subscription to the <code class="literal">TagService</code> change observable. This way, we'll get access to the initial list of tags as well as any changes in the list. After we receive a new list of tags, we will need to reapply the filtering:</p><div class="informalexample"><pre class="programlisting">ngOnInit() {
  // The TagsService is providing us with all available tags 
  // within the application
  <span class="strong"><strong>this.tagsSubscription = this.tagsService.change.subscribe(</strong></span>
    (tags) =&gt; {
      // If the available tags change we store the new list and 
      // execute filtering again
      this.tags = tags;
<span class="strong"><strong>      this.filterTags();</strong></span>
    }
  <span class="strong"><strong>);</strong></span>
}</pre></div><p>The following is the <a id="id316" class="indexterm"/>method that will be called from the <a id="id317" class="indexterm"/>template if a tag is clicked. We'll just re-emit that tag using the <code class="literal">tagSelected</code> output:</p><div class="informalexample"><pre class="programlisting">onTagClick(tag) {
<span class="strong"><strong>  this.tagSelected.next(tag);</strong></span>
}</pre></div><p>The <code class="literal">filterTags</code> method is responsible for filtering and limiting our tag list based on the filter and limit input properties and the available tags from <code class="literal">TagsService</code>. As a result, it will store the filtered and limited list in the <code class="literal">filteredTags</code> member field:</p><div class="informalexample"><pre class="programlisting">filterTags() {
  this.filteredTags = this.tags
    .filter((tag) =&gt; {
      <span class="strong"><strong>return tag.textTag.indexOf(this.filter.slice(1)) !== -1 ||</strong></span>
<span class="strong"><strong>             tag.title.indexOf(this.filter.slice(1)) !== -1;</strong></span>
    })
    <span class="strong"><strong>.slice(0, this.limit);</strong></span>
}</pre></div><p>If the input properties filter or limit changes, we will need to reapply our filtering method. By implementing the <code class="literal">ngOnChanges</code> life cycle hook, we can easily manage this requirement:</p><div class="informalexample"><pre class="programlisting">ngOnChanges(changes) {
  // If the filter or the limit input changes, we're filtering the 
  // available tags again
<span class="strong"><strong>  if (this.tags &amp;&amp; (changes.filter || changes.limit)) {</strong></span>
<span class="strong"><strong>    this.filterTags();</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Finally, we should unsubscribe from the <code class="literal">TagsService</code> change observable if the <code class="literal">TagsSelect</code> component is destroyed:</p><div class="informalexample"><pre class="programlisting">ngOnDestroy() {
  this.tagsSubscription.unsubscribe();
}</pre></div><p>The template for our <a id="id318" class="indexterm"/>component is rather simple. Let's <a id="id319" class="indexterm"/>look at the view template that is stored under <code class="literal">tags/tags-select/tags-select.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="tags-select__list"&gt;
  &lt;li <span class="strong"><strong>*ngFor="let tag of filteredTags"</strong></span>
<span class="strong"><strong>      (click)="onTagClick(tag)"</strong></span>
      class="tags-select__item"&gt;<span class="strong"><strong>{{tag.title}}</strong></span>&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>We used the <code class="literal">NgFor</code> directive to iterate over all the tags within the <code class="literal">filteredTags</code> member. If a tag is clicked, we will need to execute the <code class="literal">onTagClicked</code> method and pass the tag of the current iteration. In the listing, we'll only display the tag title that should help the user identify the tag they would like to use.</p><p>Now we have built all the pieces that we need to enable smooth tag entering for our users. Let's patch our <code class="literal">Editor</code> component again to include our changes.</p></div><div class="section" title="Integrating tag input within the editor component"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>Integrating tag input within the editor component</h2></div></div></div><p>As the first step, we <a id="id320" class="indexterm"/>should amend our <code class="literal">Editor</code> <a id="id321" class="indexterm"/>component to utilize the <code class="literal">TagInputManager</code> class. We need to delegate the user input inside the content-editable element to the tag input manager so it can detect any tag entering. Then, we'll use the information from <code class="literal">TagInputManager</code> to control a <code class="literal">TagsSelector</code> component.</p><p>First, let's look at the required changes to be made inside the <code class="literal">Component</code> class located under <code class="literal">ui/editor/editor.js</code>:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {TagsSelect} from '../../tags/tags-select/tags-select';</strong></span>
<span class="strong"><strong>import {TagInputManager} from '../../tags/tag-input-manager';</strong></span>

@Component({
  selector: 'ngc-editor',
  ...
<span class="strong"><strong>  directives: [TagsSelect]</strong></span>
})
export class Editor {
  ...
    // We're using a TagInputManager to help us dealing with tag 
    // creation
<span class="strong"><strong>    this.tagInputManager = new TagInputManager();</strong></span>
  }
  ...
  // This method is called when the editable element receives a 
  // keydown event
  onKeyDown(event) {
    // We're delegating the keydown event to the TagInputManager
<span class="strong"><strong>    this.tagInputManager.onKeyDown(event);</strong></span>
  }

  // This method is called when the editable element receives a 
  // keypress event
  onKeyPress(event) {
    // We're delegating the keypress event to the TagInputManager
<span class="strong"><strong>    this.tagInputManager.onKeyPress(event);</strong></span>
  }

  // This method is called if the child TagSelect component is 
  // emitting an event for a selected tag
  onTagSelected(tag) {
    // We replace the partial text tag within the editor with the 
    // text representation of the tag that was selected in the 
    // TagSelect component.
<span class="strong"><strong>    this.setEditableContent(</strong></span>
<span class="strong"><strong>      this.getEditableContent().replace(</strong></span>
<span class="strong"><strong>        this.tagInputManager.textTag, tag.textTag</strong></span>
<span class="strong"><strong>      )</strong></span>
<span class="strong"><strong>    );</strong></span>
<span class="strong"><strong>    this.tagInputManager.reset();</strong></span>
  }
  ...
}</pre></div><p>In our <code class="literal">@Component</code> <a id="id322" class="indexterm"/>annotation, we added the <code class="literal">TagsSelect </code>component to the directives property so we could use the component <a id="id323" class="indexterm"/>within the template.</p><p>To help us do all the low-level processing for tag entry, we used <code class="literal">TagInputManager</code> and created a new instance of it within the component constructor.</p><p>We have now created two methods for handling <code class="literal">keypress</code> and <code class="literal">keydown</code> events coming from our content-editable element. These methods delegate the events to <code class="literal">TagInputManager</code>, which will handle all of the processing to extract a text tag and the position of the caret.</p><p>Finally, we added a method that will be called once a tag is clicked within the <code class="literal">TagsSelect</code> component. Here, we simply replaced the text tag that is currently entered with the text representation of the tag that was clicked. This provides a naive implementation of some sort of autocomplete. After we added the text representation of the clicked tag to the <a id="id324" class="indexterm"/>content-editable element, we reset <code class="literal">TagInputManager</code> to clear its state.</p><p>The only bit left now <a id="id325" class="indexterm"/>is to to edit the template of the <code class="literal">Editor</code> component in order to include the <code class="literal">TagsSelect</code> component.</p><p>In the <code class="literal">ui/editor/editor.html</code> file, we need to make the following changes:</p><div class="informalexample"><pre class="programlisting">...
&lt;ngc-tags-select <span class="strong"><strong>*ngIf="enableTags"</strong></span>
<span class="strong"><strong>                 [filter]="tagInputManager.textTag"</strong></span>
<span class="strong"><strong>                 [position]="tagInputManager.position"</strong></span>
<span class="strong"><strong>                 [limit]="5"</strong></span>
<span class="strong"><strong>                 (tagSelected)="onTagSelected($event)"</strong></span>&gt;
&lt;/ngc-tags-select&gt;</pre></div><p>The <code class="literal">NgIf</code> directive helps us avoid the component from being created if tags are not enabled within the editor.</p><p>We set the <code class="literal">filter</code> and <code class="literal">position</code> input of the <code class="literal">TagsSelect</code> component from the data we have in our <code class="literal">TagInputManager</code> instance.</p><p>On the emitted <code class="literal">tagSelected</code> event of the <code class="literal">TagsSelect</code> component, we called the <code class="literal">onTagSelected</code> method on the <code class="literal">Editor</code> component we created a moment ago.</p><p>That's all we need to do with the template of the <code class="literal">Editor</code> component.</p></div><div class="section" title="Finishing up our tagging system"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec51"/>Finishing up our tagging system</h2></div></div></div><p>Congratulations! You've <a id="id326" class="indexterm"/>now successfully implemented the first of the three usability components.</p><p>With the help of a <code class="literal">TagInputManager</code> class, we offloaded heavy low-level handling of user input and the processing of the user caret position. Then, we created a component to display the available tags to the user and provided a way for them to select a tag by clicking on it. In our <code class="literal">Editor</code> component, we used the <code class="literal">TagInputManager</code> class together with the <code class="literal">TagsSelect</code> component to enable the smooth entering of tags while editing comments and other areas where we've enabled tagging.</p><p>We've covered the following concepts in this section:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We processed complex user input within a designated manager class to offload logic from our components.</li><li class="listitem">We used host bindings to set positional style attributes.</li><li class="listitem">We implemented fully reactive components that rely on observables and don't create <a id="id327" class="indexterm"/>side effects during change detection.</li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Drag and drop"><div class="titlepage" id="aid-1GKCM2"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Drag and drop</h1></div></div></div><p>We have learned to <a id="id328" class="indexterm"/>use our computer mouse and keyboard with great efficiency. Using keyboard shortcuts, different click actions and contextual mouse menus support us nicely when performing tasks. However, there is one pattern that has gained more attention again in applications lately, given the current mobile and touch devices hype. Drag and drop actions are a very intuitive and logical way to express actions such as moving or copying items. One task performed on user interfaces benefits from drag and drop particularly, which is ordering items within a list. If we need to order items via action menus, it gets very confusing. Moving items step by step using the up and down buttons works great, but it takes a lot of time. If you can drag items around and drop them in a place where you'd like them to be reordered, you can sort a list of items extremely fast.</p><p>In this topic, we will build the required elements to enable drag and drop selectively. We will use the drag and drop feature to enable users to reorder their task lists. By developing reusable directives to provide this functionality, we can enable the feature at any other spot within our application later on.</p><p>To implement our directives, we will make use of the HTML5 drag and drop API, which is supported in all the major browsers at the time of writing this book.</p><p>Since we would like to reuse our drag and drop behavior on multiple components, we will use directives for the implementation. We are going to create two directives in this section:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Draggable directive</strong></span>: This directive should be attached to components, which should be enabled for dragging</li><li class="listitem"><span class="strong"><strong>Draggable drop zone directive</strong></span>: This directive should be attached to components that will act as a drop target</li></ul></div><p>We'll also implement a feature where we can be selective about what can be dragged where. For this, we will use a type attribute on our draggable directives as well an accepted type attribute on our drop zones.</p><div class="section" title="Implementing the draggable directive"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec52"/>Implementing the draggable directive</h2></div></div></div><p>The <code class="literal">draggable</code> <a id="id329" class="indexterm"/>directive will be attached to the <a id="id330" class="indexterm"/>element that can be dragged onto other elements. Let's get started with creating a new directive class under <code class="literal">draggable/draggable.js</code>:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>@Directive</strong></span>({
  selector: '[draggable]',
  host: {
    class: 'draggable',
    // Additionally to the class we also need to set the HTML 
    // attribute draggable to enable draggable browser behavior
<span class="strong"><strong>    draggable: 'true'</strong></span>
  }
})
export class Draggable {
  ...
}</pre></div><p>Instead of using the <code class="literal">@Component</code> annotation, we've now used the <code class="literal">@Directive</code> annotation to let Angular know that the following class is a directive class. By setting the HTML attribute <code class="literal">draggable</code> to <code class="literal">true</code>, we tell the browser that we're considering this element a draggable element.</p><div class="note" title="Note"><h3 class="title"><a id="tip15"/>Tip</h3><p>The big difference of using directives in comparison to components is that they don't embrace a view but only behavior. Therefore, it's also possible to use many directives on the same element, which is not possible with components.</p></div><p>Let's look at the input for our newly created component class:</p><div class="informalexample"><pre class="programlisting">@Input() draggableData;</pre></div><p>The <code class="literal">draggableData</code> input is used to specify the data that represents the element which can be dragged. This data will be serialized to JSON and transferred to our drop zones once a drag action is completed.</p><p>By specifying a draggable type, we can be more selective when the element is dragged over a drop zone. Within the drop zone, we can have a counterpart that controls what types are acceptable to be dropped.</p><div class="informalexample"><pre class="programlisting">@Input() draggableType;</pre></div><p>Additionally to our input, we also want to use a host binding to set a special class if the element is currently dragged:</p><div class="informalexample"><pre class="programlisting">@HostBinding('class.draggable--dragging') dragging;</pre></div><p>This binding will set a <code class="literal">draggable--dragging</code> class, which will apply some special styles that will make it easy to recognize that an element is dragged.</p><p>Now we need to handle two events within our directive to implement the behavior of a draggable element. The following DOM events are triggered by the drag and drop DOM API:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">dragstart</code>: This <a id="id331" class="indexterm"/>event is emitted on elements that are grabbed and moved across the screen</li><li class="listitem"><code class="literal">dragend</code>: If the <a id="id332" class="indexterm"/>previously initiated dragging of the element is ended, because of a successful drop or a release outside of a valid drop target, this DOM event will be triggered.</li></ul></div><p>Let's look at the implementation of <code class="literal">HostListener</code> for the <code class="literal">dragstart</code> event:</p><div class="informalexample"><pre class="programlisting">// We're listening for the dragstart event and initialize the 
// dataTransfer object
<span class="strong"><strong>@HostListener('dragstart', ['$event'])</strong></span>
onDragStart(event) {
  <span class="strong"><strong>event.dataTransfer.effectAllowed = 'move';</strong></span>
  // Serialize our data to JSON and set it on our dataTransfer 
  // object
<span class="strong"><strong>  event.dataTransfer.setData(</strong></span>
<span class="strong"><strong>    'application/json', </strong></span>
<span class="strong"><strong>    JSON.stringify(this.draggableData));</strong></span>
  // By adding the draggableType as a data type key within our 
  // The dataTransfer object, we enable drop zones to observe the type 
  // before receiving the actual drop.
  <span class="strong"><strong>event.dataTransfer.setData(</strong></span>

<span class="strong"><strong>    `draggable-type:${this.draggableType}`, '');</strong></span>
<span class="strong"><strong>  this.dragging = true;</strong></span>
}</pre></div><p>Now let's discuss the different actions we will perform in the implementation of our host listener:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will need to access the DOM event object in our host listener. If we were to create this binding within the template, we would probably need to write something similar to this: <code class="literal">(dragstart)="onDragStart($event)"</code>. Within event bindings, we can make use of the synthetic variable <code class="literal">$event</code>, which is a reference to the event that would have triggered the event binding. If we were to create an event binding on our host element using the <code class="literal">@HostListener</code> annotation, we would need to construct the parameter list for the binding using the second argument of the decorator.</li><li class="listitem">The first action in our event listener is to set the desired <code class="literal">effectAllowed</code> property on the <code class="literal">dataTransfer</code> object. Currently, we only support the <code class="literal">move</code> effect as our main concern is to reorder tasks within the task list using drag and drop. The drag and drop API is very system-specific, but usually there are different drag effects if a user holds a modifier key (such as <span class="emphasis"><em>Ctrl</em></span> or <span class="emphasis"><em>Shift</em></span>) while initiating <a id="id333" class="indexterm"/>the dragging. Within our <code class="literal">draggable</code> directive, we can force the <code class="literal">move</code> effect for all drag actions.</li><li class="listitem">In the next code snippet, we will set the data that should be transferred by dragging. It's <a id="id334" class="indexterm"/>important to understand the core purpose of the drag and drop API. It does not only provide a way to implement drag and drop for elements solely in your DOM, but it also supports the dragging of files and other objects into your browser. Because of this, the API undergoes some constraints, where one of them is making it impossible to transfer data other than simple string values. In order for us to transfer complex objects, we will serialize the data from the <code class="literal">draggableData</code> input using <code class="literal">JSON.stringify</code>.</li><li class="listitem">Another limitation caused by some security constraints within the API is that data can only be read after a successful drop. This means that we cannot inspect the data if the user is just hovering over an element. However, we need to know some facts about the data when hovering drop zones. We need to know the type of the draggable element when entering a drop zone so we can make the drop zone signal if the type is accepted. We're using a small workaround for this issue. The drag and drop API hides the data when we drag data over a drop target. However, it tells us what type of data it is. Knowing this fact, we can use the <code class="literal">setData</code> function to encode our draggable type. Accessing the data keys only is considered secure and therefore can be done in all drop zone events.</li><li class="listitem">Finally, we'll set the dragging flag to <code class="literal">true</code>, which will cause the class binding to revalidate and add the <code class="literal">draggable--dragging</code> class to the element.</li></ol><div style="height:10px; width: 1px"/></div><p>After dealing with the <code class="literal">dragstart</code> event, we only need to handle the <code class="literal">dragend</code> event to complete our <code class="literal">Draggable</code> directive. The only thing we do within the <code class="literal">onDragEnd</code> method that is bound to the <code class="literal">dragend</code> event is set the dragging member to false. This will cause the <code class="literal">draggable--dragging</code> class to be removed from the host element:</p><div class="informalexample"><pre class="programlisting">@HostListener('dragend')
onDragEnd() {
<span class="strong"><strong>  this.dragging = false;</strong></span>
}</pre></div><p>That's it for the behavior of our <code class="literal">Draggable</code> directive. Now we need to create its counterpart directive to <a id="id335" class="indexterm"/>provide the behavior of a drop zone.</p></div><div class="section" title="Implementing a drop target directive"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec53"/>Implementing a drop target directive</h2></div></div></div><p>Drop zones <a id="id336" class="indexterm"/>will act as containers where <a id="id337" class="indexterm"/>draggable elements can be dropped. For this, we'll create a new directive called <code class="literal">DraggableDropZone</code> under <code class="literal">draggable/draggable-drop-zone.js</code>:</p><div class="informalexample"><pre class="programlisting">@Directive({
  selector: '[draggableDropZone]'
})
export class DraggableDropZone {
  ...
}</pre></div><p>There's nothing special about this <code class="literal">@Directive</code> annotation. We used an attribute selector so it can be attached using a <code class="literal">draggableDropZone</code> attribute on any HTML element. Using the following input, we can specify what types of draggable elements we accept in this drop zone. This will help the user identify whether they are able to drop off the draggable elements when approaching the drop zone:</p><div class="informalexample"><pre class="programlisting">@Input() dropAcceptType;</pre></div><p>Upon successful drops into the drop zone, we will need to emit an event so that the components using our drag and drop functionality can react accordingly. For this purpose, let's create a <code class="literal">dropDraggable</code> output property:</p><div class="informalexample"><pre class="programlisting">@Output() dropDraggable = new EventEmitter();</pre></div><p>The <code class="literal">over</code> member field will store the state if an accepted element is in the process of being dragged over the drop zone:</p><div class="informalexample"><pre class="programlisting">@HostBinding('class.draggable--over') over;</pre></div><p>The following method will be used to check whether our drop zone should accept any given drag and drop event by checking against our <code class="literal">dropAcceptType</code> member. If you remember the security problems we needed to work around with when creating the <code class="literal">Draggable</code> directive, you will understand why this determination is rather simple:</p><div class="informalexample"><pre class="programlisting">typeIsAccepted(event) {
  <span class="strong"><strong>const draggableType = </strong></span>
<span class="strong"><strong>      Array.from(event.dataTransfer.types).find(</strong></span>
<span class="strong"><strong>        (key) =&gt; key.indexOf('draggable-type') === 0</strong></span>
<span class="strong"><strong>      );</strong></span>
<span class="strong"><strong>  return draggableType &amp;&amp; </strong></span>
<span class="strong"><strong>         draggableType.split(':')[1] === this.dropAcceptType;</strong></span>
}</pre></div><p>We can only read the types of the data within <code class="literal">dataTransfer</code> objects for certain events, where the data itself is hidden until a successful <code class="literal">drop</code> event is occurred. To bypass this security limitation, we've encoded the draggable type information into a data key itself. Since we can list all the data types safely, it's not too hard to extract the encoded draggable type information. We will search for a data type key that starts with <code class="literal">"draggable-type"</code> and then split it by the column character. The value after the column character is our type information, which we will then compare against the <code class="literal">dropAcceptType</code> directive input property.</p><p>We will use two <a id="id338" class="indexterm"/>events to determine whether a <a id="id339" class="indexterm"/>draggable element is moved to our drop zone:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">dragenter</code>: This is fired by an element if another element is dragged over it</li><li class="listitem"><code class="literal">dragleave</code>: This is fired by an element if the previously entered element has left again</li></ul></div><p>There's one problem with the preceding events, which is that they actually bubble, and we will receive a <code class="literal">dragleave</code> event if the dragged element is moved to a child element within our drop zone. Because of the bubbling, we then also receive <code class="literal">dragenter</code> and <code class="literal">dragleave</code> events from the child elements. This is not desired in our case, and we need to build some functionality to improve this behavior. We will make use of a counter member field <code class="literal">dragEnterCount</code>, which will count up to all the <code class="literal">dragenter</code> events and count down to <code class="literal">dragleave</code> events. This way, we can now say that only on <code class="literal">dragleave</code> events, where the counter becomes zero, we will actually leave the inside of our drop zone. Let's look at the following diagram that illustrates the problem:</p><div class="mediaobject"><img src="../Images/image00332.jpeg" alt="Implementing a drop target directive"/><div class="caption"><p>Visualization of important variables and functions for our calculations</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's implement this logic to build a proper enter and leave behavior of our drop zone within the <code class="literal">draggable/draggable-drop-zone.js</code> file:</p><div class="informalexample"><pre class="programlisting">constructor() {
  // We need this counter to know if a draggable is still over our 
  // drop zone
<span class="strong"><strong>  this.dragEnterCount = 0;</strong></span>
}

// The dragenter event is captured when a draggable is dragged 
// into our drop zone
@HostListener('dragenter', ['$event'])
onDragEnter(event) {
  // Only handle event if the draggable is accepted by our drop 
  // zone
<span class="strong"><strong>  if (this.typeIsAccepted(event)) {</strong></span>
<span class="strong"><strong>    this.over = true;</strong></span>
    // We use this counter to determine if we loose focus because 
    // of child element or because of final leave
<span class="strong"><strong>    this.dragEnterCount++;</strong></span>
<span class="strong"><strong>  }</strong></span>
}

// The dragleave event is captured when the draggable leaves our 
// drop zone
@HostListener('dragleave', ['$event'])
onDragLeave(event) {
  // Using dragEnterCount, we determine if the dragleave event is 
  // because of child elements or because the draggable was moved 
  // outside the drop zone
<span class="strong"><strong>  if (this.typeIsAccepted(event) &amp;&amp; --this.dragEnterCount === 0) {</strong></span>
<span class="strong"><strong>    this.over = false;</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Within both the events, we first check whether the event is carrying a <code class="literal">dataTransfer</code> object of which we accept the type. After validating the type using our <code class="literal">typeIsAccepter</code> method, we deal with the counter and set the <code class="literal">over</code> member field if required.</p><p>We need to handle <a id="id340" class="indexterm"/>another event that is important for drag and drop functionality, which is the <code class="literal">dragover</code> event. Within the <code class="literal">dragover</code> <a id="id341" class="indexterm"/>event, we can set the accepted <code class="literal">dropEffect</code> of the current dragging action. This will tell our browser that the initiated dragging action from our draggable is suitable for this drop zone. It's also important that we prevent the default browser behavior so there's nothing in the way of our custom drag and drop behavior. Let's add an other function to cover those concerns:</p><div class="informalexample"><pre class="programlisting">@HostListener('dragover', ['$event'])
onDragOver(event) {
  // Only handle event if the draggable is accepted by our drop 
  // zone
  if (this.typeIsAccepted(event)) {
    // Prevent any default drag action of the browser and set the 
    // dropEffect of the dataTransfer object
<span class="strong"><strong>    event.preventDefault();</strong></span>
<span class="strong"><strong>    event.dataTransfer.dropEffect = 'move';</strong></span>
  }
}</pre></div><p>Finally, we need to handle the most important event in the drop zone, which is the <code class="literal">drop</code> event that is triggered if <a id="id342" class="indexterm"/>a user drops a draggable into our drop zone:</p><div class="informalexample"><pre class="programlisting">// This event will be captured if a draggable element is dropped 
// onto our drop zone
@HostListener('drop', ['$event'])
onDrop(event) {
  // Only handle event if the draggable is accepted by our drop 
  // zone
  if (this.typeIsAccepted(event)) {
    // First obtain the data object that comes with the drop event
<span class="strong"><strong>    const data = JSON.parse(</strong></span>
<span class="strong"><strong>      event.dataTransfer.getData('application/json')</strong></span>
<span class="strong"><strong>    );</strong></span>
    // After successful drop, we can reset our state and emit an 
    // event with the data
<span class="strong"><strong>    this.over = false;</strong></span>
<span class="strong"><strong>    this.dragEnterCount = 0;</strong></span>
<span class="strong"><strong>    this.dropDraggable.next(data);</strong></span>
  }
}</pre></div><p>After checking whether the dropped element is of an accepted type, we can now go ahead and read the <code class="literal">dataTransfer</code> object data from the event. This data was previously set by the <code class="literal">Draggable</code> directive and needs to be deserialized using <code class="literal">JSON.parse</code>.</p><p>Since the drop was successful, we can reset our <code class="literal">dragEnterCount</code> member and set the <code class="literal">over</code> flag to <code class="literal">false</code>.</p><p>Finally, we will <a id="id343" class="indexterm"/>emit the deserialized data from the draggable element using our <code class="literal">dropDraggable</code> output property.</p><p>That's all we need to have a highly reusable drag and drop behavior that we can now attach to any components within our application where we feel the need.</p></div><div class="section" title="Integrating drag and drop in task list component"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec54"/>Integrating drag and drop in task list component</h2></div></div></div><p>We can now <a id="id344" class="indexterm"/>use the <code class="literal">Draggable</code> and <code class="literal">DraggableDropZone</code> directives in our <code class="literal">TaskList</code> component so we can enable the reordering of tasks using drag and drop.</p><p>The way we're going to do this is by attaching both the directives to the task elements within the <code class="literal">TaskList</code> component template, where we'll render them. Yeah, that's right! We want to make our <code class="literal">Task</code> component a draggable but also a drop zone at the same time. This way, we can drop tasks into other tasks, and this gives us the foundation for reordering. What we will do is reorder the list in a drop so that the dropped task will be squeezed into the <a id="id345" class="indexterm"/>position right before the task where it was dropped.</p><p>First, let's apply the directives to the <code class="literal">&lt;ngc-task&gt;</code> element in the <code class="literal">TaskList</code> component template, namely <code class="literal">task-list/task-list.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div class="task-list__l-container"&gt;
  ...
  &lt;ngc-task *ngFor="let task of filteredTasks"
            line:[task]="task
            (taskUpdated)="onTaskUpdated(task, $event)"
            (taskDeleted)="onTaskDeleted(task)"
<span class="strong"><strong>            draggable</strong></span>
<span class="strong"><strong>            draggableType="task"</strong></span>
<span class="strong"><strong>            [draggableData]="task"</strong></span>
<span class="strong"><strong>            draggableDropZone</strong></span>
<span class="strong"><strong>            dropAcceptType="task"</strong></span>
<span class="strong"><strong>            (dropDraggable)="onTaskDrop($event, task)"</strong></span>&gt;
  &lt;/ngc-task&gt;
  ...
&lt;/div&gt;</pre></div><p>Alright, using the preceding attributes, we have made our tasks not only a draggable, but also a drop zone. By specifying both <code class="literal">draggableType</code> and <code class="literal">dropAcceptType</code> to the <code class="literal">"task"</code> string, we are telling our drag and drop behavior that these task elements can be dropped into other task elements. Our <code class="literal">DraggableDropZone</code> directive is set to emit a <code class="literal">dropDraggable</code> event whenever a valid draggable is dropped off. To handle dropped tasks, we can simply use this event and create a binding to a method in our <code class="literal">TaskList</code> component.</p><p>Let's see what we need to change within our <code class="literal">Component</code> class, located under <code class="literal">task-list/task-list.js</code>, to make this work:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {Draggable} from '../draggable/draggable';</strong></span>
<span class="strong"><strong>import {DraggableDropZone} from '../draggable/draggable-drop-zone';</strong></span>

@Component({
  selector: 'ngc-task-list',
  ...
<span class="strong"><strong>  directives: [..., Draggable, DraggableDropZone]</strong></span>
})
export class TaskList {
  ...
  onTaskDrop(<span class="strong"><strong>source, target</strong></span>) {
<span class="strong"><strong>    if (source.position === target.position) {</strong></span>
<span class="strong"><strong>      return;</strong></span>
<span class="strong"><strong>    }</strong></span>

<span class="strong"><strong>    let tasks = this.tasks.slice();</strong></span>
<span class="strong"><strong>    const sourceIndex = tasks.findIndex(</strong></span>
<span class="strong"><strong>      (task) =&gt; task.position === source.position</strong></span>
<span class="strong"><strong>    );</strong></span>
<span class="strong"><strong>    const targetIndex = tasks.findIndex(</strong></span>
<span class="strong"><strong>      (task) =&gt; task.position === target.position</strong></span>
<span class="strong"><strong>    );</strong></span>
<span class="strong"><strong>    tasks.splice(targetIndex, </strong></span>
<span class="strong"><strong>                 0, </strong></span>
<span class="strong"><strong>                 tasks.splice(sourceIndex, 1)[0]);</strong></span>
<span class="strong"><strong>    tasks = tasks.map((task, index) =&gt; {</strong></span>
<span class="strong"><strong>      return Object.assign({}, task, {</strong></span>
<span class="strong"><strong>        position: index</strong></span>
<span class="strong"><strong>      });</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>    this.tasksUpdated.next(tasks);</strong></span>
  }
  ...
}</pre></div><p>Let's elaborate on the <a id="id346" class="indexterm"/>behavior we'll see within the <code class="literal">onTaskDrop</code> method that is bound to the <code class="literal">DropZone</code>'s <code class="literal">dropDraggable</code> event in our template:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If you check the template again, you would see that we bound to the <code class="literal">onTaskDrop</code> method with the following expression: <code class="literal">(dropDraggable)="onTaskDrop($event, task)"</code>. Since the drop zone emitted an event with de-serialized data that was bound using the draggable input property <code class="literal">draggableData</code>, we can safely assume that we will receive a copy of the task that was dropped into the drop zone. As a second parameter to our binding, we added the local view variable <code class="literal">task</code>, which is actually the task that acts as the drop zone. Therefore, we can say that the first parameter of our <code class="literal">onTaskDrop</code> method represents the source, while the second represents the target task.</li><li class="listitem">As a first check in our method, we compare the source position with the target position, and if they match, we can assume that the task was dropped by itself and we don't need to perform any further actions.</li><li class="listitem">Now we can get the source and target task indices within our tasks array and execute a nested splice so that we can remove the source from its old position within the array and add it right before the position of the target.</li><li class="listitem">All that's left to do now is recalculate the position fields of the tasks so that they reflect the reordered array. We can do this easily by using <code class="literal">Array.prototype.map</code>.</li><li class="listitem">As the last step, we need to notify our parent component that we've updated the task list. We can simply use the <code class="literal">taskUpdated</code> event to do so. We have used that same event when tasks were added or removed.</li></ol><div style="height:10px; width: 1px"/></div><p>How great is that? We <a id="id347" class="indexterm"/>have successfully implemented drag and drop on our task list to provide a very usable feature to reorder tasks.</p></div><div class="section" title="Recapitulate on drag and drop"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec55"/>Recapitulate on drag and drop</h2></div></div></div><p>With the use of the <a id="id348" class="indexterm"/>low-level drag and drop API, using events and <code class="literal">dataTransfer</code> objects, we have implemented two directives that can now be used to execute smooth drag and drop functionality within our application wherever we desire.</p><p>With almost no effort, we have implemented our drag and drop behavior on the task list to provide a nice feature to reorder the tasks within the list. The only thing we needed to do, besides hooking up the directives, was to implement a method where we could reorder the tasks based on the information from the <code class="literal">DraggableDropZone</code> event.</p><p>We have worked with the following concepts in this section:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We learned the basics of HTML5 drag and drop API.</li><li class="listitem">We used the <code class="literal">dataTransfer</code> object to securely transfer data within drag and drop events.</li><li class="listitem">Built reusable behavior patterns using directives.</li><li class="listitem">Enriched the standard drag and drop API by providing our own custom selection mechanisms using a custom data type that encodes draggable-type information.</li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="To infinity and beyond!"><div class="titlepage" id="aid-1HIT82"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>To infinity and beyond!</h1></div></div></div><p>Displaying a simple list with an average size does not come with a lot of challenges. As soon as the lists starts to grow, challenges start to appear. We can easily overwhelm a user with a very long list. Long lists can also have a performance impact on our application, especially when it displays dynamic content.</p><p>One way to address the challenge faced when displaying long lists is to provide pagination. However, pages do not always translate very well. While using pagination on a desktop device with a mouse seems very intuitive, it becomes cumbersome on mobile devices with touch support.</p><p>In this chapter, we'll look at a different approach that can help us mitigate the performance implications of long lists while providing a smooth experience on mobile devices. We are using a pattern sometimes referred to as infinite scrolling. The goal is to display only enough items within the list to fill the screen, and load more items on demand if the user scrolls down.</p><p>To implement such a behavior, we could write a wrapper component that will provide an infinite scroll pane and use content insertion to embrace our list. However, we will use a different approach to implement our infinite scroll behavior and build a custom template directive such as <code class="literal">NgFor</code>.</p><div class="section" title="The asterisk syntax and templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec56"/>The asterisk syntax and templates</h2></div></div></div><p>We have used the <code class="literal">NgFor</code> <a id="id349" class="indexterm"/>and <code class="literal">NgIf</code> directives quite a lot so far using the asterisk (<code class="literal">*</code>) symbol to indicate we're dealing with a directive that creates a template. However, we haven't looked at the anatomy of the asterisk template syntax. Imagine that it will create some sort of syntactic sugar for our template.</p><p>Check out this example of using the <code class="literal">NgFor</code> directive with the asterisk template syntax:</p><div class="informalexample"><pre class="programlisting">&lt;div <span class="strong"><strong>*ngFor="let i of [1, 2, 3]"</strong></span>&gt;<span class="strong"><strong>{{i}}</strong></span>&lt;/div&gt;</pre></div><p>The template parser of Angular will handle all the attributes that start with an asterisk in a special way. The preceding example is an easier and more concise writing style of the following:</p><div class="informalexample"><pre class="programlisting">&lt;template <span class="strong"><strong>ngFor #i [ngForOf]="[1, 2, 3]"</strong></span>&gt;
  &lt;div&gt;<span class="strong"><strong>{{i}}</strong></span>&lt;/div&gt;
&lt;/template&gt;</pre></div><p>Both the preceding examples are absolutely identical. Template directives, such as <code class="literal">NgFor</code> or <code class="literal">NgIf</code>, make use of HTML template elements, which we've briefly discussed in <a class="link" title="Chapter 1. Component-Based User Interfaces" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <span class="emphasis"><em>Component-Based User Interfaces</em></span>. The reason that the Angular common directives <code class="literal">NgFor</code>, <code class="literal">NgIf</code>, and <code class="literal">NgSwitch</code> use HTML template elements is actually quite obvious if you think about their nature. All three directives need to insert and remove large regions of our DOM dynamically. <code class="literal">NgIf</code>, for example, inserts or removes the element it's attached to, based on a condition. By leveraging template elements, this can be supported by the browser's native functionality.</p><div class="note" title="Note"><h3 class="title"><a id="note10"/>Note</h3><p>If you compare the examples discussed here, it's obvious that the first writing style is much simpler to deal with. Asking you to write a separate template element every time you'd want to use <code class="literal">NgFor</code> or <code class="literal">NgIf</code> would be quite a pain. This is the only reason why the asterisk syntax exists, its raison d'être if you like. Instead of writing a template element directly, we can use an asterisk on an attribute and Angular will transform the HTML portion into a template element for us.</p></div><p>The <code class="literal">NgFor</code> directive uses a <code class="literal">TemplateRef</code> dependency, which can be injected into the constructor of the <a id="id350" class="indexterm"/>directive, to instantiate the template or multiple instances of it, as desired. The <code class="literal">[ngForOf]</code> property binding is generated during de-sugaring by appending the word <code class="literal">Of</code> within the <code class="literal">NgFor</code> expression to the directive name, <code class="literal">ngFor</code>. The binding is created by the <code class="literal">NgFor</code> directive, which accepts an input, <code class="literal">ngForOf</code>.</p><p>Consider the following example:</p><div class="informalexample"><pre class="programlisting">&lt;div *test="<span class="strong"><strong>let variable withSugar true</strong></span>"&gt;<span class="strong"><strong>{{variable}}</strong></span>&lt;/div&gt;</pre></div><p>Angular would de-sugar this into the following code:</p><div class="informalexample"><pre class="programlisting">&lt;template <span class="strong"><strong>test #variable [testWithSugar]="true"</strong></span>&gt;
  &lt;div&gt;<span class="strong"><strong>{{variable}}</strong></span>&lt;/div&gt;
&lt;/template&gt;</pre></div><p>That's just the way Angular de-sugars the asterisk template syntax. It's a shortcut to attach directives as well as one input bindings to template elements.</p><p>There's still one thing that might look confusing, which is the variable attribute in the template. Let's look at another example of using the <code class="literal">NgFor</code> directive by aliasing the exposed local variables of a directive like the current index:</p><div class="informalexample"><pre class="programlisting">&lt;div <span class="strong"><strong>*ngFor="let n of [1, 2, 3]; let i = index"</strong></span>&gt;<span class="strong"><strong>{{i}}: {{n}}</strong></span>&lt;/div&gt;</pre></div><p>This example will be de-sugared to the following template:</p><div class="informalexample"><pre class="programlisting">&lt;template <span class="strong"><strong>ngFor #n #i="index" [ngForOf]="[1, 2, 3]"</strong></span>&gt;
  &lt;div&gt;<span class="strong"><strong>{{i}}: {{n}}</strong></span>&lt;/div&gt;
&lt;/template&gt;</pre></div><p>So we can now tell from de-sugaring that additional aliases or mappings will get created as variable mappings in our template element. The index that is exposed within the code of the <code class="literal">NgFor</code> directive class as a local view variable is mapped to a local view variable within the instantiated content of the template.</p><p>So what's going on with the local view variable <code class="literal">n</code> within our instantiated templates? Why can we access <code class="literal">n</code>, when there's just one variable attribute without any value that would tell us where it's mapped to?</p><p>We have learned that when we use hash symbol attributes on regular elements, we create a local view reference. We can use this reference as an identifier in the view directly, or by querying using <code class="literal">@ViewChild</code>. However, when the view compiler of Angular discovers what looks like a local view reference on a template, the behavior is a bit different.</p><p>What is invisible to us is that Angular actually implies a default value for variable attributes on template elements that don't have an attribute value. It will create a mapping for a local view variable called <code class="literal">$implicit</code>. You can think of <code class="literal">$implicit</code> as a default value that can be exposed <a id="id351" class="indexterm"/>in directives as local view variables and will provide some ease of use when dealing with template elements.</p><p>It would also be totally valid to write the preceding example as follows:</p><div class="informalexample"><pre class="programlisting">&lt;template <span class="strong"><strong>ngFor #n="$implicit" #i="index" [ngForOf]="[1, 2, 3]"</strong></span>&gt;
  &lt;div&gt;<span class="strong"><strong>{{i}}: {{n}}</strong></span>&lt;/div&gt;
&lt;/template&gt;</pre></div><p>Here, the <code class="literal">NgFor</code> directive is exposing a local view variable <code class="literal">$implicit</code>, which is a reference to the current value associated with the instance during the iteration over the array it receives within the <code class="literal">ngForOf</code> input. Using a plain variable attribute without a value, Angular will default a mapping to <code class="literal">$implicit</code>. Because we don't want to write this mapping all the time ourselves, we can just specify an empty variable attribute and Angular will assume it for us.</p></div><div class="section" title="Creating an infinite scroll directive"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec57"/>Creating an infinite scroll directive</h2></div></div></div><p>Since we now know a <a id="id352" class="indexterm"/>bit more about template elements and how Angular deals with the asterisk syntax, we can actually create our own copy of <code class="literal">NgFor</code>, which is additionally dealing with the behavior of infinite scrolling.</p><p>Let's create a new file for our directive under <code class="literal">infinite-scroll/infinite-scroll.js</code>:</p><div class="informalexample"><pre class="programlisting">...
@Directive({
  selector: '[ngcInfiniteScroll]'
})
export class InfiniteScroll {
  ...
  // This input will be set by the for of template syntax
<span class="strong"><strong>  @Input('ngcInfiniteScrollOf')</strong></span>
  set infiniteScrollOfSetter(value) {
    this.infiniteScrollOf = value;
    ...
  }
  ...

  applyChanges(changes) {
    ...
    this.bulkInsert(insertTuples).forEach((tuple) =&gt;
      tuple.<span class="strong"><strong>view.context.$implicit = tuple.record.item)</strong></span>;
  }
  ...
}</pre></div><p>We start off by declaring a regular directive that is sensitive to the attribute selector <code class="literal">ngcInfiniteScroll</code>. The preceding code excerpt only shows the relevant code for the template element handling we discussed in the previous topic. There are some code parts that we will cover later on in this topic. You can see that we used an input property <code class="literal">ngcInfiniteScrollOf</code>, which is used to pass in the list of times used within the infinite scrolling. For inserted template instances, we set the local view variable <code class="literal">$implicit</code> to the actual item within the list we were iterating over.</p><p>We will discuss how we get to all of the surrounding code shortly, but first let's take a look at how we could use <a id="id353" class="indexterm"/>this directive within a template:</p><div class="informalexample"><pre class="programlisting">&lt;div <span class="strong"><strong>*ngcInfiniteScroll="#item of items"</strong></span>&gt;<span class="strong"><strong>{{item}}</strong></span>&lt;/div&gt;</pre></div><p>The preceding code, as per the mechanisms described in the previous topic, will de-sugar into the following template element:</p><div class="informalexample"><pre class="programlisting">&lt;template <span class="strong"><strong>ngcInfiniteScroll #item [ngcInfiniteScrollOf]="items"</strong></span>&gt;
  &lt;div&gt;<span class="strong"><strong>{{item}}</strong></span>&lt;/div&gt;
&lt;/template&gt;</pre></div><p>So what we can tell now is that the items array will be placed as a property binding onto our template element. The same element also contains the <code class="literal">InfiniteScroll</code> directive.</p><p>After discussing how the directive will be used and how we can get the required input into the directive, let's look at the implementation details that enable the infinite scroll behavior.</p><p>Our directive needs to deal with quite a lot of concerns. Let's check out a high-level requirement list:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It needs to dynamically create new child views based on the template element and also remove child views that are no longer required.</li><li class="listitem">It needs to detect changes on the input property <code class="literal">ngcInfiniteScrollOf</code>, which is bound to an array within the template. It's not sufficient to use a simple identity check, because we'd like to create a comparison of the previous array to the new array and only perform view changes based on the differences. For this purpose, we will need to implement the <code class="literal">DoCheck</code> life cycle callback.</li><li class="listitem">It needs to store a count of items that should be displayed initially, and by detecting scroll events, the displayed item count should increase so more items could be made visible. At the same time, scrolling should trigger the change detection so that we can create new instances of the template within the view.</li></ul></div><p>Let's start with the constructor of our directive:</p><div class="informalexample"><pre class="programlisting">constructor(<span class="strong"><strong>@Inject(ViewContainerRef) viewContainerRef,</strong></span>
<span class="strong"><strong>            @Inject(TemplateRef) templateRef,</strong></span>
<span class="strong"><strong>            @Inject(IterableDiffers) iterableDiffers,</strong></span>
<span class="strong"><strong>            @Inject(ChangeDetectorRef) cdr</strong></span>) {
  // Using Object.assign we can easily add all constructor 
  // arguments to our instance
<span class="strong"><strong>  Object.assign(this, </strong></span>
<span class="strong"><strong>    {viewContainerRef, templateRef, iterableDiffers, cdr});</strong></span>
  // How many items will be shown initially
<span class="strong"><strong>  this.shownItemCount = 3;</strong></span>
  // How many items should be displayed additionally, when we 
  // scroll to the bottom
<span class="strong"><strong>  this.increment = 3;</strong></span>
}</pre></div><p>We needed to use quite a lot of injected dependencies in order to perform all the operations required to <a id="id354" class="indexterm"/>fulfill the outlined requirements of our directive:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">ViewContainerRef</code> dependency helps us create new embedded views based on our template element as well as detach or completely remove existing views.</li><li class="listitem">The <code class="literal">TemplateRef</code> dependency is a reference to the template element, and we can use it in conjunction with the <code class="literal">ViewContainerRef</code> dependency in order to create new instances.</li><li class="listitem">The <code class="literal">IterableDiffers</code> dependency is used to create a diff of our input property, which is the array of items we're concerned about in our infinite scroll repeater. It supports us in finding the created, removed, and deleted items.</li><li class="listitem">The <code class="literal">ChangeDetectorRef</code> dependency is used to trigger change detection manually when we actually need it.</li></ul></div><p>As the first step, we used <code class="literal">Object.assign</code> to store all our function parameters in the instance of the directive. Then, we set two-member variables that will store information related to the number of items that should be displayed and also the number of displayed items we should increase upon scrolling.</p><p>That's it for the constructor. We also need to perform some actions after the view within our directive has been initialized. We'll use the <code class="literal">ngOnInit</code> life cycle hook for this purpose:</p><div class="informalexample"><pre class="programlisting">  ngOnInit() {
    this.scrollableElement = findScrollableParent(
      this.viewContainerRef.element.nativeElement.parentElement);
    this.scrollableElement.addEventListener('scroll', this._onScrollListener);
  }</pre></div><p>Let's look at these two lines of code in more detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The way our infinite scrolling works is that it detects whether the scrollable parent element has already scrolled to the bottom. If that's the case, we'd need to render more items from the list. In order to check  whether our parent element has already scrolled to the bottom, we will need a reference to it. As scroll events don't bubble, we need to be very precise where to monitor them. That's the <a id="id355" class="indexterm"/>reason why we use a utility function to scan the DOM tree to find the next scrollable parent element. The <code class="literal">findScrollableParent</code> function looks for the first parent element that has scrollbars or the window object. You can check the source code of this chapter if you'd like to see the internals of the function.</li><li class="listitem">Now we've added an event handler to the found scrollable parent element and registered our internal <code class="literal">onScroll</code> method as a callback.</li></ul></div></div><div class="section" title="Detecting change within our template directive"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec58"/>Detecting change within our template directive</h2></div></div></div><p>Now let's look <a id="id356" class="indexterm"/>at the complete code of the <code class="literal">ngcInfiniteScrollOf</code> property setter, which we have briefly looked at already:</p><div class="informalexample"><pre class="programlisting">@Input('ngcInfiniteScrollOf')
set infiniteScrollOfSetter(value) {
  this.infiniteScrollOf = value;
  // Create a new iterable differ for the iterable `value`, if the 
  // differ is not already present
  if (value &amp;&amp; !this.differ) {
<span class="strong"><strong>    this.differ = this.iterableDiffers.find(value).create(this.cdr);</strong></span>
    }
}</pre></div><p>Our property setter will be called by Angular every time the <code class="literal">ngcInfiniteScrollOf</code> input property changes. Since this property is bound by the de-sugaring of the asterisk template syntax to the list we refer to within our template, we can assume that the value will always be an array or a similar iterable structure.</p><p>Besides storing the new value from the input property onto our directive instance, we also lazy initialize a member field called <code class="literal">differ</code>. Using the <code class="literal">find</code> method on the <code class="literal">IterableDiffers</code> object, we can obtain a factory that matches the type of iterable you're dealing with (in our case, this will be plain arrays). On the obtained factory, we can then call the <code class="literal">create</code> method to create a new differ. The <code class="literal">create</code> method expects a <code class="literal">ChangeDetectorRef</code> object to be passed. Luckily, we have that readily available through an injection within the constructor.</p><p>The differ will help us in a later step to detect changes between the existing value of our array and an updated one. We can then perform additions, removals, and movements in a very performant way.</p><p>If we call the <code class="literal">diff</code> method on <code class="literal">IterableDiffer</code>, it will return a new <code class="literal">IterableDiffer</code> object that contains all the changes relative to the previous <code class="literal">IterableDiffer</code> object. In a differ, we can then call one of the following methods to iterate over the relevant <code class="literal">CollectionChangeRecord</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">forEachItem</code>: This <a id="id357" class="indexterm"/>iterates over each <code class="literal">CollectionChangeRecord</code> within the differ by providing a callback function. The first argument to the callback will be a change record.</li><li class="listitem"><code class="literal">forEachPreviousItem</code>: This only iterates over each <code class="literal">CollectionChangeRecord</code> within the differ that already existed in the previous differ.</li><li class="listitem"><code class="literal">forEachAddedItem</code>: This only iterates over each change record that was added from the previous diff to the current one.</li><li class="listitem"><code class="literal">forEachMovedItem</code>: This only iterates over each change record that was moved.</li><li class="listitem"><code class="literal">forEachRemovedItem</code>: This only iterates over change records that were removed</li></ul></div><p>The <code class="literal">CollectionChangeRecord</code> objects contain the following three main properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">item</code>: A reference to the item within the list which we're observing for changes using the differ</li><li class="listitem"><code class="literal">previousIndex</code>: The index of the item within the list before the <code class="literal">differ</code> iterable happened</li><li class="listitem"><code class="literal">currentIndex</code>: The index of the item within the list after the <code class="literal">differ</code> iterable</li></ul></div><p>We can also solely tell from the constellation of <code class="literal">previousIndex</code> and <code class="literal">currentIndex</code> what happened to the item. The following methods are present on an <code class="literal">IterableDiffer</code> object:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Added items</strong></span>: This can be identified if <code class="literal">previousIndex</code> is null and <code class="literal">currentIndex</code> is set to a valid number</li><li class="listitem"><span class="strong"><strong>Moved items</strong></span>: This can be identified if <code class="literal">previousIndex</code> and <code class="literal">currentIndex</code> are both set to a valid number</li><li class="listitem"><span class="strong"><strong>Removed items</strong></span>: This can be identified if <code class="literal">previousIndex</code> is set to a valid number but <code class="literal">currentIndex</code> is set to <code class="literal">null</code></li></ul></div><p>Now let's look at the <code class="literal">onScroll</code> method, which will be invoked by the scroll event callback of the scrollable container element. In this method, we need to handle the logic of our behavior that should be executed when a user scrolls down:</p><div class="informalexample"><pre class="programlisting">onScroll() {
  // If the scrollable parent is scrolled to the bottom, we will 
  // increase the count of displayed items
  if (this.scrollableElement &amp;&amp; isScrolledBottom(this.  scrollableElement)) {
<span class="strong"><strong>    this.shownItemCount = Math.min(this.infiniteScrollOf.length, this.shownItemCount + this.increment);</strong></span>
    // After incrementing the number of items displayed, we need 
    // to tell the change detection to revalidate
<span class="strong"><strong>    this.cdr.markForCheck();</strong></span>
  }
}</pre></div><p>In the <code class="literal">onScroll</code> method, we first checked whether the scrollbar of the scrollable parent element has already scrolled to the bottom. If that's the case, we can assume that we should display more items from our list.</p><p>We incremented the <code class="literal">showItemCount</code> member by the default <code class="literal">increment</code> value, which we have set to <code class="literal">3</code>, and after modifying the number of displayed items, we used the change detector to mark our subtree structure to be checked.</p><p>Since we would like to use the differ that we have lazy initialized within our input setter to detect changes and <a id="id358" class="indexterm"/>perform any actions manually, we will need to implement the <code class="literal">DoCheck</code> life cycle callback on our directive. By implementing this, we will disable the default change detection of Angular and implement our own way to deal with changes:</p><div class="informalexample"><pre class="programlisting">ngDoCheck() {
  if (this.differ) {
    // We are creating a new slice based on the displayed item 
    // count and then create a changes object containing the 
    // differences using the IterableDiffer
<span class="strong"><strong>    const updatedList = this.infiniteScrollOf</strong></span>
<span class="strong"><strong>      .slice(0, this.shownItemCount);</strong></span>
<span class="strong"><strong>    const changes = this.differ.diff(updatedList);</strong></span>
    if (changes) {
      // If we have any changes, we call our `applyChanges` method
<span class="strong"><strong>      this.applyChanges(changes);</strong></span>
    }
  }
}</pre></div><p>First, we used the differ to obtain a change record set from the current <code class="literal">infiniteScrollOf</code> array to the previous one. The differ will actually always store the previous value, so we only need to pass it the current value. The change records will then help us to perform different actions for added, removed, and moved items. It's also important to note that we did not use the whole list here to create a diff, but a slice of the list where our <code class="literal">showItemCount</code> member comes into play. This will only make the list that we're concerned about available in our infinite scroll behavior.</p></div><div class="section" title="Adding and removing embedded views"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec59"/>Adding and removing embedded views</h2></div></div></div><p>If there are any <a id="id359" class="indexterm"/>changes detected by the differ, we can call the <code class="literal">applyChanges</code> <a id="id360" class="indexterm"/>method, which deals with the details of how to perform view updates with changed items:</p><div class="informalexample"><pre class="programlisting">applyChanges(<span class="strong"><strong>changes</strong></span>) {
  // First we create a record list that contains all moved and 
  // removed change records
<span class="strong"><strong>  const recordViewTuples = [];</strong></span>
<span class="strong"><strong>  changes.forEachRemovedItem((removedRecord) =&gt; </strong></span>
<span class="strong"><strong>    recordViewTuples.push({record: removedRecord}));</strong></span>
<span class="strong"><strong>  changes.forEachMovedItem((movedRecord) =&gt; </strong></span>
<span class="strong"><strong>    recordViewTuples.push({record: movedRecord}));</strong></span>

  // We can now bulk remove all moved and removed views and as a 
  // result we get all moved records only
<span class="strong"><strong>  const insertTuples = this.bulkRemove(recordViewTuples);</strong></span>
  // In addition to all moved records we also add a record for all 
  // newly added records
<span class="strong"><strong>  changes.forEachAddedItem((addedRecord) =&gt; </strong></span>
<span class="strong"><strong>    insertTuples.push({record: addedRecord}));</strong></span>

  // Now we have stored all moved and added records within `
  // insertTuples` which we use to do a bulk insert. As a result 
  // we get the list of the newly created views. On those views 
  // we're then creating a view local variable `$implicit` that 
  // will bind the list items to the variable name used within the 
  // for of template syntax.
<span class="strong"><strong>  this.bulkInsert(insertTuples).forEach((tuple) =&gt;</strong></span>
<span class="strong"><strong>    tuple.view.context.$implicit = tuple.record.item);</strong></span>
}</pre></div><p>Let's look at the innards of the <code class="literal">applyChanges</code> method. It needs to be called from the <code class="literal">OnChange</code> life cycle hook with a parameter that reflects the record changes within the observed input array called <code class="literal">infiniteScrollOf</code>. In the constant <code class="literal">recordViewTuples</code>, we stored all the change records that were either moved or removed completely. Now you can call the <code class="literal">bulkRemove</code> method by passing the <code class="literal">recordViewTuples</code> array. The <code class="literal">bulkRemove</code> method will either detach the view, in case there is movement, or completely remove the view. The returned value is a list that will contain only the tuples that were moved. We stored these within a constant called <code class="literal">insertTuples</code>. Because they were detached from the view container, we will need to reattach them at a different position within the view container.</p><p>Now we can go ahead and add all the records to the <code class="literal">insertTuples</code> array that were added according to the latest diff. The <code class="literal">insertTuples</code> array now contains all the moved as well as added records.</p><p>Using this list, we call <a id="id361" class="indexterm"/>the <code class="literal">bulkInsert</code> method, which will reinsert moved views <a id="id362" class="indexterm"/>and create new embedded views for added records. As a result, we get a list of all the inserted records (moved and added), where each record also contains a view property that points to the inserted view.</p><p>The last step within our <code class="literal">applyChanges</code> method should now ring a bell. We iterated through the list of newly inserted views and set the local view variable <code class="literal">$implicit</code> on the view context. This way, we can set the required variable that is used to create the default variable mappings on our template elements, as discussed in the previous topic.</p><p>In order to understand how we can instantiate new views from our template element, move views around, and remove existing views, we need to understand the view container. The <code class="literal">ViewContainerRef</code> dependency is provided to our directive or component using injection in the constructor. It stores a list of views and provides some methods to add new and remove existing views. Each component within Angular contains one view container. We can then access the methods on the view container in order to programmatically modify the view.</p><p>There are four main methods in <code class="literal">ViewContainerRef</code> that we're interested in:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Method</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">createEmbeddedView</code></p>
</td><td valign="top">
<p>This method will create a new embedded view using a template reference and insert the newly created view at a given index within the view container. Embedded views are views instantiated from template elements.</p>
<p>The following are its parameters:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">templateRef</code>: The first parameter should be the template reference, which should be instantiated into an embedded view.</li><li class="listitem"><code class="literal">context</code>: This is an optional context object, which will be available for the instantiated template view. All properties within the context can be used within the view template as local view variables.</li><li class="listitem"><code class="literal">index</code>: The optional index parameter can be used to place the instantiated view at a given position within the view container.</li></ul></div>
<p>This method returns the created embedded view.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">detach</code></p>
</td><td valign="top">
<p>The <code class="literal">detach</code> method will remove an embedded view from the view container at a given index without destroying the view so it can be reattached later using the <code class="literal">insert</code> method.</p>
<p>The following is its parameter:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">index</code>: This is the index of the embedded view, which should be detached</li></ul></div>
<p>This method returns the detached embedded view.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">remove</code></p>
</td><td valign="top">
<p>The <code class="literal">remove</code> method will completely remove an embedded view from the view container and also destroy the view. A view that has been destroyed can't simply be reattached using the <code class="literal">insert</code> method.</p>
<p>The following is its parameter:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">index</code>: This <a id="id363" class="indexterm"/>is the index of the embedded view, which should be removed</li></ul></div>
<p>This method returns the removed embedded view.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">insert</code></p>
</td><td valign="top">
<p>This method <a id="id364" class="indexterm"/>will insert an existing view into the view container.</p>
<p>The following are its parameters:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">viewRef</code>: The embedded view that should be inserted into the view container.</li><li class="listitem"><code class="literal">index</code>: The optional index parameter that can be used to place the embedded view at a given position within the view container.</li></ul></div>
<p>This method returns the inserted embedded view.</p>
</td></tr></tbody></table></div><p>Let's quickly look at the <code class="literal">bulkRemove</code> and <code class="literal">bulkInsert</code> methods to see how we can use the view container to modify the containing view upon changes:</p><div class="informalexample"><pre class="programlisting">bulkRemove(tuples) {
  ...
  // Reducing the change records so we can return only moved 
  // records
  return tuples.reduceRight((movedTuples, tuple) =&gt; {
    // If an index is present on the change record, it means that 
    // its of type "moved"
<span class="strong"><strong>    if (tuple.record.currentIndex != null) {</strong></span>
      // For moved records we only detach the view from the view 
      // container and push it into the reduced record list
<span class="strong"><strong>      tuple.view = this.viewContainerRef.detach(tuple.record.previousIndex);</strong></span>
<span class="strong"><strong>      movedTuples.push(tuple);</strong></span>
    } else {
      // If we're dealing with a record of type "removed", we 
      // completely remove the view
<span class="strong"><strong>      this.viewContainerRef.remove(tuple.record.previousIndex);</strong></span>
    }
    return movedTuples;
  }, []);
}</pre></div><p>We use <code class="literal">ViewContainerRef</code> to detach views in case the record contains a valid <code class="literal">currentIndex</code> field. If that's the case, we know that we are dealing with a view that will be moved. We use the <code class="literal">detach</code> method to exclude the view from its position within the view container, but this <a id="id365" class="indexterm"/>will not destroy the view. It's important to note here that <a id="id366" class="indexterm"/>we stored the returned view from the <code class="literal">detach</code> method onto the tuple before we added it to the <code class="literal">movedTuples</code> list. This way, we were able to identify it later as a moved item, and we could use the view to reattach it using the <code class="literal">insert</code> method on the view container.</p><p>In the case where there's no valid <code class="literal">currentIndex</code>, we are dealing with an element that was removed from the list. In such cases, we'd need to use the <code class="literal">remove</code> method to completely destroy the view and remove it from the view container.</p><p>Now we'll call the <code class="literal">bulkInsert</code> method with any moved or inserted views. Let's also look at the code of this method briefly to see how we can handle view updates there:</p><div class="informalexample"><pre class="programlisting">bulkInsert(tuples) {
  ...
  tuples.forEach((tuple) =&gt; {
    if (tuple.view) {
      // We're inserting back the detached view at the new positionwithin the view container
<span class="strong"><strong>      this.viewContainerRef.insert(tuple.view, </strong></span>
<span class="strong"><strong>        tuple.record.currentIndex);</strong></span>
    } else {
      // We're dealing with a newly created view so we create a new embedded view on the view container and store it in the change record
<span class="strong"><strong>      tuple.view = </strong></span>
<span class="strong"><strong>        this.viewContainerRef.createEmbeddedView(</strong></span>
<span class="strong"><strong>          this.templateRef, </strong></span>
<span class="strong"><strong>          {},</strong></span>
<span class="strong"><strong>          tuple.record.currentIndex);</strong></span>
    }
  });
  return tuples;
}</pre></div><p>If the tuple contains a <code class="literal">view</code> property, we know we have previously detached it from a different position. We are using the insert method of the view container to reattach it at the new position using the information from <code class="literal">CollectionChangeRecord</code>.</p><p>If there's no <code class="literal">view</code> property, we <a id="id367" class="indexterm"/>are dealing with a newly added record. In that case, we simply use the <code class="literal">createEmbeddedView</code> method to create a new template instance. For <a id="id368" class="indexterm"/>the context parameter, we need to pass a new empty object. However, we've updated the context object already within our <code class="literal">applyChanges</code> method. There, we added the <code class="literal">$implicit</code> local view variable for every created view.</p><p>That's all we need for our <code class="literal">InfiniteScroll</code> directive, and we can now add it to the templates where we're planning to use this functionality. Let's use it within the task list by adding the directive to the directive list of the <code class="literal">TaskList</code> component within the <code class="literal">task-list/task-list.js</code> file:</p><div class="informalexample"><pre class="programlisting">...
<span class="strong"><strong>import {InfiniteScroll} from '../infinite-scroll/infinite-scroll';</strong></span>

@Component({
  selector: 'ngc-task-list',
  ...
<span class="strong"><strong>  directives: [..., InfiniteScroll]</strong></span>
})
export class TaskList {
  ...
}</pre></div><p>Now we can simply edit the task list template in <code class="literal">task-list/task-list.html</code> and replace the <code class="literal">NgFor</code> directive with our <code class="literal">InfiniteScroll</code> directive:</p><div class="informalexample"><pre class="programlisting">&lt;ngc-task <span class="strong"><strong>*ngcInfiniteScroll="let task of filteredTasks"</strong></span>
          [[task]="task"
          (taskUpdated)="onTaskUpdated(task, $event)"
          (taskDeleted)="onTaskDeleted(task)"
          draggable
          draggableType="task"
          [draggableData]="task"
          draggableDropZone
          dropAcceptType="task"
          (dropDraggable)="onTaskDrop($event, task)"&gt;&lt;/ngc-task&gt;</pre></div><p>That's all we need to use our infinite scroll functionality. This is highly reusable, and we can place it wherever we'd like to use it instead of the regular <code class="literal">NgFor</code> repeater.</p></div><div class="section" title="Finishing our infinite scroll directive"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec60"/>Finishing our infinite scroll directive</h2></div></div></div><p>In this topic, we <a id="id369" class="indexterm"/>created an infinite scrolling behavior by implementing a template directive similar to <code class="literal">NgFor</code>. We replaced the <code class="literal">NgFor</code> directive in our task list to use the <code class="literal">InfiniteScroll</code> directive instead. Now we don't display all the tasks right at the beginning, but as soon as the user starts to scroll, new tasks appear. In scenarios where we rely on a list that is partially loaded from the server, our directive could even be extended so it could request for more items from the server on demand.</p><p>We've covered the following subtopics here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The asterisk syntax and de-sugaring to template elements</li><li class="listitem">The local view variable, <code class="literal">$implicit</code></li><li class="listitem">Implementing the <code class="literal">OnChange</code> life cycle hook to provide custom change detection</li><li class="listitem">Using <code class="literal">IterableDiffer</code> to analyze the difference of changes within our array input property and handling <code class="literal">CollectionChangeRecord</code> objects to react on changes</li><li class="listitem">Using <code class="literal">ViewContainerRef</code> to update the view of a component programmatically</li><li class="listitem">Using <code class="literal">TemplateRef</code> as a reference to the template element within template directives</li></ul></div></div></div>
<div class="section" title="Summary" id="aid-1IHDQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we built three components to enhance the usability of our application. Users can now make use of tags to easily annotate comments with navigable items that provide summaries to the subject. They can use drag and drop to reorder tasks and benefit from an infinite scroll behavior on the task list.</p><p>Usability is a key asset in today's applications, and by providing highly encapsulated and reusable components to address usability concerns, we can make our lives a lot easier when building those applications. Thinking in terms of components when dealing with usability is a very good thing, which not only eases development, but also establishes consistency. The consistency itself then plays a major role in making an application usable.</p><p>In the next chapter, we're going to create some nifty components to manage time within our task management system. This will also include some new user input components to enable simple work time-entry fields.</p></div></body></html>