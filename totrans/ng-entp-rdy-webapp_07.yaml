- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Creating a Router-First Line-of-Business App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建以路由器为第一线的业务应用
- en: '**Line-of-Business** (**LOB**) applications are the bread and butter of the
    software development world. As defined on Wikipedia, LOB is a general term that
    refers to a product or a set of related products that serve a particular customer
    transaction, or business need. LOB apps present an excellent opportunity to demonstrate
    a variety of features and functionality, without getting into the contorted or
    specialized scenarios that large enterprise applications usually need to address.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务线应用**（**LOB**）是软件开发世界的核心。如维基百科所定义，LOB是一个通用术语，指的是一个或一系列相关产品，它们服务于特定的客户交易或业务需求。LOB应用提供了展示各种功能和特性的绝佳机会，而无需涉及大型企业应用通常需要解决的扭曲或专业场景。'
- en: The Pareto principle, also known as the 80-20 rule, states that we can accomplish
    80% of our goals with 20% of the overall effort. We will be applying the 80-20
    rule to the design and architecture of our LOB app. Given the common use cases
    LOB apps cover, they are, in a sense, perfect for the 80-20 learning experience.
    With only 20% of the effort, you can learn about 80% of the things you will need
    to deliver high-quality experiences to your users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 帕累托原则，也称为80-20法则，表明我们可以用总体努力的20%完成80%的目标。我们将把80-20法则应用于我们的业务应用的设计和架构。鉴于业务应用覆盖的常见用例，它们在某种程度上非常适合80-20的学习体验。只需付出20%的努力，你就可以了解80%你需要知道的事情，以便为用户提供高质量的用户体验。
- en: LOB apps have a curious property to them. If you end up building a semi-useful
    app, the demand for it grows, uncontrollably, and you quickly become the victim
    of your success. It's challenging to balance the architectural needs of a project;
    you want to avoid potentially devastating under-engineering and, on the flip side,
    also avoid costly over-engineering for an app that will never need it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 业务应用有一个奇特的特点。如果你最终构建了一个半有用的应用，对其的需求将不受控制地增长，你很快就会成为你成功的受害者。平衡项目的架构需求是一项挑战；你想要避免潜在的毁灭性低工程，同时，在另一方面，也避免为永远不会需要它的应用进行昂贵的过度工程。
- en: In this chapter, I'm going to introduce you to router-first architecture, the
    80-20 design solution to address the challenges of delivering a modern web application
    in an incremental and iterative manner.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你介绍路由器优先架构，80-20设计解决方案，以增量迭代的方式解决交付现代Web应用所面临的挑战。
- en: As you read in *Chapter 1*, *Introduction to Angular and Its Concepts*, software
    architecture doesn't stay static. It's essential to experiment with new ideas
    by using coding-katas, proofs-of-concept apps, and reference projects, to get
    better at creating more flexible architectures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*第一章*，*Angular及其概念简介*中阅读的那样，软件架构不会保持静止。通过使用编码练习、概念验证应用和参考项目来实验新想法，对于提高创建更灵活架构的能力是至关重要的。
- en: In this and the remaining chapters of the book, we'll set up a new application
    with rich features that can meet the demands of an LOB application with a scalable
    architecture and engineering best practices that will help you start small and
    be able to grow your solution quickly if there's demand. We will follow the Router-first
    design pattern, relying on reusable components to create a grocery store LOB named
    LemonMart. We'll discuss the idea of designing around major data entities, and
    the importance of completing high-level mock-ups for your application before you
    start to implement various conditional navigation elements, which may change significantly
    during the design phase.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和本书剩余的章节中，我们将设置一个具有丰富功能的新应用，它可以满足具有可扩展架构和工程最佳实践的业务应用需求。这将帮助你从小规模开始，并在有需求时能够快速扩展你的解决方案。我们将遵循路由器优先的设计模式，依靠可重用组件来创建一个名为LemonMart的杂货店业务应用。我们将讨论围绕主要数据实体进行设计的理念，以及在开始实现各种条件导航元素之前完成高级原型的重要性，这些元素在设计阶段可能会发生重大变化。
- en: 'In this chapter, you will learn to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Apply the 80-20 solution to software development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将80-20解决方案应用于软件开发
- en: Learn how to build router-first apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何构建路由器优先的应用
- en: Begin your creation of the LemonMart app you'll expand over the remainder of
    this book
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始创建你将在本书剩余部分扩展的LemonMart应用
- en: Create effective branding, as well as custom and material iconography
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有效的品牌，以及定制和材料图标
- en: Achieve sub-second first-paint with lazy loading
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用懒加载实现亚秒级首次绘制
- en: Create a walking skeleton
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个行走骨架
- en: Reduce repetition using a common testing module
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公共测试模块减少重复
- en: Design around major data entities
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕主要数据实体进行设计
- en: Recognize the importance of high-level UX design
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到高级用户体验设计的重要性
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书样本代码的最新版本可在以下链接的 GitHub 存储库中找到。该存储库包含代码的最终和完成状态。您可以在本章结束时通过查找 `projects` 文件夹下的代码章节快照来验证您的进度。
- en: '*For Chapter 7*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*第七章*：'
- en: Clone the repo [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart
    )
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆存储库 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: Execute `npm install` on the root folder to install dependencies
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行 `npm install` 以安装依赖项
- en: 'The code sample for this chapter is under the sub-folder:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该章节的代码示例位于子文件夹：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Angular app for this chapter, execute:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 应用程序，请执行以下操作：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run Angular unit tests for this chapter, execute:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 单元测试，请执行以下操作：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run Angular e2e tests for this chapter, execute:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular e2e 测试，请执行以下操作：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build a production-ready Angular app for this chapter, execute:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为本章构建一个生产就绪的 Angular 应用程序，请执行以下操作：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dist/ch7` folder at the root of the repository will contain the
    compiled result.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的 `dist/ch7` 文件夹将包含编译结果。
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by the Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub, because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，书中或 GitHub 上的源代码可能并不总是与 Angular CLI 生成的代码相匹配。由于生态系统不断演变，书中代码与 GitHub 上的代码在实现上可能存在细微差异。随着时间的推移，样本代码发生变化是自然的。
- en: Also, on GitHub, expect to find corrections, fixes to support newer versions
    of libraries, or side-by-side implementations of multiple techniques for you to
    observe. You are only expected to implement the ideal solution recommended in
    the book. If you find errors or have questions, please create an issue or submit
    a pull request on GitHub for the benefit of all readers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 GitHub 上，您可以期待找到更正、修复以支持库的新版本，或者观察多种技术的并行实现。您只需实现书中推荐的理想解决方案。如果您发现错误或有疑问，请为所有读者创建一个
    GitHub 上的问题或提交一个拉取请求。
- en: You may read more about updating Angular in *Appendix C*, *Keeping Angular and
    Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *附录 C* 中了解更多关于更新 Angular 的信息，即 *保持 Angular 和工具常青*。您可以从 [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    或 [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen)
    在线找到此附录。
- en: Let's start by covering the philosophy behind the design and architecture of
    our apps.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解我们应用程序设计和架构背后的哲学开始。
- en: The 80-20 solution
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 80-20 解决方案
- en: 'Whether we develop apps at home, for passion projects, or at the office, for
    work, we must remain mindful of our purpose: to deliver value. If we don''t deliver
    value with our passion projects, then we won''t feel fulfilled or happy. If we
    fail to deliver value at work, we may not get paid.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在家开发应用程序、出于激情项目，还是在办公室工作，我们都必须保持清醒的头脑：我们的目的是提供价值。如果我们不能通过我们的激情项目提供价值，那么我们不会感到满足或快乐。如果我们无法在工作场所提供价值，我们可能得不到报酬。
- en: 'Delivering a modern web application is difficult. There are numerous challenges
    that we need to overcome to be successful:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 提供现代网络应用程序是困难的。我们需要克服许多挑战才能成功：
- en: Deliver iteratively and incrementally
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步迭代交付
- en: Be scalable
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可扩展性
- en: Serve dozens of screen and input types
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持数十种屏幕和输入类型
- en: Be usable
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用
- en: Be accessible
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于访问
- en: Manage a team
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理一个团队
- en: Groom a prioritized backlog
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整理优先级较高的待办事项列表
- en: Ensure acceptance criteria are clear, concise, and concrete
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保验收标准清晰、简洁、具体
- en: If you've ever led a project or tried to implement and deliver a project on
    your own, you'll have realized that there's just never enough time and resources
    to cover the wide variety of stakeholder, team, and technical needs on any given
    project. Remember that the Pareto principle, also known as the 80-20 rule, implies
    that we can accomplish 80% of our goals with 20% of the overall effort.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经领导过一个项目或者尝试过独立实施并交付一个项目，你就会意识到在任何特定项目中，时间和资源总是不足以覆盖广泛的利益相关者、团队和技术需求。记住帕累托法则，也称为80-20法则，它意味着我们可以用总体努力的20%完成80%的目标。
- en: If we apply the 80-20 rule to our work, we can maximize our output, quality,
    and happiness. Line-of-business applications are the bread and butter of our industry.
    Applying the 80-20 rule, we can surmise that most of us are likely to earn most
    of our income by delivering such applications. Therefore, we should keep our engineering
    overhead to a minimum, and reduce the delivery risk of our project. By limiting
    experimentation in production code, we create a predictable environment for our
    team members, and only introduce changes that we had a chance to vet in proof-of-concept
    or small apps.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将80-20法则应用于我们的工作，我们可以最大化我们的产出、质量和幸福感。业务线应用是我们行业的核心。应用80-20法则，我们可以推断出我们中的大多数人很可能通过交付这样的应用来赚取大部分收入。因此，我们应该将我们的工程开销保持在最低，并减少项目的交付风险。通过限制生产代码中的实验，我们为团队成员创造了一个可预测的环境，并且只引入我们在概念验证或小型应用中有机会审查过的变化。
- en: Our 80-20 strategy, combined with discipline, can help us deliver the same project
    in the same time with more features and better quality. By treating our careers
    as marathons and not a series of sprints, you can find yourself in a position
    of delivering high-quality solutions, project after project, without feeling burned
    out.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的80-20策略，结合纪律，可以帮助我们在相同的时间内交付相同的项目，拥有更多功能和更好的质量。将我们的职业生涯视为马拉松而不是一系列冲刺，你可以发现自己处于一个不断交付高质量解决方案、项目接项目的位置，而不会感到疲惫不堪。
- en: Understanding Line-of-Business apps
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解业务线应用
- en: 'Line-of-business applications are, according to Wikipedia, a "set of critical
    computer applications perceived as vital to running an enterprise." LOB apps are
    what most developers end up developing, even though we may think we develop small
    apps or large enterprise apps. Consider the following illustration, which demonstrates
    the kinds of apps we might develop, placed on an axis relative to their size and
    scope:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，业务线应用是一组“被认为对运营企业至关重要的关键计算机应用。”业务线应用是大多数开发者最终会开发的应用，即使我们可能认为我们开发的是小型应用或大型企业应用。考虑以下插图，它展示了我们可能开发的应用类型，这些应用根据其规模和范围放置在轴上：
- en: '![](img/B14094_07_01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_01.png)'
- en: 'Figure 7.1: Relative size and scope of four kinds of apps'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：四种类型应用的大小和范围相对关系
- en: 'From my perspective, we think about four kinds of apps when we begin developing
    software:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的角度来看，当我们开始开发软件时，我们会考虑四种类型的应用：
- en: Small apps
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型应用
- en: LOB apps
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务线应用
- en: Large enterprise apps
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型企业应用
- en: Billion user scale apps
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亿级用户规模的应用
- en: Billion user scale apps are completely niche implementations that rarely have
    needs that align with the vast majority of apps that are out there. For this reason,
    we must classify these apps as outliers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 亿级用户规模的应用是完全的细分市场实现，很少需要与大量现有应用的需求相匹配。因此，我们必须将这些应用归类为异常值。
- en: Small apps start small. Architecturally, they're likely to be initially under-engineered.
    As you add features and team members to work on a small app, at some point, you're
    going to run into trouble. As your team size and feature set grow, or the overall
    complexity of the app increases, the architectural needs of the application grow
    exponentially.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 小型应用从小开始。在架构上，它们很可能是最初设计不足的。随着你向小型应用添加功能和团队成员，在某个时候，你将会遇到麻烦。随着你的团队规模和功能集的增长，或者应用的总体复杂性增加，应用的架构需求呈指数增长。
- en: 'Once you cross the inflection point of the amount of complexity your architecture
    can bear, you''re left with a costly reengineering effort to get back on track.
    See the following graph, illustrating this idea:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你超过了你的架构能够承受的复杂性的拐点，你就只剩下了一个昂贵的重构努力来回到正轨。参见以下图表，说明了这个概念：
- en: '![](img/B14094_07_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_02.png)'
- en: 'Figure 7.2: Architectural journey of a small app'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：小型应用的架构之旅
- en: 'The area under the feature line represents under-engineering, which introduces
    risk to your project. The area above the feature line shows the required engineering
    overhead to support the features needed. In comparison, large enterprise apps
    start with a massive over-engineering effort, as shown in the following diagram:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 特性线下的区域代表过度简化，这会给你的项目带来风险。特性线上的区域显示了支持所需功能所需的工程开销。相比之下，大型企业应用从大规模的过度工程努力开始，如下面的图所示：
- en: '![](img/B14094_07_03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_03.png)'
- en: 'Figure 7.3: Architectural journey of a large enterprise app'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：大型企业应用的架构之旅
- en: As time goes on and the overall complexity of the system increases, large enterprise
    apps can also face a similar inflection point, where the original architecture
    can become inadequate. With careful planning and management, you can avoid trouble
    and protect the significant initial investment made. Such large enterprise apps
    require hundreds of developers, with multiple levels of managers and architects,
    to execute successfully. Similar to billion-user scale apps, these apps can also
    have niche architectural needs. In between the small apps and the large enterprise
    apps that we develop lie LOB apps.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移和系统整体复杂性的增加，大型企业应用也可能面临一个类似的转折点，此时原始架构可能变得不足。通过仔细规划和管理工作，你可以避免麻烦并保护所做出的重大初始投资。这类大型企业应用需要数百名开发者，以及多个级别的经理和架构师来成功执行。与亿级用户规模的应用类似，这些应用也可能有特定的架构需求。在我们开发的小型应用和大型企业应用之间，存在着LOB应用。
- en: '![](img/B14094_07_04.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_04.png)'
- en: 'Figure 7.4: Dynamic nature of software evolution'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：软件演变的动态性
- en: As shown in the preceding diagram, small apps can grow and morph into LOB apps,
    and large enterprise apps can become under-utilized as users ignore the features
    that they never need, but keep the app to serve a singular purpose as a LOB app.
    In either case, despite our best efforts, we ultimately end up delivering an inefficient
    solution for the problem we're solving. None of us have a crystal ball to see
    the future, and planning and engineering can only do so much for us in an unpredictable
    business setting; we need to rely on the 80-20 rule to come up with an architecture
    that is flexible to change, but adequate to meet most business requirements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，小型应用可以增长并转变为LOB应用，而大型企业应用可能会因为用户忽视他们从未需要的功能而未被充分利用，但仍然作为LOB应用服务于单一目的。在任何情况下，尽管我们尽了最大努力，但我们最终可能为解决我们的问题提供了一个低效的解决方案。我们都没有水晶球来预见未来，规划和工程在不可预测的商业环境中只能为我们做这么多；我们需要依靠80-20规则来制定一个灵活且能够满足大多数商业需求的架构。
- en: Router-first architecture aims to maintain optimal architectural overhead, so
    that in the rush to deliver all required features, costly re-engineering or late-stage
    crunch can be avoided. Let's see how.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以路由器为首要架构的目标是保持最佳架构开销，以便在匆忙交付所有必需功能时，可以避免昂贵的重新工程或后期冲刺。让我们看看如何做到这一点。
- en: Disciplined and balanced approach
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严谨和平衡的方法
- en: We covered the *what* of software development, but we must also consider the
    *why*, *when*, *where*, and *who*, before we can get to the *how*. When we develop
    apps for learning or passion projects, we usually end up under-engineering our
    projects. If your passion project somehow becomes an overnight success, then it
    becomes costly to maintain or keep adding features to your app. In this case,
    you're likely to face a choice to either bear the cost of ongoing maintenance,
    or rewrite your application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了软件开发中的“是什么”，但我们必须考虑“为什么”、“何时”、“何地”和“谁”，然后我们才能到达“如何”。当我们为学习或激情项目开发应用时，我们通常会过度简化我们的项目。如果你的激情项目意外地一夜成名，那么维护或继续添加应用功能可能会变得成本高昂。在这种情况下，你可能会面临一个选择，即承担持续维护的成本，或者重写你的应用程序。
- en: When we develop apps for work, we tend to be more conservative, and we're likely
    to over-engineer our solution. However, if you only code for work, then you're
    likely to experiment in production-bound code. It is dangerous to experiment in
    a codebase with other team members. You may be introducing a new pattern, without
    your team understanding the consequences of your choices. You're also less likely
    to be aware of mid-to long-term risks or benefits of the technologies you are
    introducing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们为工作开发应用时，我们往往更加保守，我们可能会过度工程我们的解决方案。然而，如果你只为工作编码，那么你可能会在生产代码中进行实验。在与其他团队成员共享的代码库中进行实验是危险的。你可能会引入一种新的模式，而你的团队可能不了解你选择的结果。你也不太可能意识到你引入的技术在中等或长期风险或收益。 '
- en: Reckless experimentation can also have a severe negative impact on your team
    members. In a team of senior and experienced software engineers, you can likely
    get away with experimenting in a moving car. However, we are likely to have team
    members of varying backgrounds and learning styles on our teams. Some of us have
    computer science degrees, some of us are lone wolves, and some of us depend a
    bit too much on Stack Overflow. Some of us work at companies that are great at
    supporting professional growth, but some of us work at places that won't even
    give you a day to learn something new. So, when we are experimenting, we must
    consider our environment; otherwise we can cause our colleagues to work overtime or
    feel helpless and frustrated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'With a disciplined and balanced approach, we can reduce the number of bugs
    delivered, avoid costly rework, and work with a group of people who are all moving
    in the same direction. We also need the right architecture, tools, and patterns/practices
    to deliver successfully. In summary, our approach must consider:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The size of our app
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason we are developing the app
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The skill level of developers
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterative and incremental delivery
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant forward flow of features
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the cloud things
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideally, we need to maintain optimal engineering overhead. Our architecture
    should support our short-term needs while being extensible, so we can pivot in
    different directions if our mid-or long-term needs change without having to rewrite
    large swaths of code. Consider the following diagram, in contrast to the ones
    about small and large enterprise apps in the previous section:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_05.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Ideal architectural journey of a LOB app'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Router-first architecture aims to help you find the balance in the engineering
    overhead, feature delivery, and flexibility of your codebase. However, you must
    bring the discipline yourself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_003.png) or Shu Ha Ri is a concept that can help bring discipline
    to your work. It is a way of thinking that instructs you first to master the basics
    without worrying about the underlying theory, then master the theory, and finally
    be able to adapt what you mastered to your needs. However, if you skip steps 1
    or 2, you are going to find yourself adapting the wrong thing in the wrong way.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Having covered the *what*, *why*, *when*, *where*, and *who*, let's jump into
    the *how* in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Router-first architecture
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Router-first architecture is a way to:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '**Enforce** high-level thinking'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensure** consensus on features, *before* you start coding'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan** for your codebase/team to grow'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Introduce** little engineering overhead'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are seven steps to implementing router-first architecture:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Develop a roadmap and scope (*Chapter 7*)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design with lazy loading in mind (*Chapter 7*)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a walking-skeleton navigation experience (*Chapter 7*)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Achieve a stateless, data-driven design (*Chapters 7* and *10*)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enforce a decoupled component architecture (*Chapters 8*, *11*, and *12*)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate between user controls and components (*Chapter 11*)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分用户控件和组件（*第11章*）
- en: Maximize code reuse with TypeScript and ES features (*Chapters 8*, *10*, *11*,
    and *12*)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用TypeScript和ES功能最大化代码复用（*第8章*、*第10章*、*第11章*和*第12章*）
- en: Each step will be covered in more detail in this and coming chapters, as noted
    previously. Before we go over these steps at a high level, let's first cover feature
    modules in Angular, which are an important fundamental technical concept.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个步骤将在本章和后续章节中更详细地介绍。在我们从高层次概述这些步骤之前，让我们首先介绍Angular中的功能模块，这是一个重要的基本技术概念。
- en: Feature modules
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能模块
- en: In *Chapter 1*, *Introduction to Angular and Its Concepts*, we covered Angular's
    architecture at a high level and introduced the concepts of lazy loading and routing.
    Feature modules are a key component in implementing lazy loading. There are two
    kinds of modules, the root module and feature modules. Modules are implemented
    by the class `NgModule`. An `NgModule` contains all the necessary metadata to
    render components and inject services. A component without a module doesn't do
    much.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*Angular及其概念简介*中，我们以高层次介绍了Angular的架构，并介绍了懒加载和路由的概念。功能模块是实现懒加载的关键组件。有两种类型的模块：根模块和功能模块。模块通过`NgModule`类实现。`NgModule`包含渲染组件和注入服务所需的所有必要元数据。没有模块的组件几乎不起作用。
- en: 'An Angular application is defined by an `NgModule` that sits at the root of
    the application. This is called the root module. The root module is responsible
    for rendering what appears in the `<app-root>` element in your `index.html` file.
    Locate the root module in the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular应用程序由一个位于应用程序根部的`NgModule`定义。这被称为根模块。根模块负责渲染`index.html`文件中的`<app-root>`元素中显示的内容。在以下图中定位根模块：
- en: '![](img/B14094_07_06.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_06.png)'
- en: 'Figure 7.6: Major architectural components of Angular'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Angular的主要架构组件
- en: An NgModule can contain many other NgModules. An Angular app only has one root
    module, so by definition every other NgModule becomes a feature module. In the
    preceding diagram, you can see that you can organize a group of components (**Cmp**)
    and services (**Svc**) into feature modules. Grouping functionality into modules
    allows us to organize our code into chunks, which can be separated from the initial
    payload of our application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个NgModule可以包含许多其他NgModules。Angular应用程序只有一个根模块，因此根据定义，每个其他NgModule都成为功能模块。在前面的图中，你可以看到可以将一组组件（**Cmp**）和服务（**Svc**）组织到功能模块中。将功能分组到模块中允许我们将代码组织成块，这些块可以与应用程序的初始负载分离。
- en: This idea of root and feature modules represents a parent/child relationship,
    which is a concept that extends to other functionality and frameworks. For example,
    note that the preceding diagram injects a root router into the root module. A
    root router can have child routes. Child routes can be configured to load feature
    modules. Similarly, NgRx has root and feature module-level stores to organize
    the state data of your application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根模块和功能模块的概念代表了父/子关系，这是一个扩展到其他功能和框架的概念。例如，注意前面的图中将根路由注入到根模块中。根路由可以有子路由。子路由可以配置为加载功能模块。同样，NgRx有根模块和功能模块级别的存储来组织应用程序的状态数据。
- en: 'For all intents and purposes, any mention of a sub-module, child module, or
    a feature module in this book refers to the same thing: a module that is not the
    root module.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就本书而言，任何提及的子模块、子模块或功能模块都指的是同一件事：不是根模块的模块。
- en: Feature modules and child routes allows for a separation of concerns between
    major components of your application. Two teams can work on two different modules
    without interfering with each other. This separation means that any dependency
    required by a feature module must be explicitly added to the imports, declarations,
    or providers of that module. This can seem repetitive and annoying, when sharing
    code between modules, but it is a necessary evil.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 功能模块和子路由允许将应用程序的主要组件之间的关注点分离。两个团队可以同时工作在不同的模块上，而不会相互干扰。这种分离意味着任何功能模块所需的依赖项都必须明确添加到该模块的导入、声明或提供者中。当在模块之间共享代码时，这可能会显得重复且令人烦恼，但这是必要的恶行。
- en: In Angular, by default, services are singletons – one instance per module. Before
    importing a service that's already imported to the root module into a feature
    module, consider if this is truly the desired behavior. A service that is provided
    in the root module is available to be imported in a feature module without needing
    to be provided again. Providing a service in the root and feature modules will
    result in having multiple instances of that service in memory, which breaks your
    expectation that, by default, services are singletons. In *Chapter 8*, *Designing
    Authentication and Authorization*, you will see this in action when we implement
    the `AuthService`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，默认情况下，服务是单例的——每个模块一个实例。在将已导入根模块的服务导入功能模块之前，考虑这是否真的是期望的行为。在根模块中提供的服务可以在功能模块中导入，而无需再次提供。在根模块和功能模块中提供服务会导致内存中有多个该服务的实例，这打破了默认情况下服务是单例的预期。在*第8章*，*设计身份验证和授权*中，当我们实现`AuthService`时，你将看到这一行为的具体实现。
- en: 'With the introduction of the Ivy rendering engine in Angular 9, the road is
    paved to create self-describing components. Self-describing components do not
    need an NgModule to be useful. With future versions of Angular it will be possible
    to implement simple apps without the whole ceremony (read: boilerplate code) of modules.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Angular 9中Ivy渲染引擎的引入，创建自描述组件的道路已经铺平。自描述组件不需要NgModule就能发挥作用。随着Angular未来版本的推出，将能够实现无需整个仪式（即：样板代码）的简单应用。
- en: Now, let's go over the seven steps of router-first architecture at a high level.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从高层次上概述一下路由优先架构的七个步骤。
- en: Developing a roadmap and scope
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制定路线图和确定范围
- en: Developing a roadmap and establishing the scope of your project early on is
    critical to getting the high-level architecture right. Creating a backlog, wireframes,
    mock-ups and interactive prototypes will help you define the map before getting
    on the road and capture the vision concretely. It is important to remember to
    bring tools only when necessary. Don't start with Photoshop, when a piece of paper
    and a pencil will do. If stakeholders and team members understand what is being
    developed, then it will be possible to deliver your solution iteratively and incrementally.
    However, don't fall into the perfection trap. Save the tweaking and furniture
    rearranging for after the fundamentals are in place and agreed upon.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目早期就制定路线图和确定项目范围对于确保高级架构的正确性至关重要。创建待办事项列表、线框图、原型和交互式原型将帮助你确定路线图，在开始之前捕捉到具体愿景。重要的是要记住，只有在必要时才携带工具。不要一开始就使用Photoshop，一张纸和一支铅笔就足够了。如果利益相关者和团队成员了解正在开发的内容，那么就有可能迭代和逐步交付你的解决方案。然而，不要陷入完美的陷阱。在基本要素到位并获得一致同意之后，再进行微调和家具调整。
- en: Document every artifact you create. Later in the chapter we cover how you can
    leverage GitHub Wikis to store your artifacts.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 记录你创建的每一个工件。在本章的后面部分，我们将介绍如何利用GitHub Wikis来存储你的工件。
- en: Later in this chapter, we will go over how to develop a roadmap and a technique
    to define your scope, building on the roadmap building techniques covered in *Chapter 3*,
    *Creating a Basic Angular App*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将介绍如何制定路线图和定义范围的技术，这些技术是在*第3章*，*创建基本的Angular应用*中介绍的路线图构建技术的基础上进行的。
- en: Designing with lazy loading in mind
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以懒加载为设计理念
- en: First-paint matters, a lot! According to Google Analytics data gathered by the
    Angular Team in 2018, 53% of mobile users abandoned a website when load times
    exceeded 3 seconds. During the same time period most websites were consumed on mobile
    devices, around 70%+ in the US and 90%+ in China. As we covered in *Chapter 5*,
    *Delivering High-Quality UX with Material*, UI libraries and static assets can
    add significant size to your application. Given that most content is consumed
    on mobile, it's very important to defer the loading of non-critical assets.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首次绘制非常重要！根据Angular团队在2018年收集的Google Analytics数据，53%的移动用户在加载时间超过3秒时放弃了网站。在同一时间段内，大多数网站都是在移动设备上被消费的，在美国约为70%以上，在中国约为90%以上。正如我们在*第5章*，*使用Material提供高质量UX*中所述，UI库和静态资产可以显著增加你的应用程序的大小。鉴于大多数内容都是在移动设备上被消费的，延迟加载非关键资产非常重要。
- en: We defer loading of assets by divvying up the parts of our Angular application
    into feature modules. This way Angular can load only the assets that are necessary
    to render the current screen and dynamically download further resources as they
    are needed. A good way to divide your application into feature modules is by defining
    the various user roles your application may use. User roles normally indicate
    the job function of a user, such as a manager or data-entry specialist. In technical
    terms, they can be thought of as a group of actions that a particular class of
    user is allowed to execute. After all, a data-entry specialist won't ever see
    most of the screens that a manager can, so why deliver those assets to those users
    and slow down their experience?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将我们的Angular应用程序的部分划分为功能模块来延迟加载资源。这样，Angular只能加载渲染当前屏幕所需的资源，并在需要时动态下载进一步的资源。将你的应用程序划分为功能模块的一个好方法是通过定义应用程序可能使用的各种用户角色。用户角色通常表示用户的职能，例如经理或数据录入专员。从技术角度来说，它们可以被视为一组特定类别的用户被允许执行的操作。毕竟，数据录入专员永远不会看到经理可以看到的大多数屏幕，那么为什么要把这些资源提供给这些用户并减慢他们的体验呢？
- en: Lazy loading is critical in creating a scalable application architecture, allowing
    you to deliver high-quality and efficient products. Lazy loading is a low-hanging
    fruit that we will tackle as a baseline design goal. It can be costly to implement
    lazy loading after the fact.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载对于创建可扩展的应用程序架构至关重要，它允许你交付高质量和高效的产品。懒加载是一个低垂的果实，我们将将其作为基本设计目标来处理。在事后实现懒加载可能会很昂贵。
- en: Starting with Angular 9, it is possible to lazy load individual components.
    Angular 9's Ivy rendering engine enables self-describing and standalone components.
    Components that do not require all the bootstrapping that an Angular application
    requires have the potential to revolutionize and simplify how we design applications.
    However, it is not yet feasible to design apps this way. Expect future versions
    of Angular to introduce public APIs that make it easy to use the new features,
    reducing the need to carefully design feature modules early on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Angular 9 开始，可以懒加载单个组件。Angular 9 的 Ivy 渲染引擎使得组件具有自描述性和独立性。那些不需要Angular应用程序所需的所有引导的组件有可能彻底改变并简化我们设计应用程序的方式。然而，目前还无法以这种方式设计应用程序。期待Angular的未来版本引入公共API，使其能够轻松使用新功能，减少早期精心设计功能模块的需求。
- en: Later in this chapter, you will learn about how to implement lazy loading using
    feature modules.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将学习如何使用功能模块实现懒加载。
- en: Implementing a walking-skeleton
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个行走骨架
- en: Configuring lazy loading can be tricky, which is why it is essential to nail
    down a walking-skeleton navigation experience early on. Implementing a clickable
    version of your app will help you gather feedback from users early on. That way,
    you'll be able to work out fundamental workflow and integration issues quickly.
    Additionally, you'll be able to establish a concrete representation of the scope
    of your current development effort. Developers and stakeholders alike will be
    able to better visualize how the end product will look.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 配置懒加载可能很棘手，这就是为什么在早期就确定行走骨架导航体验至关重要。实现一个可点击的应用程序版本将帮助你尽早收集用户反馈。这样，你将能够快速解决基本的工作流程和集成问题。此外，你将能够确立当前开发工作的具体范围。开发人员和利益相关者都将能够更好地可视化最终产品的外观。
- en: A walking-skeleton also sets the stage for multiple teams to work in tandem.
    Multiple people can start developing different feature modules or components at
    the same time, without worrying about how the puzzle pieces are going to come
    together later on. By the end of this chapter, you will have completed implementing
    the walking-skeleton of the sample app LemonMart.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 行走骨架也为多个团队协同工作奠定了基础。多个人可以同时开始开发不同的功能模块或组件，而不必担心这些拼图碎片将来如何拼合在一起。到本章结束时，你将完成实现示例应用程序
    LemonMart 的行走骨架。
- en: Achieve a stateless, data-driven design
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现无状态、数据驱动的架构
- en: As highlighted in *Chapter 10*, *RESTful APIs and Full-Stack Implementation*,
    stateless design in full-stack architecture is critical to implementing a maintainable
    application. As covered in *Chapter 1*, *Introduction to Angular and Its Concepts*,
    and later in *Chapter 12*, *Recipes – Master/Detail, Data Tables, and NgRx*, the
    flux pattern and NgRx make it possible to achieve an immutable state for your
    application. However, the flux pattern is likely to be overkill for most applications.
    NgRx itself leverages a lot of the core technologies present in RxJS.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 10 章“RESTful API 和全栈实现”中强调的那样，在全栈架构中实现无状态设计对于构建可维护的应用程序至关重要。如第 1 章“Angular
    简介及其概念”和第 12 章“食谱 - 主/详细、数据表和 NgRx”中所述，Flux 模式和 NgRx 使得为应用程序实现不可变状态成为可能。然而，Flux
    模式对于大多数应用程序来说可能过于复杂。NgRx 本身利用了 RxJS 中许多核心技术。
- en: We are going to use RxJS and the reactive programming paradigm to implement
    a minimal, stateless, and data-driven pattern for our application. Identifying
    major data entities, such as invoices or people, that your users will work with
    is going to help you avoid over-engineering your application. Designing around
    major data entities will inform API design early on, and help define `BehaviorSubject`
    data anchors that you will use to achieve a stateless, data-driven design. That
    design will, in turn, ensure a decoupled component architecture, as detailed in
    *Chapter 6*, *Forms, Observables, and Subjects*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 RxJS 和响应式编程范式来实现一个最小化、无状态和以数据驱动的模式来构建我们的应用程序。识别用户将要操作的主要数据实体，例如发票或人员，将帮助您避免过度设计应用程序。围绕主要数据实体进行设计将在早期就指导
    API 设计，并帮助定义您将用于实现无状态、数据驱动设计的 `BehaviorSubject` 数据锚点。这种设计反过来将确保一个解耦的组件架构，如第 6
    章“表单、Observables 和 Subjects”中详细所述。
- en: By defining observable data anchors, you can ensure that data across various
    components will be kept in sync. By writing functional reactive code, leveraging
    RxJS features, and not storing state in components, we can implement immutable
    data streams.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义可观察的数据锚点，您可以确保各个组件之间的数据保持同步。通过编写功能响应式代码，利用 RxJS 功能，并在组件中不存储状态，我们可以实现不可变的数据流。
- en: We will cover how to design the data models for your application in *Chapter
    10*, *RESTful APIs and Full-Stack Implementation*, and will continue using these
    models in the following chapters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 10 章“RESTful API 和全栈实现”中介绍如何设计应用程序的数据模型，并在接下来的章节中继续使用这些模型。
- en: Enforce a decoupled component architecture
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制实施解耦的组件架构
- en: As we discussed in *Chapter 1*, *Introduction to Angular and Its Concepts*,
    decoupling components of your architecture is critical in ensuring a maintainable
    codebase. In Angular, you can decouple components by leveraging `@Input` and `@Output`
    bindings and Router orchestration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在第 1 章“Angular 简介及其概念”中讨论的那样，解耦架构中的组件对于确保代码库的可维护性至关重要。在 Angular 中，您可以通过利用
    `@Input` 和 `@Output` 绑定以及路由编排来实现组件的解耦。
- en: Bindings will help you maintain a simple hierarchy of components, and avoid
    using dynamic templates in situations where static designs are more effective,
    such as the creation of multi-page forms.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定将帮助您维护一个简单的组件层次结构，并在静态设计更有效的情况下避免使用动态模板，例如创建多页表单。
- en: Router outlets and auxiliary paths allow you to compose your view using the
    router. Resolvers can help load data by consuming router parameters. Auth guards
    can help control access to various modules and components. Using router links,
    you can dynamically customize elements that a user will see in an immutable and
    predictable way, similar to the way we designed and developed data anchors in
    the previous step.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 路由出口和辅助路径允许您使用路由来组合视图。解析器可以通过消耗路由参数来帮助加载数据。身份验证守卫可以帮助控制对各种模块和组件的访问。使用路由链接，您可以以动态和可预测的方式定制用户将看到的元素，类似于我们在上一步中设计和开发数据锚点的方式。
- en: If you ensure every component is responsible for loading its own data, then
    you can compose components via URLs. However, overusing the router can in itself
    become an anti-pattern. If a parent component logically owns a child component,
    then the effort to decouple them will be wasted.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确保每个组件都负责加载自己的数据，那么您可以通过 URL 来组合组件。然而，过度使用路由本身可能成为一种反模式。如果一个父组件在逻辑上拥有一个子组件，那么解耦它们的努力将是徒劳的。
- en: In *Chapter 6*, *Forms, Observables, and Subjects*, you learned how to enable
    component interactions using `BehaviorSubject`. In *Chapter 11*, *Recipes – Reusability,
    Routing, and Caching*, you will learn how to implement `@Input` and `@Output`
    bindings and in the upcoming chapters you will learn about how to implement router
    features.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章“表单、可观察对象和主题”中，你学习了如何使用 `BehaviorSubject` 启用组件交互。在第 11 章“食谱 - 可重用性、路由和缓存”中，你将学习如何实现
    `@Input` 和 `@Output` 绑定，在接下来的章节中，你将学习如何实现路由功能。
- en: Differentiate between user controls and components
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分用户控件和组件。
- en: Another important idea is differentiating user controls from components. A user
    control is like a custom date input, or a custom star rater. It is often highly
    interactive and dynamic code that ends up being highly coupled, convoluted, and
    complicated code. Such controls may use Angular features no one has ever heard
    of before, which are most likely not covered in this book.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的观点是区分用户控件和组件。用户控件就像自定义日期输入或自定义星级评分器。它通常是高度交互性和动态的代码，最终会变成高度耦合、复杂和复杂的代码。这样的控件可能会使用到之前没有人听说过的
    Angular 特性，这些特性很可能在本书中没有涉及。
- en: A component is more like a form with fields, which may contain simple date inputs
    or a star rater. Because forms encapsulate business functionality, their code
    must be easy to read and understand. Your code should stick to Angular basics,
    so the code is stable and easy to maintain, like most of the code that is presented
    in this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 组件更像是带有字段的表单，可能包含简单的日期输入或星级评分器。因为表单封装了业务功能，所以其代码必须易于阅读和理解。你的代码应遵循 Angular 基础，这样代码就稳定且易于维护，就像本书中展示的大多数代码一样。
- en: By differentiating between user controls and components you can make better
    decisions when deciding what kind of code you want to make reusable. Creating
    reusable code is costly. If you create the right reusable code, you can save time
    and resources. If you create the wrong reusable code, then you can waste a lot
    of time and resources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过区分用户控件和组件，你可以在决定想要创建哪种可重用代码时做出更好的决策。创建可重用代码是有成本的。如果你创建了正确的可重用代码，你可以节省时间和资源。如果你创建了错误的可重用代码，那么你可能会浪费大量的时间和资源。
- en: Wire-framing allows you to identify reusable elements early on. User controls
    will help keep user interaction code separate from business logic. Well-crafted
    component reuse will enable you to encapsulate domain-specific behavior, and share it
    later.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计允许你早期识别可重用元素。用户控件将帮助将用户交互代码与业务逻辑分离。精心设计的组件重用将使你能够封装特定领域的行怍，并在以后共享。
- en: It's important to identify self-contained user controls that encapsulate unique
    behaviors that you wish to create for your app. User controls will likely be created
    as directives or components that have data-binding properties and tightly coupled
    controller logic and templates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 识别封装你希望为你的应用程序创建的独特行为的自包含用户控件是很重要的。用户控件很可能会以指令或具有数据绑定属性和紧密耦合的控制器逻辑和模板的组件的形式创建。
- en: Components, on the other hand, leverage router life cycle events to parse parameters
    and perform CRUD operations on data. Identifying these component reuses early
    on will result in creating more flexible components that can be reused in multiple
    contexts (as orchestrated by the router), maximizing code reuse.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，组件利用路由生命周期事件来解析参数并在数据上执行 CRUD 操作。早期识别这些组件重用将导致创建更多灵活的组件，这些组件可以在多个上下文中重用（由路由器编排），从而最大化代码重用。
- en: We will cover how to create reusable components and user controls in *Chapter
    11*, *Recipes – Reusability, Routing, and Caching*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 11 章“食谱 - 可重用性、路由和缓存”中介绍如何创建可重用组件和用户控件。
- en: Maximize code reuse with TypeScript and ES
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TypeScript 和 ES 最大化代码重用。
- en: It's essential to remember the underlying features of the language you work
    with before you consider the features offered by Angular, RxJS, and all the libraries
    you use. There are decades of software engineering fundamentals that you can leverage
    to write readable and maintainable code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 Angular、RxJS 以及你使用的所有库提供的功能之前，记住你所使用语言的底层特性是至关重要的。你可以利用数十年的软件工程基础来编写可读性和可维护性强的代码。
- en: 'First and foremost is the DRY principle. It stands for don''t repeat yourself.
    So, don''t copy-paste code. Don''t just change a variable or two. Proactively
    refactor your code to make your functions stateless and reusable. In a few words:
    don''t repeat yourself, don''t repeat yourself, and don''t repeat yourself.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Leverage object-oriented design. Move behavior to classes; if your person has
    a `fullName` property, don't re-implement the same logic in a dozen different
    places, but implement it once in the `person` class. This means you will need
    to become familiar with hydration, also known as injecting a JSON object into
    a newly instantiated class, and serialization using `toJSON`. It is important
    not to abuse OOP. You should still remain stateless, and functional, by avoiding
    storing state in class parameters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: You can truly unleash the power of OO design by leveraging generics, inheritance,
    and abstract classes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript introduces the concept of interfaces to JavaScript. Interfaces are
    a concept mostly reserved for statically typed languages. An interface represents
    an abstract notion of what an object can do, without specifying any implementation
    details. Furthermore, an interface can be used to document the shape of data.
    For example, you can write a partial interface of a third-party API to document
    the fields you're interested in consuming. When other developers read your code,
    they have an inherent understanding of the structure of the data they're consuming,
    without having to read documentation on another website.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces also allow you to morph the shape of your data in a well-defined
    manner. So, you can write a transform function to transform the shape of external
    data into internal data. TypeScript will catch any errors you may make. Taking
    this concept further, you can also use interfaces to flatten data. If the data
    you receive has a multi-entity relational structure, you can flatten the relationship
    to decouple the design of the data from your UI code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Don't overly flatten your data. Arrays and simple shapes for common objects
    are okay, such as a name object or commonly used domain-specific object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: You should also avoid string literals in your code. Writing business logic where
    you compare `'apples' !== 'Oranges'` results in unmaintainable code. You should
    leverage `enums` in TypeScript, so your code isn't subject to the spelling mistakes
    of coders or changing business requirements. So `'oranges' === Fruit.Organes`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Beyond TypeScript and ECMAScript, Angular also offers helpful functions for
    you to reuse logic. Angular validators, pipes, route resolvers, and route guards
    all allow you to share code across components and templates.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chapters will demonstrate the aforementioned concepts:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Designing Authentication and Authorization*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 10*, *RESTful APIs and Full-Stack Implementation*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 11*, *Recipes – Reusability, Routing, and Caching*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 12*, *Recipes – Master/Detail, Data Tables, and NgRx*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's start by creating, LemonMart™, a fully featured line-of-business
    app that you can use as a template to kickstart your next professional project.
    LemonMart is a robust and realistic project that can support feature growth and
    different backend implementations, and it comes with a complete and configurable
    authentication and authorization solution out of the box.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Since its introduction, LemonMart has served more than 160,000 lemons to over
    14,000 developers. Zesty! ![](img/B14094_07_001.png)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You can always clone the finished project from GitHub, [https://www.github.com/duluca/lemon-mart](https://www.github.com/duluca/lemon-mart),
    whenever you need it. Let's jump right into it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Creating LemonMart
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LemonMart will be a mid-sized line-of-business application with over 90 code
    files. We will start our journey by creating a new Angular app, with routing and
    Angular Material configured from the get-go.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: It is presumed that you have installed all the requisite software mentioned
    in *Chapter 2*, *Setting Up Your Development Environment*. If you have not, execute
    the following commands for your OS to configure your environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows PowerShell, execute:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On macOS Terminal, execute:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For more information refer to [https://github.com/duluca/web-dev-environment-setup](https://github.com/duluca/web-dev-environment-setup).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Creating a router-first app
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the router-first approach, we want to enable routing early on in our application:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: You can create the new application, with routing already configured, by executing
    this command.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that `@angular/cli` is not installed globally, or you may run into errors:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting with Angular 9, you may use `--strict` to turn on TypeScript features
    like `noImplicitAny`, `noImplicitReturns`, `noFallthroughCasesInSwitch`, and `strictNullChecks`.
    These options will decrease the chances of making coding mistakes, but result
    in more verbose code. In my opinion, that is a good thing, and this option is
    highly recommended for production-bound applications.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A new `AppRoutingModule` file has been created for us:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will be defining routes inside the routes array. Note that the routes array
    is passed in to be configured as the root routes for the application; the default
    root route is `/`.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When configuring your `RouterModule`, you can pass in additional options to
    customize the default behavior of the Router, such as when you attempt to load
    a route that you''re already on. Normally, if the route you''re attempting to
    navigate to is the same as the current one, the router wouldn''t take any action.
    However, if you wanted the router to refresh the page, you would customize the
    default behavior of the router, such as with `RouterModule.forRoot(routes, { onSameUrlNavigation:
    ''reload'' })`. With this setting in place, if you navigate to the same URL that
    you are on, you will force a reload of the current component.'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, `AppRoutingModule` is registered with `AppModule`, as shown:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Configuring Angular and VS Code
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly apply configuration steps covered in *Chapters 2-6* run the following
    commands:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The following scripts do not require you to use VS Code. If you wish to use
    another IDE like WebStorm, the `npm` scripts that are configured will run equally
    well.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Angular VS Code task:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Apply the Angular VS Code configuration:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Install the npm Scripts for the Docker task:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Apply the npm Scripts for the Docker configuration:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Implement an npm script to build your application in production mode named `build:prod`
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These settings are continually tweaked to adapt to the ever-evolving landscape
    of extensions, plug-ins, Angular, and VS Code. Always make sure to install a fresh
    version of the task by re-running the `install` command to get the latest version.
    Alternatively, you can use the Angular Evergreen extension for VS Code, to run
    the configuration commands with one click.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if the preceding configuration scripts fail to execute, then the
    following npm scripts will also fail. In this case, you have two options: revert
    your changes and ignore these scripts, or manually implement these scripts as
    covered in earlier chapters (or as demonstrated on GitHub).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Execute `npm run style:fix`
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm run lint:fix`
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm start` and ensure you're running on `http://localhost:5000`, instead
    of the default port `4200`
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to *Chapter 2*, *Setting Up Your Development Environment*, for further
    configuration details.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You may optionally setup npm Scripts for AWS ECS, which is used in *Chapter
    13*, *Highly Available Cloud Infrastructure on AWS*, by using `mrm-task-npm-aws`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the mrm tasks refer to:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/expertly-simple/mrm-task-angular-vscode](https://github.com/expertly-simple/mrm-task-angular-vscode)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/expertly-simple/mrm-task-npm-docker](https://github.com/expertly-simple/mrm-task-npm-docker)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/expertly-simple/mrm-task-npm-aws](https://github.com/expertly-simple/mrm-task-npm-aws)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Material and Styles
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will also need to set up Angular Material and configure a theme to use,
    as covered in *Chapter 5*, *Delivering High-Quality UX with Material*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Angular Material:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In `material.module.ts`, define a `const` `modules` array and export `MatButtonModule`,
    `MatToolbarModule`, and `MatIconModule`, removing `CommonModule`
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `app.modules.ts`, import `FlexLayoutModule` so Angular Flex Layout can be
    activated
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Append common CSS to `styles.css` as shown in the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Update your application's title in `index.html`
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to *Chapter 5*, *Delivering High-Quality UX with Material*, for further
    configuration details.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We will apply custom branding to the app later in this chapter. Next, let's
    start designing our line-of-business application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Designing LemonMart
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to build a rudimentary roadmap to follow, from the database
    to the frontend, while also avoiding over-engineering. This initial design phase
    is critical to the long-term health and success of your project, where any existing
    silos between teams must be broken down and an overall technical vision well understood
    by all members of the team. This is easier said than done, and there are volumes
    of books written on the topic.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In engineering, there's no one right answer to a problem, so it is important
    to remember that no one person can ever have all the answers, nor a crystal-clear
    vision. It is important that technical and non-technical leaders create a safe
    space with opportunities for open discussion and experimentation as part of the
    culture. The humility and empathy that comes along with being able to court such
    uncertainty as a team is as important as any single team member's technical capability.
    Every team member must be comfortable with checking their egos at the door because
    our collective goal will be to grow and evolve an application to ever-changing
    requirements during the development cycle. You will know that you have succeeded
    if individual parts of the software you created are easily replaceable by anyone.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start by developing a roadmap and identifying the scope of our application.
    For this, we will be defining user roles and then building a site map, to create
    a vision of how our app might work.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Identifying user roles
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step of our design will be to think about who is using the application
    and why.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'We envision four user states, or roles, for LemonMart:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated; any authenticated user would have access to their profile
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cashier, whose sole role is to check out customers
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clerk, whose sole role is to perform inventory-related functions
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manager, who can perform all actions a cashier and a clerk can perform but also
    have access to administrative functions
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, we can start to create a high-level design for our app.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Identifying high-level modules with a site map
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Develop a high-level site map of your application, as shown:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_07.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Landing pages for users'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'I used MockFlow.com''s SiteMap tool to create the site map shown: [https://sitemap.mockflow.com](https://sitemap.mockflow.com).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon first examination, three high-level modules emerge as lazy-loading candidates:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**Point of Sale (POS)**'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inventory**'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Manager**'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Cashier will only have access to the **POS** module and component. The
    Clerk will only have access to the **Inventory** module, which will include additional
    screens for the **Stock Entry**, **Products**, and **Categories** management components:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_08.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Inventory pages'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the **Manager** will be able to access all three modules with the
    **Manager** module, including user management and receipt lookup components:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_09.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Manager pages'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: There'll be great benefits from enabling lazy loading for all three modules;
    since Cashiers and Clerks will never use components belonging to other user roles,
    there's no reason to send those bytes down to their devices. This means as the
    **Manager** module gains more advanced reporting features, or new roles are added
    to the application, the **POS** module will be unaffected by the bandwidth and
    memory impact of an otherwise growing application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: This means fewer support calls, and consistent performance on the same hardware
    for a much longer period of time.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Generating router-enabled modules
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our high-level components defined as **Manager**, **Inventory**,
    and **POS**, we can define them as modules. These modules will be different from
    the ones you''ve created so far, for routing and Angular Material. We can create
    the user profile as a component on the app module; however, note that user profile
    will only ever be used for already-authenticated users, so it makes sense to define
    a fourth module only meant for authenticated users in general. This way, you will
    ensure that your app''s first payload remains as minimal as possible. In addition,
    we will create a Home component to contain the landing experience for our app
    so that we can keep implementation details out of `app.component`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate `manager`, `inventory`, `pos`, and `user` modules, specifying their
    target module and routing capabilities:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As discussed in *Chapter 2*, *Setting Up Your Development Environment*, if you
    have configured `npx` to automatically recognize `ng` as a command, you can save
    some more keystrokes because you won't have to append `npx` to your commands every
    time. Do not globally install `@angular/cli`.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note the abbreviated command structure, where `ng generate module manager` becomes
    `ng g m manager`, and similarly, `--module` becomes `-m`.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that you don't have CLI errors.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that using `npx` on Windows may throw an error such as `Path must be a
    string. Received undefined`. This error doesn't seem to have any effect on the
    successful operation of the command, which is why it is critical to always inspect
    what the CLI tool generated.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that the folder and the files are created:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Examine how `ManagerModule` has been wired.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A feature module implements an `@NgModule` similar to `app.module`. The biggest
    difference is that a feature module does not implement the `bootstrap` property,
    which is required for your root module to initialize your Angular app:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since we have specified the `-m` option, the module has been imported into
    `app.module`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition, because we also specified the `--routing` option, a routing module
    has been created and imported into `ManagerModule`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that `RouterModule` is being configured using `forChild`, as opposed to
    `forRoot`, which was the case for the `AppRouting` module. This way, the router
    understands the proper relationship between routes defined in different modules'
    contexts and can correctly prepend `/manager` to all child routes in this example.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The CLI doesn't respect your `tslint.json` settings. If you have correctly configured
    your VS Code environment with Prettier, your code styling preferences will be
    applied as you work on each file or globally when you run the `prettier` command.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to run your `style:fix` and `lint:fix` commands before moving on. Now,
    let's design how the landing page for LemonMart will look and work.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Designing the home route
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following mock-up as the landing experience for LemonMart:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_10.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: LemonMart landing experience'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `LocalCastWeather` app, we don't want all this markup to be in the
    `App` component. The `App` component is the root element of your entire application;
    therefore, it should only contain elements that will persistently appear throughout
    your application. In the following annotated mock-up, the toolbar marked as **1**
    will be persistent throughout the app.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The area marked as **2** will house the `home` component, which itself will
    contain a login user control, marked as **3**:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_11.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: LemonMart layout structure'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: It's best practice to create your default or landing component as a separate
    element in Angular. This helps reduce the amount of code that must be loaded and
    logic executed in every page, but it also results in a more flexible architecture
    when utilizing the router.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the `home` component with inline template and styles:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that a component with an inline template and a style is also referred to
    as a **Single File Component** or an **SFC**.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are ready to configure the router.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Setting up default routes
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s get started with setting up a simple route for LemonMart. We need to
    set up the `/` route (also known as the empty route) and the `/home` routes to
    display the `HomeComponent`. We also need a wildcard route to capture all undefined
    routes and display a `PageNotFoundComponent`, which also needs to be created:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure your `home` route:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We first define a path for `'home'` and inform the router to render `HomeComponent`
    by setting the `component` property. Then, we set the default path of the application
    `''` to be redirected to `'/home'`. By setting the `pathMatch` property, we always
    ensure that this very specific instance of the `home` route will be rendered as
    the landing experience.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a `pageNotFound` component with an inline template
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure a wildcard route for `PageNotFoundComponent`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This way, any route that is not matched will be directed to the `PageNotFoundComponent`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: RouterLink
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a user lands on the `PageNotFoundComponent`, we would like them to be
    redirected to the `HomeComponent` using the `routerLink` direction:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'On `PageNotFoundComponent`, replace the inline template to link back to `home`
    using `routerLink`:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This navigation can also be done via an `<a href>` tag implementation; however,
    in more dynamic and complicated navigation scenarios, you will lose features such
    as automatic active link tracking or dynamic link generation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The Angular bootstrap process will ensure that `AppComponent` is inside the
    `<app-root>` element in your `index.html`. However, we must manually define where
    we would like `HomeComponent` to render, to finalize the router configuration.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Router outlet
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AppComponent` is considered a root element for the root router defined in
    `app-routing.module`, which allows us to define outlets within this root element
    to dynamically load any content we wish using the `<router-outlet>` element:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Configure `AppComponent` to use inline template and styles, deleting any existing
    content in the html and css files
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the toolbar for your application
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the name of your application as a button link so that it takes the user
    to the home page when clicked on
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `<router-outlet>` for the content to render:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the contents of `home` will render inside `<router-outlet>`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Branding, customization, and Material icons
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to construct an attractive and intuitive toolbar, we must introduce
    some iconography and branding to the app so that the users can easily navigate
    through the app with the help of familiar icons.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Branding
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In terms of branding, you should ensure that your web app has a custom color
    palette and integrates with desktop and mobile browser features to bring forward
    your app's name and iconography.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Color palette
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pick a color palette using the Material Color tool, as discussed in *Chapter
    5*, *Delivering High-Quality UX with Material*. Here''s the one I picked for LemonMart:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[https://material.io/resources/color/#!/?view.left=0&view.right=0&primary.color=2E7D32&secondary.color=C6FF00](https://material.io/resources/color/#!/?view.left=0&view.right=0&primary.color=2E7D32&secondary.color=C6FF00).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Rename `custom-theme.scss` to `lemonmart-theme.scss`
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `angular.json` with the new theme file name
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Configure your custom theme with the chosen color palette
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also grab LemonMart-related assets from GitHub at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: For the Local Weather app, we replaced the `favicon.ico` file to brand our app
    in the browser. While this would've been enough ten years ago, today's devices
    vary wildly, and each platform can leverage optimized assets to better represent
    your web app within their operating systems. Next, let's implement a more robust
    favicon.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Implementing browser manifest and icons
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to ensure that the browser shows the correct title text and icon in
    a **Browser** tab. Further, a manifest file should be created that implements
    specific icons for various mobile operating systems, so that if a user pins your
    website, a desirable icon is displayed similar to other app icons on a phone.
    This will ensure that if a user favorites or pins your web app on their mobile
    device''s home screen, they''ll get a native-looking app icon:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Create or obtain an SVG version of your website's logo from a designer or a
    site like [https://www.flaticon.com](https://www.flaticon.com )
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, I will be using the likeness of the Eureka Lemon:![](img/B14094_07_12.png)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.12: LemonMart''s signature logo'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When using images you find on the internet, pay attention to applicable copyrights.
    In this case, I have purchased a license to be able to publish this lemon logo,
    but you may grab your own copy at the following URL, given that you provide the
    required attribution to the author of the image: [https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070).'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Generate the `favicon.ico` and manifest files using a tool such as [https://realfavicongenerator.net](https://realfavicongenerator.net
    )
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust settings for iOS, Android, Windows Metro, and macOS Safari to your liking
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you set a version number, as favicons can be notorious with caching;
    a random version number will ensure that users always get the latest version
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and extract the generated `favicons.zip` file into your `src` folder
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `angular.json` file to include the new assets in your app:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Insert the generated code in the `<head>` section of your `index.html`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Please put the preceding HTML after your favicon declaration, but before your
    style imports. The order does matter. Browsers load data top down. You want your
    application's icon to be parsed before the user has to wait for CSS files to be
    downloaded.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that your new favicon displays correctly
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your basic branding work has been completed, consider if you'd like to
    establish a more unique look and feel with theming.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Custom themes
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may further customize Material''s look and feel, to achieve a unique experience
    for your app, by leveraging tools listed on [https://material.io/tools](https://material.io/tools)
    and some other tools that I have discovered, which are listed as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Material Theme Editor (retired as of March 2020) is a plugin for the popular
    design app Sketch on macOS to create a theme that is more than skin deep. An alternative
    tool is yet to be announced, but you can find resources you can continue to use
    in the meantime on the blog post linked at [https://material.io/tools/theme-editor](https://material.io/tools/theme-editor)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Theme Builder is an alternative to build custom themes that work in the
    browser on Glitch.com at [https://material-theme-builder.glitch.me](https://material-theme-builder.glitch.me
    )
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Design Theme Palette Generator will generate the necessary code to define
    your custom color palette to create truly unique themes at [http://mcg.mbitson.com](http://mcg.mbitson.com
    )
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color Blender helps with finding midway points between two colors, which is
    useful when defining in-between colors for the color swatches, located at [https://meyerweb.com/eric/tools/color-blend](https://meyerweb.com/eric/tools/color-blend
    )
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a wealth of information on [https://material.io](https://material.io)
    on the in-depth philosophy behind Material design, with great sections on things
    like the color system, [https://material.io/design/color/the-color-system.html](https://material.io/design/color/the-color-system.html),
    which dives deep into selecting the right color palette for your brand and other
    topics such as creating a dark theme for your app.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to distinguish your brand from other apps or your competitors.
    Creating a high-quality custom theme will be a time-consuming process; however,
    the benefits of creating a great first impression with your users are considerable.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will show you how you can add custom icons to your Angular apps.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Custom icons
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s add your custom branding inside your Angular app. You will need
    the svg icon you used to create your favicon:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Place the image under `src/assets/img/icons`, named `lemon.svg`
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `app.module.ts`, import `HttpClientModule` to `AppComponent` so that the
    `.svg` file can be requested over HTTP
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `AppComponent` to register the new svg file as an icon:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the icon to the toolbar:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now let's add the remaining icons for menu, user profile, and logout.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Material icons
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular Material works out of the box with the Material Design icon font, which
    is automatically imported into your app as a web font in your `index.html`. It
    is possible to self-host the font; however, if you go down that path, you don't
    get the benefit if the user's browser has already cached the font from when they
    visited another website, which could save the speed and latency of downloading
    a 42-56 KB file in the process. The complete list of icons can be found at [https://material.io/icons/](https://material.io/icons/).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s update the toolbar with some icons and set up the home page with
    a minimal template for a fake login button:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the Material icons `<link>` tag has been added to `index.html`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instructions on how to self-host can be found under the **Self Hosting** section
    at [http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons).
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once configured, working with Material icons is easy.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On `AppComponent`, update the toolbar to place a **Menu** button to the left
    of the title.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `fxFlex` directive so that the remaining icons are right aligned.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add user profile and logout icons:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On `HomeComponent`, add a minimal template for a login experience, replacing any
    existing content:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your app should look similar to this screenshot:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_13.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: LemonMart with minimal login'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: There's still some work to be done, in terms of implementing and showing/hiding
    the menu, profile, and logout icons, given the user's authentication status. We
    will cover this functionality in *Chapter 8*, *Designing Authentication and Authorization*.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In order to debug the router, get a visualization of your routers, and tightly
    integrate Chrome debugging features using Angular Augury, see *Appendix A,* *Debugging
    Angular*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've set up basic routing for your app, we can move on to setting
    up lazily loaded modules with subcomponents. If you're not familiar with troubleshooting
    and debugging Angular, please refer to the *Appendix A**, Debugging Angular*,
    before moving forward.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Feature modules with lazy loading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways resources are loaded: eagerly or lazily. When the browser
    loads up the `index.html` for your app, it starts processing it top to bottom.
    First the `<head>` element is processed, then the `<body>`. For example, the CSS
    resources we defined in the `<head>` of our app will be downloaded before our
    app is rendered, because our Angular app is defined as a `<script>` in the `<body>`
    of the HTML file.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: When you use the command `ng build`, Angular leverages the webpack module bundler
    to combine all the JavaScript, HTML, and CSS into minified and optimized JavaScript
    bundles.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: If you don't leverage lazy loading in Angular, the entire contents of your app
    will be eagerly loaded. The user won't see the first screen of your app until
    all screens are downloaded and loaded.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading allows the Angular build process, working in tandem with webpack,
    to separate your web application into different JavaScript files called chunks.
    We can enable this chunking by separating out portions of the application into
    feature modules. Feature modules and their dependencies can be bundled into separate
    chunks. Remember that the root module and its dependencies will always be in the
    first chunk that is downloaded. So, by chunking our application's JavaScript bundle
    size, we keep the size of the initial chunk at a minimum. With a minimal first
    chunk, no matter how big your application grows, the time to first meaningful
    paint remains constant. Otherwise, your app would take longer and longer to download
    and render as you add more features and functionality to it. Lazy loading is critical
    to achieving a scalable application architecture.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following graphic to determine which routes are eagerly loaded
    and which ones are lazily loaded:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_14.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Angular router eager vs lazy loading'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rootRouter` defines three routes: `a`, `b`, and `c`. `/master` and `/detail`
    represent named router outlets, which are covered in *Chapter 12*, *Recipes –
    Master/Detail, Data Tables, and NgRx*. Route `a` is the default route for the
    app. Routes `a` and `c` are connected to the `rootRouter` with a solid line, whereas
    route `b` is connected using a dashed line. In this context, route `b` is configured
    as a lazy-loaded route. This means that route `b` will dynamically load a feature
    module, called **BModule**, that contains its `childRouter`. This `childRouter`
    can define any number of components, even reusing route names that were reused
    elsewhere. In this case, `b` defines three additional routes: `d`, `e`, and `f`.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example router definition for the `rootRouter`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that the definitions for routes `d`, `e`, and `f` do not exist in the
    `rootRouter`. See the example router definition for the `childRouter`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see the routes defined in the `childRouter` are independent of the
    ones defined in the `rootRouter`. Child routes exist in a hierarchy, where `/b`
    is the parent path. To navigate to the `DComponent`, you must use the path `/b/d`,
    whereas, to navigate to `CComponent`, you can just use `/c`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Given this example configuration, every component defined in the `rootRouter`
    and their dependencies would be in the first chunk of our app, and thus eagerly
    loaded. The first chunk would include the components `A`, `Master`, `Detail`,
    `C`, and `PageNotFound`. The second chunk would contain the components `D`, `E`,
    and `F`. This second chunk would not be downloaded or loaded until the user navigated
    to a path starting with `/b`; thus, it's lazily loaded.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: In the book I only cover the well-established method of lazily loaded feature
    modules. Check out John Papa's blog post on creating lazily loading components
    at [https://johnpapa.net/angular-9-lazy-loading-components/](https://johnpapa.net/angular-9-lazy-loading-components/).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: We will now go over how to set up a feature module with components and routes.
    We will also use Augury to observe the effects of our various router configurations.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Configuring feature modules with components and routes
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The manager module needs a landing page, as shown in this mock-up:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_15.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Manager''s dashboard'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the home screen for the `ManagerModule`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ManagerHome` component:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In order to create the new component under the `manager` folder, we must prefix
    `manager/` in front of the component name. In addition, we specify that the component
    should be imported and declared with the `ManagerModule`. Since this is another
    landing page, it is unlikely to be complicated enough to require separate HTML
    and CSS files. You can use `--inline-style` (alias `-s`) and/or `--inline-template`
    (alias `-t`) to avoid creating additional files.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that your folder structure looks as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Configure the `ManagerHome` component''s route with `manager-routing.module`,
    similar to how we configured the `Home` component with `app-route.module`:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that `http://localhost:5000/manager` doesn't actually resolve to a component
    yet, because our Angular app isn't aware that `ManagerModule` exists. Let's first
    try the brute-force, eager-loading approach to import `ManagerModule` and register
    the manager route with our app.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Eager loading
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by eagerly loading the `ManagerModule`, so we can see how importing
    and registering routes in the root module doesn''t result in a scalable solution:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `ManagerModule` in `app.module.ts`:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will note that `http://localhost:5000/manager` still doesn't render its
    `home` component.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use **Augury** to debug the router state, as shown:![](img/B14094_07_16.png)
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.16: Router tree with eager loading'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that at the time of publishing, Augury''s support for the Ivy rendering
    engine is not great. In order to reliably view the **Router Tree** tab, you need
    to disable Ivy. You can do so by adding the following setting to the `tsconfig.app.json`
    file in your project:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will need to restart your Angular app and reload Augury for changes to take
    effect. However, getting the pretty diagram is not worth accidentally shipping
    your app with Ivy disabled. Be careful with this one!
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It seems as if the `/manager` path is correctly registered and pointed at the
    correct component, `ManagerHomeComponent`. The issue here is that the `rootRouter`
    configured in `app-routing.module` isn't aware of the `/manager` path, so the
    `**` path is taking precedence and rendering the `PageNotFoundComponent` instead.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `''manager''` path in `app-routing.module.ts` and assign `ManagerHomeComponent`
    to it, so we can see what happens:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](img/B14094_07_17.png)'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.17: Manager home renders with duplicate path registration'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As shown in the image above, `http://localhost:5000/manager` renders correctly,
    by displaying manager-home works! However, when you debug the router state through
    Augury, note that the `ManagerHomeComponent` is registered twice. This is because
    both the `rootRouter` and the `childRouter` registrations are being picked up.
    To avoid this issue, we would have to centralize all path creation in the `rootRouter`
    and not use child routers.
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Centralizing all paths in the `rootRouter` doesn't scale well, because it forces
    all developers to maintain a single master file to import and configure every
    module. It is ripe for merge conflicts and frustrating exchanges between team
    members. As a file grows larger, the chances of introducing a bug increase exponentially,
    where the same route could unintentionally be registered multiple times.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is possible to engineer a solution to divide up the modules into multiple
    files. Instead of the standard `*-routing.module`, you could implement a new routes
    array in `ManagerModule` and import it to the `rootRouter`. Let's fix the duplicate
    registration issue.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In `manager.module.ts`, remove `ManagerRoutingModule` from the imports array.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `manager.module.ts`, implement a `Routes` array and set an empty path for
    the component `ManagerHomeComponent` as shown:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `app-routing.module.ts`, import the array you just created and assign it
    to the `children` property of the `''manager''` path:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Don't forget to remove the `component` property and the import for `ManagerHomeModule`.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s inspect the **Router Tree** on Augury again to see if we resolved the
    duplicate registration issue:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_18.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: Router Tree with children routes'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: The provided solution works. There are no duplicate registrations, because we
    stopped using the `childRouters` in `manager-routing.module.ts`. In addition,
    we maintained some separation of concerns, by not importing `ManagerHomeComponent`
    outside of `ManagerModule`, resulting in a more scalable solution. However, as
    the app grows, we must still register all modules with `app.module.ts`. As a result,
    feature modules are still tightly coupled to the root module in potentially unpredictable
    ways. Further, this code can't be chunked, because the feature module is directly
    imported in `app.module.ts`, so the TypeScript compiler sees it as a required
    dependency.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's transform our configuration into a lazily loading one.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand how eager loading of modules works, you will be able
    to better understand the code we are about to write, which may otherwise seem
    like black magic, and magical (also known as misunderstood) code always leads
    to spaghetti architectures.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now evolve the eager loading solution to be a lazy loading one. In
    order to load routes from a different module, we know we can''t simply import
    them, otherwise they will be eagerly loaded. The answer lies in configuring a
    route using the `loadChildren` attribute with an inline import statement informing
    the router how to load a feature module in `app-routing.module.ts`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that any module you intend to lazy load is not imported in `app.module.ts`,
    so remove the `ManagerModule` from the `imports`.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `Routes` array added to `ManagerModule`.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add back the `ManagerRoutingModule` to `imports` in `ManagerModule`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `app-routing.module.ts`, implement or update the `''manager''` path with
    the `loadChildren` attribute:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Lazy loading is achieved via a clever trick that avoids using an import statement
    at the file level. A function delegate is set to the `loadChildren` property,
    which contains an inline import statement defining the location of the feature
    module file, such as `./manager/manager.module`, allowing us to refer to `ManagerModule`
    in a type-safe manner without actually fully loading it. The inline import statement
    can be interpreted during the build process to create a separate JavaScript chunk
    that can be downloaded only when needed. `ManagerModule` then acts as if its own
    Angular app and manages all its children dependencies and routes.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `manager-routing.module` routes, considering that `manager` is now
    their root route:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can now update the route for `ManagerHomeComponent` to a more meaningful
    `'home'` path. This path won't clash with the one found in `app-routing.module`,
    because in this context, `'home'` resolves to `'manager/home'` and, similarly,
    where `path` is empty, the URL will look like `http://localhost:5000/manager`.
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Restart your `ng serve` or `npm start` command, so Angular can chunk the app
    properly.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:5000/manager`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that lazy loading is working by looking at Augury, as follows:![](img/B14094_07_19.png)
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.19: Router tree with lazy loading'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The root node for `ManagerHomeComponent` is now named **manager [Lazy]**.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully set up a feature module with lazy loading. Next, let's
    implement the walking skeleton for LemonMart.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Completing the walking skeleton
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the site map we created for LemonMart earlier in the chapter, we need
    to complete the walking skeleton navigation experience for the app. In order to
    create this experience, we will need to create some buttons to link all modules
    and components together. We will go at this module by module.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, update the login button on the `HomeComponent` to navigate
    to the `''manager''` path using the `routerLink` attribute and rename the button:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, we can navigate to the `ManagerHome` component by clicking on the **Login**
    button.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: The manager module
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we already enabled lazy loading for `ManagerModule`, let's go ahead and
    complete the rest of the navigational elements for it.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current setup, `ManagerHomeComponent` renders in the `<router-outlet>`
    defined in `AppComponent`''s template, so when the user navigates from `HomeComponent`
    to `ManagerHomeComponent`, the toolbar implemented in `AppComponent` remains in
    place. See the following mock-up for **Manager''s Dashboard**:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_20.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: App-wide and feature module toolbars'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: The app-wide toolbar remains in place no matter where we navigate to. You can
    imagine that we can implement a similar toolbar for the feature module that persists
    throughout `ManagerModule`. So, the navigational buttons **User Management** and
    **Receipt Look-up** would always be visible. This allows us to create a consistent
    UX for navigating subpages across modules.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a secondary toolbar, we need to replicate the parent-child relationship
    between `AppComponent` and `HomeComponent`, where the parent implements the toolbar
    and a `<router-outlet>` so that children elements can be rendered in there:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the base `manager` component:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `--flat` option skips directory creation and places the component directly
    under the `manager` folder, just like `app.component` residing directly under
    the `app` folder.
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `ManagerComponent`, implement a navigational toolbar with `activeLink` tracking:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It must be noted that feature modules don't automatically have access to services
    or components created in parent modules. This is an important default behavior
    to preserve a decoupled architecture. However, there are certain cases where it
    is desirable to share some amount of code. In this case, `mat-toolbar` needs to
    be reimported. Since the `MatToolbarModule` is already loaded in `src/app/material.module.ts`,
    we can just import this module into `manager.module.ts` and there will not be
    a performance or memory penalty for doing so.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure `ManagerComponent` is declared and `MaterialModule` is imported in `ManagerModule`:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create components for the subpages:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the parent-children routing. We know that we need the following routes
    to be able to navigate to our subpages, as follows:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to target the `<router-outlet>` defined in `ManagerComponent`, we
    need to create a parent route first and then specify routes for the subpages:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should now be able to navigate through the app. When you click on the **Login
    as Manager** button, you will be taken to the page shown here. The clickable targets
    are highlighted, as shown:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_21.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: Manager''s Dashboard with all router links highlighted'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: If you click on **LemonMart**, you will be taken to the home page. If you click
    on **Manager's Dashboard**, **User Management**, or **Receipt Lookup**, you will
    be navigated to the corresponding subpage, while the active link will be bold
    and underlined on the toolbar.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: User module
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Upon login, users will be able to access their profiles and view a list of
    actions they can access in the LemonMart app through a side navigation menu. In
    *Chapter 8*, *Designing Authentication and Authorization*, when we implement authentication
    and authorization, we will be receiving the role of the user from the server.
    Based on the role of the user, we will be able to automatically navigate or limit
    the options users can see. We will implement these components in this module so
    that they will only be loaded once a user is logged in. For the purpose of completing
    the walking skeleton, we will ignore authentication-related concerns:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the necessary components:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Implement routing.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start with implementing the lazy loading in `app-routing.module.ts`:'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Ensure that the `PageNotFoundComponent` route is always the last route in `app-routing.module`.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now implement the child routes in `user-routing.module.ts`:'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are implementing routing for `NavigationMenuComponent`, because it'll be
    directly used as an HTML element. In addition, since `UserModule` doesn't have
    a landing page, there's no default path defined.
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `AppComponent`, wire up the user and logout icons:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Icon buttons can be cryptic, so it's a good idea to add tooltips to them. In
    order for tooltips to work, switch from the `mat-icon-button` directive to the
    `mat-mini-fab` directive and ensure that you import `MatTooltipModule` in `material.module.ts`.
    In addition, ensure that you add `aria-label` for icon-only buttons so that users
    with disabilities relying on screen readers can still navigate your web application.
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that the app works.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll note that the two buttons are too close to each other, as follows:'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14094_07_22.png)'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.22: Toolbar with icons'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can fix the icon layout issue by adding `fxLayoutGap="8px"` to `<mat-toolbar>`;
    however, now the lemon logo is too far apart from the app name, as shown:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B14094_07_23.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: Toolbar with padded icons'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'The logo layout issue can be fixed by merging the icon and the button:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As shown in the following screenshot, the grouping fixes the layout issue:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_24.png)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: Toolbar with grouped and padded elements'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: This is more desirable from a UX perspective also; now users can go back to
    the home page by clicking on the lemon as well.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: POS and inventory modules
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our walking skeleton presumes the role of the manager. To be able to access
    all components we are about to create, we need to enable the manager to be able
    to access POS and inventory modules.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `ManagerComponent` with two new buttons:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that these router links will navigate us out of the realm of the `ManagerModule`,
    so it is normal for the manager-specific secondary toolbar to disappear.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Now, it'll be up to you to implement the last two remaining modules. For the
    two new modules, I provide high-level steps and refer you to a previous module
    you can model the new one on. If you get stuck refer to the `projects/ch7` folder
    on the GitHub project at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: POS module
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PosModule` is very similar to the `UserModule`, except that `PosModule` was
    a default path. The `PosComponent` will be the default component. This has the
    potential to be a complicated component with some subcomponents, so don''t use
    inline templates or styles:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Create the `PosComponent`
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register `PosComponent` as the default path
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure lazy loading for `PosModule`
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the app works
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's implement the inventory module.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Inventory module
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`InventoryModule` is very similar to `ManagerModule`, as shown:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_25.png)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.25: Inventory Dashboard mock-up'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Create a base `Inventory` component
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the `MaterialModule`
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create **Inventory Home**, **Stock Entry**, **Products**, and **Categories**
    components
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure parent-children routes in `inventory-routing.module.ts`
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure lazy loading for `InventoryModule`
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a secondary toolbar for internal `InventoryModule` navigation in `InventoryComponent`
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the app works, as shown:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B14094_07_26.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.26: LemonMart Inventory Dashboard'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Now that the walking skeleton of the app is completed, it is important to inspect
    the router tree to ensure that lazy loading has been configured correctly and
    modules aren't unintentionally being eagerly loaded.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the router tree
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigate to the base route of the app and use Augury to inspect the router
    tree, as illustrated:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_27.png)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.27: Router tree with lazy loading'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Everything but the initially required components should be denoted with the
    **[Lazy]** attribute. If, for some reason, routes are not denoted with **[Lazy]**,
    chances are that they are mistakenly being imported in `app.module.ts` or some
    other component.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: In your router tree, you may notice that `ProfileComponent` and `LogoutComponent`
    are eagerly loaded, whereas the `UserModule` is correctly labeled as **[Lazy]**.
    Even multiple visual inspections through the tooling and the codebase may leave
    you searching for the culprit. However, if you run a global search for `UserModule`,
    you'll quickly discover that it was being imported into `app.module.ts`. When
    running CLI commands, your module may inadvertently get re-imported into `app.module.ts`,
    so keep an eye out for this!
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'To be on the safe side, inspect your `app.module.ts` file and be sure to remove
    any import statements for modules or components that are not at the root level.
    Your file should look like the following one:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you disabled Ivy while debugging your routes with Augury, now's the time
    to re-enable it.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: It is expected that the reader resolves any testing errors before moving on.
    Ensure that `npm test` and `npm run e2e` execute without errors.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Common testing module
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a lot of modules to deal with, it becomes tedious to configure
    the imports and providers for each spec file individually. For this purpose, I
    recommend creating a common testing module to contain generic configuration that
    you can reuse across the board.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: First start by creating a new `.ts` file
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Create `common/common.testing.ts`.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate it with common testing providers, fakes, and modules.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I have provided fake implementations of `ObservableMedia`, `MatIconRegistry`,
    and `DomSanitizer`, along with arrays for `commonTestingProviders` and `commonTestingModules`:'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now let''s see a sample use of this shared configuration file:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Most other modules will just need `commonTestingModules` to be imported.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Stop! Did you ensure all your unit tests are passing? To ensure that your tests
    are always passing implement a CI pipeline in CircleCI, as demonstrated in *Chapter
    4*, *Automated Testing, CI, and Releasing to Production*.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: With your tests up and running, the walking skeleton for LemonMart is completed.
    Now, let's look ahead and start thinking about what kinds of data entities we
    might be working with.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Designing around major data entities
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth step in router-first architecture is achieving a stateless, data-driven
    design. To achieve this, it helps a lot to organize your APIs around major data
    components. This will roughly match how you consume data in various components in
    your Angular application. We will start off by defining our major data components
    by creating a rough data **entity relationship diagram** (**ERD**). In *Chapter
    10*, *RESTful APIs and Full-Stack Implementation*, we will design and implement
    an API for the user data entity using Swagger.io and Express.js.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by taking a stab at what kind of entities you would like to store
    and how these entities might relate to one another.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample design for LemonMart, created using [draw.io](http://draw.io):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_28.png)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.28: ERD for LemonMart'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, whether your entities are stored in a SQL or NoSQL database
    is inconsequential. My suggestion is to stick to what you know, but if you're
    starting from scratch, a NoSQL database like MongoDB will offer the most flexibility
    as your implementation and requirements evolve.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, you will need CRUD APIs for each entity. Considering these
    data elements, we can also imagine some user interfaces around these CRUD APIs.
    Let's do that next.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: High-level UX design
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mock-ups are important in determining what kind of components and user controls
    we will need throughout the app. Any user control or component that will be used
    across components will need to be defined at the root level and others scoped
    with their own modules.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we identified the sub modules and designed landing
    pages for them to complete the walking skeleton. Now that we have defined the
    major data components, we can complete mock-ups for the rest of the app. When
    designing screens at a high level, keep several things in mind:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Can a user complete common tasks required for their role with as little navigation
    as possible?
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can users readily access all information and functionality of the app through
    visible elements on the screen?
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can a user search for the data they need easily?
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a user finds a record of interest, can they drill down into detail records
    or view related records with ease?
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is that pop-up alert really necessary? You know users won't read it, right?
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that there's no one right way to design any user experience, which
    is why when designing screens, you should always keep modularity and reusability
    in mind.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Creating an artifacts Wiki
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, it is important to document every artifact
    you create. Wikis offer a way to create living documentation that can be collaboratively
    updated or edited. While Slack, Teams, email, and whiteboards offer good collaboration
    opportunities, their ephemeral nature leaves a lot to be desired.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as you generate various design artifacts, such as mock-ups or design decisions,
    take care to post them on a wiki reachable by all team members:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub, switch over to the **Wiki** tab
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may check out my sample wiki at [https://github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki),
    as shown:![](img/B14094_07_29.png)
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.29: GitHub.com LemonMart wiki'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When creating a wiki page, ensure that you cross-link between any other documentation
    available, such as **Readme**
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that GitHub shows subpages on the wiki under **Pages**
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, an additional summary is helpful, such as the **Design Artifacts**
    section, since some people may miss the navigational element on the right
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you complete mock-ups, post them on the wiki
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see a summary view of the wiki here:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_30.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.30: Summary view of LemonMart mock-ups'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Now that your artifacts are in a centralized place, it is accessible by all
    team members. They can add, edit, update, or groom the content. This way your
    wiki becomes useful, living documentation of the information that your team needs,
    as opposed to a piece of documentation you feel like you're being forced to create.
    Raise your hand if you've ever found yourself in that situation!
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_002.png)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
- en: Next, integrate your mock-ups into your app, so you can collect early feedback
    from your stakeholders and test out the flow of your application.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging mock-ups in your app
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the mock-ups in the walking skeleton app so that testers can better envision
    the functionality that is yet to be developed. See an example of this idea in
    action here:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_07_31.png)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.31: Using mock-ups in the UI to verify flow of app'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: This will also be helpful when designing and implementing your authentication
    and authorization workflow. With the mock-ups completed, we can now continue the
    implementation of LemonMart's authentication and authorization workflow in *Chapter
    8*, *Designing Authentication and Authorization*.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you mastered how to effectively use the Angular CLI to create
    major Angular components and scaffolds. You became familiar with the 80-20 rule.
    You created the branding of your app, leveraging custom and built-in Material
    iconography. You learned how to debug complicated router configurations with Augury.
    Finally, you began building router-first apps, defining user roles early on, designing
    with lazy loading in mind, and nailing down a walking-skeleton navigation experience
    early on. We went over designing around major data entities. We also covered the
    importance of completing and documenting high-level UX design of our entire app
    so that we can properly design a great conditional navigation experience.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, in order to pull off a router-first implementation, you need to do
    this:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Develop a roadmap and scope
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design with lazy loading in mind
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a walking-skeleton navigation experience
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Achieve a stateless, data-driven design
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enforce a decoupled component architecture
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate between user controls and components
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximize code reuse with TypeScript and ES6
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, you executed steps 1-3; in the next four chapters, you will
    execute steps 4-7\. In *Chapter 8*, *Designing Authentication and Authorization*,
    we will tap into OOP design and inheritance and abstraction, along with a deep
    dive into security considerations and designing a conditional navigation experience.
    In *Chapter 10*, *RESTful APIs and Full-Stack Implementation*, you will see a
    concrete full-stack implementation using the Minimal MEAN stack. *Chapter 11*,
    *Recipes – Reusability, Routing, and Caching*, and *Chapter 12*, *Recipes – Master/Detail,
    Data Tables, and NgRx*, we will tie everything together by sticking to a decoupled
    component architecture, smartly choosing between creating user controls and components,
    and maximizing code reuse with various TypeScript, RxJS, and Angular coding techniques.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Ha, Not Ready to Ri: The Shu Ha Ri Approach to Agile Development*, Brian Sjoberg,
    Ken Furlong, July 29, 2015, [https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development](https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development).'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Angular 9: Lazy Loading Components*, John Papa, February 16, 2020, [https://johnpapa.net/angular-9-lazy-loading-components/](https://johnpapa.net/angular-9-lazy-loading-components/).'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webpack module bundler, [https://webpack.js.org/](https://webpack.js.org/).
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: What is the Pareto principle?
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main goals of router-first architecture?
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the root module and a feature module?
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of lazy loading?
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why create a walking skeleton of your application?
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
