- en: Chapter 3.  More Angular 2 – SPA, Routing, and Data Flows in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。更多Angular 2-SPA，路由和深入的数据流
- en: If the previous chapter was about building our first useful app in Angular,
    then this chapter is about adding a whole lot of Angular goodness to it. Within
    the learning curve, we have made a start in exploring a technology platform and
    now we can build some rudimentary apps using Angular. But that's just the start!
    There is a lot more to learn before we can make effective use of Angular in a
    decent-sized application. This chapter takes us one step closer to realizing this
    goal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上一章是关于在Angular中构建我们的第一个有用的应用程序，那么这一章是关于为其添加大量的Angular功能。在学习曲线中，我们已经开始探索技术平台，现在我们可以使用Angular构建一些基本的应用程序。但这只是开始！在我们能够在一个相当大的应用程序中有效使用Angular之前，还有很多东西要学习。这一章让我们离实现这个目标更近了一步。
- en: The *7 Minute Workout* app still has some rough edges/limitations that we can
    fix while making the overall app experience better. This chapter is all about
    adding those enhancements and features. And as always, this app-building process
    provides us with enough opportunities to enhance our understanding of the framework
    and learn new things about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*应用程序仍然有一些不足之处/限制，我们可以在改善整体应用程序体验的同时解决这些问题。这一章就是关于添加这些增强和功能的。而且，像往常一样，这个应用程序构建过程为我们提供了足够的机会来增强我们对框架的理解，并学习关于它的新知识。'
- en: 'The topics we cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: '**Exploring Angular Single Page Applications** (**SPA**): We explore Angular''s
    Single Page Application capabilities, which include route navigation, link generation,
    and routing events.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Angular单页应用程序（SPA）：我们探索Angular的单页应用程序功能，包括路由导航、链接生成和路由事件。
- en: '**Understanding Dependency Injection**: One of the core platform features.
    In this chapter, we learn how Angular makes effective use of dependency injection
    to inject components and services across the application.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解依赖注入：这是核心平台功能之一。在本章中，我们将学习Angular如何有效利用依赖注入，在整个应用程序中注入组件和服务。
- en: '**Angular pure (stateless) and impure (stateful) pipes**: We explore the primary
    data transformation construct of Angular, pipes, in more detail as we build some
    new pipes.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular纯（无状态）和不纯（有状态）管道：我们将更详细地探索Angular的主要数据转换构造，管道，同时构建一些新的管道。
- en: '**Cross-component communication**: Since Angular is all about components and
    their interactions, we look at how to do cross-component communication in a parent-child
    and sibling component setup. We learn how Angular template variables and events
    facilitate this communication.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨组件通信：由于Angular完全涉及组件及其交互，我们将看看如何在父子和同级组件设置中进行跨组件通信。我们将学习Angular模板变量和事件如何促进这种通信。
- en: '**Creating and consuming events**: We learn how a component can expose its
    own events and how to bind to these events from template HTML and from other components.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用事件：我们将学习组件如何公开自己的事件，以及如何从模板HTML和其他组件绑定到这些事件。
- en: AS a side note, I expect you are using the *7 Minute Workout* on a regular basis
    and working on your physical fitness. If not take a 7-minute exercise break and
    exercise now. I insist!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个旁注，我希望你经常使用*7分钟锻炼*并关注你的身体健康。如果没有，请休息七分钟并进行锻炼。我坚持！
- en: Hope the workout was fun! Now let's get back to some serious business. Let's
    start with exploring Angular Single Page Application (SPA) capabilities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 希望锻炼很有趣！现在让我们回到一些严肃的事情。让我们开始探索Angular单页应用程序（SPA）的功能。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are starting from where we left off in [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "Chapter 2.  Building Our First App - 7 Minute Workout"), *Building Our First
    App - 7 Minute Workout*. The git branch `checkpoint2.4` can serve as the base
    for this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第2章](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "第2章。构建我们的第一个应用程序-7分钟锻炼")中离开的地方开始，*构建我们的第一个应用程序-7分钟锻炼*。git分支`checkpoint2.4`可以作为本章的基础。
- en: The code is also available on GitHub ([https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可在GitHub上获取（[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)），供所有人下载。检查点在GitHub上作为分支实现。
- en: If you are not using git, download the snapshot of `checkpoint2.4` (a ZIP file)
    from the GitHub location [http://bit.ly/ng2be-checkpoint2-4](http://bit.ly/ng2be-checkpoint2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用git，请从GitHub位置[http://bit.ly/ng2be-checkpoint2-4](http://bit.ly/ng2be-checkpoint2-4)下载`checkpoint2.4`的快照（ZIP文件）。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Exploring Single Page Application capabilities
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单页应用程序的能力
- en: The *7 Minute Workout* starts when we load the app, but it ends with the last
    exercise sticking to the screen permanently. Not a very elegant solution. Why
    don't we add a start and finish page to the app? This makes the app more professional
    and allows us to understand the single-page nomenclature of AngularJS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*从加载应用程序开始，但以最后一次锻炼永久停留在屏幕上结束。这不是一个非常优雅的解决方案。为什么我们不在应用程序中添加开始和结束页面呢？这使应用程序更专业，并且可以让我们理解AngularJS的单页面命名法。'
- en: The Angular SPA infrastructure
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular SPA基础设施
- en: With modern web frameworks such as Angular (Angular 1.x) and Ember, we are now
    getting used to apps that do not perform full page refreshes. But if you are new
    to this scene it's worth mentioning what these SPAs are.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代Web框架（如Angular（Angular 1.x）和Ember），我们现在习惯于不执行完整页面刷新的应用程序。但是，如果您是新手，值得一提的是这些单页应用程序（SPAs）是什么。
- en: Single Page Applications (SPAs) are browser-based apps devoid of any full page
    refresh. In such apps, once the initial HTML is loaded, any future page navigations
    are retrieved using AJAX as HTML fragments and injected into the already loaded
    view. Google Mail is a great example of a SPA. SPAs make for a great user experience
    as the user gets a desktop app-like feel, with no constant post-backs and page
    refreshes, which are typically associated with traditional web apps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序（SPAs）是基于浏览器的应用程序，不需要进行完整的页面刷新。在这种应用程序中，一旦加载了初始HTML，任何未来的页面导航都是使用AJAX作为HTML片段检索并注入到已加载的视图中。谷歌邮件是SPA的一个很好的例子。SPAs为用户提供了极佳的用户体验，因为用户可以获得类似桌面应用程序的感觉，而无需不断的后退和页面刷新，这通常与传统Web应用程序相关联。
- en: Like its predecessor, Angular 2 too provides the necessary constructs for SPA
    implementation. Let's understand them and add our app pages too.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与其前身一样，Angular 2也为SPA实现提供了必要的构造。让我们了解它们并添加我们的应用程序页面。
- en: Angular routing
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular路由
- en: Angular supports SPA development using its routing infrastructure. This infrastructure
    tracks browser URLs, enables hyperlink generation, exposes routing events, and
    provides a set of directives/components for view.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用其路由基础设施支持SPA开发。该基础设施跟踪浏览器URL，启用超链接生成，公开路由事件，并提供一组用于视图的指令/组件。
- en: 'There are four major framework pieces that work together to support the Angular
    routing infrastructure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个主要的框架部分共同支持Angular路由基础设施：
- en: '**The Router (Router)**: The primary infrastructure piece that actually provides
    component navigation'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器（Router）**：实际提供组件导航的主要基础设施'
- en: '**Routing configuration (Route)**: The component router is dependent upon the
    routing configuration for setting up routes'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由配置（Route）**：组件路由器依赖于路由配置来设置路由'
- en: '**RouterOutlet component**: The `RouterOutlet` component is the placeholder
    container (*host*) where route-specific views are loaded'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RouterOutlet组件**：`RouterOutlet`组件是路由特定视图加载的占位符容器（*主机*）'
- en: '**RouterLink directive**: This generates hyperlinks that can be embedded in
    the anchor tags for navigation'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RouterLink指令**：这会生成可以嵌入到锚标签中用于导航的超链接'
- en: 'The following diagram highlights the roles these components play within the
    routing setup:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表突出显示了这些组件在路由设置中所扮演的角色：
- en: '![Angular routing](../Images/image00446.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Angular routing](../Images/image00446.jpeg)'
- en: I highly encourage everyone to keep revisiting this diagram as we set up routing
    for *7 Minute Workout*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈鼓励每个人在为*7分钟锻炼*设置路由时不断回顾这个图表。
- en: '*Router* is the central piece of this complete setup; therefore a quick overview
    of the router will be helpful.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器是这个完整设置的核心部分；因此，对路由器的快速概述将会很有帮助。
- en: Angular router
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角度路由器
- en: If you have worked with any JavaScript framework with SPA support, this is how
    things work. The framework watches the browser URL and serves views based on the
    URL loaded. There are dedicated framework components for this job. In the Angular
    world, this tracking is done by a *framework service*, the router.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过带有SPA支持的任何JavaScript框架，这就是它的工作原理。框架监视浏览器URL，并根据加载的URL提供视图。有专门的框架组件来完成这项工作。在Angular世界中，这种跟踪是由*框架服务*，即路由器来完成的。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Angular, any class, object, or function that provides some generic functionality
    is termed a **service**. Angular does not provide any special construct to declare
    a service as it does for components, directives, and pipes. Anything that can
    be consumed by components/directives/pipes can be termed a service. Router is
    one such service. And there are many more services that are part of the framework.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，任何提供一些通用功能的类、对象或函数都被称为**服务**。Angular没有提供任何特殊的构造来声明服务，就像它为组件、指令和管道所做的那样。任何可以被组件/指令/管道消耗的东西都可以被称为服务。路由器就是这样的一个服务。还有许多其他作为框架一部分的服务。
- en: If you are from the Angular 1 realm, this is a pleasant surprise-no service,
    factory, provider, value, or constant!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Angular 1领域，这是一个令人愉快的惊喜-没有服务、工厂、提供者、值或常量！
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When building a component try to delegate as much functionality as possible
    to a service. Components should only act as a mediator that helps in synchronizing
    the component model and the view state
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建组件时，尽量将尽可能多的功能委托给服务。组件应该只充当帮助同步组件模型和视图状态的中介者
- en: 'The Angular router is there to:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 角度路由器的作用是：
- en: Enable navigation between components on route change
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由更改时在组件之间启用导航
- en: Pass routing data between component views
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件视图之间传递路由数据
- en: Make the state of the currently route available to active/loaded components
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使当前路由的状态对活动/加载的组件可用
- en: Provide APIs that allow navigation for component code
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供允许组件代码导航的API
- en: Track the navigation history, allowing us the move back and forward between
    component views using browser buttons
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪导航历史，允许我们使用浏览器按钮在组件视图之间前进和后退
- en: Provide life cycle events and guard conditions that allow us to affect navigation
    based on some external factors
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供生命周期事件和守卫条件，允许我们根据一些外部因素影响导航
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The router also supports some advance routing concepts such as parent-child
    routes. This gives us the ability to define routes at multiple levels inside the
    component tree. The parent component can define routes and child components can
    further add more sub-routes to the parent route definition. This is something
    that we cover in detail in [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器还支持一些高级路由概念，如父子路由。这使我们能够在组件树的多个级别定义路由。父组件可以定义路由，子组件可以进一步添加更多的子路由到父路由定义中。这是我们在[第4章](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "第4章。个人教练")中详细介绍的内容，*构建个人教练*。
- en: The router does not work alone. As highlighted in the preceding diagram, it
    depends upon other framework pieces to achieve the desired results. Let's add
    some app pages and work with each piece of the puzzle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器不能单独工作。正如前面的图表所示，它依赖于其他框架部分来实现期望的结果。让我们添加一些应用页面，并与每个拼图的每个部分一起工作。
- en: Routing setup
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由设置
- en: For the component router to work, we first need to reference it as the router
    is not part of the core framework.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使组件路由器工作，我们首先需要将其引用，因为路由器不是核心框架的一部分。
- en: 'Open `package.json` and add a package reference to the router as highlighted
    here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`package.json`并按照这里的提示向路由器添加一个包引用：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next install the package from the command line using:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用命令行安装包：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, reference the package in `systemjs.config.js`. This allows SystemJS
    to load the `router` module correctly. Add the router package to the `ngPackageNames`
    array to set up the `packages` configuration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`systemjs.config.js`中引用该包。这样SystemJS就可以正确加载`router`模块了。将路由器包添加到`ngPackageNames`数组中以设置`packages`配置：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also add the `base` reference (highlighted) to the `head` section of `index.html` if
    not present:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，还要在`index.html`的`head`部分中添加`base`引用（已高亮显示）：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The router requires `base href` to be set. The `href` value specifies the base
    URL to use for all relative URLs within an HTML document, including links to CSS,
    scripts, images, and any other resource.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器需要设置`base href`。`href`值指定用于HTML文档中所有相对URL的基本URL，包括链接到CSS、脚本、图像和任何其他资源。
- en: 'The router uses the **pushstate** mechanism for URL navigation. This allows
    us to use URLs such as:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器使用**pushstate**机制进行URL导航。这使我们能够使用诸如：
- en: '`localhost:9000/start`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/start`'
- en: '`localhost:9000/workout`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/workout`'
- en: '`localhost:9000/finish`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/finish`'
- en: 'This may not seem a big deal, but remember that we are doing client-side navigation,
    not the  full-page redirects that we are used to. As the **developer guide** states:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是什么大不了的事，但请记住，我们正在进行客户端导航，而不是我们习惯的全页重定向。正如**开发者指南**所述：
- en: '*Modern HTML 5 browsers support `history.pushState`, a technique that changes
    a browser''s location and history without triggering a server page request. The
    router can compose a "natural" URL that is indistinguishable from one that would
    otherwise require a page load.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*现代HTML 5浏览器支持`history.pushState`，这是一种在不触发服务器页面请求的情况下更改浏览器位置和历史记录的技术。路由器可以组合一个与需要页面加载的URL无法区分的“自然”URL。*'
- en: Pushstate API and server-side url-rewrites
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pushstate API和服务器端URL重写
- en: The pushstate API used by the router works only when we click on links embedded
    in the view (`<a>` tag) or use the router API. The router intercepts any navigation
    events, loads the appropriate component view, and finally updates the browser
    URL. The request never goes to the server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器使用的pushstate API仅在我们点击视图中嵌入的链接（`<a>`标签）或使用路由器API时才起作用。路由器拦截任何导航事件，加载适当的组件视图，最后更新浏览器URL。请求从不发送到服务器。
- en: But what if we refresh the browser?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们刷新浏览器会怎么样？
- en: The Angular router cannot intercept the browser's refresh event, and hence a
    complete page refresh happens. In such a scenario, the server needs to respond
    to a resource request that only exists on the client side. A typical server response
    is to send the app host file (such as `index.html`) for any arbitrary request
    that may result in a **404 (Not Found)** error. This is what we call server **url-rewrite**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器无法拦截浏览器的刷新事件，因此会发生完整的页面刷新。在这种情况下，服务器需要响应仅存在于客户端的资源请求。典型的服务器响应是对于可能导致**404（未找到）**错误的任何任意请求发送应用主机文件（如`index.html`）。这就是我们所说的服务器**URL重写**。
- en: 'Even our server setup does url-rewrite. Check out the highlighted line in `gulpfile.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的服务器设置也进行了URL重写。查看`gulpfile.js`中的突出显示行：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last configuration parameter to `connect.server` sets the `fallback` URL
    for the app server to `index.html`. This implies requests to any non-existent
    URLs such as `/start`, `/workout`, `/finish` or any other loads the index page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect.server`的最后一个配置参数设置了应用服务器的`fallback` URL为`index.html`。这意味着对任何不存在的URL的请求，如`/start`、`/workout`、`/finish`或其他任何URL，都会加载首页。'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Each server platform has a different mechanism to support url-rewrite. We suggest
    you look at the documentation for the server stack you use to enable url-rewrite
    for your Angular apps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务器平台都有不同的机制来支持URL重写。我们建议您查看您使用的服务器堆栈的文档，以启用Angular应用程序的URL重写。
- en: We can see the server-side rewrites in action once we add some pages to *7 Minute
    Workout*. Once the new pages are in place, try to refresh the app and see the
    browser's network log; the server sends `index.html` content every time irrespective
    of the URL requested.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为*7分钟锻炼*添加了一些页面，我们就可以看到服务器端的重写。一旦新页面就位，尝试刷新应用程序并查看浏览器的网络日志；服务器每次都发送`index.html`内容，无论请求的URL是什么。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Fall back path and debugging**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**回退路径和调试**'
- en: Setting up a fall back path for all non-existing URLs can be detrimental while
    debugging the application. Once the fall back mechanism is in place, there are
    no 404 errors for script/HTML/CSS load failures. This can produce unexpected results
    for any missing reference as the server always returns the `index.html` file.
    Watch out for content returned in the browser network log and the browser console
    for anomalies whenever you add new files to the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有不存在的URL设置一个回退路径可能会在调试应用程序时产生不利影响。一旦回退机制就位，对于脚本/HTML/CSS加载失败，就不会出现404错误。这可能会对任何缺失的引用产生意外结果，因为服务器总是返回`index.html`文件。每当您向应用程序添加新文件时，请注意浏览器网络日志和浏览器控制台中返回的内容是否有异常。
- en: As part of the preceding router setup, we have learned how router scripts are
    included, how server-side redirects are set up to support the HTML5 push state
    and the need to set up `base href`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前面路由器设置的一部分，我们已经学会了如何包含路由器脚本，如何设置服务器端重定向以支持HTML5推送状态以及设置`base href`的需要。
- en: Before we proceed any further, we need to add some other pages to our app and
    configure the routes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要为我们的应用程序添加一些其他页面并配置路由。
- en: Adding start and finish pages
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加开始和完成页面
- en: 'The plan here is to have three pages for *7 Minute Workout*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的计划是为*7分钟锻炼*创建三个页面：
- en: '**Start page**: This becomes the landing page for the app'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始页面**：这将成为应用程序的登陆页面'
- en: '**Workout page**: What we have currently'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锻炼页面**：我们目前拥有的内容'
- en: '**Finish page**: We navigate to this once the workout is complete'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成页面**：我们在锻炼完成后导航到这里'
- en: The workout component and its view (`workout-runner.component.ts` and `workout-runner.html`)
    are already there. So let's create `StartComponent` and `FinishComponent`, and
    their view.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼组件及其视图（`workout-runner.component.ts`和`workout-runner.html`）已经存在。因此，让我们创建`StartComponent`和`FinishComponent`以及它们的视图。
- en: 'Copy the following files from git branch `checkpoint3.1`. The files are located
    in the `start` and `finish` folders, under the `components` folder (the GitHub
    location to download from is [http://bit.ly/ng2be-3-1-components](http://bit.ly/ng2be-3-1-components)):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从git分支`checkpoint3.1`复制以下文件。这些文件位于`components`文件夹下的`start`和`finish`文件夹中（从GitHub位置下载的链接是[http://bit.ly/ng2be-3-1-components](http://bit.ly/ng2be-3-1-components)）：
- en: '`start.component.ts`, `start.html`, and `start.module.ts`: This includes the
    `StartComponent` implementation and view template. A standard HTML view, and a
    basic component, which uses the `routerLink` directive to generate a hyperlink.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start.component.ts`，`start.html`和`start.module.ts`：这包括`StartComponent`的实现和视图模板。一个标准的HTML视图，和一个基本的组件，使用`routerLink`指令生成超链接。'
- en: '`finish.component.ts`, `finish.html`, and `finish.module.ts`: This includes
    the `FinishComponent` implementation and view template. It follows the same pattern
    as `StartComponent`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish.component.ts`，`finish.html`和`finish.module.ts`：这包括`FinishComponent`的实现和视图模板。它遵循与`StartComponent`相同的模式。'
- en: Both the `Start` and `Finish` components have been defined with their own modules.
    The convention we will follow is module per top-level view.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`和`Finish`组件都已经使用自己的模块进行了定义。我们将遵循的约定是每个顶级视图一个模块。'
- en: All three components are ready. Time to define the route configurations!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 三个组件都已准备就绪。是时候定义路由配置了！
- en: Route configuration
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由配置
- en: 'To set up the routes for *7 Minute Workout*, we are going to create a route
    definition file. Create a file called `app.routes.ts` in the `components/app`
    folder defining the top-level routes for the app. Add the following routing setup:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置*7分钟锻炼*的路由，我们将创建一个路由定义文件。在`components/app`文件夹中创建一个名为`app.routes.ts`的文件，定义应用程序的顶级路由。添加以下路由设置：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `routes` variable is an array of `Route` objects. Each `Route` defines
    the configuration of a single route, which contains:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`变量是`Route`对象的数组。每个`Route`定义了单个路由的配置，其中包含：'
- en: '`path`: The target path to match'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：要匹配的目标路径'
- en: '`component`: The component to be loaded when the path is hit'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：当路径被命中时要加载的组件'
- en: 'Such a route definition can be interpreted as: "When the user navigates to
    a path (defined in `path`), load the corresponding component defined in the `component`
    property." Take the first route example; navigating to `http://localhost:9000/start`
    loads the component view for `StartComponent`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的路由定义可以解释为：“当用户导航到一个路径（在`path`中定义），加载`component`属性中定义的相应组件。”以第一个路由示例为例；导航到`http://localhost:9000/start`会加载`StartComponent`的组件视图。
- en: You may have noticed that the last `Route` definition looks a bit different.
    The `path` looks odd and it does not have a `component` property either. A path
    with `**` denotes a catch-all path or the *wildcard route* for our app. Any navigation
    that does not match one of the first three routes, matches the catch-all route,
    causing the app to navigate to the start page (defined in the `redirectTo` property).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到最后一个`Route`定义看起来有点不同。`path`看起来很奇怪，而且也没有`component`属性。带有`**`的路径表示一个捕获所有路径或我们应用程序的*通配符路由*。任何不匹配前三个路由之一的导航都会匹配捕获所有路由，导致应用程序导航到起始页面（在`redirectTo`属性中定义）。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can try this once the routing setup is complete. Type any random route such
    as `http://localhost:9000/abcd` and the app automatically redirects to `http://localhost:9000/start`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦路由设置完成，我们可以尝试这个。输入任意随机路由，如`http://localhost:9000/abcd`，应用程序会自动重定向到`http://localhost:9000/start`。
- en: 'The final call to `RouterModule.forRoot` is used to export this route setup
    as a module. We use the setup (exported as `routing`) inside AppModule to complete
    the route setup. Open `app.module.ts` and import the routing setup as well the
    modules we have created with respect to the `Start` and `Finish` pages:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后调用`RouterModule.forRoot`用于将此路由设置导出为模块。我们在AppModule中使用这个设置（导出为`routing`）来完成路由设置。打开`app.module.ts`并导入路由设置以及我们根据`Start`和`Finish`页面创建的模块：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have all the required components and all the routes defined, where
    do we inject these components on route change? We just need to define a placeholder
    for that in the host view.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有所需的组件和所有定义的路由，我们在路由更改时在哪里注入这些组件呢？我们只需要在宿主视图中为其定义一个占位符。
- en: Rendering component views with router-outlet
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用router-outlet渲染组件视图
- en: 'If we check the current `TrainerAppComponent` template, it has an embedded
    `WorkoutRunnerComponent`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查当前的`TrainerAppComponent`模板，它有一个嵌入的`WorkoutRunnerComponent`：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This needs to change. Remove the preceding declaration and replace it with:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要改变。删除前面的声明并替换为：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`RouterOutlet` is an Angular component directive that acts as a placeholder
    for a child component to load on route change. It integrates with the router to
    load the appropriate component based on the current browser URL and the route
    definition.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterOutlet`是一个Angular组件指令，作为一个占位符，在路由更改时加载子组件。它与路由器集成，根据当前浏览器URL和路由定义加载适当的组件。'
- en: 'The following diagram helps us to easily visualize what is happening with the
    `router-outlet` setup:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表帮助我们轻松地可视化了`router-outlet`的设置发生了什么：
- en: '![Rendering component views with router-outlet](../Images/image00447.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![使用router-outlet渲染组件视图](../Images/image00447.jpeg)'
- en: We are almost done now; it's time to trigger navigation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎完成了；是时候触发导航了。
- en: Route navigation
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由导航
- en: 'Like standard browser navigation, Angular navigation can happen:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 像标准浏览器导航一样，Angular导航可以发生：
- en: When a user enters a URL directly in the browser
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户直接在浏览器中输入URL时
- en: On clicking on a link on the anchor tag
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击锚标签上的链接
- en: On using a script/code to navigate
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本/代码进行导航
- en: If not started, start the app and load `http://localhost:9000` or `http://localhost:9000/start`.
    The start page should be loaded.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未启动，请启动应用程序并加载`http://localhost:9000`或`http://localhost:9000/start`。应该加载开始页面。
- en: Click on the **Start** button of the page and the workout view should be loaded
    at `http://localhost:9000/workout`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单击页面上的**开始**按钮，训练视图应该加载到`http://localhost:9000/workout`。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Angular router also supports the old style of *hash (#)-based routing*.
    When hash-based routing is enabled, the routes appear as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器还支持旧式的基于*哈希（#）*的路由。启用基于哈希的路由时，路由如下所示：
- en: '`localhost:9000/#/start`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/start`'
- en: '`localhost:9000/#/workout`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/workout`'
- en: '`localhost:9000/#/finish`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/finish`'
- en: 'The default routing option is *pushState*-based. To change it to hash-based
    routing, the route configuration for the top level routes changes during route
    setup as shown in this example: `export const routing: ModuleWithProviders` `=
    RouterModule.forRoot(routes,` `**{ useHash: true }**` `);`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '默认的路由选项是基于*pushState*的。要将其更改为基于哈希的路由，顶级路由的路由配置在路由设置期间更改，如本例所示：`export const
    routing: ModuleWithProviders` `= RouterModule.forRoot(routes,` `**{ useHash: true
    }**` `);`'
- en: 'Interestingly, the anchor link in the `StartComponent''s` view definition does
    not have a `href` attribute. Instead, there is a `RouterLink` directive:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`StartComponent`视图定义中的锚链接没有`href`属性。相反，有一个`RouterLink`指令：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This looks like a property binding syntax, where the `RouterLink` directive
    is taking an input parameter of type array. This is an array of route links parameters
    (or the link parameter array).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是属性绑定语法，`RouterLink` 指令接受一个数组类型的输入参数。这是一个路由链接参数数组（或链接参数数组）。
- en: The `routerLink` directive, together with the router, uses this link parameter
    array to resolve the correct URL path. In the preceding case, the only element
    in the array is the name of the route.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLink` 指令与路由器一起使用这个链接参数数组来解析正确的 URL 路径。在前面的情况下，数组中唯一的元素是路由的名称。'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the **/** prefix in the preceding route path. `/` is used to specify
    an absolute path. The Angular router also supports relative paths, which are useful
    when working with child routes. We will explore the concept of child routes in
    the next few chapters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前面的路由路径中的 **/** 前缀。`/` 用于指定绝对路径。Angular 路由器还支持相对路径，这在处理子路由时非常有用。我们将在接下来的几章中探讨子路由的概念。
- en: 'Refresh the app and check the rendered HTML for `StartComponent`; the preceding
    anchor tag is rendered as:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新应用并检查 `StartComponent` 的渲染 HTML；前面的锚标签被渲染为：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Avoid hardcoding route links**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 避免硬编码路由链接
- en: While you could have directly used `<a href="/workout">`, prefer `routerLink`
    to avoid hardcoding routes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以直接使用 `<a href="/workout">`，但最好使用 `routerLink` 来避免硬编码路由。
- en: Link parameter array
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接参数数组
- en: 'The link parameter array passed to the `routerLink` directive follows a specific
    pattern:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `routerLink` 指令的链接参数数组遵循特定的模式：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first element is always the route path, and the next set of parameters is
    there to replace placeholder tokens defined in a route template.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素始终是路由路径，下一组参数用于替换路由模板中定义的占位符标记。
- en: 'The route setup for the current *7 Minute Workout* is quite simple, and there
    isn''t a need to pass parameters as part of link generation. But the capability
    is there for non-trivial routes that require dynamic parameters. See this example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 *7分钟锻炼* 的路由设置非常简单，不需要在链接生成中传递参数。但是对于需要动态参数的非平凡路由，可以使用这个功能。看看这个例子：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is how the first route can be generated:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何生成第一个路由的：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Angular router is quite a beast and supports almost everything that we expect
    of a modern router library. It supports child routes, async routes, lifecycle
    hooks, and some other advanced scenarios. We'll delay discussion on these topics
    until later chapters. This chapter just gets us started with Angular routing,
    but there is more to come!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器非常强大，支持几乎我们对现代路由库的所有期望。它支持子路由、异步路由、生命周期钩子和其他一些高级场景。我们将延迟讨论这些主题，直到后面的章节。本章只是让我们开始使用
    Angular 路由，但还有更多内容要学习！
- en: 'The router link parameter can also be an object. Such objects are used to supply
    *optional parameters* to the route. See this example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 路由链接参数也可以是一个对象。这样的对象用于向路由提供*可选参数*。看看这个例子：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the generated link contains a semicolon to separate parameters from
    the route and other parameters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意生成的链接包含一个分号，用于将参数与路由和其他参数分开。
- en: The last missing part in the implementation is routing to the finish pages once
    the workout completes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中最后缺失的部分是在锻炼完成后路由到完成页面。
- en: Using the router service for component navigation
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用路由服务进行组件导航
- en: Navigation from the workout page to the finish page is not triggered manually
    but on completion of the workout. `WorkoutRunnerComponent` needs to trigger this
    transition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从锻炼页面导航到完成页面不是手动触发的，而是在完成锻炼时触发。`WorkoutRunnerComponent` 需要触发这个转换。
- en: For this, `WorkoutRunnerComponent` needs to get hold of the component router
    and invoke the `navigate` method on it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，`WorkoutRunnerComponent` 需要获取组件路由并在其上调用 `navigate` 方法。
- en: How does `WorkoutRunnerComponent` get the router instance? Using Angular's *dependency
    injection framework*. We have been shying away from this topic for some time now.
    We have achieved a lot without even knowing that there's a dependency injection
    framework in play all this while.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`如何获得路由器实例？使用Angular的*依赖注入框架*。我们已经有一段时间没有涉及这个话题了。我们甚至不知道在这段时间里依赖注入框架一直在发挥作用。'
- en: Let's wait a tad longer and firstly concentrate on fixing the navigation issue.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再等一会儿，首先集中精力解决导航问题。
- en: 'For `WorkoutRunnerComponent` to get hold of the router service instance, it
    just needs to declare the service on the constructor. Update the `WorkoutRunnerComponent`
    constructor and add the imports:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`WorkoutRunnerComponent`获得路由器服务实例，它只需要在构造函数中声明该服务。更新`WorkoutRunnerComponent`构造函数并添加导入：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Angular now magically injects the current router into the `router` private variable
    when `WorkoutRunnerComponent` is instantiated. The magic it uses is the *dependency
    injection framework*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当`WorkoutRunnerComponent`被实例化时，Angular会神奇地将当前路由器注入到`router`私有变量中。它使用的魔法是*依赖注入框架*。
- en: 'It''s now just a matter of replacing the statement `console.log("Workout complete!");`
    with the call to the `navigation` router:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需要用调用`navigation`路由替换语句`console.log("Workout complete!");`：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `navigate` method takes the same link parameter array as the `RouterLink`
    directive. We can verify the implementation by patiently waiting for the workout
    to complete!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigate`方法接受与`RouterLink`指令相同的链接参数数组。我们可以通过耐心等待锻炼完成来验证实现！'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are having a problem with running the code, look at the git branch `checkpoint3.1`
    for a working version of what we have done thus far.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看git分支`checkpoint3.1`，了解我们迄今为止所做的工作的可工作版本。
- en: Or if you are not using git, download the snapshot of `checkpoint3.1` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-1](http://bit.ly/ng2be-checkpoint3-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果您不使用git，请从[http://bit.ly/ng2be-checkpoint3-1](http://bit.ly/ng2be-checkpoint3-1)下载`checkpoint3.1`的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: If you are still wondering how to access route parameters for the current route,
    we have the `ActivatedRoute` service.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然想知道如何访问当前路由的路由参数，我们有`ActivatedRoute`服务。
- en: Using the ActivatedRoute service to access route params
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`ActivatedRoute`服务访问路由参数
- en: There are times when the current view requires access to the active route state.
    Information such as the current URL fragment, the current route parameters, and
    other route-related data may come in handy during component implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当前视图需要访问活动路由状态。在组件实现过程中，诸如当前URL片段、当前路由参数和其他与路由相关的数据可能会派上用场。
- en: The `ActivatedRoute` service is a one-stop shop for all current route-related
    queries. It has a number of properties, including `url` and `params`, that can
    utilize the route's current state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedRoute`服务是所有当前路由相关查询的一站式商店。它有许多属性，包括`url`和`params`，可以利用路由的当前状态。'
- en: 'Let''s look at an example of a parameterized route and how to access a parameter
    passed from a component. Given this route:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个带参数的路由的例子，以及如何从组件中访问传递的参数。给定这个路由：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the user navigates to `/user/5`, the underlying component can access the
    `:id` parameter value by first injecting `ActivatedRoute` into its constructor:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到`/user/5`时，底层组件可以通过首先将`ActivatedRoute`注入到其构造函数中来访问`:id`参数值：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It then queries the `id` property from the `params` property of the `ActivatedRoute`
    service. Look at this example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从`ActivatedRoute`服务的`params`属性中查询`id`属性。看看这个例子：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `params` property on `ActivatedObject` is actually an *observable*. We will
    learn more about observables later in the chapter, but for now it is enough to
    understand that observables are objects that raise events and can be subscribed
    to.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedObject`上的`params`属性实际上是一个*observable*。我们将在本章后面学习更多关于observables的知识，但现在足够理解observables是可以触发事件并且可以被订阅的对象。'
- en: We use the `forEach` function on the `route.params` observable to get the route's
    parameters. The callback object (`params:Params`) contains properties corresponding
    to each route parameter. Check how we retrieve the `id` property and use it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`route.params` observable上的`forEach`函数来获取路由的参数。回调对象（`params:Params`）包含与每个路由参数对应的属性。看看我们如何检索`id`属性并使用它。
- en: 'We have now covered the basic Angular routing infrastructure, but there is
    more to explore in the later chapters. It''s now time to concentrate on a much
    overdue topic: *Dependency Injection*.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了基本的Angular路由基础设施，但在后面的章节中还有更多内容可以探索。现在是时候集中精力讨论一个长期以来的话题：*依赖注入*。
- en: Angular dependency injection
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular依赖注入
- en: Angular makes heavy use of dependency injection to manage app and framework
    dependencies. The surprising part is that we could ignore this topic until we
    started our discussion on the router without compromising our understanding of
    how things work. All this while, the Angular dependency injection framework has
    been supporting our implementation. The hallmark of a good dependency injection
    framework is that the consumer can use it without bothering about the internals
    and with little ceremony.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Angular大量使用依赖注入来管理应用程序和框架的依赖关系。令人惊讶的是，我们可以忽略这个话题，直到我们开始讨论路由器，而不会影响我们对事物如何工作的理解。在此期间，Angular依赖注入框架一直在支持我们的实现。一个好的依赖注入框架的特点是，消费者可以在不关心内部细节的情况下使用它，并且只需很少的仪式感。
- en: If you are not sure what dependency injection is or just have a vague idea about
    it, an introduction to DI surely does not hurt anyone.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定什么是依赖注入，或者只是对它有一个模糊的概念，那么对DI的介绍肯定不会伤害任何人。
- en: Dependency injection 101
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入101
- en: For any application, its components (not to be confused with Angular components)
    do not work in isolation. There are dependencies between them. A component may
    use other components to achieve its desired functionalities. **Dependency injection**
    is a pattern for managing such dependencies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何应用程序，其组件（不要与Angular组件混淆）并不是孤立工作的。它们之间存在依赖关系。一个组件可能使用其他组件来实现其所需的功能。**依赖注入**是一种管理这种依赖关系的模式。
- en: The DI pattern is popular in many programming languages as it allows us to manage
    dependencies in a loosely coupled manner. With such a framework in place, dependent
    objects are managed by a DI container. This makes dependencies swappable and the
    overall code more decoupled and testable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: DI模式在许多编程语言中很受欢迎，因为它允许我们以松散耦合的方式管理依赖关系。有了这样一个框架，依赖对象由DI容器管理。这使得依赖关系可互换，并且整体代码更加解耦和可测试。
- en: The idea behind DI is that an object does not create\manage its own dependencies.
    Instead, the dependencies are provided from outside. These dependencies are made
    available either through a constructor, which is called **constructor injection**
    (Angular also does this) or by directly setting the object properties, which is
    called **property injection**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: DI背后的理念是一个对象不会创建\管理自己的依赖关系。相反，依赖关系是从外部提供的。这些依赖关系可以通过构造函数提供，这被称为**构造函数注入**（Angular也这样做），或者直接设置对象属性，这被称为**属性注入**。
- en: 'Here is a rudimentary example of DI in action. Consider a class called `Tracker`
    that requires a `Logger` for a logging operation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个依赖注入实例的基本示例。考虑一个名为`Tracker`的类，它需要一个`Logger`来进行日志记录操作：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The dependency of the class `Logger` is hardwired inside `Tracker`. What if
    we externalize this dependency? So the class becomes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Logger`的依赖关系在`Tracker`内部是硬编码的。如果我们将这种依赖关系外部化呢？所以类变成了：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This innocuous-looking change has a major impact. By adding the ability to
    provide the dependency externally, we can now:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这看似无害的改变产生了重大影响。通过添加提供外部依赖的能力，我们现在可以：
- en: 'Decouple components and enable extensibility. The DI pattern allows us to alter
    the logging behavior of the `Tracker` class without touching the class itself.
    Here is an example:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦组件并实现可扩展性。DI模式允许我们在不触及类本身的情况下改变`Tracker`类的日志行为。这里有一个例子：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The two `Tracker` objects we just saw have different logging capabilities for
    the same `Tracker` class implementation. `trackerWithDBLog` logs to a DB and `trackerWithMemoryLog`
    to the memory (assuming both `DBLogger` and `MemoryLogger` are derived from `Logger`
    class). Since Tracker is not dependent of specific implementation on a `Logger`
    (`DBLogger` or `MemoryLogger`), this implies `Logger` and `Tracker` are loosely
    coupled. In future we can derive a new `Logger` class implementation and use that
    for logging without changing the `Tracker` implementation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的两个`Tracker`对象对于相同的`Tracker`类实现具有不同的日志功能。`trackerWithDBLog`记录到数据库，`trackerWithMemoryLog`记录到内存（假设`DBLogger`和`MemoryLogger`都是从`Logger`类派生的）。由于Tracker不依赖于`Logger`的特定实现（`DBLogger`或`MemoryLogger`），这意味着`Logger`和`Tracker`是松耦合的。将来，我们可以派生一个新的`Logger`类实现，并在不改变`Tracker`实现的情况下用它来记录。
- en: 'Mock dependencies: The ability to mock dependencies makes our components more
    testable. The tracker implementation can be tested in isolation (unit testing)
    by providing a mock implementation for Logger such as MockLogger, or by using
    a mocking framework that can easily mock the `Logger` interface.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟依赖关系：模拟依赖关系的能力使我们的组件更易于测试。通过为Logger提供一个模拟实现，如MockLogger，或者使用一个可以轻松模拟`Logger`接口的模拟框架，可以单独测试跟踪器实现（单元测试）。
- en: We can now understand how powerful DI is. Once DI is in place, the responsibility
    for resolving the dependencies falls on the calling/consumer code. In the preceding
    example, a class that was earlier instantiating `Tracker` now needs to create
    a `Logger` derivation and inject it into `Tracker` before using it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以理解DI是多么强大。一旦DI就位，解决依赖关系的责任就落在了调用/消费者代码身上。在前面的例子中，之前实例化`Tracker`的类现在需要创建一个`Logger`的派生类并在使用之前将其注入到`Tracker`中。
- en: Clearly, this flexibility in swapping internal dependencies of a component comes
    at a price. The calling code implementation can become overly complex as it now
    has to manage child dependencies too. This may seem simple at first, but given
    the fact that dependent components may themselves have dependencies, what we are
    dealing with is a complex dependency tree structure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种在组件中交换内部依赖的灵活性是有代价的。调用代码的实现可能变得过于复杂，因为现在它必须管理子依赖关系。这一开始可能看起来很简单，但考虑到依赖组件本身可能有依赖关系，我们正在处理的是一个复杂的依赖树结构。
- en: To make dependency management less cumbersome for the calling code, there is
    a need for DI containers/frameworks. These containers are responsible for constructing/managing
    dependencies and providing it to our client/consumer code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少调用代码的依赖管理工作，需要使用DI容器/框架。这些容器负责构建/管理依赖关系并将其提供给我们的客户/消费者代码。
- en: The Angular DI framework manages dependencies for our Angular components, directives,
    pipes, and services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Angular DI框架管理我们的Angular组件、指令、管道和服务的依赖关系。
- en: Exploring dependency injection in Angular
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Angular中探索依赖注入
- en: 'Angular employs its very own DI framework to manage dependencies across the
    application. The very first example of visible dependency injection was the injection
    of the component router into `WorkoutRunnerComponent`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Angular采用自己的DI框架来管理应用程序中的依赖关系。可见的依赖注入的第一个示例是将组件路由器注入到`WorkoutRunnerComponent`中：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the `WorkoutRunnerComponent` class gets instantiated, the DI framework
    internally locates/creates the correct router instance and injects it into the
    caller (in our case, `WorkoutRunnerComponent`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当`WorkoutRunnerComponent`类被实例化时，DI框架在内部定位/创建正确的路由器实例，并将其注入到调用者（在我们的例子中是`WorkoutRunnerComponent`）中。
- en: While Angular does a good job at keeping the DI infrastructure hidden, it's
    imperative that we understand how Angular DI works. Otherwise, everything may
    seem rather magical.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular在隐藏DI基础设施方面做得很好，但我们必须了解Angular DI的工作原理。否则，一切可能看起来相当神奇。
- en: 'DI is about creating and managing dependencies, and the framework component
    that does this is dubbed the **injector**. For the injector to manage dependencies,
    it needs to understand the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: DI是关于创建和管理依赖项的，负责这一点的框架组件被称为**注入器**。为了注入器能够管理依赖项，它需要理解以下内容：
- en: '**The what:** What is the dependency? The dependency could be a class, an object,
    a factory function, or a value. Every dependency needs to be registered with the
    DI framework before it can be injected.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**什么是依赖项：** 依赖项是什么？依赖项可以是一个类、一个对象、一个工厂函数或一个值。每个依赖项在注入之前都需要在DI框架中注册。'
- en: '**The where/when:** The DI framework needs to know where to inject a dependency
    and when.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时何地：** DI框架需要知道在哪里注入依赖项以及何时注入。'
- en: '**The how**: The DI framework also needs to know the recipe for creating the
    dependency when requested.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何：** DI框架还需要知道在请求时创建依赖项的方法。'
- en: Any injected dependency needs to answer these questions irrespective of whether
    it's a framework construct or artefacts created by us.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是框架构造还是我们创建的工件，任何注入的依赖项都需要回答这些问题。
- en: 'Take for example the `Router` instance injection done in `WorkoutRunnerComponent`.
    To answer the what and how parts, we register the `Router` service in the app
    module (`app.module.ts`) via the import statement on the module decorator:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`WorkoutRunnerComponent`中进行的`Router`实例注入。为了回答“什么”和“如何”部分，我们通过模块装饰器上的导入语句在应用模块（`app.module.ts`）中注册`Router`服务：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `routing` variable is a module that exports multiple routes together with
    all the Angular-router-related services (technically it re-exports `RouterModule`).
    We export this variable from `app.routes.ts` with this statement:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`routing`变量是一个模块，它导出了多个路由以及所有与Angular路由相关的服务（技术上它重新导出了`RouterModule`）。我们通过以下语句从`app.routes.ts`中导出这个变量：'
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The where and when are decided based on the component that requires the dependencies.
    The constructor of `WorkoutRunnerComponent` takes a dependency of `Router`. This
    informs the injector to inject the current `Router` instance when `WorkoutRunnerComponent`
    is created as part of route navigation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: “何时”和“何地”是根据需要依赖项的组件来决定的。`WorkoutRunnerComponent`的构造函数需要一个`Router`的依赖项。这通知注入器在路由导航的过程中创建`WorkoutRunnerComponent`时注入当前的`Router`实例。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, the Injector determines the dependencies of a class based on the
    metadata reflected from it when converting TypeScript to ES5 code (done by the
    TypeScript compiler). The metadata is generated only if we add a decorator such
    as `@Component` or `@RouteConfig` on the class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，注入器根据从TypeScript转换为ES5代码时反映出的元数据来确定类的依赖关系（由TypeScript编译器完成）。只有在类上添加了`@Component`或`@RouteConfig`等装饰器时才会生成元数据。
- en: What happens if we inject `Router` into another class? Is the same `Router`
    instance used? The short answer is yes. The Angular injector creates and caches
    dependencies for future reuse, and hence these services are singleton in nature.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Router`注入到另一个类中会发生什么？答案是是。Angular注入器会创建和缓存依赖项以供将来重用，因此这些服务在本质上是单例的。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While dependencies in an injector are singleton, at any given time, there can
    be multiple injectors active throughout an Angular app. You'll learn about the
    injector hierarchy shortly.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然注入器中的依赖项是单例的，但在任何给定时间，整个Angular应用程序中可能有多个活动的注入器。你很快就会了解注入器层次结构。
- en: With the router, there is another layer of complexity. Since Angular supports
    the *child route* concept, each of these routes has its own router instance. Wait
    until we cover child routers in the next chapter so that you can understand the
    intricacies!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由器，还有另一层复杂性。由于Angular支持*子路由*概念，每个路由都有自己的路由器实例。等到下一章涵盖子路由时，你就能理解其中的复杂性！
- en: Let's create an Angular service to track workout history. This process will
    help you understand how dependencies are wired using Angular DI.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个Angular服务来跟踪训练历史。这个过程将帮助你理解如何使用Angular DI连接依赖项。
- en: Tracking workout history
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪训练历史
- en: It would be a great addition to our app if we could track the workout history.
    When did we last exercise? Did we complete it? How much time did we spend?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够跟踪训练历史，这将是我们应用的一个很好的补充。我们上次锻炼是什么时候？我们完成了吗？我们花了多少时间？
- en: Tracing the workout history requires us to track workout progress. Somehow,
    we need to track when the workout starts and when it stops. This tracking data
    then needs to be persisted somewhere.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪训练历史需要我们跟踪训练进度。我们需要以某种方式跟踪训练何时开始和何时结束。然后需要将这些跟踪数据持久化存储在某个地方。
- en: One way to implement this history tracking is by extending our `WorkoutRunnerComponent`
    with the desired functionality. But that adds unnecessary complexity to `WorkoutRunnerComponent`
    and that's not its primary job. We need a dedicated history tracking service for
    this job, a service that tracks historical data and shares it throughout the app.
    Let's start building the `WorkoutHistoryTracker` service.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种历史跟踪的一种方法是通过扩展我们的`WorkoutRunnerComponent`来实现所需的功能。但这会给`WorkoutRunnerComponent`增加不必要的复杂性，这不是它的主要工作。我们需要一个专门的历史跟踪服务来完成这项工作，一个可以跟踪历史数据并在整个应用程序中共享的服务。让我们开始构建`WorkoutHistoryTracker`服务。
- en: Building the WorkoutHistoryTracker service
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建WorkoutHistoryTracker服务
- en: With the `WorkoutHistoryTracker` service, we plan to track the execution of
    the workout. The service also exposes an interface, allowing `WorkoutRunnerComponent`
    to start and stop workout tracking.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`WorkoutHistoryTracker`服务，我们计划跟踪训练的执行。该服务还公开了一个接口，允许`WorkoutRunnerComponent`启动和停止训练跟踪。
- en: 'Create a `services` folder inside the `src` folder if not there and add a file
    called `workout-history-tracker.ts` with this code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，请在`src`文件夹内创建一个名为`services`的文件夹，并添加一个名为`workout-history-tracker.ts`的文件，其中包含以下代码：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are two classes defined: `WorkoutHistoryTracker` and `WorkoutLogEntry`.
    As the name suggests, `WorkoutLogEntry` defines log data for one workout execution.
    `maxHistoryItems` allows us to configure the maximum number of items to store
    in the `workoutHistory` array, the array that contains the historical data. The
    `get tracking()` method defines a getter property for `workoutTracked` in TypeScript.
    `workoutTracked` is set to `true` during workout execution.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了两个类：`WorkoutHistoryTracker`和`WorkoutLogEntry`。顾名思义，`WorkoutLogEntry`定义了一个训练执行的日志数据。`maxHistoryItems`允许我们配置要存储在`workoutHistory`数组中的最大项目数，该数组包含历史数据。`get
    tracking()`方法在TypeScript中定义了`workoutTracked`的getter属性。在训练执行期间，`workoutTracked`被设置为`true`。
- en: 'Let''s add the start tracking, stop tracking, and exercise complete functions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加开始跟踪、停止跟踪和完成练习的功能：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `startTracking` function creates a `WorkoutLogEntry` and adds it to the
    `workoutHistory` array. By setting the `currentWorkoutLog` to the newly created
    log entry, we can manipulate it later during workout execution. The `endTracking`
    function and the `exerciseComplete` function just alter `currentWorkoutLog`. The
    `exerciseComplete` function should be called on completion of each exercise that
    is part of the workout.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTracking`函数创建一个`WorkoutLogEntry`并将其添加到`workoutHistory`数组中。通过将`currentWorkoutLog`设置为新创建的日志条目，我们可以在以后的训练执行过程中对其进行操作。`endTracking`函数和`exerciseComplete`函数只是改变`currentWorkoutLog`。`exerciseComplete`函数应该在完成训练中的每个练习时调用。'
- en: 'Lastly, add a function that returns the complete historical data:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个返回完整历史数据的函数：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That completes the `WorkoutHistoryTracker` implementation; now it's time to
    integrate it into workout execution.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`WorkoutHistoryTracker`的实现；现在是将其整合到训练执行中的时候了。
- en: Integrating with WorkoutRunnerComponent
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与`WorkoutRunnerComponent`整合
- en: The `WorkoutRunnerComponent` requires `WorkoutHistoryTracker` to track workout
    history; hence there is a dependency to be fulfilled.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`需要`WorkoutHistoryTracker`来跟踪训练历史记录；因此需要满足一个依赖关系。'
- en: To make `WorkoutHistoryTracker` discoverable, it needs to be registered with
    the framework. At this point, we are spoilt for choices. There are a number of
    ways to register a dependency and a number of places too! This flexibility makes
    the DI framework very powerful, albeit it adds to the confusion too.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`WorkoutHistoryTracker`可发现，它需要在框架中注册。在这一点上，我们有很多选择。有很多种方法可以注册依赖项，也有很多地方可以注册！这种灵活性使得DI框架非常强大，尽管它也增加了混乱。
- en: Let's firstly try to understand the different mechanisms we can use to register
    a dependency using the `WorkoutHistoryTracker` as an example.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试理解使用`WorkoutHistoryTracker`作为示例来注册依赖项的不同机制。
- en: Registering dependencies
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册依赖项
- en: The simplest way to register a dependency is to register it at the root/global
    level. This can be done by passing the dependency type into the `provides` attribute
    (array) in the module decorator.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注册依赖项的最简单方法是在根/全局级别注册它。这可以通过将依赖类型传递到模块装饰器中的`provides`属性（数组）来实现。
- en: 'As shown in this example, adding `WorkoutHistoryTracker` to any module''s `providers`
    array registers the service globally:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，将`WorkoutHistoryTracker`添加到任何模块的`providers`数组中会全局注册该服务：
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Technically speaking, when a service is added to the `providers` array it gets
    registered with the **app's root injector**, irrespective of the Angular module
    it is declared in. Any Angular artefact in any module henceforth can use the service
    (`WorkoutHistoryTracker`). No module imports are required at all.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，当一个服务被添加到`providers`数组中时，它会被注册到**应用程序的根注入器**中，而不管它在哪个Angular模块中声明。因此，以后任何模块中的任何Angular构件都可以使用该服务（`WorkoutHistoryTracker`）。根本不需要任何模块导入。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This behavior is different from component/directive/pipe registration. Such
    artefacts have to be exported from a module for another module to use them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与组件/指令/管道的注册不同。这些构件必须从一个模块中导出，以便另一个模块使用它们。
- en: 'Providers create dependencies when the Angular injector requests them. These
    providers have the recipe to create these dependencies. While a class seems to
    be the obvious dependency that can be registered, we can also register:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular注入器请求它们时，提供者会创建依赖项。这些提供者有创建这些依赖项的配方。虽然类似乎是可以注册的明显依赖项，但我们也可以注册：
- en: A specific object/value
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特定的对象/值
- en: A factory function
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工厂函数
- en: Directly using the class type to register a dependency (as shown in the `bootstrap`
    function) may mostly meet our needs, but at times we need some flexibility with
    our dependency registrations. The expanded version of provider registration syntax
    gives us that flexibility.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用类类型来注册依赖关系（如在`bootstrap`函数中所示）可能大多数情况下可以满足我们的需求，但有时我们需要在依赖注册中具有一些灵活性。提供者注册语法的扩展版本为我们提供了这种灵活性。
- en: To learn about these variations, we need to explore providers and dependency
    registration in a little more detail.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些变化，我们需要更详细地探讨提供者和依赖注册。
- en: Angular providers
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Angular提供者
- en: Providers create dependencies that are served by the DI framework.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者创建由DI框架提供的依赖关系。
- en: 'Look at the `WorkoutHistoryTracker` dependency registration in the previous
    section:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上一节中`WorkoutHistoryTracker`的依赖关系注册：
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This syntax is a short-form notation for the following version:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法是以下版本的简写形式：
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first property (`provide`) is a token that acts like a key for registering
    a dependency. This key also allows us to locate the dependency during dependency
    injection.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性（`provide`）是一个令牌，充当注册依赖关系的键。这个键还允许我们在依赖注入期间定位依赖关系。
- en: The second property (`useClass`) is a provider definition object that defines
    the recipe for creating the dependency value. The framework provides a number
    of ways to create these dependencies, as we will see shortly.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性（`useClass`）是一个提供者定义对象，定义了创建依赖值的方法。框架提供了许多创建这些依赖关系的方法，我们很快就会看到。
- en: With `useClass`, we are registering class `provider`.  The class `provider` create
    dependencies by instantiating the type of object requested for.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useClass`，我们正在注册类`provider`。类`provider`通过实例化所请求的对象类型来创建依赖关系。
- en: Value providers
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 值提供者
- en: The class `provider` create class objects and fulfil the dependency, but at
    times we want to register a specific object/primitive with the DI provider instead.
    Value providers solve this use case.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 类`provider`创建类对象并满足依赖，但有时我们希望注册一个特定的对象/原始对象到DI提供者中。值提供者解决了这种用例。
- en: 'Take an example of `WorkoutHistoryTracker` registered using this technique:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以使用此技术注册的`WorkoutHistoryTracker`为例：
- en: '[PRE32]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What is registered is an instance of the `WorkoutHistoryTracker` object created
    by us, instead of letting Angular DI create one. Take such hand-crafted dependencies
    (dependencies created manually) into consideration if there are dependencies further
    down the lineage that too need to be hand-crafted. Take the example of `WorkoutHistoryTracker`
    again. If `WorkoutHistoryTracker` has some dependencies, those too need to be
    fulfilled by manual injection:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注册的是我们创建的`WorkoutHistoryTracker`对象的实例，而不是让Angular DI创建一个。如果下游也需要手工创建的依赖关系，那么考虑这样手工创建的依赖关系（手动创建的依赖关系）。再次以`WorkoutHistoryTracker`为例。如果`WorkoutHistoryTracker`有一些依赖关系，那么这些依赖关系也需要通过手动注入来满足：
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Value providers come in handy in specific scenarios. For example, we can register
    a common app configuration using a value provider:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 值提供者在特定情况下非常有用。例如，我们可以使用值提供者注册一个常见的应用程序配置：
- en: '[PRE34]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or register a mock dependency while unit-testing:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在单元测试时注册一个模拟依赖：
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Factory providers
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工厂提供者
- en: There are times when injection is not a trivial affair. Injection depends upon
    external factors. These factors decide what objects or class instances are created
    and returned. Factory providers do this heavy lifting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候注入并不是一件简单的事情。注入取决于外部因素。这些因素决定了创建和返回的对象或类实例。工厂提供者完成了这项繁重的工作。
- en: 'Take an example where we want to have different configurations for dev and
    production releases. We can very well use a factory implementation to select the
    right configuration:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们想要为开发和生产版本设置不同的配置。我们可以很好地使用工厂实现来选择正确的配置：
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A factory function can have its own dependencies too. In such a case, the syntax
    changes a bit:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数也可以有自己的依赖项。在这种情况下，语法会有一些变化：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The dependency is passed as a parameter to the factory function and registered
    on the provider definition object property, `deps`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项作为参数传递给工厂函数，并在提供者定义对象属性`deps`上注册。
- en: Use the `UseFactory` provide if the construction of the dependency is complex
    and not everything can be decided during wire-up.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果依赖项的构建复杂，并且在连接期间无法决定所有内容，可以使用`UseFactory`提供。
- en: While we have a number of options to declare dependencies, consuming dependencies
    is far simpler.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有许多选项来声明依赖项，但消耗依赖项要简单得多。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before continuing further, let's register the `WorkoutHistoryTracker` service
    in a new service module. This new module (`ServicesModule`) will be used to register
    all application-wide services.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们在一个新的服务模块中注册`WorkoutHistoryTracker`服务。这个新模块（`ServicesModule`）将用于注册所有应用程序范围的服务。
- en: 'Copy the module definition from the git branch `checkpoint3.2` into the `src/services`
    folder locally. You can download it from this GitHub location: [http://bit.ly/ng2be-3-2-services-module-ts](http://bit.ly/ng2be-3-2-services-module-ts).
    Also delete all references to the `LocalStorage` service as we plan to add it
    later in the chapter. Finally, import the module into `AppModule` (`app.module.ts`).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块定义从git分支`checkpoint3.2`复制到本地的`src/services`文件夹中。您可以从此GitHub位置下载它：[http://bit.ly/ng2be-3-2-services-module-ts](http://bit.ly/ng2be-3-2-services-module-ts)。还要删除所有对`LocalStorage`服务的引用，因为我们计划在本章稍后添加它。最后，将该模块导入`AppModule`（`app.module.ts`）。
- en: Injecting dependencies
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入依赖项
- en: Consuming dependency is easy! More often than not, we use constructor injection
    to consume a dependency.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗依赖项很容易！往往我们使用构造函数注入来消耗依赖项。
- en: Constructor injection
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: 'Add the `import` statement at the top and update the `WorkoutRunnerComponent''s`
    constructor, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部添加`import`语句，并更新`WorkoutRunnerComponent`的构造函数，如下所示：
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As with router, Angular injects `WorkoutHistoryTracker` too when `WorkoutRunnerComponent`
    is created. Easy!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 与路由器一样，当创建`WorkoutRunnerComponent`时，Angular也会注入`WorkoutHistoryTracker`。简单！
- en: Before we continue any further with our integration, let's explore some other
    facts about Angular's DI framework.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续整合之前，让我们探索一下关于Angular的DI框架的其他事实。
- en: Explicit injection using injector
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用注入器进行显式注入
- en: 'We can even do explicit injection using Angular''s `Injector` service. This
    is the same injector Angular uses to support DI. Here is how to inject the `WorkoutHistoryTracker`
    service using `Injector`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用Angular的`Injector`服务进行显式注入。这是Angular用来支持DI的相同注入器。以下是如何使用`Injector`注入`WorkoutHistoryTracker`服务：
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We inject the `Injector` first and then ask the `Injector` for the `WorkoutHistoryTracker`
    instance explicitly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注入`Injector`，然后显式要求`Injector`获取`WorkoutHistoryTracker`实例。
- en: When would someone want to do this? Well, almost never. Avoid this pattern as
    it exposes the DI container to your implementation and adds a bit of noise too.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候有人想要这样做呢？嗯，几乎从不。避免这种模式，因为它会将DI容器暴露给您的实现，并且还会增加一些噪音。
- en: Consuming dependency was easy, but how does the DI framework locate these dependencies?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗依赖项很容易，但DI框架如何定位这些依赖项呢？
- en: Dependency tokens
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖项标记
- en: Remember this expanded version of dependency registration shown earlier?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得之前显示的依赖项注册的扩展版本吗？
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `provide` property value is a token. This token is used to identify the
    dependency to inject. Whenever Angular sees this statement:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`provide`属性值是一个标记。此标记用于标识要注入的依赖项。每当Angular看到这个语句时：'
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It injects the correct dependency based on the class type. This is an example
    of a class token. The class type is used for dependency searching/mapping. Angular
    supports some other tokens too.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它根据类类型注入正确的依赖项。这是一个类令牌的示例。类类型用于依赖项搜索/映射。Angular还支持一些其他令牌。
- en: String token
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串令牌
- en: 'Instead of a class, we can use a string literal to identify a dependency. We
    can register the `WorkoutHistoryTracker` dependency using a string token, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字符串文字而不是类来标识依赖项。我们可以使用字符串令牌注册`WorkoutHistoryTracker`依赖项，如下所示：
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we now do:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在这样做：
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Angular does not like it one little bit and fails to inject the dependency.
    Since the `WorkoutHistoryTracker` seen before was registered with a string token,
    the token needs to be provided during injection too.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Angular一点也不喜欢它，并且无法注入依赖项。由于之前看到的`WorkoutHistoryTracker`是使用字符串令牌注册的，因此在注入时也需要提供令牌。
- en: 'To inject a dependency registered using a string token, we need to use the
    `@Inject` decorator. This works perfectly fine:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要注入使用字符串令牌注册的依赖项，我们需要使用`@Inject`装饰器。这样做非常完美：
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When `@Inject()` is not present, the Injector uses the type name of the parameter
    (class token).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当不存在`@Inject()`时，注入器使用参数的类型名称（类令牌）。
- en: 'String tokens are useful when registering instances or objects. The app configuration
    registration examples that we shared earlier can be rewritten using string tokens
    if there is no such class as `AppConfig`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册实例或对象时，字符串令牌非常有用。如果没有`AppConfig`这样的类，我们之前分享的应用程序配置注册示例可以使用字符串令牌进行重写：
- en: '[PRE45]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And then injected using `@Inject`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`@Inject`注入：
- en: '[PRE46]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'While any object can act as a token, the most common token types are class
    and string tokens. Internally, provider turns the token parameter into an instance
    of the `OpaqueToken` class. Look at the framework documentation to learn more
    about `OpaqueToken`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何对象都可以充当令牌，但最常见的令牌类型是类和字符串令牌。在内部，提供程序将令牌参数转换为`OpaqueToken`类的实例。查看框架文档以了解有关`OpaqueToken`的更多信息：
- en: '[https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html](https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html](https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html)。'
- en: While the `WorkoutHistoryTracker` injection into `WorkoutRunnerComponent` is
    done, its integration is still incomplete.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`WorkoutHistoryTracker`注入到`WorkoutRunnerComponent`中已完成，但其集成仍然不完整。
- en: Integrating with WorkoutRunnerComponent - continued
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与`WorkoutRunnerComponent`集成-继续
- en: The history tracker instance (`tracker`) needs to be called when the workout
    starts, when an exercise is complete, and when the workout finishes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 历史跟踪器实例（`tracker`）需要在锻炼开始时、锻炼完成时和锻炼结束时调用。
- en: 'Add this as the first statement in the `start` function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加为`start`函数中的第一条语句：
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `startExerciseTimeTracking` function, add the highlighted code after
    the `clearInterval` call:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startExerciseTimeTracking`函数中，在`clearInterval`调用后添加突出显示的代码：
- en: '[PRE48]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And the highlighted code inside the workout to complete the `else` condition
    in the same function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在锻炼中使用突出显示的代码来完成相同函数中的`else`条件：
- en: '[PRE49]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: History tracking is almost complete except for one case. What if the user manually
    navigates away from the workout page?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 历史跟踪几乎完成，除了一个情况。如果用户手动从锻炼页面导航离开呢？
- en: When that happens, we can always rely on the component's lifecycle hooks/events
    to help us. Workout tracking can be stopped when the `NgOnDestroy` event is fired.
    An appropriate place to perform any clean-up work is before the component is removed
    from the component tree. Let's do it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生这种情况时，我们总是可以依赖组件的生命周期钩子/事件来帮助我们。当触发`NgOnDestroy`事件时，可以停止锻炼跟踪。在组件从组件树中移除之前，执行任何清理工作的合适位置。让我们来做吧。
- en: 'Add this function to `workout-runner.component.ts`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数添加到`workout-runner.component.ts`中：
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While we now have workout history tracking implemented, we don't have a mechanism
    to check the history. The pressing need is for a workout history page/component.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在已经实现了锻炼历史跟踪，但我们没有检查历史的机制。迫切需要一个锻炼历史页面/组件。
- en: Adding the workout history page
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加锻炼历史页面
- en: The workout history data that we are collecting during the execution of the
    workout can now be rendered in a view. Let's add a History component. The component
    will be available at the `/history` location and can be loaded by clicking on
    a link in the app header section.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在锻炼执行过程中收集的锻炼历史数据现在可以在视图中呈现出来。让我们添加一个历史组件。该组件将位于`/history`位置，并且可以通过单击应用程序标题部分的链接来加载。
- en: 'Update the route definition in `app.routes.ts` to include a new route and the
    related import:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`app.routes.ts`中的路由定义以包括新路由和相关导入：
- en: '[PRE51]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The **History** link needs to be added to the app header section. Let''s refactor
    the header section into its own component. Update the `app.component.ts` template
    `navbar` `div` to:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**历史**链接需要添加到应用程序标题部分。让我们将标题部分重构为自己的组件。更新`app.component.ts`模板`navbar` `div`为：'
- en: '[PRE52]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There is a new `HeaderComponent` here. Copy the definition for the header component
    (`header.component.ts`) from the git branch `checkpoint3.2`, `app` folder (GitHub
    location: [http://bit.ly/ng2be-3-2-header-component-ts](http://bit.ly/ng2be-3-2-header-component-ts)).
    Also add the component to the declarations array in `app.module.ts` as we do for
    any Angular component:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个新的`HeaderComponent`。从git分支`checkpoint3.2`的`app`文件夹中复制标题组件（`header.component.ts`）的定义（GitHub位置：[http://bit.ly/ng2be-3-2-header-component-ts](http://bit.ly/ng2be-3-2-header-component-ts)）。还将该组件添加到`app.module.ts`的声明数组中，就像对任何Angular组件一样：
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you look at `HeaderComponent`, the history link is now there. Let's add the
    workout history component.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看`HeaderComponent`，现在已经有了历史链接。让我们添加锻炼历史组件。
- en: 'The `WorkoutHistoryComponent` implementation is available in the git branch
    `checkpoint3.2`; the folder is `workout-history` (GitHub location: [http://bit.ly/ng2be-3-2-workout-history](http://bit.ly/ng2be-3-2-workout-history)).
    Copy all three files from the folder to a corresponding folder locally. Remember
    to maintain the same folder hierarchy in your local setup too. Make a note that
    `WorkoutHistoryComponent` has been defined in a separate module (`WorkoutHistoryModule`)
    and needs to be imported into `AppModule` (`app.module.ts`). Import `WorkoutHistoryModule`
    into `AppModule` before proceeding further. For now remove all references to `SharedModule`
    from `WorkoutHistoryModule`.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryComponent`的实现可在git分支`checkpoint3.2`中找到；文件夹是`workout-history`（GitHub位置：[http://bit.ly/ng2be-3-2-workout-history](http://bit.ly/ng2be-3-2-workout-history)）。将文件夹中的所有三个文件复制到本地相应的文件夹中。记得在本地设置中保持相同的文件夹层次结构。请注意，`WorkoutHistoryComponent`已在一个单独的模块（`WorkoutHistoryModule`）中定义，并且需要导入到`AppModule`（`app.module.ts`）中。在继续之前，将`WorkoutHistoryModule`导入到`AppModule`中。现在从`WorkoutHistoryModule`中删除对`SharedModule`的所有引用。'
- en: 'The `WorkoutHistoryComponent` view code is trivial to say the least: a few
    Angular constructs, including `ngFor` and `ngIf`. The component implementation
    too is pretty straightforward. Inject the `WorkoutHistoryTracker` service dependency
    and set the history data when `WorkoutHistoryComponent` is initialized:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryComponent`的视图代码可以说是微不足道的：一些Angular构造，包括`ngFor`和`ngIf`。组件实现也非常简单。在`WorkoutHistoryComponent`初始化时注入`WorkoutHistoryTracker`服务依赖项并设置历史数据：'
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And this time, we use the `Location` service instead of `Router` to navigate
    away from the history component:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们使用`Location`服务而不是`Router`来从历史组件中导航离开：
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The Location service is used to interact with the browser URL. Depending upon
    the URL strategy, either URL paths (such as `/start`, `/workout`) or URL hash
    segments (such as `#/start`, `#/workout`) are used to track location changes.
    The router service too uses the location service internally to trigger navigation.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 位置服务用于与浏览器URL交互。根据URL策略，可以使用URL路径（例如`/start`，`/workout`）或URL哈希段（例如`#/start`，`#/workout`）来跟踪位置更改。路由器服务也在内部使用位置服务来触发导航。
- en: Tip
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Router versus Location**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器与位置**'
- en: While the `Location` service allows us to perform navigation, using `Router`
    is a preferred way to perform route navigation. We used the location service here
    because the need was to navigate to the last route without bothering about how
    to construct the route.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Location`服务允许我们执行导航，但使用`Router`是执行路由导航的首选方式。我们在这里使用位置服务，因为需要导航到最后一个路由，而不必担心如何构建路由。
- en: 'We are ready to test our workout history implementation. Load the start page
    and click on the **History** link. The history page is loaded with an empty grid.
    Start a workout and let an exercise complete. Check the history page again; there
    should be a workout listed:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备测试我们的锻炼历史实现。加载起始页面，然后单击**历史**链接。历史页面加载时为空白。开始锻炼并让一个锻炼完成。再次检查历史页面；应该列出一个锻炼：
- en: '![Adding the workout history page](../Images/image00448.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![添加锻炼历史页面](../Images/image00448.jpeg)'
- en: Looks good, except for one sore point in this listing. It would be better if
    the historical data were ordered chronologically, with the newest at the top.
    And it would be great if we had filtering capabilities too.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，除了这个列表中的一个痛点。如果历史数据按时间顺序排序，并且最新的数据在顶部，那将更好。如果我们也有过滤功能，那将更好。
- en: Sorting and filtering history data using pipes
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用管道对历史数据进行排序和过滤
- en: In [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2. 
    Building Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute
    Workout*, we explored pipes. We even built our own pipe to format seconds values
    as hh:mm:ss. Since the primary purpose of pipes is to transform data, this can
    be used with any input. For arrays, pipes can be used to sort and filter data.
    We create two pipes, one for each sorting and filtering.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "第2章。构建我们的第一个应用程序-7分钟锻炼")，“构建我们的第一个应用程序-7分钟锻炼”，我们探索了管道。我们甚至建立了自己的管道来将秒值格式化为hh:mm:ss。由于管道的主要目的是转换数据，这可以与任何输入一起使用。对于数组，管道可以用于对数据进行排序和过滤。我们创建了两个管道，一个用于排序，一个用于过滤。
- en: Note
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Angular1 has prebuilt filters (filters are pipes in Angular2), `orderBy` and
    `filter`, for this very purpose. The effort to port these filters in Angular2
    has been stalled for now. See this GitHub issue: [http://bit.ly/ng2-issue-2340](http://bit.ly/ng2-issue-2340).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Angular1具有预构建的过滤器（在Angular2中是管道），`orderBy`和`filter`，用于这个目的。目前，将这些过滤器移植到Angular2的工作已经停滞。请参阅此GitHub问题：[http://bit.ly/ng2-issue-2340](http://bit.ly/ng2-issue-2340)。
- en: Let's start with the `orderBy` pipe.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`orderBy`管道开始。
- en: The orderBy pipe
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: orderBy管道
- en: 'The `orderBy` pipe we implement is going to order an array of objects based
    on any of the object''s properties. The usage pattern for sorting items in ascending
    order based on the `fieldName` property is going to be:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的`orderBy`管道将根据对象的任何属性对对象数组进行排序。基于`fieldName`属性按升序排序项目的使用模式将是：
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And for sorting items in descending order, the usage pattern is:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于按降序排序项目，使用模式是：
- en: '[PRE57]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Make note of the extra hyphen before `fieldName`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`fieldName`之前的额外连字符。
- en: 'Create a folder called `shared` in `src/components` and copy all three files
    located in the corresponding location in git branch `checkpoint3.2` (GitHub location:
    [http://bit.ly/ng2be-3-2-shared](http://bit.ly/ng2be-3-2-shared)). There are two
    pipes and a new module definition (`SharedModule`) in this folder. `SharedModule`
    defines components/directives/pipes that that are shared across the application.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/components`中创建一个名为`shared`的文件夹，并复制位于git分支`checkpoint3.2`（GitHub位置：[http://bit.ly/ng2be-3-2-shared](http://bit.ly/ng2be-3-2-shared)）相应位置的所有三个文件。此文件夹中有两个管道和一个新的模块定义（`SharedModule`）。`SharedModule`定义了在整个应用程序中共享的组件/指令/管道。
- en: 'Open `order-by.pipe.ts` and look at the pipe implementation. While we are not
    going to delve into the pipe''s implementation details, some relevant parts need
    to be highlighted. Look at this pipe outline:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`order-by.pipe.ts`并查看管道实现。虽然我们不会深入讨论管道的实现细节，但有些相关部分需要被强调。查看这个管道概述：
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding `field` variable receives the field on which sorting is required.
    Check the code below to understand how the `field` argument is passed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`field`变量接收需要排序的字段。查看下面的代码以了解如何传递`field`参数。
- en: If the field has a `-` prefix, we truncate the prefix before sorting the array
    in descending order.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段有`-`前缀，我们在对数组进行降序排序之前截断前缀。
- en: Note
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The pipe also uses the spread operator, which may be new to you. Learn more
    about the spread operator on MDN here: [http://bit.ly/js-spread](http://bit.ly/js-spread).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 该管道还使用了扩展运算符，这可能对您来说是新的。在MDN上了解有关扩展运算符的更多信息：[http://bit.ly/js-spread](http://bit.ly/js-spread)。
- en: '**To use this pipe in the workout history view, import `SharedModule` into
    `WorkoutHistoryModule`.**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**要在锻炼历史视图中使用这个管道，将`SharedModule`导入`WorkoutHistoryModule`。**'
- en: 'Update the template HTML:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模板HTML：
- en: '[PRE59]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The historical data will now be sorted in descending order on `startedOn`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 历史数据现在将按`startedOn`降序排序。
- en: Note
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make note of the single quotes around the pipe parameter (`'-startedOn'`). We
    are passing a literal string to the `orderBy` pipe. Instead, pipe parameters can
    be bound to component properties too.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意管道参数周围的单引号（`'-startedOn'`）。我们将一个字面字符串传递给`orderBy`管道。相反，管道参数也可以绑定到组件属性。
- en: That's enough for the `orderBy` pipe. Let's implement filtering.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于`orderBy`管道已经足够了。让我们实现过滤。
- en: The search pipe
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索管道
- en: The `SearchPipe` that we added earlier does a basic equality-based filtering.
    Nothing special.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前添加的`SearchPipe`只是进行基于相等性的基本过滤。没有什么特别的。
- en: Look at the pipe code; the pipe takes two arguments, the first being the field
    to search and the second the value to search. We use the array's `filter` function
    to filter the record, doing a strict equality check.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 查看管道代码；管道接受两个参数，第一个是要搜索的字段，第二个是要搜索的值。我们使用数组的`filter`函数来过滤记录，进行严格的相等性检查。
- en: 'Let''s update the workout history view and incorporate the search pipe too.
    Open `workout-history.html` and uncomment the div with radio buttons. These radio
    buttons filter workouts based on whether they were completed or not. This is how
    the filter selection HTML looks:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新锻炼历史视图，并加入搜索管道。打开`workout-history.html`并取消注释带有单选按钮的div。这些单选按钮根据是否完成来过滤锻炼。这是过滤选择HTML的样子：
- en: '[PRE60]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can have three filters: `all`, `completed`, and `incomplete` workouts. The
    radio selection sets the component''s property `completed` using the `change`
    event expression. `$event.target` is the radio button that was clicked. We do
    not assign `completed=$event.target.value` as its value is of the string type.
    The `completed` property (on `WorkoutHistoryComponent`) should be of the `boolean`
    type for equality comparison with the `WorkoutLogEntry.completed` property to
    work.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有三个过滤器：`all`、`completed`和`incomplete`的锻炼。单选按钮通过`change`事件表达式设置组件的属性`completed`。`$event.target`是被点击的单选按钮。我们不将`completed=$event.target.value`赋值，因为它的值是字符串类型。`completed`属性（在`WorkoutHistoryComponent`上）应该是`boolean`类型，以便与`WorkoutLogEntry.completed`属性进行相等比较。
- en: 'The `search` pipe can now be added to the `ngFor` directive expression. We
    are going to chain the `search` and `orderBy` pipe. Update the `ngFor` expression
    to:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`管道现在可以添加到`ngFor`指令表达式中。我们将链式使用`search`和`orderBy`管道。更新`ngFor`表达式为：'
- en: '[PRE61]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `search` pipe first filters the historical data followed by the `orderBy`
    pipe reordering it. Pay close attention to the `search` pipe parameters: the first
    parameter is a string literal denoting the field to search (`''completed''`),
    whereas the second parameter is derived from the component property `completed`.
    Having the ability to bind pipe parameters to component properties allows us great
    flexibility.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`管道首先过滤历史数据，然后`orderBy`管道重新排序。要特别注意`search`管道的参数：第一个参数是一个字符串字面量，表示要搜索的字段（`''completed''`），而第二个参数是从组件属性`completed`派生的。能够将管道参数绑定到组件属性允许我们有很大的灵活性。'
- en: Go ahead and verify the search capabilities of the history page. Based on the
    radio selection, the history records are filtered, and of course they are sorted
    in reverse chronological order based on the workout start dates.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 继续验证历史页面的搜索功能。根据单选按钮的选择，历史记录被过滤，当然它们根据锻炼开始日期的逆序排列。
- en: While pipe usage with arrays looks simple, it can throw up some surprises if
    we do not understand when pipes are evaluated.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用管道与数组看起来很简单，但如果我们不理解管道何时被评估，可能会出现一些意外情况。
- en: Pipe gotcha with arrays
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组的管道陷阱
- en: To understand the issue with pipes applied to arrays, let's reproduce the problem.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解应用于数组的管道的问题，请重现问题。
- en: 'Open `search.pipe.ts` and remove the `@Pipe` decorator attribute `pure`. Also
    change the following statement:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`search.pipe.ts`并删除`@Pipe`装饰器属性`pure`。还要更改以下语句：
- en: '[PRE62]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 到以下内容：
- en: '[PRE63]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add a button at the end of the radio list (in `workout-history.html`) that
    adds a new log entry to the `history` array:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在单选按钮列表的末尾（在`workout-history.html`中）添加一个按钮，将新的日志条目添加到`history`数组中：
- en: '[PRE64]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add a function to `WorkoutHistoryComponent`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutHistoryComponent`中添加一个函数：
- en: '[PRE65]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The preceding function duplicates the first history item and adds back to the
    `history` array. If we load the page and click on the button, a new log entry
    gets added to the history array but it does not show up on the view, unless we
    change the filter (by clicking on the other radios). Interesting!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数复制了第一个历史项目，并将其添加回`history`数组。如果我们加载页面并点击按钮，新的日志条目将被添加到历史数组，但除非我们更改过滤器（点击其他单选按钮），否则它不会显示在视图中。有趣！
- en: Note
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before calling `addLog` make sure at least one history log is already there;
    otherwise the `addLog` function will fail.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`addLog`之前，请确保至少已经有一个历史记录；否则`addLog`函数将失败。
- en: The pipes that we have built thus far are *stateless* (also called pure) in
    nature. They simply transform input data into output. Stateless pipes are revaluated
    any time the pipe input changes (the expression on the left side of pipe symbol)
    or any pipe argument is updated.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建的管道都是*无状态*（也称为纯粹）的。它们只是将输入数据转换为输出。无状态管道在管道输入发生变化（管道符号左侧的表达式）或任何管道参数更新时重新评估。
- en: For arrays, this happens on an array assignment/reference change and not on
    the addition or deletion of elements. Switching the filter condition works as
    it causes the search pipe to evaluate again as the search parameter (the `completed`
    status) changes. This behavior is something to be aware of.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，这发生在数组赋值/引用更改时，而不是元素的添加或删除。切换过滤条件会起作用，因为它会导致搜索管道再次评估，因为搜索参数（`completed`状态）发生变化。这是需要注意的行为。
- en: 'What''s the fix? For starters, we can make the history array immutable, which
    implies that it cannot be changed once created. To add a new element we need to
    create a new array with the new value, something like:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么解决方法？首先，我们可以使历史数组不可变，这意味着一旦创建就无法更改。要添加一个新元素，我们需要使用新值创建一个新数组，类似于：
- en: '[PRE66]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Works perfectly, but we are changing our implementation to make it work with
    pipes. Instead, we can change the pipe and mark it stateful.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 工作得很完美，但我们正在改变我们的实现方式以使其与管道一起工作。相反，我们可以更改管道并将其标记为有状态。
- en: The difference between a stateless and stateful pipe is that stateful pipes
    are evaluated by Angular every time the framework does a change detection run,
    which involves checking the complete application for changes. Therefore, with
    stateful pipes, the check is not limited to the pipe input/argument changes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态和有状态管道的区别在于，有状态管道在每次框架进行变更检测运行时都会被Angular评估，这涉及检查完整的应用程序是否有变化。因此，对于有状态管道，检查不仅限于管道输入/参数的变化。
- en: 'To make a `search` pipe stateless, just update the `Pipe` decorator with `pure:false`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`search`管道无状态，只需使用`pure:false`更新`Pipe`装饰器：
- en: '[PRE67]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It still does not work! The `search` pipe has one more quirk that needs a fix.
    The **"All"** radio selection does not work perfectly. Add a new workout log,
    and it still does not show up, unless we switch filters.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然不起作用！`search`管道还有一个需要修复的小问题。**“全部”**单选按钮选择不完美。添加一个新的训练日志，它仍然不会显示，除非我们切换过滤器。
- en: 'The fix here is to revert this line in the `search` pipe:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方法是恢复`search`管道中的这一行：
- en: '[PRE68]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下内容：
- en: '[PRE69]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We changed the `if` condition to return a new array every time (using the spread
    operator), even when `searchTerm` is `null`. If we return the same array reference,
    Angular does not check for a size change in the array and hence does not update
    the UI.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`if`条件更改为每次返回一个新数组（使用扩展运算符），即使`searchTerm`为`null`。如果我们返回相同的数组引用，Angular不会检查数组大小的变化，因此不会更新UI。
- en: That completes our History page implementation. You may now be wondering what
    the last few fixes on pipes have to do with how change detection works. Or you
    may be wondering what is change detection? Let's put all of these doubts to rest
    and introduce everyone to Angular's change detection system.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的历史页面实现。您现在可能想知道管道的最后几个修复与变更检测的工作方式有什么关系。或者您可能想知道什么是变更检测？让我们消除所有这些疑虑，并向每个人介绍Angular的变更检测系统。
- en: Note
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Angular's change detection will be covered extensively in [Chapter 8](part0080.xhtml#2C9D01-edca168d36254bda8a21f611a95615c3
    "Chapter 8.  Some Practical Scenarios"), *Some Practical Scenarios*. The aim of
    the next section is to introduce the concept of change detection and how Angular
    performs this process.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的变更检测将在[第8章](part0080.xhtml#2C9D01-edca168d36254bda8a21f611a95615c3 "第8章。一些实际场景")中得到广泛覆盖，*一些实际场景*。下一节的目标是介绍变更检测的概念以及Angular如何执行此过程。
- en: Angular change detection overview
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular变更检测概述
- en: To put it succinctly, change detection is all about tracking changes done to
    the component model during app execution. This helps Angular's databinding infrastructure
    to identify what parts of the view need to be updated. Every databinding framework
    needs to address this issue, and the approach these frameworks take for tracking
    changes differs. It even differs from Angular1 to Angular2.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，变更检测就是跟踪应用程序执行期间对组件模型所做的更改。这有助于Angular的数据绑定基础设施确定需要更新哪些视图部分。每个数据绑定框架都需要解决这个问题，而这些框架用于跟踪更改的方法也不同。甚至从Angular1到Angular2也有所不同。
- en: To understand how change detection works in Angular, there are a few things
    that we need to keep in mind.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Angular中的变更检测如何工作，有一些事情我们需要记住。
- en: Firstly, an Angular app is nothing but a hierarchy of components, from root
    to the leaf.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，Angular应用程序只是一个从根到叶的组件层次结构。
- en: Secondly, there is nothing special about the component properties that we bind
    to view; therefore Angular needs an efficient mechanism to know when these properties
    change. It cannot keep polling for changes in these properties.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们绑定到视图的组件属性没有任何特殊之处；因此，Angular需要一种有效的机制来知道这些属性何时发生更改。它无法持续轮询这些属性的更改。
- en: And finally to detect changes in a property value Angular does a *strict comparison*
    (`===`) between the previous and current value. For reference types it means only
    the references are compared. No deep comparison is done.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，为了检测属性值的变化，Angular对先前值和当前值进行*严格比较*（`===`）。对于引用类型，这意味着只比较引用。不进行深层比较。
- en: Note
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For precisely this reason, we had to mark our search pipe as stateful.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为这个原因，我们不得不将我们的搜索管道标记为有状态。
- en: Adding elements to an existing array does not change the array reference and
    hence Angular fails to detect any change to the array. Once the pipe is marked
    as stateful, the pipe is evaluated irrespective of whether the array has changed
    or not.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 向现有数组添加元素不会改变数组引用，因此Angular无法检测到数组的任何更改。一旦管道被标记为有状态，无论数组是否发生更改，管道都会被评估。
- en: Since Angular cannot know when any bound property is updated automatically,
    it instead resorts to checking every bound property when a change detection run
    is triggered. Starting from the root of the component tree, Angular checks each
    bound property for changes down the component hierarchy. If a change is detected
    that component is marked for refresh. It's worth reiterating that changes in a
    bound property do not immediately update the view. Instead, a change detection
    run works in two phases.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular无法自动知道何时更新任何绑定属性，因此在触发变更检测运行时，它会检查每个绑定属性。从组件树的根开始，Angular检查每个绑定属性以查找组件层次结构中的更改。如果检测到更改，该组件将被标记为需要刷新。值得重申的是，绑定属性的更改不会立即更新视图。相反，变更检测运行分为两个阶段。
- en: In the first phase it does the component tree walk and marks components that
    need to be refreshed due to model updates
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一阶段，它执行组件树遍历并标记需要由于模型更新而刷新的组件
- en: In the second phase, the actual view is synchronized with the underlying model
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二阶段，实际视图与底层模型同步
- en: Note
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Model changes and view updates are never interleaved during a change detection
    run.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在变更检测运行期间，模型更改和视图更新永远不会交错进行。
- en: We now just need to answer two more questions. When is a change detection run
    triggered? And how many times does it run?
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要回答另外两个问题。何时触发变更检测运行？它运行多少次？
- en: 'An Angular change detection run is triggered when any of these events are triggered:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发以下事件之一时，将触发Angular变更检测运行：
- en: '**User input/ browser events**: We click on a button, enter some text, scroll
    the content. Each of these actions can update the view (and the underlying model).'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入/浏览器事件**：我们点击按钮，输入一些文本，滚动内容。这些操作都可以更新视图（和底层模型）。'
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程 XHR 请求**：这是视图更新的另一个常见原因。从远程服务器获取数据以显示在网格上，以及获取用户数据以渲染视图都是这种情况的例子。'
- en: '**setTimeout and setInterval**: As it turns out, we can use `setTimeout` and
    `setInterval` to execute some code asynchronously and at specific intervals. Such
    code can also update the model. For example, a `setInterval` timer may check for
    stock quotes at regular interval and updates the stock price on the UI.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setTimeout 和 setInterval**：事实证明，我们可以使用`setTimeout`和`setInterval`来异步执行一些代码，并在特定间隔内执行。这样的代码也可以更新模型。例如，`setInterval`计时器可以定期检查股票报价并更新
    UI 上的股价。'
- en: And most importantly each component model is checked only once, in a top-down
    fashion, starting from the root component to the tree leaves.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，每个组件模型只检查一次，以自顶向下的方式进行，从根组件到树叶。
- en: Note
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The last statement is true when Angular is configured to run in production mode.
    In development mode the component tree is traversed twice for changes. Angular
    expects that the model be stable after the first tree walk. If that is not the
    case Angular throws an error in development mode, and ignores the changes in production
    mode.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 配置为运行在生产模式时，最后一句是正确的。在开发模式下，组件树会被遍历两次以进行更改。Angular 期望在第一次遍历树后模型是稳定的。如果不是这种情况，Angular
    会在开发模式下抛出错误，并在生产模式下忽略更改。
- en: We can enable production mode by invoking the `enableProdMode` function before
    the `bootstrap` function call. `import {enableProdMode} from '@angular/core'`
    `enableProdMode();` `platformBrowserDynamic().bootstrapModule(AppModule);`
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`bootstrap`函数调用之前调用`enableProdMode`函数来启用生产模式。`import {enableProdMode}
    from '@angular/core'` `enableProdMode();` `platformBrowserDynamic().bootstrapModule(AppModule);`
- en: Let's explore some other faÃ§ades of the Angular DI framework, starting with
    hierarchical injectors, a confusing yet very powerful feature of Angular.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些 Angular DI 框架的其他方面，从层次注入器开始，这是 Angular 的一个令人困惑但非常强大的特性。
- en: Hierarchical injectors
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次注入器
- en: An injector in Angular is a dependency container that is responsible for storing
    dependencies and dispensing them when asked for. The provider registration examples
    shown earlier on modules actually register the dependencies with a global Injector.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，注入器是一个负责存储依赖项并在需要时分发它们的依赖容器。之前在模块上展示的提供者注册示例实际上是在全局注入器中注册依赖项。
- en: Registering component level dependencies
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册组件级别的依赖关系
- en: All of the dependency registration that we have done thus far were done inside
    a module. Angular goes one step further and allows registration of dependencies
    at the component level too. There is a similar providers attribute on the `@Component`
    decorator that allows us to register dependency at the component level.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的所有依赖注册都是在模块内完成的。Angular 更进一步，还允许在组件级别注册依赖关系。在`@Component`装饰器上有一个类似的
    providers 属性，允许我们在组件级别注册依赖。
- en: 'We could''ve very well registered the `WorkoutHistoryTracker` dependency on
    `WorkoutRunnerComponent`. Something on these lines:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来可以在`WorkoutRunnerComponent`上注册`WorkoutHistoryTracker`的依赖关系。类似这样的东西：
- en: '[PRE70]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: But whether we should do it or not is something that we are going to discuss
    in this section shortly.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们是否应该这样做，这是我们将在本节中讨论的事情。
- en: In the context of this discussion on hierarchical injectors, it's important
    to understand that Angular creates an injector per component (oversimplified).
    Dependency registration done at the component level is available on the component
    and its descendants.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论分层注射器的情况下，重要的是要理解Angular为每个组件创建一个注射器（过于简化）。在组件级别进行的依赖项注册可在组件及其后代上使用。
- en: We also learned that dependencies are singleton in nature. Once created, the
    Injector will always return the same dependency every time. This feature is quite
    evident from the workout history implementation.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学到了依赖项是单例的。一旦创建，注射器每次都会返回相同的依赖项。这一特性在锻炼历史实现中非常明显。
- en: '`WorkoutHistoryTracker` was registered with the `ServicesModule` and then injected
    into two components, `WorkoutRunnerComponent` and `WorkoutHistoryComponent`. Both
    components get the same instance of `WorkoutHistoryTracker`. The next diagram
    highlights this registration and injection:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryTracker`已在`ServicesModule`中注册，然后注入到两个组件`WorkoutRunnerComponent`和`WorkoutHistoryComponent`中。两个组件都获得相同的`WorkoutHistoryTracker`实例。下一个图表突出了这个注册和注入：'
- en: '![Registering component level dependencies](../Images/image00449.jpeg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![注册组件级别依赖项](../Images/image00449.jpeg)'
- en: 'To confirm, just add a `console.log` statement in the `WorkoutHistoryTracker`
    constructor:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认，只需在`WorkoutHistoryTracker`构造函数中添加一个`console.log`语句：
- en: '[PRE71]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Refresh the app and open the history page by clicking on the header link. The
    message log is generated once, irrespective of how many times we run the workout
    or open the history page.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新应用程序并通过点击标题链接打开历史页面。无论我们运行锻炼多少次或打开历史页面，消息日志都会生成一次。
- en: We now see a new interaction/data flow pattern! Think carefully; a service is
    being used to share state between two components. `WorkoutRunnerComponent` is
    generating data and `WorkoutHistoryComponent` is consuming it. And that too without
    any interdependence. We are exploiting the fact that dependencies are singleton
    in nature. This data sharing/interaction/data flow pattern can be used to share
    state between any number of components. Indeed, this is a very powerful weapon
    in our arsenal. Next time, there is a need to share state between unrelated components,
    think of services.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了一个新的交互/数据流模式！仔细想想；一个服务被用来在两个组件之间共享状态。`WorkoutRunnerComponent`生成数据，`WorkoutHistoryComponent`消耗数据。而且这一切都没有任何相互依赖。我们正在利用依赖项是单例的事实。这种数据共享/交互/数据流模式可以用来在任意数量的组件之间共享状态。事实上，这是我们武器库中非常强大的武器。下次需要在不相关的组件之间共享状态时，考虑使用服务。
- en: But what does this have to do with hierarchical injectors? Ok, let's not beat
    around the bush; let's get straight to the point.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 但这与分层注射器有什么关系呢？好吧，让我们不拐弯抹角了；让我们直截了当地说。
- en: While dependencies registered with the injector are singleton, Injector itself
    is not! At any given point in time, there are multiple injectors active in the
    application. In fact, injectors are created in the same hierarchy as the component
    tree. Angular creates an `Injector` instance for every component in the component
    tree (oversimplification; see the next information box).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用注射器注册的依赖项是单例的，但注射器本身不是！在任何给定的时间点，应用程序中都有多个活动的注射器。实际上，注射器是按照组件树的相同层次结构创建的。Angular为组件树中的每个组件创建一个`Injector`实例（过于简化；请参阅下一个信息框）。
- en: Note
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Angular does not literally create an injector for each component. As explained
    in Angular the developer guide:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Angular并不是为每个组件都创建一个注射器。如Angular开发人员指南中所解释的：
- en: Every component doesn't need its own injector and it would be horribly inefficient
    to create masses of injectors for no good purpose.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都不需要自己的注射器，为了没有好处而大量创建注射器将是非常低效的。
- en: But it is true that every component has an injector (even if it shares that
    injector with another component) and there may be many different injector instances
    operating at different levels of the component tree.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实是每个组件都有一个注入器（即使它与另一个组件共享该注入器），并且可能有许多不同的注入器实例在组件树的不同级别运行。
- en: It is useful to pretend that every component has its own injector.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个组件都有自己的注入器是很有用的。
- en: 'The component and injector tree looks something like this when a workout is
    running:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行锻炼时，组件和注入器树看起来像这样：
- en: '![Registering component level dependencies](../Images/image00450.jpeg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![注册组件级别依赖项](../Images/image00450.jpeg)'
- en: The insert textbox denotes the component name. The **root injector** is the
    injector created as part of the application bootstrap process.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 插入文本框表示组件名称。**根注入器**是作为应用程序引导过程的一部分创建的注入器。
- en: What is the significance of this injector hierarchy? To understand the implications,
    we need to understand what happens when a component requests for a dependency.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这种注入器层次结构的重要性是什么？要理解其影响，我们需要了解当组件请求依赖项时会发生什么。
- en: Angular DI dependency walk
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular DI依赖项遍历
- en: 'Whenever requesting for a dependency, Angular first tries to satisfy the dependency
    from the component''s own injector. If it fails to find the requested dependency,
    it queries the parent component injector for the dependency, and its parent if
    the probing fails again, and so on and so forth till it finds the dependency or
    reaches the root injector. The takeaway: any dependency search is hierarchy-based.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 每当请求依赖项时，Angular首先尝试从组件自己的注入器满足依赖项。如果无法找到所请求的依赖项，则会查询父组件注入器以获取依赖项，如果再次失败，则查询其父级，依此类推，直到找到依赖项或达到根注入器。要点：任何依赖搜索都是基于层次结构的。
- en: Earlier when we registered `WorkoutHistoryTracker`, it was registered with the
    root injector. The `WorkoutHistoryTracker` dependency request from both `WorkoutRunnerComponent`
    and `WorkoutHistoryComponent` was satisfied by the root injector, not their own
    component injectors.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，当我们注册`WorkoutHistoryTracker`时，它是与根注入器一起注册的。`WorkoutRunnerComponent`和`WorkoutHistoryComponent`对`WorkoutHistoryTracker`的依赖请求是由根注入器满足的，而不是它们自己的组件注入器。
- en: This hierarchical injector structure brings a lot of flexibility. We can configure
    different providers at different component levels and override the parent provider
    configuration in child components. This only applies to dependencies registered
    on components. If the dependency is added on a module it gets registered on the
    root injector.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分层注入器结构带来了很大的灵活性。我们可以在不同的组件级别配置不同的提供者，并在子组件中覆盖父级提供者配置。这仅适用于在组件上注册的依赖项。如果依赖项添加在模块上，它将在根注入器上注册。
- en: Let's try to override the global `WorkoutHistoryTracker` service in components
    that use it to learn what happens on such overrides. It's going to be fun and
    we will learn a lot!
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在使用它的组件中覆盖全局`WorkoutHistoryTracker`服务，以了解这种覆盖会发生什么。这将会很有趣，我们会学到很多！
- en: 'Open `workout-runner.component.ts` and to the `@Component` decorator add a
    `providers` attribute:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-runner.component.ts`，并在`@Component`装饰器中添加一个`providers`属性：
- en: '[PRE72]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Do this in `workout-history.component.ts` too. Now if we refresh the app, start
    a workout, and then load the history page, the grid is empty. Irrespective of
    the times we try to run the workout, the history grid is always empty.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-history.component.ts`中也这样做。现在，如果我们刷新应用程序，开始锻炼，然后加载历史页面，网格是空的。无论我们尝试运行锻炼的次数，历史网格始终为空。
- en: 'The reason is quite obvious. Post setting the `WorkoutHistoryTracker` provider
    on each `WorkoutRunnerComponent` and `WorkoutHistoryComponent`, the dependency
    is being fulfilled by the respective component injectors themselves. Both component
    injectors create their own instance of `WorkoutHistoryTracker` when requested,
    and hence history tracking is broken. Look at the following diagram to understand
    how the request is fulfilled in both scenarios:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是非常明显的。在每个`WorkoutRunnerComponent`和`WorkoutHistoryComponent`上设置`WorkoutHistoryTracker`提供程序后，依赖关系由各自的组件注入器自行满足。当请求时，两个组件注入器都会创建自己的`WorkoutHistoryTracker`实例，因此历史跟踪被破坏。查看以下图表以了解在两种情况下请求是如何被满足的：
- en: '![Angular DI dependency walk](../Images/image00451.jpeg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![Angular DI dependency walk](../Images/image00451.jpeg)'
- en: 'A quick question: What happens if we register the dependency in the root component,
    `TrainerAppComponent`, instead of doing it during app bootstrapping? Something
    like:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的问题：如果我们在根组件`TrainerAppComponent`中注册依赖项，而不是在应用程序引导期间进行注册，会发生什么？类似于：
- en: '[PRE73]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Interestingly, with this setup too, things work perfectly. That's pretty evident;
    `TrainerAppComponent` is a parent component for `RouterOutlet` that internally
    loads `WorkoutRunnerComponent` and `WorkoutHistoryComponent`. Hence in such a
    setup, the dependency gets fulfilled by the `TrainerAppComponent`'s injector.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，即使使用这种设置，事情也能完美地运行。这是非常明显的；`TrainerAppComponent`是`RouterOutlet`的父组件，它在内部加载`WorkoutRunnerComponent`和`WorkoutHistoryComponent`。因此，在这样的设置中，依赖关系由`TrainerAppComponent`的注入器满足。
- en: Note
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Dependency lookup up on the component hierarchy can be manipulated if an intermediate
    component has declared itself as a host component. We will learn more about it
    in later chapters.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中间组件声明自己是宿主组件，那么在组件层次结构上进行的依赖查找可以被操纵。我们将在后面的章节中了解更多关于这个的内容。
- en: Hierarchical injectors allow us to register dependencies at a component level,
    avoiding the need to register all dependencies globally.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 分层注入器允许我们在组件级别注册依赖项，避免了全局注册所有依赖项的需要。
- en: This functionality really comes in handy when building an Angular library component.
    Such components can register their own dependencies without requiring the consumer
    of the library to register library-specific dependencies.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在构建Angular库组件时非常方便。这样的组件可以注册它们自己的依赖项，而不需要库的消费者注册特定于库的依赖项。
- en: Tip
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Remember: if you are having trouble loading the right service/dependency, make
    sure you check the component hierarchy for overrides done at any level.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：如果你在加载正确的服务/依赖项时遇到问题，请确保检查组件层次结构，看看是否在任何级别上进行了覆盖。
- en: We now understand how dependency resolution works in components. But what happens
    if a service has a dependency? Yet another uncharted territory to explore.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解了组件中的依赖解析是如何工作的。但是如果一个服务有一个依赖项会发生什么呢？又是另一个未知的领域需要探索。
- en: Tip
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remove the `provider` registration we did in those two components before continuing
    further.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，删除我们在这两个组件中进行的`provider`注册。
- en: Dependency injection with @Injectable
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@Injectable进行依赖注入
- en: The `WorkoutHistoryTracker` has a fundamental flaw; the history is not persisted.
    Refresh the app and the history is lost. We need to add persistence logic to store
    historical data. To avoid any complex setup, we use the browser local storage
    to store historical data.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryTracker`有一个基本缺陷；历史记录没有被持久化。刷新应用程序，历史记录就丢失了。我们需要添加持久化逻辑来存储历史数据。为了避免任何复杂的设置，我们使用浏览器本地存储来存储历史数据。'
- en: 'Add a `local-storage.ts` file to the `services` folder. And add the following
    class definition:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在`services`文件夹中添加一个`local-storage.ts`文件。并添加以下类定义：
- en: '[PRE74]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: A simple wrapper over the browser's `localStorage` object.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的`localStorage`对象上的一个简单包装器。
- en: Go ahead and register the `LocalStorage` service in the services module (`services.module.ts`).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在服务模块（`services.module.ts`）中注册 `LocalStorage` 服务。
- en: 'And like any other dependency, inject it in the `WorkoutHistoryTracker` constructor
    (the `workout-history-tracker.ts` file) with the necessary import:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他依赖项一样，在 `WorkoutHistoryTracker` 构造函数中注入它（`workout-history-tracker.ts` 文件）并进行必要的导入：
- en: '[PRE75]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is standard DI stuff except that it does not work as expected. If we refresh
    the app now, Angular throws an error:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标准的 DI 内容，只是它没有按预期工作。如果我们现在刷新应用程序，Angular 会抛出一个错误：
- en: '[PRE76]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Strange! The all so awesome DI failed, and for no good reason! Not really; Angular
    is not doing any magic. It needs to know the class dependencies, and the only
    way it can know these is by inspecting the class definition and constructor arguments.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪！这么棒的 DI 居然失败了，而且没有任何好的理由！其实不然；Angular 并没有进行任何魔法。它需要知道类的依赖关系，唯一的方法就是检查类的定义和构造函数参数。
- en: 'Add a decorator called `@Injectable()` (remember to add parentheses) above
    `WorkoutHistoryTracker` and add the module import statement:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WorkoutHistoryTracker` 上添加一个名为 `@Injectable()` 的装饰器（记得加上括号），并添加模块导入语句：
- en: '[PRE77]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Refresh the page and the DI works perfectly. What made it work?
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面，DI 就能完美地工作了。是什么让它工作的？
- en: By putting in the `@Injectable` decorator, we are forcing the TypeScript transpiler
    to generate metadata for the `WorkoutHistoryTracker` class. This includes details
    about the constructor arguments. Angular DI consumes this generated metadata to
    determine the types of dependency the service has, and in future it fulfils these
    dependencies when the service is created.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `@Injectable` 装饰器，我们强制 TypeScript 转译器为 `WorkoutHistoryTracker` 类生成元数据。这包括有关构造函数参数的详细信息。Angular
    DI 使用这些生成的元数据来确定服务的依赖类型，并在将来创建服务时满足这些依赖。
- en: What about components using `WorkoutHistoryTracker`? We have not used `@Injectable`
    there but still the DI works. We don't need to. Any decorator works and there
    is already an `@Component` decorator applied to all components.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 那些使用 `WorkoutHistoryTracker` 的组件呢？我们没有在那里使用 `@Injectable`，但是 DI 仍然起作用。我们不需要。任何装饰器都可以使用，而且所有组件已经应用了
    `@Component` 装饰器。
- en: Tip
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember the decorator needs to be added on the calling class (or client class).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 记住装饰器需要添加到调用类（或客户类）上。
- en: The actual integration between the `LocalStorage` service and `WorkoutHistoryTracker`
    is a mundane process.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalStorage` 服务和 `WorkoutHistoryTracker` 之间的实际集成是一个平凡的过程。'
- en: 'Update the constructor for `WorkoutHistoryTracker` as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `WorkoutHistoryTracker` 的构造函数如下：
- en: '[PRE78]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And add a declaration for `storageKey`:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 并添加一个 `storageKey` 的声明：
- en: '[PRE79]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The constructor loads the workout logs from the local storage. The `map` function
    call is necessary as everything stored in `localStorage` is a string. Therefore,
    while de-serializing we need to convert the string back to the date value.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数从本地存储中加载训练日志。`map` 函数调用是必要的，因为 `localStorage` 中存储的所有内容都是字符串。因此，在反序列化时，我们需要将字符串转换回日期值。
- en: 'Add this statement last in the `startTracking`, `exerciseComplete`, and `endTracking`
    functions:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `startTracking`、`exerciseComplete` 和 `endTracking` 函数中最后添加这个声明：
- en: '[PRE80]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We save the workout history to local storage every time historical data changes.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次历史数据发生变化时都会将训练记录保存到本地存储中。
- en: That's it! We have built workout history tracking over `localStorage`. Verify
    it!
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经在 `localStorage` 上构建了训练历史记录跟踪。验证一下！
- en: Before we move on to our big-ticket item, audio support, there are a few minor
    fixes that are needed for a better user experience. The first one is related to
    the **History** link.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理音频支持这个大问题之前，还有一些小的修复需要进行，以提供更好的用户体验。第一个与 **历史** 链接有关。
- en: Tracking route changes using the router service
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路由器服务跟踪路由更改。
- en: The **History** link in the `Header` component is visible for all routes. It
    will be better if we hide the link on the workout page. We don't want to lose
    an in-progress workout by accidentally clicking on the **History** link. Moreover,
    no one is interested in knowing about the workout history while doing a workout.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`Header`组件中的**History**链接对所有路由可见。如果在锻炼页面上隐藏该链接会更好。我们不希望因为意外点击**History**链接而丢失正在进行中的锻炼。此外，在进行锻炼时，没有人对锻炼历史感兴趣。'
- en: The fix is easy. We just need to determine if the current route is the workout
    route and hide the link. The `Router` service is going to help us with this job.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 修复很容易。我们只需要确定当前路由是否是锻炼路由，并隐藏链接。`Router`服务将帮助我们完成这项工作。
- en: 'Open `header.component.ts` and add the necessary imports for router; update
    the `Header` class definition to:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`header.component.ts`并为路由添加必要的导入；更新`Header`类的定义为：
- en: '[PRE81]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `showHistoryLink` property determines if the history link is shown to the
    user or not. In the constructor, we inject the `Router` service and register a
    callback on the `events` property using the `subscribe` function.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`showHistoryLink`属性确定是否向用户显示历史链接。在构造函数中，我们注入了`Router`服务，并使用`subscribe`函数在`events`属性上注册了一个回调。'
- en: The `events` property is an observable. We will learn more about observables
    later in the chapter, but for now it is enough to understand that observables
    are objects that raise events and can be subscribed to. The `subscribe` function
    registers a callback function that is invoked every time the route changes.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`events`属性是一个可观察对象。我们将在本章后面学习更多关于可观察对象的知识，但现在理解可观察对象是指能够触发事件并且可以被订阅的对象就足够了。`subscribe`函数注册一个回调函数，每当路由改变时就会被调用。'
- en: The callback implementation just toggles the `showHistoryLink` state based on
    the current route name. The name we derive from the `url` property of the `router`
    object.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的实现只是根据当前路由名称切换`showHistoryLink`状态。我们从`router`对象的`url`属性中获取名称。
- en: 'To use the `showHistoryLink` in the view just update the header template line
    with the anchor tag to:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中使用`showHistoryLink`，只需更新头部模板行的锚标签为：
- en: '[PRE82]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: And that's it! The **History** link does not show up on the workout page.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！**History**链接不会出现在锻炼页面上。
- en: Another fix/enhancement is related to the video panel on the workout page.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个修复/增强与锻炼页面上的视频面板有关。
- en: Fixing the video playback experience
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复视频播放体验
- en: The current video panel implementation can at best be termed amateurish. The
    size of the default player is small. When we play the video, the workout does
    not pause. The video playback is interrupted on exercise transitions. Also, the
    overall video load experience adds a noticeable lag at the start of every exercise
    routine. This is a clear indication that this approach to video playback needs
    some fixing.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当前视频面板的实现最多可以称为业余。默认播放器的大小很小。当我们播放视频时，锻炼不会暂停。在锻炼转换时，视频播放会中断。此外，整体视频加载体验在每次锻炼例行程序开始时都会有明显的延迟。这清楚地表明了视频播放需要一些修复。
- en: 'This is what we are going to do to fix the video panel:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们要做的来修复视频面板的方法：
- en: Show the image thumbnail for the exercise video instead of loading the video
    player itself
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为锻炼视频使用图像缩略图，而不是加载视频播放器本身
- en: When the user clicks on the thumbnail, load a popup/dialog with a bigger video
    player that can play the selected video
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击缩略图时，加载一个可以播放所选视频的更大的视频播放器的弹出窗口/对话框
- en: Pause the workout while the video playback is on
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视频播放时暂停锻炼
- en: Let's get on with the job!
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作吧！
- en: Using thumbnails for video
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视频缩略图
- en: 'Replace the `ngFor` template html inside `video-player.html` with this snippet:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 用这段代码替换`video-player.html`中的`ngFor`模板html：
- en: '[PRE83]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We have abandoned iframe and instead loaded the thumbnail image of the video
    (check the `img` tag). All other content shown here is for styling the image.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经放弃了iframe，而是加载了视频的缩略图图片（检查`img`标签）。这里显示的所有其他内容都是为了给图片设置样式。
- en: Note
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have referenced the Stack Overflow post at [http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)
    to determine the thumbnail image URL for our videos.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经参考了Stack Overflow上的帖子[http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)来确定我们视频的缩略图图片URL。
- en: Start a new workout; the images should show up, but the playback functionality
    is broken. We need to add the video playback dialog.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的训练；图片应该显示出来，但是播放功能是坏的。我们需要添加视频播放对话框。
- en: Using the angular2-modal dialog library
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用angular2-modal对话框库
- en: The Angular framework does not come with any pre-packaged UI library/controls.
    We need to look outwards and find a community solution for any UI control requirements.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架没有预打包的UI库/控件。我们需要向外寻找社区解决方案来满足任何UI控件的需求。
- en: The library we are going to use is angular2-modal, available on GitHub at [http://bit.ly/angular2-modal](http://bit.ly/angular2-modal).
    Let's install and configure the library.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的库是angular2-modal，在GitHub上可以找到[http://bit.ly/angular2-modal](http://bit.ly/angular2-modal)。让我们安装和配置这个库。
- en: 'From the command line (inside the `trainer` folder), run the following command
    to install the library:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行（在`trainer`文件夹内），运行以下命令来安装这个库：
- en: '[PRE84]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To integrate angular2-modal within our app, we need to add the package references
    for angular2-modal in `systemjs.config.js`. Copy the updated `systemjs.config.js`
    from git branch `checkpoint3.2` (GitHub location: [http://bit.ly/ng2be-3-2-system-config-js](http://bit.ly/ng2be-3-2-system-config-js))
    in the `trainer` folder and overwriting the local configuration file. The updated
    configurations allow SystemJS to know how to load the modal dialog library when
    it encounters library `import` statements.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用中集成angular2-modal，我们需要在`systemjs.config.js`中添加angular2-modal的包引用。从git分支`checkpoint3.2`（GitHub位置：[http://bit.ly/ng2be-3-2-system-config-js](http://bit.ly/ng2be-3-2-system-config-js)）中复制更新后的`systemjs.config.js`到`trainer`文件夹，并覆盖本地配置文件。更新后的配置允许SystemJS在遇到库`import`语句时知道如何加载模态对话框库。
- en: 'The next few steps highlight the configuration ceremony to be performed before
    angular2-modal can be used:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几步突出了在使用angular2-modal之前需要执行的配置仪式：
- en: 'In the first step, we configure the root element for angular2-modal. Open `app.component.ts`
    and add the highlighted code:'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一步中，我们要配置angular2-modal的根元素。打开`app.component.ts`并添加下面的代码：
- en: '[PRE85]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This step is essential as the modal dialog needs a container component to host
    itself. By passing in the `ViewContainerRef` of `TrainerAppComponent`, we allow
    the dialog to load inside the app root.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步是必不可少的，因为模态对话框需要一个容器组件来托管自己。通过传入`TrainerAppComponent`的`ViewContainerRef`，我们允许对话框在应用根内加载。
- en: 'The next step is to add two modules from the library to `AppModule`. Update
    `app.module.ts` and add this code:'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步是将库中的两个模块添加到`AppModule`中。更新`app.module.ts`并添加以下代码：
- en: '[PRE86]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The library is now ready for use.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个库已经准备好使用了。
- en: While angular2-modal has a number of predefined templates for standard dialogs
    such as alert, prompt, and confirm, these dialogs provide little customization
    in terms of look and feel. To have better control over the dialog UI, we need
    to create a custom dialog, which thankfully the library supports.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然angular2-modal有许多预定义的标准对话框模板，比如警报、提示和确认，但这些对话框在外观和感觉方面提供了很少的定制。为了更好地控制对话框UI，我们需要创建一个自定义对话框，幸运的是这个库支持。
- en: Creating custom dialogs with angular2-modal
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用angular2-modal创建自定义对话框
- en: Custom dialogs in angular2-modal are nothing but Angular components with some
    special library constructs incorporated.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在angular2-modal中创建自定义对话框只是一些带有一些特殊库构造的Angular组件。
- en: 'Copy the `video-dialog.component.ts` file from the `workout-runner/video-player`
    folder in git branch `checkpoint3.2` (GitHub location: [http://bit.ly/ng2be-3-2-video-dialog-component-ts](http://bit.ly/ng2be-3-2-video-dialog-component-ts))
    into your local setup. The file contains the custom dialog implementation.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 从git分支`checkpoint3.2`的`workout-runner/video-player`文件夹中复制`video-dialog.component.ts`文件（GitHub位置：[http://bit.ly/ng2be-3-2-video-dialog-component-ts](http://bit.ly/ng2be-3-2-video-dialog-component-ts)）到本地设置中。该文件包含了自定义对话框的实现。
- en: 'Next, update `workout-runner.module.ts` and add a new `entryComponents` attribute
    to the module decorator:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新`workout-runner.module.ts`，并在模块装饰器中添加一个新的`entryComponents`属性：
- en: '[PRE87]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `VideoDialogComponent` needs to be added to `entryComponents` as it is not
    explicitly used in the component tree.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将`VideoDialogComponent`添加到`entryComponents`中，因为它在组件树中没有明确使用。
- en: The `VideoDialogComponent` is a standard Angular component, with some modal
    dialog, specific implementations that we describe later.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoDialogComponent`是一个标准的Angular组件，具有一些模态对话框的特定实现，我们稍后会描述。'
- en: The `VideoDialogContext` class has been created to pass the `videoId` of the
    YouTube video clicked to the dialog instance. The class inherits from `BSModalContext` a
    configuration class the dialog library uses to alter the behavior and UI of the
    modal dialog.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoDialogContext`类已经被创建，用于将点击的YouTube视频的`videoId`传递给对话框实例。该类继承自`BSModalContext`，这是对话框库用于修改模态对话框行为和UI的配置类。'
- en: To get a better sense of how `VideoDialogContext` is utilized, let's invoke
    the preceding dialog from workout runner.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解`VideoDialogContext`的使用方式，让我们从锻炼运行器中调用前面的对话框。
- en: 'Update the `ngFor` div in `video-player.html` and add a `click` event handler:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`video-player.html`中的`ngFor` div，并添加一个`click`事件处理程序：
- en: '[PRE88]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The preceding handler invokes the `playVideo` method, passing in the video
    clicked. The `playVideo` function in turn opens the corresponding video dialog.
    Add the `playVideo` implementation to `video-player.component.ts` as highlighted:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的处理程序调用`playVideo`方法，传入点击的视频。`playVideo`函数反过来打开相应的视频对话框。将`playVideo`的实现添加到`video-player.component.ts`中，如下所示：
- en: '[PRE89]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The `playVideo` function calls the `Modal` class `open` function, passing in
    the dialog component to open and a new instance of the `VideoDialogContext` class
    with the `videoId` of the YouTube video. Before proceeding, delete the `ngOnChange`
    function from the file too.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`playVideo`函数调用`Modal`类的`open`函数，传入要打开的对话框组件以及`VideoDialogContext`类的新实例，其中包含YouTube视频的`videoId`。在继续之前，也要从文件中删除`ngOnChange`函数。'
- en: The dialog implementation in `video-dialog.component.ts` implements the `ModalComponent<VideoDialogContext>`
    interface, required by the modal library. Look at how the context (`VideoDialogContext`)
    to the dialog is passed to the constructor and how we extract and assign the `videoId`
    property from the context. Then it's just a matter of binding the `videoId` property
    to the template view (see the template HTML) and rendering the YouTube player.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`video-dialog.component.ts`中的对话框实现实现了`ModalComponent<VideoDialogContext>`接口，这是模态库所需的。看看如何将上下文(`VideoDialogContext`)传递给构造函数，以及如何从上下文中提取和分配`videoId`属性。然后只需要将`videoId`属性绑定到模板视图（查看模板HTML）并渲染YouTube播放器。'
- en: And we are good to go. Load the app and start the workout. Then click on any
    workout video images. The video dialog should load and now we can watch the video!
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备就绪。加载应用程序并开始锻炼。然后点击任何锻炼视频图片。视频对话框应该加载，现在我们可以观看视频了！
- en: 'Before we call the dialog implementation complete, there is one small issue
    that needs to be fixed. When the dialog opens the workout should pause: that''s
    not happening currently. We will fix it in the next section using Angular eventing
    support.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成对话框实现之前，有一个小问题需要解决。当对话框打开时，锻炼应该暂停：目前并没有发生。我们将在下一节中使用Angular事件支持来解决这个问题。
- en: Note
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are having a problem with running the code, look at git branch `checkpoint3.2`
    for a working version of what we have done thus far.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看git分支`checkpoint3.2`，以获取我们迄今为止所做的工作的可工作版本。
- en: Or if you are not using git, download the snapshot of `checkpoint3.2` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-2](http://bit.ly/ng2be-checkpoint3-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您不使用git，请从[http://bit.ly/ng2be-checkpoint3-2](http://bit.ly/ng2be-checkpoint3-2)下载`checkpoint3.2`的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'There is one last feature that we plan to add to *7 Minute Workout* before
    wrapping up the application and building something new with Angular: audio support.
    It teaches us some new cross-component communication patterns too.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在用Angular构建新的东西之前，我们计划在*7分钟锻炼*中添加最后一个功能：音频支持。它还教会我们一些新的跨组件通信模式。
- en: Cross-component communication using Angular events
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular事件进行跨组件通信
- en: We touched upon events in the last chapter when learning about Angular's binding
    infrastructure. It's time now to look at eventing in more depth. Let's add audio
    support to *7 Minute Workout*.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到了事件，当学习Angular的绑定基础设施时。现在是时候更深入地了解事件了。让我们为*7分钟锻炼*添加音频支持。
- en: Tracking exercise progress with audio
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用音频跟踪运动进展
- en: For the *7 Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues helps the user perform the
    workout effectively as he/she can just follow the audio instructions.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*7分钟锻炼*应用程序，添加声音支持至关重要。人们无法一直盯着屏幕做运动。音频提示有助于用户有效地进行锻炼，因为他/她可以只需跟随音频指示。
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将如何使用音频提示支持运动跟踪：
- en: A ticking clock sound tracks progress during the exercise
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滴答声跟踪运动进展
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半程指示器发出声音，表明练习已经进行了一半
- en: An exercise-completion audio clip plays when the exercise is about to end
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当练习即将结束时，会播放一个练习完成的音频片段
- en: An audio clip plays during the rest phase and informs users about the next exercise
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在休息阶段播放音频片段，通知用户下一个练习
- en: There will be an audio clip for each of these scenarios.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况都会有一个音频片段。
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into html content. We too will use the `<audio>`
    tag to playback our clips.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器对音频有很好的支持。HTML5的`<audio>`标签提供了一种将音频片段嵌入到html内容中的机制。我们也将使用`<audio>`标签来播放我们的片段。
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计划使用HTML的`<audio>`元素，我们需要创建一个包装指令，允许我们从Angular控制音频元素。请记住，指令是没有视图的HTML扩展。
- en: Note
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Git `checkpoint3.3` folder `trainer/static/audio` contains all the audio
    files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng2be-checkpoint3-3](http://bit.ly/ng2be-checkpoint3-3).
    Download and unzip the content and copy the audio files.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: Git的`checkpoint3.3`文件夹`trainer/static/audio`包含了所有用于播放的音频文件；首先复制它们。如果您不使用Git，可以在[http://bit.ly/ng2be-checkpoint3-3](http://bit.ly/ng2be-checkpoint3-3)下载并解压内容并复制音频文件。
- en: Building Angular directives to wrap HTML audio
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Angular指令来包装HTML音频
- en: You may not have realized so far, but we have purposefully shied away from directly
    accessing the DOM for any of our component implementations. There has not been
    a need to do it. Angular data binding infrastructure, including property, attribute,
    and event binding, has helped us manipulate HTML without touching the DOM.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能还没有意识到，但我们有意避免直接访问DOM以实现任何组件。目前还没有这样的需求。Angular的数据绑定基础设施，包括属性、属性和事件绑定，已经帮助我们在不触及DOM的情况下操作HTML。
- en: For the audio element too, the access pattern should be Angularish. Let's create
    a directive that wraps access to audio elements.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 对于音频元素，访问模式也应该符合Angular的风格。让我们创建一个包装对音频元素访问的指令。
- en: 'Create a folder `workout-audio` inside `workout-runner` and add a new file
    `my-audio.directive.ts` to it. Next add the implementation for the `MyAudioDirective`
    directive outlined here to this file:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`文件夹内创建一个名为`workout-audio`的文件夹，并在其中添加一个名为`my-audio.directive.ts`的新文件。然后将此处概述的`MyAudioDirective`指令的实现添加到该文件中：
- en: '[PRE90]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive`
    decorator is similar to the `@Component` decorator except we cannot have an attached
    view. Therefore, no `template` or `templateUrl` is allowed!
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAudioDirective`类被装饰为`@Directive`。`@Directive`装饰器类似于`@Component`装饰器，只是我们不能有附加的视图。因此，不允许有`template`或`templateUrl`！'
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. Using `audio` as the selector makes our directive load for
    every `<audio>` tag used in html.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`selector`属性允许框架确定应用指令的位置。使用`audio`作为选择器使我们的指令在html中的每个`<audio>`标签中加载。
- en: Note
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a standard scenario, directive selectors are attribute-based, which helps
    us identify where the directive has been applied. We deviate from this norm and
    use an element selector for the `MyAudioDirective` directive.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准情况下，指令选择器是基于属性的，这有助于我们确定指令的应用位置。我们偏离了这个规范，使用了`MyAudioDirective`指令的元素选择器。
- en: We want this directive to be loaded for every audio element, and it becomes
    cumbersome to go to each audio declaration and add a directive-specific attribute.
    Hence an element selector.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望该指令加载到每个音频元素中，而逐个音频声明并添加指令特定属性变得繁琐。因此使用了元素选择器。
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在视图模板中使用该指令时，使用`exportAs`就变得清晰了。
- en: The `ElementRef` object injected in constructor is the Angular element for which
    the directive is loaded. Angular creates the `ElementRef` instance for every component
    and directive when it compiles and executes the html template. When requested
    in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the actual audio element in code
    (the instance of `HTMLAudioElement`). The `audioPlayer` property holds this reference.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中注入的`ElementRef`对象是该指令加载的Angular元素。当Angular编译和执行html模板时，为每个组件和指令创建`ElementRef`实例。在构造函数中请求时，DI框架会定位相应的`ElementRef`并注入它。我们使用`ElementRef`来在代码中获取实际的音频元素（`HTMLAudioElement`的实例）。`audioPlayer`属性保存了这个引用。
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令现在需要公开一个API来操作音频播放器。将这些函数添加到`MyAudioDirective`指令中：
- en: '[PRE91]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAudioDirective` API有两个函数（`start`和`stop`）和三个getter（`currentTime`，`duration`，以及一个名为`playbackComplete`的布尔属性）。这些函数和属性的实现只是包装了音频元素的函数。'
- en: Note
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 从MDN文档中了解这些音频功能：[http://bit.ly/html-media-element](http://bit.ly/html-media-element)。
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们如何使用音频指令，让我们创建一个新的组件来管理音频播放。
- en: Note
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to register the `MyAudioDirective` under `WorkoutRunnerModule` before
    proceeding any further.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记得在`WorkoutRunnerModule`下注册`MyAudioDirective`。
- en: Creating WorkoutAudioComponent for audio support
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为音频支持创建WorkoutAudioComponent
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>`
    tags (two audio tags work together for next-up audio).
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回过头来看一下所需的音频提示，有四个不同的音频提示，因此我们将创建一个带有五个嵌入式`<audio>`标签的组件（两个音频标签一起用于接下来的音频）。
- en: 'Open the `workout-audio` folder and create a file called `workout-audio.html`
    for the component template. Add this HTML snippet:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-audio`文件夹，并为组件模板创建一个名为`workout-audio.html`的文件。添加以下HTML片段：
- en: '[PRE92]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Five `<audio>` tags one for each:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 五个`<audio>`标签，每个标签对应一个：
- en: '**Ticking audio**: This audio produces the ticking sound and is started as
    soon as the workout starts. Referred using the template variable `ticks`.'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滴答声音**：此音频产生滴答声音，并在锻炼开始时立即开始。使用模板变量`ticks`引用。'
- en: '**Next up audio and  exercise audio**: There are two audio tags that work together.
    The first tag with the template variable as nextUp produces the "Next up" sound.
    And the actual exercise audio (`nextUpExercise`).'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接下来的音频和锻炼音频**：有两个一起工作的音频标签。第一个带有模板变量`nextUp`产生“接下来”声音。而实际的锻炼音频（`nextUpExercise`）。'
- en: '**Halfway audio**: The halfway audio plays halfway through the exercise.'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中途音频**：中途音频在锻炼进行到一半时播放。'
- en: '**About to complete audio**: This audio piece is played to denote the completion
    of an exercise (`aboutToComplete`).'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即将完成的音频**：播放此音频片段以表示完成一项锻炼（`aboutToComplete`）。'
- en: Did you notice the usage of the `#` symbol in the view? There are some variable
    assignments prefixed with `#`. In the Angular world, these variables are known
    as template reference variables or at times template variables.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到视图中使用了`#`符号？有一些变量赋值以`#`为前缀。在Angular世界中，这些变量被称为模板引用变量，有时也称为模板变量。
- en: 'The platform developer guide describes them thus:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 平台开发人员指南这样描述它们：
- en: '*A template reference variable is a reference to an DOM element or directive
    within a template.*'
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*模板引用变量是模板内的DOM元素或指令的引用。*'
- en: Note
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Don''t confuse them with the template input variables that we have used with
    the `ngFor` directive earlier: `*ngFor="let video of videos"`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将它们与我们之前在`ngFor`指令中使用的模板输入变量混淆：“*ngFor="let video of videos"`”
- en: Template input variables (`video` in this case) allow us to access the model
    object from the view. The value assigned to `video` depends upon the context of
    the `ngFor` directive loop.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 模板输入变量（在本例中为`video`）允许我们从视图中访问模型对象。分配给`video`的值取决于`ngFor`指令循环的上下文。
- en: 'Look at the last section where we set the `MyAudioDirective` directive''s `exportAs`
    metadata to `MyAudio`. We repeat that same string while assigning the template
    reference variable in the preceding view:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下最后一节，我们在那里将`MyAudioDirective`指令的`exportAs`元数据设置为`MyAudio`。我们在前面的视图中分配模板引用变量时重复了相同的字符串：
- en: '[PRE93]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template variable.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`exportAs`的作用是定义可以在视图中用来将该指令分配给变量的名称。记住，单个元素/组件可以应用多个指令。`exportAs`允许我们选择应该分配给模板变量的指令。'
- en: Template variables, once declared, can be accessed from other parts of the view.
    We will take up this discussion shortly. But in our case, we will use template
    variables to refer to the multiple `MyAudioDirective`s from parent component code.
    Let's understand how that works.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了模板变量，就可以从视图的其他部分访问它们。我们很快就会讨论这个问题。但在我们的情况下，我们将使用模板变量来引用父组件代码中的多个`MyAudioDirective`。让我们了解一下它是如何工作的。
- en: 'Add the `workout-audio.compnent.ts` file to the `workout-audio` folder with
    the following outline:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 将`workout-audio.compnent.ts`文件添加到`workout-audio`文件夹，并按以下大纲进行编写：
- en: '[PRE94]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The interesting bit here is the `@ViewChild` decorator against the five properties.
    The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed is the template variable name,
    which helps DI match the element/directive to inject. When Angular instantiates
    the `WorkoutAudioComponent`, it injects the corresponding audio component based
    on the `@ViewChild` decorator. Let's complete the basic class implementation before
    we look at `@ViewChild` in detail.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的地方是对五个属性使用的`@ViewChild`装饰器。`@ViewChild`装饰器允许我们将子组件/指令/元素引用注入到其父组件中。传递的参数是模板变量名称，它帮助DI匹配要注入的元素/指令。当Angular实例化`WorkoutAudioComponent`时，它会根据`@ViewChild`装饰器注入相应的音频组件。在我们详细了解`@ViewChild`之前，让我们完成基本的类实现。
- en: Note
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild`
    injection injects the related `ElementRef` instance instead of the `MyAudioDirective`
    instance.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyAudioDirective`指令上没有设置`exportAs`时，`@ViewChild`注入会注入相关的`ElementRef`实例，而不是`MyAudioDirective`实例。
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的任务就是在正确的时间播放正确的音频组件。将这些函数添加到`WorkoutAudioComponent`中：
- en: '[PRE95]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Having trouble writing these functions? They are available in Git branch `checkpoint3.3`.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这些函数时遇到了困难吗？它们可以在Git分支`checkpoint3.3`中找到。
- en: Next, go ahead and add `WorkoutAudioComponent` to the `declarations` array of
    `WorkoutRunnerModule`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，继续将`WorkoutAudioComponent`添加到`WorkoutRunnerModule`的`declarations`数组中。
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts,` as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中使用了两个新的模型类。将它们的声明添加到`model.ts`中，如下所示：
- en: '[PRE96]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: These are model classes to track progress events. The `WorkoutAudioComponent`
    implementation consumes this data. How the data is produced becomes clear as we
    move along.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于跟踪进度事件的模型类。`WorkoutAudioComponent`的实现会使用这些数据。随着我们的进展，数据是如何产生的就会变得清晰起来。
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, when about to complete,
    or half-way audio playback. We just want to continue from where we left off.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`resume`函数在开始、暂停或完成训练时停止和恢复音频。在`resume`函数中的额外复杂性是为了处理当训练在下一个动作时被暂停，当即将完成时被暂停，或者在播放音频时半途而废的情况。我们只想从上次离开的地方继续。'
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`onExerciseProgress` 函数应该被调用以报告锻炼进度。它用于根据锻炼的状态播放中途音频和即将完成的音频。传递给它的参数是一个包含锻炼进度数据的对象。'
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line, and helps
    `WorkoutAudioComponent` to decide when to play the next-up exercise audio.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 当锻炼改变时，应该调用 `onExerciseChanged` 函数。输入参数包含当前和下一个锻炼，帮助 `WorkoutAudioComponent`
    决定何时播放下一个锻炼的音频。
- en: Make note that these two functions are called by the consumer of the component
    (in this case, `WorkoutRunnerComponent`). We don't invoke them internally.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个函数是由组件的消费者（在本例中是 `WorkoutRunnerComponent`）调用的。我们不在内部调用它们。
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涉及了两个新概念：模板引用变量和将子元素/指令注入到父元素中。在继续实现之前，值得更详细地探讨这两个概念。我们将首先学习更多关于模板引用变量的知识。
- en: Understanding template reference variables
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解模板引用变量
- en: Template reference variables are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用变量是在视图模板上创建的，并且大多数情况下是从视图中使用的。正如您已经学到的，这些变量可以通过使用 `#` 前缀来声明来识别。
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量的最大好处之一是它们在视图模板级别促进了跨组件通信。一旦声明，这些变量可以被同级元素/组件及其子元素引用。查看以下片段：
- en: '[PRE97]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This snippet declares a template variable, `emailId`, and then references it
    in the interpolation and the button `click` expression.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段声明了一个模板变量 `emailId`，然后在插值和按钮的 `click` 表达式中引用它。
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模板引擎将 `input` 的 DOM 对象（`HTMLInputElement` 的一个实例）分配给 `emailId` 变量。由于该变量在同级元素中可用，我们在按钮的
    `click` 表达式中使用它。
- en: 'Template variables work with components too. We can easily do this:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量也适用于组件。我们可以轻松地这样做：
- en: '[PRE98]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this case, `runner` has a reference to `WorkoutRunnerComponent` object, and
    the button is used to start the workout.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`runner` 引用了 `WorkoutRunnerComponent` 对象，并且按钮用于开始锻炼。
- en: Note
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref-` 前缀是 `#` 的规范替代。`#runner` 变量也可以声明为 `ref-runner`。'
- en: Template variable assignment
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板变量赋值
- en: 'There is something interesting about the template variable assignments that
    we have seen thus far. To recap the examples that we have used:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见到的模板变量赋值有一些有趣的地方。回顾我们使用的例子：
- en: '[PRE99]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'What got assigned to the variable depended on where the variable was declared.
    This is governed by rules in Angular as described here:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 变量分配的内容取决于变量声明的位置。这由 Angular 中的规则所控制，如下所述：
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective`
    directive sets the `ticks` variable to an instance of `MyAudioDirective`.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指令存在于元素上，例如在前面显示的第一个示例中的`MyAudioDirective`，则该指令设置该值。`MyAudioDirective`指令将`ticks`变量设置为`MyAudioDirective`的实例。
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `email` and `workout-runner`
    example).
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指令存在，要么分配底层HTML DOM元素，要么分配组件对象（如`email`和`workout-runner`示例中所示）。
- en: We will be employing this technique to implement workout audio component integration
    with the workout runner component. This introduction gives us the head start that
    we need.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用这种技术来实现训练音频组件与训练运行器组件的集成。这个介绍给了我们所需要的先发优势。
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承诺要涵盖的另一个新概念是使用`ViewChild`和`ViewChildren`装饰器进行子元素/指令注入。
- en: Using the @ViewChild decorator
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`@ViewChild`装饰器
- en: The `@ViewChild` decorator informs the Angular DI framework to search for the
    child component/directive/element in the component tree and inject them into the
    parent. In the preceding code, the audio element directive (the `MyAudioDirective`
    class) is injected into the `WorkoutAudioComponent` code.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChild`装饰器通知Angular DI框架在组件树中搜索子组件/指令/元素并将它们注入到父组件中。在上面的代码中，音频元素指令（`MyAudioDirective`类）被注入到`WorkoutAudioComponent`代码中。'
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立上下文，让我们重新检查`WorkoutAudioComponent`中的一个视图片段：
- en: '[PRE100]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent`
    property `ticks`. The mapping is done based on the selector passed to the `@ViewChild`
    decorator.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将指令（`MyAudioDirective`）注入到`WorkoutAudioComponent`属性`ticks`中。映射是基于传递给`@ViewChild`装饰器的选择器进行的。
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewChild`上的选择器参数可以是字符串值，在这种情况下，Angular会搜索匹配的模板变量，就像以前一样。'
- en: 'Or it can be a type. This is valid:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可以是一个类型。这是有效的：
- en: '[PRE101]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: However, it does not work in our case. There are multiple `MyAudioDirective`
    directives loaded in the `WorkoutAudioComponent` view, one for each of the `<audio>`
    tags. In such a scenario, the first match is injected. Not very useful. Passing
    the type selector would have worked if there was only one `<audio>` tag in the
    view.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们的情况下，这并不起作用。在`WorkoutAudioComponent`视图中加载了多个`MyAudioDirective`指令，每个`<audio>`标签对应一个。在这种情况下，只会注入第一个匹配项。并不是很有用。如果视图中只有一个`<audio>`标签，传递类型选择器将起作用。
- en: Tip
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit`
    event hook on the component is called. This implies such properties are `null`
    if accessed inside the constructor.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@ViewChild`装饰的属性在调用组件的`ngAfterViewInit`事件钩子之前一定会被设置。这意味着如果在构造函数内部访问这些属性，它们将为`null`。
- en: Like `@ViewChild`, Angular has a decorator to locate multiple child components/directives: `@ViewChildren`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 与`@ViewChild`类似，Angular有一个装饰器来定位多个子组件/指令：`@ViewChildren`。
- en: The @ViewChildren decorator
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@ViewChildren`装饰器'
- en: '`@ViewChildren` works similarly to `@ViewChild` except it''s used when the
    view has multiple child components/directives of one type. Using `@ViewChildren`
    we can get all the `MyAudioDirective` directive instances in `WorkoutAudioComponent`
    , as shown here:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChildren`的工作方式与`@ViewChild`类似，只是当视图具有多个相同类型的子组件/指令时使用。使用`@ViewChildren`，我们可以获取`WorkoutAudioComponent`中所有`MyAudioDirective`指令的实例，如下所示：'
- en: '[PRE102]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Look carefully; `allAudios` is not an array but a custom object, `QueryList<Type>`.
    `QueryList` is an immutable collection of components/directives that Angular was
    able to locate. The best thing about this list is that Angular will keep this
    list in sync with the state of the view. When directives/components get added/removed
    from the view dynamically this list is updated too. Components/directives generated
    using `ng-for` are a prime example of this dynamic behavior. Consider the preceding
    `@ViewChildren` usage and this view template:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看，“allAudios”不是一个数组，而是一个自定义对象，“QueryList<Type>”。 “QueryList”是Angular能够定位的组件/指令的不可变集合。这个列表最好的地方是，Angular将保持此列表与视图状态同步。当动态地从视图中添加/删除指令/组件时，此列表也会更新。使用“ng-for”生成的组件/指令是这种动态行为的一个主要例子。考虑前面的“@ViewChildren”用法和这个视图模板：
- en: '[PRE103]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into `allAudio` property and keeps it in
    sync when items are added or removed from the `clips` array.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 由Angular创建的“MyAudioDirective”指令的数量取决于“clips”的数量。当使用“@ViewChildren”时，Angular会将正确数量的“MyAudioDirective”实例注入到“allAudio”属性中，并在从“clips”数组中添加或删除项目时保持同步。
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective`
    directives, it cannot be used to control the playback. You see, we need to get
    hold of individual `MyAudioDirective` instances as the audio playback timing varies.
    Hence we will stick to the `@ViewChild` implementation.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用“@ViewChildren”允许我们获得所有“MyAudioDirective”指令，但它不能用于控制播放。你看，我们需要获得单独的“MyAudioDirective”实例，因为音频播放的时间不同。因此，我们将坚持使用“@ViewChild”实现。
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了附加到每个音频元素的“MyAudioDirective”指令，只需在正确的时间播放音频轨道。
- en: Integrating WorkoutAudioComponent
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成WorkoutAudioComponent
- en: While we have componentized audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to `WorkoutRunnerComponent` implementation.
    `WorkoutAudioComponent` derives its operational intelligence from `WorkoutRunnerComponent`.
    Hence the two components need to interact. `WorkoutRunnerComponent` needs to provide
    the `WorkoutAudioComponent` state change data, including when the workout started,
    exercise progress, workout stopped, paused, and resumed.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经将音频播放功能组件化为“WorkoutAudioComponent”，但它始终与“WorkoutRunnerComponent”实现紧密耦合。“WorkoutAudioComponent”从“WorkoutRunnerComponent”获取其操作智能。因此，这两个组件需要互动。“WorkoutRunnerComponent”需要提供“WorkoutAudioComponent”的状态更改数据，包括训练开始时，练习进度，训练停止，暂停和恢复。
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent`
    API (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此集成的一种方法是使用当前公开的“WorkoutAudioComponent”API（停止，恢复和其他功能）从“WorkoutRunnerComponent”中。
- en: 'Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
    Check out this code:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将“WorkoutAudioComponent”注入到“WorkoutRunnerComponent”中来完成一些工作，就像我们之前将“MyAudioDirective”注入到“WorkoutAudioComponent”中一样。看看这段代码：
- en: '[PRE104]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `WorkoutAudioComponent` functions then can be invoked from `WorkoutRunnerComponent`
    from different places in the code. For example, this is how `pause` would change:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，“WorkoutAudioComponent”函数可以从代码中的不同位置调用“WorkoutRunnerComponent”。例如，这就是“pause”会如何改变的方式：
- en: '[PRE105]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'And to play the next up audio, we would need to change parts of the `startExerciseTimeTracking`
    function:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放接下来的音频，我们需要更改“startExerciseTimeTracking”函数的部分内容：
- en: '[PRE106]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent`
    now needs to manage audio playback too.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全可行的选择，其中`WorkoutAudioComponent`成为由`WorkoutRunnerComponent`控制的哑组件。这种解决方案的唯一问题是，它给`WorkoutRunnerComponent`的实现增加了一些噪音。`WorkoutRunnerComponent`现在还需要管理音频播放。
- en: There is an alternative, however. `WorkoutRunnerComponent` can expose events
    that are triggered during different times of workout execution, that is, events
    such as workout started, exercise started, and workout paused, and so on and so
    forth. Another advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components with `WorkoutRunnerComponent` in future,
    using the same events.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种选择。`WorkoutRunnerComponent`可以在锻炼执行的不同时间触发事件，比如锻炼开始、练习开始、锻炼暂停等等。`WorkoutRunnerComponent`暴露事件的另一个优势是，它允许我们在未来将其他组件与`WorkoutRunnerComponent`集成，使用相同的事件。
- en: Exposing WorkoutRunnerComponent events
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴露WorkoutRunnerComponent事件
- en: 'Angular allows components and directives to expose custom events using the
    `EventEmitter` class. Add these event declarations to `WorkoutRunnerComponent`
    at the end of the variable declaration section:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: Angular允许组件和指令使用`EventEmitter`类来暴露自定义事件。在变量声明部分的末尾，将这些事件声明添加到`WorkoutRunnerComponent`中：
- en: '[PRE107]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent`
    implementation we need to raise these at the appropriate times.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的名称不言自明，在我们的`WorkoutRunnerComponent`实现中，我们需要在适当的时机触发这些事件。
- en: Remember to add `ExerciseProgressEvent` and import to the model module that
    is already declared on top. And add the `Output` and `EventEmitter` imports to
    `@angular/core`.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将`ExerciseProgressEvent`添加到模型模块中，并在顶部已经声明的模块中导入。并且将`Output`和`EventEmitter`导入到`@angular/core`中。
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter`
    class.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解`@Output`装饰器和`EventEmitter`类的作用。
- en: The @Output decorator
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Output装饰器'
- en: We covered a decent amount of Angular eventing capabilities in [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "Chapter 2.  Building Our First App - 7 Minute Workout"), Building Our First App
    - 7 Minute Workout. Specifically, we learned how we can consume any event on a
    component, directive, or DOM element using the `bracketed ()` syntax. How about
    raising our own events?
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "第2章。构建我们的第一个应用程序-7分钟锻炼")中，我们涵盖了相当多的Angular事件能力。具体来说，我们学会了如何使用`bracketed
    ()`语法在组件、指令或DOM元素上消耗任何事件。那么如何触发我们自己的事件呢？
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class we can define and raise custom events.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们可以创建和触发自己的事件，这些事件表示组件/指令中发生了值得注意的事情。使用`@Output`装饰器和`EventEmitter`类，我们可以定义和触发自定义事件。
- en: Now would be a good time to refresh what we learned about events, by revisiting
    the *Eventing subsection* in the *Angular Event binding infrastructure* section
    from [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2. 
    Building Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute
    Workout*.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个很好的时机，通过重新访问[第2章](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "第2章。构建我们的第一个应用程序-7分钟锻炼")中的*Angular事件绑定基础设施*部分的*Eventing子部分*来复习一下我们学到的关于事件的知识。
- en: 'Remember, it is through events that components can communicate with the outside
    world. When we declare:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，正是通过事件，组件才能与外部世界进行通信。当我们声明：
- en: '[PRE108]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: It signifies that `WorkoutRunnerComponent` exposes an event `exercisePaused`
    (raised when the workout is paused).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示 `WorkoutRunnerComponent` 公开了一个名为 `exercisePaused` 的事件（在锻炼暂停时触发）。
- en: 'To subscribe to this event, we do:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 要订阅此事件，我们这样做：
- en: '[PRE109]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This looks absolutely similar to how we did DOM event subscription in the workout
    runner template:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们在锻炼运行器模板中订阅 DOM 事件的方式非常相似：
- en: '[PRE110]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. You can create an event without the `@Output` decorator, but such an
    event cannot be referenced in html.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Output` 装饰器指示 Angular 使此事件可用于模板绑定。你可以创建一个没有 `@Output` 装饰器的事件，但这样的事件不能在 html
    中引用。'
- en: Note
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `@Output` decorated can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> = new EventEmitter<number>();`'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Output` 装饰器也可以带一个参数，表示事件的名称。如果没有提供，装饰器将使用属性名称：`@Output("workoutPaused") exercisePaused:
    EventEmitter<number> = new EventEmitter<number>();`'
- en: This declares an event `workoutPaused` instead of `exercisePaused`.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个名为 `workoutPaused` 的事件，而不是 `exercisePaused`。
- en: Like any decorator, the `@Output` decorator too is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the
    `EventEmitter` class.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何装饰器一样，`@Output` 装饰器也只是为了提供元数据，以便 Angular 框架使用。真正的重活是由 `EventEmitter` 类完成的。
- en: Eventing with EventEmitter
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 EventEmitter 进行事件处理
- en: Angular embraces Reactive Programming (also dubbed as **Rx**-style programming)
    to support asynchronous operations and events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: Angular采用响应式编程（也称为**Rx**风格编程）来支持异步操作和事件。如果你第一次听到这个术语，或者对响应式编程不太了解，你并不孤单。
- en: Reactive programming is all about programming against asynchronous data streams.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程就是针对异步数据流进行编程。这样的流就是基于它们发生的时间顺序排列的一系列持续事件。我们可以把流想象成一个生成数据（以某种方式）并将其推送给一个或多个订阅者的管道。由于这些事件被订阅者异步捕获，它们被称为异步数据流。
- en: The data can be anything, ranging from browser/DOM element events, to user input
    to loading remote data loaded using AJAX. With *Rx* style, we consume this data
    uniformly.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是任何东西，从浏览器/DOM 元素事件，到用户输入，再到使用 AJAX 加载的远程数据。使用 *Rx* 风格，我们统一消耗这些数据。
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular Observer design pattern. Observables are streams that emit data.
    Observers on the other hand subscribe to these events.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rx 世界中，有观察者和可观察对象，这是从非常流行的观察者设计模式派生出来的概念。可观察对象是发出数据的流。观察者则订阅这些事件。
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an observer and observable. We can fire events on it
    and it can be used to listen to events too.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中的 `EventEmitter` 类主要负责提供事件支持。它既充当观察者又充当可观察对象。我们可以在其上触发事件，也可以用它来监听事件。
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 上有两个函数对我们很有兴趣：'
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` is the observable side.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emit`：顾名思义，使用这个函数来触发事件。它接受一个事件数据作为参数。`emit` 是可观察的一面。'
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`.
    `subscribe` is the observer side.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`：使用这个函数来订阅`EventEmitter`引发的事件。`subscribe`是观察者端。'
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一些事件发布和订阅，以了解前面的函数是如何工作的。
- en: Raising events from WorkoutRunnerComponent
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从WorkoutRunnerComponent中引发事件
- en: Look at the `EventEmitter` declaration. These have been declared with the `type`
    parameter. The `type` parameter signifies the type of data emitted.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`EventEmitter`的声明。这些已经声明了`type`参数。`type`参数表示发出的数据类型。
- en: Let's add the event implementation to `workout-runner.component.ts` in chronological
    order starting from the top and moving down.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照时间顺序从顶部开始，逐步向下在`workout-runner.component.ts`中添加事件实现。
- en: 'Add this statement to the end of the `start` function:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start`函数的末尾添加这个语句：
- en: '[PRE111]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We use the `EventEmitter`'s `emit`function to raise an event `workoutStarted`,
    with the current workout plan as an argument.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EventEmitter`的`emit`函数来引发一个名为`workoutStarted`的事件，并将当前的训练计划作为参数。
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`pause`，添加以下行来引发`exercisePaused`事件：
- en: '[PRE112]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To `resume`, add the following line:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`resume`，添加以下行：
- en: '[PRE113]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising `exercisePaused` and `exerciseResumed` events.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在引发`exercisePaused`和`exerciseResumed`事件时，我们都将当前的练习索引作为参数传递给`emit`。
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startExerciseTimeTracking`函数内，在调用`startExercise`后添加高亮显示的代码：
- en: '[PRE114]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数包含即将开始的练习（`next`）和队列中的下一个练习（`this.getNextExercise()`）。
- en: 'To the same function, add the highlighted code:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，添加高亮显示的代码：
- en: '[PRE115]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The event is raised when the workout is completed.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 当训练完成时引发事件。
- en: 'Lastly in the same function, we raise an event that communicates workout progress.
    Add this statement:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 最后在同一个函数中，我们引发一个表达训练进度的事件。添加这个语句：
- en: '[PRE116]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: That completes our eventing implementation.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的事件实现。
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，`WorkoutAudioComponent`现在需要消费这些事件。这里的挑战是如何组织这些组件，以便它们可以以最小的相互依赖来进行通信。
- en: Component communication patterns
  id: totrans-755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件通信模式
- en: As the implementation stands now, we have a basic `WorkoutAudioComponent` implementation
    and have augmented `WorkoutRunnerComponent` by exposing workout lifecycle events.
    These two just need to talk to each other now.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前的实现而言，我们有一个基本的`WorkoutAudioComponent`实现，并通过暴露训练生命周期事件来增强了`WorkoutRunnerComponent`。现在这两者只需要相互交流。
- en: The first obvious option that comes to mind is to add the `WorkoutAudioComponent`
    declaration to the `WorkoutRunnerComponent` view. `WorkoutAudioComponent` hence
    becomes a child component of `WorkoutRunnerComponent`. However, in such a setup,
    communication between them becomes a bit clunky. Remember, events are a mechanism
    for a component to communicate with the outside world.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 首先显而易见的选择是将`WorkoutAudioComponent`声明添加到`WorkoutRunnerComponent`视图中。因此，`WorkoutAudioComponent`成为`WorkoutRunnerComponent`的子组件。然而，在这样的设置中，它们之间的通信变得有点笨拙。记住，事件是组件与外部世界通信的机制。
- en: 'If the parent needs to communicate with its children, it can do this by:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父组件需要与其子组件通信，可以通过以下方式实现：
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example:'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性绑定**：父组件可以在子组件上设置属性绑定，将数据推送到子组件。例如：'
- en: '[PRE117]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Property binding in this case works fine. When the workout is paused, the audio
    too is stopped. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，属性绑定效果很好。当锻炼暂停时，音频也会停止。但并非所有情况都可以使用属性绑定来处理。播放下一个练习音频或中途音频需要更多的控制。
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren`
    decorators in the `WorkoutAudioComponent` implementation.'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在子组件上调用函数**：如果父组件可以获取子组件，那么父组件也可以在子组件上调用函数。我们已经看到了如何在`WorkoutAudioComponent`的实现中使用`@ViewChild`和`@ViewChildren`装饰器来实现这一点。'
- en: There is one more not-so-good option where the parent component instance can
    be injected into the child component. In such a case, the child component can
    call parent component functions or set up internal event handlers to parent events.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个不太好的选择，即父组件实例可以被注入到子组件中。在这种情况下，子组件可以调用父组件函数或设置内部事件处理程序以处理父事件。
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试这种方法，然后放弃实现一个更好的方法！我们计划实现的不太理想的解决方案可以带来很多学习。
- en: Injecting a parent component into a child component
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将父组件注入到子组件中
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before
    the last closing div:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个闭合div之前将`WorkoutAudioComponent`添加到`WorkoutRunnerComponent`视图中：
- en: '[PRE118]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Next we need to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要将`WorkoutRunnerComponent`注入到`WorkoutAudioComponent`中。
- en: 'Open `workout-audio.component.ts` and add the following declaration and a constructor:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-audio.component.ts`并添加以下声明和构造函数：
- en: '[PRE119]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'And remember to add these imports:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 记得添加这些导入：
- en: '[PRE120]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We have used some trickery in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent` it fails with
    Angular complaining of not being able to find all dependency. Read the code and
    think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent`
    already is dependent on `WorkoutAudioComponent` as we have referenced `WorkoutAudioComponent`
    in the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent`
    in `WorkoutAudioComponent`, we have created a dependency cycle.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造注入中使用了一些技巧。如果我们直接尝试将`WorkoutRunnerComponent`注入到`WorkoutAudioComponent`中，Angular会抱怨无法找到所有依赖项。仔细阅读代码并深思熟虑；这里隐藏着一个微妙的依赖循环问题。`WorkoutRunnerComponent`已经依赖于`WorkoutAudioComponent`，因为我们在`WorkoutRunnerComponent`视图中引用了`WorkoutAudioComponent`。现在通过在`WorkoutAudioComponent`中注入`WorkoutRunnerComponent`，我们创建了一个依赖循环。
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject`
    decorator and passing in the token created using the `forwardRef()` global framework
    function.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖对于任何DI框架来说都是具有挑战性的。在创建具有循环依赖的组件时，框架必须以某种方式解决这个循环。在前面的例子中，我们通过使用`@Inject`装饰器并传入使用`forwardRef()`全局框架函数创建的标记来解决循环依赖问题。
- en: Inside the constructor, we attach a handler to the events, using the `EventEmitter`
    subscribe function. The arrow function passed to `subscribe` is called whenever
    the event occurs with a specific event argument. We collect all the subscriptions
    into an array `subscription`. This array comes in handy when we unsubscribe, which
    we need to, to avoid memory leaks.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用“EventEmitter”订阅函数将处理程序附加到事件上。传递给“subscribe”的箭头函数在特定事件发生时被调用。我们将所有订阅收集到一个数组“subscription”中。当我们需要取消订阅时，这个数组非常有用，以避免内存泄漏。
- en: 'The `EventEmmiter`''s subscription (`subscribe` function) takes three arguments:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: “EventEmmiter”的订阅（“subscribe”函数）有三个参数：
- en: '[PRE121]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The first argument is a callback, which is invoked whenever an event is emitted
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个回调函数，每当事件被触发时调用
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个错误回调函数，当可观察对象（生成事件的部分）出现错误时调用
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的参数是一个回调函数，当可观察对象完成发布事件时调用
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all other audio clips play at the right
    time. You may have to wait for some time to hear to the other audio clips. What
    is the problem?
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了足够的工作来使音频集成工作。运行应用程序并开始锻炼。除了滴答声音之外，所有其他音频片段都会在正确的时间播放。您可能需要等一段时间才能听到其他音频片段。问题是什么？
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks`
    audio element or using the `component lifecycle events` to trigger the ticking
    sound. Let's take the second approach.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们从未在锻炼开始时播放滴答声音。我们可以通过在“ticks”音频元素上设置“autoplay”属性或使用“组件生命周期事件”来触发滴答声音来修复它。让我们采取第二种方法。
- en: Using component lifecycle events
  id: totrans-783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用组件生命周期事件
- en: 'We performed the `MyAudioDirective` injection in `WorkoutAudioComponent`:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“WorkoutAudioComponent”中进行了“MyAudioDirective”的注入：
- en: '[PRE122]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This will not be available unit the component''s view has been initialized:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的视图被初始化之前，这将不可用：
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    `WorkoutAudioComponent`'s children to be initialized.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在构造函数中访问“ticks”变量来验证它；它将为null。Angular仍然没有发挥其魔力，我们需要等待“WorkoutAudioComponent”的子级初始化。
- en: The component's lifecycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的生命周期钩子可以帮助我们。一旦组件的视图被初始化，就会调用“AfterViewInit”事件钩子，因此从中访问组件的子指令/元素是一个安全的地方。让我们快速做一下。
- en: 'Update the `WorkoutAudioComponent` by adding the interface implementation,
    and the necessary imports, as highlighted:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加接口实现和必要的导入来更新“WorkoutAudioComponent”，如下所示：
- en: '[PRE123]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 继续测试应用程序。应用程序已经具备了完整的音频反馈。不错！
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If in the middle of the workout we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表面上一切看起来都很好，但现在应用程序中存在内存泄漏。如果在锻炼过程中我们从锻炼页面导航到开始或结束页面，然后再返回到锻炼页面，多个音频片段会在随机时间播放。
- en: It seems that the `WorkoutRunnerComponent` is not getting destroyed on route
    navigation, and due to this, none of the child components are destroyed, including
    `WorkoutAudioComponent`. The net result? A new `WorkoutRunnerComponent` is being
    created every time we navigate to the workout page, but is never removed from
    the memory on navigating away.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎`WorkoutRunnerComponent`在路由导航时没有被销毁，因此，包括`WorkoutAudioComponent`在内的子组件都没有被销毁。结果是什么？每次我们导航到锻炼页面时都会创建一个新的`WorkoutRunnerComponent`，但在导航离开时却从内存中永远不会被移除。
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will not
    be dereferenced.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内存泄漏的主要原因是我们在`WorkoutAudioComponent`中添加的事件处理程序。当音频组件卸载时，我们需要取消订阅这些事件，否则`WorkoutRunnerComponent`的引用将不会被解除引用。
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` ! Add
    this implementation to the `WorkoutAudioComponent` class:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组件生命周期事件在这里拯救我们：`OnDestroy`！将这个实现添加到`WorkoutAudioComponent`类中：
- en: '[PRE124]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Also remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得像我们为`AfterViewInit`那样为`OnDestroy`事件接口添加引用吗？
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们在事件订阅期间创建的`subscription`数组现在有意义了。一次性取消订阅！
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这个音频集成现在完成了。虽然这种方法并不是集成这两个组件的一个非常糟糕的方式，但我们可以做得更好。子组件引用父组件似乎是不可取的。
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` are organized as
    sibling components?
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WorkoutRunnerComponent`和`WorkoutAudioComponent`组织为兄弟组件呢？
- en: Note
  id: totrans-801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts`
    from the *Injecting a Parent Component into a Child Component* section onwards.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，删除我们从*将父组件注入到子组件*部分开始添加到`workout-audio.component.ts`的代码。
- en: Sibling component interaction using events and template variables
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件和模板变量进行兄弟组件交互
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular eventing and template reference variables. Confused?
    Well, to start with, this is how the components should be laid out:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WorkoutAudioComponent`和`WorkoutRunnerComponent`变成兄弟组件，我们可以充分利用Angular的事件和模板引用变量。感到困惑？好吧，首先，组件应该布局如下：
- en: '[PRE125]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Does it ring any bells? Starting from this template, can you guess how the final
    template HTML would look? Think about it before you proceed further.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有什么灵感？从这个模板开始，你能猜到最终的模板HTML会是什么样子吗？在继续之前先想一想。
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 还在挣扎吗？一旦我们将它们变成兄弟组件，Angular模板引擎的威力就显现出来了。以下模板代码足以集成`WorkoutRunnerComponent`和`WorkoutAudioComponent`：
- en: '[PRE126]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `WorkoutAudioComponent`''s template variable `wa` is being manipulated
    on `WorkoutRunnerComponent''s` template. Quite elegant! We still need to solve
    the biggest puzzle in this approach: Where does the preceding code go? Remember,
    `WorkoutRunnerComponent` is loaded as part of route loading. Nowhere in the code
    have we had a statement like:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutAudioComponent`的模板变量`wa`在`WorkoutRunnerComponent`的模板上被操作。相当优雅！在这种方法中，我们仍然需要解决最大的难题：前面的代码应该放在哪里？记住，`WorkoutRunnerComponent`是作为路由加载的一部分加载的。在代码中我们从来没有像这样的语句：'
- en: '[PRE127]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We need to re-organize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新组织组件树，并引入一个容器组件，可以承载`WorkoutRunnerComponent`和`WorkoutAudioComponent`。然后路由器加载此容器组件，而不是`WorkoutRunnerComponent`。让我们开始吧。
- en: Create a folder called `workout-container` inside the `workout-runner` folder
    and add two new files, `workout-container.component.ts` and `workout-container.html`.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`文件夹内创建一个名为`workout-container`的文件夹，并添加两个新文件，`workout-container.component.ts`和`workout-container.html`。
- en: 'Copy the HTML code with the events described before to the template file, and
    add the following declaration to `workout-container.component.ts`:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 将带有前面描述的事件的HTML代码复制到模板文件中，并在`workout-container.component.ts`中添加以下声明：
- en: '[PRE128]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The workout container component is ready. Add it to the `declarations` section
    in `workout-runner.module.ts` and export it instead of `WorkoutRunnerComponent`.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼容器组件已准备就绪。将其添加到`workout-runner.module.ts`中的`declarations`部分，并导出它，而不是`WorkoutRunnerComponent`。
- en: 'Next, we just need to rewire the routing setup. Open `app.routes.ts`. Change
    the route for the workout page and add the necessary import:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要重新设置路由。打开`app.routes.ts`。更改锻炼页面的路由并添加必要的导入：
- en: '[PRE129]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eyes too!
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个清晰、简洁且令人愉悦的工作音频集成！
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候结束本章了，但在解决早期部分引入的视频播放器对话框故障之前还不要结束。当视频播放器对话框打开时，锻炼不会停止/暂停。
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.3` code.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在这里详细说明修复方法，并敦促读者在不查看`checkpoint3.3`代码的情况下尝试一下。
- en: Here is an obvious hint. Use the eventing infrastructure!
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个明显的提示。使用事件基础设施！
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个：从`VideoPlayerComponent`中触发事件，每个事件对应播放开始和结束。
- en: 'And the last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的提示：对话框服务（`Modal`）上的`open`函数返回一个promise，在对话框关闭时解析。
- en: Note
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are having a problem with running the code, look at git branch `checkpoint3.3`
    for a working version of what we have done thus far.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看git分支`checkpoint3.3`，以获取到目前为止我们所做的工作的可用版本。
- en: Or if you are not using git, download the snapshot of `checkpoint3.2` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-3](http://bit.ly/ng2be-checkpoint3-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您不使用git，请从[http://bit.ly/ng2be-checkpoint3-3](http://bit.ly/ng2be-checkpoint3-3)下载`checkpoint3.2`的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Summary
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Bit by bit, piece by piece, we have added a number of enhancements to the *7
    Minute Workout* that are imperative for any professional app. There is still scope
    for new features and improvements, but the core app works just fine.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 一点一点地，我们为*7分钟锻炼*添加了许多增强功能，这对于任何专业应用程序都是必不可少的。仍然有新功能和改进的空间，但核心应用程序运行良好。
- en: We started the chapter by exploring the Single Page Application (SPA) capabilities
    of Angular. Here we learned about basic Angular routing, setting up routes, using
    route configuration, generating links using the `RouterLink` directive, and using
    the Angular `Router` and `Location` services to perform navigation.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始本章时探讨了Angular的单页面应用（SPA）功能。在这里，我们学习了基本的Angular路由，设置路由，使用路由配置，使用`RouterLink`指令生成链接，以及使用Angular的`Router`和`Location`服务进行导航。
- en: From the app perspective, we added start, finish, and workout pages to *7 Minute
    Workout*.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序的角度来看，我们为*7分钟锻炼*添加了开始、完成和锻炼页面。
- en: We then built a workout history tracker service that was used to track historical
    workout executions. During this process, we learned about Angular **Dependency
    Injection (DI)** in depth. How a dependency is registered, what a dependency token
    is, and how dependencies are singleton in nature are what we learned in this section.
    We also learned about injectors and how hierarchical injectors affect dependency
    probing.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了一个锻炼历史跟踪器服务，用于跟踪历史锻炼执行情况。在这个过程中，我们深入学习了Angular的**依赖注入（DI）**。我们学习了依赖项的注册方式，依赖项令牌是什么，以及依赖项是单例的特性。
- en: 'Lastly, we touched upon an important topic: cross component communication,
    primarily using Angular Eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提到了一个重要的主题：跨组件通信，主要使用Angular事件。我们详细介绍了如何使用`@Output`装饰器和`EventEmitter`创建自定义事件。
- en: The `@ViewChild` and `@ViewChildren` decorator that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChild`和`@ViewChildren`装饰器在本章中帮助我们理解了父组件如何获取子组件以供使用。Angular DI也允许将父组件注入到子组件中。'
- en: We concluded the chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling component communication can happen using Angular events and template
    variables.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建一个`WorkoutAudioComponent`来结束了本章，并突出了如何使用Angular事件和模板变量进行兄弟组件通信。
- en: What next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7 Minute Workout* app into a generic *Workout Runner*
    app that can run workouts that we build using *Personal Trainer*.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来呢？我们将构建一个新的应用程序，*个人教练*。这个应用程序将允许我们构建自己的定制锻炼。一旦我们能够创建自己的锻炼，我们将把*7分钟锻炼*应用程序改造成一个通用的*锻炼运行器*应用程序，可以运行我们使用*个人教练*构建的锻炼。
- en: For the next chapter, we showcase AngularJS form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示AngularJS表单的功能，同时构建一个允许我们创建、更新和查看自定义锻炼/练习的UI。
