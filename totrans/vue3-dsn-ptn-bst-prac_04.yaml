- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User Interface Composition with Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a closer look at how to compose user interfaces
    with components. While we could just create our entire web page with just one
    component, as we did with our initial *To-Do list* application in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079),
    *Setting Up a Working Project*, this approach is not a good practice save for
    simple applications, partial migrations of functionality in existing web applications,
    or some edge cases when there could be no other option. Components are central
    to Vue’s approach to building interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to compose user interfaces with a hierarchy of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn different ways in which components interact and communicate with each
    other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look into special and custom components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an example plugin applying design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-write our to-do application using our plugin and component composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will introduce core and advanced concepts and give you the tools
    for building solid web applications with reusable components. In particular, we
    will apply our knowledge of design patterns from [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040),
    *Software Design Principles and Patterns*, in the implementation of the code.
  prefs: []
  type: TYPE_NORMAL
- en: A note about styles
  prefs: []
  type: TYPE_NORMAL
- en: To avoid lengthy code listings, we will omit sample icons and styles in the
    code sample. The complete code, along with the styles and iconography, can be
    found in this book’s GitHub repository at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements to follow this chapter are the same as previously mentioned
    in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting Up a* *Working Project*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://packt.link/eqm4l](https://packt.link/eqm4l)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub here: [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: Page composition with components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a user interface, we must have a starting point, be it a crude sketch
    to a fancy full-fledged design. The graphic design of a web application is beyond
    the scope of this book, so we will consider that it has been created already.
    To translate the design into components, we could approach it as a process that
    answers the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we represent the layout and multiple elements with components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How will these components communicate and relate to each other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What dynamic elements will enter or leave the scene, and what events or application
    states will they be triggered by?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What design patterns can we apply that best serve the use case, considering
    trade-offs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vue 3 is specially fit to create dynamic, interactive interfaces. These questions
    lead us to a repeatable approach for the implementation. So, let’s define a general
    process with well-defined stages, step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – identify layouts and user interface elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This step answers the question: *How can we represent the layout and multiple
    elements* *with components?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take the page as a whole and consider what layout would work best,
    given the design. Should we use columns? Sections? Navigation menus? Islands of
    content? Are there dialogs or modal windows? A simple approach is to take the
    design image and mark the sections that may represent components with rectangles,
    from the outermost down to the singular unit of interaction. Iterate over this
    *slicing* of the page until you have a comfortable number of components. Considering
    the new To-Do application design, here is what this step may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: "![ Figure 4.1 \uFEFF– A slicing of the design into components with dashed boxes](img/Figure_4.01_B18602.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – A slicing of the design into components with dashed boxes
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve identified the components, we must extract the relationships between
    them, creating a hierarchy from the topmost root component (usually, this will
    be our `App.vue`). New components may appear because of grouping components by
    context or functionality. This is a good time to name the components. This initial
    architecture will evolve as we implement design patterns. Following this example,
    the hierarchy may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.2 \uFEFF– An initial approach to the component’s hierarchy](img/Figure_4.02_B18602.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – An initial approach to the component’s hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Notice how a new component appeared, `ToDoProject.vue`, from grouping other
    components. The `App` component usually deals with the main layout of the application
    and the starting point in the hierarchy. Now, with our initial design in place,
    it is time to move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – identify relationships, the data flow, interactions, and events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This step answers the question: *How will these components communicate and
    relate to* *each other?*'
  prefs: []
  type: TYPE_NORMAL
- en: In this stage, we need to understand the user’s interaction (with a use case,
    user story, or something else). For each component, we decide what information
    it will hold (the state), what will pass down to its children, what it needs from
    its parent, and what events it will trigger. In Vue, components can only relate
    vertically to one another. Siblings ignore the existence of each other for the
    best part. If a sibling component needs to share data with another, that data
    must be hosted by a common third party who can share it with both, usually the
    parent who has common visibility. There are other solutions for this, such as
    reactive state management, which we will cover in detail in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173),
    *Data Flow Management*. For this chapter, we will settle with the basic relationship
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to document this information: scribbled notes in the hierarchy
    tree (see *Figure 4**.2*), descriptive formal documentation, UML diagrams (**UML**
    stands for **Universal Modeling Language**, an iconography representation of software
    components), and more. For simplicity, let’s write down only one segment of the
    tree in a table format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Function** | **State,** **I/O, events** |'
  prefs: []
  type: TYPE_TB
- en: '| ToDoProject.vue | Hosts a list of to-do items and coordinates interaction
    with the user. This component will actively modify the items. | State: The to-do
    listEvents: Open new, edit, and delete modals |'
  prefs: []
  type: TYPE_TB
- en: '| ToDoSummary.vue | Displays a summary count of to-do items by state. | Input:
    The list of to-do itemsState: Counters for each item state |'
  prefs: []
  type: TYPE_TB
- en: '| ToDoFilter.vue | Collects a string to filter the list of to-do items. | Output:
    A filter stringState: An auxiliary variable |'
  prefs: []
  type: TYPE_TB
- en: '| ToDoList.vue | Displays the list of to-do items, and the signal operations
    for each one. | Input: The to-do list, a filter stringEvents: Toggle item state,
    edit and delete item |'
  prefs: []
  type: TYPE_TB
- en: For brevity, I have omitted the components and interactions that will make up
    the user dialogs. We will see them later in this chapter, but suffice it to say,
    it is the responsibility of `ToDoProject.vue` to manage the interaction using
    modal dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – identify user interactivity elements (inputs, dialogs, notifications,
    and more)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This step answers the question: *What dynamic elements will enter or leave
    the scene, and what events or application states will they be* *triggered by?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, the main CRUD operations (`ToDoProject.vue` component that
    controls this interaction as a response to certain events. This process is illustrated
    in this sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.3 \uFEFF– User interaction through modals – edit an item](img/Figure_4.03_B18602.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – User interaction through modals – edit an item
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, the `ToDoProject` component shares the to-do list with the
    `ToDoList` component. When the user triggers the `edit` event, the child component
    notifies the parent by raising such an event. The parent then makes a copy of
    the item and opens a modal dialog, passing said copy. When the dialog is accepted,
    the parent modifies the original item with the changes. Then, Vue’s reactivity
    reflects the state change in the child components.
  prefs: []
  type: TYPE_NORMAL
- en: Often, these interactions help us identify the need for additional components
    that were not evident in *Step 1*, such as the implementation of design patterns...
    which is the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – identify design patterns and trade-offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This step answers the question: *What design patterns can we apply that best
    serve the use case,* *considering trade-offs?*'
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what patterns to use can be a very creative process. There is no silver
    bullet, and multiple solutions can provide different results. It is common to
    make several prototypes to test different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In our new application, we have introduced the concept of modal dialogs to capture
    user input. Modal dialogs are used when an operation requires a user action or
    decision to proceed. The user can accept or reject the dialog, and cannot interact
    with any other part of the application until such a decision is made. Given these
    conditions, one possible pattern to apply is the **Async** **Promise** pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we want to open a modal dialog as a promise that, by definition,
    will provide us with a `resolve()`(accept) or `reject()` (cancel) function. Moreover,
    we want to be able to use this solution in multiple projects, and globally in
    our application. We can create a plugin for this purpose, and use the **dependency
    injection pattern** to access the modal functionality from any component. These
    patterns will provide us with the solution we need to make our modal dialog reusable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are almost ready to start implementing the components conceptually.
    However, to create a more suitable and sturdy application, and implement the aforementioned
    patterns, we should take a moment to learn more about Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: Components in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the building blocks of the framework. In [*Chapter 1*](B18602_01.xhtml#_idTextAnchor017),
    *The Vue 3 Framework*, we saw how to work with components, declare reactive variables,
    and more. In this section, we will explore more advanced features and definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Local and global components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we start our Vue 3 application, we mount the main component (`App.vue`)
    to an HTML element in the `main.js` file. After that, in the script section of
    each component, we can import other components to use locally through this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this manner, to use `MyComponent` in another component, we need to import
    it again in such a component. If one component is used continuously in multiple
    components, this repetitive action breaks the development DRY principle (see [*Chapter
    2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and Patterns*).
    The alternative is to declare the component as `main.js` file, we can use the
    `App.component()` method for this use case:'
  prefs: []
  type: TYPE_NORMAL
- en: Main.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `component()` method receives two arguments: a `String` that represents
    the HTML tag for the component, and an object with the component definition (either
    imported or in-lined). After registration, it is available to all the components
    in our application. There are, however, a few drawbacks to using global components:'
  prefs: []
  type: TYPE_NORMAL
- en: The component will be included in the final build, even if never used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global registrations obscures the relationship and dependencies between components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name collision may occur with locally imported components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommendation is to globally register only those components that provide
    generic functionality and avoid those that are an integral part of a workflow
    or specific context.
  prefs: []
  type: TYPE_NORMAL
- en: Static, asynchronous, and dynamic imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, all the components we have imported have been *statically* defined with
    the `import XYZ from "filename"` syntax. Bundlers such as **Vite** include them
    in a single JavaScript file. This increases the bundle’s size and could create
    delays in the startup of our application as the browser needs to download, parse,
    and execute the bundle and all its dependencies before any user interaction may
    take place. This code may include features that are seldom used or accessed. The
    clear alternative to this is to split our bundle file into multiple smaller files
    and load them as needed. In this case, we have two approaches – one provided by
    Vue 3 and another one provided by the newest JavaScript syntax for dynamic imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue 3 provides a function called `defineAsyncComponent`. This function takes
    a parameter another function that returns a dynamic import as an argument. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of this function makes it safe to use in most bundlers. An alternative
    to this syntax is used by Vue Router, which we will see in [*Chapter 5*](B18602_05.xhtml#_idTextAnchor130),
    *Single-Page Applications*: the `import()` dynamic declaration provided by JavaScript
    ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import)),
    This has a very similar syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this syntax is more succinct. However, it can only be used when
    defining routes with Vue Router as, internally, the way that Vue 3 and Vue Router
    handle lazy loading components is different. In the end, both approaches will
    split the main bundle file into multiple smaller files that will be automatically
    loaded when needed in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `defineAsyncComponent` has some advantages. We can also pass any function
    that returns a promise that resolves to a component. This allows us to implement
    logic to control the process dynamically at runtime. Here is an example where
    we have decided to load one component based on the value of an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The third syntax for `defineAsyncComponent` is probably the most useful. We
    can pass an object with attributes as an argument, which provides more control
    over the loading operation. It has these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loader` (mandatory): It must provide a function that returns a promise that
    loads the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadingComponent`: The component to display while the asynchronous component
    is loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`: The number of milliseconds to wait before displaying `loadingComponent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errorComponent`: The component to display if the promise rejects, or if the
    loading fails for any reason'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`: The time in milliseconds before considering the operation to have
    failed and displaying `errorComponent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example that uses all these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While the browser retrieves the component from the `loader` attribute, we display
    a `SpinnerComponent` to inform the user that the operation is underway. After
    1 minute of waiting, as defined by `timeout`, it will display the `LoadingError`
    component automatically.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, our code is better optimized. Now, let’s learn how to receive
    data and notify other components through events.
  prefs: []
  type: TYPE_NORMAL
- en: Props, events, and the v-model directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen basic uses for props and events as means of passing data in and
    out of a component to its parent. But more powerful definitions are possible with
    multiple syntaxes. Props can be defined in the `script setup` syntax with `defineProps`
    and any of the following argument formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an array of strings – for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const $props=defineProps(``)`'
  prefs: []
  type: TYPE_NORMAL
- en: As an object, whose attributes are used as a name, and the value is of the data
    type – for example,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const $props=defineProps(``)`'
  prefs: []
  type: TYPE_NORMAL
- en: As an object, whose attributes define an object with a type and default value
    – for example,
  prefs: []
  type: TYPE_NORMAL
- en: '`const $props=defineProps(`**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    name: { type: String, default: “John”},**'
  prefs: []
  type: TYPE_NORMAL
- en: '**    last_name: {type: String, default: “Doe”}**'
  prefs: []
  type: TYPE_NORMAL
- en: '`)`'
  prefs: []
  type: TYPE_NORMAL
- en: We need to keep in mind that primitive values are passed to the component by
    **value**(meaning that changing their value inside the child component will not
    affect their value in the parent). However, complex data types, such as objects
    and arrays, are passed as **references**, so changes to their inner keys/values
    will reflect in the parent.
  prefs: []
  type: TYPE_NORMAL
- en: A note on complex types
  prefs: []
  type: TYPE_NORMAL
- en: When defining props of the `Object` or `Array` type with default values, the
    default attribute must be a function that returns said object or array. Otherwise,
    the reference to the object/array will be shared by all the instances of the component.
  prefs: []
  type: TYPE_NORMAL
- en: '*Events* are signals that our child component emits to the parent. This is
    an example of how to define the events for a component in the `script` `setup`
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike props, emits only accept an array of strings declaration. Events can
    also pass a value to the receiver. Here is an example of the invocation from the
    aforementioned definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `defineEmits` returns a function that accepts one of the same
    names provided in the definition array as the first argument. The second argument,
    `some_value`, is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Custom input controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One special application with props and events acting together is to create
    custom input controllers. In the previous examples, we used the Vue `v-model`
    directive on basic HTML input elements to capture their value. Props and events
    that follow a special naming convention allow us to create input components that
    accept the `v-model` directive. Let’s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Parent component template
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `MyComponent` in use inside our parent component, let’s
    see how we create the tie in:'
  prefs: []
  type: TYPE_NORMAL
- en: MyComponent script setup
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are using the array definition of `Props` for brevity. Notice that the name
    of the prop is `modelValue`, and the event is `update:modelValue`. This syntax
    is expected. When the parent assigns a variable with `v-model`, the value will
    be copied to `modelValue`. When the child emits the `update:modelValue` event,
    the parent variable’s value will be updated. In this way, you can create powerful
    input controls. But there’s more – you can have multiple `v-models!`
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider that `modelValue` is the default when using `v-model`. Vue 3
    has introduced a new syntax for this directive so that we can have multiple models.
    The declaration is very simple. Consider the following child component’s declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: Child component props and event
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding props and emits definition, we can now reference both from
    the parent component as the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: Parent component template
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we can attach a modifier to the `v-model:name_of_prop` directive.
    In the `Child` component, the event’s name now has to include the `update:` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The use of props and events allows a direct data flow to occur between parent
    and child components. This implies that if data needs to be shared with multiple
    children, it has to be managed at the parent level. One issue with this restriction
    appears when the parent needs to pass data not to a child, but to a grandchild
    or other deeply nested component in the hierarchy tree. That is where the *dependency
    injection pattern* comes in to save the day. Vue implements this naturally with
    the `Provide` and `Inject` functions, which we will cover in more detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection with Provide and Inject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When data in the parent needs to be available in a deeply nested child, using
    only props, we would have to “pass” the data between components, even if they
    don’t need it or use it. This issue is called *props drilling*. The same occurs
    with events traveling in the opposite direction, having to “bubble” upwards. To
    solve this issue, Vue offers an implementation of the dependency injection pattern
    with two functions named `Provide` and `Inject`. Using these, the parent or root
    component *provides* data (either by value or reference, such as an object), that
    can be *injected* into any of its children down the hierarchy tree. Visually,
    we can represent this situation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.\uFEFF4 – Representation of Provide/Inject](img/Figure_4.04_B18602.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Representation of Provide/Inject
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the process is very simple, as well as the syntax to implement
    the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the parent (root) component, we import the `provide` function from Vue and
    create a provision with a key (name) and the data to pass along:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the receiving component, we import the `inject` function and retrieve the
    data by key (name):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also provide a resource at the application level in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, the provision can be injected into any component of our application.
    It is worth mentioning that we can also provide complex data types, such as arrays,
    objects, and reactive variables. In the following example, we are providing an
    object with functions and references to the parent methods:'
  prefs: []
  type: TYPE_NORMAL
- en: In the parent/root component
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the child component
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have effectively provided an `Admin.Users.Individual.Profile`
    is more descriptive than `user_data`. It is up to the team and the developer to
    define the naming convention (a path-like naming is just a suggestion, not a standard).
    As mentioned before in this book, once you’ve decided upon a convention, what
    matters is that you are consistent throughout the source code. Later in this chapter,
    we will use this method to create a plugin to display modal dialogs, but before
    that, we need to see a few more concepts regarding special components and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Special components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hierarchy of components is very powerful but has limitations. We have seen
    how we can apply the dependency injection pattern to solve one of those, but there
    are other cases where we need a bit more flexibility, reusability, or power to
    share code or templates, or even move a component that’s rendering outside the
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Slots, slots, and more slots...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Through the use of props, our component can receive JavaScript data. With analog
    reasoning, it is also possible to pass template fragments (HTML, JSX, and so on)
    into specific parts of a component’s template using placeholders called **slots**.
    Just like props, they accept several types of syntax. Let’s start with the most
    basic: the *default slot*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a component named `MyMenuBar` that acts as a placeholder
    for a top menu. We want the parent component to populate the options in the same
    way that we use a common HTML tag such as `header` or `div`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Parent component
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: MyMenuBar component
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Provided that we applied the necessary styling and classes in `MyMenuBar`,
    the final rendered template may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A menu bar using slots](img/Figure_4.05_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – A menu bar using slots
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic that’s applied is quite straightforward. The `<slot></slot>` placeholder
    will be replaced at runtime by whatever content is provided by the parent component
    inside the child tags. In the preceding example, if we inspect the rendered final
    HTML, we may find something like this (considering that we are using `W3.css`
    classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fundamental concept in user interface design. Now, what if we need
    multiple “slots” – for example, to create a layout component? Here, an alternative
    syntax called *named slots* comes into play. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: MyLayout component
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have named each slot through the *name attribute*. In the
    parent component, we must now use the `template` element with the `v-slot` directive
    to access each one. Here is how a parent component would make use of `MyLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: Parent component
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `v-slot` directive receives one argument, matching the slot name, with
    these remarks:'
  prefs: []
  type: TYPE_NORMAL
- en: If the name does not match any available slot, the content is not rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no name is provided, or the name `default` is used, then the content is rendered
    in the default nameless slot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If no content is provided for a template, then the default elements inside
    of the slot definition will be shown. Default content is placed in between the
    slot tags: `<slot>...default` `content here...</slot>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also a shorthand notation for the `v-slot` directive. We just prefix
    the name of the slot with a numeral sign (`#`). For example, the templates in
    the preceding parent component can be simplified like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Slots in Vue 3 are very powerful, to the point that they even admit a way to
    pass props to the parent if needed. The syntax varies depending on whether we
    are using a *default slot* or *named slots*. For example, consider the following
    component template definition:'
  prefs: []
  type: TYPE_NORMAL
- en: PassingPropsUpward component
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the slot is passing a prop to the parent, named `data`. The parent component
    can then access it with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Parent component receiving props from the slot
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the parent component, we use the `v-slot` directive and assign a local name
    to the props passed by the slot – in this case, `upwardProp`. This variable will
    receive an object similar in function to the props object but scoped to the element.
    Because of this, these types of slots are called *named scoped slots*, and the
    syntax is similar. Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There are other advanced uses for slots that cover edge cases, but we will not
    cover those in this book. Instead, I encourage you to investigate the topic further
    in the official documentation at [https://vuejs.org/guide/components/slots.html](https://vuejs.org/guide/components/slots.html).
  prefs: []
  type: TYPE_NORMAL
- en: There is one more concept related to this topic that we will see later in this
    book, in [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173), *Data Flow Management*,
    that applies to reactive central state management. Now, let’s look at some special
    components that behave a bit out of the ordinary.
  prefs: []
  type: TYPE_NORMAL
- en: Composables and mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Vue 2, a special component named `composables`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **composable** is a function that uses the Composition API to encapsulate
    and reuse *stateful logic* between components. It is important to distinguish
    composables from service classes or other encapsulations of *business logic*.
    The main purpose of a composable is to share *user interface or user interaction
    logic*. In general, each composable does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exposes a function that returns *reactive* variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follows a naming convention prefixed with `use` in *camelCase* format – for
    example, `useStore()`, `useAdmin()`, `useWindowsEvents()`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is self-contained in its own module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles *stateful logic*. This means that it manages data that persists and
    changes over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The classical example of a composable attaches itself to environmental events
    (window resizing, mouse movements, sensors, animations, and so on). Let’s implement
    a simple composable that reads the vertical scroll of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: DocumentScroll.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this small composable, we start by importing component''s life cycle events
    and the reactive constructor from Vue (`//1`). Our main function, `useDocumentScroll`,
    contains the entire code that we will share and export later (`//6`). In `//2`,
    we create a reactive constant and initialize it to the current window vertical
    scroll. Then, we create an internal function, `update`, that updates the value
    of `y`. We add this function as a listener to the document scroll event in `//3`,
    and then remove it in `//4` (principle *“Clean after yourself,”* from [*Chapter
    2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and Patterns*).
    Finally, in `//5`, we return our reactive constant wrapped in an object. Then,
    in a component, we use this composable in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: SomeComponent.js – script setup
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once we have imported the reactive variable, we can use it in our code and template
    as usual. If we need to use this bit of logic in more than one component, we just
    need to import the composable (**DRY** principle).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [https://vueuse.org/](https://vueuse.org/) has an impressive collection
    of composables for our projects. It is worth checking out.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic components with “component:is”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Vue 3 framework provides a special component called `<component>` whose
    job is to be a placeholder to render other components dynamically. It works with
    a special attribute, `:is`, that can receive either a **String** with the name
    of a component, or a variable with the component definition. It also accepts some
    basic expressions (a line of code that resolves to a value). Here is a simple
    example using an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: CoinFlip component
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When this component is rendered, we will see either the `Heads` or `Tails` component
    based on the result of the `flipCoin()` function.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be wondering, why not use a simple `v-show/v-if`? The
    power of this component becomes apparent when managing components dynamically
    and we don’t know which ones are available at the time of creating the template.
    The official Vue Router, which we will see in [*Chapter 5*](B18602_05.xhtml#_idTextAnchor130),
    *Single-Page Applications*, uses this special component to simulate page navigation.
  prefs: []
  type: TYPE_NORMAL
- en: There is an edge case, however, that we need to be aware of. While most template
    attributes will pass through to the dynamic component, the use of some directives
    such as `v-model` will not work on *native input elements*. This situation is
    so rare that we will not discuss it in detail, but it can be found in the official
    documentation at [https://vuejs.org/api/built-in-special-elements.html#component](https://vuejs.org/api/built-in-special-elements.html#component).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a deeper understanding of components, let’s put this new knowledge
    to work in two projects: a plugin, and a new version of our To-Do application.'
  prefs: []
  type: TYPE_NORMAL
- en: A real-world example – a modals plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen multiple approaches for sharing data and functionality *within*
    a project. Plugins are a design pattern for sharing functionality between projects
    and at the same time augmenting a system’s capabilities. Vue 3 provides a very
    simple interface to create plugins and attach them to our application instance.
    Any object that exposes an `install()` method or a function that accepts the same
    parameters can become a plugin. A plugin can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Register global components and directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register an injectable resource at the application level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and attach new properties or methods to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will create a plugin that implements modal dialogs as global
    components. We will use dependency injection to provide them as a resource and
    leverage Vue’s reactivity to manage them through promises.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the instructions in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079),
    *Setting Up a Working Project*, so that you have a starting point. In the `src/`
    directory, create a new folder named `plugins/`, with a sub-folder named `modals/`.
    It is a standard approach to place our plugins in individual directories inside
    the `plugins/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our plugin will install a component globally and keep an internal reactive
    state to track the current modal dialog status. It will also provide an API to
    be injected as a dependency to those components that need to open a modal dialog.
    This interaction can be represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.6 \uFEFF– The modal plugin’s representation](img/Figure_4.06_B18602.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The modal plugin’s representation
  prefs: []
  type: TYPE_NORMAL
- en: Components will implement a modal element, and we will open the dialog through
    code. When a modal is open, it will return a promise following the async pattern.
    When the user accepts the modal, the promise will resolve, and reject upon cancellation.
    The content of the modal will be provided by the parent component through the
    use of slots.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this plugin, we will only need two files – one for the plugin''s logic
    and one for our component. Go ahead and create the `index.js` and `Modal.vue`
    files in the `src/plugins/modal` folder. At the moment, just scaffold the component
    with the section’s script setup, template, and style. We will come back later
    to complete it. With those files in place, let’s start, step by step, with the
    `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/plugins/modals/index.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We start in `//1` by importing the `reactive` constructor from Vue, and a `Modal`
    component whose file we have not yet created. Then, in line `//2`, we create an
    internal state property, `_current`, and in `//3`, an object that will be our
    API. For now, these are just placeholders. The important section is in line `//4`,
    where we define the `install()` function. This function receives two parameters
    in order:'
  prefs: []
  type: TYPE_NORMAL
- en: The application instance (`App`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An object with options, if one was passed during the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the application instance, we register `Modal` as a global component and
    provide the API as an injectable resource under the name `$modals,` both at the
    application level. To use the plugin in our application, we must import it into
    `main.js` and register it with the `use` method. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/Main.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, creating and using a plugin is rather simple. However, thus
    far, our plugin doesn’t do much. Let’s go back to our plugin code and complete
    the API. What we need is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `show()` method that takes a name that identifies a modal dialog implementation
    and returns a promise. We will then save the name and references to the `resolve()`
    and `reject()` functions in our reactive state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `accept()` and `cancel()` methods, to resolve and reject the promise, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `active()` method to retrieve the name of the current modal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following these guidelines, we can complete the code so that our `index.js`
    file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/plugins/modals/index.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our internal state is kept with a `reactive` variable and only accessed through
    our API. In general, this is a good design for any API. Now, it is time to make
    the magic happen in our `Modal.vue` component, to complete the workflow. I’m omitting
    the classes and styles for brevity, but the full code can be found in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our modal component will have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cover the entire viewable area with a translucent element to block interaction
    with the rest of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide the dialog to be displayed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *prop* to register the name of the component, as provided by the parent.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A *header* to display a title. The title will also be a prop.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An area for the parent component to populate with custom content.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A footer with *accept* and *cancel* buttons.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A reactive property that triggers when the component should appear.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With our definition in place, let’s work on the template:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/plugins/modals/Modal.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In line `//1`, the reactive variable, `_show`, controls the visibility of the
    dialog modal. We display the prop `title` in line `//2`, and reserve a slot in
    line `//3`. The buttons in line `//4` will close the modal on the click event,
    each one with a representative Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not, it’s time to write the logic of the component. In our script, we need
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define two props: `title` (for display) and `name` (for identification)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inject the `$modals` resource so that we can interact with the API and do these
    things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if the modal’s name matches the current component (this “opens” the modal
    dialog)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the modal by resolving or rejecting the promise
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Following these directions, we can complete our `script setup:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We begin in line `//1` by importing the `inject` and `computed` functions. In
    line `//2`, we create the props with sensible defaults. In line `//3`, we inject
    the `$modals` resource (dependency) that we will use in the computed property
    in line `//4` to retrieve the current active modal and compare it with the component.
    Finally, in line `//5`, based on the click of the buttons, we trigger the resolution
    or rejection of the promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this plugin from any component in our application, we must follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `template`, define a modal component with the name registered in our plugin
    (`Modal`). Notice the use of the attributes for props:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our script setup, inject the dependency with the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the modal component by the given name with this code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, we have completed our first plugin in Vue 3\. Let’s put it to good
    use in our new To-Do list application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our new To-Do application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw a design for our new to-do application,
    and we sliced it into hierarchical components (see *Figure 4**.1*). To follow
    the rest of this section, you will need a copy of the source code from this book’s
    GitHub repository ([https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices)).
    As our code base grows, it is not possible to see each piece of implementation
    in detail, so we will focus on the main changes and specific bits of code. With
    that in mind, let’s review the changes from the previous implementation, roughly
    in order of file execution. To start, we added two new directories to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/plugins`, where we placed our `Modals` plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/src/services`, where we place modules with our business or middleware logic.
    Here, we created a service object to handle the business logic of our To-Do list:
    the `todo.js` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `main.js`, we import and add our plugin to the application object, using
    the `.use(Modals)` method to register our plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The `App.vue` file has become primarily a layout component, without any other
    application logic. We import and use a header, `(MainHeader.vue)`, and a parent
    component to manage our To-Do list and UI, (`ToDoProject.vue)`, just like in the
    design shown in *Figure 4**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ToDoProject` component contains the state of the list through reactive
    variables, where we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_items` is an array that contains our To-Do items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_item` is an auxiliary reactive variable that we use to create new items or
    edit a duplicate of an item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_filter` is another auxiliary reactive variable that we use to input a string
    to filter on our list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth mentioning that we also declare a constant, `$modals`, that receives
    the injected `Modals` object API. Notice how the `showModal()` function opens
    and manages the result of the dialog for new and edited items using this object.
    Then, the modal in question appears in the template, by the ending marked with
    a comment. It is customary to place all the modal templates toward the end of
    a component, instead of being spaced all over the template.
  prefs: []
  type: TYPE_NORMAL
- en: The `ToDoProject` component delegates state data through props to child components
    to display summary and list items. It also receives events from them, with instructions
    to manipulate the list. You can consider this component as the *root* of functionality.
    Our application only has one, but this begins to hint at the idea of how a web
    application starts to get organized by functionality.
  prefs: []
  type: TYPE_NORMAL
- en: There is another point worth mentioning, which is the use of *service objects
    and classes*. In our application, we have `todo.js`, which we import as `todoService`
    where needed. In this case, this is a *singleton*, but it could also be a class
    constructor. *Notice that it does not contain any interface logic, only application
    or business logic*. This is a defining factor that differentiates it from *composables*,
    which we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another change is that the To-Do items now have multiple states, and we can
    cycle through them with a click. We have implemented this logic in the `toggleStatus()`
    function of the service, *not in the component*. The flow between the states can
    be represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.7 \uFEFF– A circular finite state machine](img/Figure_4.07_B18602.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – A circular finite state machine
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recognize the design, as it represents a `switch` statement, like in
    our example:'
  prefs: []
  type: TYPE_NORMAL
- en: Todo.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This function, given its current status, will return the next one. Calling this
    function on each click, we can update the state of each item in a clean manner.
  prefs: []
  type: TYPE_NORMAL
- en: The final point to remark about this new implementation is the use of computed
    properties in the `ToDoSummary` component. We use them to display summary cards
    with the different states of our items. Notice how well the reactivity works –
    the moment we alter the state of an item in the list, the summary is immediately
    updated!
  prefs: []
  type: TYPE_NORMAL
- en: With the new implementation in order, it is time to take a step back and view
    our work with a critical mind.
  prefs: []
  type: TYPE_NORMAL
- en: A small critique of our new To-Do application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This new version of the To-Do application is a clear improvement over our first
    approach, but it can be improved:'
  prefs: []
  type: TYPE_NORMAL
- en: We still have only one list of tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything still happens in just one page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our items are ephemeral. They disappear when we close or refresh the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no security, no way to have multiple users, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can only add plain text. How about images or rich text?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a bit of work, we could expand our application so that it manages multiple
    projects, additional content, assignments, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have made good progress, but there is still more to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived deep into components and learned how they can communicate,
    share functionality, and implement design patterns within the framework. We also
    saw an approach to transform a rough sketch or detailed design into components.
    We then learned about special components, created a plugin for modal dialogs using
    the framework’s dependency injection, and applied other patterns to make our coding
    easier and more congruent. Furthermore, we refactored our application and expanded
    its capabilities while taking a glimpse at better state management, independent
    from the HTML element we used before. We have made good progress, but there is
    still more to go.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a **single-page application** (**SPA**)
    with what we learned this far.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we start from a visual design or prototype and plan the implementation
    with components?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the many ways that components can communicate with each other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can reuse code in multiple components? Is there any other way?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a plugin, and how can we create one?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which patterns have we applied to the new To-Do application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What would you change in the implementation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
