- en: Chapter 6. The Slider and Progressbar Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。滑块和进度条小部件
- en: The slider component allows us to implement an engaging and easy-to-use widget
    that our visitors should find attractive and intuitive to use. Its basic function
    is simple. The slider track represents a series of values that are selected by
    dragging the handle along the track.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块组件允许我们实现一个引人入胜且易于使用的小部件，我们的访问者应该会发现它吸引人且直观易用。它的基本功能很简单。滑块轨道表示一系列由沿着轨道拖动的手柄选择的值。
- en: The progressbar widget is used to show the percentage complete for any arbitrary
    process. It's a simple and easy-to-use component with an extremely compact API
    that provides excellent visual feedback to visitors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条部件用于显示任意过程的完成百分比。这是一个简单易用的组件，具有极其紧凑的 API，为访问者提供了出色的视觉反馈。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The default slider implementation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的滑块实现
- en: Custom styling for sliders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块的自定义样式
- en: Changing the configuration options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改配置选项
- en: Creating a vertical slider
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建垂直滑块
- en: Setting minimum, maximum, and default values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置最小值、最大值和默认值
- en: Enabling multiple handles and ranges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用多个手柄和范围
- en: The slider's built-in event callbacks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块的内置事件回调
- en: Slider methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块方法
- en: The default implementation for a progressbar
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进度条的默认实现
- en: The configurable options
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的选项
- en: The event API exposed by the widget
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件公开的事件 API
- en: The single unique method exposed by the progressbar
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进度条公开的唯一方法
- en: Some real-world examples of a progressbar
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进度条的一些真实世界示例
- en: 'Before we roll up our sleeves and begin creating a slider, let''s look at the
    different elements that it is made from. The following diagram shows a typical
    slider widget:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们卷起袖子开始创建滑块之前，让我们看一下它由哪些不同的元素组成。以下图示显示了一个典型的滑块小部件：
- en: '![The Slider and Progressbar Widgets](img/2209OS_06_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![滑块和进度条小部件](img/2209OS_06_01.jpg)'
- en: It's a simple widget, as you can see, comprised of just two main elements—the
    **slider** **handle** (sometimes called the thumb), and the **slider track**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，这是一个简单的小部件，只由两个主要元素组成——**滑块手柄**（有时称为拇指）和**滑块轨道**。
- en: Introducing the slider widget
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入滑块部件
- en: 'Creating the default, basic slider takes no more code than any of the other
    widgets that we have looked at so far. The underlying HTML markup required is
    also minimal. Let''s create a basic one now. In a new page in your text editor,
    add the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建默认的基本滑块所需的代码与我们迄今为止看过的任何其他小部件一样少。所需的基本 HTML 标记也很少。现在让我们创建一个基本的滑块。在文本编辑器的新页面中，添加以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save this file as `slider1.html` and view it in your browser. On the page is
    a simple container element; this will be transformed by the widget into the slider
    track. In `<script>` within the `<head>` section of the code, we select this element
    and call the `slider` method on it. The `<a>` element that is used for the slider
    handle will be automatically created by the widget.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider1.html`并在浏览器中查看。页面上有一个简单的容器元素；该元素将由小部件转换为滑块轨道。在代码的`<head>`部分中的`<script>`内，我们选择此元素并在其上调用`slider`方法。用于滑块手柄的`<a>`元素将由小部件自动创建。
- en: 'When we run the `slider1.html` file in a browser, we should see something similar
    to the previous diagram. We''ve used several library resources for the default
    implementation, including the following files:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行`slider1.html`文件时，我们应该会看到类似于上一个图示的东西。我们为默认实现使用了几个库资源，包括以下文件：
- en: '`jquery.ui.all.css`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.all.css`'
- en: '`jquery-2.0.3.js`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-2.0.3.js`'
- en: '`jquery.ui.core.js`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.core.js`'
- en: '`jquery.ui.widget.js`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.widget.js`'
- en: '`jquery.ui.mouse.js`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.mouse.js`'
- en: '`jquery.ui.slider.js`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.slider.js`'
- en: The default behavior of a basic slider is simple but effective. The thumb can
    be moved horizontally along any pixel of the track on the x axis by dragging the
    thumb with the mouse pointer, or using the left/down or right/up arrow keys on
    the keyboard. Clicking anywhere on the track with the left button will instantly
    move the handle to that position.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基本滑块的默认行为简单而有效。可以通过用鼠标指针拖动拇指或使用键盘上的左/下或右/上箭头键，在 x 轴上沿轨道的任何像素移动拇指。使用鼠标左键单击轨道上的任何位置将立即将手柄移动到该位置。
- en: Custom styling
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义样式
- en: 'Because of its simplicity, it is easy to create a custom theme for the slider
    widget. Using ThemeRoller is one method of theming: we can simply download a new
    theme, then put it into the theme folder and change the reference within our code
    to the name of the new theme. Like all other widgets, the slider will be restyled
    to use the new theme.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性，很容易为滑块小部件创建自定义主题。使用ThemeRoller是其中一种主题化的方法：我们只需下载一个新主题，然后将其放入主题文件夹，并在代码中更改对新主题的引用名称。与所有其他小部件一样，滑块将被重新设计为使用新主题。
- en: 'To completely change the look and feel of the widget though, we can easily
    create our own theme file. In your text editor create the following stylesheet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全改变小部件的外观和感觉，我们可以轻松创建自己的主题文件。在您的文本编辑器中创建以下样式表：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save this file as `sliderTheme.css` in the `css` directory. In `slider1.html`,
    add a link to the stylesheet in the `<head>` of the page (after the jQuery UI
    stylesheet), and wrap the underlying slider element in a new container:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`sliderTheme.css`，放在`css`目录中。在`slider1.html`中，在页面的`<head>`标签中添加一个链接到样式表（在jQuery
    UI样式表之后），并将底层滑块元素包裹在一个新容器中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save this file as `slider2.html`. With a minimum of CSS and a few images (these
    can be found in the code download), we can easily but considerably modify the
    widget''s appearance, as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider2.html`。只需最少量的CSS和几张图片（这些可以在代码下载中找到），我们就可以轻松但显著地修改小部件的外观，如下面的屏幕截图所示：
- en: '![Custom styling](img/2209OS_06_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![自定义样式](img/2209OS_06_02.jpg)'
- en: Let us turn our attention to how we can configure the slider widget, using some
    of its options.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向如何配置滑块小部件，使用一些选项。
- en: Configuring a basic slider
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基本滑块
- en: 'Additional functionality, such as vertical sliders, multiple handles, and stepping
    can also be configured using an object literal, passed into the widget method
    when the slider is initialized. The options that can be used in conjunction with
    the slider widget are listed in the following table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用对象文字配置额外的功能，例如垂直滑块、多个手柄和步进，这些功能在初始化滑块时传递到小部件方法中。可以与滑块小部件一起使用的选项列在以下表格中：
- en: '| Option | Default value | Usage |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用法 |'
- en: '| --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `animate` | `false` | Enables a smooth animation of the slider handle when
    the track is clicked. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `animate` | `false` | 当单击轨道时启用滑块手柄的平滑动画。 |'
- en: '| `disabled` | `false` | Disables the widget when it is initialized. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | `false` | 当初始化小部件时禁用小部件。 |'
- en: '| `max` | `100` | Sets the maximum value of the slider. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `max` | `100` | 设置滑块的最大值。 |'
- en: '| `min` | `0` | Sets the minimum value of the slider. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `min` | `0` | 设置滑块的最小值。 |'
- en: '| `orientation` | `auto` | Sets the axis along which the slider thumb is moved.
    This can accept the strings vertical or horizontal. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `orientation` | `auto` | 设置滑块手柄移动的轴。这可以接受字符串垂直或水平。 |'
- en: '| `range` | `false` | Creates a styleable range of elements between them. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `range` | `false` | 在它们之间创建一个可定制样式的元素范围。 |'
- en: '| `step` | `1` | Sets the distance of the step that the handle will take along
    the track. The max value must be equally divisible by the supplied number. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `step` | `1` | 设置手柄沿轨道移动的步距。最大值必须能够被提供的数字整除。 |'
- en: '| `value` | `0` | Sets the value of the slider thumb when the widget is initialized.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `value` | `0` | 在初始化小部件时设置滑块手柄的值。 |'
- en: '| `values` | `null` | Accepts an array of values. Each supplied integer will
    become the value of a slider handle. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `values` | `null` | 接受一个值数组。每个提供的整数将成为滑块手柄的值。 |'
- en: Creating a vertical slider
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个垂直滑块
- en: To make a vertical slider, all we need to do is set the `orientation` option
    to `vertical`; the widget will do the rest for us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个垂直滑块，我们只需将`orientation`选项设置为`vertical`；小部件将为我们完成其余工作。
- en: 'In `slider1.html`, change the final `<script>` element so that it appears as
    follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`slider1.html`中，更改最后的`<script>`元素，使其如下所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save this file as `slider3.html`. We just need to set this single option to
    put the slider into `vertical` mode. When we launch the page, we see that the
    slider operates exactly as it did before, except that it now moves along the y
    axis, as in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider3.html`。我们只需要设置这个单一选项就可以将滑块放入`vertical`模式。当我们启动页面时，我们会看到滑块的操作与以前完全相同，只是现在它沿着y轴移动，如下图所示：
- en: '![Creating a vertical slider](img/2209OS_06_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个垂直滑块](img/2209OS_06_03.jpg)'
- en: The widget defaults to `100px` in height, unless we provide our own CSS rule
    for `.ui-slider-vertical` in the stylesheet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件默认高度为`100px`，除非我们在样式表中为`.ui-slider-vertical`提供自己的CSS规则。
- en: Setting the maximum and minimum values
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置最大值和最小值
- en: 'By default, the minimum value of the slider is `0` and the maximum value is
    `100`, but we can change these values easily using the `min` and `max` options.
    Change the configuration object in `slider3.html` to the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，滑块的最小值为`0`，最大值为`100`，但是我们可以使用`min`和`max`选项轻松更改这些值。将`slider3.html`中的配置对象更改为以下代码：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save this file as `slider4.html`. We simply specify the integers that we'd like
    to set as the start and end values. The `value` and `values` methods are exclusive
    to the slider, and are used to get or set the value of single or multiple handles.
    As the `value` option is set to `0` by default, when we run the `slider4.html`
    file, the slider thumb will start in the middle of the track, half way between
    `-50` and `50`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider4.html`。我们只需指定我们希望设置为起始和结束值的整数。`value`和`values`方法是滑块专有的，并且用于获取或设置单个或多个手柄的值。由于`value`选项默认设置为`0`，当我们运行`slider4.html`文件时，滑块拇指将从轨道中间开始，在`-50`和`50`之间。
- en: 'When the slider handle, in this example, is at the minimum value, the `value`
    method will return to `-50`, as we would expect. To prove this, we could adapt
    `slider4.html` to show this value in an alert. Add the following code immediately
    below the slider configuration object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，当滑块手柄位于最小值时，`value`方法将返回`-50`，正如我们所期望的那样。为了证明这一点，我们可以修改`slider4.html`以在警报中显示此值。在滑块配置对象的下方立即添加以下代码：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the markup within `<body>`, change it as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<body>`标记中，将其更改如下：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we now try previewing changes in a browser, you will get an alert that will
    appear when clicking on the button, once you've moved the handle to the far left
    of the slider. We will explore the `value` option later in the *Using the slider
    methods* section of this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试在浏览器中预览更改，当您将手柄移动到滑块的最左端时，将会弹出一个警报。我们将在本章的*使用滑块方法*部分中探讨`value`选项。
- en: Stepping with the slider widget
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用滑块小部件进行步进
- en: 'The `step` option refers to the number and position of steps along the track
    that the slider''s handle jumps, when moving from the minimum to the maximum positions
    on the track. The best way to understand how this option works is to see it in
    action, so change the configuration object in `slider4.html` to the following
    code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`step`选项是指滑块手柄在从轨道的最小位置移动到最大位置时跳跃的步数和位置。了解此选项如何工作的最佳方法是将其实际操作，因此将`slider4.html`中的配置对象更改为以下代码：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Save this file as `slider5.html`. We set the `step` option to `25` in this example.
    We haven't set the `min` or `max` options, so they will take the default values
    of `0` and `100` respectively. Hence, by setting `step` to `25`, we're saying
    that each step along the track should be a quarter of the track's length, because
    `100` (the maximum) divided by `25` (the step value) is `4`. The handle will therefore
    take four steps along the track, from beginning to end.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider5.html`。在此示例中，我们将`step`选项设置为`25`。我们尚未设置`min`或`max`选项，因此它们将采用默认值`0`和`100`。因此，通过将`step`设置为`25`，我们的意思是沿着轨道的每一步应该是轨道长度的四分之一，因为`100`（最大值）除以`25`（步长值）等于`4`。因此，手柄将沿着轨道从头到尾走四步。
- en: The `max` value of the slider should be equally divisible by whatever value
    we set as the `step` option; other than that, we're free to use whatever value
    we wish. The `step` option is useful to confine the value selected by the visitors
    to one of a set of predefined values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块的`max`值应该被设置为`step`选项设置的任何值的整数倍；除此之外，我们可以自由选择任何值。`step`选项对于将访问者选择的值限制在一组预定义值中非常有用。
- en: If we were to set the value of the `step` option, in this example, to `27` instead
    of `25`, the slider would still work, but the points along the track that the
    handle stepped to would not be equal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个例子中将`step`选项的值设置为`27`而不是`25`，滑块仍然可以工作，但手柄跳转到的轨道上的点将不相等。
- en: Animating the slider widget
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对滑块小部件进行动画处理
- en: 'The slider widget comes with a built-in animation that moves the slider handle
    smoothly to a new position, whenever the slider track is clicked. This animation
    is disabled by default, but we can easily enable it by setting the `animate` option
    to `true`. Change the configuration object in `slider5.html`, so that it is as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块小部件配有内置动画，每当单击滑块轨道时，该动画会将滑块手柄平滑地移动到新位置。此动画默认情况下是禁用的，但我们可以通过将`animate`选项设置为`true`来轻松启用它。更改`slider5.html`中的配置对象，使其如下所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save this file as `slider6.html`. This simple change can give a slider a more
    polished feel; instead of the slider handle just moving instantly to a new position
    when the track is clicked, it smoothly slides there.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider6.html`。这个简单的改变可以让滑块感觉更加精致；当点击轨道时，滑块手柄不再立即移动到新位置，而是平滑地滑动到那里。
- en: If the `step` option is configured to a value other than `1`, and the `animate`
    option is enabled, the thumb will slide to the nearest step mark on the track.
    This may mean that the slider thumb moves past the point that was clicked.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`step`选项配置为`1`之外的值，并启用`animate`选项，则拇指将滑动到轨道上最近的步骤标记处。这可能意味着滑块拇指移动超过了被点击的点。
- en: Setting the slider's value
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置滑块的值
- en: 'The `value` option, when set to `true` in a configuration object, determines
    the starting value for the slider thumb. Depending on what we want the slider
    to represent, the starting value of the handle may not be `0`. If we wanted to
    start at half-way across the track instead of at the beginning, we can use the
    following configuration object:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`选项，当在配置对象中设置为`true`时，确定滑块拇指的起始值。根据我们想要滑块表示的内容，手柄的起始值可能不是`0`。如果我们想要在轨道的中间开始而不是在开头，我们可以使用以下配置对象：'
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save this file as `slider7.html`. When the file is loaded in a browser, we see
    that the handle starts halfway along the track instead of at the beginning, exactly
    as it did when we set the `min` and `max` options earlier. We can also set this
    option after initialization, to programmatically set a new value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider7.html`。当在浏览器中加载文件时，我们可以看到手柄从轨道中间开始，而不是从开头开始，就像我们之前设置`min`和`max`选项时一样。我们也可以在初始化后设置此选项，以编程方式设置新值。
- en: Using multiple handles
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个手柄
- en: 'I mentioned earlier that a slider may have multiple handles; additional handles
    can be added using the `values` option. It accepts an array where each item in
    the array is a starting point for a handle. We can specify as many items as we
    wish, up to the `max` value (taking step into account):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过滑块可能有多个手柄；可以使用`values`选项添加额外的手柄。它接受一个数组，数组中的每个项都是一个手柄的起始点。我们可以指定尽可能多的项，直到`max`值（考虑到步骤）：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save this file as `slider8.html`. This is all we need to do; we don't need to
    supply any additional underlying markup. The widget has created both new handles
    for us, and as you'll see, they both function exactly as a standard single handle
    does.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider8.html`。这是我们需要做的一切；我们不需要提供任何额外的底层标记。小部件已为我们创建了两个新手柄，正如您将看到的，它们的功能都与标准单手柄完全相同。
- en: 'The following screenshot shows our dual-handled slider:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了我们的双手柄滑块：
- en: '![Using multiple handles](img/2209OS_06_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![使用多个手柄](img/2209OS_06_04.jpg)'
- en: We could make use of a double-handled slider to create a time window for a schedule.
    A good example would be on a travel booking form. Normally you would enter dates
    manually, which could be a bit clunky.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用双手柄滑块创建时间窗口以供日程安排使用。一个很好的例子是在旅行预订表格上。通常你需要手动输入日期，这可能有点笨拙。
- en: Instead, you could use a double-handled slider to select dates; the user would
    simply slide each handle to the left or right to change the date window. We can
    then use the method described in *Setting the minimum and maximum values* section
    earlier in this chapter to obtain the position values of each slider's handle.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以使用双手柄滑块选择日期；用户只需将每个手柄向左或向右滑动以更改日期窗口。然后，我们可以使用本章前面描述的*设置最小值和最大值*部分中描述的方法来获取每个滑块手柄的位置值。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When a slider has two or more handles, each handle may move past the other handle(s)
    without issue; you may want to consider setting a `range`, if you need to prevent
    this from happening.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当滑块有两个或更多手柄时，每个手柄都可以无障碍地移动到其他手柄之后；如果需要阻止此情况发生，可能需要考虑设置一个`range`。
- en: Working with the range option
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用范围选项
- en: 'When working with multiple handles, we can set the `range` option to `true`.
    This adds a styled range element between two handles. In `slider8.html`, change
    the configuration object so that it is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个手柄时，我们可以将`range`选项设置为`true`。这将在两个手柄之间添加一个样式化的范围元素。在`slider8.html`中，更改配置对象如下：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Save this file as `slider9.html`. When the page loads, we should see that a
    styled `<div>` element now connects our two handles, as shown in the following
    screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider9.html`。当页面加载时，我们应该看到一个样式化的`<div>`元素现在连接了我们的两个手柄，如下面的截图所示：
- en: '![Working with the range option](img/2209OS_06_05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用范围选项](img/2209OS_06_05.jpg)'
- en: When using two handles and a range, the two handles will not be able to cross
    each other on the track.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用两个手柄和一个范围时，两个手柄将无法在轨道上交叉。
- en: 'A maximum of two handles can be used in conjunction with the `range` option,
    but we can also enable it with a single handle change the configuration object
    in the previous example to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最多可以使用两个手柄与`range`选项一起使用，但我们也可以仅启用一个手柄将上一个示例中的配置对象更改为以下内容：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save this file as `slider10.html`. Along with the Boolean value `true`, we can
    also supply one of the string values `min` or `max`, but only when a single handle
    is in use.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider10.html`。除了布尔值`true`，我们还可以提供字符串值`min`或`max`中的一个，但仅当仅使用一个手柄时。
- en: In this example, we set it to `min`, so when we move the slider handle along
    the track, the range element will stretch from the start of the track to the slider
    handle. If we set the option to `max`, the range will stretch from the handle
    to the end of the track.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将其设置为`min`，所以当我们沿着轨道移动滑块手柄时，范围元素将从轨道的起点延伸到滑块手柄。如果我们将选项设置为`max`，范围将从手柄延伸到轨道的末端。
- en: If you want to capture the value of where the handle is on the scale, we can
    do this by using the `slide` event handler. In this instance, we only need to
    get one value (as we only have one handle), but the same principle applies if
    a second handle had been configured.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要捕获手柄在刻度上的位置，我们可以通过使用`slide`事件处理程序来实现。在这种情况下，我们只需要获取一个值（因为我们只有一个手柄），但是如果配置了第二个手柄，同样的原则也适用。
- en: 'In `slider4.html`, add the following function in just above our slider''s configuration
    object:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`slider4.html`中，将以下函数添加到我们滑块的配置对象的上方：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need to then modify the configuration object, to call our `slideValues`
    event handler at the appropriate time:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要修改配置对象，以在适当的时候调用我们的`slideValues`事件处理程序：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So we can display the results on screen, add this in below the existing markup
    in the `<body>` section:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在现有标记的`<body>`部分下方添加以下内容以在屏幕上显示结果：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can then do as we wish with the value; if you preview the results, you will
    see the value on the right change; the left value will always remain at `0`, as
    this is the default value for the `min` option in our code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照我们的意愿操作该值；如果你预览结果，你将看到右侧的值发生变化；左侧的值将始终保持为`0`，因为这是我们代码中`min`选项的默认值。
- en: Using the slider's event API
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滑块的事件API
- en: 'In addition to the options we saw earlier, there are another five options used
    to define functions that are executed at different times during a slider interaction.
    Any callback functions that we use are automatically passed the standard event
    object, and an object representing the slider. The following table lists the event
    options we can use:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前看到的选项外，还有另外五个选项用于定义在滑块交互期间不同时间执行的函数。我们使用的任何回调函数都会自动传递标准事件对象和表示滑块的对象。以下表格列出了我们可以使用的事件选项：
- en: '| Event | Fired when… |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 触发时… |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `change` | The slider''s handle stops moving and its value has changed. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `change` | 滑块的手柄停止移动并且其值已更改。 |'
- en: '| `create` | The slider is created |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 滑块已创建 |'
- en: '| `slide` | The slider''s handle moves. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `slide` | 滑块的手柄移动。 |'
- en: '| `start` | The slider''s handle starts moving. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `start` | 滑块的手柄开始移动。 |'
- en: '| `stop` | The slider''s handle stops moving. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `stop` | 滑块的手柄停止移动。 |'
- en: 'Hooking into these built-in callback functions is easy. Let''s put a basic
    example together to see. Change the configuration object in `slider10.html` so
    that it appears as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到这些内置的回调函数很容易。让我们组合一个基本示例来看看。将`slider10.html`中的配置对象更改为如下所示：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save this file as `slider11.html`. We use two of the callback options in this
    example—`start` and `change`. In the `start` function, we select the tooltip element
    if it exists, and fade it out with jQuery's `fadeOut()` method. Once hidden from
    view, it is removed from the page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider11.html`。在这个例子中，我们使用了两个回调选项——`start`和`change`。在`start`函数中，如果存在，我们选择提示工具元素，并使用jQuery的`fadeOut()`方法将其淡出。一旦从视图中隐藏，它将从页面中移除。
- en: The `change` function will be executed each time the value of the slider handle
    changes; when the function is called, we create the tool tip and append it to
    the slider. We position it so that it appears above the center of the slider handle
    and give it some of the framework class names in order to style it with the theme
    in use.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每次滑块手柄的值更改时都将执行`change`函数；当调用该函数时，我们创建工具提示并将其附加到滑块上。我们将其定位，使其出现在滑块手柄的中心上方，并给它一些框架类名称，以便根据使用的主题对其进行样式化。
- en: In several places we use the second object passed to the callback function,
    the prepared `ui` object that contains useful information from the slider. In
    this example, we use the `value` option of the object to obtain the new value
    of the slider handle.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个地方，我们使用传递给回调函数的第二个对象，即包含滑块有用信息的准备好的`ui`对象。在这个例子中，我们使用对象的`value`选项来获取滑块手柄的新值。
- en: 'We also need a very small custom stylesheet for this example. In your text
    editor, add the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们还需要一个非常小的自定义样式表。在文本编辑器中，添加以下代码：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Save this file as `sliderTheme2.css` in the `css` folder and add a link to
    it from the `<head>` of `slider11.html`. When displayed, our tool tip should appear
    as shown in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`css`文件夹中的`sliderTheme2.css`，并从`slider11.html`的`<head>`中添加一个链接。当显示时，我们的工具提示应该如下图所示：
- en: '![Using the slider''s event API](img/2209OS_06_06.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![使用滑块的事件 API](img/2209OS_06_06.jpg)'
- en: 'When all of the event options are used together, the events will be fired in
    the following order:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有事件选项一起使用时，事件将按以下顺序触发：
- en: '`create`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`'
- en: '`start`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`'
- en: '`slide`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slide`'
- en: '`stop`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`'
- en: '`change`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change`'
- en: The `slide` callback can be quite an intensive event as it is fired on every
    mouse movewhile the handle is selected, but it can also be used to prevent a slide
    in certain situations by returning `false` from the callback function. When using
    the `stop` and `change` callbacks together, the `change` callback may override
    the `stop` callback.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`slide`回调可能是一个相当密集的事件，因为它在每次选择手柄时都会触发鼠标移动，但它也可以通过从回调函数返回`false`来防止在某些情况下滑动。当同时使用`stop`和`change`回调时，`change`回调可能会覆盖`stop`回调。'
- en: As with all library components each of these events can also be used with the
    jQuery's `on()` method by prefixing the word `slider` to the event name, for example,
    `sliderstart`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与库中的所有组件一样，每个事件也可以在jQuery的`on()`方法中使用，只需在事件名前加上`slider`一词即可，例如，`sliderstart`。
- en: Using slider methods
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用滑块方法
- en: 'The slider is intuitive, and like the other components in the library it comes
    with a range of methods that are used to programmatically control the widget after
    it has been initialized. The methods specific to the slider are shown in the following
    table:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块很直观，与库中的其他组件一样，它还配备了一系列方法，用于在初始化后以编程方式控制小部件。滑块特有的方法显示在下表中：
- en: '| Method | Usage |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用法 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `value` | Sets a single slider handle to a new value. This will move the
    handle to the new position on the track automatically. This method accepts a single
    argument which is an integer representing the new value. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `value` | 将单个滑块手柄设置为新值。这将自动将手柄移动到轨道上的新位置。此方法接受一个参数，即表示新值的整数。'
- en: '| `values` | Sets the specified handle to move to a new value when multiple
    handles are in use. This method is the same as the value method, except that it
    takes two arguments—the index number of the handle followed by the new value.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `values` | 当使用多个手柄时，设置指定手柄移动到新值。此方法与`value`方法相同，只是它接受两个参数——手柄的索引号，后跟新值。'
- en: The `destroy`, `disable`, `enable`, `option`, and `widget` methods are common
    to all components, and work in the same way with a slider that we would expect
    them to.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy`、`disable`、`enable`、`option`和`widget`方法对所有组件都是通用的，并且与我们期望的滑块的方式相同地工作。'
- en: As we saw earlier in this chapter, the `value` and `values` methods are exclusive
    to the slider, and can be used to get or set the value of single or multiple handles.
    Of course, we can also do this using the `option` method, so these two methods
    are merely shortcuts to cater for common implementation requirements. Let's take
    a look at them in action. First of all let's see how the `value` method can be
    used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章早些时候看到的，`value`和`values`方法是专门针对滑块的，并且可以用于获取或设置单个或多个手柄的值。当然，我们也可以使用`option`方法来实现这一点，所以这两种方法只是为了满足常见的实现需求而设置的快捷方式。让我们看看它们的作用。首先让我们看看`value`方法如何使用。
- en: 'In `slider11.html`, remove the `<link>` to `sliderTheme2.css` and add a new
    `<button>` element to the page, directly after the slider container:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`slider11.html`中，删除对`sliderTheme2.css`的`<link>`并在页面上的滑块容器后直接添加一个新的`<button>`元素：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, change the final `<script>` element so that it is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更改最终的`<script>`元素，使其如下所示：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Save this file as `slider12.html`. We add a click handler for our new `<button>`;
    whenever it is clicked, this method will first determine what the maximum value
    for the slider is, by setting a variable to the result of the `option` method,
    specifying `max` as the option we'd like to get. Once we have the maximum value,
    we then call the `value` method, passing in the variable that holds the maximum
    value as the second argument; our variable will be used as the new value. Whenever
    the button is clicked, the slider handle will instantly move to the end of the
    track.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider12.html`。我们为新的`<button>`添加了一个点击处理程序；每当它被点击时，此方法将首先确定滑块的最大值，方法是通过将一个变量设置为`option`方法的结果来指定我们想要获取的选项为`max`。一旦我们有了最大值，然后我们调用`value`方法，传入包含最大值的变量作为第二个参数；我们的变量将被用作新值。每当按钮被点击时，滑块手柄将立即移动到轨道的末端。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Using value as an option or method**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**将值作为选项或方法使用**'
- en: In a number of examples throughout this chapter, we've made reference to `value`
    (or `values`) as an option or method. This can be a little confusing; think of
    `value's` method as being a shortcut for using the value option as a getter in
    your code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的许多示例中，我们提到了`value`（或`values`）作为选项或方法。这可能有点令人困惑；把`value`方法看作是在代码中使用值选项作为getter的快捷方式。
- en: Working with multiple handles is just as easy but involves a slightly different
    approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个手柄同样简单，但涉及略有不同的方法。
- en: 'Remove the `setMax` button in `slider12.html` and add the following two buttons
    directly after the slider element:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`slider12.html`中删除`setMax`按钮，并直接在滑块元素后添加以下两个按钮：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now change the final `<script>` element at the end of the `<head>` to the following
    code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`<head>`末尾的最后一个`<script>`元素更改为以下代码：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Save this file as `slider13.html`. To trigger multiple handles, we specify the
    values of two handles in our configuration object. When either of the two `<button>`
    elements on the page are clicked, we work out whether **Preset 1** or **Preset
    2** was clicked and then set the handles to either low values or high values,
    depending on which button was clicked.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider13.html`。要触发多个手柄，我们在配置对象中指定了两个手柄的值。当页面上的两个`<button>`元素中的任何一个被点击时，我们会确定是单击了**预设1**还是**预设2**，然后根据点击的按钮设置手柄为低值或高值。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can also use the array notation method for setting the values in a slider;
    this will set the same value for all the handles, irrespective of how many are
    present.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用数组表示法来设置滑块中的值；这将为所有手柄设置相同的值，而不管存在多少手柄。
- en: 'The `values` method takes two arguments. The first argument is the index number
    of the handle we''d like to change, and the second argument is the value that
    we''d like the handle to be set to. The following screenshot shows how the page
    should appear after the second button is clicked:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`values`方法接受两个参数。第一个参数是我们想要更改的手柄的索引号，第二个参数是我们希望手柄设置的值。以下截图显示了在单击第二个按钮后页面应该显示的样子：'
- en: '![Using slider methods](img/2209OS_06_07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用滑块方法](img/2209OS_06_07.jpg)'
- en: Practical uses
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际用途
- en: An HTML5 element that may lend itself particularly well to implementations of
    the slider widget is the `<audio>` element. This element will automatically add
    controls that enable the visitor to play, pause, and adjust the volume of the
    media being played.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5元素可能特别适合滑块小部件的实现是`<audio>`元素。此元素将自动添加控件，使访问者可以播放、暂停和调整正在播放的媒体的音量。
- en: The default controls, however, cannot be styled; if we wish to change their
    appearance, we need to create our own controls. A slider widget, of course, makes
    an excellent substitution for the default volume control. Let's take a look at
    how you can add one, as a basis that you can take further in your own projects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，默认控件无法进行样式化；如果我们希望改变它们的外观，就需要创建我们自己的控件。当然，滑块小部件是默认音量控制的绝佳替代品。让我们看看如何添加一个，作为你自己项目的基础，你可以在其中进一步发展。
- en: 'Create the following new code in your text editor:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中创建以下新代码：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Save this file as `slider14.html`. We also need to add a couple of styles to
    tweak the display. In a new page in your text editor, add the following, and save
    it as `sliderTheme3.css`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider14.html`。我们还需要添加一些样式来调整显示。在文本编辑器中的新页面中添加以下内容，并将其保存为`sliderTheme3.css`：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Don''t forget to add a link to `sliderTheme3.css` from your main page:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记从主页添加到`sliderTheme3.css`的链接：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On the `slider14.html` page, we have the `<audio>` tag that has its `src` attribute
    set to an audio clip available from the Internet Archive. We also have the empty
    container element for our volume control.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`slider14.html`页面上，我们有一个`<audio>`标记，其`src`属性设置为来自互联网档案馆的音频剪辑。我们还有一个空的容器元素用于我们的音量控制。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example uses one of the music soundtrack files created by Jan Morgenstern
    for the Big Bunny Movie; you can download it, and others in the collection at
    [https://archive.org/details/JanMorgenstern-BigBuckBunny](https://archive.org/details/JanMorgenstern-BigBuckBunny).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了 Jan Morgenstern 为大兔子电影创建的音乐配乐文件之一；你可以在 [https://archive.org/details/JanMorgenstern-BigBuckBunny](https://archive.org/details/JanMorgenstern-BigBuckBunny)
    下载它以及收藏中的其他文件。
- en: In the script, we first select the `<audio>` element using the standard jQuery
    syntax and retrieve the actual DOM element from the jQuery object, so that we
    can call methods from the `<audio>` API.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们首先使用标准的 jQuery 语法选择`<audio>`元素，并从 jQuery 对象中检索实际的 DOM 元素，以便我们可以从`<audio>`API中调用方法。
- en: Next, we define the configuration object for our slider and set the initial
    minimum and maximum values. We then add a handler for the `change` event that
    is used to change the volume of the currently playing audio track, using the `volume`
    property method. Whenever the slider is changed, we get a new slider value and
    convert it to the required format for the `volume` property, by dividing the slider
    value by `10`. Once our variables are defined, we set the volume of the audio
    clip and begin playing the clip immediately with the `play()` method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的滑块定义配置对象并设置初始最小和最大值。然后，我们添加一个用于更改当前播放音轨音量的`change`事件处理程序，使用`volume`属性方法。每当滑块被更改时，我们都会得到一个新的滑块值，并将其转换为所需的`volume`属性格式，方法是将滑块值除以`10`。一旦我们的变量被定义，我们就设置音频剪辑的音量，并立即使用`play()`方法播放音频剪辑。
- en: 'When we run this example in a supporting browser, we can pause or play the
    audio clip; if the slider handle is moved, the volume of the clip should increase
    or decrease as shown in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在支持的浏览器中运行此示例时，我们可以暂停或播放音频剪辑；如果移动滑块手柄，则剪辑的音量应该增加或减少，如下图所示：
- en: '![Practical uses](img/2209OS_06_08.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![实际应用](img/2209OS_06_08.jpg)'
- en: Creating a color slider
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个颜色滑块
- en: 'A fun implementation of the slider widget, which can be very useful in certain
    applications, is the color slider. Let''s put what we''ve learned about this widget
    into practice to produce a basic color-choosing tool. The following screenshot
    shows the page that we''ll be making:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中非常有用的滑块小部件的有趣实现是颜色滑块。让我们将学到的关于此小部件的知识付诸实践，制作一个基本的颜色选择工具。以下屏幕截图显示了我们将要制作的页面：
- en: '![Creating a color slider](img/2209OS_06_09.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![创建颜色滑块](img/2209OS_06_09.jpg)'
- en: 'In your text editor, alter the `<body>` markup in `slider1.html` to the following
    code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中，将`slider1.html`中的`<body>`标记更改为以下代码：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s now add in the `script` functionality for our demo, so go ahead and
    remove the contents of the last `<script>` element, and add the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的演示添加`script`功能，所以请继续移除最后一个`<script>`元素的内容，并添加以下代码：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save this file as `slider15.html`. The page itself is simple enough. We've got
    some elements used primarily for displaying the different components of the color
    slider, as well as the individual container elements that will be transformed
    into slider widgets. We use three sliders for our color chooser, one for each
    RGB channel.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`slider15.html`。页面本身非常简单。我们有一些主要用于显示颜色滑块的不同组件的元素，以及将被转换为滑块小部件的各个容器元素。我们为我们的颜色选择器使用了三个滑块，每个滑块对应一个
    RGB 通道。
- en: 'We''ll need some CSS as well to complete the overall appearance of our widget.
    In a new page in your text editor, create the following stylesheet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些 CSS 来完善我们小部件的整体外观。在你的文本编辑器中新建一个页面，创建以下样式表：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save this file as `colorSliderTheme.css` in the `css` folder; don''t forget
    to add a link to this in your main file immediately after the call to the jQuery
    UI stylesheet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`colorSliderTheme.css`在`css`文件夹中；别忘了在主文件中调用 jQuery UI 样式表后立即添加对此文件的链接：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In our code, we give the container and color box elements class names from the
    CSS framework, so that we can take advantage of effects such as the rounded corners,
    so that we can cut down on the amount of CSS we need to write ourselves.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们给容器和颜色框元素分配了来自 CSS 框架的类名，这样我们就可以利用诸如圆角之类的效果，以减少我们自己编写的 CSS 量。
- en: Turning our attention to the JavaScript code, we first set the configuration
    object. As RGB color values range from `0` to `255`, we set the `max` option to
    `255` and the `value` option to `255` as well, so that the widget handles start
    in the correct location (the color box will have a white background on page load).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关注JavaScript代码，我们首先设置配置对象。由于RGB颜色值范围从`0`到`255`，我们将`max`选项设置为`255`，将`value`选项也设置为`255`，这样小部件手柄就会在正确的位置开始（页面加载时，颜色框将具有白色背景）。
- en: The `slide` callback is where the action happens. Every time a handle is moved,
    we update each of the `r`, `g`, and `b` variables, by using the `value` method,
    and then construct a new RGB string from the values of our variables. This is
    necessary as we can't pass the variables directly into jQuery's `css()` method.
    We also update the value in the `<input>` field.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`slide`回调是行动发生的地方。每当移动一个手柄时，我们都会使用`value`方法更新`r`、`g`和`b`变量的值，然后从我们的变量值构造一个新的RGB字符串。这是必要的，因为我们不能直接将变量传递给jQuery的`css()`方法。我们还会更新`<input>`字段中的值。'
- en: When we run the example, we should find that everything works as expected. As
    soon as we start moving any of the slider handles, the color box begins to change
    color and the `<input>` updates.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例时，我们应该发现一切都按预期工作。一旦我们开始移动任何一个滑块手柄，颜色框就开始变色，而`<input>`也会更新。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The slide event is fired on every mouse move as soon as the handle is selected;
    this is a potentially intensive event that may cause issues in older browsers
    or on slow computers. Care should therefore be taken when used in a production
    environment to keep any unnecessary actions in the event handler to a minimum.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`slide`事件在选定手柄后的每次鼠标移动时触发；这是一个潜在的密集型事件，在旧浏览器或慢速计算机上可能会引起问题。因此，在生产环境中使用时应谨慎，以使事件处理程序中的不必要操作最小化。'
- en: Introducing the progressbar widget
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入进度条小部件
- en: 'The widget is made up of just two nested `<div>` elements—an outer `<div>`
    container and an inner `<div>` container, which is used to highlight the current
    progress. The following diagram shows a progressbar that is 50 percent complete:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件只由两个嵌套的`<div>`元素组成——一个外部`<div>`容器和一个内部`<div>`容器，用于突出显示当前进度。下图显示了一个完成50%的进度条：
- en: '![Introducing the progressbar widget](img/2209OS_06_10.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![引入进度条小部件](img/2209OS_06_10.jpg)'
- en: 'Let''s take a look at the most basic progressbar implementation. In a new file
    in your text editor, create the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看最基本的进度条实现。在文本编辑器中的新文件中，创建以下代码：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Save this file as `progressbar1.html` in the `jqueryui` project folder. With
    no configuration, the progressbar is, of course, empty. Our example should appear
    like the first screenshot but without any progress displayed (the container is
    empty).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`jqueryui`项目文件夹中的`progressbar1.html`。没有配置时，进度条当然是空的。我们的示例应该看起来像第一张截图，但没有显示任何进度（容器为空）。
- en: 'The progress bar depends on the following components:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条依赖以下组件：
- en: '`jquery.ui.all.css`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.all.css`'
- en: '`jquery-2.0.3.js`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-2.0.3.js`'
- en: '`jquery-ui.core.js`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-ui.core.js`'
- en: '`jquery-ui.progressbar.js`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-ui.progressbar.js`'
- en: All we need on the page is a simple container element. In this case we've used
    a `<div>` element, but other block-level elements, such as a `<p>` for example,
    can also be used. The widget will add a nested `<div>` element to the specified
    container element at initialization that represents the value of the progressbar.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上所需的全部就是一个简单的容器元素。在这种情况下，我们使用了一个`<div>`元素，但是其他块级元素，比如`<p>`，也可以使用。小部件会在初始化时向指定的容器元素添加一个表示进度条值的嵌套`<div>`元素。
- en: This widget, like some of the other widgets, such as the accordion, will naturally
    fill the width of its container. Other widgets that also work in a similar way
    are tabs, accordion, slider, and menu—each of these equally need some form of
    container to restrict their size on screen. Both the container and the inner `<div>`
    element are given a series of attributes and class names by the component. The
    class names pick up styling from the `theme` file in use, and the component is
    fully ThemeRoller-ready. Being ThemeRoller-ready means that your chosen theme
    can easily be changed with another jQuery ThemeRoller theme, and that widgets
    will still function without any changes required to styling.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件与其他一些小部件（如手风琴）一样，会自然填满其容器的宽度。其他也以类似方式工作的小部件包括标签页、手风琴、滑块和菜单——每个都需要某种形式的容器来限制其在屏幕上的大小。组件会给容器和内部`<div>`元素分别添加一系列属性和类名。类名从正在使用的`theme`文件中获取样式，并且组件完全支持ThemeRoller。支持ThemeRoller意味着你选择的主题可以轻松地更改为另一个jQuery
    ThemeRoller主题，并且小部件将继续正常工作，无需对样式进行任何更改。
- en: 'The additional attributes added to the widget are ARIA compliant, making the
    widget fully accessible to visitors using assisted technologies. **ARIA** (**Accessible
    Rich Internet Applications**) defines ways of making web content more accessible
    to those with assistive technologies such as screen the readers. All jQuery widgets
    have varying levels of support for ARIA, including a progressbar; this is provided
    through the use of additional tags that appear in your code, such as these (highlighted
    in the following code):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到小部件的其他属性符合ARIA规范，使小部件对使用辅助技术的访问者完全可访问。**ARIA**（**Accessible Rich Internet
    Applications**）定义了使Web内容对使用辅助技术（如屏幕阅读器）的人更具可访问性的方法。所有jQuery小部件都对ARIA有不同程度的支持，包括进度条；这是通过在代码中出现其他标签来提供的，例如以下代码中突出显示的标签：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These help translate code into content that assistive technologies will understand;
    without them, the code is effectively hidden, which will affect what the end user
    will see or hear.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些帮助将代码转换为辅助技术将理解的内容；没有它们，代码实际上是隐藏的，这会影响最终用户将看到或听到的内容。
- en: Listing the progressbar's options
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出进度条的选项
- en: 'The progressbar has three configuration options at the time of writing:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 写作时，进度条有三个配置选项：
- en: '| Option | Default Value | Usage |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用法 |'
- en: '| --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `disabled` | `false` | Disable the widget |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | `false` | 禁用小部件 |'
- en: '| `Max` | `100` | The maximum value of the progressbar |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `Max` | `100` | 进度条的最大值 |'
- en: '| `Value` | `0` | Set the value (in percent) of the widget |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `Value` | `0` | 设置小部件的值（以百分比表示） |'
- en: Setting the progressbar's value
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置进度条的值
- en: 'Change the final `<script>` element in `progressbar1.html`, so that it appears
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`progressbar1.html`中的最终`<script>`元素，使其显示如下：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Save this file as `progressbar2.html`. The `value` option takes an integer and
    sets the width of the inner `<div>` of the widget to the corresponding percentage.
    This change will make the widget appear as it did in the first screenshot of this
    chapter, with the progressbar half-filled.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`progressbar2.html`。`value`选项接受一个整数，并将小部件的内部`<div>`的宽度设置为相应的百分比。此更改将使小部件显示为本章第一个屏幕截图中的样子，进度条填充了一半。
- en: The progressbar's event API
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进度条的事件API
- en: 'The progressbar exposes three custom events as shown in the following table:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条公开了三个自定义事件，如下表所示：
- en: '| Event | Fired when… |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 当...时触发 |'
- en: '| --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `create` | The widget is initialized |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 初始化小部件 |'
- en: '| `change` | The widget''s value changes |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `change` | 小部件的值更改 |'
- en: '| `complete` | The value of the widget reaches 100 percent |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `complete` | 小部件的值达到100％ |'
- en: As with the other widgets, we can supply an anonymous callback function as the
    value of these events in a configuration object, and the component will automatically
    call the function for us, each time the event fires.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他小部件一样，我们可以在配置对象中以匿名回调函数的形式提供这些事件的值，组件将自动为我们调用该函数，每次事件发生时。
- en: 'To see this event in action add the following `<button>` to the page in `progressbar2.html`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`progressbar2.html`页面中看到此事件的实际效果，请添加以下`<button>`：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, change the final `<script>` block to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将最终的`<script>`块更改为以下内容：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save this file as `progressbar3.html`. We also need to add some styling for
    our progressbar, so add the following to a new file, saving it as `progressIncrease.css`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`progressbar3.html`。我们还需要为我们的进度条添加一些样式，因此请添加以下内容到一个新文件，并将其保存为`progressIncrease.css`：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Don''t forget to add a link to the new stylesheet from the `<head>` of our
    page (after the link to the standard jQuery UI stylesheet):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记从页面的`<head>`中添加链接到新样式表（在标准jQuery UI样式表之后）：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our example, we first cache the selector for the progressbar, then define
    an event handler for the `change` event. Within this callback function, we first
    obtain the current value of the progressbar, which will correspond to the value
    after its last update. We can select the progressbar using `$(this)`when inside
    the event handler.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们首先缓存了进度条的选择器，然后为`change`事件定义了一个事件处理程序。在这个回调函数中，我们首先获取进度条的当前值，这个值将对应于其上次更新后的值。当在事件处理程序内部时，我们可以使用`$(this)`选择进度条。
- en: Provided the value is less than or equal to 100 (percent), we check whether
    there is already an element with an `id` of `value` on the page. If the element
    doesn't exist (that is, its value has no length), we create a new `<span>` element
    and set its text to the current value. We also give it an `id` attribute and position
    it, so that it appears inside the progressbar. If the element already exists,
    we just update its text to the new value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 假设值小于或等于100（百分比），我们检查页面上是否已经存在具有`id`为`value`的元素。如果元素不存在（即其值没有长度），我们创建一个新的`<span>`元素，并将其文本设置为当前值。我们还给它一个`id`属性并将其定位，以便它出现在进度条内。如果元素已经存在，我们只需将其文本更新为新值。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Use of self-closing shortcut tag selectors**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用自关闭快捷标签选择器**'
- en: You may have seen the use of `$("<span />")` in the code; this is a shortcut
    that jQuery uses to produce the full version of the tags; in this instance, it
    would encapsulate any content it is passed within `<span>`…`</span>` tags.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在代码中看到了`$("<span />")`的使用；这是jQuery用于生成标签的完整版本的快捷方式；在这种情况下，它会将其传递的任何内容封装在`<span>`…`</span>`标签中。
- en: We also add a click-handler for the button that we added to the page. Whenever
    the button is clicked, we first get the current value of the progressbar by using
    the `option` method in `getter` mode. We then add `10` to the value before using
    the `option` method in `setter` mode to increase the value of the inner `<div>`
    by `10` percent. The value is added to a `<span>` element to indicate the progress.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为页面上添加的按钮添加了点击处理程序。每当按钮被点击时，我们首先使用`getter`模式中的`option`方法获取进度条的当前值。然后，在将值增加`10`之后，我们使用`setter`模式中的`option`方法将内部`<div>`的值增加`10`个百分点。将该值添加到`<span>`元素中以指示进度。
- en: 'The following screenshot shows the result of clicking on the button:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮的结果如下所示：
- en: '![The progressbar''s event API](img/2209OS_06_11.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![进度条事件API](img/2209OS_06_11.jpg)'
- en: In this example, we set the value of the progressbar manually whenever the **Increase
    by 10%** button is clicked; we use the standard `option` method, common to all
    UI library components, to retrieve information about the current state of the
    progressbar.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，每当**增加10%**按钮被点击时，我们都手动设置进度条的值；我们使用标准的`option`方法，该方法适用于所有UI库组件，以检索有关进度条当前状态的信息。
- en: Don't forget that like the other library components, this event can be used
    with jQuery's `on()` method by prefixing the name of the widget onto the event
    name, for example, `progressbarchange`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，像其他库组件一样，此事件也可以通过在事件名称上添加小部件名称前缀来使用jQuery的`on()`方法，例如，`progressbarchange`。
- en: Using progressbar methods
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用进度条方法
- en: In addition to the common API methods that are exposed by all library components,
    such as `destroy`, `disable`, `enable`, `widget`, and `option`, the slider API
    also exposes the `value` method, which is a shortcut for using the `option` method
    to set the value of the progressbar.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有库组件都公开的常见API方法（如`destroy`、`disable`、`enable`、`widget`和`option`）之外，滑块API还公开了`value`方法，该方法是使用`option`方法设置进度条值的快捷方式。
- en: 'We can do exactly the same as we did in the last example, but with less code,
    using the `value` method. Change the final `<script>` element in `progressbar3.html`,
    so that it is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以完全像上一个示例中所做的那样，但代码更少，使用`value`方法。更改`progressbar3.html`中的最后一个`<script>`元素，使其如下所示：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save this file as `progressbar4.html`. We lose the configuration object in this
    example, as it isn't required.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`progressbar4.html`。在这个例子中，我们丢失了配置对象，因为它不是必需的。
- en: The logic for increasing the value using the `value` method has been moved into
    the click handler for the `<button>` element. Within the event handler, we get
    the value of `currentVal`, then add `10` to it, and assign that to `newVal`. The
    `value` attribute of the progressbar widget is updated with the new value; a check
    is performed to see if the percentage count text exists. If it doesn't (that is,
    the length of `#value` is zero), then we add a new instance, with the updated
    figure and display this on screen.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`value`方法增加值的逻辑已经移到了`<button>`元素的点击处理程序中。在事件处理程序中，我们获取`currentVal`的值，然后加上`10`，并将其赋值给`newVal`。进度条小部件的`value`属性被更新为新值；进行检查以查看百分比计数文本是否存在。如果不存在（即`#value`的长度为零），则我们添加一个新的实例，其中包含更新后的数字，并在屏幕上显示此数字。
- en: You will notice though, with the move of the update code into the event handler,
    that this has allowed us to perform the same action as in the previous example,
    but in a more concise format.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但随着更新代码移动到事件处理程序中，我们看到这使我们能够以更简洁的格式执行与上一个示例相同的操作。
- en: Adding indeterminate support
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加不定支持
- en: So far, we've looked at how you can control the percentage value that a progressbar
    should use, when updating its results. However, there may be instances where this
    isn't always possible—to allow for this, an indeterminate option can be used.
    Added in jQuery UI 1.10, this allows for those instances where the value can't
    be updated, as the final value is not known.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了在更新其结果时如何控制进度条应该使用的百分比值。但是，在某些情况下可能无法始终这样做 - 为了解决这个问题，可以使用一个不定选项。在jQuery
    UI 1.10中添加了这个选项，它允许在不能更新值的情况下使用。这是一个示例，如下图所示：
- en: 'Let''s take a look at a couple of examples to compare the difference between
    setting a known value and an indeterminate one. In `progressbar4.html`, change
    the `<script>` element to the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子来比较设置已知值和不确定值之间的差异。在`progressbar4.html`中，将`<script>`元素更改为以下代码：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `<body>` element of the code, alter the HTML to the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的`<body>`元素中，将HTML更改为以下代码：
- en: '[PRE38]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Save this file as `progressbar5.html`. The following screenshot shows the results
    of clicking on the **Indeterminate** button:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件另存为`progressbar5.html`。点击**不定**按钮的结果如下截图所示：
- en: '![Adding indeterminate support](img/2209OS_06_12.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![添加不定支持](img/2209OS_06_12.jpg)'
- en: Although it's hard to see it in action in print, the previous example shows
    a continually moving progressbar at 100 percent; clicking on the **Indeterminate**
    button sets the value attribute to `false`, which tells the progressbar to assume
    100 percent as the value. The automatic setting to 100 percent in this instance
    is an indicator that we are making progress. As we are unable to get an accurate
    figure for how much progress has been made at each point, the progressbar widget
    automatically assumes that the value is 100 percent.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在纸质版本中很难看到它的实际效果，但上一个例子显示了一个持续移动的进度条达到100%，点击**不定**按钮会将`value`属性设置为`false`，告诉进度条假定值为100%。在这种情况下，自动设置为100%，表示我们正在取得进展。由于我们无法准确地得出在每个点上取得了多少进展，进度条小部件会自动假定该值为100%。
- en: 'In comparison, if we know the value that the progressbar should use, we can
    set that value instead. Clicking on the **Random Value - Determinate** button
    shows the effect of setting such a value as shown in the following screenshot,
    in a similar fashion to previous examples throughout this chapter:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们知道进度条应该使用的值，我们可以设置该值。点击**随机值 - 确定**按钮，在本章的示例中以类似的方式显示设置这样一个值的效果，如下截图所示：
- en: '![Adding indeterminate support](img/2209OS_06_13.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![添加不定支持](img/2209OS_06_13.jpg)'
- en: Responding to user interaction
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应用户交互
- en: 'At its most basic level, we can manually update the progressbar in response
    to user interaction. For example, we could specify a wizard-style form, which
    has several steps to complete. In this example, we''ll create a form as shown
    in the following screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的层面上，我们可以在响应用户交互时手动更新进度条。例如，我们可以指定一种向导式表单，其中有几个步骤要完成。在这个示例中，我们将创建一个如下截图所示的表单：
- en: '![Responding to user interaction](img/2209OS_06_14.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![响应用户交互](img/2209OS_06_14.jpg)'
- en: 'During each step, we can increment the progressbar manually to let the user
    know how far through the process they are. In `progressbar5.html`, replace the
    progressbar container and buttons with the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤期间，我们可以手动递增进度条，以让用户知道他们进行到了多远的进程。在 `progressbar5.html` 中，用以下代码替换进度条容器和按钮：
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Save this file as `progressbar6.html`. In the `<head>` section, we add a link
    to the framework theme files, as we have done with the other examples in this
    chapter, and will need to add a link to a custom stylesheet that we''ll add in
    a moment:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `progressbar6.html`。在 `<head>` 部分，我们添加了一个链接到框架主题文件，就像我们在本章的其他示例中所做的那样，并且将需要添加一个链接到稍后添加的自定义样式表：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `<body>` element of the page contains a few layout elements and some text
    nodes, but the main elements are the container for the progressbar and the `<form>`.
    The `<form>` section is separated into several different sections using the `<div>`
    and `<fieldset>` elements. The reason for this is that we can hide the parts of
    the form to make it appear as if it spans several pages.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的 `<body>` 元素包含一些布局元素和一些文本节点，但主要元素是进度条的容器和 `<form>`。`<form>` 部分使用 `<div>`
    和 `<fieldset>` 元素分隔为几个不同的部分。这样做的原因是我们可以隐藏表单的部分，使其看起来好像跨越了几个页面。
- en: We've added a paragraph and a `<label>` parameter next to the progressbar. We'll
    position these so that they appear inside the widget. The paragraph contains a
    simple text string. The label will be used to show the current progress value.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进度条旁边添加了一个段落和一个 `<label>` 参数。我们将对它们进行定位，使它们出现在小部件内部。段落包含一个简单的文本字符串。标签将用于显示当前进度值。
- en: The outer container is given several class names; the first is that we can apply
    some custom styling to the element, but the next two are to target different features
    of the jQuery UI CSS framework. The `ui-helper-clearfix` class is used to automatically
    clear floated elements and is a great way of reducing the clutter of additional
    and unnecessary clearing of the `<div>` elements. Don't forget to make explicit
    use of this and other framework classes when creating your own widgets.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 外部容器被赋予几个类名；第一个是我们可以对元素应用一些自定义样式，但下一个两个是为了针对 jQuery UI CSS 框架的不同特性。`ui-helper-clearfix`
    类用于自动清除浮动元素，并且是减少 `<div>` 元素的额外和不必要的清除混乱的好方法。在创建自己的小部件时，请不要忘记显式使用此类和其他框架类。
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We covered some of the core CSS classes back in [Chapter 2](ch02.html "Chapter 2. The
    CSS Framework and Other Utilities"), *The CSS Framework and Other Utilities*;
    more details of the CSS framework API are available at [http://learn.jquery.com/jquery-ui/theming/api/](http://learn.jquery.com/jquery-ui/theming/api/).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第二章](ch02.html "第二章。CSS 框架和其他实用工具")中介绍了一些核心 CSS 类；CSS 框架 API 的更多详细信息可在[http://learn.jquery.com/jquery-ui/theming/api/](http://learn.jquery.com/jquery-ui/theming/api/)上找到。
- en: The `ui-corner-all` class is used to give the container element (as well as
    the progressbar itself, which has them automatically, and our `<fieldset>` elements)
    rounded corners, using several proprietary style rules. These are now supported
    by most modern browsers. We also have a **Next** button to move forward through
    each panel, and a **Back** button that is disabled by default.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui-corner-all` 类用于给容器元素（以及进度条本身，它们自动具有这些特性，以及我们的 `<fieldset>` 元素）添加圆角，使用了几个专有的样式规则。这些现在被大多数现代浏览器支持。我们还有一个**下一个**按钮来在每个面板之间前进，并且一个默认情况下被禁用的**返回**按钮。'
- en: 'We use another class from the CSS framework within the form. Several panels
    need to be hidden when the page first loads; we can therefore make use of the
    `ui-helper-hidden` class to ensure that they are set to `display: none`. When
    we want to show them, all we have to do is remove this class name.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在表单中使用 CSS 框架的另一个类。页面首次加载时需要隐藏多个面板；因此，我们可以使用 `ui-helper-hidden` 类来确保它们设置为
    `display: none`。当我们想要显示它们时，我们只需删除此类名。'
- en: 'Now let''s add the JavaScript. Change the final `<script>` element at the bottom
    of the page, so that it appears as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加 JavaScript。更改页面底部的最后一个 `<script>` 元素，使其显示如下：
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We first cache a selector for the progressbar and define our configuration object,
    making use of the `change` event to specify an anonymous callback function. Each
    time the event is fired we'll grab the current value of the progressbar using
    the `value` method, and set it as the text of the `<label>` parameter directly
    after the progressbar element. The event is fired after the change takes place,
    so the value we obtain will always be the new value.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先缓存进度条的选择器，并定义我们的配置对象，利用`change`事件来指定一个匿名回调函数。每次事件被触发时，我们将使用`value`方法获取进度条的当前值，并将其设置为直接在进度条元素之后的`<label>`参数的文本。事件在更改发生后触发，因此我们获得的值将始终是新值。
- en: Once the progressbar is initialized, we add a click handler for the buttons
    after the form. Within this handler function, we first disable both of the buttons
    to prevent the form from breaking if a `<button>` is repeatedly clicked. We then
    use an `if` statement to run the slightly different code branches, depending on
    the button that was clicked.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进度条被初始化，我们为表单后的按钮添加一个点击处理程序。在此处理程序函数内，我们首先禁用两个按钮，以防止重复点击`<button>`导致表单破坏。然后，我们使用`if`语句运行稍微不同的代码分支，具体取决于所点击的按钮。
- en: If the **Next** button was clicked, we increase the value of the progressbar
    by `50` percent by setting the `value` option to the current value plus `50` percent.
    We then fade out the currently visible panel and fade in the next panel. We use
    a callback function as an argument to the `fadeIn()` method, which will be executed
    once the animation ends.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击了**下一步**按钮，则通过将`value`选项设置为当前值加上`50`％来将进度条的值增加`50`％。然后，我们淡出当前可见的面板，并淡入下一个面板。我们使用回调函数作为`fadeIn()`方法的参数，该函数将在动画结束时执行。
- en: Within this function, we re-enable the **Back** button (as it was **Next** that
    was clicked, it is not possible for the first panel to be visible, and so this
    button should be enabled) and determine whether to enable the **Next** button,
    which can be done, provided the last panel is not visible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在此功能内，我们重新启用**返回**按钮（因为点击了**下一步**，所以第一个面板不可见，因此应该启用此按钮），并确定是否启用**下一步**按钮，只要最后一个面板不可见，就可以完成此操作。
- en: The second branch of the outer `if` statement deals with the **Back** button
    being clicked. In this case, we reduce the progressbar by `50` percent, enable
    the **Next** button, and check whether the **Back** button should be enabled.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 外部`if`语句的第二个分支处理了点击**返回**按钮的情况。在这种情况下，我们将进度条减少`50`％，启用**下一步**按钮，并检查是否应启用**返回**按钮。
- en: 'This is now all of the JavaScript that we''ll need. All we have to do now is
    add some basic CSS to lay the example out; in a new file in your text editor add
    the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在是我们所需的所有 JavaScript 代码。现在我们所要做的就是添加一些基本的 CSS 来布置示例；在文本编辑器中的新文件中添加以下代码：
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Save this as `progressTheme.css` in the `css` directory. We should now have
    a working page with a wired-up progressbar. When we run the page, we should find
    that we can navigate through each panel of the form, and the progressbar will
    update itself accordingly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 `progressTheme.css` 在 `css` 目录中。现在，我们应该有一个带有已连接的进度条的工作页面。当我们运行页面时，我们应该发现我们可以浏览表单的每个面板，并且进度条将相应地更新自身。
- en: We're still relying on user interaction to set the value of the progressbar
    in this example, which is driven by the visitor navigating through each of the
    panels.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然依赖用户交互来设置进度条的值，在这个示例中，这是由访问者通过每个面板进行导航驱动的。
- en: Implementing rich uploads with a progressbar
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有进度条的丰富上传
- en: Instead of relying on user interaction to increase the value of the progressbar
    and therefore the completion of the specified task, we can instead rely on the
    system to update it, as long as something is available that can be used to update
    it accurately.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 不再依赖用户交互来增加进度条的值，从而完成指定的任务，我们可以依赖系统来更新它，只要有可用的东西可以准确地更新它。
- en: In our final progressbar example, we can incorporate the HTML5 file API, in
    order to upload a file asynchronously, and can use the `onprogress` event to update
    the progressbar, while the file is uploading.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最终的进度条示例中，我们可以整合 HTML5 文件 API，以便异步上传文件，并可以使用`onprogress`事件来在文件上传时更新进度条。
- en: Tip
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At this point, you may like to obtain a copy of the code download that accompanies
    this book, so that you can work through the code at the same time as you study
    the example.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能想获取伴随本书的代码下载副本，以便您可以在学习示例的同时查看代码。
- en: This example will only work correctly using a full web server with PHP installed
    and configured. We won't be looking at the server-side part of the upload process
    in this example; we're not interested in what happens to the file once it's been
    uploaded, only in updating the progressbar based on feedback received from the
    system, while it is uploading.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例只有在安装了并配置了 PHP 的完整 Web 服务器时才能正常工作。在这个示例中，我们不会查看上传过程的服务器端部分；我们只对一旦上传完成，根据从系统收到的反馈来更新进度条感兴趣。
- en: 'Change the `<body>` in `progressbar6.html`, so that it contains the following
    elements:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`progressbar6.html`中的`<body>`，使其包含以下元素：
- en: '[PRE43]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'On the page, we have an `<input>` element of the `file` type, followed by the
    container for the progressbar as usual. Next, let''s add the script; change the
    final `<script>` element at the end of `<head>` to the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上，我们有一个`file`类型的`<input>`元素，后面跟着进度条的容器，就像往常一样。接下来，让我们添加脚本；将`<head>`末尾的最后一个`<script>`元素更改为以下代码：
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save this file as `progressbar7.html`. Add the following code to a new document,
    and save it as `uploads.js`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`progressbar7.html`。将以下代码添加到一个新文档中，并保存为`uploads.js`：
- en: '[PRE45]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, add the following immediately below the links to jQuery UI in the
    `<head>` element of your document:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在文档的`<head>`元素下方立即添加以下内容：
- en: '[PRE46]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First of all, in `progressbar7.html` we perform a check to confirm if the browser
    supports the File API; if it can, then we instigate an event handler that fires
    as soon as the `fileselect` button is clicked.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`progressbar7.html`中，我们进行检查以确认浏览器是否支持 File API；如果可以，我们就会启动一个事件处理程序，该处理程序会在点击`fileselect`按钮时立即触发。
- en: Within the change handler, we get details of the files selected and save them
    to an array; we then call out to the `ParseFile()` function (in `uploads.js`)
    to first initiate the output messages, then to load and read a copy of the image
    using `FileReader()`, and output a copy of the image to screen. At the same time,
    we display details of the image name.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改处理程序中，我们获取所选文件的详细信息并将其保存到数组中；然后，我们调用`ParseFile()`函数（在`uploads.js`中）来首先启动输出消息，然后使用`FileReader()`加载和读取图像的副本，并将图像的副本输出到屏幕。同时，我们显示图像名称的详细信息。
- en: Moving on to `uploads.js`, we then shell out to the `UploadFile` function, which
    is where the real magic happens. We begin by initiating an instance of the progressbar,
    give it the `progress` ID, and using a `<div>` element as its container. The code
    then sets up an instance of `XMLHttpRequest()` and opens a `POST` connection in
    order to upload the file. In this instance, the file is actually only uploaded
    to a test folder on the server (or in this case, your PC), called uploads; it's
    at this point where you would create an upload script that would redirect the
    file to the appropriate location on the remote server.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 继续到`uploads.js`，然后我们调用`UploadFile`函数，这就是真正的魔法发生的地方。我们首先初始化一个进度条的实例，给它一个`progress`
    ID，并使用一个`<div>`元素作为其容器。然后，代码设置了一个`XMLHttpRequest()`的实例，并打开了一个`POST`连接以上传文件。在这种情况下，文件实际上只上传到服务器上的一个测试文件夹（或在这种情况下，您的个人电脑上），称为
    uploads；在这一点上，您将创建一个上传脚本，该脚本将把文件重定向到远程服务器上的适当位置。
- en: Each time the `XMLHttpRequest` parameter is updated, it fires the `onprogress`
    event handler to update the progressbar; we calculate the difference between the
    total file size and the uploaded content, then convert it to a percentage and
    use this to update the progressbar. Once the upload is completed, we fire the
    `onload()` event handler to ensure it shows 100 percent completion.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`XMLHttpRequest`参数更新时，它都会触发`onprogress`事件处理程序来更新进度条；我们计算总文件大小与已上传内容之间的差异，然后将其转换为百分比，并用此百分比来更新进度条。一旦上传完成，我们就会触发`onload()`事件处理程序，以确保它显示
    100% 完成。
- en: 'We also need a bit of CSS for this example; in a new text file add the following
    code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们还需要一些 CSS；在一个新的文本文件中添加以下代码：
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This file can be saved in the `css` folder as `uploads.css`. Mostly the styles
    just position the various elements and set the width of the progressbar. We also
    don't need the link to `progressTheme.css`, so this can be removed as well.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件可以保存在`css`文件夹中，命名为`uploads.css`。大部分样式只是定位各个元素并设置进度条的宽度。我们也不需要链接到`progressTheme.css`，因此也可以将其删除。
- en: When we run this file, we should see that once a file has been selected, it
    will automatically begin to upload, and the progressbar will begin to fill up.
    If testing locally, it will be pretty quick, so it's best tested with reasonably
    large files.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个文件时，我们应该看到一旦选择了文件，它就会自动开始上传，并且进度条将开始填充。如果在本地进行测试，速度会相当快，所以最好使用相当大的文件进行测试。
- en: 'The following screenshot shows the page once the upload has completed:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了上传完成后的页面：
- en: '![Implementing rich uploads with a progressbar](img/2209OS_06_15.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![使用进度条实现丰富上传](img/2209OS_06_15.jpg)'
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've looked at two interface widgets that can both provide
    some form of visual feedback, either as result of an operation, or to set a particular
    value. We saw how quickly and easily it can put a slider widget on the page, and
    that it requires minimal underlying markup and just a single line of code to initialize.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了两个界面小部件，它们都可以提供某种形式的视觉反馈，无论是作为操作的结果还是设置特定的值。我们看到了如何快速、简单地将滑块小部件放在页面上，并且它需要最少的底层标记和仅一行代码来初始化。
- en: We explored the different options that we can set, to control how the slider
    behaves and how it is configured once it's initialized, while providing callbacks
    that can be used to execute code at important times during an interaction. We
    also covered the range of methods that can be used to programmatically interact
    with the slider, including methods for setting the value of the handle(s), or
    getting and setting configuration options after initialization.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了可以设置的不同选项，以控制滑块的行为以及在初始化后如何配置它，同时提供可以在交互期间的重要时间执行代码的回调。我们还介绍了可以用于以编程方式与滑块进行交互的方法，包括用于设置手柄值的方法，或在初始化后获取和设置配置选项的方法。
- en: We also looked at the progressbar widget with a compact API that provides essential
    visitor feedback when processes are in progress. We then looked into the various
    options that can be used to configure the widget, prior to initialization, or
    once the widget is in use. We also examined the methods available for working
    with the progressbar widget, to see how we can easily react to changes in progress,
    or once the widget has completed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了具有紧凑 API 的进度条小部件，它在进程进行时提供了必要的访问者反馈。然后我们研究了在初始化之前或小部件正在使用时可以用来配置小部件的各种选项。我们还研究了可用于与进度条小部件一起工作的方法，看看我们如何可以轻松地对进度更改做出反应，或者在小部件完成后做出反应。
- en: We also looked at how the progressbar includes support for an indeterminate
    progress indicator, for use when the current status of the process cannot be accurately
    determined.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了进度条如何包含对不确定进度指示器的支持，用于在当前进程状态无法精确确定时使用。
- en: In the next chapter, we will look at the datepicker widget, which has the biggest,
    most feature-packed API of any widget in the library and includes full internationalization.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到日期选择器小部件，它拥有库中所有小部件中最大、功能最丰富的 API，并包含完整的国际化支持。
