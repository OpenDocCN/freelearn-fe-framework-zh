- en: Get Going with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On September 18, 2014, Google pushed the first public commit to the repository
    that now contains Angular. A few weeks later, at ng-europe, Igor, and Tobias,
    from the core team, gave a short overview of what were the expected features of
    the new framework. The vision at that time was far from final; however, one thing
    was certain: Angular would be an entirely different framework compared to AngularJS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This announcement brought a lot of questions and controversies. The reasons
    behind the drastic changes were quite clear: AngularJS was no longer able to take
    full advantage of the evolved web and the requirements of large-scale JavaScript
    applications needed to be completely satisfied. A new framework would let Angular
    developers capitalize on developments in web technology in simpler, more performant,
    and productive ways. Yet, people were concerned. One of the biggest nightmares
    with backward incompatibility for developers is the migration of their current
    code bases to the new version of the third-party software they use. In Angular''s
    case, after that first announcement, migration looked daunting, even impossible.
    Later, at **ng-conf** 2015 and **ng-vegas** 2015, different migration strategies
    were introduced. The Angular community came together and shared additional ideas,
    anticipating the benefits of the new version of the framework, while preserving
    the things learned from AngularJS.'
  prefs: []
  type: TYPE_NORMAL
- en: This book is a part of that project. Making the upgrade to Angular is now smooth
    and is worth it. The main drivers behind the drastic changes in Angular 2 and
    its lack of backward compatibility are the evolution of the web and the lessons
    learned from the usage of AngularJS in the wild. This book will help you learn
    the new framework by making you understand how we got here and why Angular's new
    features make intuitive sense for the modern web in building high-performance,
    scalable, single-page applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics that we will discuss in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using TypeScript and understanding how it extends JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the user interface of Angular applications with a component-based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular's dependency injection mechanism and delegating the business logic
    to services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Angular's router and forms module in depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the Ahead-of-Time compilation for building lightning fast applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evolution of the web – time for a new framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past couple of years, the web has evolved in big steps. During the implementation
    of ECMAScript 5, the ECMAScript 6 standard started its development (now known
    as **ECMAScript 2015** or **ES2015**). ES2015 introduced many changes in JavaScript,
    such as adding built-in language support for modules, block scope variable definition,
    and a lot of syntactical sugar, such as classes and destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, **web components** were invented. Web components allow us to define
    custom HTML elements and attach behavior to them. Since it is hard to extend the
    existing set of HTML elements with new ones (such as dialogs, charts, and grids),
    mostly because of the time required for consolidation and standardization of their
    APIs, a better solution is to allow developers to extend the existing elements
    in the way they want. Web components provide us with a number of benefits, including
    better encapsulation, better semantics of the markup we produce, better modularity,
    and easier communication between developers and designers.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, JavaScript is a single-threaded language. Initially, it was developed
    for simple client-side scripting, but over time, its role has shifted quite a
    bit. Now, with HTML5, we have different APIs that allow audio and video processing,
    communication with external services through a two-directional communication channel,
    transferring and processing big chunks of raw data, and more. All these heavy
    computations in the main thread may create a poor user experience. They may introduce
    freezing of the user interface when time-consuming computations are being performed.
    This led to the development of **web workers**, which allow the execution of the
    scripts in the background that communicate with the main thread through message
    passing. This way, multithreaded programming was brought to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these APIs were introduced after the development of AngularJS had begun;
    that''s why the framework wasn''t built with most of them in mind. Taking advantage
    of the APIs gives developers many benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Significant performance improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development of software with better quality characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's briefly discuss how each of these technologies has been made part
    of the Angular core and why.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of ECMAScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, browser vendors are releasing new features in short iterations, and
    users receive updates quite often. This helps developers take advantage of bleeding-edge
    web technologies. ES2015 is already standardized. The implementation of the latest
    version of the language has already started in the major browsers. Learning the
    new syntax and taking advantage of it will not only increase our productivity
    as developers but will also prepare us for the near future when all browsers will
    have full support for it. This makes it essential to start using the latest syntax
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements of some projects may enforce us to support older browsers,
    which do not support any ES2015 features. In this case, we can directly write
    ECMAScript 5, which has a different syntax, but has semantics equivalent to ES2015\.
    On the other hand, a better approach will be to take advantage of the process
    of **transpilation**. Using a transpiler in our build process allows us to take
    advantage of the new syntax by writing ES2015 and translating it to a target language
    that is supported by the browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Angular has been around since 2009\. Back then, the frontend of most websites
    was powered by ECMAScript 3—the last main release of ECMAScript before ECMAScript
    5\. This automatically meant that the language used for the implementation of
    the framework was ECMAScript 3\. Taking advantage of the new version of the language
    requires porting of the entirety of AngularJS to ES2015.
  prefs: []
  type: TYPE_NORMAL
- en: From the beginning, Angular took into account the current state of the web by
    bringing the latest syntax in the framework. Angular is written with a superset
    of ES2016, called TypeScript, which we'll take a look at in [Chapter 4](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml),
    *TypeScript Crash Course*. The type annotations allow us to take additional performance
    boost because they open the door for a process called **ahead-of-time** (**AOT**)
    compilation, which as part of the build process, generates efficient code for
    change detection, rendering, and dependency injection. You can find more about
    AOT compilation in [Chapter 9](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml), *Tooling
    and Development Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: Web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first public draft of web components was published on May 22, 2012, about
    3 years after the release of AngularJS. As mentioned, the web components standard
    allows us to create custom elements and attach behavior to them. It sounds familiar
    because we've already used a similar concept in the development of the user interface
    with AngularJS. Web components sound like an alternative to Angular directives;
    however, they have a more intuitive API and built-in browser support. They introduced
    a few other benefits, such as better encapsulation, which is very important, for
    example, in handling CSS-style collisions.
  prefs: []
  type: TYPE_NORMAL
- en: A possible strategy for adding web components support in AngularJS is to change
    the directives implementation and introduce primitives of the new standard in
    the DOM compiler. As Angular developers, we know how powerful and complex the
    directives API is. It includes a lot of properties, such as `postLink`, `preLink`,
    `compile`, `restrict`, `scope`, and `controller`, and of course, our favorite
    `transclude`. Approved as standard, web components will be implemented on a much
    lower level in the browsers, which introduces plenty of benefits, such as better
    performance and native API.
  prefs: []
  type: TYPE_NORMAL
- en: During the implementation of web components, a lot of web specialists met with
    the same problems the AngularJS team did when developing the directives API, and
    came up with similar ideas. Good design decisions behind web components include
    the **content** element, which deals with the infamous transclusion problem in
    AngularJS. Since both the directives API and web components solve similar problems
    in different ways, keeping the directives API on top of web components would have
    been redundant and added unnecessary complexity. This is why the Angular core
    team decided to start from the beginning by building a framework compatible with
    web components and taking full advantage of the new standard. Web components involve
    new features; some of them are not yet implemented by all browsers. In case our
    application is run in a browser which does not support any of these features natively,
    Angular emulates them. An example for this is the `content` element polyfilled
    with the `ng-content` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Web workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is known for its event loop. Usually, JavaScript programs are executed
    in a single thread and different events are scheduled by being pushed in a queue
    and processed sequentially in the order of their arrival. However, this computational
    strategy is not effective when one of the scheduled events requires a lot of computational
    time. In such cases, the event's handling will block the main thread, and all
    other events will not be handled until the time-consuming computation is complete
    and the execution passed to the next one in the queue. A simple example of this
    is a mouse click that triggers an event, in which the callback does some audio
    processing using the HTML5 audio API. If the processed audio track is big and
    the algorithm running over it is heavy; this will affect the user's experience
    by freezing the UI until the execution is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The web workers API was introduced in order to prevent such pitfalls. It allows
    execution of heavy computations inside the context of a different thread, which
    leaves the main thread execution free, capable of handling user input and rendering
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we take advantage of this in Angular? In order to answer this question,
    let''s think about how things work in AngularJS. What if we have an enterprise
    application, which processes a huge amount of data that needs to be rendered on
    the screen using data binding? For each binding, the framework will create a new
    watcher. Once the digest loop is run, it will loop over all the watchers, execute
    the expressions associated with them, and compare the returned results with the
    results gained from the previous iteration. We have a few slowdowns here:'
  prefs: []
  type: TYPE_NORMAL
- en: The iteration over a large number of watchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evaluation of the expression in a given context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The copy of the returned result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comparison between the current result of the expression's evaluation and
    the previous one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these steps could be quite slow, depending on the size of the input. If
    the digest loop involves heavy computations, why not move it to a web worker?
    Why not run the digest loop inside the web worker, get the changed bindings, and
    then apply them to the DOM?
  prefs: []
  type: TYPE_NORMAL
- en: There were experiments by the community which aimed for this result. However,
    their integration into the framework wasn't trivial.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main reasons behind the lack of satisfying results was the coupling
    of the framework with the DOM. Often, inside the callbacks of watchers, AngularJS
    directly manipulates the DOM, which makes it impossible to move the watchers inside
    a web worker since the web workers are executed in an isolated context, without
    access to the DOM. In AngularJS, we may have implicit or explicit dependencies
    between the different watchers, which require multiple iterations of the digest
    loop in order to get stable results. Combining the last two points, it is quite
    hard to achieve practical results in calculating the changes in threads other
    than the main thread of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing this in AngularJS introduces a great deal of complexity into the internal
    implementation. The framework simply was not built with this in mind. Since web
    workers were introduced before the Angular design process started, the core team
    took them into consideration from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons learned from AngularJS in the wild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the previous section listed a lot of arguments for the required re-implementation
    of the framework responding to the latest trends, it's important to remember that
    we're not starting completely from scratch. We're taking what we've learned from
    AngularJS with us. In the period since 2009, the web is not the only thing that
    evolved. We also started building more and more complex applications. Today, single-page
    applications are not something exotic, but more like a strict requirement for
    all web applications solving business problems, which are aiming for high performance
    and a good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS helped us to efficiently build large-scale, single-page applications.
    However, by applying it in various use cases, we've also discovered some of its
    pitfalls. Learning from the community's experience, Angular's core team worked
    on new ideas aiming to answer the new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS follows the **Model-View-Controller** (**MVC**) micro-architectural
    pattern. Some may argue that it looks more like **Model-View-ViewModel** (**MVVM**)
    because of the view model attached as properties to the scope or the current context
    in case of *controller as syntax*. It could be approached differently again, if
    we use the **Model-View-Presenter** (**MVP**). Because of all the different variations
    of how we can structure the logic in our applications, the core team called AngularJS
    a **Model-View-Whatever** (**MVW**) framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view in any AngularJS application is supposed to be a composition of directives.
    The directives collaborate together in order to deliver fully functional user
    interfaces. Services are responsible for encapsulating the business logic of the
    applications. This is the place where we should put the communication with RESTful
    services through HTTP, real-time communication with WebSockets, and even WebRTC.
    Services are the building blocks where we should implement the domain models and
    business rules of our applications. There''s one more component, which is mostly
    responsible for handling user input and delegating the execution to the services:
    the controller.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the services and directives have well-defined roles, we can often see
    the anti-pattern of the **Massive View Controller**, which is common in iOS applications.
    Occasionally, developers are tempted to access or even manipulate the DOM directly
    from their controllers. Initially, this happens while you want to achieve something
    simple, such as changing the size of an element, or quick and dirty changing styles
    of elements. Another noticeable antipattern is the duplication of the business
    logic across controllers. Often, developers tend to copy and paste logic, which
    should be encapsulated inside services.
  prefs: []
  type: TYPE_NORMAL
- en: The best practices for building AngularJS applications state that the controllers
    should not manipulate the DOM at all; instead, all DOM access and manipulations
    should be isolated in directives. If we have some repetitive logic between controllers,
    most likely we want to encapsulate it into a service and inject this service with
    the dependency injection mechanism of Angular in all the controllers that need
    that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This is where we're coming from in AngularJS. All this said, it seems that the
    functionality of controllers could be moved into the controllers of the directive.
    Since directives support the dependency injection API, after receiving the user's
    input, we can directly delegate the execution to a specific service, already injected.
    This is the main reason why Angular now uses a different approach, by removing
    the ability to put controllers everywhere using the `ng-controller` directive.
    We'll take a look at how the responsibilities of AngularJS controllers could be
    taken from the new components and directives in [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml),
    *Getting Started with Angular Components and Directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data binding in AngularJS is achieved using the `scope` object. We can attach
    properties to it and explicitly declare in the template that we want to bind to
    these properties (one- or two-way). Although the idea of the scope seems clear,
    it has two more responsibilities, including event dispatching and the change detection-related
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular beginners have a hard time understanding what scope really is and how
    it should be used. AngularJS 1.2 introduced something called **controller as syntax**.
    It allows us to add properties to the current context inside the given controller
    (`this`), instead of explicitly injecting the `scope` object and later adding
    properties to it. This simplified syntax can be demonstrated through the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The latest Angular took this even further by removing the `scope` object. All
    the expressions are evaluated in the context of the given UI component. Removing
    the entire scope API introduces higher simplicity; we don't need to explicitly
    inject it anymore, instead, we add properties to the UI components to which we
    can later bind. This API feels much simpler and more natural.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a more detailed look at the components and the change detection
    mechanism of Angular in [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml),
    *Getting Started with Angular Components and Directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe the first framework on the market that included **Inversion of Control**
    (**IoC**) through **Dependency Injection** (**DI**) in the JavaScript world was
    AngularJS. DI provides a number of benefits, such as easier testability, better
    code organization and modularization, and simplicity. Although the DI in AngularJS
    does an amazing job, Angular took this even further. Since Angular is on top of
    the latest web standards, it uses the syntax of ECMAScript 2016 decorators for
    annotating the code for using DI. Decorators are quite similar to the decorators
    in Python or annotations in Java. They allow us to *decorate* the behavior of
    a given object, or add metadata to it, using reflection. Since decorators are
    not yet standardized and supported by major browsers, their usage requires an
    intermediate transpilation step.
  prefs: []
  type: TYPE_NORMAL
- en: The new DI is much more flexible and feature-rich. It also fixes some of the
    pitfalls of AngularJS, such as the different APIs; in the first version of the
    framework, some objects are injected by position (such as the scope, element,
    attributes, and controller in the link function of the directives) and others,
    by name (using parameters names in controllers, directives, services, and filters).
  prefs: []
  type: TYPE_NORMAL
- en: We will take a further look at the Angular's dependency injection API in [Chapter
    6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml), *Dependency Injection in Angular*.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bigger the requirements of the web are, the more complex web applications
    become. Building a real-life, single-page application requires writing a huge
    amount of JavaScript, and including all the required external libraries may increase
    the size of the scripts on our page to a few megabytes. The initialization of
    the application may take up to several seconds or even tens of seconds on a mobile
    device until all the resources get fetched from the server, the JavaScript is
    parsed and executed, the page gets rendered, and all the styles are applied. On
    low-end mobile devices that use a mobile internet connection, this process may
    make the users give up on visiting our application. Although there are a few practices
    that speed up this process, in complex applications, there's no silver bullet.
  prefs: []
  type: TYPE_NORMAL
- en: In the process of trying to improve the user experience, developers discovered
    a technique called **server-side rendering**. It allows us to render the requested
    view of a single-page application on the server and directly provide the HTML
    for the page to the user. Later, once all the resources are processed, the event
    listeners and bindings can be added by the script files. This sounds like a good
    way to boost the performance of our application. One of the pioneers in this was
    React, which allowed prerendering of the user interface on the server side using
    Node.js DOM implementations. Unfortunately, the architecture of AngularJS does
    not allow this. The showstopper is the strong coupling between the framework and
    the browser APIs, the same issue we had in running the change detection in web
    workers.
  prefs: []
  type: TYPE_NORMAL
- en: Another typical use case for the server-side rendering is for building **Search
    Engine Optimization** (**SEO**)-friendly applications. There were a couple of
    hacks used in the past for making the AngularJS applications indexable by the
    search engines. One such practice, for instance, is the traversal of the application
    with a headless browser, which executes the scripts on each page and caches the
    rendered output into HTML files, making it accessible by the search engines.
  prefs: []
  type: TYPE_NORMAL
- en: Although this workaround for building SEO-friendly applications works, server-side
    rendering solves both of the aforementioned issues, improving the user experience
    and allowing us to build SEO-friendly applications much more easily and far more
    elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: The decoupling of Angular with the DOM allows us to run our Angular applications
    outside the context of the browser. We will take a further look at it in [Chapter
    9](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml), *Tooling and Development Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVW has been the default choice for building single-page applications since
    Backbone.js appeared. It allows separation of concerns by isolating the business
    logic from the view, allowing us to build well-designed applications. Taking advantage
    of the observer pattern, MVW allows listening for model changes in the view and
    updating it when changes are detected. However, there are some explicit and implicit
    dependencies between these event handlers, which make the data flow in our applications
    not obvious and hard to reason about. In AngularJS, we are allowed to have dependencies
    between the different watchers, which requires the digest loop to iterate over
    all of them a couple of times until the results of the expressions results get
    stable. Angular makes the data flow in one direction; this has a number of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: More explicit data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No dependencies between bindings, so no **time to live** (**TTL**) of the digest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better performance of the framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The digest loop is run only once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create apps that are friendly to immutable or observable models that
    allow us to make further optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change in the data flow introduces one more fundamental change in the AngularJS
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We may take another perspective on the scalability problem when we need to maintain
    a large code base written in JavaScript. Although JavaScript's duck typing makes
    the language quite flexible, it also makes its analysis and support by IDEs and
    text editors harder. Refactoring of large projects gets very hard and error prone
    because in most cases, the static analysis and type inference are impossible.
    The lack of compiler makes typos all too easy, which are hard to notice until
    we run our test suite or run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular core team decided to use TypeScript because of the better tooling
    possible with it and the compile-time type checking, which help us to be more
    productive and less error prone. As the following figure shows, TypeScript is
    a superset of ECMAScript; it introduces explicit type annotations and a compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c674b35-6caf-4c3c-a770-a9d6d5442985.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript language is compiled to plain JavaScript, supported by today's
    browsers. Since version 1.6, TypeScript implements the ECMAScript 2016 decorators,
    which makes it the perfect choice for Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of TypeScript allows much better IDE and support of the text editors
    with static code analysis and type checking. All this increases our productivity
    dramatically by reducing the mistakes we make and simplifying the refactoring
    process. Another important benefit of TypeScript is the performance improvement
    we implicitly get by the static typing, which allows runtime optimizations by
    the JavaScript virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be talking about TypeScript in detail in [Chapter 4](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml),
    *TypeScript Crash Course*.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are one of the key features in AngularJS. They are simple HTML and
    do not require any intermediate translation, unlike most template engines, such
    as mustache. Templates in Angular combine simplicity with power by allowing us
    to extend HTML by creating an internal **Domain-Specific Language** (**DSL**)
    inside it, with custom elements and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the main purposes of web components as well. We already mentioned
    how and why Angular takes advantage of this new technology. Although AngularJS
    templates are great, they can still get better! The new Angular templates took
    the best from the past and enhanced it by fixing some of the confusing parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we have a directive and we want to allow the user to
    pass a property to it using an attribute. In AngularJS, we can approach this in
    the following three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the `user` directive, we pass the `name` property using three different approaches.
    We can either pass a literal (in this case, the `"literal"` string), a string,
    which will be evaluated as an expression (in our case `"expression"`), or an expression
    inside, `{{ }}`. Which syntax should be used completely depends on the implementation
    of the directive, which makes its API tangled and hard to remember.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with a large amount of components with different design decisions on
    a daily basis is a frustrating task. By introducing a common convention, we can
    handle such problems. However, in order to have good results and consistent APIs,
    the entire community needs to agree with it.
  prefs: []
  type: TYPE_NORMAL
- en: Angular deals with this problem by providing a special syntax for attributes,
    whose values need to be evaluated in the context of the current component, and
    a different syntax for passing literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we''re used to, based on our AngularJS experience, is the microsyntax
    in template directives, such as `ng-if` and `ng-for`. For instance, if we want
    to iterate over a list of users and display their names in AngularJS, we can use
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this syntax looks intuitive to us, it allows limited tooling support.
    However, Angular approached this differently by bringing a little bit more explicit
    syntax with richer semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet explicitly defines the property, which has to be created
    in the context of the current iteration (`user`), and the one we iterate over
    (`users`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this syntax is too verbose for typing, developers can use the following
    syntax, which later gets translated to the more verbose one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The improvements in the new templates will also allow better tooling for advanced
    support by text editors and IDEs. We will discuss Angular's templates in [Chapter
    5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started with Angular
    Components and Directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the w*eb workers* section, we already mentioned the opportunity to run the
    digest loop in the context of a different thread, instantiated as web worker.
    However, the implementation of the digest loop in AngularJS is not quite as memory-efficient
    and prevents the JavaScript virtual machine from doing further code optimizations,
    which allows for significant performance improvements. One such optimization is
    the inline caching ([http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The Angular team did a lot of research in order to discover different ways the
    performance and efficiency of the change detection could be improved. This led
    to the development of a brand new change detection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, Angular performs change detection in code that the framework directly
    generates from the templates of the components; the code is generated by the **Angular
    compiler**. The Angular compiler is a module of the framework which can process
    an Angular application, after that perform different optimizations on top of it,
    and in the end generate code that will perform much better than the source code
    that we have written.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two built-in code generation (also known as compilation) strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Just-in-time (JIT) compilation**: At runtime, Angular generates code that
    performs change detection on the entire application. The generated code is optimized
    for the JavaScript virtual machine, which provides a great performance boost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ahead-of-time (AOT) compilation**: This is similar to JIT, with the difference
    that the code is being generated as part of the application''s build process.
    It can be used for speeding the rendering up by not performing the compilation
    in the browser and also in environments that disallow `eval()`, such as ones with
    strict **Content-Security-Policy** (**CSP**) and Chrome extensions. We will discuss
    it further in the next sections of the book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take a look at the new change detection mechanism and how we can configure
    it in [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started
    with Angular Components and Directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we considered the main reasons behind the lack of backward
    compatibility between AngularJS and Angular. We saw that the design decisions
    implemented in Angular were fueled by two things: the evolution of the web and
    the evolution of the frontend development, with the lessons learned from the development
    of AngularJS applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, you learned why we need to use the latest version of the
    JavaScript language, why to take advantage of web components and web workers,
    and why it's not worth integrating all these powerful tools in AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: We observed the current direction of frontend development and the lessons learned
    in the last few years. We described why the controller and scope were removed
    from Angular, and why the architecture of AngularJS was changed in order to allow
    server-side rendering for SEO-friendly, high-performance, single-page applications.
    Another fundamental topic we took a look at was building large-scale applications,
    and how that motivated single-way data flow in the framework and the choice of
    the statically typed language, TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at the main building blocks of an Angular
    application, how they can be used, and how they relate to each other. Angular
    reuses some of the naming of the concepts introduced by AngularJS, but generally
    changes the building blocks of our single-page applications completely. We'll
    make a quick introduction to modules, directives, components, the new router,
    pipes, and services, and describe how they could be combined for building classy,
    single-page applications.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the example code
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  prefs: []
  type: TYPE_NORMAL
