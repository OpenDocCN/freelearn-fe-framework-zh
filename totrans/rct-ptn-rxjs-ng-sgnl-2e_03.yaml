- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Fetching Data as Streams
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据作为流获取
- en: The way you manage your application’s data has a huge impact on your UI performance
    and the user experience. As far as I’m concerned, great user experience and performant
    UIs are no longer an option nowadays – they are key determinants of user satisfaction.
    Furthermore, managing data efficiently optimizes the code and enhances its quality,
    which consequently minimizes maintenance and improvement costs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您管理应用程序数据的方式对UI性能和用户体验有巨大影响。在我看来，如今，出色的用户体验和性能UI不再是可选的——它们是用户满意度的重要决定因素。此外，高效地管理数据可以优化代码并提高其质量，从而降低维护和改进成本。
- en: So, how can we manage our data efficiently? Well, this is what we will be answering
    in the following chapters. There are a few reactive patterns that come in handy
    in many use cases, and we will start by exploring the most basic reactive pattern
    for displaying values received from a REST endpoint to allow users to read and
    interact with them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何有效地管理我们的数据呢？这正是我们将在以下章节中回答的问题。有几个响应式模式在许多用例中都很有用，我们将从探索用于显示从REST端点接收到的最基本响应式模式开始，以便用户可以阅读和与之交互。
- en: To begin, we will explain the requirement that we’re going to implement in the
    recipe application. Then, we will introduce the classic pattern to retrieve data,
    followed by the different approaches that you can use to manage unsubscriptions
    and all the important technical concepts surrounding them. We will also learn
    about a new feature of Angular 14+, which is standalone components. Following
    this, we will explain the reactive pattern to fetch data, and highlight the advantages
    of the reactive pattern over the classic one. Finally, we will learn about the
    new built-in control flow introduced in Angular 17.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将解释在食谱应用程序中将要实现的需求。然后，我们将介绍用于检索数据的经典模式，接着介绍您可以使用来管理取消订阅及其周围所有重要技术概念的多种方法。我们还将了解Angular
    14+的新特性——独立组件。在此之后，我们将解释用于获取数据的响应式模式，并强调响应式模式相对于经典模式的优点。最后，我们将了解Angular 17中引入的新内置控制流。
- en: 'So, in this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主要主题：
- en: Defining the data fetch requirement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据获取需求
- en: Exploring the classic pattern for fetching data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索用于获取数据的经典模式
- en: Exploring the reactive pattern for fetching data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索用于获取数据的响应式模式
- en: Highlighting the advantages of the reactive pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出响应式模式的优点
- en: Diving into the built-in control flow in Angular 17
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Angular 17中的内置控制流
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have a basic understanding of HttpClient, Angular
    components, Angular modules, and routing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经对HttpClient、Angular组件、Angular模块和路由有基本的了解。
- en: We’ll be using a mocked REST API backend built with JSON Server, which allows
    you to spin up a REST API server with a fully working API. We’ll not be learning
    how to use JSON Server, but if you are interested in learning more, you can find
    further information at [https://github.com/typicode/json-server](https://github.com/typicode/json-server).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用使用JSON Server构建的模拟REST API后端，它允许您启动一个具有完整工作API的REST API服务器。我们不会学习如何使用JSON
    Server，但如果您有兴趣了解更多信息，您可以在[https://github.com/typicode/json-server](https://github.com/typicode/json-server)找到更多信息。
- en: You can access the project source code for this chapter in the GitHub repository
    at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap03](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap03).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库中找到本章的项目源代码，网址为[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap03](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap03)。
- en: 'The project is composed of two folders:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目由两个文件夹组成：
- en: '`recipes-book-api`: This contains the mocked RESTful server already set up.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipes-book-api`：这包含已设置好的模拟RESTful服务器。'
- en: '`recipes-book-front`: This contains the frontend application that was built
    with Angular 17 and RxJS 7\. As a third-party dependency, we’ve added `bootstrap`
    and `primeng` libraries to help us build beautiful UI components quickly. Please
    refer to the previous chapter’s *Technical requirements* section for the environment
    and dependencies setup.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipes-book-front`：这包含使用Angular 17和RxJS 7构建的前端应用程序。作为第三方依赖项，我们添加了`bootstrap`和`primeng`库，以帮助我们快速构建美观的UI组件。请参阅上一章的*技术要求*部分以获取环境和依赖项设置。'
- en: The project complies with the standard Angular style guide, which can be found
    at [https://angular.dev/style-guide#](https://angular.dev/style-guide#).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目符合标准的 Angular 风格指南，可在 [https://angular.dev/style-guide#](https://angular.dev/style-guide#)
    找到。
- en: The first time you run the apps, you will need to install dependencies beforehand.
    You only have to run the `npm i` command in the `recipes-book-api` and `recipes-book-front`
    folders.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行应用程序时，您需要先安装依赖项。您只需在 `recipes-book-api` 和 `recipes-book-front` 文件夹中运行 `npm
    i` 命令。
- en: 'Once dependencies are installed, you need to start the server by running the
    following command in the `recipes-book-api` folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项安装完成后，您需要在 `recipes-book-api` 文件夹中运行以下命令来启动服务器：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The server will be running `at http://localhost:8081`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将在 `http://localhost:8081` 上运行。
- en: 'Then, you start the frontend by running the following command in the `recipes-book-front`
    folder:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `recipes-book-front` 文件夹中运行以下命令来启动前端：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can read more about the `--proxy-config` parameter at [https://angular.dev/tools/cli/serve#proxying-to-a-backend-server](https://angular.dev/tools/cli/serve#proxying-to-a-backend-server).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://angular.dev/tools/cli/serve#proxying-to-a-backend-server](https://angular.dev/tools/cli/serve#proxying-to-a-backend-server)
    阅读有关 `--proxy-config` 参数的更多信息。
- en: Defining the data fetch requirement
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据获取需求
- en: 'First, let’s define the requirement we are going to implement in a reactive
    way. We want to display the list of recipes retrieved from the mocked backend
    on the home page, progressively building the user story detailed in the *View
    one – the landing page* section of [*Chapter 2*](B21180_02.xhtml#_idTextAnchor031),
    *Walking through* *Our Application*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们将以响应式方式实现的要求。我们希望在主页上显示从模拟后端检索到的菜谱列表，逐步构建在 [*第二章*](B21180_02.xhtml#_idTextAnchor031)
    的 *视图一 – 登录页面* 部分中详细说明的用户故事：
- en: '![Figure 3.1 – The landing page view](img/B21180_02_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 登录页面视图](img/B21180_02_01.jpg)'
- en: Figure 3.1 – The landing page view
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 登录页面视图
- en: 'To do this, we need to fetch the list of recipes beforehand to display it to
    the user as cards, right? So, the list of recipes represents the first data that
    we need to request, which is available in our `recipes-book-api` server through
    the following endpoint:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要事先获取菜谱列表以将其作为卡片显示给用户，对吧？因此，菜谱列表代表我们首先需要请求的第一份数据，它可以通过以下端点在我们的 `recipes-book-api`
    服务器上找到：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Please don’t forget to start the server as detailed in the *Technical requirements*
    section. Once the server is started, you can check the result of the fetch API
    at `http://localhost:8081/api/recipes`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要忘记按照 *技术要求* 部分中的详细说明启动服务器。一旦服务器启动，您可以在 `http://localhost:8081/api/recipes`
    检查获取 API 的结果。
- en: In the following sections, we will see how we can implement the fetching data
    requirement in both classic and reactive styles to understand the basic differences
    between them, and to see the benefits the reactive programming gives us over the
    imperative one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将了解如何以经典和响应式风格实现获取数据的需求，以便理解它们之间的基本差异，并看到响应式编程相对于命令式编程带来的好处。
- en: Exploring the classic pattern for fetching data
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索获取数据的经典模式
- en: Let’s first have a look at the implementation of the classic pattern for fetching
    the list of recipes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看获取菜谱列表的经典模式的实现。
- en: Defining the structure of your data
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义您数据结构
- en: First and foremost, we need to define the structure of our data so that we can
    strongly type it. This will allow us to take advantage of TypeScript’s type-checking
    features and catch type errors early.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们数据的结构，以便我们可以对其进行强类型化。这将使我们能够利用 TypeScript 的类型检查功能，并在早期捕获类型错误。
- en: 'We can use the Angular CLI to generate the `src/app/` `core/model` folder:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Angular CLI 生成 `src/app/` `core/model` 文件夹：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For convention purposes, we will change the name of the generated file from
    `recipe.ts` to `recipe.model.ts`. Then, we will populate the interface with the
    specific properties of `Recipe`, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循惯例，我们将生成的文件名从 `recipe.ts` 更改为 `recipe.model.ts`。然后，我们将使用 `Recipe` 的具体属性填充接口，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One by one, we enter the properties of the recipe we are going to use, followed
    by the type of each property. The description of each property is detailed in
    *View two – the New Recipe interface* section of [*Chapter 2*](B21180_02.xhtml#_idTextAnchor031),
    *Walking through* *Our Application*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个输入我们将要使用的菜谱的属性，然后是每个属性的类型。每个属性的描述在 [*第二章*](B21180_02.xhtml#_idTextAnchor031)
    的 *视图二 – 新菜谱界面* 部分中详细说明，*漫步* *我们的应用程序*。
- en: For optional properties, we placed a question mark (`?`) just before the property’s
    type annotation when declaring the interface to tell TypeScript that the property
    is optional.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可选属性，我们在声明接口时在属性类型注释之前放置一个问号（`?`），以告诉TypeScript该属性是可选的。
- en: Creating the fetching data service
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建获取数据服务
- en: The next step is to create an Angular service named `RecipesService` that will
    be responsible for managing all the operations around the recipes. This service
    will encapsulate the **create, read, update, and delete** (**CRUD**) operations
    and make them available to the various UI components. In this chapter, we will
    only implement the read (fetch) operation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个名为`RecipesService`的Angular服务，该服务将负责管理所有与食谱相关的操作。该服务将封装**创建、读取、更新和删除**（**CRUD**）操作，并将它们提供给各种UI组件。在本章中，我们只实现读取（获取）操作。
- en: Now, why do we create a service? Well, we do it to increase modularity and to
    ensure the reusability of the service over the other components.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么要创建一个服务呢？嗯，我们这样做是为了增加模块化并确保服务在其他组件中的可重用性。
- en: 'To generate the service underneath the `core/services` folder, we execute the
    `ng g s` command under the `core/services` folder like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`core/services`文件夹下生成服务，我们可以在`core/services`文件夹下执行`ng g s`命令，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that the service is generated successfully, let’s create and implement
    the method that will have the responsibility of fetching the data. We will inject
    the `HttpClient` in the `RecipesService` and define a method to retrieve the data.
    The service will look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已成功生成，让我们创建并实现一个负责获取数据的函数。我们将在`RecipesService`中注入`HttpClient`并定义一个获取数据的方法。该服务将如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s break down what is going on at the level of `RecipesService`. It’s nothing
    fancy – we have a `getRecipes()` method that gets the list of recipes over HTTP
    and returns a strongly typed HTTP response: `Observable<Recipe[]>`. This Observable
    represents the data stream that will be created when you issue the HTTP GET request.
    When you subscribe to it, it will emit the list of recipes as a JSON array and
    then completes. So, the stream represented by this HTTP request will be completed
    after emitting the response data once.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下`RecipesService`级别的操作。这并不复杂——我们有一个`getRecipes()`方法，它通过HTTP获取食谱列表并返回一个强类型HTTP响应：`Observable<Recipe[]>`。这个Observable代表了当你发出HTTP
    GET请求时将创建的数据流。当你订阅它时，它将作为JSON数组发出食谱列表，然后完成。因此，这个HTTP请求所代表的流将在发出响应数据后完成。
- en: As a best practice, we externalized `BASE_PATH` in the `environment.ts` file
    because, in many cases, the server’s base path depends on the environment (such
    as testing or production). This way, it is easier to update the paths in one place
    rather than updating all the services using it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我们在`environment.ts`文件中外部化了`BASE_PATH`，因为在许多情况下，服务器的基路径取决于环境（如测试或生产）。这样，在单个位置更新路径比在所有使用它的服务中更新路径要容易得多。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Starting from Angular 15, the environment files are not shipped by default anymore.
    However, you can choose to generate them on demand by executing `$ ng` `g environments`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular 15开始，环境文件不再默认提供。然而，你可以选择在需要时通过执行`$ ng g environments`来生成它们。
- en: 'We’ve also injected the `HttpClient` dependency in the constructor as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在构造函数中注入了`HttpClient`依赖项，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This technique is known as **constructor injection**. Angular’s built-in dependency
    injection system will automatically provide the injected dependencies when an
    instance of the component or service is created.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为**构造函数注入**。Angular内置的依赖注入系统将在创建组件或服务实例时自动提供注入的依赖项。
- en: 'Plus, starting from version 14, Angular’s dependency injection system provided
    the `inject()` utility function. This allows you to manually resolve and retrieve
    dependencies within a component or a service like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从版本14开始，Angular的依赖注入系统提供了`inject()`实用函数。这允许你手动解决和检索组件或服务中的依赖项，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This approach is useful when you need to dynamically resolve dependencies or
    perform conditional dependency injection based on runtime conditions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要动态解决依赖项或根据运行时条件执行条件依赖注入时，这种方法很有用。
- en: We will use the constructor injection technique throughout the book. However,
    should you wish to adopt the newer approach, you have the flexibility to do so.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中使用构造函数注入技术。但是，如果你希望采用更新的方法，你有灵活性这样做。
- en: Creating Angular standalone components
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Angular独立组件
- en: 'Now, we should create the component responsible for displaying the list of
    recipes named `RecipesListComponent` under `src/app/recipe-list`. Before that,
    though, let’s just stop here and explain a super interesting new type of component
    introduced in Angular 14: the standalone component.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该在 `src/app/recipe-list` 下创建负责显示食谱列表的组件，名为 `RecipesListComponent`。在此之前，让我们先停下来，解释一下在
    Angular 14 中引入的一种非常有趣的新类型组件：独立组件。
- en: By definition, a `NgModule` and can be used by either other standalone components
    or module-based components.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`NgModule` 可以被其他独立组件或基于模块的组件使用。
- en: 'Before Angular 14, we only had one way to create components:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 14 之前，我们只有一种创建组件的方法：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command will create a component named `RecipesListComponent` and add it
    to an `NgModule`. Which module, though? If you specify `--module` in the command
    line, followed by the path of your module, then the CLI will add the component
    in that specific module. If the `--module` option is not set, then the CLI will
    check whether there’s a module in the same directory; if not, it will check in
    the nearest parent directory. If neither of those options is the case, it will
    generate a new module file in the same directory as the component and declare
    the component in that new module.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个名为 `RecipesListComponent` 的组件并将其添加到 `NgModule` 中。那么是哪个模块呢？如果您在命令行中指定了
    `--module`，后跟您的模块路径，那么 CLI 将将组件添加到该特定模块中。如果没有设置 `--module` 选项，CLI 将检查同一目录中是否有模块；如果没有，它将在最近的父目录中检查。如果这两种选项都不适用，它将在组件相同的目录中生成一个新的模块文件，并在该新模块中声明组件。
- en: In short, the CLI will always end up associating the component to a module and
    adding it to the module’s declaration array; otherwise, you will get a compilation
    error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，CLI 总是将组件关联到模块，并将其添加到模块的声明数组中；否则，您将遇到编译错误。
- en: 'However, starting from Angular 14, you can decide to create a standalone component
    that doesn’t belong to any `NgModule` by mentioning the `--standalone` flag in
    the command line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从 Angular 14 开始，您可以通过在命令行中提及 `--standalone` 标志来决定创建不属于任何 `NgModule` 的独立组件：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using this in our project, `RecipesListComponent` won’t be added to an `NgModule`,
    and will contain the `standalone: true` flag inside the `@Component` decorator,
    as well as the `imports` property:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的项目中使用此方法，`RecipesListComponent` 不会被添加到 `NgModule` 中，并且将在 `@Component` 装饰器内部以及
    `imports` 属性中包含 `standalone: true` 标志：'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the standalone component depends on other components, whether module-based
    or standalone, you should mention those components in the `imports` array; otherwise,
    you will get a compilation error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果独立组件依赖于其他组件，无论是基于模块的还是独立的，您应该在 `imports` 数组中提及这些组件；否则，您将遇到编译错误。
- en: Standalone components can also be used by module-based components or other standalone
    components. Plus, they can be used when loading routes, and in lazy loading. It’s
    also worth knowing that you can create standalone directives and standalone pipes
    as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 独立组件也可以被基于模块的组件或其他独立组件使用。此外，它们可以在加载路由和懒加载时使用。还值得注意的是，您还可以创建独立的指令和独立的管道。
- en: 'So far, so good! Now, why should you care? There are a few good reasons we
    should adopt standalone components in our projects:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在，为什么你应该关心呢？有几个很好的理由我们应该在我们的项目中采用独立组件：
- en: Less code means less boilerplate to write, and hence, quicker build times, plus
    better code organization, testing, and maintainability.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更少意味着更少的样板代码要编写，因此构建时间更快，代码组织、测试和可维护性也更好。
- en: It is easier to understand the component’s dependencies as they are mentioned
    directly in the `imports` property of the standalone component. For a module-based
    component, you will have to scan your component’s code and then check the module’s
    dependencies that are shared by all the components belonging to that module.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于独立组件的依赖关系直接在 `imports` 属性中提及，因此更容易理解组件的依赖关系。对于基于模块的组件，您将不得不扫描您的组件代码，然后检查该模块的所有组件共享的模块依赖关系。
- en: The power of standalone components lies in their isolation and self-contained
    nature. You only import what is needed by your component, while module-based components
    sometimes import useless dependencies used by other components in the same module.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立组件的力量在于它们的隔离和自包含特性。您只需导入组件所需的内容，而基于模块的组件有时会导入同一模块中其他组件使用的无用依赖项。
- en: Let’s suppose that we have a module “M” that imports “A,” “B,” and “C” components
    and “S1,” “S2,” and “S3” services, and we have a “D” component that does not belong
    to that module but depends on the component “B.” As “B” is a module-based component,
    then “D” should import the entire module ‘M’; this leads to unnecessary dependencies
    as “D” does not need the components “A” and “B” or the services “S1” and “S2.”
    So, integrating standalone components gives us more flexibility to only import
    the components and services required, since standalone components are self-contained
    and have their own sets of dependencies and logic. Consequently, it eliminates
    redundant code, leading to a more optimized app.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们有一个模块“M”，它导入了“A”、“B”和“C”组件以及“S1”、“S2”和“S3”服务，并且我们有一个不属于该模块但依赖于组件“B”的“D”组件。由于“B”是一个基于模块的组件，因此“D”应该导入整个模块“M”；这会导致不必要的依赖，因为“D”不需要组件“A”和“B”或服务“S1”和“S2”。因此，集成独立组件使我们能够仅导入所需的组件和服务，因为独立组件是自包含的，并且有自己的依赖关系和逻辑集合。因此，它消除了冗余代码，导致应用程序更加优化。
- en: It makes the learning curve for beginner Angular developers less steep.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得初学 Angular 开发者的学习曲线不那么陡峭。
- en: 'We will be using standalone components in our recipe app to adopt a modular
    and self-contained approach. We will only keep the app component as a module-based
    component, even though we can bootstrap the application using a standalone component.
    Here’s a schema representing our component’s dependencies:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的食谱应用中使用独立组件，以采用模块化和自包含的方法。我们只保留应用程序组件作为基于模块的组件，尽管我们可以使用独立组件启动应用程序。以下是一个表示我们的组件依赖关系的方案：
- en: '![Figure 3.2 – The recipe app''s components’ dependencies](img/B21180_03_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 食谱应用组件的依赖关系](img/B21180_03_02.jpg)'
- en: Figure 3.2 – The recipe app's components’ dependencies
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 食谱应用组件的依赖关系
- en: The `AppComponent` parent component is a module-based component that imports
    the `HeaderComponent` standalone component in the `AppModule` imports declaration.
    `HeaderComponent` uses some PrimeNG external dependencies, so it needs to be imported
    in the component’s imports declaration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件 `AppComponent` 是一个基于模块的组件，它在 `AppModule` 的导入声明中导入了 `HeaderComponent` 独立组件。`HeaderComponent`
    使用一些 PrimeNG 外部依赖，因此需要在组件的导入声明中导入。
- en: '`HomeComponent` is a standalone component that will be routed to by `AppComponent`.
    `HomeComponent` imports the `RecipesListComponent` standalone component in the
    component’s imports declaration. The latter uses some PrimeNG external dependencies,
    so it needs to be imported in the component’s imports declaration. All the code
    is available in the GitHub repository.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`HomeComponent` 是一个独立组件，它将通过 `AppComponent` 进行路由。`HomeComponent` 在组件的导入声明中导入了
    `RecipesListComponent` 独立组件。后者使用一些 PrimeNG 外部依赖，因此需要在组件的导入声明中导入。所有代码都可在 GitHub
    仓库中找到。'
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on standalone components, you can check [https://angular.dev/reference/migrations/standalone](https://angular.dev/reference/migrations/standalone)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关于独立组件的更多信息，你可以查看 [https://angular.dev/reference/migrations/standalone](https://angular.dev/reference/migrations/standalone)
- en: Hopefully, the concept of standalone components is clear, so let’s move on to
    the following step.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 希望独立组件的概念已经清楚，那么让我们继续下一步。
- en: Injecting and subscribing to the service in your component
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的组件中注入和订阅服务
- en: In this section, we will inject the `RecipesService` service in the `RecipesListComponent`
    component and call the `getRecipes()`method in `ngOnInit()` (when the component
    is initialized). We will also make a read operation against the API server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将 `RecipesService` 服务注入到 `RecipesListComponent` 组件中，并在 `ngOnInit()`（组件初始化时）调用
    `getRecipes()` 方法。我们还将对 API 服务器执行读取操作。
- en: 'In order to get the data emitted, we need to subscribe to the returned Observable
    from the `getRecipes()` method. Then, we bind the data to a local array property
    created in our component, called `recipes`. The component’s code will look like
    this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取发出的数据，我们需要订阅 `getRecipes()` 方法返回的 Observable。然后，我们将数据绑定到我们在组件中创建的本地数组属性，称为
    `recipes`。组件的代码将如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we’ve retrieved the data and stored it in a local property, let’s see
    how we will display it in the UI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检索了数据并将其存储在本地属性中，让我们看看我们如何在 UI 中显示它。
- en: Displaying the data in the template
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中显示数据
- en: Now we can use the `recipes` property (which is available in the component)
    in our HTML template to display the list of recipes in our UI. In our case, we
    are using the `DataView` PrimeNG component to display the list of recipes as cards
    in a grid layout (further details about this component can be found at [https://primeng.org/dataview](https://primeng.org/dataview)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用组件中可用的`recipes`属性在我们的HTML模板中显示食谱列表。在我们的案例中，我们使用`DataView` PrimeNG组件以网格布局显示食谱列表作为卡片（有关此组件的更多详细信息，请参阅[https://primeng.org/dataview](https://primeng.org/dataview)）。
- en: 'Of course, our goal is to focus not on the template code, but on the manipulation
    of the data inside it. As you can see in the following example, we passed the
    `recipes` array to the `value` input of the data view component (you can also
    use structural directives to render a data view component with pure HTML if you
    don’t want to include a third-party dependency):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的目标是关注模板代码之外的数据操作。正如您在下面的示例中可以看到的，我们将`recipes`数组传递给了数据视图组件的`value`输入（如果您不想包含第三方依赖项，您也可以使用结构化指令以纯HTML渲染数据视图组件）：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the basic pattern for collecting data, which you would have discovered
    back when you started learning about Angular, so you have likely seen something
    like this before.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是收集数据的基本模式，您在开始学习Angular时就已经发现了，所以您可能之前已经见过类似的东西。
- en: Now there’s just one thing left – you should handle the unsubscription of the
    Observable, as this code manages subscriptions manually. Otherwise, the `Observable`
    subscription will stay alive after the component has been destroyed, and the memory’s
    reference will not be released, causing memory leaks. That’s why you should always
    be careful of this when manually subscribing to Observables inside Angular components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下一点——您应该处理Observable的取消订阅，因为这段代码手动管理订阅。否则，组件被销毁后，`Observable`的订阅将保持活跃状态，内存引用将不会被释放，导致内存泄漏。这就是为什么您在Angular组件内部手动订阅Observable时应该始终小心。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although `HttpClient` Observables unsubscribe automatically after the server
    request responds or times out, we will still demonstrate how to handle their unsubscription
    to secure our implementation and showcase best practices. This will also serve
    as a showcase for handling unsubscription with other Observables.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在服务器请求响应或超时后`HttpClient`的Observable会自动取消订阅，但我们仍将演示如何处理它们的取消订阅以确保我们的实现并展示最佳实践。这还将作为处理其他Observable取消订阅的展示。
- en: Managing unsubscriptions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理取消订阅
- en: 'There are two commonly used ways to manage unsubscriptions: the imperative
    pattern and the declarative reactive pattern. Let’s look at both patterns in detail.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 管理取消订阅有两种常用的方法：强制性模式和声明性响应模式。让我们详细看看这两种模式。
- en: Imperative unsubscription management
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制性取消订阅管理
- en: 'Imperative unsubscription means that we manually call the `unsubscribe()` method
    on the subscription object that we manage ourselves. The following code snippet
    illustrates this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 强制性取消订阅意味着我们手动调用我们自行管理的订阅对象的`unsubscribe()`方法。以下代码片段说明了这一点：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we simply store the subscription inside a variable called `subscription`
    and unsubscribe from it in the `ngOnDestroy()` lifecycle hook.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将订阅存储在一个名为`subscription`的变量中，并在`ngOnDestroy()`生命周期钩子中取消订阅。
- en: This works fine, but it is not a recommended pattern. There is a better way,
    using the power of RxJS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以正常工作，但并不是一个推荐的模式。有一个更好的方法，利用RxJS的力量。
- en: Declarative unsubscription management
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明性取消订阅管理
- en: 'The second unsubscription method is cleaner and far more declarative, using
    the RxJS `takeUntil` operator. However, before we dive into this pattern, let’s
    gain an understanding of the role of `takeUntil` using the following marble diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种取消订阅的方法更为简洁且声明性更强，使用了RxJS的`takeUntil`操作符。然而，在我们深入探讨这个模式之前，让我们通过以下宝石图来了解`takeUntil`的作用：
- en: '![Figure 3.3 – The takeUntil marble diagram](img/B21180_03_03.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – takeUntil宝石图](img/B21180_03_03.jpg)'
- en: Figure 3.3 – The takeUntil marble diagram
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – takeUntil宝石图
- en: The `takeUntil()` operator emits values from the source Observable (the first
    timeline) until the `Observable` notifier, which is given as input (the second
    timeline), emits a value. At that time, `takeUntil()` will stop the emission and
    complete. In the marble diagram, the source Observable emitted the values of `a`,
    `b`, `c`, and `d` – so `takeUntil()` will emit them, respectively. After that,
    the `Observable` notifier emits `z`, then `takeUntil()` will stop emitting values
    and will be completed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeUntil()`操作符从源可观察对象（第一个时间轴）发出值，直到输入的可观察对象通知器（第二个时间轴）发出一个值。在那个时刻，`takeUntil()`将停止发出值并完成。在油管图中，源可观察对象发出了`a`、`b`、`c`和`d`的值——所以`takeUntil()`将分别发出它们。之后，可观察对象通知器发出`z`，然后`takeUntil()`将停止发出值并完成。'
- en: 'In our application, the `takeUntil` operator will help us keep the subscription
    alive for a period that we define. We want it to be alive until the component
    has been destroyed, so we will create an RxJS subject that will emit a value when
    the component has been destroyed. Then, we will pass this subject to `takeUntil`
    as input:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，`takeUntil`操作符将帮助我们保持订阅在我们定义的期间活跃。我们希望它能在组件被销毁时保持活跃，所以我们将创建一个RxJS主题，当组件被销毁时它会发出一个值。然后，我们将这个主题传递给`takeUntil`作为输入：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `$` sign is an informal convention that is used to indicate that the variable
    is an Observable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`符号是一个非正式约定，用来表示变量是一个可观察对象。'
- en: The first thing you might notice here is that it’s less code than the first
    approach. Furthermore, when we call `unsubscribe()` on a returned subscription
    object (the first way), there’s no way we can be notified that the unsubscription
    happened. However, using `takeUntil()`, we will be notified of the Observable
    completion through the completion handler.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是，这比第一种方法代码更少。此外，当我们对一个返回的订阅对象（第一种方式）调用`unsubscribe()`时，我们无法得到取消订阅发生的通知。然而，使用`takeUntil()`，我们将通过完成处理程序得到可观察对象完成的通告。
- en: It is worth noting that this implementation can be further enhanced by using
    the `takeUntilDestroyed` operator introduced in Angular 16\. This operator simplifies
    Observable subscription management in your Angular components and directives.
    It automatically completes subscriptions when the associated component or directive
    is destroyed, eliminating the need for manual cleanup in the `ngOnDestroy` lifecycle
    hook.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个实现可以通过使用Angular 16中引入的`takeUntilDestroyed`操作符进一步优化。这个操作符简化了Angular组件和指令中的可观察对象订阅管理。它会在关联的组件或指令被销毁时自动完成订阅，从而消除了在`ngOnDestroy`生命周期钩子中进行手动清理的需要。
- en: 'You only have to import the `takeUntilDestroyed` operator from the `@angular/core/rxjs-interop`
    package as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要按照以下方式从`@angular/core/rxjs-interop`包中导入`takeUntilDestroyed`操作符：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we use this operator within the pipe operator of our subscription. The
    previous code will look like this after using `takeUntilDestroyed`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在订阅的管道操作符中使用这个操作符。使用`takeUntilDestroyed`之后，之前的代码将如下所示：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the manual cleanup code in the `ngOnDestroy` lifecycle hook
    has been removed along with the `destroy$` subject, resulting in a more concise
    and readable component implementation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`ngOnDestroy`生命周期钩子中的手动清理代码以及`destroy$`主题已被移除，从而使得组件实现更加简洁易读。
- en: The `takeUntilDestroyed()` operator will automatically handle the subscription
    cleanup when `RecipesListComponent` is destroyed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeUntilDestroyed()`操作符将在`RecipesListComponent`被销毁时自动处理订阅清理。'
- en: 'Apart from the `takeUntil` and `takeUntilDestroyed` operators, there are other
    operators that manage unsubscription for you in a more reactive way. The following
    are some examples:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`takeUntil`和`takeUntilDestroyed`操作符之外，还有其他操作符可以以更反应式的方式为你管理取消订阅。以下是一些示例：
- en: '`take(X)`: This emits *x* values and then completes (will no longer emit values).
    For example, `take(3)` will emit three values from the given Observable and then
    complete. However, bear in mind that if your network is slow and the *xth* emission
    didn’t happen, then you have to unsubscribe manually.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take(X)`: 这会发出*x*个值然后完成（将不再发出值）。例如，`take(3)`将从给定的可观察对象中发出三个值然后完成。然而，请注意，如果你的网络速度慢，并且*x*次发出没有发生，那么你必须手动取消订阅。'
- en: '`first()`: This emits the first value and then completes.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first()`: 这会发出第一个值然后完成。'
- en: '`last()`: This emits the last value and then completes.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last()`: 这会发出最后一个值然后完成。'
- en: 'This was the classic pattern that we have all learned as a beginner, and it
    is a relatively valid way for fetching data. To sum up, the following diagram
    describes all the steps that we walked through:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们作为初学者都学过的经典模式，并且对于获取数据来说是一个相对有效的方法。总结一下，以下图表描述了我们走过的所有步骤：
- en: '![Figure 3.4 – The classic pattern workflow](img/B21180_03_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 经典模式工作流程](img/B21180_03_04.jpg)'
- en: Figure 3.4 – The classic pattern workflow
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 经典模式工作流程
- en: However, there is another pattern that we can use, which is much more declarative
    and reactive and has many advantages. We’ll discover it next!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还可以使用另一种模式，它更加声明性和响应性，并且具有许多优点。我们将在下一部分发现它！
- en: Exploring the reactive pattern for fetching data
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索用于获取数据的响应式模式
- en: The idea behind this reactive pattern is to keep and use the Observable as a
    stream throughout the application. Don’t worry – this will become more apparent
    to you as you explore this section. Let’s get started.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种响应式模式背后的想法是在整个应用程序中保持并使用可观察对象作为流。别担心——当你探索这一部分时，这会对你更加明显。让我们开始吧。
- en: Retrieving data as streams
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以流的形式检索数据
- en: 'To start using the reactive pattern, instead of defining a method to retrieve
    our data, we will declare a variable inside our service:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用响应式模式，我们不是定义一个方法来检索我们的数据，而是在我们的服务中声明一个变量：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are declaring the `recipes$` variable as the result of HTTP GET, which
    is either an Observable or the data stream. Think of every piece of data that
    changes over time as a stream and declare it as an Observable in a separate service.
    This will make it accessible throughout the app and give us more flexibility to
    manipulate it in different parts of the application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明`recipes$`变量作为HTTP GET的结果，它要么是一个可观察对象，要么是数据流。想象一下，随着时间的推移而改变的数据的每一部分都是一个流，并在单独的服务中将它声明为一个可观察对象。这将使它在整个应用程序中可访问，并给我们更多的灵活性，以便在应用程序的不同部分中操作它。
- en: Defining the stream in your component
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的组件中定义流
- en: 'Now, in `RecipesListComponent`, we are going to do the same thing we did in
    the classic pattern – that is, declare a variable holding the stream returned
    from our service. However, this time, the variable is the Observable we created
    in `RecipesService`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`RecipesListComponent`中，我们将做与经典模式相同的事情——那就是，声明一个变量来持有从我们的服务返回的流。然而，这次，变量是我们创建在`RecipesService`中的可观察对象：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But wait! We need to subscribe in order to get the emitted data, right? That’s
    absolutely correct. Let’s see how we will do it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！我们需要订阅以获取发出的数据，对吧？这是绝对正确的。让我们看看我们将如何做到这一点。
- en: Using the async pipe in your template
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的模板中使用异步管道
- en: For this pattern, we will not subscribe manually but instead, use a better way,
    the async pipe. The **async pipe** makes rendering values emitted from the Observable
    easier.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，我们不会手动订阅，而是使用一种更好的方式，即异步管道。异步管道使得从可观察对象中渲染值变得更容易。
- en: First of all, it automatically subscribes to the input Observable. Then, it
    returns the latest value emitted. Best of all, when the component has been destroyed,
    it automatically unsubscribes to avoid any potential memory leaks. This means
    there is no need to manually clean up any subscriptions when the component has
    been destroyed. That’s amazing!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它会自动订阅输入的可观察对象。然后，它返回最新的发出的值。最好的是，当组件被销毁时，它会自动取消订阅，以避免任何潜在的内存泄漏。这意味着当组件被销毁时，不需要手动清理任何订阅。这真是太棒了！
- en: 'So, in the template, we bind to an Observable using the async pipe. As `recipes`
    describes the array variable that the values are emitted into, we can use it in
    the template as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在模板中，我们使用异步管道绑定到一个可观察对象。由于`recipes`描述了值被发出的数组变量，我们可以在模板中如下使用它：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you may have noticed, the `<div>` element contains a `*ngIf` structural directive.
    This directive conditionally renders its child elements based on the truthiness
    of the `recipes$ |` `async` expression.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，`<div>`元素包含一个`*ngIf`结构指令。这个指令根据`recipes$ | async`表达式的真值条件性地渲染其子元素。
- en: The `recipes$ | async` expression subscribes to the `recipes$` Observable and
    asynchronously renders the child elements of the `<div>` element (which is the
    `DataView` component in our case) when the Observable emits a value. It also unsubscribes
    and cleans up the subscription when the element is removed from the **DOM** (**Document**
    **Object Model**).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`recipes$ | async`表达式订阅了`recipes$`可观察对象，并在可观察对象发出值时异步渲染`<div>`元素的子元素（在我们的例子中是`DataView`组件）。它还会在元素从**DOM**（**文档对象模型**）中移除时取消订阅并清理订阅。'
- en: The `*ngIf` directive is followed by `as recipes`, which assigns the emitted
    value from the Observable to the local `recipes` variable. This allows us to access
    the emitted value within the scope of the `<div>` element and its children using
    the `recipes` variable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`*ngIf` 指令后面跟着 `as recipes`，这会将 Observable 发射的值赋给局部的 `recipes` 变量。这使得我们可以在
    `<div>` 元素及其子元素的作用域内使用 `recipes` 变量来访问发射的值。'
- en: By using the async pipes, we don’t need the `ngOnInit` lifecycle hook, as we
    will not subscribe to the `Observable` notifier in `ngOnInit()` and unsubscribe
    from `ngOnDestroy()` as we did in the classic pattern. Instead, we simply set
    a local property in our component and we are good to go – we don’t need to handle
    the subscription and unsubscription on our own!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用异步管道，我们不需要 `ngOnInit` 生命周期钩子，因为我们不会在 `ngOnInit()` 中订阅 `Observable` 通知器，也不会在
    `ngOnDestroy()` 中取消订阅，就像我们在经典模式中所做的那样。相反，我们只需在我们的组件中设置一个本地属性，我们就准备好了——我们不需要自己处理订阅和取消订阅！
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The full code of the HTML template is available in the GitHub repository.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 模板的完整代码可在 GitHub 仓库中找到。
- en: 'To sum up this pattern, the following diagram describes all the steps we walked
    through:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这种模式，以下图表描述了我们走过的所有步骤：
- en: '![Figure 3.5 – The reactive pattern workflow](img/B21180_03_05.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 响应式模式工作流程](img/B21180_03_05.jpg)'
- en: Figure 3.5 – The reactive pattern workflow
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 响应式模式工作流程
- en: Now that we have explained the reactive pattern in action, in the next section,
    let’s review its advantages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了响应式模式在实际中的应用，在下一节中，让我们回顾其优点。
- en: Highlighting the advantages of the reactive pattern
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出显示响应式模式的优点
- en: I think you might have guessed the first advantage of the reactive pattern –
    we don’t have to manually manage subscriptions and unsubscriptions, and what a
    relief – but there are a lot of other advantages. Let’s look at the other advantages
    in more detail.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你可能已经猜到了响应式模式的第一大优点——我们不必手动管理订阅和取消订阅，多么令人欣慰——但还有很多其他的优点。让我们更详细地看看其他优点。
- en: Using the declarative approach
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用声明式方法
- en: Let’s shed light on why we don’t explicitly use the `subscribe()` method. What’s
    wrong with `subscribe()`? Well, subscribing to a stream inside our component means
    we are allowing imperative code to leak into our functional and reactive code.
    Using the RxJS Observables does not make our code reactive and declarative systematically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看为什么我们不显式使用 `subscribe()` 方法。`subscribe()` 有什么问题？嗯，在组件内部订阅流意味着我们允许命令式代码泄漏到我们的函数式和响应式代码中。使用
    RxJS Observables 并不能使我们的代码系统性地变得响应式和声明式。
- en: 'But what does declarative mean, exactly? Well, first, we will nail down some
    key terms. Then, let’s iterate from there:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但“声明式”究竟是什么意思呢？嗯，首先，我们将确定一些关键术语。然后，让我们从这里开始迭代：
- en: A **pure function** is a function that will always return identical outputs
    for identical inputs, no matter how many times it is called. In other words, the
    function will always predictably produce the same output.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**是一个函数，无论被调用多少次，对于相同的输入总是返回相同的输出。换句话说，该函数总是可预测地产生相同的输出。'
- en: '**Declarative** refers to the use of declared functions to perform actions.
    You rely upon pure functions that can define an event flow. With RxJS, you can
    see this in the form of Observables and operators.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式**指的是使用声明的函数来执行操作。你依赖于可以定义事件流的纯函数。在 RxJS 中，你可以以 Observables 和操作符的形式看到这一点。'
- en: 'So, why should you care? Well, you should care because the declarative approach
    using RxJS operators and Observables has many advantages, namely, the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么你应该关心呢？好吧，你应该关心，因为使用 RxJS 操作符和 Observables 的声明式方法有很多优点，具体如下：
- en: It makes your code cleaner and more readable.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使你的代码更简洁、更易读。
- en: It makes your code easier to test because it is predictable.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使你的代码更容易测试，因为它具有可预测性。
- en: It makes you able to cache the stream output given a certain input, and this
    will enhance performance. We will explore this in more detail in [*Chapter 7*](B21180_07.xhtml#_idTextAnchor107),
    *Sharing Data between Angular Components*, [*Chapter 9*](B21180_09.xhtml#_idTextAnchor146),
    *Demystifying Multicasting*, and [*Chapter 10*](B21180_10.xhtml#_idTextAnchor159),
    *Boosting Performance with* *Reactive Caching*.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使你能够根据一定的输入缓存流输出，这将提高性能。我们将在[*第7章*](B21180_07.xhtml#_idTextAnchor107) *Angular组件间共享数据*、[*第9章*](B21180_09.xhtml#_idTextAnchor146)
    *揭秘多播*和[*第10章*](B21180_10.xhtml#_idTextAnchor159) *使用响应式缓存提升性能*中更详细地探讨这一点。
- en: It enables you to leverage RxJS operators and transform and combine streams
    coming from different services or even within the same service. This is what we
    will see in [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083), *Combining Streams*,
    and [*Chapter 6*](B21180_06.xhtml#_idTextAnchor097), *Transforming Streams*.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使你能够利用RxJS运算符，转换和组合来自不同服务或甚至同一服务中的流。这就是我们将在[*第5章*](B21180_05.xhtml#_idTextAnchor083)“组合流”和[*第6章*](B21180_06.xhtml#_idTextAnchor097)“转换流”中看到的内容。
- en: It helps you react easily to user interactions in order to execute an action.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以帮助你轻松响应用户交互以执行操作。
- en: 'So, more declarative means more reactive. However, be careful. This doesn’t
    mean you can’t ever call the `subscribe()` method. It is unavoidable in some situations
    to trigger the `Observable` notifier. But try to ask yourself: do I really need
    to subscribe here? Can I instead compose multiple streams together, or use RxJS
    operators, to achieve what I need without subscribing? Aside from cases where
    it is unavoidable, never use `subscribe()`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更声明式的意味着更具反应性。然而，请注意。这并不意味着你永远不能调用`subscribe()`方法。在某些情况下，触发`Observable`通知器是不可避免的。但试着问问自己：我真的需要在这里订阅吗？我能否通过组合多个流或使用RxJS运算符来实现所需的功能，而不需要订阅？除了不可避免的情况外，永远不要使用`subscribe()`。
- en: Now, let’s move to the change detection concept and see how it can improve performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向变更检测概念，看看它如何提高性能。
- en: Using the change detection strategy of OnPush
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OnPush变更检测策略
- en: The other really cool thing is that we can use the `changeDetection` strategy,
    `OnPush`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件非常酷的事情是，我们可以使用`changeDetection`策略，`OnPush`。
- en: '**Change detection** is one of the most powerful features of Angular. It is
    about detecting when the component’s data changes and then automatically re-rendering
    the view or updating the DOM to reflect that change. The default strategy of “check
    always” means that, whenever any data is mutated or changed, Angular will run
    the change detector to update the DOM. So, it is automatic until explicitly deactivated.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**变更检测**是Angular最强大的功能之一。它涉及检测组件数据何时发生变化，然后自动重新渲染视图或更新DOM以反映这种变化。默认策略“始终检查”意味着，每当任何数据被修改或更改时，Angular都会运行变更检测器来更新DOM。因此，直到明确停用，它是自动的。'
- en: 'In the `OnPush` strategy, Angular will only run the change detector when one
    of the following occurs:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnPush`策略中，Angular只有在以下情况之一发生时才会运行变更检测器：
- en: '*Condition 1*: A reference of a component’s `@Input` property changes (bear
    in mind that when the input property object is mutated directly, then the reference
    of the object will not change and, consequently, the change detector will not
    run. In this case, we should return a new reference of the property object to
    trigger the change detection).'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*条件1*：组件的`@Input`属性引用发生变化（请注意，当直接修改输入属性对象时，对象的引用不会改变，因此变更检测器不会运行。在这种情况下，我们应该返回属性对象的新引用以触发变更检测）。'
- en: '*Condition 2*: A component event handler is emitted or gets triggered.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*条件2*：组件事件处理程序被触发或发出。'
- en: '*Condition 3*: A bound Observable via the async pipe emits a new value.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*条件3*：通过异步管道绑定的Observable发出新值。'
- en: Therefore, using the `ChangeDetection` `OnPush` strategy minimizes any change
    detection cycles and will only check for changes to re-render our components in
    the preceding cases. This strategy applies to all child directives and cannot
    be overridden.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`ChangeDetection`的`OnPush`策略可以最小化任何变更检测周期，并且只有在上述情况下才会检查更改以重新渲染我们的组件。此策略适用于所有子指令，并且不能被覆盖。
- en: 'In our scenario, we only need the change detector to run if we get a new value;
    otherwise, we get useless updates. So, our scenario matches *Condition 3*. The
    good news is that we can use the change detection `onPush` strategy as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们只需要在获取新值时运行变更检测器；否则，我们会得到无用的更新。因此，我们的场景符合*条件3*。好消息是，我们可以使用变更检测的`onPush`策略，如下所示：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we remember to use the async pipe as much as possible, we will see a couple
    of advantages:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记得尽可能多地使用异步管道，我们将看到一些优点：
- en: We will make it easier to later switch from the default change detection strategy
    to `OnPush` if we need to
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要，我们将使从默认的变更检测策略切换到`OnPush`变得更加容易。
- en: We will run into fewer change detection cycles using `OnPush`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`OnPush`将减少变更检测周期。
- en: In general, using the async pipe will help you to achieve a high-performing
    UI, and it will have a lot of impact if your view is doing multiple tasks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用异步管道可以帮助你实现高性能的用户界面，如果你的视图正在执行多个任务，这将产生很大的影响。
- en: 'And here’s the output of our UI after all of that work in the chapter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有这些工作之后，以下是我们的 UI 输出：
- en: '![Figure 3.6 – An overview of the list of recipes](img/B21180_03_06.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 菜单列表概述](img/B21180_03_06.jpg)'
- en: Figure 3.6 – An overview of the list of recipes
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 菜单列表概述
- en: So, after all that, in a nutshell, using the reactive pattern for fetching data
    will improve the performance of your application, the change detection strategy,
    and the code clarity and readability. As well as that, it will make the code more
    declarative and reactive, it will make it easier to leverage RxJS operators, and
    it will make it easier to react to user actions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总结一下，使用响应式模式来获取数据将提高您应用程序的性能，改变检测策略，以及代码的清晰度和可读性。此外，它将使代码更具声明性和响应性，更容易利用
    RxJS 操作符，并更容易响应用户操作。
- en: Now that we’ve established the reactive pattern, let’s conclude this chapter
    by exploring an intriguing feature introduced in Angular 17, understanding its
    benefits, and applying it in practice within our recipe app.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了响应式模式，让我们通过探索 Angular 17 中引入的一个有趣功能来结束本章，了解其好处，并在我们的食谱应用中实际应用它。
- en: Diving into the built-in control flow in Angular 17
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 Angular 17 的内置控制流
- en: Before Angular 17, control flow within templates was predominantly managed using
    structural directives. Let’s start by exploring the structural directives.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 17 之前，模板中的控制流主要使用结构化指令来管理。让我们首先探索结构化指令。
- en: Structural directives
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化指令
- en: 'Structural directives are responsible for altering the structure of the DOM
    and orchestrating how elements are added, removed, or repeated based on certain
    conditions. Here’s the list of available directives in Angular to control the
    execution of the template:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化指令负责根据某些条件改变 DOM 的结构，并编排元素如何根据条件添加、删除或重复。以下是 Angular 中用于控制模板执行的可用指令列表：
- en: '`*ngIf`: This structural directive is used to conditionally include or exclude
    elements from the DOM based on the truthiness of an expression. For instance,
    consider the following code snippet, which displays the message `items` array
    is empty:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngIf`：这个结构化指令用于根据表达式的真值有条件地包含或排除 DOM 中的元素。例如，考虑以下代码片段，它显示消息“items”数组为空：'
- en: '[PRE22]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <ul>
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <ul>
- en: <li *ngFor="let product of products">
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <li *ngFor="let product of products">
- en: '{{ product.name }}'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ product.name }}'
- en: </li>
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </li>
- en: </ul>
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </ul>
- en: '[PRE23]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <ul>
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <ul>
- en: '<li *ngFor="let product of products; trackBy:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '<li *ngFor="let product of products; trackBy:'
- en: trackProduct">{{ product.name }}
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: trackProduct>{{ product.name }}
- en: </li>
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </li>
- en: </ul>
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </ul>
- en: '[PRE24]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'trackProduct(index: number, product: Product) {'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'trackProduct(index: number, product: Product) {'
- en: 'return product ? product.id : undefined;'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'return product ? product.id : undefined;'
- en: '}'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`ngSwitch`: This structural directive is used to conditionally include or exclude
    elements from the DOM based on the evaluated value of a provided expression. It
    is commonly used when there are multiple conditions to be evaluated. Here’s an
    example that renders different views based on user roles:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitch`：这个结构化指令用于根据提供的表达式的评估值有条件地包含或排除 DOM 中的元素。它通常在需要评估多个条件时使用。以下是一个根据用户角色渲染不同视图的示例：'
- en: '[PRE26]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we’ve explored the structural directives in Angular, which provided
    a mechanism for dynamically altering the structure of the DOM based on certain
    conditions, we can delve into the next evolution of control flow management within
    Angular templates. With the release of Angular version 17, a new paradigm emerges:
    the built-in control flow. Let’s delve into the details of this exciting new feature
    and explore how it enhances the Angular development experience.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Angular 中的结构化指令，它提供了一种根据某些条件动态改变 DOM 结构的机制，我们可以深入了解 Angular 模板中控制流管理的下一个发展阶段。随着
    Angular 版本 17 的发布，一个新的范式出现：内置控制流。让我们深入了解这个令人兴奋的新功能，并探索它是如何增强 Angular 开发体验的。
- en: Built-in control flows
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置控制流
- en: Built-in control flows offer a more concise and declarative way to manage control
    flow logic directly within your component templates, eliminating the need for
    structural directives. Here are the new built-in control flow statements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 内置控制流提供了一种更简洁、更具声明性的方式来直接在组件模板中管理控制流逻辑，消除了对结构化指令的需求。以下是新的内置控制流语句。
- en: Built-in if statement
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置if语句
- en: The `@if` statement conditionally renders content based on a Boolean expression.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`@if`语句根据布尔表达式有条件地渲染内容。'
- en: 'Let’s consider the previous example of `*ngIf`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑之前的 `*ngIf` 示例：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the new `@if` and `@else` statements, the example will now look like
    this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的`@if`和`@else`语句，示例现在将如下所示：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you may have noticed, there are differences in syntax between the two code
    blocks. The `@if` and `@else` statements replace the `*ngIf` directive and the
    `ng-template` element by providing a more intuitive and JavaScript-like syntax
    for handling conditional rendering within component templates. You can optionally
    use an `@else` statement to provide alternative content when the condition evaluates
    to false.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，两个代码块之间存在语法差异。`@if`和`@else`语句通过提供更直观且类似JavaScript的语法来处理组件模板中的条件渲染，从而替换了`*ngIf`指令和`ng-template`元素。你可以选择使用`@else`语句，当条件评估为假时提供替代内容。
- en: Furthermore, while `*ngIf` requires importing `CommonModule` to function properly,
    `@if` is a standalone statement that can be directly used within the template
    without any additional imports.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虽然`*ngIf`需要导入`CommonModule`才能正常工作，但`@if`是一个独立的语句，可以直接在模板中使用，无需任何额外的导入。
- en: 'Additionally, the `@if` block may have one or more associated `@else` blocks.
    After an `@if` block, you can optionally chain any number of `@else if` blocks
    and one `@else` block as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`@if`块可以有一个或多个相关的`@else`块。在`@if`块之后，你可以选择性地链接任意数量的`@else if`块和一个`@else`块，如下所示：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Built-in for-loop statement
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置for循环语句
- en: The `@for` statement iterates over a collection of data and renders content
    for each item.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`@for`语句遍历数据集合，并为每个项目渲染内容。'
- en: 'Let’s take the previous `*ngFor` example again:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次以之前的`*ngFor`示例为例：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using the new `@for` statement, the example will look like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的`@for`语句，示例将如下所示：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Replacing the previously optional `trackBy` function used with `*ngFor` is the
    `track` function within the `@for` statement. Both approaches serve the same core
    purpose, enabling Angular to efficiently track changes within your iterated lists
    by focusing on the unique identifier of each item rather than its position in
    the array.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 替换之前与`*ngFor`一起使用的可选`trackBy`函数的是`@for`语句中的`track`函数。两种方法都服务于相同的核心目的，即通过关注每个项目的唯一标识符而不是其在数组中的位置，使Angular能够高效地跟踪迭代列表中的更改。
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While `trackBy` was optional, its absence often led to performance issues. However,
    using `track` is now mandatory within `@for` loops, ensuring optimal rendering
    speed by default.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`trackBy`是可选的，但它的缺失往往会导致性能问题。然而，现在在`@for`循环中使用`track`是强制性的，默认确保了最佳的渲染速度。
- en: A significant advantage of `track` is its ease of use compared to `trackBy`.
    You can directly include an expression representing the unique identifier of each
    item within the template itself, eliminating the need for a separate `trackBy`
    method in your component class (`trackProduct` in the previous example). This
    streamlines your code and improves readability.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`track`的一个显著优势是，与`trackBy`相比，它易于使用。你可以在模板中直接包含一个表示每个项目唯一标识符的表达式，从而消除了在组件类（如前例中的`trackProduct`）中单独使用`trackBy`方法的需求。这简化了你的代码并提高了可读性。'
- en: 'The transition to `track` is designed to be seamless for developers who have
    already implemented `trackBy` functions and wish to migrate without removing those
    methods. They can seamlessly retain the existing methods and simply update the
    template as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已经实现了`trackBy`函数并希望迁移而不删除这些方法的开发者，`track`的过渡被设计得无缝。他们可以无缝保留现有方法，只需更新模板如下：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This ensures backward compatibility and a smooth transition process.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了向后兼容性和平滑的过渡过程。
- en: In essence, `track` offers a mandatory and simplified approach to change tracking
    within `@for` loops, promoting optimal performance and a more concise syntax in
    your Angular applications.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`track`提供了一种强制性和简化的方法来在`@for`循环中进行更改跟踪，促进了Angular应用程序中的最佳性能和更简洁的语法。
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth mentioning that the `@for` statement uses a new diffing algorithm
    and offers a more optimized implementation compared to `*ngFor`. This enhancement
    results in up to 90% faster runtime according to community framework benchmarks.
    For more information, refer to [https://krausest.github.io/js-framework-benchmark/current.html](https://krausest.github.io/js-framework-benchmark/current.html).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`@for`语句使用了一种新的diffing算法，与`*ngFor`相比提供了更优化的实现。根据社区框架基准测试，这种增强使得运行时速度提高了高达90%。更多信息，请参阅[https://krausest.github.io/js-framework-benchmark/current.html](https://krausest.github.io/js-framework-benchmark/current.html)。
- en: 'Furthermore, the built-in `@for` loop has a shortcut to deal with empty collections,
    referred to as the optional `@``empty` block:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内置的 `@for` 循环有一个快捷方式来处理空集合，称为可选的 `@empty` 块：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `@empty` block offers a convenient and efficient way to display informative
    messages or alternative content when no data is available. It promotes a better
    user experience and keeps your component logic well-organized.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`@empty` 块提供了一个方便且高效的方式来显示信息性消息或替代内容，当没有数据可用时。它促进了更好的用户体验，并使组件逻辑保持良好的组织。'
- en: 'We went into a bit of detail there, so to summarize, here are the key benefits
    of the new `@``for` statement:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在那里详细说明了，为了总结，以下是新 `@for` 语句的关键好处：
- en: The `@for` syntax offers a cleaner and more readable way to iterate over lists,
    display alternative content when no data is available, and define unique identifiers
    for the list items.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@for` 语法提供了一种更干净、更易读的方式来遍历列表，在数据不可用时显示替代内容，并为列表项定义唯一标识符。'
- en: By requiring `track`, `@for` guarantees efficient DOM updates, leading to a
    smoother user experience.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过要求 `track`，`@for` 确保了高效的 DOM 更新，从而带来了更流畅的用户体验。
- en: The `@for` loop leverages a new, optimized diffing algorithm compared to `*ngFor`.
    This has led to significant performance improvements, as evidenced by community
    benchmarks.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `*ngFor` 相比，`@for` 循环利用了一个新的、优化的 diffing 算法。这导致了显著的性能提升，正如社区基准测试所证明的那样。
- en: In essence, the `@for` statement provides an all-around upgrade for iterating
    over collections in your Angular applications. It empowers developers with a cleaner,
    more performant, and more user-friendly way to manage data within templates.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`@for` 语句为在 Angular 应用程序中遍历集合提供了一个全面的升级。它赋予开发者一个更干净、更高效、更用户友好的方式来管理模板中的数据。
- en: Built-in switch statement
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置的 switch 语句
- en: The `@switch` statement selects content based on a matching expression.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`@switch` 语句根据匹配表达式选择内容。'
- en: 'Let’s take the previous example of `*ngSwitch`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前面的 `*ngSwitch` 示例为例：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using the new `@switch` statement, it will now look like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `@switch` 语句，它现在看起来是这样的：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you may have noticed, both `@switch` and `*ngSwitch` achieve conditional
    rendering in Angular templates. However, `@switch` offers a more concise and modern
    approach that aligns better with current JavaScript practices. This syntax is
    more intuitive and closer to standard JavaScript switch statements, making code
    easier to understand and maintain.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，`@switch` 和 `*ngSwitch` 都在 Angular 模板中实现了条件渲染。然而，`@switch` 提供了一种更简洁、更现代的方法，与当前的
    JavaScript 实践更一致。这种语法更直观，更接近标准的 JavaScript switch 语句，使得代码更容易理解和维护。
- en: The `@default` block is optional and can be excluded. In the absence of a matching
    `@case` and if there’s no `@default` block provided, nothing will be displayed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`@default` 块是可选的，可以省略。如果没有提供匹配的 `@case` 块，也没有提供 `@default` 块，则不会显示任何内容。'
- en: Including built-in control flows in our recipe app
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的食谱应用中包含内置控制流
- en: Now that we’ve learned about the new built-in control flow, let’s take advantage
    of it and update our template code with this new syntax.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了新的内置控制流，让我们利用它并使用这种新语法更新我们的模板代码。
- en: 'The HTML code of our `RecipesListComponent.html` file uses the Angular structural
    directives `*ngIf` (used to conditionally render the data view when the `recipes$`
    Observable returns a value) and `*ngFor` (used to iterate over the list of recipes
    and render a card for each recipe). Here is the code snippet:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `RecipesListComponent.html` 文件的 HTML 代码使用了 Angular 结构性指令 `*ngIf`（用于在 `recipes$`
    可观察对象返回值时条件性地渲染数据视图）和 `*ngFor`（用于遍历食谱列表并为每个食谱渲染一张卡片）。以下是代码片段：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let’s update this code using the new built-in control flow:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用新的内置控制流来更新这段代码：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We replaced `*ngIf` with `@if` to conditionally render the data view when the
    `recipes$` Observable returns a value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 `@if` 替换了 `*ngIf`，以便在 `recipes$` 可观察对象返回值时条件性地渲染数据视图。
- en: We also replaced `*ngFor` with `@for` to iterate over the list of recipes and
    render a card for each recipe. We included within the `@for` statement the track
    function, `track recipe.id`. The recipe’s ID is the unique identifier of the recipe.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还用 `@for` 替换了 `*ngFor` 来遍历食谱列表并为每个食谱渲染一张卡片。我们在 `@for` 语句中包含了跟踪函数，`track recipe.id`。食谱的
    ID 是食谱的唯一标识符。
- en: We now have a refreshed template that not only is more performant but also aligns
    seamlessly with the latest version of Angular.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个更新的模板，它不仅性能更优，而且与 Angular 的最新版本无缝对接。
- en: 'Additionally, if you have existing projects, you can easily migrate them to
    leverage the new built-in flow syntax by using the following migration schematic:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您有现有项目，您可以通过使用以下迁移图轻松地将它们迁移到利用新的内置流语法：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Benefits of built-in control flow
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置控制流的优点
- en: 'There are several benefits to using Angular’s built-in control flow syntax,
    as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular的内置控制流语法有几个优点，如下所述：
- en: '*Improved readability*: The syntax aligns more closely with JavaScript, making
    the code easier to understand and maintain.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高可读性*：语法更接近JavaScript，使代码更容易理解和维护。'
- en: '*Reduced boilerplate*: You can remove the need for separate directive imports
    and properties.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*减少样板代码*：您可以消除对单独指令导入和属性的依赖。'
- en: '*Built-in availability*: No additional imports are required; the feature is
    readily available out of the box in your templates.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内置可用性*：无需额外导入；该功能在模板中开箱即用。'
- en: '*Enhanced type safety*: The compiler provides more robust type narrowing, resulting
    in improved type safety and error detection.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*增强的类型安全性*：编译器提供了更稳健的类型缩小，从而提高了类型安全性和错误检测。'
- en: '*Performance improvements*: While performance improvements can vary depending
    on your application’s structure and data size, the `@for` statement utilizes a
    more streamlined diffing algorithm compared to `*ngFor`. This can potentially
    lead to smoother rendering and a better user experience, especially when dealing
    with large or frequently updated lists.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能提升*：虽然性能提升可能因您的应用程序结构和数据大小而异，但`@for`语句相较于`*ngFor`使用了一个更优化的diffing算法。这可能导致渲染更加流畅，用户体验更好，尤其是在处理大型或频繁更新的列表时。'
- en: In short, the built-in control flow syntax fosters a more intuitive, concise,
    and performant approach to writing Angular templates. It promotes code readability,
    reduces boilerplate, and offers enhanced type safety.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，内置控制流语法促进了编写Angular模板的更直观、简洁和高效的方法。它促进了代码可读性，减少了样板代码，并提供了增强的类型安全性。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the classic and reactive patterns for fetching
    data. We learned about the imperative way in which to manage unsubscriptions and
    the reactive pattern. We explained some useful RxJS operators, and also shed light
    on the advantages of using the reactive pattern and learned about all the technical
    aspects around it. We also learned about standalone components, a new edition
    to Angular, as well as how to create them, and what their benefits are. Lastly,
    we delved into the new built-in control flow introduced in Angular 17, covering
    its various applications, syntax, and associated benefits.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了获取数据的经典和响应式模式。我们学习了如何以命令式方式管理取消订阅和响应式模式。我们解释了一些有用的RxJS操作符，并阐明了使用响应式模式的优点以及与之相关的所有技术方面。我们还学习了独立组件，这是Angular的新增功能，以及如何创建它们以及它们的优点。最后，我们深入探讨了Angular
    17中引入的新内置控制流，涵盖了其各种应用、语法和相关的优点。
- en: Now that we have retrieved our data as RxJS streams, in the next chapters, let’s
    start playing with those streams to react to user actions using RxJS streams and,
    consequently, build our `RecipesApp` application in a reactive way. In the next
    chapter, we will focus on the reactive patterns for error handling and the different
    strategies that are available.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据作为RxJS流检索，在接下来的章节中，让我们开始使用RxJS流来响应用户操作，从而以响应式的方式构建我们的`RecipesApp`应用程序。在下一章中，我们将关注错误处理的响应式模式以及可用的不同策略。
