- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Caching Strategies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存策略
- en: '“*There are only two hard things in computer science: cache invalidation and
    naming things.*” – Phil Karlton'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “*在计算机科学中，只有两件难事：缓存失效和命名事物。*” – Phil Karlton
- en: Caching can significantly enhance a website’s performance by eliminating or
    shortening network roundtrips and reusing previously stored data and content.
    However, caching is also hard to get right. As usual, Remix provides a thin abstraction
    layer on top of the web platform and eases the usage of HTTP caching strategies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可以通过消除或缩短网络往返次数以及重用先前存储的数据和内容，显著提高网站的性能。然而，缓存也难以正确设置。通常，Remix在Web平台之上提供了一个薄薄的抽象层，简化了HTTP缓存策略的使用。
- en: 'In this chapter, we will learn about different caching strategies and how to
    utilize them with Remix. This chapter is divided into two sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解不同的缓存策略以及如何利用Remix来使用它们。本章分为两个部分：
- en: Working with HTTP caching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与HTTP缓存一起工作
- en: Exploring in-memory caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索内存缓存
- en: First, we will learn about HTTP caching. We will study different HTTP caching
    headers and see how we can utilize HTTP caching in the browser and with CDNs.
    Next, we will focus on in-memory caching. We will refer to [*Chapter 3*](B17399_03.xhtml#_idTextAnchor043),
    *Deployment Targets, Adapters, and Stacks*, to understand when and where we can
    cache data in memory. We will also discuss using services such as Redis to cache
    data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将了解HTTP缓存。我们将研究不同的HTTP缓存头部，并了解如何在浏览器和CDN中利用HTTP缓存。接下来，我们将关注内存缓存。我们将参考[*第3章*](B17399_03.xhtml#_idTextAnchor043)，*部署目标、适配器和堆栈*，了解何时何地可以在内存中缓存数据。我们还将讨论使用Redis等服务来缓存数据。
- en: After reading this chapter, you will understand how to utilize caching with
    Remix to improve the user experience. You will have also practiced working with
    HTTP headers and know when to use different caching strategies, such as CDN, browser,
    **entity tags** (**ETags**), and in-memory caching.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将了解如何利用Remix进行缓存以改善用户体验。您还将练习使用HTTP头部，并了解何时使用不同的缓存策略，例如CDN、浏览器、**实体标签**（**ETags**）和内存缓存。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/12-caching-strategies](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/12-caching-strategies).
    You can go ahead and use the end solution from the previous chapter. No additional
    setup steps are required for this chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/12-caching-strategies](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/12-caching-strategies)。您可以继续使用上一章的最终解决方案。本章不需要额外的设置步骤。
- en: Working with HTTP caching
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与HTTP缓存一起工作
- en: The web platform utilizes HTTP headers to control caching behavior. Web clients
    can read caching directives specified in response headers to reuse previously
    fetched data. This allows web clients to avoid unnecessary network requests and
    improve response times. In this section, you will learn about popular HTTP caching
    headers and strategies and how to use them in Remix. First, we will see how we
    can define HTTP headers for document responses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Web平台使用HTTP头部来控制缓存行为。Web客户端可以读取响应头部中指定的缓存指令，以重用先前获取的数据。这允许Web客户端避免不必要的网络请求并提高响应时间。在本节中，您将了解流行的HTTP缓存头部和策略，以及如何在Remix中使用它们。首先，我们将看到如何为文档响应定义HTTP头部。
- en: Adding HTTP headers in Remix
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Remix中添加HTTP头部
- en: Remix’s route module API includes a `headers` export that we can use to add
    HTTP headers to the route’s document response. Like the `links` function, the
    `headers` function is only ever executed on the server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Remix的route模块API包括一个`headers`导出，我们可以用它来向路由的文档响应添加HTTP头部。像`links`函数一样，`headers`函数仅在服务器上执行。
- en: The `headers` function is called after all `loader` functions and all parent
    `headers` functions. The `headers` function has access to the `parentsHeaders`,
    `errorHeaders`, `actionHeaders`, and `loaderHeaders` objects to update document
    headers based on the headers added via parent `header` functions, loader data
    responses, action data responses, and error responses. Remix utilizes the most
    deeply exported `headers` function available and allows you to mix and merge the
    headers as required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers`函数在所有`loader`函数和所有父`headers`函数之后被调用。`headers`函数可以访问`parentsHeaders`、`errorHeaders`、`actionHeaders`和`loaderHeaders`对象，根据通过父`header`函数、loader数据响应、action数据响应和错误响应添加的头部来更新文档头部。Remix利用可用的最深导出的`headers`函数，并允许您按需混合和合并头部。'
- en: Loader data-based cache control
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基于加载器数据的缓存控制
- en: Remix’s `headers` function receives the `loaderHeaders` parameter, which allows
    us to specify caching directives for each route based on the loader data for fine-grained
    cache control.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的 `headers` 函数接收 `loaderHeaders` 参数，这允许我们根据加载器数据为每个路由指定缓存指令，以实现细粒度的缓存控制。
- en: Now that we have a theoretical understanding of how to apply HTTP headers with
    Remix, let’s run through our BeeRich routes to investigate how to utilize caching.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从理论上了解了如何使用 Remix 应用 HTTP 头部，让我们运行我们的 BeeRich 路由来调查如何利用缓存。
- en: Caching public pages in shared caches
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在共享缓存中缓存公共页面
- en: Public pages without user-specific information can be stored in a shared cache
    such as a CDN. Adding a CDN in front of your (Remix) web server distributes cached
    content globally and closer to your users. It reduces the request response time
    for cached content and the number of requests the web server has to process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特定于用户信息的公共页面可以存储在共享缓存中，如 CDN。在你的（Remix）网络服务器前添加 CDN 可以在全球范围内以及更接近用户的地方分发缓存内容。它减少了缓存内容的请求响应时间以及网络服务器需要处理的请求数量。
- en: 'If you aren’t sure what a CDN is, the MDN Web Docs provide a great introduction:
    [https://developer.mozilla.org/en-US/docs/Glossary/CDN](https://developer.mozilla.org/en-US/docs/Glossary/CDN).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定 CDN 是什么，MDN Web Docs 提供了一个很好的介绍：[https://developer.mozilla.org/en-US/docs/Glossary/CDN](https://developer.mozilla.org/en-US/docs/Glossary/CDN)。
- en: In this section, we will use Remix’s `headers` route module API to add HTTP
    caching headers to our public pages on BeeRich.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Remix 的 `headers` 路由模块 API 为 BeeRich 的公共页面添加 HTTP 缓存头部。
- en: BeeRich consists of public and private routes. The public pages are nested inside
    the `_layout` segment and include the BeeRich home page (`_layout._index.tsx`)
    and the login and signup pages. We can identify that these pages are static and
    do not depend on user-specific data. We’re okay if the user occasionally sees
    a stale page version. We can specify HTTP headers so that we keep serving a cached
    version of the page for one hour before requesting a new version.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: BeeRich 由公共和私有路由组成。公共页面嵌套在 `_layout` 段中，包括 BeeRich 主页 (`_layout._index.tsx`)
    以及登录和注册页面。我们可以确定这些页面是静态的，并且不依赖于特定于用户的数据。如果用户偶尔看到过时的页面版本，我们是可以接受的。我们可以指定 HTTP 头部，以便在请求新版本之前，我们继续为页面提供缓存版本，时间为一个小时。
- en: 'Let’s see what this would look like in action. Add the following `headers`
    function export to the `_layout.tsx` pathless layout route module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这会是什么样子。将以下 `headers` 函数导出添加到 `_layout.tsx` 路径无布局路由模块中：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With these changes, we apply a caching header to all child routes that do not
    themselves export a `headers` function. The specified caching header includes
    a `public` value and a `max-age` directive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们将缓存头应用于所有不自身导出 `headers` 函数的子路由。指定的缓存头包括 `public` 值和 `max-age` 指令。
- en: The `max-age` directive defines the number of seconds the available response
    can be reused before it must be regenerated. This means the nested routes, such
    as `/`, `/login`, and `/signup`, are now cached for 3,600 seconds (1 hour).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`max-age` 指令定义了可用响应在必须重新生成之前可以重用的秒数。这意味着嵌套路由，如 `/`、`/login` 和 `/signup`，现在被缓存了
    3,600 秒（1 小时）。'
- en: The `public` value communicates that the response data can be stored in a public
    cache. We can differentiate between public (shared) and private caches. Private
    caches exist on web clients (for example, browsers), while shared caches live
    on proxy services and CDNs. By specifying that a document can be cached publicly,
    we also allow proxies and CDNs to cache the document for all future requests.
    This means the cache not only serves one browser (user) but may improve the response
    times for any subsequent user requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 值表示响应数据可以存储在公共缓存中。我们可以区分公共（共享）和私有缓存。私有缓存存在于网络客户端（例如，浏览器）中，而共享缓存存在于代理服务和
    CDN 上。通过指定文档可以公开缓存，我们也允许代理和 CDN 为所有未来的请求缓存文档。这意味着缓存不仅服务于一个浏览器（用户），还可能提高后续用户请求的响应时间。'
- en: 'Let’s investigate this caching behavior:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查这种缓存行为：
- en: Run `npm run dev` in the root of the project.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中运行 `npm run dev`。
- en: Next, open the login page in a new browser window ([http://localhost:3000](http://localhost:3000)).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在新的浏览器窗口中打开登录页面 ([http://localhost:3000](http://localhost:3000))。
- en: Open the developer tools of your browser and navigate to the **Network** tab.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器的开发者工具并导航到 **网络** 选项卡。
- en: Make sure you uncheck the **Disable cache** option if it’s checked.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已勾选，请确保取消勾选 **禁用缓存** 选项。
- en: 'Now, hard-refresh the page to emulate an initial page load:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，强制刷新页面以模拟初始页面加载：
- en: '![Figure 12.1 – Initial page load of the login page](img/Figure_12.01_B17399.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 登录页面初始加载](img/Figure_12.01_B17399.jpg)'
- en: Figure 12.1 – Initial page load of the login page
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 登录页面初始加载
- en: Notice that the specified caching header is returned as part of the response
    headers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，指定的缓存头作为响应头的一部分返回。
- en: Refresh the page again; you may see that the document was restored from the
    disk cache. Some browsers disable document request caching headers on localhost
    for a better developer experience. So, don’t worry if you can’t seem to make it
    work on localhost.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次刷新页面；你可能看到文档是从磁盘缓存中恢复的。一些浏览器为了更好的开发者体验，禁用了localhost上的文档请求缓存头。所以，如果你在localhost上似乎无法使其工作，请不要担心。
- en: Be cautious not to publicly cache documents with user-specific information.
    While CDNs often automatically remove `Set-Cookie` headers, you likely want to
    avoid caching altogether when a user session cookie is in the server's response.
    If you're using a CDN, make sure to cache only for visitors, not logged-in users,
    to avoid caching conditionally rendered UIs for logged-in users. For example,
    the navigation bar in `_layout.tsx` shows a Logout button if a user is logged
    in. Caching this could cause layout shifts when the `Logout` button is replaced
    by `Log in` and `Sign up` after React hydrates on the client and re-renders the
    page.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎不要公开缓存包含用户特定信息的文档。虽然CDN通常会自动删除`Set-Cookie`头，但当你希望服务器响应中包含用户会话cookie时，你很可能想完全避免缓存。如果你正在使用CDN，请确保只为访客缓存，而不是已登录用户，以避免为已登录用户缓存条件渲染的UI。例如，`_layout.tsx`中的导航栏在用户登录时会显示“注销”按钮。缓存这可能会导致React在客户端进行水合和重新渲染页面后，将“注销”按钮替换为“登录”和“注册”时布局发生变化。
- en: Let’s investigate how Remix uses HTTP caching headers for the public assets
    of our pages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查Remix如何为我们页面的公共资源使用HTTP缓存头。
- en: Understanding Remix’s built-in caching
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Remix的内置缓存
- en: Remix optimizes many of the served assets out of the box. In this section, we
    will review how Remix utilizes HTTP caching headers on static assets to optimize
    our app’s performance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Remix默认优化了许多服务资源。在本节中，我们将回顾Remix如何利用静态资源的HTTP缓存头来优化我们应用程序的性能。
- en: 'Follow the steps from the previous section to open the login page of BeeRich
    in a browser window. Click on any downloaded JavaScript bundles in the **Network**
    tab and review the response headers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一节的步骤，在浏览器窗口中打开BeeRich的登录页面。在**网络**标签中单击任何下载的JavaScript包，并检查响应头：
- en: '![Figure 12.2 – Remix’s built-in caching behavior](img/Figure_12.02_B17399.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – Remix的内置缓存行为](img/Figure_12.02_B17399.jpg)'
- en: Figure 12.2 – Remix’s built-in caching behavior
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – Remix的内置缓存行为
- en: 'As visible in *Figure 12**.2*, the `manifest-*.js` file was retrieved from
    the browser’s memory or disk cache. Remix adds a cache control header to each
    JavaScript bundle (`Cache-Control: public, max-age=31536000, immutable`). Each
    JavaScript bundle is defined to be publicly cached for up to one year – the maximum
    possible `max-age` value. The `immutable` directive further indicates that the
    content of the assets never changes, which helps us avoid potential revalidation
    requests.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '如*图12.2*所示，`manifest-*.js`文件是从浏览器的内存或磁盘缓存中检索的。Remix为每个JavaScript包添加了缓存控制头（`Cache-Control:
    public, max-age=31536000, immutable`）。每个JavaScript包被定义为公开缓存，最多可达一年——这是可能的`max-age`值的最大值。`immutable`指令进一步表明资源内容永远不会改变，这有助于我们避免潜在的重新验证请求。'
- en: Next, review the `tailwind.css` stylesheet from the `root.ts` file’s `links`
    export. Compare the cache control header of the linked stylesheet and the JavaScript
    bundles. They match!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查`root.ts`文件中`links`导出的`tailwind.css`样式表。比较链接样式表和JavaScript包的缓存控制头。它们匹配！
- en: Finally, review the names of the static assets. Notice that all JavaScript bundles
    and linked assets include a hash postfix. The hash is computed based on the content
    of the asset. Any time we update any assets, a new version is created. The hash
    ensures that there are never two assets with the same name but different content.
    This allows Remix to allow clients to cache each asset indefinitely.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，检查静态资源的名称。注意，所有JavaScript包和链接资源都包含一个哈希后缀。哈希是根据资源内容计算的。每次我们更新任何资源时，都会创建一个新的版本。哈希确保不会有两个名称相同但内容不同的资源。这允许Remix允许客户端无限期地缓存每个资源。
- en: Remix’s built-in HTTP caching
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Remix内置的HTTP缓存
- en: Hash-based filenames of static assets ensure that new versions automatically
    result in new assets. This allows Remix to add aggressive caching directives to
    all linked assets returned from the `links` route module API. Remix adds the same
    directives to all its JavaScript bundles.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 静态资产的基于哈希的文件名确保新版本自动产生新资产。这允许 Remix 向 `links` 路由模块 API 返回的所有链接资产添加积极的缓存指令。Remix
    将相同的指令添加到所有其 JavaScript 打包中。
- en: The aggressive caching directives used by Remix allow browsers and CDNs to cache
    all static assets of your Remix app. This can significantly improve performance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 使用的积极缓存指令允许浏览器和 CDN 缓存你的 Remix 应用程序的所有静态资产。这可以显著提高性能。
- en: Next, we will discuss how to cache personalized pages and content.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何缓存个性化页面和内容。
- en: Caching personalized pages in private caches
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在私有缓存中缓存个性化页面
- en: Controlling HTTP caching is not only about caching responses but also about
    controlling when not to cache. Remix offers full control over what should be cached
    by providing access to the `Response` object of each document and data request.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 控制HTTP缓存不仅关乎缓存响应，还关乎控制何时不缓存。Remix 通过提供对每个文档和数据请求的 `Response` 对象的访问，提供了对应该缓存什么的完全控制。
- en: The `dashboard` routes of BeeRich are personalized pages that are made up of
    user-specific data. User-specific data must not be stored in a shared cache to
    avoid leakage of private user information. The content on the `dashboard` routes
    is highly dynamic, and we should only cache it briefly to avoid stale UI states.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: BeeRich 的 `dashboard` 路由是包含用户特定数据的个性化页面。用户特定数据不得存储在共享缓存中，以避免泄露私人用户信息。`dashboard`
    路由上的内容高度动态，我们应该只短暂缓存它，以避免过时的 UI 状态。
- en: 'Let’s utilize the `no-cache` and `private` directives on the `dashboard.tsx`
    route to apply a default for all `dashboard` routes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用 `dashboard.tsx` 路由上的 `no-cache` 和 `private` 指令为所有 `dashboard` 路由应用默认设置：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The added cache control header specifies that the HTML documents on the `dashboard`
    routes can only be cached in private caches (for example, the browser) and that
    any request should go to the server for revalidation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的缓存控制头指定，`dashboard` 路由上的 HTML 文档只能缓存在私有缓存中（例如，浏览器），并且任何请求都应该发送到服务器进行重新验证。
- en: Note that the `no-cache` directives still allow the browser to reuse content
    when using the browser's back and forward buttons. This is different from `no-store`,
    which forces the browser to fetch new content even during back and forward navigation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`no-cache` 指令仍然允许在浏览器使用后退和前进按钮时重用内容。这与 `no-store` 不同，后者即使在后退和前进导航期间也会强制浏览器获取新内容。
- en: Great – we've now learned how to apply caching headers to document responses.
    But how about `loader` and `action` data responses?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了 – 我们现在已经学会了如何将缓存头应用于文档响应。但关于 `loader` 和 `action` 数据响应呢？
- en: Caching immutable data responses
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存不可变数据响应
- en: In Remix, we can also control HTTP headers for data responses from `loader`
    and `action` functions. Thus, we can set caching controls not only for documents
    but also for data responses.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Remix 中，我们还可以控制来自 `loader` 和 `action` 函数的数据响应的 HTTP 头部。因此，我们不仅可以设置文档的缓存控制，还可以设置数据响应的缓存控制。
- en: Most of the data in BeeRich is highly dynamic. The invoice and expense data
    can be edited and must always be fresh. However, this is different for the expense
    and invoice attachments. Each attachment has a unique filename (identifier), which
    is part of the request URL. Conclusively, two attachments are never served via
    the same URL.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: BeeRich 中的大部分数据都是高度动态的。发票和费用数据可以编辑，并且必须始终是最新的。然而，费用和发票附件的情况不同。每个附件都有一个唯一的文件名（标识符），它是请求
    URL 的一部分。最终，两个附件永远不会通过相同的 URL 提供服务。
- en: 'Let’s update the attachment logic in BeeRich to take advantage of HTTP caching:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 BeeRich 中的附件逻辑，以利用 HTTP 缓存：
- en: 'First, update the `buildFileResponse` function in `app/modules/attachments.server.ts`
    so that it supports passing in custom headers:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新 `app/modules/attachments.server.ts` 中的 `buildFileResponse` 函数，以便它支持传递自定义头部：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, update the `loader` function in the `dashboard.expenses.$id.attachments.$.tsx`
    resource route module:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `dashboard.expenses.$id.attachments.$.tsx` 资源路由模块中的 `loader` 函数：
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Start BeeRich by executing `npm run dev` and, in your browser, navigate to an
    expense details page.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `npm run dev` 启动 BeeRich，并在浏览器中导航到费用详情页面。
- en: 'Next, download an attachment twice and inspect the second network payload in
    the **Network** tab:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载附件两次，并在 **网络** 选项卡中检查第二次网络有效载荷：
- en: '![Figure 12.3 – Attachment cached on disk](img/Figure_12.03_B17399.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 存储在磁盘上的附件](img/Figure_12.03_B17399.jpg)'
- en: Figure 12.3 – Attachment cached on disk
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.3 – 附件已缓存到磁盘**'
- en: Great! As visible in *Figure 12**.3*, we avoided a request to the web server
    for the second download request. Instead, the attachment was downloaded from the
    disk cache of the browser.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如**图12.3**.3所示，我们避免了在第二次下载请求中对Web服务器的请求。相反，附件是从浏览器的磁盘缓存中下载的。
- en: Caching is hard, especially when you’re trying to cache user-specific data.
    Can you think of any potential security concerns with the current implementation?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存很困难，尤其是当你试图缓存特定于用户的数据时。你能想到当前实现中任何潜在的安全问题吗？
- en: Imagine a user logging in to BeeRich from a public computer to access expense
    attachments. The user downloads one of the attachments to print it. The user then
    deletes the attachment from the public computer and logs themselves out from BeeRich.
    Now, could a malicious actor retrieve the attachment from the browser cache? Potentially.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个用户从公共电脑登录BeeRich以访问费用附件。用户下载其中一个附件以打印它。然后，用户从公共电脑删除附件并从BeeRich注销。现在，恶意行为者能否从浏览器缓存中检索附件？有可能。
- en: Copy and paste the **Request URL** property to your attachment from the **Headers**
    **Network** tab. Now, log out from BeeRich to be redirected to the login page.
    Copy and paste the copied request URL into the address bar and hit *Enter*. Since
    we allow the browser to cache the document on its private disk cache, the request
    will not go to the resource route where we would authenticate the user. Instead,
    the browser retrieves the document from the memory or disk cache and serves it
    to the user, a potential security vulnerability.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将**请求URL**属性从**Headers** **Network**选项卡复制并粘贴到你的附件中。现在，从BeeRich注销，将被重定向到登录页面。将复制的请求URL粘贴到地址栏并按*Enter*。由于我们允许浏览器将其文档缓存到其私有磁盘缓存中，请求将不会发送到我们会验证用户的资源路由。相反，浏览器从内存或磁盘缓存中检索文档并将其提供给用户，这是一个潜在的安全漏洞。
- en: In this section, you learned about the potential security risks of leaking user
    data using private and public cache control directives. We can use a different
    caching strategy instead of caching private data in the browser cache. Next, we
    will have a look at entity tags.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了使用私有和公共缓存控制指令泄露用户数据的潜在安全风险。我们可以使用不同的缓存策略，而不是在浏览器缓存中缓存私有数据。接下来，我们将探讨实体标签。
- en: Caching dynamic data responses with entity tags
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用实体标签缓存动态数据响应
- en: An HTTP request for a document can result in different HTTP responses. A response
    with status code 200 usually includes an HTTP body containing the requested document
    – for instance, an HTML document, PDF, or image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对文档的HTTP请求可能导致不同的HTTP响应。状态码为200的响应通常包含包含请求文档的HTTP主体 - 例如，HTML文档、PDF或图像。
- en: The HTTP request-response flow allows us to authorize user access and potentially
    turn down requests with 401 (Unauthorized) responses. In the previous section,
    we cached data in private and shared caches, which cuts the request-response flow
    short from reaching our server on a cache hit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求-响应流允许我们授权用户访问，并可能通过401（未授权）响应拒绝请求。在上一个章节中，我们在私有和共享缓存中缓存了数据，这缩短了请求-响应流，使其在缓存命中时无法到达我们的服务器。
- en: In this section, we will explore how to utilize the `ETag` and `If-None-Match`
    headers so that we can avoid resending full responses but still execute authorization
    functions on the server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何利用`ETag`和`If-None-Match`头，这样我们就可以避免重新发送完整的响应，但仍然在服务器上执行授权功能。
- en: The `ETag` header may carry a unique identifier (entity tag) for a response,
    which the client can use to append subsequent requests to the same URL with the
    `If-None-Match` header. The server can then compute the new response and compare
    the new tag with the request `If-None-Match` header.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ETag`头可能携带一个用于响应的唯一标识符（实体标签），客户端可以使用它将带有`If-None-Match`头的后续请求附加到相同的URL。然后，服务器可以计算新的响应并将新标签与请求的`If-None-Match`头进行比较。'
- en: 'Let’s update the `loader` function in the `dashboard.expenses.$id.attachments.$.tsx`
    resource route module to see how this looks like in action:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`dashboard.expenses.$id.attachments.$.tsx`资源路由模块中的`loader`函数，看看它在实际操作中的样子：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use the attachment identifier as the entity tag and append it to the response
    headers. If a client requests the same attachment twice, we can access the previously
    sent `ETag` header through the `If-None-Match` request header.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用附件标识符作为实体标签并将其附加到响应头中。如果客户端两次请求相同的附件，我们可以通过`If-None-Match`请求头访问之前发送的`ETag`头。
- en: After authorizing the user in the `loader` function, we can check whether the
    request contains an `If-None-Match` header. In that case, we can communicate to
    the client that there has been no change to the response using the 304 status
    code. The client can then use the cached response body instead of redownloading
    the attachment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loader` 函数中授权用户后，我们可以检查请求是否包含 `If-None-Match` 标头。在这种情况下，我们可以通过使用 304 状态码通知客户端响应没有变化。然后客户端可以使用缓存的响应体而不是重新下载附件。
- en: 'Investigate the new implementation by repeating the steps from the previous
    sections to download the same attachment twice. Note that your browser’s guest
    and incognito modes reset caches on each session, which makes them great tools
    for testing initial page load times:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重复前几节中的步骤来调查新的实现，下载相同的附件两次。请注意，你的浏览器的访客和隐身模式会在每个会话中重置缓存，这使得它们成为测试初始页面加载时间的优秀工具：
- en: '![Figure 12.4 – ETag-based caching of attachments](img/Figure_12.04_B17399.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 基于ETag的附件缓存](img/Figure_12.04_B17399.jpg)'
- en: Figure 12.4 – ETag-based caching of attachments
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 基于ETag的附件缓存
- en: As visible in *Figure 12**.4*, any subsequent download of the attachment now
    triggers a request that receives a 304 response. When inspecting the `ETag` (response)
    and `If-None-Match` (request) headers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 12**.4*所示，任何后续的附件下载现在都会触发一个收到 304 响应的请求。当检查 `ETag`（响应）和 `If-None-Match`（请求）标头时。
- en: Finally, copy the **Request URL** property and log out. Now, attempt to access
    the attachment by navigating to the request URL. Notice that BeeRich redirects
    to the login page. This is because ETag-based caching triggers a request to the
    server. The server then checks for the session cookie and redirects accordingly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，复制**请求 URL**属性并登出。现在，通过导航到请求 URL 来尝试访问附件。注意，BeeRich 会重定向到登录页面。这是因为基于 ETag
    的缓存触发了对服务器的请求。服务器随后检查会话cookie并根据情况重定向。
- en: ETags come with a different set of trade-offs. When using ETags to revalidate
    content, we can’t avoid the roundtrip to the web server, but we can still avoid
    downloading the same response body twice. This serves as a good middle ground
    as we can execute authorization and authentication functions on the server but
    also improve performance by reusing existing response bodies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ETags 带有一套不同的权衡。当使用 ETags 来重新验证内容时，我们无法避免往返于 Web 服务器，但我们仍然可以避免下载相同的响应体两次。这作为一个良好的折衷方案，因为我们可以在服务器上执行授权和身份验证功能，同时通过重用现有的响应体来提高性能。
- en: 'Great! We implemented three HTTP caching strategies in BeeRich: public caching
    of public pages, no caching for the dynamic dashboard pages, and ETags for private
    static assets. You also learned how Remix uses HTTP caching for static assets
    out of the box.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们在 BeeRich 中实现了三种 HTTP 缓存策略：公共页面的公共缓存、动态仪表板页面的无缓存，以及私有静态资产的 ETags。你还学习了
    Remix 如何默认使用 HTTP 缓存静态资产。
- en: Ensure you update the `dashboard.income.$id.attachments.$.tsx` resource route
    to take advantage of ETag-based caching for invoice attachments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你更新了 `dashboard.income.$id.attachments.$.tsx` 资源路由，以便利用基于 ETag 的缓存进行发票附件。
- en: HTTP caching has much to offer. In this chapter, you learned about a few common
    strategies, but there are many more, such as stale-while-revalidate caching strategies.
    Refer to the *Further reading* section for more information about HTTP caching
    strategies.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 缓存有很多优点。在本章中，你了解了一些常见的策略，但还有很多其他的策略，例如过时但可验证的缓存策略。有关 HTTP 缓存策略的更多信息，请参阅*进一步阅读*部分。
- en: Next, let’s discuss how to utilize caching on our Remix server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何在 Remix 服务器上利用缓存。
- en: Exploring in-memory caching
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索内存缓存
- en: Caching effectiveness increases the closer the cache is to the users. In-browser
    caching avoids network requests altogether. CDN-based caching can significantly
    shorten network requests. However, we may also give up more control over the cache
    the further it is away from our Remix server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的有效性随着缓存与用户距离的接近而提高。浏览器内缓存可以完全避免网络请求。基于 CDN 的缓存可以显著缩短网络请求。然而，我们可能也会放弃更多对缓存的控制，如果它离我们的
    Remix 服务器越远。
- en: In this section, we will discuss in-memory caching strategies and learn about
    the advantages and disadvantages of in-memory caching options.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论内存缓存策略，并了解内存缓存选项的优缺点。
- en: HTTP caching might not always be the right strategy. For instance, we already
    discussed privacy issues when caching user-specified information. In some cases,
    it might make sense to implement a custom caching layer on the web server.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP缓存可能并不总是正确的策略。例如，我们已经讨论了在缓存用户指定信息时的隐私问题。在某些情况下，在Web服务器上实现自定义缓存层可能是有意义的。
- en: The easiest way is to store computation results or fetched responses in memory
    on the server itself. However, as we learned in [*Chapter 3*](B17399_03.xhtml#_idTextAnchor043),
    *Deployment Targets, Adapters, and Stacks*, this may not always be possible. Runtime
    environments such as the edge and serverless may shut down after every request
    and may not be capable of sharing memory between requests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是将计算结果或获取的响应存储在服务器本身的内存中。然而，正如我们在[*第3章*](B17399_03.xhtml#_idTextAnchor043)，“部署目标、适配器和堆栈”中学习的那样，这并不总是可能的。运行时环境，如边缘和无服务器，可能在每个请求后关闭，并且可能无法在请求之间共享内存。
- en: In BeeRich, we utilize a long-running Express.js server. Long-running environments
    are capable of sharing memory between requests. Hence, we can use our server’s
    memory to cache data. Caching data in memory allows us to avoid database queries
    and downstream fetch requests. Caching data in memory is a great way to improve
    performance. However, we must also consider memory limitations and overflows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在BeeRich中，我们使用了一个长期运行的Express.js服务器。长期运行的环境能够在请求之间共享内存。因此，我们可以使用服务器的内存来缓存数据。在内存中缓存数据可以让我们避免数据库查询和下游的获取请求。在内存中缓存数据是提高性能的绝佳方式。然而，我们也必须考虑内存限制和溢出问题。
- en: Alternatively, we can utilize services such as Redis, low-latency in-memory
    databases, to store computation or fetch results. Utilizing Redis as a cache is
    also a great solution when running on serverless or edge runtimes, where memory
    might not be shared between requests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以利用像Redis这样的低延迟内存数据库服务来存储计算或获取结果。当在无服务器或边缘运行时使用Redis作为缓存也是一个很好的解决方案，在这些环境中，请求之间可能无法共享内存。
- en: But what about BeeRich? BeeRich utilizes a SQLite database, which provides very
    fast responses for simple queries (a few milliseconds). Using Redis would likely
    not improve the performance as it would introduce a network request to the Redis
    server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于BeeRich呢？BeeRich使用SQLite数据库，它为简单的查询提供了非常快的响应（几毫秒）。使用Redis可能不会提高性能，因为它会引入对Redis服务器的网络请求。
- en: Unfortunately, in the real world, database and API requests may be much slower.
    In these cases, it may make sense to cache the results in Redis or in-memory on
    the server to reuse fetched results and avoid subsequent slow requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在现实世界中，数据库和API请求可能要慢得多。在这些情况下，将结果缓存到Redis或服务器内存中以重用获取的结果并避免后续缓慢的请求可能是有意义的。
- en: One great example is our user object. We fetch the user object on every incoming
    request in the `root.tsx loader` function. We can identify that we read the user
    object disproportionally more often than updating it. If responses become slow,
    this may be a good indication to store the user object in an in-memory cache.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是我们的用户对象。我们在`root.tsx loader`函数中为每个进入的请求获取用户对象。我们可以确定我们读取用户对象的频率远高于更新它。如果响应变得缓慢，这可能是一个很好的迹象，表明将用户对象存储在内存缓存中。
- en: In-memory caching requires us to implement custom cache invalidation logic,
    but it may also improve performance when HTTP caching is not the right tool for
    the job. Conclusively, adding a service such as Redis could be a good consideration
    in case our responses become slow, and we identify that slow database or API queries
    are the root cause.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 内存缓存需要我们实现自定义的缓存失效逻辑，但这也可能在HTTP缓存不是最佳工具时提高性能。总之，如果我们的响应变得缓慢，并且我们确定缓慢的数据库或API查询是根本原因，那么添加像Redis这样的服务可能是一个很好的考虑。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about different caching strategies and how to implement
    them with Remix.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了不同的缓存策略以及如何使用Remix实现它们。
- en: Remix’s `headers` route module API export lets us specify HTTP headers for the
    HTML document on a per-route level. We also have access to `loaderHeaders` and
    `parentHeaders`, which allows us to merge HTTP headers and specify headers based
    on the loader data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Remix的`headers`路由模块API导出允许我们为HTML文档在每个路由级别指定HTTP头。我们还有权访问`loaderHeaders`和`parentHeaders`，这允许我们合并HTTP头并根据加载器数据指定头。
- en: You also learned how to cache both document and data requests in Remix. You
    learned how to use the `Cache-Control` header to specify and prevent caching.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何在Remix中缓存文档和数据请求。你学习了如何使用`Cache-Control`头指定和防止缓存。
- en: Then, you applied the `private`, `public`, `max-age`, `no-cache`, and `immutable`
    directives. Additionally, you reviewed how Remix implements HTTP caching for static
    assets out of the box.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应用了`private`、`public`、`max-age`、`no-cache`和`immutable`指令。此外，你还回顾了Remix如何默认实现HTTP缓存以用于静态资源。
- en: Next, you learned about the privacy concerns of caching user-specific data and
    how to use ETags to avoid downloading full responses while sending requests to
    the server where the user authorization can be checked.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了缓存用户特定数据时的隐私问题以及如何使用ETags在向服务器发送请求以检查用户授权时避免下载完整的响应。
- en: Finally, we discussed in-memory caching and using services such as Redis to
    avoid requests to slow third-party services or databases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了内存缓存以及使用Redis等服务来避免对缓慢的第三方服务或数据库的请求。
- en: In the next chapter, we will learn about deferring loader data. Like caching,
    deferring loader data is a great lever to improve the user experience and performance
    of web applications.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于延迟加载器数据的内容。与缓存一样，延迟加载器数据是提高Web应用程序用户体验和性能的强大杠杆。
- en: Further reading
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can learn more about CDNs in the MDN Web Docs: [https://developer.mozilla.org/en-US/docs/Glossary/CDN](https://developer.mozilla.org/en-US/docs/Glossary/CDN).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在MDN Web Docs中了解更多关于CDN的信息：[https://developer.mozilla.org/en-US/docs/Glossary/CDN](https://developer.mozilla.org/en-US/docs/Glossary/CDN)。
- en: 'You can also find an overview of HTTP caching concepts in the MDN Web Docs:
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在MDN Web Docs中找到HTTP缓存概念的概述：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)。
- en: 'The MDN Web Docs also provide detailed information about each HTTP caching
    header:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MDN Web Docs还提供了关于每个HTTP缓存头部的详细信息：
- en: '`ETag`: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ETag`：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)'
- en: '`Cache-Control`: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cache-Control`：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)'
- en: 'Refer to the Remix documentation for more information about Remix’s `headers`
    route module API: [https://remix.run/docs/en/2/route/headers](https://remix.run/docs/en/2/route/headers).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考Remix文档以获取有关Remix的`headers`路由模块API的更多信息：[https://remix.run/docs/en/2/route/headers](https://remix.run/docs/en/2/route/headers)。
- en: 'Ryan Florence recorded two great videos about caching on the Remix YouTube
    channel. Fun fact – they were the very first videos that were uploaded on the
    Remix YouTube channel, and they are worth checking out:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ryan Florence在Remix YouTube频道上录制了两段关于缓存的精彩视频。有趣的事实——它们是Remix YouTube频道上上传的第一批视频，值得一看：
- en: '*Remix Run – Introduction to HTTP* *Caching*: [https://www.youtube.com/watch?v=3XkU_DXcgl0](https://www.youtube.com/watch?v=3XkU_DXcgl0)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Remix Run – HTTP缓存简介*：[https://www.youtube.com/watch?v=3XkU_DXcgl0](https://www.youtube.com/watch?v=3XkU_DXcgl0)'
- en: '*CDN Caching, Static Site Generation, and Server Side* *Rendering*: [https://www.youtube.com/watch?v=bfLFHp7Sbkg](https://www.youtube.com/watch?v=bfLFHp7Sbkg)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CDN缓存、静态站点生成和服务器端渲染*：[https://www.youtube.com/watch?v=bfLFHp7Sbkg](https://www.youtube.com/watch?v=bfLFHp7Sbkg)'
- en: 'You can also find a great guide for using ETags with Remix on Sergio’s blog:
    [https://sergiodxa.com/articles/use-etags-in-remix](https://sergiodxa.com/articles/use-etags-in-remix).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在Sergio的博客上找到使用Remix的ETags的出色指南：[https://sergiodxa.com/articles/use-etags-in-remix](https://sergiodxa.com/articles/use-etags-in-remix)。
