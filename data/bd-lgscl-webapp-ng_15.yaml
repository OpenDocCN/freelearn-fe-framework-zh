- en: Angular App Design and Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 应用程序设计和技巧
- en: In this chapter, we will complete the implementation of LemonMart. As part of
    the router-first approach, I will demonstrate the creation of reusable routable components
    that also support data binding - the ability to lay out components using auxiliary
    routes of the router, using resolve guards to reduce boilerplate code and leveraging
    class, interfaces, enums, validators, and pipes to maximize code reuse. In addition,
    we will create multi-step forms and implement data tables with pagination, and
    explore responsive design. Along the way, in this book, we will have touched upon
    most of the major functionality that Angular and Angular Material has to offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完成 LemonMart 的实现。作为先路由的方法的一部分，我将展示如何创建可重用的可路由组件，同时支持数据绑定——使用辅助路由布置组件的能力，使用
    resolve guards 减少样板代码，并利用类、接口、枚举、验证器和管道来最大程度地重用代码。此外，我们将创建多步骤表单，并实现带分页的数据表格，并探索响应式设计。在本书中，我们将触及Angular和Angular
    Material提供的大部分主要功能。
- en: In this chapter, the training wheels are off. I will provide general guidance
    to get you started on an implementation; however, it will be up to you to try
    and complete the implementation on your own. If you need assistance, you may refer
    to the complete source code that is provided with the book or refer to up-to-date
    sample on GitHub at [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，训练车轮已经卸下。我将提供一般指导来帮助您开始实施；然而，您将需要自己尝试并完成实施。如果需要帮助，您可以参考本书附带的完整源代码，或在[Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)上查看最新的示例。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Object-oriented class design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象类设计
- en: Routable reusable components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可复用的可路由组件
- en: Caching service responses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存服务响应
- en: HTTP POST requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP POST 请求
- en: Multi-step responsive forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多步骤响应表单
- en: Resolve guards
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析守卫
- en: Master/detail views using auxiliary routes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用辅助路由进行主/细节视图
- en: Data tables with pagination
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带分页的数据表格
- en: User class and object-oriented programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户类和面向对象编程
- en: So far, we have only worked with interfaces to represent data, and we still
    want to continue using interfaces when passing data around various components
    and services. However, there's a need to create a default object to initialize
    a `BehaviorSubject`. In **Object-oriented Programming** (**OOP**), it makes a
    lot of sense for the `User` object to own this functionality instead of a service.
    So, let's implement a `User` class to achieve this goal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是使用接口来表示数据，并且当在各个组件和服务之间传递数据时，我们仍然希望继续使用接口。然而，我们需要创建一个默认对象来初始化`BehaviorSubject`。在**面向对象编程**（**OOP**）中，让`User`对象拥有这个功能而不是一个服务，这样做非常有意义。所以，让我们实现一个`User`类来实现这个目标。
- en: 'Inside the `user/user` folder, define an `IUser` interface and a `User` class
    provided in `UserModule`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user/user`文件夹内，定义一个`IUser`接口和`UserModule`中提供的`User`类：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that by defining all properties with default values in the constructors
    as `public` properties, we hit two birds with one stone; otherwise, we will need
    to define properties and initialize them separately. This way, we achieve a concise
    implementation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在构造函数中使用默认值定义所有属性为`public`属性，我们一举两得；否则，我们将需要分别定义属性并初始化它们。这样，我们就实现了一个简洁的实现。
- en: 'You can also implement calculated properties for use in templates, such as
    being able to conveniently display the `fullName` of a user:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以实现计算属性以在模板中使用，比如可以方便地显示用户的`fullName`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using a `static BuildUser` function, you can quickly hydrate the object with
    data received from the server. You can also implement the `toJSON()` function
    to customize the serialization behavior of your object before sending the data
    up to the server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static BuildUser`函数，您可以快速用从服务器接收的数据填充对象。您还可以实现`toJSON()`函数来自定义对象在发送数据到服务器之前的序列化行为。
- en: Reusing components
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用组件
- en: 'We need a component that can display a given user''s information. A natural
    place for this information to be presented is when the user navigates to `/user/profile`.
    You can see the mock-up `User` profile file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个能够显示给定用户信息的组件。这些信息最自然的呈现位置是当用户导航到`/user/profile`时。您可以看到`User`概要文件的模拟：
- en: '![](img/eac254e3-0556-42ff-8841-6b44a5020fff.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eac254e3-0556-42ff-8841-6b44a5020fff.png)'
- en: User profile mock-up
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户概要模拟
- en: 'User information is also displayed mocked up elsewhere in the app, at `/manager/users`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用户信息也在应用程序的其他地方进行了模拟显示，在`/manager/users`：
- en: '![](img/b9b855d5-243b-4cc0-b625-511856a1f3b8.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9b855d5-243b-4cc0-b625-511856a1f3b8.png)'
- en: Manager user management mock-up
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理模拟
- en: To maximize code reuse, we need to ensure that you design a `User` component
    that can be used in both contexts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地提高代码重用率，我们需要确保设计一个能在两种情境下使用的`User`组件。
- en: As an example, let's complete the implementation of two user profile-related
    screens.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们完成两个与用户资料相关的屏幕的实现。
- en: User profile with multi-step auth-enabled responsive forms
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有多步鉴权功能的响应式表单的用户资料
- en: Now, let's implement a multi-step input form to capture user profile information.
    We will also make this multi-step form responsive for mobile devices using media
    queries.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个多步输入表单来捕获用户资料信息。我们还将使用媒体查询使这个多步表单对移动设备具有响应性。
- en: 'Let''s start with adding some helper data that will help us display an input
    form with options:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先添加一些辅助数据，这些数据将帮助我们显示具有选项的输入表单：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Install a helper library to programmatically access TypeScript enum values
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个帮助库来以编程方式访问TypeScript枚举值
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add new validation rules to `common/validations.ts`
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`common/validations.ts`中添加新的验证规则
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now implement `profile.component.ts` as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照以下方式实现`profile.component.ts`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Upon load, we request the current user from `userService`, but this will take
    a while, so we must first build an empty form with `this.buildUserForm()`. On
    this function, you can also implement a resolve guard, as discussed in a later
    section, to load a user based on their `userId` provided on a route, and pass
    that data into `buildUserForm(routeUser)` and skip loading `currentUser` to increase
    reusability of this component.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 加载时，我们从`userService`请求当前用户，但这可能需要一段时间，因此我们必须首先用`this.buildUserForm()`构建一个空表单。在这个函数中，您还可以实现一个resolve守卫，如后面将要讨论的，根据路由提供的`userId`加载用户，并将数据传递到`buildUserForm(routeUser)`，然后跳过加载`currentUser`以增加此组件的可重用性。
- en: Form groups
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单组
- en: Our form has many input fields, so we will use a `FormGroup`, created by `this.formBuilder.group`
    to house our various `FormControl` objects. Additionally, children `FormGroup`
    objects will allow us to maintain the correct shape of the data structure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单有许多输入字段，因此我们将使用`FormGroup`，由`this.formBuilder.group`创建以容纳我们的各种`FormControl`对象。此外，子`FormGroup`对象将允许我们保持数据结构的正确形状。
- en: 'Start building the `buildUserForm` function, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 开始构建`buildUserForm`函数，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`buildUserForm` optionally accepts an `IUser` to prefill the form, otherwise
    all fields are set to their default values. The `userForm` itself is the top-level
    `FormGroup`. Various `FormControls` are added to it, such as `email`, with validators
    attached to them as needed. Note how `name` and `address` are their own `FormGroup`
    objects. This parent-child relationship ensures proper structure of the form data,
    when serialized to JSON, which fits the structure of `IUser`, in a manner that
    the rest of our application and server-side code can utilize.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildUserForm`可选择接受一个`IUser`以预填表单，否则所有字段都设置为默认值。`userForm`本身是顶层`FormGroup`。其中添加了各种`FormControls`，例如`email`，根据需要连接到它们的验证器。注意`name`和`address`是它们自己的`FormGroup`对象。这种父子关系确保表单数据的正确结构，在序列化为JSON时，这适配了`IUser`的结构，以保证我们应用程序和服务端代码的运用。'
- en: You will completing the implementation of the `userForm` independently following
    the sample code provided for the chapter and I will be going over sections of
    the code piece by piece over the next few sections to explain certain key capabilities.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您将独立完成`userForm`的实现，按照章节提供的示例代码，并且在接下来的几个章节中我将逐步解释代码的某些关键功能。
- en: Stepper and responsive layout
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分步表单和响应式布局
- en: 'Angular Material Stepper ships with the MatStepperModule. The stepper allows
    for form inputs to be broken up into multiple steps so that the user is not overwhelmed
    with processing dozens of input fields all at once. The user can still track their
    place in the process and as a side effect, as the developer we breakup our `<form>`
    implementation and enforce validation rules on a step-by-step basis or create
    optional workflows where certain steps can be skipped or required. As with all
    Material user controls, the stepper has been designed with a responsive UX in
    mind. In the next few sections, we will implement three steps covering different
    form-input techniques in the process:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material Stepper附带了`MatStepperModule`。该步骤条允许将表单输入分解为多个步骤，以便用户不会被一次性处理数十个输入字段而感到不知所措。用户仍然可以跟踪他们在过程中的位置，作为开发人员的副作用，我们将我们的`<form>`实现分解并逐步强制执行验证规则，或者创建可以跳过或必填的可选工作流程。与所有Material用户控件一样，步骤条已经设计成具有响应式UX。在接下来的几节中，我们将实现包括不同表单输入技术的三个步骤：
- en: Account Information
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户信息
- en: Input validation
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证
- en: Responsive layout with media queries
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用媒体查询进行响应式布局
- en: Calculated properties
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性
- en: DatePicker
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期选择器
- en: Contact Information
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系信息
- en: Type ahead support
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动完成支持
- en: Dynamic form arrays
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: Review
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评论
- en: Read-only views
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读视图
- en: Saving and clearing data
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据保存和清除
- en: 'Let''s prep the User module for some new Material modules:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为用户模块准备一些新的Material模块：
- en: 'Create a `user-material.module` containing the following Material modules:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`user-material.module`，其中包含以下Material模块：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ensure `user.module` correctly imports:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`user.module`正确导入：
- en: The new `user-material.module`
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的`user-material.module`
- en: The baseline  `app-material.module`
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基线`app-material.module`
- en: Required  `FormsModule`, `ReactiveFormsModule` and `FlexLayoutModule`
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须引入`FormsModule`，`ReactiveFormsModule`和`FlexLayoutModule`
- en: As we start adding sub material modules, it makes sense to rename our root `material.module.ts`
    file to `app-material.modules.ts` inline with how `app-routing.module.ts` is named.
    Going forward, I will be using the latter convention.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始添加子Material模块时，将根`material.module.ts`文件重命名为`app-material.modules.ts`是合理的，与`app-routing.module.ts`的命名方式一致。今后，我将使用后一种约定。
- en: 'Now, start implementing the first row of the Account Information step:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始实现“账户信息”步骤的第一行：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Take care to understand how the stepper and the form configuration works so
    far, you should be seeing the first row render, pulling mock data:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意理解当前步骤条和表单配置的工作原理，你应该看到第一行渲染，并从模拟数据中拉取：
- en: '![](img/32843e4b-d12a-4a66-9b97-6c034e13732b.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32843e4b-d12a-4a66-9b97-6c034e13732b.png)'
- en: Multi-step form - Step 1
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 多步表单 - 第1步
- en: In order to complete the implementation of the form please refer to the sample
    code provided for this chapter or the reference implementation on [GitHub.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成表单的实现，请参考本章提供的示例代码或[GitHub.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)上的参考实现。
- en: During your implementation, you will notice that the Review step uses a directive
    named `<app-view-user>`. A minimal version of this component is implemented in
    the ViewUser component section below. However, feel free to implement the capability
    inline for now and refactor your code during the Reusable component with binding
    and route data section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的实现过程中，你会注意到“评论”步骤使用名为`<app-view-user>`的指令。这个组件的最简版本在下面的ViewUser组件部分实现了。然而，现在可以自由地在页面内实现这个功能，并在“可绑定和路由数据”部分重构代码。
- en: 'In the following screenshot, you can see what a completed implementation of
    the multi-step form looks like on a desktop:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，你可以看到在桌面端完成的多步表单的实现效果：
- en: '![](img/e9a485ac-1bb5-4881-9c2f-bffcee671f75.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9a485ac-1bb5-4881-9c2f-bffcee671f75.png)'
- en: Multi-step form on desktop
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面端多步表单
- en: 'Note that adding `fxLayout.lt-sm="column"` on a row with `fxLayout="row"` enables
    a responsive layout of the form, as shown:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用`fxLayout.lt-sm="column"`替代`fxLayout="row"`的情况下，使一行具有响应式布局形式，如下所示：
- en: '![](img/d8d82436-fc54-4675-8091-cf033e2123d3.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8d82436-fc54-4675-8091-cf033e2123d3.png)'
- en: Multi-step form on mobile
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 移动端多步表单
- en: Let's see how the Date of Birth field works in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中日期选择器字段是如何工作的。
- en: Calculated properties and DatePicker
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性和日期选择器
- en: 'If you like to display calculated properties based on user input, you can follow
    the pattern shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想根据用户输入显示已计算的属性，可以按照这里所示的模式进行：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The usage of calculated properties in the template looks like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的计算属性使用如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here it is in action:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的情况中，你可以看到它的实际效果：
- en: '![](img/8aff43df-f604-43cf-9eed-4fb412b9163d.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8aff43df-f604-43cf-9eed-4fb412b9163d.png)'
- en: Selecting date with DatePicker
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DatePicker选择日期
- en: 'After the date is selected, the calculated age is displayed, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择日期后，将显示计算的年龄，如下所示：
- en: '![](img/65a05b6a-4266-4a78-816f-1749e2a0bab1.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65a05b6a-4266-4a78-816f-1749e2a0bab1.png)'
- en: Calculated age property
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 计算年龄属性
- en: Now, let's move on to the next step, Contact Information and see how we can
    enable a convenient way to display and input the state portion of the address
    field.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一步，联系信息，并看看我们如何实现方便的方式来显示和输入地址字段的州部分。
- en: Type ahead support
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Type ahead支持
- en: 'In `buildUserForm`, we set a listener on `address.state` to support a type
    ahead filtering drop-down experience:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`buildUserForm`中，我们设置了对`address.state`的监听器，以支持类型前输入下拉筛选体验：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the template, implement `mat-autocomplete` bound to the filtered states
    array with an `async` pipe:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板上，使用`mat-autocomplete`绑定到过滤后的州数组，并使用`async`管道：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s how it looks when a user enters the `V` character:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入`V`字符时，它是这样的样子：
- en: '![](img/efe44748-d14c-4d5e-b990-004fd345bd1f.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efe44748-d14c-4d5e-b990-004fd345bd1f.png)'
- en: Dropdown with Typeahead Support
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉框与Typeahead支持
- en: In the next section, let's enable the input of multiple phone numbers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们启用多个电话号码的输入。
- en: Dynamic form arrays
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: 'Note that `phones` is an array, potentially allowing for many inputs. We can
    implement this by building a `FormArray` with `this.formBuilder.array` and with
    several helper functions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`phones`是一个数组，可能允许多个输入。我们可以通过使用`this.formBuilder.array`构建`FormArray`及使用几个辅助函数来实现这一点：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`BuildPhoneArray` supports initializing a form with a single phone input or
    filling it with the existing data, working in tandem with `BuildPhoneFormControl`.
    The latter function comes in handy when a user clicks on an Add button to create
    a new row for entry:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildPhoneArray`支持使用单个电话输入初始化表单或使用现有数据填充表单，与`BuildPhoneFormControl`协同工作。当用户单击Add按钮创建新的条目行时，后一个函数非常有用：'
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `phonesArray` property getter is a common pattern to make it easier to
    access certain form properties. However, in this case, it is also necessary, because
    `get(''phones'')` must be typecast to `FormArray` so that we can access the `length`
    property on it on the template:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`phonesArray`属性getter是一个常见的模式，可以更轻松地访问某些表单属性。然而，在这种情况下，这也是必要的，因为我们必须将`get(''phones'')`转换为`FormArray`，以便我们可以在模板上访问它的`length`属性：'
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `remove` function is implemented inline.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`函数是内联实现的。'
- en: 'Let''s see how it should be working:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看它应该如何工作：
- en: '![](img/3fb49d34-6c03-4edb-86a6-43d3183d8068.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fb49d34-6c03-4edb-86a6-43d3183d8068.png)'
- en: Multiple inputs using FormArray
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FormArray进行多个输入
- en: Now that we're done with inputing data, we can move on to the last step of the
    stepper, Review. However, as it was mentioned earlier, the Review step uses the `app-view-user`
    directive to display its data. Let's build that view first.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了输入数据，我们可以继续进行步进器的最后一步：Review。然而，正如之前提到的，Review步骤使用`app-view-user`指令来显示其数据。让我们先构建该视图。
- en: ViewUser component
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ViewUser组件
- en: Here's a minimal implementation of the `<app-view-user>` directive that is a
    prerequisite for the Review step.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`<app-view-user>`指令的最小实现，这是Review步骤的先决条件。
- en: 'Create a new `viewUser` component under `user` as shown below:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user`下创建一个新的`viewUser`组件，如下所示：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The component above uses input binding with `@Input` to get user data, compliant
    with the `IUser` interface, from an outside component. We implement the `ngOnChanges`
    event, which fires whenever the bound data changes. In this event, we hydrate
    the simple JSON object stored in `this.user` as an instance of the class `User`
    with  `User.BuildUser` and assign it to `this.currentUser`. The template uses
    this variable, because calculated properties like `currentUser.fullName` will
    only work if the data resides in an instance of the class `User`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的组件使用`@Input`进行输入绑定，从外部组件获取符合`IUser`接口的用户数据。我们实现`ngOnChanges`事件，每当绑定的数据发生变化时触发。在此事件中，我们使用`User.BuildUser`将存储在`this.user`中的简单JSON对象填充为`User`类的实例，并将其分配给`this.currentUser`。模板使用此变量，因为像`currentUser.fullName`这样的计算属性只有在数据驻留在`User`类的实例中时才会起作用。
- en: Now, we are ready to complete the multi-step form.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备完成多步表单。
- en: Review component and Save form
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查组件并保存表单
- en: 'On the last step of the multistep form, users should be able to review and
    then save the form data. As a good practice, a successful `POST` request will
    return the data that was saved back to the browser. We can then reload the form
    with the information received back from the server:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在多步表单的最后一步，用户应该能够进行审查，然后保存表单数据。作为良好的做法，成功的`POST`请求将返回保存的数据到浏览器。然后我们可以使用从服务器收到的信息重新加载表单：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If there are errors, they''ll be set to `userError` to be displayed. Before
    saving, we will present the data in a compact form in a reusable component that
    we can bind the form data to:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，它们将被设置为`userError`来显示。在保存之前，我们将以紧凑的形式呈现数据，使用可重用组件将表单数据绑定到：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is how the final product should look:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最终产品应该是这样的：
- en: '![](img/3f8afd93-786d-4ae7-b43b-d665971ae9a6.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f8afd93-786d-4ae7-b43b-d665971ae9a6.png)'
- en: Review step
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 审查步骤
- en: Note the option to reset the form. Adding an alert dialog to confirm resetting
    of user input data would be good UX.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意重置表单的选项。添加一个警报对话框来确认重置用户输入数据将是良好的用户体验。
- en: Now that the user profile input is done, we are about midway into our eventual
    goal of creating a master/detail view where a Manager can click on a user and
    view their profile details. We still have a lot more code to add, and along the
    way, we have fallen into a pattern of adding lots of boilerplate code to load
    the requisite data for a component. In the next section, we will learn about resolve
    guards so that we can simplify our code and reduce boilerplate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户配置文件输入完成，我们正在逐渐地朝着最终目标迈进，即创建一个主/细节视图，其中经理可以点击用户并查看其个人资料详细信息。我们仍然需要添加更多的代码，并且在此过程中，我们已经陷入了一种向组件加载必要数据的样板代码模式。在下一部分中，我们将了解resolve守卫，以便我们可以简化我们的代码并减少样板内容。
- en: Resolve guard
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析守卫
- en: A resolve guard is a type of a router guard, as mentioned in [Chapter 14](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml),* Design
    Authentication and Authorization.* A resolve guard can load necessary data for
    a component by reading record IDs from route parameters, asynchronously load the
    data and have it ready by the time the component activates and initializes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 解析守卫是路由守卫的一种类型，如 [第14章](c1386d03-1f04-49e0-a623-bc5c64be089c.xhtml)中所述，*设计身份验证和授权。*
    解析守卫可以通过从路由参数中读取记录ID异步加载必要的数据，并在组件激活和初始化时准备好这些数据。
- en: 'The major advantages for a resolve guard includes reusability of loading logic,
    reduction of boilerplate code, and also shedding dependencies, because the component
    can receive the data it needs without having to import any service:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 解析守卫的主要优势包括加载逻辑的可重用性，减少样板代码以及摆脱依赖关系，因为组件可以接收到其所需的数据而无需导入任何服务：
- en: 'Create a new `user.resolve.ts` class under `user/user`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user/user`下创建一个新的 `user.resolve.ts` 类：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can use a resolve guard as shown:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以像这样使用resolve守卫：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `routerLink` will look like this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`routerLink`将是这样的：'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the ` ngOnInit` hook of the target component, you can read the resolved
    user like this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标组件的 ` ngOnInit` 挂钩中，您可以这样读取已解析的用户：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can observe this behavior in action in the next two sections, after we update `ViewUserComponent` and
    the router to leverage the resolve guard.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新`ViewUserComponent`和路由以利用resolve守卫后，您可以在接下来的两个部分中观察这种行为。
- en: Reusable component with binding and route data
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有绑定和路由数据的可重用组件
- en: 'Now, let''s refactor the `viewUser` component, so that we can reuse it in multiple
    contexts. One where it can load its own data using a resolve guard, suitable for
    a master/detail view and another, where we can bind the current user to it, as
    we have done in the Review step of the multi-step input form we built in the prior
    section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构`viewUser`组件，以便我们可以在多个上下文中重复使用它。一个是它可以使用resolve守卫加载自己的数据，适用于主/细节视图，另一个是可以将当前用户绑定到它上，在我们在前一节中构建的多步输入表单的审查步骤中已经完成了绑定：
- en: 'Update `viewUser` component with the following changes:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下更改更新`viewUser`组件：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We now have two independent events. One for `ngOnChanges`, which handles what
    value gets assigned to `this.currentUser`, if `this.user` has been bound to. `ngOnInit`
    will only fire once, when the component is first initialized or has been routed
    to. In this case, if any data for the route has been resolved then it'll be assigned
    to `this.currentUser`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个独立的事件。一个用于`ngOnChanges`，它处理`this.user`已绑定的情况下`this.currentUser`被分配了哪个值。
    `ngOnInit`只会在组件首次初始化或路由到达时触发一次。在这种情况下，如果路由的任何数据已被解析，那么它将被分配给`this.currentUser`。
- en: To be able to use this component across multiple lazy loaded modules, we must
    wrap it in its own module.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在多个延迟加载的模块中使用此组件，我们必须将其包装在自己的模块中。
- en: 'Create a new `shared-components.module.ts` under `app`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`下创建一个新的`shared-components.module.ts`：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ensure that you import `SharedComponentsModule` module into each feature module
    you intended to use `ViewUserComponent` in. In our case, these will be `User`
    and `Manager` modules.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在你打算在`User`和`Manager`模块中使用`ViewUserComponent`时，将`SharedComponentsModule`模块引入到每个功能模块中。
- en: Remove `ViewUserComponent` from the `User` module declarations
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`User`模块的声明中移除`ViewUserComponent`
- en: We now have the key pieces in place to begin the implementation of master/detail
    view.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经具备开始实现主/细节视图的关键要素。
- en: Master/detail view auxiliary routes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主/细节视图辅助路由
- en: The true power of router-first architecture comes to fruition with the use of
    auxiliary routes, where we can influence the layout of components solely through
    router configuration, allowing for rich scenarios where we can remix the existing
    components into different layouts. Auxiliary routes are routes that are independent
    of each other where they can render content in named outlets that have been defined
    in the markup, such as `<router-outlet name="master">` or `<router-outlet name="detail">`.
    Furthermore, auxiliary routes can have their own parameters, browser history,
    children, and nested auxiliaries.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器优先架构的真正力量在于辅助路由的使用，通过仅通过路由器配置影响组件的布局，从而允许在不同布局中重新组合现有组件的丰富场景。辅助路由是彼此独立的路由，它们可以在标记中已定义的命名插座中呈现内容，例如`<router-outlet
    name="master">`或`<router-outlet name="detail">`。此外，辅助路由可以具有自己的参数、浏览器历史、子级和嵌套辅助路由。
- en: 'In the following example, we will implement a basic master/detail view using
    auxiliary routes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用辅助路由实现基本的主/细节视图：
- en: 'Implement a simple component with two named outlets defined:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个带有两个命名插座的简单组件：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Create a `userTable` component under `manager`
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manager`下创建一个`userTable`组件
- en: 'Update `manager-routing.module` to define the auxiliary routes:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`manager-routing.module`以定义辅助路由：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This means that when a user navigates to `/manager/users`, they'll see the `UserTableComponent`,
    because it is implemented with the `default` path.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当用户导航到`/manager/users`时，他们将看到`UserTableComponent`，因为它是用`default`路径实现的。
- en: Provide `UserResolve` in `manager.module` since `viewUser` depends on it
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`manager.module`中提供`UserResolve`，因为`viewUser`依赖于它
- en: Implement a temporary button in `userTable`
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`userTable`中实现一个临时按钮
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Consider that a user clicks on a View detail button like the one defined above,
    then `ViewUserComponent` will be rendered for the user with the given `userId`.
    In the next screenshot, you can see what the View Details button will look like
    after we implement the data table in the next section:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户点击了上述定义的`View detail`按钮，那么`ViewUserComponent`将为具有给定`userId`的用户呈现。在下一张截图中，您可以看到在下一节中实现数据表后，`View
    Details`按钮将是什么样子：
- en: '![](img/27e24385-6a13-4375-8905-4e0a4da346c9.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27e24385-6a13-4375-8905-4e0a4da346c9.png)'
- en: View Details button
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 查看详情按钮
- en: 'You can have as many combinations and alternative components defined for master
    and detail, allowing for an infinite possibilities of dynamic layouts. However,
    setting up the `routerLink` can be a frustrating experience. Depending on the
    exact condition, you have to either supply or not supply all or some outlets in
    the link. For example, for the preceding scenario, if the link was `[''/manager/users'',
    { outlets: { master: [''''], detail: [''user'', {userId: row.id}] } }]`, the route
    will silently fail to load. Expect these quirks to be ironed out in future Angular
    releases.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以为主和详细信息定义多种组合和备用组件，从而允许无限可能的动态布局。然而，设置`routerLink`可能是一个令人沮丧的体验。根据确切的条件，您必须在链接中提供或不提供所有或一些插座。例如，在上述场景中，如果链接是`[''/manager/users'',
    { outlets: { master: [''''], detail: [''user'', {userId: row.id}] } }]`，则路由将悄无声息地加载失败。预计这些怪癖将在未来的Angular版本中得到解决。'
- en: Now that, we've completed the implementation of the resolve guard for `ViewUserComponent`,
    you can use Chrome Dev Tools to see the data being loaded correctly. Before debugging,
    ensure that the mock server we created in [Chapter 13,](215237a5-318b-4de2-82a8-4e40e438b228.xhtml)
    *Continuous Integration and API Design*, is running.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了对`ViewUserComponent`的解析守卫的实现，你可以使用Chrome Dev Tools查看数据是否被正确加载。在调试之前，请确保我们在[第13章](215237a5-318b-4de2-82a8-4e40e438b228.xhtml)，*持续集成和API设计*中创建的模拟服务器正在运行。
- en: Ensure that mock server is running by executing either `docker run -p 3000:3000
    -t duluca/lemon-mart-swagger-server` or `npm run mock:standalone`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保模拟服务器正在运行，通过执行 `docker run -p 3000:3000 -t duluca/lemon-mart-swagger-server`
    或者 `npm run mock:standalone`。
- en: 'In Chrome Dev Tools, set a break point right after `this.currentUser` is assigned
    to, as shown:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Chrome Dev Tools 中，在`this.currentUser` 赋值后设置断点，如下所示：
- en: '![](img/6af6ebd9-acd6-4797-acf2-f02135a7c6a9.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6af6ebd9-acd6-4797-acf2-f02135a7c6a9.png)'
- en: Dev Tools Debugging ViewUserComponent
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Dev 工具调试 ViewUserComponent
- en: You will observe that `this.currentUser` is correctly set without any boilerplate
    code for loading data inside the `ngOnInit` function, showing the true benefit
    of a resolve guard. `ViewUserComponent` is the detail view; now let's implement
    the master view as a data table with pagination.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在 `ngOnInit` 函数中正确设置了`this.currentUser`，展示了解析守卫的真正好处。`ViewUserComponent`
    是详细视图；现在让我们实现带有分页的数据表作为主视图。
- en: Data table with pagination
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有分页的数据表
- en: We have created the scaffolding to lay out our master/detail view. In the master
    outlet, we will have a paginated data table of users, so let's implement `UserTableComponent`,
    which will contain a `MatTableDataSource` property named `dataSource`. We will
    need to be able to fetch user data in bulk using standard pagination controls
    like `pageSize` and `pagesToSkip` and be able to further narrow down the selection
    with user provided `searchText`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了铺设主/详细视图的脚手架。在主出口中，我们将有一个用户的分页数据表，因此让我们实现 `UserTableComponent`，其中包含一个名为
    `dataSource` 的 `MatTableDataSource` 属性。我们需要能够使用标准分页控件（如 `pageSize` 和 `pagesToSkip`）批量获取用户数据，并且能够通过用户提供的
    `searchText` 进一步缩小选择范围。
- en: Let's start by adding the necessary functionality to the `UserService`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为 `UserService` 添加必要的功能。
- en: Implement a new interface `IUsers` to describe the data structure of paginated
    data
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新的接口 `IUsers` 来描述分页数据的数据结构
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Add `getUsers` to `UserService`
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `UserService` 添加 `getUsers`
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set up `UserTable` with pagination, sorting, and filtering:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置带有分页、排序和过滤的`UserTable`：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After initializing the pagination, sorting, and the filter properties, we use
    the `merge` method to listen for changes in all three data streams. If one changes,
    the whole `pipe` is triggered, which contains a call to `this.userService.getUsers`.
    Results are then mapped to the table's `datasource` property, otherwise errors
    are caught and handled.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化分页、排序和筛选属性后，我们使用 `merge` 方法来监听所有三个数据流的更改。如果有一个发生了变化，整个 `pipe` 就会被触发，其中包含对
    `this.userService.getUsers` 的调用。然后将结果映射到表的 `datasource` 属性，否则捕获和处理错误。
- en: 'Create a `manager-material.module` containing the following Material modules:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下 Material 模块的 `manager-material.module`：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Ensure `manager.module` correctly imports:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 `manager.module` 正确导入：
- en: The new `manager-material.module`
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的 `manager-material.module`
- en: The baseline  `app-material.module`
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基线的 `app-material.module`
- en: Required  `FormsModule`, `ReactiveFormsModule` and `FlexLayoutModule`
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必需的 `FormsModule` 、 `ReactiveFormsModule` 和 `FlexLayoutModule`
- en: 'Finally, implement the `userTable` template:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现 `userTable` 模板：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With just the master view, the table looks like this screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 只有主视图，表格看起来像这样的截图：
- en: '![](img/b9bdc8f6-da44-4279-bf37-70dcff4e8794.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9bdc8f6-da44-4279-bf37-70dcff4e8794.png)'
- en: UserTable
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: UserTable
- en: 'If you click on the View icon, `ViewUserComponent` will get rendered in the
    detail outlet, as shown:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击查看图标，`ViewUserComponent` 将在详细视图中渲染，如下所示：
- en: '![](img/b31311fa-24cf-44b1-884b-14d612c84a12.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b31311fa-24cf-44b1-884b-14d612c84a12.png)'
- en: Master/Detail view
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 主/详细视图
- en: You can then wire up the Edit button and pass the `userId` to the `UserProfile` so
    that the data can be edited and updated. Alternatively, you can render the `UserProfile`
    in place in the detail outlet.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将 Edit 按钮连接起来，将 `userId` 传递给 `UserProfile`，以便编辑和更新数据。或者，您可以将 `UserProfile`
    直接呈现在详细视图中。
- en: Data table with pagination completes the implementation of LemonMart for the
    purpose of this book. Now let's make sure all our tests our passing, before we
    move on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 带有分页的数据表完成了 LemonMart 的实现目的。现在让我们确保我们所有的测试都通过，然后再继续。
- en: Updating Unit Tests
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新单元测试
- en: Since we introduced a new `userService`, create a fake implementation for it,
    using the same pattern from `authService` and `commonTestingProviders` with it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们引入了新的 `userService`，为其创建一个虚假实现，使用与 `authService` 和 `commonTestingProviders`
    相同的模式。
- en: Implement `IUserService` interface for `UserService`
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `UserService` 实现 `IUserService` 接口
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Implement the fake user service
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现虚假用户服务
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Add the user service fake to `commonTestingProviders`
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `commonTestingProviders` 中添加用户服务的虚假到
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Add `SharedComponentsModule` to `commonTestingModules`
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SharedComponentsModule`添加到`commonTestingModules`
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Instantiate default data for `UserTableComponent`
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`UserTableComponent`的默认数据
- en: 'After fixing up its providers and imports, you will notice `UserTableComponent`
    is still failing to create. This is because, the component initialization logic
    requires `dataSource` to be defined. If undefined, the component can''t be created.
    However, we can easily modify component properties in the second `beforeEach`
    method, which executes after the `TestBed` has injected real, mocked or fake dependencies
    to the component class. See the changes bolded below for test data setup:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复了提供者和导入后，您会注意到`UserTableComponent`仍然无法创建。这是因为，组件初始化逻辑要求定义`dataSource`。如果未定义，组件将无法创建。但是，我们可以在第二个`beforeEach`方法中轻松修改组件属性，该方法在`TestBed`注入了真实的、模拟的或伪造的依赖项到组件类之后执行。查看下面加粗的变化以进行测试数据设置：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'By now, you may have noticed that just by updating some of our central configuration
    some tests are passing and the rest of tests can be resolved by applying the various
    patterns we have been using throughout the book. For example `user-management.component.spec.ts`
    uses the common testing modules and providers we have created:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到通过更新我们的一些中心配置，一些测试通过了，并且其余的测试可以通过应用我们在整本书中一直在使用的各种模式来解决。例如`user-management.component.spec.ts`使用了我们创建的常用测试模块和提供者：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When you are working with providers and fakes, keep in mind what module, component,
    service or class is under test and take care to only provide fakes of dependencies.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用提供者和伪造品时，请记住正在测试哪个模块、组件、服务或类，并小心仅提供依赖项的伪造品。
- en: '`ViewUserComponent` is a special case, where we can''t use our common testing
    modules and providers, otherwise we would end up creating a circular dependency.
    In this case, manually specify the modules that need to be imported.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewUserComponent`是一个特殊情况，我们无法使用我们的常用测试模块和提供者，否则我们将最终创建一个循环依赖。在这种情况下，需要手动指定需要引入的模块。'
- en: Continue fixing unit test configurations until all of them are passing!
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续修复单元测试配置，直到所有测试都通过！
- en: In this book, we didn't cover any functional unit testing, where we would test
    some business logic to test its correctness. Instead, we focused on keeping the
    auto-generated tests in working order. I highly recommend implementing unit tests
    to cover key business logic using the excellent framework provided by Angular
    out-of-the-box.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们没有涵盖任何功能单元测试，其中我们将测试一些业务逻辑以测试其正确性。相反，我们专注于保持自动生成的测试处于工作状态。我强烈建议使用Angular自带的优秀框架来实现单元测试，覆盖关键业务逻辑。
- en: You always have the option to write even further elemental unit tests, testing
    classes and functions in isolation using Jasmine. Jasmine has rich test double
    functionality, able to mock and spy on dependencies. It is easier and cheaper
    to write and maintain these kinds of elemental unit tests. However, this topic
    is a deep one in its own right and is beyond the scope of this book.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终可以选择进一步编写基本的单元测试，使用Jasmine在隔离环境中测试类和函数。Jasmine具有丰富的测试双功能，能够模拟和监视依赖项。编写和维护这种基本单元测试更容易、更便宜。但是，这个主题本身是一个深入的主题，超出了本书的范围。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we completed going over all major Angular app design considerations,
    along with recipes, to be able to implement a line-of-business app with ease.
    We talked about applying object-oriented class design to make hydrating or serializing
    data easier. We created reusable components that can be activated by the router
    or embedded within another component with data binding. We showed that you can
    `POST` data to the server and cache responses. We also created a rich multistep
    input forms that is responsive to changing screen sizes. We removed boilerplate
    code from components by leveraging a resolve guard to load user data. We then
    implemented a master/detail view using auxiliary routes and demonstrated how to
    build data tables with pagination.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了所有主要的Angular应用程序设计考虑以及配方，以便能够轻松地实现业务应用程序。我们讨论了应用面向对象的类设计来使数据的填充或序列化更容易。我们创建了可以通过路由器激活或嵌入另一个带有数据绑定的组件的可重用组件。我们表明您可以将数据`POST`到服务器并缓存响应。我们还创建了一个响应屏幕尺寸变化的丰富多步输入表单。通过利用解析守卫从组件中删除样板代码，我们构建了一个主/细节视图。然后，使用辅助路由实现了数据表格分页。
- en: Overall, by using the router-first design, architecture, and implementation
    approach, we approached our application's design with a good high-level understanding
    of what we wanted to achieve. Also, by identifying reuse opportunities early on,
    we were able to optimize our implementation strategy to implement reusable components
    ahead of time without running the risk of grossly over-engineering our solution.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，通过采用先路由设计、架构和实施方法，我们对应用程序的设计有了一个很好的高层次理解我们想要实现的目标。此外，通过及早识别重用机会，我们能够优化我们的实施策略，提前实现可重用组件，而不会面临过度设计解决方案的风险。
- en: In the next chapter, we will set up a highly-available infrastructure on AWS
    to host LemonMart. We will update the project with new scripts to enable no-downtime
    Blue-Green deployments.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在AWS上建立一个高可用的基础架构来托管LemonMart。我们将更新项目，使用新的脚本来实现无停机蓝绿部署。
