- en: Building the Multitrack Player
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建多轨播放器
- en: We've made it to the keystone of NativeScript development: Direct access to Objective-C/Swift
    APIs on iOS and Java APIs on Android via TypeScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了 NativeScript 开发的关键点：通过 TypeScript 直接访问 iOS 的 Objective-C/Swift API 和
    Android 的 Java API。
- en: This is, by far, one of the most unique aspects of NativeScript and opens up
    many opportunities to you as a mobile developer. In particular, our app is going
    to need to take advantage of rich native audio APIs on both iOS and Android to
    achieve its core competency of delivering a compelling multitrack recording/mixing
    experience to our users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是 NativeScript 最独特的特点之一，为您作为移动开发者打开了众多机会。特别是，我们的应用程序将需要利用 iOS 和 Android 上的丰富原生音频
    API，以实现其核心能力，即为用户提供引人入胜的多轨录音/混音体验。
- en: Understanding how to code against these APIs will be essential to unlocking
    your mobile app's full potential. Additionally, learning how to integrate existing
    NativeScript plugins, which may already provide consistent APIs on both iOS and
    Android, can help you reach your goals even faster. Leveraging the best performance
    each platform can deliver will be the focus of our journey in Part 3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何针对这些 API 进行编码对于解锁移动应用程序的全部潜力至关重要。此外，学习如何集成现有的 NativeScript 插件，这些插件可能已经在
    iOS 和 Android 上提供了一致的 API，可以帮助您更快地实现目标。利用每个平台能提供的最佳性能将是我们在第三部分旅程中的重点。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Integrating the Nativescript-audio plugin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Nativescript-audio 插件
- en: Creating a model for our track player for future scalability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的轨道播放器创建一个模型以实现未来的可扩展性
- en: Working with RxJS observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RxJS 可观察对象进行工作
- en: Understanding Angular's NgZone with third-party libraries and view bindings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过第三方库和视图绑定理解 Angular 的 NgZone
- en: Handling audio playback sync with multiple audio sources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理与多个音频源同步的音频播放
- en: Taking advantage of Angular's bindings, as well as NativeScript's native event
    bindings, to achieve the exact usability we're after
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Angular 的绑定以及 NativeScript 的原生事件绑定，以实现我们追求的精确可用性
- en: Building a custom shuttle slider for our player controls using Angular platform-specific
    directives
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 平台特定的指令为我们的播放器控件构建自定义穿梭滑块
- en: Implementing our multitrack player via the nativescript-audio plugin
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 nativescript-audio 插件实现我们的多轨播放器
- en: Luckily, the NativeScript community has published a plugin that provides us
    with a consistent API to use across both iOS and Android to get going with an
    audio player. Feel free to browse [http://plugins.nativescript.org](http://plugins.nativescript.org), *the
    official source for NativeScript plugins,* before implementing features, in order to
    determine if an existing plugin may work for your project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，NativeScript 社区已经发布了一个插件，它为我们提供了一个一致的 API，可以在 iOS 和 Android 上使用，以便开始使用音频播放器。在实现功能之前，请随意浏览
    [http://plugins.nativescript.org](http://plugins.nativescript.org)，*这是 NativeScript
    插件的官方来源*，以确定现有的插件是否适合您的项目。
- en: 'In this case, the **nativescript-audio** plugin found at [http://plugins.nativescript.org/plugin/nativescript-
    audio](http://plugins.nativescript.org/plugin/nativescript-audio) contains what
    we need to start integrating the player portion of our app''s features, and it
    works on both iOS and Android. *It even provides a recorder we may be able to
    use*. Let''s start by installing it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，位于 [http://plugins.nativescript.org/plugin/nativescript-audio](http://plugins.nativescript.org/plugin/nativescript-audio)
    的 **nativescript-audio** 插件包含了我们开始集成应用程序功能播放器部分所需的内容，并且它在 iOS 和 Android 上都能工作。*它甚至提供了一个我们可能能够使用的录音器*。让我们先从安装它开始：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The NativeScript framework allows you to integrate with any npm module, opening
    up a dizzying array of integration possibilities, including NativeScript specific
    plugins. In fact, if you ever run into a situation where an npm module is giving
    you trouble (perhaps, because it relies on a node API not compatible in the NativeScript
    environment), there's even a plugin to help you deal with that at [https://www.npmjs.com/package/nativescript-nodeify](https://www.npmjs.com/package/nativescript-nodeify).
    It is described in detail at [https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript](https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: NativeScript框架允许您与任何npm模块集成，从而打开了一个令人眼花缭乱的集成可能性，包括NativeScript特定的插件。实际上，如果您遇到npm模块给您带来麻烦的情况（可能是因为它依赖于在NativeScript环境中不兼容的node
    API），甚至有一个插件可以帮助您处理这种情况，请参阅[https://www.npmjs.com/package/nativescript-nodeify](https://www.npmjs.com/package/nativescript-nodeify)。它详细描述在[https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript](https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript)。
- en: Whenever integrating with a NativeScript plugin, create a model or Angular service
    around its integration to provide isolation around that integration point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在与NativeScript插件集成时，创建一个模型或Angular服务来围绕其集成提供隔离。
- en: '**Try to isolate third-party plugin integration points by creating a reusable
    model or Angular service around that plugin**. This will not only provide your
    app with nice scalability into the future, but will give you more flexibility
    down the road if you need to swap that plugin out with something different and/or
    provide different implementations on iOS or Android.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试通过创建一个可重用的模型或Angular服务来隔离第三方插件集成点**。这不仅将为您的应用程序提供良好的未来可扩展性，而且在您需要用不同的插件替换该插件或为iOS或Android提供不同的实现时，将提供更多的灵活性。'
- en: Building the TrackPlayerModel for our multitrack player
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的多音轨播放器构建`TrackPlayerModel`
- en: We need each track to have its own instance of an audio player, as well as to
    expose an API to load the track's audio file. This will also provide a good place
    to expose the track's duration once the audio file is loaded.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要每个音轨都有自己的音频播放器实例，以及暴露一个API来加载音轨的音频文件。这也会提供一个很好的地方来暴露音频文件加载后的音轨时长。
- en: 'Since this model will likely be shared across the entire app (foreseeably with
    recording playback in the future as well), we will create this with our other
    models in `app/modules/shared/models/track-player.model.ts`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个模型可能会在整个应用程序中共享（预计未来还会与录音播放一起），我们将在`app/modules/shared/models/track-player.model.ts`中与我们的其他模型一起创建它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start by importing the sweet NativeScript community audio player `TNSPlayer`
    from the `nativescript- audio` plugin. We then define a simple interface to implement
    for our model which, will reference `trackId`, its `duration`, and a `readonly`
    getter for the `player` instance. Then, we include that interface to use with
    our implementation, which constructs an instance of `TNSPlayer` with itself. Since
    we want a flexible model that can load its track file at any time, we provide
    a `load` method taking `ITrack` that utilizes the `initFromFile` method. This,
    in turn, asynchronously fetches the track's total duration (returned as a string,
    so we use `+duration`) to store the number on the model before resolving the track's
    initialization completes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从`nativescript-audio`插件中导入甜美的NativeScript社区音频播放器`TNSPlayer`。然后，我们定义一个简单的接口来实现我们的模型，该接口将引用`trackId`、其`duration`以及一个用于`player`实例的`readonly`获取器。接着，我们将该接口包含在我们的实现中，它使用自身构建一个`TNSPlayer`实例。由于我们希望有一个灵活的模型，可以在任何时间加载其音轨文件，我们提供了一个接受`ITrack`的`load`方法，该方法利用了`initFromFile`方法。这反过来会异步获取音轨的总时长（以字符串形式返回，因此我们使用`+duration`），在模型中存储该数字，在解决音轨初始化完成之前。
- en: 'For consistency and standards, just be sure to also export this new model from
    `app/modules/shared/models/index.ts`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性和标准，请确保也从`app/modules/shared/models/index.ts`导出这个新模型：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, we provide a getter for the player instance that `PlayerService` will
    use. This brings us to our next step: open `app/modules/player/services/player.service.ts`.
    We are going to change up our initial implementation a bit with our latest developments;
    have a look at this in totality and we will explain afterward:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供了一个用于播放器实例的获取器，`PlayerService`将使用它。这使我们来到了下一步：打开`app/modules/player/services/player.service.ts`。我们将根据我们最新的发展对我们的初始实现进行一些修改；整体查看这个，我们将在之后解释：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The cornerstone of `PlayerService` at this point is to not only manage the
    hard work of playing multiple tracks in the mix, but to provide a state, which
    our views can observe to reflect the composition''s state. Hence, we have the
    following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 `PlayerService` 的基石不仅在于管理混音中播放多个音轨的繁重工作，还在于提供一个状态，我们的视图可以观察以反映组合的状态。因此，我们有以下内容：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our view will need to know the playing state as well as `duration` and `currentTime`.
    Using `Subject` for the `playing$` and `duration$` states will work well, since
    they are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图需要知道播放状态以及 `duration` 和 `currentTime`。使用 `Subject` 对于 `playing$` 和 `duration$`
    状态将工作得很好，因为它们如下：
- en: They can emit values directly
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以直接发出值
- en: They don't need to emit an initial value
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要发出初始值
- en: They don't need any observable composition
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要任何可观察的组合
- en: On the other hand, `currentTime$` is going to be set up with some composition
    in mind, since its value will be dependent on an intermittent state that may develop
    over time (more on this shortly!). In other words, the `playing$` state is a value
    we control and emit directly via play actions made by the user (or internally
    based on player state) and the `duration$` state is a value we emit directly as
    a result of all our track's players becoming initialized and ready**. **
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '另一方面，`currentTime$` 将会根据一些组合来设置，因为它的值将依赖于可能随时间发展的间歇性状态（关于这一点稍后会有更多说明！）。换句话说，`playing$`
    状态是我们通过用户（或基于播放器状态内部）进行的播放操作直接控制和发出的一个值，而 `duration$` 状态是我们直接发出的一个值，作为所有音轨播放器初始化并准备好的结果**。** '
- en: '`currentTime` is a value that the player does not emit automatically via a
    player event but rather a value we must check for intermittently. Therefore, we
    compose `Observable.interval(1000)` that will auto emit our mapped value representing
    the longest track''s player instance''s actual `currentTime` every 1 second upon
    its subscription.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentTime` 是播放器不会通过播放器事件自动发出的一个值，而是一个我们必须间歇性检查的值。因此，我们组合 `Observable.interval(1000)`，它将在订阅时每秒自动发出一个映射值，代表最长音轨播放实例的实际
    `currentTime`。'
- en: The other `private` references help maintain the internal state for the service's
    use. Most interestingly, we will keep a reference to `_longestTrack`, since our
    composition's total duration will always be based on the longest track and, hence,
    will also be used to track `currentTime`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 `private` 引用有助于维护服务内部状态。最有趣的是，我们将保留 `_longestTrack` 的引用，因为我们的组合的总时长将始终基于最长音轨，因此也将用于跟踪
    `currentTime`。
- en: This set up will provide the essentials of what our view will need to suffice
    proper user interaction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置将提供我们视图所需的基本要素，以实现适当的用户交互。
- en: '*RxJS does not include any operators by default. Therefore, `Observable.interval(1000)`
    and `.map` will crash your app right now if you are to run it!*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*RxJS 默认不包含任何操作符。因此，如果你现在运行 `Observable.interval(1000)` 和 `.map`，它们将使你的应用崩溃！*'
- en: The minute you start working more with RxJS, it's a good idea to create an `operators.ts`
    file to import all your RxJS operators into. Then, import that file in your root
    `AppComponent`, so you don't end up with those operator imports scattered everywhere
    throughout your codebase.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始更多地使用 RxJS 时，创建一个 `operators.ts` 文件并将所有 RxJS 操作符导入其中是个好主意。然后，在根 `AppComponent`
    中导入该文件，这样你就不需要在代码库的各个地方散布那些操作符导入。
- en: 'Create `app/operators.ts` with the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `app/operators.ts` 并包含以下内容：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, open `app/app.component.ts` and import that file on the very first line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开 `app/app.component.ts` 并在第一行导入该文件：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we are free to use map, interval, and any other `rxjs` operators we need
    anywhere in our code, provided we import them into that single file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以自由地在代码的任何地方使用 map、interval 以及我们需要的任何其他 `rxjs` 操作符，前提是我们将它们导入到那个单一文件中。
- en: 'The next bit of our service is rather self-explanatory:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的下一部分相当直观：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our `playing` setter ensures that the internal state, `_playing`, is updated,
    as well as our `playing$` subject''s value emitted for any subscribers needing
    to react to this state change. Convenient getters are also added for good measure.
    The next setter for our composition gets rather interesting, as this is where
    we interact with our new `TrackPlayerModel`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `playing` 设置器确保内部状态 `_playing` 被更新，以及 `playing$` 主题的值被发出，以便任何需要对此状态变化做出反应的订阅者。为了保险起见，还添加了一些方便的获取器。我们组合的下一个设置器变得相当有趣，因为这是我们与新的
    `TrackPlayerModel` 交互的地方：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Whenever we set the active composition, we first ensure our service''s internal
    `_trackPlayers` reference is properly cleaned up and cleared with `this._resetTrackPlayers()`.
    We then set up a local method `initTrackPlayer` that can be called iteratively,
    given the async nature of each player''s `load` method to ensure each track''s
    player is properly loaded with the audio file, including its duration. After each
    successful load, we add to our collection of `_trackPlayers`, iterate, and continue
    until all the audio files are loaded. When complete, we call `this._updateTotalDuration()`
    to determine the final duration of our composition of tracks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们设置活动作品时，我们首先确保我们的服务内部`_trackPlayers`引用被正确清理和清除，使用`this._resetTrackPlayers()`。然后我们设置一个本地方法`initTrackPlayer`，它可以被迭代调用，考虑到每个播放器的`load`方法具有异步特性，以确保每个轨道的播放器正确加载音频文件，包括其时长。每次成功加载后，我们将它添加到我们的`_trackPlayers`集合中，迭代并继续，直到所有音频文件都加载完成。完成后，我们调用`this._updateTotalDuration()`来确定我们轨道作品的最终时长：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the track with the longest duration should always be used to determine
    the total duration of the entire composition, we use `Math.max` to determine what
    the longest duration is and then store a reference to the track. Because multiple
    tracks could have the same duration, it doesn't really matter which track is used,
    just as long as one matches the longest duration. This `_longestTrack` will be
    our *pace setter* if you will, as it will be used to determine `currentTime` of
    the entire composition. Lastly, we emit the longest duration as `totalDuration`
    via our `duration$` subject for any subscribing observers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应该始终使用最长时长的轨道来确定整个作品的持续时间，我们使用`Math.max`来确定最长时长，然后存储对轨道的引用。因为可能有多个轨道具有相同的时长，所以使用哪个轨道并不重要，只要有一个匹配最长时长即可。这个`_longestTrack`将作为我们的*节奏设定者*，因为它将用于确定整个作品的`currentTime`。最后，我们通过`duration$`主题将最长时长作为`totalDuration`发射给任何订阅的观察者。
- en: 'The next couple of methods provide the basis of our composition''s overall
    playback control:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个方法提供了我们作品整体播放控制的基础：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our primary play button in our UI will use the `togglePlay` method to control
    playback and, hence, is used to toggle the internal state as well as engage all
    the track player's play or pause methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们UI中的主要播放按钮将使用`togglePlay`方法来控制播放，因此也用于切换内部状态以及激活所有轨道播放器的播放或暂停方法。
- en: Let the music play!
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让音乐播放！
- en: To try all this out, let's add three sample audio files from a jazz track composed
    by the exquisite *Jesper Buhl Trio* called *What Is This Thing Called Love*. The
    tracks are already separated by drums, bass, and piano. We can add these `.mp3`
    files to an `app/audio` folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试所有这些，让我们添加来自由杰出的*Jesper Buhl Trio*创作的爵士曲目*What Is This Thing Called Love*的三个样本音频文件。这些曲目已经由鼓、贝斯和钢琴分开。我们可以将这些`.mp3`文件添加到`app/audio`文件夹中。
- en: 'Let''s modify our demo composition''s tracks in `MixerService` to provide references
    to these new real audio files. Open `app/modules/mixer/services/mixer.service.ts`
    and make the following modifications:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`MixerService`中我们的演示作品的轨道，以提供对这些新真实音频文件的引用。打开`app/modules/mixer/services/mixer.service.ts`并进行以下修改：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now provide an input to our player controls, which will take our selected
    composition. Open `app/modules/mixer/components/mixer.component.html`, and make
    the following highlighted modification:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向我们的播放器控制输入一个输入，这将选择我们的选定作品。打开`app/modules/mixer/components/mixer.component.html`，并进行以下高亮显示的修改：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in `PlayerControlsComponent` at `app/modules/player/components/player-
    controls/player-controls.component.ts`, we can now observe the state of `PlayerService` via
    its various observables:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`PlayerControlsComponent`的`app/modules/player/components/player- controls/player-controls.component.ts`中，我们现在可以通过其各种可观察对象观察`PlayerService`的状态：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The cornerstone of `PlayerControlComponent` is now its ability to set the active
    composition via `this.playerService.composition = this.composition` inside `ngOnInit`,
    which is when the composition input is ready, as well as subscribe to the various
    states provided by `PlayerService` to update our UI. Most interesting here is
    the `playing$` subscription that manages the `currentTime$` subscription based
    on whether it''s playing or not. If you recall, our `currentTime$` observable
    started with `Observable.interval(1000)`, meaning every one second, it will emit
    the longest track''s `currentTime`, shown here again for reference:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerControlComponent` 的基石现在是其通过 `ngOnInit` 中的 `this.playerService.composition
    = this.composition` 来设置活动组合的能力，这时组合输入已经就绪，以及订阅 `PlayerService` 提供的各种状态来更新我们的 UI。这里最有趣的是
    `playing$` 订阅，它根据是否播放来管理 `currentTime$` 订阅。如果你还记得，我们的 `currentTime$` 可观察者是从 `Observable.interval(1000)`
    开始的，这意味着每秒会发出最长轨道的 `currentTime`，这里再次列出以供参考：'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We only want to update `currentTime` of `Slider` when playback is engaged; hence,
    the subscription when the `playing$` subject emit is `true`, which will allow
    our component to receive the player's `currentTime` every second. When `playing$`
    emit is `false`, we unsubscribe, to no longer receive the `currentTime` updates.
    Excellent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在播放参与时更新 `Slider` 的 `currentTime`；因此，当 `playing$` 主题发出 `true` 时，这将允许我们的组件每秒接收播放器的
    `currentTime`。当 `playing$` 发出 `false` 时，我们取消订阅，不再接收 `currentTime` 更新。非常好。
- en: We also subscribe to our `duration$` subject to update the Slider's maxValue.
    Lastly, we ensure all subscriptions are cleaned up via their `Subscription` references
    inside `ngOnDestroy`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还订阅了我们的 `duration$` 主题来更新滑块的 `maxValue`。最后，我们确保通过它们在 `ngOnDestroy` 中的 `Subscription`
    引用清理所有订阅。
- en: 'Let''s take a look at our view bindings now for `PlayerControlsComponent` at
    `app/modules/player/components/player-controls/player-controls.component.html`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `PlayerControlsComponent` 的视图绑定，它在 `app/modules/player/components/player-controls/player-controls.component.html`：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you run the app, you can now select the Demo composition and play music on
    both iOS and Android.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你现在可以选中演示组合，并在 iOS 和 Android 上播放音乐。
- en: '*MUSIC TO OUR EARS! This is pretty awesome. In fact, it''s friggin'' sweet!!*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*音乐动听！这真是太棒了。事实上，它简直太棒了！！*'
- en: 'There are a couple things you may notice or desire at this point:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能注意到或希望以下几件事情：
- en: After choosing the Play button, it properly changes to Stop, but when playback
    reaches the end, it does not return to its original Play text.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择播放按钮后，它正确地变为停止，但当播放到达末尾时，它不会返回到原始的播放文本。
- en: '`Slider` should also return to position 0 to reset playback.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider` 也应该返回到位置 0 以重置播放。'
- en: The total `duration` and `currentTime` on iOS uses seconds; however, Android
    uses milliseconds.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 上的总 `duration` 和 `currentTime` 使用秒；然而，Android 使用毫秒。
- en: On iOS, you may notice a very subtle playback sync issue on all the tracks if
    you choose to play/pause many times during the playback of the composition's demo
    tracks.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 iOS 上，如果你在组合的演示轨道播放期间多次选择播放/暂停，你可能会注意到所有轨道上非常微妙的播放同步问题。
- en: The current time and duration labels are needed.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要当前时间和持续时间标签。
- en: '**Playback seeking** would be nice to be able to shuttle our slider to control
    the position of playback.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放寻找** 很好，能够将滑块穿梭以控制播放位置。'
- en: Polishing the implementation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完善实现
- en: 'We''re missing a few important pieces in our model and service to really polish
    off our implementation. Let''s start with handling completion and error conditions
    with our track player instances. Open `TrackPlayerModel` at `app/modules/shared/models/track-player.model.ts` and
    add the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型和服务中缺少一些重要的部分来真正完善我们的实现。让我们从处理轨道播放实例的完成和错误条件开始。打开 `TrackPlayerModel` 在
    `app/modules/shared/models/track-player.model.ts`，并添加以下内容：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by defining the shape of each track error with `IPlayerError`. Then,
    we define references to the `_completeHandler` and `_errorHandler` functions captured via
    the `load` arguments, which now require complete and error callbacks. We assign
    those both before assigning the model's internal `this._trackComplete`and `this._trackError`
    (*using the `.bind(this)` syntax to ensure the function scope is locked to itself*)to
    `completeCallback` and `errorCallback` of `TNSPlayer`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '我们首先使用 `IPlayerError` 定义每个轨道错误的形状。然后，我们定义通过 `load` 参数捕获的 `_completeHandler`
    和 `_errorHandler` 函数的引用，现在这些函数需要完整的和错误回调。我们在将模型内部的 `this._trackComplete` 和 `this._trackError`（使用
    `.bind(this)` 语法确保函数作用域锁定到自身）分配给 `TNSPlayer` 的 `completeCallback` 和 `errorCallback`
    之前分配这些。 '
- en: '`completeCallback` and`errorCallback` will fire outside the zone. This is why
    we inject `NgZone` and use `ngZone.run()` later in the chapter. We can avoid that
    by creating a callback with the `zonedCallback` function. It will make sure that
    the callback will be executed in the same zone as the code that creates the callback.
    For example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`completeCallback`和`errorCallback`将在区域外触发。这就是为什么我们在本章后面注入`NgZone`并使用`ngZone.run()`。我们可以通过创建一个使用`zonedCallback`函数的回调来避免这种情况。它将确保回调将在创建回调的同一区域中执行。例如：'
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This provides us the ability to internally handle each condition before dispatching
    out those conditions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在分发这些条件之前内部处理每个条件。
- en: 'One such internal condition is resetting each audio player back to zero when
    it completes playing, so we simply call the `seekTo` method of `TNSPlayer`to reset
    it. We mark a *TODO,* because although this works well when all the tracks are
    the same length (*as is the case with our Demo tracks*), this will most certainly
    become potentially problematic in the future when we start recording our own varied
    multitracks with different lengths. Imagine we have two tracks in a composition:
    track 1 with a duration of 1 minute and track 2 a duration of 30 seconds. If we
    play the composition to 45 seconds and hit pause, track 2 would have called its
    completion handler already and reset back to 0\. We then hit play to resume. Track
    1 resumes from 45 seconds but track 2 is back at 0\. *We will address that when
    we get there, so don''t fret about it!* At this point, we are polishing our first
    phase implementation.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个内部条件是在音频播放完成后将每个音频播放器重置为零，所以我们只需调用`TNSPlayer`的`seekTo`方法来重置它。我们标记为*待办事项*，因为尽管当所有轨道长度相同（如我们的演示轨道）时这效果很好，但在我们开始录制不同长度的多轨时，这可能会在未来变得可能有问题。想象一下，在一个作品中我们有两个轨道：轨道1时长1分钟，轨道2时长30秒。如果我们播放作品到45秒并按暂停，轨道2已经调用了其完成处理程序并重置回0。然后我们按播放来继续。轨道1从45秒开始继续，但轨道2回到了0。*我们将在到达那里时解决它，所以不要担心！*
    到目前为止，我们正在完善第一阶段实现。
- en: Lastly, we call out to the assigned `completeHandler` to let the caller know
    which trackId has completed. For `trackError`, we simply call out passing along
    `trackId` and `error`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用分配的`completeHandler`来通知调用者哪个`trackId`已经完成。对于`trackError`，我们简单地调用传递`trackId`和`error`。
- en: 'Now, let''s go back to `PlayerService` and wire this in. Open `app/modules/player/services/player.service.ts` and
    make the following modifications:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`PlayerService`并连接这个功能。打开`app/modules/player/services/player.service.ts`并做出以下修改：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've added another subject, `complete$`, to allow view components to subscribe
    to when the track playback completes. Additionally, we have added two callback
    handlers, `_trackComplete` and `_trackError`, which we pass along to our `load`
    method of `TrackPlayerModel`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了另一个主题，`complete$`，以便视图组件可以在轨道播放完成时订阅。此外，我们还添加了两个回调处理程序，`_trackComplete`和`_trackError`，我们将它们传递给`TrackPlayerModel`的`load`方法。
- en: However, if we were to try and update view bindings as a result of the `complete$`
    subscriptions firing in any view component, you would notice something puzzling.
    **The view would not update!**
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试在任何视图组件中由于`complete$`订阅触发而更新视图绑定，你会注意到一些令人困惑的事情。**视图不会更新！**
- en: Anytime you integrate with third-party libraries, take note of callback handlers
    coming from the library, which you may intend to update a view binding. Inject
    NgZone and wrap with `this.ngZone.run(() => ...` where needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你与第三方库集成时，请注意来自库的回调处理程序，你可能打算更新视图绑定。在需要的地方注入NgZone并使用`this.ngZone.run(() =>
    ...`包裹。
- en: Third-party libraries that provide callbacks may often need to run through Angular's NgZone.
    The great folks at Thoughtram published a great article on Zones if you'd like
    to learn more, at [https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html](https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提供回调的第三方库可能经常需要通过Angular的NgZone运行。如果你想了解更多关于区域的信息，Thoughttram的伟大团队发布了一篇很好的文章，可以在[https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html](https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html)找到。
- en: The third-party library **nativescript-audio** integrates with the iOS and Android
    native audio players and provides callbacks you can wire up to handle completion
    and error conditions. These callbacks are executed asynchronously within the context
    of the native audio players and, because they are not handled within the context
    of user events like a tap, or a result of a network request, or a timer like `setTimeout`,
    we need to ensure the result and the subsequent code execution take place within
    Angular's NgZone if we intend them to result in updating view bindings.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方库`nativescript-audio`与iOS和Android的原生音频播放器集成，并提供你可以连接起来处理完成和错误条件的回调。这些回调在原生音频播放器的上下文中异步执行，并且由于它们不是在用户事件（如点击、网络请求的结果或`setTimeout`定时器）的上下文中处理的，因此如果我们希望它们导致视图绑定的更新，我们需要确保结果和随后的代码执行在Angular的NgZone中进行。
- en: 'Since we intend for the `complete$` subject to result in view binding updates
    (*specifically, resetting our slider*), we will inject NgZone and wrap our callback
    handling. Back in `app/modules/player/services/player.service.ts`, let''s make
    the following adjustment:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望`complete$`主题导致视图绑定更新（特别是重置我们的滑块），我们将注入NgZone并包装我们的回调处理。回到`app/modules/player/services/player.service.ts`，让我们进行以下调整：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will be clear when using this new `complete$` subject to react to our
    service''s state in our view components. Let''s adjust `PlayerControlsComponent`
    at `app/modules/player/components/player- controls/player-controls.component.ts` to
    observe the `complete$` subject to reset our `currentTime` binding:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当使用这个新的`complete$`主题来响应我们的服务状态时，我们将非常明确。让我们调整`PlayerControlsComponent`在`app/modules/player/components/player-controls/player-controls.component.ts`中的设置，以观察`complete$`主题来重置我们的`currentTime`绑定：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: iOS Audio Player reports `duration` and `currentTime` in seconds, whereas Android
    reports in milliseconds. We need to standardize that!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: iOS音频播放器报告`duration`和`currentTime`为秒，而Android报告为毫秒。我们需要标准化这一点！
- en: 'Let''s add a method to `PlayerService` to standardize the time, so we can rely
    on both the platforms providing time in seconds:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`PlayerService`中添加一个方法来标准化时间，这样我们就可以依赖提供秒数时间的两个平台：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are able to take advantage of the `isIOS` Boolean provided by the `platform`
    module from NativeScript to conditionally adjust our time for Android's milliseconds
    to seconds conversion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用NativeScript的`platform`模块提供的`isIOS`布尔值，有条件地调整我们的时间，将Android的毫秒转换为秒。
- en: Using the `isIOS` and/or `isAndroid` Boolean from NativeScript's `platform`
    module is a very effective way to make platform adjustments across your codebase
    where needed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NativeScript的`platform`模块中的`isIOS`和/或`isAndroid`布尔值是在代码库中需要时进行平台调整的非常有效的方法。
- en: '**So what about that subtle playback sync issue with multiple tracks on iOS
    ?**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**那么，iOS上多个音轨的微妙播放同步问题怎么办呢？**'
- en: On iOS, you may notice a very subtle playback sync issue on all the tracks if
    you choose play/pause many times during the 14 seconds of playback on the composition's
    demo tracks. We could surmise this could also happen on Android at some point.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，如果你在14秒的播放时间内多次选择播放/暂停，你可能会注意到所有音轨上都非常微妙的播放同步问题。我们可以推测这可能在Android的某个时刻也会发生。
- en: Using NativeScript's strengths by tapping directly into the native API of the
    underlying iOS AVAudioPlayer instance from the nativescript-audio plugin
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过直接从nativescript-audio插件调用底层iOS AVAudioPlayer实例的本地API来利用NativeScript的优势。
- en: Let's insert some safeguards into our play/pause logic to help ensure our tracks
    stay in sync to the best of our programming abilities. The **nativescript-audio**
    plugin offers an iOS-only method called `playAtTime`. It works in tandem with
    the special `deviceCurrentTime` property, as described in Apple's documentation
    for this very purpose at [https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?
    language=objc](https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?language=objc).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在播放/暂停逻辑中插入一些安全措施，以帮助确保我们的音轨尽可能同步到我们的编程能力。`nativescript-audio`插件提供了一个仅适用于iOS的方法，称为`playAtTime`。它与特殊的`deviceCurrentTime`属性协同工作，正如Apple在其针对此目的的文档中所描述的，可以在[https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?language=objc](https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?language=objc)找到。
- en: 'Since `deviceCurrentTime` is not exposed by the nativescript-audio plugin,
    we can access the native property directly via the `ios` getter. Let''s adjust
    the `play` method of `PlayerService`to use it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`deviceCurrentTime`属性没有被nativescript-audio插件暴露，我们可以通过`ios`获取器直接访问原生属性。让我们调整`PlayerService`的`play`方法来使用它：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since `track.player` is our instance of `TNSPlayer`, we can access the underlying
    native platform player instance (for iOS, it's `AVAudioPlayer`) via its **ios**
    getter to access `deviceCurrentTime` directly. We provide a very short start delay
    for good measure, add that into the first track's `deviceCurrentTime`, and use
    that to start all of our tracks at precisely the same time, which works wonderfully! Because
    `playAtTime` is not published via the TypeScript definitions with the nativescript-audio
    plugin, we simply type-cast the player instance (`<any>track.player`) before calling
    the method to suffice the tsc compiler. Since there is no equivalent on Android,
    we will just use the standard media player's play method, which works well for
    Android.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`track.player`是我们的`TNSPlayer`实例，我们可以通过其**ios**获取器直接访问底层原生平台播放器实例（对于iOS，它是`AVAudioPlayer`），以直接访问`deviceCurrentTime`。为了保险起见，我们提供了一个非常短的开始延迟，将其添加到第一首轨道的`deviceCurrentTime`中，并使用它来精确地同时启动所有轨道，这效果非常好！由于`playAtTime`没有通过TypeScript定义与nativescript-audio插件一起发布，我们在调用方法之前简单地将播放器实例（`<any>track.player`）进行类型转换，以满足tsc编译器。由于Android没有等效功能，我们将仅使用标准媒体播放器的播放方法，这对于Android来说效果很好。
- en: 'Let''s now adjust our pause method with a similar safeguard:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用类似的安全措施调整我们的暂停方法：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By using the first track's `currentTime` as the **pace setter**, we pause each
    track in our mix and ensure they remain at exactly the same time by seeking to
    the same `currentTime` immediately after pausing. This helps ensure that, when
    we resume play, they all start from the same point in time. Let's put all this to
    use in the next section when we build a custom shuttle slider.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用第一首轨道的`currentTime`作为**速度设置器**，我们在我们的混音中暂停每首轨道，并通过在暂停后立即跳转到相同的`currentTime`来确保它们保持完全相同的时间。这有助于确保当我们恢复播放时，它们都从相同的时间点开始。让我们在下一节中构建自定义穿梭滑块时使用所有这些功能。
- en: Creating a custom ShuttleSliderComponent
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义ShuttleSliderComponent
- en: We can't have a multitrack studio experience without the ability to shuttle
    back and forth through our mix! Let's double down on `Slider` and enhance its
    capabilities by combining the best of all the options NativeScript and Angular
    provide us. In the process, our player controls will start to become much more
    useful.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有来回穿梭混音的能力，我们就无法拥有多轨录音室体验！让我们加大力度，增强`Slider`的功能，通过结合NativeScript和Angular为我们提供的所有最佳选项。在这个过程中，我们的播放器控件将开始变得非常有用。
- en: 'Starting at the high level, open `app/modules/player/components/player-controls/player-controls.component.html`
    and replace it with the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次开始，打开`app/modules/player/components/player-controls/player-controls.component.html`并将其替换为以下内容：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are replacing `GridLayout` with `StackLayout` to change up our player control''s
    layout a bit. Let''s go with a full-width slider stacked on top of our play/pause
    button. What we''re after is similar to the Apple Music app on an iPhone, where
    the slider is full width with the current time and duration displayed underneath.
    Now, let''s build our custom `shuttle-slider` component and create `app/modules/player/components/player-controls/shuttle-
    slider.component.html` with the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在用`StackLayout`替换`GridLayout`，以改变我们的播放器控件布局。让我们使用一个全宽的滑块堆叠在我们的播放/暂停按钮上方。我们追求的效果类似于iPhone上的Apple
    Music应用，其中滑块是全宽的，下面显示了当前时间和持续时间。现在，让我们构建我们的自定义`shuttle-slider`组件，并创建`app/modules/player/components/player-controls/shuttle-slider.component.html`，内容如下：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here's where things are going to get very interesting. We are going to combine
    Angular bindings where useful, like these bindings: `[maxValue]="duration"` and `[text]="durationDisplay"` .
    However for the rest of our usability wiring we will want more fine grained and
    manual control. For instance, our containing `GridLayout` via `#sliderArea` is
    going to be the area the user is going to be able to touch to shuttle back/forth
    instead of the `Slider` component itself, and we are going to completely disable
    user interaction with the Slider itself (hence, the `slim-slider` directive attribute,
    you see). The slider is going to instead be used just for its visual representation
    of time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we will be doing this is because we want this interaction to kick
    off several programmatic actions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Pause playback (if playing) while shuttling
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the current time display label as we move back/forth
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kick off the `seekTo` commands to our track player's instances in a controlled
    manner; hence, reducing extraneous seek commands
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resume playback when no longer shuttling if it was playing before attempting
    to shuttle
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we used `Slider` with an Angular binding to `currentTime` via the `currentTime$`
    observable, which in turn was being controlled by our interaction with it in addition
    to the state of our track's players, things would be coupled too tightly to achieve the
    fine grain control we need.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of what we are about to do here serves as an exemplary testament
    to how flexible the combination of Angular with NativeScript really is. Let''s
    start programming our interactions in `app/modules/player/components/player-controls/shuttle-slider.component.ts`; here''s
    the complete setup for you to view in full, which we will break down in a moment:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For a rather small component footprint, there's a ton of great stuff going on
    here! Let's break it down.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at those property decorators, starting with `@Input`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we have our `@ViewChild` references:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can then access those `ElementRef` instances in our component to programmatically
    work with them; however, not right away. Since `ElementRef` is a proxy wrapper
    to the view component, its underlying `nativeElement` (our actual NativeScript
    component) is only accessible once Angular's component lifecycle hook `ngAfterViewInit`
    fires.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn all about Angular''s component lifecycle hooks here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[https://angular.io/docs/ts/latest/guide/lifecycle- hooks.html.](https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we assign private references to our actual NativeScript components
    here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We also take this opportunity to reference the overall screen width using the
    **density-independent pixel** (**dip**) units via the `screen` utility from the
    `platform` module. This will allow us to do some calculations using our user's
    finger position on our `sliderArea` StackLayout to adjust the actual value of
    `Slider`. We then make a call to set up our essential event handlers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our `_sliderArea` reference to the containing StackLayout, we add a `touch`
    gesture listener to capture any touches the user makes to our slider area:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This allows us to grab the `X` position of their finger via `args.getX()`. We
    use that to divide into the user's device screen width to determine a percentage
    from the left to the right. Since our calculation is not exactly precise, we make
    a small adjustment when the user passes the 50% mark. This usability works well
    for our use case right now, but we will reserve the option to improve that later;
    however, it's perfectly fine for now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'We then multiply the duration by this percentage to get our `seekTo` mark to
    update our value of  `Slider` in order to get immediate UI updates using manual
    precision:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are actually using our NativeScript components directly without Angular's
    bindings or NgZone in the mix. This can be very handy in cases where you need
    fine grained and performance control of your UI. Since we want the `Slider` track
    to move immediately with the user's finger, as well as the time display label
    formatted with standard musical timecode to represent real time as they interact,
    we set their values directly at the appropriate time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We then use a seek delay timeout to ensure we don't make extraneous seek commands
    to our multitrack player. Each movement by the user will further delay making
    an actual seek command until they rest where they want it. We also use our `isIOS`
    Boolean to convert the time as appropriately needed by each platform audio player
    (seconds for iOS and milliseconds for Android).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Most interesting might be our `ngOnChanges` lifecycle hook:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Angular calls its `ngOnChanges()` method whenever it detects changes to the
    ***input properties*** of the component (or directive).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: This is a wonderful way for `ShuttleSliderComponent` to react to its `Input`
    property changes, `currentTime`, and `duration`. Here, we simply update our slider
    and the current time display label manually via `this._updateSlider(this.currentTime)`
    only when it does fire with a valid number. Lastly, we also ensure we update our
    duration display label. This method will fire every second the PlayerService's
    `currentTime$` observable fires while an active subscription exists. **Nice!**
    Oh, and don't forget to add `ShuttleSliderComponent` to the `COMPONENTS` array
    to be included with the module.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to actually implement this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We are going to use a couple more nifty observable tricks with our seeking
    state. Let''s open our PlayerService in `app/modules/player/services/player.service.ts`
    and add the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are introducing three new observable operators `switchMap`, `never`, and
    `of`, which we need to ensure are also imported in our `app/operators.ts` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`switchMap` allows our observable to switch streams based on several conditions,
    helping us to manage whether `currentTime` needs to emit updates or not. Clearly,
    when seeking, we don''t need to react to the `currentTime` changes. Therefore,
    we switch our Observable stream to `Observable.never()` while `this._seeking`
    is true, ensuring our observer is never called.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: In our `seeking` setter, we adjust the internal state reference (`this._seeking`)
    ,and if it was currently `this._playing` and had not yet been paused due to seeking
    (hence, `!this._seekPaused`), we immediately pause playback (only once). We then
    set up another timeout to delay resuming playback an additional 400 milliseconds
    after `seekTo` has been fired from the component if it was playing when seek started
    (hence, the check on `this._seekPaused`).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: This way, the user is free to move their finger across our shuttle slider as
    much as they'd like and as quickly as they'd like. They will see immediate UI
    updates to the `Slider` track as well as the current time display label in real
    time; all the while we are avoiding extraneous `seekTo` commands being sent to
    our multitrack player until they come to rest, providing a really nice user experience.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Creating SlimSliderDirective for iOS and Android native API modifications
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still have a directive to create for that `slim-slider` attribute we had
    on `Slider`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are going to create platform-specific directives, since we will tap into
    the slider's actual native API on iOS and Android to disable user interaction
    and hide the thumb for a seamless appearance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'For iOS, create `app/modules/player/directives/slider.directive.ios.ts` with
    the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We gain access to the underlying native iOS `UISlider` instance via NativeScript's
    `ios` getter off the `Slider` component itself. We use Apple's API reference documentation
    ([https://developer.apple.com/reference/uikit/uislider](https://developer.apple.com/reference/uikit/uislider))
    to locate an appropriate API to disable interaction via the `userInteractionEnabled`
    flag and hide the thumb by setting a blank as the thumb. Perfect.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'For Android, create `app/modules/player/directives/slider.directive.android.ts`
    with the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We gain access to the native `android.widget.SeekBar` instance via the `android`
    getter on the `Slider` component. We use Android's API reference documentation
    ([https://developer.android.com/reference/android/ widget/SeekBar.html](https://developer.android.com/reference/android/widget/SeekBar.html))
    to locate the SeekBar's API and disable user interaction by overriding `OnTouchListener`,
    and we hide the thumb by setting its Drawable alpha to 0.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create `app/modules/player/directives/slider.directive.d.ts`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will allow us to import and use our `SlimSlider` class as a standard ES6
    module; Create `app/modules/player/directives/index.ts`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At runtime, NativeScript will only build the appropriate platform-specific files
    into the target platform, completely excluding nonapplicable code. This is a very
    powerful way to create platform-specific functionality in your codebase.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，NativeScript只会将适当的平台特定文件构建到目标平台中，完全排除不适用代码。这是在代码库中创建平台特定功能的一种非常强大的方式。
- en: 'To finish up, let''s just ensure our directives are declared in `PlayerModule`
    at `app/modules/player/player.module.ts` with the following changes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保我们的指令已声明在`PlayerModule`中，位于`app/modules/player/player.module.ts`，以下是一些更改：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We should now see this on iOS with our playback paused at 6 seconds:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该在iOS上看到这一点，我们的播放暂停在6秒处：
- en: '![](img/00034.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: 'For Android, it will be as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，情况如下：
- en: '![](img/00035.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: 'You can now observe the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以观察到以下情况：
- en: All the three tracks play together in a perfect mix
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有三个轨道以完美的混音一起播放
- en: Playback can be shuttled via the slider whether it's playing or not
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不论是否正在播放，都可以通过滑块切换播放
- en: The play/pause toggle
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放/暂停切换
- en: When playback reaches the end, our controls properly reset
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当播放结束时，我们的控件会正确重置
- en: And it all works on iOS and Android. An amazing feat, without question.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这一切在iOS和Android上都能正常工作。毫无疑问，这是一项了不起的成就。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are now fully immersed in the rich world of NativeScript, having introduced
    plugin integration as well as direct access to native APIs on iOS and Android.
    To top it off, we have a really neat multitrack player with full playback control,
    including shuttling through the mix!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完全沉浸在NativeScript的丰富世界中，因为我们已经介绍了插件集成以及iOS和Android上对原生API的直接访问。更不用说，我们还有一个非常棒的具有完整播放控制的多人轨播放器，包括在混音中切换！
- en: The exciting combination of Angular, including its RxJS observable underpinnings,
    is really starting to shine through, where we've been able to take advantage of
    view bindings where needed and react to service event streams with powerful observable
    compositions, all while still retaining the ability to manually control our UI
    with fine grain control. Whether our view needs an Angular directive to enrich
    its capabilities or manual touch gesture control via raw NativeScript capabilities,
    we have it all at our fingertips now.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 包括其RxJS可观察性基础在内的Angular的激动人心的组合，现在开始真正闪耀，我们能够在需要的地方利用视图绑定，并使用强大的可观察性组合对服务事件流做出反应，同时仍然保留手动以细粒度控制我们的UI的能力。无论是我们的视图需要Angular指令来丰富其功能，还是通过原始NativeScript功能的手动触摸手势控制，我们现在都可以轻松掌握。
- en: The fact that all along we are building a fully native iOS and Android app is
    truly mind blowing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们一直在构建一个完全本地的iOS和Android应用程序，这确实令人震惊。
- en: In the next chapter, we will continue to dig further into native APIs and plugins
    as we bring recording into our app's abilities to deliver on the core requirements
    of our multi-track recording studio mobile app.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续深入挖掘原生API和插件，随着我们将录音功能引入我们的应用程序，以满足多轨录音室移动应用程序的核心需求。
