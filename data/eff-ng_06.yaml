- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Applying Code Conventions and Design Patterns in Angular
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中应用代码规范和设计模式
- en: In this chapter, we will explore code conventions, best practices, and design
    patterns commonly used within Angular applications. You will also create a generic
    HTTP service and mock API responses using an HTTP interceptor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Angular应用程序中常用的代码规范、最佳实践和设计模式。你还将创建一个通用的HTTP服务，并使用HTTP拦截器模拟API响应。
- en: Following good code conventions allows you to write code consistently. Whether
    you write your code solo or in a team, conventions ensure that you use similar
    syntax for common occurrences and follow best practices. Using good design patterns
    helps you to write code implementations that scale well and are battle-tested.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循良好的代码规范可以使你编写出一致的代码。无论你是单独编写代码还是在团队中，规范都能确保你使用相似的语法来处理常见情况，并遵循最佳实践。使用良好的设计模式可以帮助你编写出扩展性好且经过实战检验的代码实现。
- en: Code conventions and best practices focus more on processes and style-related
    aspects such as using the CLI, naming, using types, or preventing nested observables.
    Design patterns, on the other hand, focus on how you set up, handle, and implement
    common occurrences, problems, and flows within your code base.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 代码规范和最佳实践更多地关注过程和与风格相关的方面，例如使用CLI、命名、使用类型或防止嵌套可观察对象。另一方面，设计模式关注的是你如何在代码库中设置、处理和实现常见情况、问题和流程。
- en: By the end of this chapter, you will know all about code conventions, best practices,
    and commonly used design patterns within Angular applications. Some patterns and
    principles you will learn about in this chapter are inheritance, facade services,
    observables, reactive programming, and anti-patterns. This chapter will provide
    a good foundation for the following chapters, where we dive deep into reactive
    programming and state management. The chapter will help you understand the benefits
    of good design patterns and code conventions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解Angular应用程序中所有关于代码规范、最佳实践和常用设计模式的内容。在本章中，你将学习到的某些模式和原则包括继承、外观服务、可观察对象、响应式编程和反模式。本章将为后续章节提供一个良好的基础，在这些章节中，我们将深入探讨响应式编程和状态管理。本章将帮助你理解良好设计模式和代码规范的好处。
- en: 'This chapter will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Exploring commonly used code conventions and best practices in Angular applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Angular应用程序中常用的代码规范和最佳实践
- en: Exploring commonly used design patterns in Angular applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Angular应用程序中常用的设计模式
- en: Building a generic HTTP service containing a model adapter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建包含模型适配器的通用HTTP服务
- en: Exploring commonly used code conventions and best practices in Angular applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Angular应用程序中常用的代码规范和最佳实践
- en: In this chapter’s first section, you will learn about **code conventions** and
    best practices within Angular applications. Using code conventions ensures that
    everyone working on your project uses similar naming for variables, files, and
    folders. Good code conventions also make code more readable and allow you to recognize
    certain features, implementations, or data types quickly. In addition, code conventions
    make your code consistent and easier to debug, refactor, and understand. Setting
    up good code conventions for your project promotes the usage of best practices.
    Code conventions also make it easier for new developers to be onboarded into the
    code base, as they have a set of rules they can follow that allows them to write
    code in a similar way to the rest of the people working on the code base.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，你将了解Angular应用程序中的**代码规范**和最佳实践。使用代码规范确保所有参与你项目的人使用相似的变量、文件和文件夹命名。良好的代码规范还能使代码更易于阅读，并允许你快速识别某些特性、实现或数据类型。此外，代码规范使你的代码更加一致，更容易调试、重构和理解。为你的项目设置良好的代码规范可以促进最佳实践的使用。代码规范还使新开发者更容易融入代码库，因为他们有一套规则可以遵循，这使他们能够以与其他代码库工作者相似的方式编写代码。
- en: Personally, I think it’s a good practice to create a document with all code
    conventions and best practices you adopt within your project. This way, new people
    have something to go off of besides what they see in the code. What code conventions
    your company adopts is entirely up to the people writing and maintaining the code
    base. However, some commonly used conventions and best practices within the Angular
    community exist.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 个人认为，创建一个包含你在项目中采用的所有代码规范和最佳实践的文档是一个好习惯。这样，新来的人除了在代码中看到的内容外，还有其他可以参考的东西。你公司采用的代码规范完全取决于编写和维护代码库的人。然而，Angular
    社区中存在一些常用的规范和最佳实践。
- en: For starters, Angular has a *style guide* in which it declares everything it
    considers a good practice and why. You can find the style guide on the official
    Angular website at [https://angular.io/guide/styleguide](https://angular.io/guide/styleguide).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Angular 有一个 *风格指南*，其中声明了它认为的所有良好实践及其原因。你可以在官方 Angular 网站上找到该风格指南：[https://angular.io/guide/styleguide](https://angular.io/guide/styleguide)。
- en: Next, we learn about common conventions and best practices for Angular applications.
    We will start with naming and structural conventions and follow this up with best
    practices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习 Angular 应用程序中常见的规范和最佳实践。我们将从命名和结构规范开始，然后继续介绍最佳实践。
- en: Naming conventions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名规范
- en: Naming is the main focus of conventions. **Naming conventions** are essential
    to ensuring maintainability and readability. Good naming conventions allow you
    to navigate the code base easily and find content quickly. Naming conventions
    apply to several aspects of the code, so we will divide them up, starting with
    folders and files.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 命名是规范的主要焦点。**命名规范**对于确保可维护性和可读性至关重要。良好的命名规范使你能够轻松地导航代码库并快速找到内容。命名规范适用于代码的多个方面，因此我们将它们分开，从文件夹和文件开始。
- en: Naming folders and files
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名文件夹和文件
- en: File and folder names should clearly describe the intent of the folder or file.
    This way, you can quickly locate files and folders you need even when the project
    grows. For folders, you should use single words, but if you do use multiple words,
    you can separate them with a dash (`-`). For file names, you can use the format
    of `feature.type.ts`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和文件夹名称应清楚地描述文件夹或文件的目的。这样，即使项目增长，你也能快速找到所需的文件和文件夹。对于文件夹，你应该使用单词，但如果确实使用了多个单词，你可以用破折号（`-`）将它们分开。对于文件名，你可以使用
    `feature.type.ts` 的格式。
- en: The feature describes what the file entails and the type refers to things such
    as components, services, directives, pipes, and so on (some examples include `expenses-list.component.ts`,
    `expenses.service.ts`, and `unit.directive.ts`). Use conventional names for the
    file types (`.component`, `.directive`, `.service`, `.pipe`, `.module`, `.directive`,
    `.store`, `.actions`, `.stories`). For unit tests, use `.spec` for the type. Lastly,
    it’s wise to prevent duplicate folder or file names. As your monorepo grows, avoiding
    duplicate file or folder names might not always be possible, but try to prevent
    it for as long as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能描述了文件包含的内容，而类型则指代诸如组件、服务、指令、管道等事物（一些例子包括 `expenses-list.component.ts`、`expenses.service.ts`
    和 `unit.directive.ts`）。请使用传统的文件类型名称（`.component`、`.directive`、`.service`、`.pipe`、`.module`、`.directive`、`.store`、`.actions`、`.stories`）。对于单元测试，请使用
    `.spec` 作为类型。最后，避免重复的文件夹或文件名是明智之举。随着你的单一代码库的增长，避免重复的文件或文件夹名称可能并不总是可能的，但尽可能长时间地避免它。
- en: Besides naming conventions for files and folders, adhering to naming conventions
    within your code is vital. It would be best to keep naming consistent for your
    classes, properties, functions, selectors, and other aspects of your code. Having
    good naming conventions within your code helps you to quickly identify different
    parts of your code, improving readability and making refactoring and maintaining
    your code easier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件和文件夹的命名规范外，遵守代码中的命名规范同样至关重要。最好保持你的类、属性、函数、选择器和其他代码方面的命名一致性。代码中的良好命名规范帮助你快速识别代码的不同部分，提高可读性，并使重构和维护代码变得更加容易。
- en: Naming conventions within your code
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码中的命名规范
- en: Angular is predominantly a class-based framework, so let’s start by naming classes.
    All classes should use upper camel case. Upper camel case is when you start every
    word with an uppercase letter. The class names should equal the file feature combined
    with the file type. So, `expenses-list.component.ts` becomes `ExpensesListComponent`
    and `expenses.service.ts` becomes `ExpensesService`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Angular主要是一个基于类的框架，所以让我们从命名类开始。所有类都应该使用大驼峰式命名法。大驼峰式命名法是指每个单词都以大写字母开头。类名应该等于文件功能与文件类型的组合。因此，`expenses-list.component.ts`变为`ExpensesListComponent`，而`expenses.service.ts`变为`ExpensesService`。
- en: Another important part of Angular applications is the selectors of components,
    directives, and pipes. For components and directives, it’s a convention to prefix
    the selectors. Make the selector prefix unique so you can distinguish it from
    selectors from any third-party libraries you might use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序的另一个重要部分是组件、指令和管道的选择器。对于组件和指令，有一个约定是使用前缀。使选择器前缀独特，以便你可以将其与可能使用的任何第三方库的选择器区分开来。
- en: Component selectors are all lowercase and words are separated with dashes. For
    directive selectors, you use regular camel case. With regular camel case, the
    first word is in lowercase and all subsequent words start with a capital letter.
    With selectors for pipes, you should use a single word in all lowercase without
    a prefix. For pipes, use regular camel case if you have to use multiple words
    for the pipe selector.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 组件选择器全部使用小写字母，单词之间用连字符分隔。对于指令选择器，你使用常规的驼峰式命名法。在常规驼峰式命名法中，第一个单词以小写字母开头，所有后续单词以大写字母开头。对于管道选择器，你应该使用一个单词，全部小写，不带前缀。如果必须使用多个单词作为管道选择器，则使用常规驼峰式命名法。
- en: 'There are also some common conventions when we look at the code within classes
    (or function files):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看类（或函数文件）内的代码时，也有一些常见的约定：
- en: 'First, we use camel case to declare properties, functions, and methods. Using
    descriptive names for your properties, functions, and methods is also important.
    When you handle events or component outputs with functions, you should prefixed
    these functions with `on` (`onClick`, `onAddExpense`, `onHover`):'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用驼峰式命名法来声明属性、函数和方法。为你的属性、函数和方法使用描述性名称也很重要。当你用函数处理事件或组件输出时，你应该在这些函数前加上`on`前缀（如`onClick`、`onAddExpense`、`onHover`）：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '@Output() saved = new EventEmitter<boolean>();   // Good'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Output() saved = new EventEmitter<boolean>();   // Good'
- en: '@Output() $):'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Output() $):'
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that you know about naming conventions for files and naming conventions
    for your code, let’s look at some conventions for structuring your files and projects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了文件命名规范和代码命名规范，让我们来看看一些关于文件和项目结构的约定。
- en: Structural conventions
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构性约定
- en: Besides naming conventions, you can have conventions for structuring your files
    and projects. Like good naming, having a predictable and good structure inside
    your files and projects helps with readability and maintainability. With a good
    file structure, you can easily recognize and find the parts of code that you need.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命名规范外，你还可以为你的文件和项目结构制定规范。像好的命名一样，在你的文件和项目中拥有可预测和良好的结构有助于可读性和可维护性。有了良好的文件结构，你可以轻松识别和找到所需的代码部分。
- en: First, it’s a good convention to use the **rule of one**. Each file should serve
    a single purpose. Having a single purpose for each file makes it easier to read
    and maintain them, and it keeps the files small. A single purpose for each file
    also makes it easy to locate bugs. It would be best if you also tried to limit
    files to a maximum of 400 lines. When a file exceeds 400 lines of code, it’s a
    good indicator that you might need to split it up and move some methods to a separate
    file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用**单一规则**是一个好的约定。每个文件应该只服务于单一目的。每个文件只有一个目的会使它们更容易阅读和维护，并保持文件大小适中。每个文件只有一个目的也使得定位错误变得容易。最好尝试将文件限制在最多400行。当一个文件超过400行代码时，这是一个很好的迹象，表明你可能需要将其拆分，并将一些方法移动到单独的文件中。
- en: You should watch the size of your file and also the size of your functions.
    Ideally, functions should not be more than 50 lines, and it’s best to keep them
    under 25 lines. Some exceptions might exist, but splitting them into separate
    functions when they grow larger is better. When functions grow too large, they
    become hard to read, test, and debug.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该关注你的文件大小以及函数的大小。理想情况下，函数不应超过50行，最好控制在25行以下。可能会有一些例外，但当函数变得更大时，将它们拆分成单独的函数会更好。当函数变得过大时，它们就变得难以阅读、测试和调试。
- en: In Angular, you can write the template, CSS, and logic in a single file, but
    extracting the template and CSS into their own files is recommended. Using a separate
    file for the template and CSS promotes the rule of one, where each file has a
    single purpose, and it also helps with readability and maintainability. If your
    template consists of one or two HTML tags without additional styling, you can
    make an exception and place everything in a single file. However, I would still
    separate the template and component class. Besides separating your files into
    dedicated HTML, CSS, and TypeScript files, a good folder structure also helps
    with maintaining a clear overview, so let’s look at some conventions for our folder
    structure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，你可以在一个文件中编写模板、CSS和逻辑，但将模板和CSS提取到它们自己的文件中是推荐的。使用单独的文件来存储模板和CSS促进了单一用途原则，即每个文件只有一个目的，这也有助于可读性和可维护性。如果你的模板只包含一个或两个HTML标签而没有额外的样式，你可以例外，将所有内容放在一个文件中。然而，我仍然会分离模板和组件类。除了将你的文件分离到专门的HTML、CSS和TypeScript文件中之外，良好的文件夹结构也有助于保持清晰的概述，因此让我们来看看我们的文件夹结构的一些约定。
- en: Try to maintain a flat folder structure for as long as possible. Having a lot
    of nested folders makes it easier to find the folders and files you need and can
    make your overview of the folder and file structure clearer. Create a folder or,
    better yet, a library for each domain in your project. You should split your code
    inside these libraries into `data-access`, `features`, `UI`, and `utils`. Each
    element inside your `data-access`, `features`, `UI`, and `utils` libraries should
    also be its own library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能长时间保持扁平的文件夹结构。拥有大量的嵌套文件夹可以更容易地找到所需的文件夹和文件，并可以使你对文件夹和文件结构的概述更加清晰。为你的项目中的每个领域创建一个文件夹，或者更好的是，创建一个库。你应该将这些库中的代码分割到`data-access`、`features`、`UI`和`utils`中。`data-access`、`features`、`UI`和`utils`库中的每个元素也应该是一个独立的库。
- en: Using libraries promotes an API-driven architecture and ensures good separation
    of concerns. By having an API-driven architecture, you also start to write more
    reusable code. Inside each library, you have an `index.ts` file to export what
    you need to consume elsewhere.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库可以促进API驱动的架构，并确保关注点的良好分离。通过采用API驱动的架构，你也将开始编写更多可重用的代码。在库的内部，你有一个`index.ts`文件来导出你需要在其他地方使用的内容。
- en: Next, it’s recommended to use the **DRY principle**. DRY stands for “Don’t repeat
    yourself.” When your mono repository grows larger, sometimes you can’t help repeating
    yourself, but in general, you should try to write code only once and share it
    where you need it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，建议使用**DRY原则**。DRY代表“不要重复自己”。当你的单一代码库变得更大时，有时你不可避免地会重复自己，但一般来说，你应该尽量只编写一次代码，并在需要的地方共享它。
- en: 'Lastly, you need a way to order your code within your files. A common way to
    order your code is by using the following structure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要一种方法来对你的文件中的代码进行排序。一个常见的排序方法是使用以下结构：
- en: '`@``Input()` decorators'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Input()`装饰器'
- en: '`@``Output()` decorators'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Output()`装饰器'
- en: Public properties and private properties
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共属性和私有属性
- en: Constructor
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Getters and setters
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: Lifecycle hooks
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: Public methods and private methods
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共方法和私有方法
- en: Sort properties and methods alphabetically (after dividing them into public
    and private properties and methods). Initialize `@Input()` directives whenever
    possible, and when using lifecycle hooks, implement the interface as well.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性和方法按字母顺序排序（在将它们分为公共属性和方法和私有属性和方法之后）。尽可能初始化`@Input()`指令，并在使用生命周期钩子时，也要实现该接口。
- en: You can extend the before-mentioned conventions to make your project more robust
    and uniform. The number of conventions you should come up with and try to use
    is unlimited, but for now, you have a good starting point and idea of what your
    conventions should look like and focus on. Next, we will discuss some best practices
    within Angular applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将上述约定扩展，使你的项目更加健壮和统一。你应该提出并尝试使用的约定数量没有限制，但就目前而言，你有一个良好的起点，并了解你的约定应该是什么样子，以及应该关注什么。接下来，我们将讨论Angular应用中的一些最佳实践。
- en: Using best practices in Angular applications
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Angular应用中使用最佳实践
- en: Using best practices ensures that you do things properly and your code stays
    robust, maintainable, and scalable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最佳实践确保你正确地做事，并且你的代码保持健壮、可维护和可扩展。
- en: The first best practice is to use the Angular CLI (or the Nx CLI when using
    Nx) as much as possible. Using the CLI to generate components, services, directives,
    projects, libraries, and other elements ensures consistency. When using the Nx
    CLI, you’re also assured that all dependencies and settings are configured properly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项最佳实践是尽可能多地使用 Angular CLI（或在使用 Nx 时使用 Nx CLI）。使用 CLI 生成组件、服务、指令、项目、库和其他元素可以确保一致性。当使用
    Nx CLI 时，你还可以确保所有依赖项和设置都配置正确。
- en: Use the new standalone components, directives, and pipes as much as possible.
    Using the new standalone API helps better isolate your logic, making debugging
    and testing your components, pipes, and directives easier. Using the standalone
    API also helps to reduce your bundle sizes, resulting in faster load times. You
    should also use the new `inject` function over constructor injection for dependency
    injection. The `inject` function provides more flexibility and is no hindrance
    when you use inheritance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地使用新的独立组件、指令和管道。使用新的独立 API 可以更好地隔离你的逻辑，使得调试和测试你的组件、管道和指令变得更容易。使用独立 API 还有助于减小你的包大小，从而实现更快的加载时间。你还应该使用新的
    `inject` 函数代替构造函数注入进行依赖注入。`inject` 函数提供了更多的灵活性，并且在使用继承时不会造成阻碍。
- en: 'Always use access modifiers on your properties and methods. In Angular, we
    have three access modifiers: `public`, `private`, and `protected`. Using the correct
    access modifiers makes it easy to identify what can be used where and helps to
    prevent bugs and unintended behavior.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在你的属性和方法上使用访问修饰符。在 Angular 中，我们有三种访问修饰符：`public`、`private` 和 `protected`。使用正确的访问修饰符可以轻松识别可以在哪里使用什么，并有助于防止错误和意外的行为。
- en: Performance-related best practices
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与性能相关的最佳实践
- en: There are a bunch of best practices related to performance. First, always use
    the `trackBy` function on the `*ngFor` directive. When you use the new control
    flow syntax introduced in Angular 17, you are required to use the `track` function.
    Using the new control flow syntax is recommended as it improves readability, and
    you don’t need to import the common module to use them, so it will reduce your
    bundle sizes a bit.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与性能相关有许多最佳实践。首先，始终在 `*ngFor` 指令上使用 `trackBy` 函数。当你使用 Angular 17 中引入的新控制流语法时，你必须使用
    `track` 函数。使用新的控制流语法是推荐的，因为它提高了可读性，并且你不需要导入公共模块来使用它们，因此可以稍微减小你的包大小。
- en: Next, you should use *lazy loading* as much as possible as this ensures that
    you only download what your user requests. With the new standalone components,
    you can easily lazy load every route, and with new defer blocks introduced in
    Angular 17, you can even lazy load different parts of the HTML templates.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你应该尽可能多地使用 *懒加载*，因为这可以确保你只下载用户请求的内容。使用新的独立组件，你可以轻松地懒加载每个路由，并且随着 Angular
    17 中引入的新延迟块，你甚至可以懒加载 HTML 模板的不同部分。
- en: You should try to use the `OnPush` change detection strategy inside your components
    as much as possible. Using `OnPush` change detection reduces the number of times
    Angular renders your template. For even better change detection and performance,
    you should also utilize Angular signals as much as possible to manage the synchronous
    state in your application (we will discuss signals in detail in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在组件内部尽可能多地使用 `OnPush` 变更检测策略。使用 `OnPush` 变更检测可以减少 Angular 渲染模板的次数。为了更好的变更检测和性能，你还应该尽可能多地利用
    Angular 信号来管理应用程序中的同步状态（我们将在 [*第 7 章*](B21625_07.xhtml#_idTextAnchor129) 中详细讨论信号）。
- en: For asynchronous data flows, you should use `async` pipe as much as possible.
    The `async` pipe unsubscribes automatically for you when the component is destroyed
    or the property is assigned with a new observable; this prevents memory leaks
    and improves the performance of your application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步数据流，你应该尽可能多地使用 `async` 管道。当组件被销毁或属性被分配新的可观察对象时，`async` 管道会自动为你取消订阅；这可以防止内存泄漏并提高应用程序的性能。
- en: 'Don’t use function calls or getters in your HTML templates. Calling functions
    or using getters in the template negatively impacts the performance of your application.
    Use **CDK virtual scroll** to display large lists. The CDK virtual scroll will
    only render the elements displayed inside the view instead of the entire list.
    Use pure pipes as much as possible:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在你的 HTML 模板中使用函数调用或获取器。在模板中调用函数或使用获取器会对应用程序的性能产生负面影响。使用 **CDK 虚拟滚动** 来显示大量列表。CDK
    虚拟滚动只会渲染视图内部显示的元素，而不是整个列表。尽可能多地使用纯管道：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For example, when using the `ngOnChanges` lifecycle to assign a property based
    on the newly received input values, there is a big chance you can handle the same
    using a pipe. Using pure pipes is better for performance and promotes reusability.
    Don’t use `filter`, `forEach`, `reduce`, or `map` on arrays inside pipes, as this
    negatively affects the performance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用 `ngOnChanges` 生命周期来根据新接收的输入值分配属性时，有很大可能性你可以使用管道来处理相同的情况。使用纯管道对性能更好，并促进了可重用性。不要在管道内的数组上使用
    `filter`、`forEach`、`reduce` 或 `map`，因为这会负面影响性能。
- en: Lastly, you should cache API requests for as long as feasible and do the same
    with resource-intensive methods.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该尽可能长时间地缓存API请求，以及资源密集型方法也是如此。
- en: Preventing bugs with best practices
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用最佳实践防止bug
- en: Besides performance-related best practices, there are some best practices to
    prevent bugs and improve testability and maintainability. Avoid `any` types in
    your code. Having everything strongly typed prevents bugs, improves suggestions,
    and makes debugging and testing easier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与性能相关的最佳实践外，还有一些最佳实践可以防止bug并提高可测试性和可维护性。避免在代码中使用 `any` 类型。将所有内容都进行强类型化可以防止bug，提高建议，并使调试和测试更容易。
- en: When you have observables inside component classes that aren’t used within the
    template, use the RxJS `takeUntilDestroyed`, `takeUntil`, or `take` operators.
    These three operators ensure that your subscriptions on observables are unsubscribed
    correctly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件类中存在未被模板内使用的可观察对象时，请使用 RxJS 的 `takeUntilDestroyed`、`takeUntil` 或 `take` 操作符。这三个操作符确保你的可观察对象订阅被正确取消。
- en: Also, don’t use nested observables; instead, use RxJS operators such as `combineLatest`
    and `withLatestFrom` to handle scenarios where you need nested observables. Nested
    observables can quickly lead to memory leaks and bugs that are difficult to debug.
    Nested observables are also hard to write tests for.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不要使用嵌套的可观察对象；相反，使用 RxJS 操作符如 `combineLatest` 和 `withLatestFrom` 来处理需要嵌套可观察对象的情况。嵌套的可观察对象可能导致内存泄漏和难以调试的bug。嵌套的可观察对象也难以编写测试。
- en: Additionally, avoid using multiple `ng-container` elements with an `async` pipe
    when you must await multiple observables before rendering a piece of HTML.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在必须等待多个可观察对象以渲染HTML片段之前，避免使用多个带有 `async` 管道的 `ng-container` 元素。
- en: 'Don’t do this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead, map both observables into a single observable inside your component
    class and use the single observable in the template with the `async` pipe:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在你的组件类中将两个可观察对象映射到单个可观察对象中，并在模板中使用 `async` 管道来使用这个单个可观察对象：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Combining the observables will prevent bugs, make your template more readable,
    and ensure everything is updated correctly when an observable receives new values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 合并可观察对象可以防止bug，使你的模板更易读，并确保当可观察对象接收到新值时，一切都能正确更新。
- en: Now that you know some best practices that prevent bugs, let’s explore best
    practices regarding your setup and architecture.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些防止bug的最佳实践，让我们来探讨关于设置和架构的最佳实践。
- en: Best practices for your project setup and architecture
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目设置和架构的最佳实践
- en: A good setup helps with better maintainability and standards throughout your
    codebase. We already discussed how to set up a project in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014),
    but to recap, use smart and dumb components.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的设置有助于提高整个代码库的可维护性和标准。我们已经在 [*第一章*](B21625_01.xhtml#_idTextAnchor014) 中讨论了如何设置项目，但为了回顾，请使用智能和哑组件。
- en: '*Smart components* connect with your state management and *dumb components*
    only receive data through inputs and output changes to the parents. This ensures
    you don’t have unintended dependencies and your component focuses on a single
    responsibility. Use `export default` on your components as much as possible to
    auto unwrap when lazy loading. Using default exports with automated unwraps keeps
    your routing files clean and readable.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能组件* 与你的状态管理连接，而 *哑组件* 只通过输入和输出变化接收父组件的数据。这确保了你不会有不预期的依赖，并且你的组件专注于单一职责。尽可能在你的组件上使用
    `export default` 以在懒加载时自动解包。使用默认导出和自动解包可以保持你的路由文件整洁易读。'
- en: Use the `canMatch` route guard over the `canActivate` and `canLoad` guards.
    The `canMatch` guard will not download the code if the guard returns false. Lastly,
    you need to use lint rules to enforce your conventions and best practices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `canMatch` 路由守卫而不是 `canActivate` 和 `canLoad` 守卫。如果守卫返回false，`canMatch` 守卫将不会下载代码。最后，你需要使用lint规则来强制执行你的约定和最佳实践。
- en: You have learned about naming and structural conventions. You also learned about
    best practices you can use within your Angular applications. Going forward, I
    will mention other best practices as we go, but first, we will learn about common
    design patterns in Angular applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了命名和结构规范。你还学习了可以在你的Angular应用程序中使用的最佳实践。向前看，我会在我们前进的过程中提到其他最佳实践，但首先，我们将学习Angular应用程序中的常见设计模式。
- en: Exploring commonly used design patterns in Angular applications
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Angular应用程序中常用的设计模式
- en: Design patterns help solve common software development problems in a predefined
    approach. Design patterns are like blueprints for building your application. Design
    patterns tell you how your code should behave and how to create a structure or
    separate parts of your code base. Using design patterns ensures that you have
    battle-tested solutions for common problems with a good level of abstraction so
    your code can scale without becoming a mess, entangled with dependencies all over
    the place, which is commonly referred to as “spaghetti code.”
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式帮助以预定义的方法解决常见的软件开发问题。设计模式就像构建应用程序的蓝图。设计模式告诉你代码应该如何表现，以及如何创建代码库的结构或分离代码库的各个部分。使用设计模式确保你拥有经过实战检验的解决方案，以良好的抽象级别解决常见问题，这样你的代码就可以扩展而不会变得混乱，不会到处纠缠着依赖，这通常被称为“意大利面代码”。
- en: '**Abstraction** in software development means you separate the details and
    behavior of your system from the implementation logic. For example, if you have
    a state management solution in your Angular application, you should separate the
    implementation of your state management from your component layer. By separating
    the component layer and state management solution, you can change your state management
    solution without touching your component layer. This provides extra flexibility
    and can save you some severe refactoring down the road as your application grows
    and its needs change.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**在软件开发中意味着你将系统的细节和行为与实现逻辑分离。例如，如果你的Angular应用程序中有一个状态管理解决方案，你应该将你的状态管理实现与组件层分离。通过分离组件层和状态管理解决方案，你可以更改你的状态管理解决方案，而无需触及组件层。这提供了额外的灵活性，并且可以在你的应用程序增长和需求变化时，避免一些严重的重构。'
- en: To stay with the state management example, in the beginning, you might manage
    your state using a simple approach with RxJS `Subject` and `BehaviorSubject`,
    but when the application grows and your state becomes more complex, you might
    want to change it for something such as **NgRx** or **NgXs** as they offer a safer,
    more robust and flexible approach for handling complex application state.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以状态管理为例，一开始，你可能使用RxJS的`Subject`和`BehaviorSubject`以简单的方式管理状态，但随着应用程序的增长和状态的复杂性增加，你可能希望将其更改为像**NgRx**或**NgXs**这样的东西，因为它们提供了更安全、更健壮和更灵活的方法来处理复杂的应用程序状态。
- en: Suppose your component layer is entangled with your state management. In that
    case, you have to refactor your entire application to switch the state management
    implementation. In contrast, if you have a good level of abstraction between the
    component layer and the state management solution, you can change the state management
    implementation without touching your components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的组件层与状态管理纠缠在一起。在这种情况下，你必须重构整个应用程序以切换状态管理实现。相反，如果你在组件层和状态管理解决方案之间有良好的抽象级别，你可以更改状态管理实现而不触及组件。
- en: Design patterns are a good starting point for solving common problems in software
    development, but they are no holy grail or a one-size-fits-all solution. You should
    always consider what is useful for your application; don’t overdo it by using
    design patterns where none are needed. When it makes sense to follow design patterns
    to the letter, you can do so, but when it doesn’t, adapt the patterns to fit your
    specific needs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是解决软件开发中常见问题的良好起点，但它们并不是神圣的圣杯或一刀切解决方案。你应该始终考虑什么对你的应用程序有用；不要过度使用设计模式，在没有需要的地方使用它们。当有必要严格遵循设计模式时，你可以这样做，但当不适用时，适应模式以适应你的特定需求。
- en: Now, without further ado, let’s explore some commonly used design patterns in
    Angular applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再拖延，让我们探索Angular应用程序中一些常用的设计模式。
- en: Creational design patterns in Angular
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular中的创建型设计模式
- en: '**Creational design patterns** form the foundation of how we create classes
    and objects within our applications. Within Angular applications, creational patterns
    are used by the framework for the creation of components, services, and other
    essential building blocks of the application. Developers can ensure modular, reusable,
    and maintainable code by implementing creational patterns, such as factory and
    singleton patterns.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建型设计模式**构成了我们在应用程序中创建类和对象的基础。在Angular应用程序中，创建型模式被框架用于创建组件、服务和其他应用程序的基本构建块。通过实现创建型模式，如工厂和单例模式，开发者可以确保代码模块化、可重用和可维护。'
- en: Singleton pattern
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例模式
- en: 'The **singleton pattern** is used to create a single instance of an object
    or class. Using the singleton pattern ensures that all code interacting with the
    singleton uses the same instance. Another advantage of the singleton pattern is
    good memory usage, as you only have to allocate memory for the object or the class
    once. In *Figure 6**.1*, you can see a visual representation of the singleton
    pattern:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例模式**用于创建一个对象或类的单个实例。使用单例模式确保所有与单例交互的代码都使用相同的实例。单例模式的另一个优点是良好的内存使用，因为您只需为对象或类分配一次内存。在*图6.1*中，您可以看到单例模式的视觉表示：'
- en: '![Figure 6.1: Singleton pattern](img/B21625_06_1.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：单例模式](img/B21625_06_1.jpg)'
- en: 'Figure 6.1: Singleton pattern'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：单例模式
- en: As you can see in *Figure 6**.1*, there is one single instance of a class used
    by different consumers. When you don’t use the singleton pattern, you have multiple
    instances of the global configuration class, where each consumer uses its own
    instance. Now that you know what the singleton pattern is, let’s explore how the
    pattern is commonly used in the context of Angular.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*图6.1*中可以看到，有一个类被不同的消费者使用。当您不使用单例模式时，全局配置类会有多个实例，每个消费者使用自己的实例。现在您已经知道了单例模式是什么，让我们来探讨在Angular环境中单例模式通常是如何被使用的。
- en: Within the context of Angular, the singleton pattern is mostly used in combination
    with dependency injection. When you create a service or provide other dependencies
    in your Angular applications, it’s generally done as a singleton, meaning only
    one instance of the dependency is created and shared by all consumers throughout
    the application. Because there is only one instance, you can safely use singleton
    services and classes to manage the state within your Angular application or handle
    other logic where each consumer needs access to the same instance, such as configurations
    and caching.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的上下文中，单例模式通常与依赖注入结合使用。当您在Angular应用程序中创建服务或提供其他依赖项时，通常是以单例的形式进行的，这意味着只创建一个依赖项实例，并由应用程序中的所有消费者共享。因为只有一个实例，所以您可以使用单例服务和类在Angular应用程序中管理状态或处理其他逻辑，例如配置和缓存。
- en: 'To provide a dependency as a singleton, you must provide it within your application’s
    *root providers array*. When working on an Angular application without modules,
    the root providers array is located in the `ApplicationConfig` object you provide
    to the `bootstrapApplication` method. If you use `ngModules` in your Angular application,
    you make a dependency a singleton by providing it in the app module. You can also
    use the `providedIn` root configuration object when it comes to services:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要将依赖项作为单例提供，您必须在应用程序的*根提供者数组*中提供它。在没有模块的Angular应用程序中工作，根提供者数组位于您提供给`bootstrapApplication`方法的`ApplicationConfig`对象中。如果您在Angular应用程序中使用`ngModules`，您可以通过在应用程序模块中提供依赖项来将其作为单例。您还可以在服务方面使用`providedIn`根配置对象：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In general, you can really only create a single instance of objects utilizing
    the singleton pattern. In the case of Angular dependencies, a singleton is created
    within the context of the provider array where the dependency is provided. We
    already explained the providers array and creation of dependencies in more detail
    in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您只能使用单例模式创建对象的单个实例。在Angular依赖项的情况下，单例是在提供依赖项的提供者数组上下文中创建的。我们已经在[*第2章*](B21625_02.xhtml#_idTextAnchor033)中更详细地解释了提供者数组和依赖项的创建。
- en: 'To further clarify the singleton pattern, let’s look at some real-world examples
    of when the pattern is useful:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阐明单例模式，让我们看看一些单例模式有用的实际例子：
- en: '**Managing the logged-in user**: If you have a class to manage the logged-in
    user, you want there to be a single instance of that class so that there is a
    single source of truth. If there are multiple copies of the class, the user data,
    login state, and other properties could vary amongst the different instances of
    the class, resulting in unintended behavior.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理已登录用户**：如果你有一个用于管理已登录用户的类，你想要这个类只有一个实例，这样就有了一个单一的真实来源。如果有多个类的副本，用户数据、登录状态和其他属性可能在类的不同实例之间有所不同，从而导致意外的行为。'
- en: '**State management**: When you have a class to manage the global application
    state, the singleton pattern is also a good fit. You want to ensure that everyone
    who needs the global application state receives the same value and can update
    it in the same source. If there are many instances of the state class, these instances
    can hold different values, resulting in a corrupted state. Keeping different instances
    synchronized can be a hard task, so using a single source of truth makes sense
    and uses less memory.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态管理**：当你有一个用于管理全局应用程序状态的类时，单例模式也是一个很好的选择。你想要确保所有需要全局应用程序状态的人都能收到相同的值，并且可以在同一源中更新它。如果有许多状态类的实例，这些实例可以持有不同的值，从而导致状态损坏。保持不同实例的同步可能是一项艰巨的任务，因此使用单一的真实来源是有意义的，并且使用更少的内存。'
- en: Now that you know about the singleton pattern and when it’s used within the
    Angular application, let’s explore the factory pattern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了单例模式以及它在Angular应用程序中的使用情况，让我们来探索工厂模式。
- en: Factory pattern
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂模式
- en: 'The **factory pattern** serves as a versatile blueprint for object creation.
    The factory pattern is beneficial in scenarios where the exact type of object
    needed is determined at runtime, allowing for dynamic instantiation based on certain
    conditions or parameters. By encapsulating object creation, the factory pattern
    prevents tight coupling between client code and specific classes, promoting maintainability,
    scalability, and easier modifications. *Figure 6**.2* shows a visual representation
    of the factory pattern:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂模式**作为对象创建的灵活蓝图。在需要运行时确定所需对象的确切类型的情况下，工厂模式是有益的，它允许根据某些条件或参数进行动态实例化。通过封装对象创建，工厂模式防止客户端代码与特定类之间的紧密耦合，从而促进可维护性、可扩展性和更容易的修改。*图6.2*展示了工厂模式的视觉表示：'
- en: '![Figure 6.2: Factory pattern](img/B21625_06_2.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：工厂模式](img/B21625_06_2.jpg)'
- en: 'Figure 6.2: Factory pattern'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：工厂模式
- en: As you can see in *Figure 6**.2*, we send the factory some information (in the
    figure, it’s a list of product details) and the factory creates what we want it
    to create and returns the result. In the figure, the factory creates and returns
    a product to the component using the factory. Now that you have a better idea
    of what the factory pattern is, let’s see how it is commonly used in the context
    of an Angular application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*图6.2*中可以看到的，我们向工厂提供一些信息（在图中，它是一系列产品详情的列表），然后工厂创建我们想要它创建的内容，并返回结果。在图中，工厂使用工厂创建并返回一个产品给组件。现在你对工厂模式有了更好的理解，让我们看看它在Angular应用程序的上下文中通常是如何使用的。
- en: 'Within the context of Angular, the factory pattern is also mainly used in combination
    with dependency injection. You can create a provider with the `useFactory` property
    and provide a factory method for creating the dependency value. Using the `useFactory`
    property in a provider can be useful when you want to provide different classes
    based on a condition or when you want to provide a value to the created class
    that is only accessible upon runtime:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的上下文中，工厂模式也主要是与依赖注入结合使用的。你可以使用`useFactory`属性创建一个提供者，并为创建依赖值提供一个工厂方法。在提供者中使用`useFactory`属性在你想根据条件提供不同的类，或者你想在运行时向创建的类提供只能访问的值时非常有用：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another place where you commonly use factory methods within Angular applications
    is in services. Oftentimes, services are used to create specific objects; this
    can be done with a factory method so you have a concise way to create the objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序中，你通常还会在服务中使用工厂方法。很多时候，服务被用来创建特定的对象；这可以通过工厂方法来完成，这样你就有一种简洁的方式来创建对象。
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you know the factory pattern is used to create objects and classes in a
    predictable manner. Next, we will talk about the dependency injection pattern.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了工厂模式是用来以可预测的方式创建对象和类的。接下来，我们将讨论依赖注入模式。
- en: Dependency injection pattern
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: '**Dependency injection** (**DI**) stands at the core of the Angular framework.
    Strictly speaking, DI falls under the umbrella of the **inversion of control**
    (**IoC**) principle. IoC essentially delegates control of certain aspects of a
    program to an external framework or container, allowing it to manage the flow
    and connections between components. But because DI is in charge of the creation
    and distribution of dependencies within your Angular application, we can place
    it under the category of creational design patterns.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（DI）是Angular框架的核心。严格来说，DI属于**控制反转**（IoC）原则的范畴。IoC本质上将程序某些方面的控制权委托给外部框架或容器，允许它管理组件之间的流动和连接。但由于DI负责在Angular应用程序中创建和分配依赖项，我们可以将其归类为创建型设计模式。'
- en: DI promotes modularity by decoupling components and services, making them more
    reusable across the application. By facilitating the management of dependencies,
    DI makes it easier to scale applications by adding or modifying functionality
    without needing to make significant code changes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）通过解耦组件和服务，促进了模块化，使得它们在应用程序中更具可重用性。通过简化依赖关系的管理，DI使得通过添加或修改功能来扩展应用程序变得更加容易，而无需进行重大的代码更改。
- en: The Angular DI system helps identify and prevent circular dependencies, which
    can lead to runtime errors and hard-to-debug issues. Dependency injection also
    enforces type safety, reducing the risk of errors related to incorrect data types
    being injected.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的DI系统有助于识别和防止循环依赖，这可能导致运行时错误和难以调试的问题。依赖注入还强制执行类型安全，减少了与注入错误数据类型相关的错误风险。
- en: We already discussed Angular DI in great detail in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033),
    so for now we will move on to structural design patterns.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第二章*](B21625_02.xhtml#_idTextAnchor033)中详细讨论了Angular DI，因此现在我们将继续讨论结构型设计模式。
- en: Structural design patterns in Angular
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular中的结构型设计模式
- en: '**Structural design patterns** are fundamental in shaping the architecture
    of your Angular applications. Structural design patterns help organize components,
    services, and modules, defining how they interact and collaborate within your
    applications. Angular leverages these patterns to establish a clear structure,
    facilitating the development of scalable, modular, and maintainable applications.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构型设计模式**是塑造Angular应用程序架构的基础。结构型设计模式有助于组织组件、服务和模块，定义它们在应用程序中的交互和协作方式。Angular利用这些模式来建立清晰的结构，促进可扩展、模块化和可维护应用程序的开发。'
- en: For instance, patterns such as component-based architecture and module structure
    are inherent in Angular applications. The decorator pattern is also heavily used
    in Angular (e.g., `@Component`, `@Injectable`). The facade pattern is often used
    in Angular applications to provide abstraction between the services and component
    layer of your Angular applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，组件化架构和模块结构等模式是Angular应用程序固有的。装饰器模式在Angular中也被广泛使用（例如，`@Component`，`@Injectable`）。外观模式在Angular应用程序中常用于在服务层和组件层之间提供抽象。
- en: Overall, using structural design patterns in Angular guides developers in creating
    well-organized, scalable, and adaptable applications by defining how components,
    services, and modules interconnect and collaborate within the framework’s architecture.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，在Angular中使用结构型设计模式通过定义组件、服务和模块在框架架构中的相互连接和协作方式，指导开发者创建组织良好、可扩展和适应性强应用程序。
- en: Component-based architecture
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件化架构
- en: '**Component-based architecture** **(CBA)** is a design pattern where we build
    applications by composing individual, self-contained, and reusable components.
    It’s obvious where CBA comes into play within Angular applications. When building
    components, it’s important to keep them as self-contained and reusable as possible.
    Because we want to build reusable components, it’s important to use the smart/dumb
    principle within your Angular components.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件化架构**（CBA）是一种设计模式，其中我们通过组合单个、自包含和可重用的组件来构建应用程序。在Angular应用程序中，CBA的应用显而易见。在构建组件时，保持它们尽可能的自包含和可重用非常重要。因为我们希望构建可重用的组件，所以在Angular组件中使用智能/愚笨原则（smart/dumb
    principle）非常重要。'
- en: We already talked about smart and dumb components in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014)
    and [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033), but to reiterate, smart components
    are mainly pages or large feature components and have a connection with your business
    logic and state management (or the facade services).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第一章*](B21625_01.xhtml#_idTextAnchor014)和[*第二章*](B21625_02.xhtml#_idTextAnchor033)中讨论了智能组件和哑组件，但为了重申，智能组件主要是页面或大型功能组件，并且与你的业务逻辑和状态管理（或外观服务）有关。
- en: Dumb components are UI elements that are used to build up the smart components.
    Dumb components receive their data through inputs and notify other components
    of changes with outputs. Using this smart/dumb approach enforces good architecture
    and reusability of your components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 哑组件是用于构建智能组件的UI元素。哑组件通过输入接收数据，并通过输出通知其他组件的变化。使用这种智能/哑方法强制执行良好的架构和组件的可重用性。
- en: Now that we have briefly reiterated the CBA pattern, let’s move on and learn
    about the decorator pattern.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要回顾了CBA模式，让我们继续学习装饰器模式。
- en: Decorator pattern
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: 'The **decorator pattern** is a structural design pattern that enables you to
    modify the behavior of classes, functions, and properties without altering the
    object itself. The most commonly used decorators within the Angular framework
    are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器模式**是一种结构型设计模式，它允许你在不改变对象本身的情况下修改类、函数和属性的行为。在Angular框架中最常用的装饰器如下：'
- en: '`@Component`: This decorates a class as an Angular component, providing metadata
    for Angular’s compiler. It includes information about the component’s template,
    styles, and other configurations such as the standalone flag, imports, the component
    selector, and directive decomposition.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component`: 这个装饰器将一个类装饰为Angular组件，为Angular编译器提供元数据。它包括有关组件模板、样式以及其他配置的信息，如独立标志、导入、组件选择器和指令分解。'
- en: '`@Injectable`: This decorates a class as an injectable service, allowing it
    to be injected into other components or services through Angular’s DI system.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Injectable`: 这个装饰器将一个类装饰为可注入的服务，允许它通过Angular的DI系统注入到其他组件或服务中。'
- en: '`@NgModule`: This decorates a class as an Angular module, providing metadata
    that defines the module’s dependencies, components, directives, services, etc.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NgModule`: 这个装饰器将一个类装饰为Angular模块，提供定义模块依赖项、组件、指令、服务等的元数据。'
- en: '`@Input` and `@Output`: These are decorators used in component properties to
    define inputs and outputs for communication between components.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input`和`@Output`: 这些是用于组件属性的装饰器，用于定义组件之间的输入和输出通信。'
- en: '`@HostListener`: This decorates a class method to declare a DOM event listener.
    It’s used within directives to listen for events on the host element.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@HostListener`: 这个装饰器用于装饰一个类方法，以声明一个DOM事件监听器。它用于指令中监听宿主元素上的事件。'
- en: '`@HostBinding`: This decorates a class property to bind it to a host element
    property within a directive.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@HostBinding`: 这个装饰器用于装饰一个类属性，将其绑定到指令内的宿主元素属性。'
- en: '`@ViewChild` and `@ViewChildren`: These are decorators used to query and obtain
    references to child components or DOM elements within a parent component or directive.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ViewChild`和`@ViewChildren`: 这些是用于在父组件或指令中查询和获取子组件或DOM元素引用的装饰器。'
- en: 'You can also create your own custom decorators. We can, for example, make a
    custom decorator that will log when a function is called and include the provided
    function parameters in the log. To start, you need to set `experimentalDecorators`
    to true inside your `tsconfig.json`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建自己的自定义装饰器。例如，我们可以创建一个自定义装饰器，当函数被调用时记录下来，并在日志中包含提供的函数参数。首先，你需要在`tsconfig.json`中将`experimentalDecorators`设置为`true`：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the case of Angular, the `experimentalDecorators` property is set to `true`
    by default because Angular already uses decorators within the framework. To create
    a decorator, you have to create a function that takes three arguments: `target`
    (class prototype), `propertyKey` (name of the method), and `descriptor` (property
    descriptor of the method). Within the decorator, you modify the behavior of the
    decorated method by wrapping its original logic inside a new function. This new
    function logs a message before invoking the original method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的情况下，`experimentalDecorators`属性默认设置为`true`，因为Angular已经在框架内部使用了装饰器。要创建一个装饰器，你需要创建一个接受三个参数的函数：`target`（类原型），`propertyKey`（方法名称），和`descriptor`（方法属性描述符）。在装饰器内部，你通过将原始逻辑包装在一个新函数中来修改被装饰方法的行怍。这个新函数在调用原始方法之前记录一条消息：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, to use the decorator, you simply add it above a method, like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用装饰器，您只需将其添加到方法之上，如下所示：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you now call the `test` method, the decorator makes sure it is logged, including
    the `a` and `b` parameters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在调用`test`方法，装饰器确保它被记录，包括`a`和`b`参数：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can place the custom decorator in a new `custom-decorators` library of type
    util in the shared domain. I created a `func-logger.decorator.ts` file inside
    the `custom-decorators` library and placed the logic of the decorator in that
    file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将自定义装饰器放置在共享域中的新`custom-decorators`库中，该库的类型为util。我在`custom-decorators`库内部创建了一个`func-logger.decorator.ts`文件，并将装饰器的逻辑放在该文件中。
- en: You now know where Angular uses the decorator pattern and how you can use it
    yourself to extend or modify the behavior of objects, functions, and classes without
    modifying the objects themselves. Next, you will learn about the facade pattern.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道Angular在哪里使用装饰器模式，以及您如何自己使用它来扩展或修改对象、函数和类的行为，而不修改对象本身。接下来，您将了解外观模式。
- en: Facade pattern
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外观模式
- en: 'We mentioned the **facade pattern** a couple of times throughout this book.
    Now it’s time to explain what the facade pattern is. The facade pattern is a structural
    design pattern that provides a simplified interface to a larger, more complex
    system of classes, subsystems, or APIs. In the context of Angular applications,
    the facade pattern is commonly used to create a simple interface for and an abstraction
    layer between the component layers and your services where you implement your
    state management solution and business logic. In *Figure 6**.3*, you’ll find a
    visual representation of the facade pattern:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中多次提到了**外观模式**。现在，是时候解释外观模式是什么了。外观模式是一种结构型设计模式，它为更大的、更复杂的类、子系统或API系统提供了一个简化的接口。在Angular应用程序的上下文中，外观模式通常用于创建组件层和实现状态管理解决方案和业务逻辑的服务之间的简单接口和抽象层。在**图6.3**中，您将找到外观模式的视觉表示：
- en: '![Figure 6.3: Facade pattern](img/B21625_06_3.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：外观模式](img/B21625_06_3.jpg)'
- en: 'Figure 6.3: Facade pattern'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：外观模式
- en: In *Figure 6**.3*, to get the data needed in the component, three different
    services need to be called. If you have to do this for all your components, you
    create a lot of dependencies and you need to create a lot of logic inside your
    components. Instead of directly calling the services from the components, we place
    a facade in between the components and services. The facade provides a simple
    `get data` method to retrieve the data we need inside the components. Instead
    of having dependencies inside the components, the facade has all the dependencies
    to the services. By using the façade, you can keep your components simple and
    clean without dependencies. Furthermore, you create a level of abstraction, and
    because of that, you can change the how you retrieve the data without changing
    the component layer; you simply change how the facade gets the data and the component
    still calls the `get data` method from the facade service. In most cases, you
    have your state management on the right side of the facade and your components
    on the left side of the facade.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图6.3**中，为了获取组件所需的数据，需要调用三个不同的服务。如果您必须为所有组件执行此操作，您将创建大量的依赖关系，并在组件内部创建大量的逻辑。我们不是直接从组件中调用服务，而是在组件和服务之间放置一个外观。外观提供了一个简单的`获取数据`方法来检索组件内部所需的数据。外观没有组件内部的依赖关系，而是拥有所有对服务的依赖关系。通过使用外观，您可以保持组件简单且干净，没有依赖关系。此外，您创建了一个抽象层，因此您可以更改数据检索方式而不更改组件层；您只需更改外观获取数据的方式，组件仍然调用外观服务的`获取数据`方法。在大多数情况下，您在外观的右侧管理状态，在左侧放置组件。
- en: In large applications and monorepos, the state management layer can become large
    and complex to handle. For something as simple as getting all expenses in a large
    monorepo of business tool applications, you can find yourself accessing multiple
    state files (commonly named stores) and selectors of these stores. Because the
    pieces of the state can live in different files or even different libraries, it’s
    not as easy as creating a function that combines the parts inside the state itself.
    You need another place, and that would be the facade service. The same goes for
    updating; in large systems, this can involve updating multiple stores and handling
    multiple callbacks or effects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序和单一代码库中，状态管理层可能会变得庞大且复杂，难以处理。对于像在大型单一代码库中的商业工具应用程序中获取所有费用这样简单的事情，你可能会发现自己需要访问多个状态文件（通常称为存储）和这些存储的选择器。因为状态的不同部分可能存在于不同的文件或甚至不同的库中，所以创建一个结合状态内部各部分的功能的函数并不像想象中那么简单。你需要另一个地方，那就是界面服务。同样，对于更新操作，在大系统中，这可能涉及到更新多个存储和处理多个回调或效果。
- en: Let’s say you create an expenses facade. In this facade, you create methods
    that are simple to call and give you access to everything you need in your component
    layer. Think of things such as getting all expenses, getting filtered expenses,
    updating a single expense, or updating expenses in bulk. The facade helps keep
    things simple in your component layers and ensures that you only have to call
    a single function to get or do what you need to make your components work and
    update your state accordingly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你创建了一个费用界面。在这个界面中，你创建了简单易调用的方法，并为你提供了访问组件层中所需一切的功能。例如，获取所有费用、获取筛选后的费用、更新单个费用或批量更新费用。这个界面有助于保持组件层中的简单性，并确保你只需调用一个函数就能获取或完成你需要使组件工作并相应更新状态的操作。
- en: The facade makes accessing and updating your state easy and provides an extra
    level of abstraction, decoupling your state management implementation from your
    component layer. This abstraction layer allows you to change your state management
    solution without touching your component layer. You only have to change your state
    management and update the facade and your component layer will keep working as
    if nothing changes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 界面使得访问和更新你的状态变得简单，并提供了一个额外的抽象层，将你的状态管理实现与组件层解耦。这个抽象层允许你在不触及组件层的情况下更改你的状态管理解决方案。你只需更改状态管理并更新界面，你的组件层就会像没有变化一样继续工作。
- en: If you do not have the facade in between, you need to go into every component
    where you use the state and update them all independently, resulting in more work
    and a higher chance of you missing something. So, even if you have a simple state
    where you can access and update most things with a single method, adding a facade
    between your component layer and state management is still wise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在组件层和状态管理之间添加界面，你需要进入每个使用状态的组件，并独立地更新它们，这会导致更多的工作，并且你遗漏某事的可能性更高。所以，即使你有一个简单的状态，你可以使用单个方法访问和更新大多数事物，但在组件层和状态管理之间添加一个界面仍然是明智的。
- en: 'The following is a simple example of how a facade service might look:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个界面服务可能看起来很简单的示例：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, we made a façade service that exposes two methods:
    one to get all expenses and one to update expenses. If the implementation in the
    state management now changes, you only have to change it in the facade instead
    of everywhere you get or update the expenses in your components. The preceding
    code is just an example; you don’t have to add this in the monorepo. In [*Chapter
    8*](B21625_08.xhtml#_idTextAnchor150), we will create a facade in our monorepo.
    For now, you just need to know what the facade pattern is and why it’s useful.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个界面服务，它公开了两种方法：一种用于获取所有费用，另一种用于更新费用。如果状态管理中的实现现在发生了变化，你只需在界面中更改它，而不是在组件中获取或更新费用的每个地方都进行更改。前面的代码只是一个示例；你不需要在单一代码库中添加这个功能。在[*第8章*](B21625_08.xhtml#_idTextAnchor150)中，我们将在我们的单一代码库中创建一个界面。现在，你只需要知道界面模式是什么以及为什么它有用。
- en: Next, we will take a look at the inheritance pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨继承模式。
- en: Model adapter pattern
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型适配器模式
- en: The **model adapter pattern** is an implementation of the adapter pattern. The
    model adapter pattern is commonly used to map objects received from the API to
    a representation of those models used within the frontend (not specifically into
    models used within the view layer). You might ask yourself, why is this useful?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型适配器模式**是适配器模式的一种实现。模型适配器模式通常用于将API接收到的对象映射到前端（不是特指视图层中使用的模型）使用的模型表示。你可能会问自己，这有什么用？'
- en: 'Imagine you receive an object from the API with a `title` property:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你从API接收到一个具有`title`属性的对象：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s say you use this `title` property in 100 different places throughout your
    application. If, for some reason, the backend has to change the property name
    from `title` to `subject`, you need to go to all 100 places within your application
    to change them from `title` to `subject`. If you have a model adapter, you can
    change them in one place and map the new `subject` property to the `title` property
    of your frontend model.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在应用程序的100个不同地方使用了这个`title`属性。如果出于某种原因，后端必须将属性名从`title`更改为`subject`，你需要进入应用程序中的所有100个地方来将它们从`title`更改为`subject`。如果你有一个模型适配器，你可以在一个地方更改它们，并将新的`subject`属性映射到前端模型的`title`属性。
- en: Inheritance pattern
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承模式
- en: The **inheritance pattern**, a foundational concept in object-oriented programming,
    establishes a hierarchical relationship between classes, enabling one class (the
    subclass or derived class) to inherit properties, methods, and behaviors from
    another class (the superclass or base class). In Angular applications, services
    and components can utilize inheritance to form hierarchical relationships and
    share generic functionalities and properties. The base class exposes the shared
    functionalities and properties with the child class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承模式**是面向对象编程的基础概念，它建立了类之间的层次关系，使得一个类（子类或派生类）能够从另一个类（超类或基类）继承属性、方法和行为。在Angular应用程序中，服务和组件可以利用继承来形成层次关系，并共享通用功能和属性。基类通过子类公开共享的功能和属性。'
- en: Inheritance is a powerful and useful design pattern, but it should be used in
    moderation, especially within the component layer of your Angular applications.
    Excessive use of inheritance can create tight coupling between the base and child
    components. Changes in the base component might inadvertently impact multiple
    derived components, making the system fragile and harder to maintain. Deep hierarchies
    with multiple levels of inheritance can introduce complexity, making the codebase
    harder to understand and maintain. Over-engineering by creating overly complex
    inheritance structures might hinder rather than aid development.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种强大且有用的设计模式，但应该适度使用，尤其是在你的Angular应用程序的组件层中。过度使用继承会在基组件和子组件之间创建紧密耦合。基组件的变化可能会意外地影响多个派生组件，使系统脆弱且难以维护。具有多个继承级别的深层层次结构可能会引入复杂性，使代码库更难以理解和维护。通过创建过于复杂的继承结构进行过度设计可能会阻碍而不是帮助开发。
- en: Also, in the context of the component layer, you can often create pipes and
    directives to share common functionalities. For example, you can have a base class
    where you add common logic for handling disabled states, handling some commonly
    used component stylings such as `primary`, `alert`, and `danger`, and adding the
    option to change this styling when clicked or double-clicked.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在组件层的情况下，你通常可以创建管道和指令来共享常用功能。例如，你可以有一个基类，在其中添加处理禁用状态、处理一些常用的组件样式，如`primary`、`alert`和`danger`，以及添加在点击或双击时更改这种样式的选项。
- en: This might seem like a valid solution, but you might only need one or two of
    the options in some scenarios. Some components might have different styling types
    but should not be able to change the styling type based on a click, and others
    should not be able to be disabled. It’s generally a bad practice to expose behavior
    to a component that does not apply to the component. So, in this scenario, it
    would be better to create three directives that handle disabling, styling, and
    styling change behaviors and apply them using directive composition.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个有效的解决方案，但在某些情况下你可能只需要一个或两个选项。一些组件可能具有不同的样式类型，但不应能够根据点击来更改样式类型，而其他组件则不应能够被禁用。将不适用于组件的行为暴露给组件通常是一种不好的做法。因此，在这种情况下，创建三个处理禁用、样式和样式更改行为的指令，并使用指令组合来应用它们会更好。
- en: So, inheritance can be used to share common functionalities, but make sure it
    is the right solution for the problem so that you don’t create base classes that
    expose a lot of functionalities and behaviors that most child classes will not
    use. One way I like to use the inheritance pattern is for creating a generic HTTP
    service. We will create a generic HTTP service with a model adapter in the next
    section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继承可以用来共享公共功能，但请确保它是解决问题的正确方案，这样你就不会创建大量暴露给子类而子类不会使用的功能和行为的基础类。我喜欢使用继承模式的一种方式是创建一个通用的HTTP服务。我们将在下一节创建一个带有模型适配器的通用HTTP服务。
- en: Now that you have learned about the most used structural design patterns within
    Angular applications, we will start learning about common behavioral design patterns
    within Angular applications.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Angular应用中最常用的结构设计模式，我们将开始学习Angular应用中的常见行为设计模式。
- en: Behavioral design patterns in Angular
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular中的行为设计模式
- en: '**Behavioral design patterns** focus on how objects and classes communicate
    and delegate responsibilities to each other. Using behavioral patterns ensures
    that your code remains flexible, modular, and maintainable.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为设计模式**关注对象和类之间如何通信和委托责任。使用行为模式确保你的代码保持灵活、模块化和可维护。'
- en: 'The most common behavioral pattern within Angular applications is the observer
    pattern, but others, such as the interceptor, redux, and strategy patterns, are
    also commonly used. Let’s start with the most commonly used: the observer pattern.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用中最常见的行为模式是观察者模式，但其他模式，如拦截器、Redux和策略模式，也经常被使用。让我们从最常用的开始：观察者模式。
- en: Observer pattern
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者模式
- en: If you have ever used Angular, you know the framework heavily relies on **observables**.
    The Angular framework integrated RxJS to manage observables and handle asynchronous
    data streams effectively and in a reactive manner. RxJS is a library focused on
    handling observable data streams. The **observer pattern** allows you to create
    one-to-many relationships so that when one object changes, all the dependent elements
    within your code are notified and updated automatically.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过Angular，你知道该框架严重依赖于**可观察对象**。Angular框架集成了RxJS来管理可观察对象并有效地以响应式方式处理异步数据流。RxJS是一个专注于处理可观察数据流的库。**观察者模式**允许你创建一对多关系，以便当一个对象发生变化时，你代码中所有相关的元素都会被通知并自动更新。
- en: Within the observer pattern, you have the **observable** and the **observers**,
    which are more commonly referred to as the subscribers. I like to explain the
    Observer pattern with a magazine subscription analogy.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者模式中，你有**可观察对象**和**观察者**，它们更常被称为订阅者。我喜欢用杂志订阅的类比来解释观察者模式。
- en: Let’s say there is a magazine that releases a new issue weekly. The magazine
    is the observable and the people subscribing to the magazine are the observers
    or subscribers. Each time the magazine releases a new issue, all subscribers are
    notified and receive the new issue automatically in their mailboxes. The subscribers
    to the magazine will receive the magazine for as long as they are subscribed,
    and when they unsubscribe, they will no longer receive the magazine.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一家杂志每周发布一期新杂志。杂志是可观察对象，订阅杂志的人是观察者或订阅者。每次杂志发布新期号时，所有订阅者都会收到通知，并自动在他们的邮箱中收到新期号。只要订阅者订阅杂志，就会收到杂志，当他们取消订阅时，就不再收到杂志。
- en: The magazine can be subscribed to by all people who want to receive it. There
    is one magazine issue and many readers of the issue, hence the one-to-many relationship,
    as we have in the observer pattern. There are also observers and an observable,
    just as with the observer pattern.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所有希望接收该杂志的人都可以订阅该杂志。有一个杂志期号和许多读者，因此存在一对多关系，正如我们在观察者模式中所见。同样，也存在观察者和可观察对象，就像在观察者模式中一样。
- en: Observables come in two types, hot and cold observables, and within the context
    of Angular applications and RxJS, there are a couple of ways you can set up observables;
    we will dive deeper into observable types, RxJS, and handling observable streams
    in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象有两种类型，热可观察对象和冷可观察对象，在Angular应用和RxJS的上下文中，你可以设置可观察对象的方式有几种；我们将在[*第7章*](B21625_07.xhtml#_idTextAnchor129)中深入探讨可观察对象类型、RxJS以及处理可观察流。
- en: Interceptor pattern
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拦截器模式
- en: The **interceptor pattern** allows you to intercept communications and perform
    some logic on the data that is being transferred and either stop or continue the
    intercepted communication.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**拦截器模式**允许你拦截通信并在传输的数据上执行一些逻辑，然后停止或继续被拦截的通信。'
- en: 'Within the context of Angular applications, you commonly see the interceptor
    pattern in two different places:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序的上下文中，你通常在两个不同的地方看到拦截器模式：
- en: '**Route guards** intercept route changes and either allow or block the route
    change based on some logic.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由守卫**拦截路由变化并根据某些逻辑允许或阻止路由变化。'
- en: '**HTTP interceptors** intercept HTTP requests and responses. The HTTP interceptor
    is commonly used to add authorization headers to HTTP requests and handle retry
    logic or logging.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP拦截器**拦截HTTP请求和响应。HTTP拦截器通常用于向HTTP请求添加授权头并处理重试逻辑或日志记录。'
- en: We will create a route guard in [*Chapter 9*](B21625_09.xhtml#_idTextAnchor170).
    For now, we will only create an HTTP interceptor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B21625_09.xhtml#_idTextAnchor170)中创建一个路由守卫。现在，我们只创建一个HTTP拦截器。
- en: Creating an HTTP interceptor can be done through a class-based or functional
    approach. We will use the functional approach, as this is the newer method and
    requires less boilerplate code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建HTTP拦截器可以通过类方法或函数方法完成。我们将使用函数方法，因为这是较新的方法，需要更少的样板代码。
- en: 'To create an HTTP interceptor, you first need to make some adjustments to your
    `ApplicationConfig` object. Start by adding the `provideHttpClient` function inside
    your `providers` array:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个HTTP拦截器，你首先需要对你的`ApplicationConfig`对象做一些调整。首先，在你的`providers`数组中添加`provideHttpClient`函数：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'provideHttpClient(withInterceptors function, you will register your HTTP interceptors.
    You create an interceptor by creating a function that implements the HttpInterceptorFn
    interface. The function takes an HttpRequest and an HttpHandlerFn as function
    parameters. The HttpRequest gives you access to the request and the HttpHandlerFn
    is called to continue the request after you perform your logic:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: provideHttpClient(withInterceptors function, 你将注册你的HTTP拦截器。你通过创建一个实现HttpInterceptorFn接口的函数来创建一个拦截器。该函数接受HttpRequest和HttpHandlerFn作为函数参数。HttpRequest让你访问请求，HttpHandlerFn在执行你的逻辑后调用以继续请求：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code is just a simple example; we add a string as our authorization
    token. In reality, you should store your token in a safe place, such as in your
    environment variables, and retrieve it from there. You can also add more logic
    to the interceptor; this is just a simple example to illustrate how you create
    an interceptor. To activate the interceptor, you need to add it to the array of
    the `withInterceptors` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是一个简单的示例；我们添加一个字符串作为我们的授权令牌。实际上，你应该将令牌存储在安全的地方，例如环境变量中，并从中检索它。你还可以在拦截器中添加更多逻辑；这只是一个简单的示例，用于说明如何创建拦截器。要激活拦截器，你需要将其添加到`withInterceptors`函数的数组中：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: export interface ModelAdapter<T, S> {
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: export interface ModelAdapter<T, S> {
- en: 'fromDto(dto: T): S;'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'fromDto(dto: T): S;'
- en: 'toDto(model: S): T;'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'toDto(model: S): T;'
- en: '}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '@Injectable({'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '@Injectable({'
- en: 'providedIn: ''root'''
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'providedIn: ''root'''
- en: '})'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '})'
- en: export abstract class GenericHttpService<T, S> {
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: export abstract class GenericHttpService<T, S> {
- en: protected url;
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: protected url;
- en: defaultHeaders = new HttpHeaders();
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: defaultHeaders = new HttpHeaders();
- en: protected readonly httpClient = inject(HttpClient);
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: protected readonly httpClient = inject(HttpClient);
- en: '}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: constructor(
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: constructor(
- en: 'private endpoint: string,'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'private endpoint: string,'
- en: 'private baseUrl: string,'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'private baseUrl: string,'
- en: 'private adapter: ModelAdapter<T, S>'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'private adapter: ModelAdapter<T, S>'
- en: ) {
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ) {
- en: this.url = this.baseUrl + '/api' + this.endpoint;
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: this.url = this.baseUrl + '/api' + this.endpoint;
- en: '}'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'public get(extraHttpRequestParams?: Partial<HttpHeaders>): Observable<S[]>
    {'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'public get(extraHttpRequestParams?: Partial<HttpHeaders>): Observable<S[]>
    {'
- en: return this.httpClient.get<T[]>(`${this.url}`, this.prepareRequestOptions(extraHttpRequestParams)).pipe(
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: return this.httpClient.get<T[]>(`${this.url}`, this.prepareRequestOptions(extraHttpRequestParams)).pipe(
- en: 'map((data: T[]) => data.map(item => this.adapter.fromDto(item) as S)));'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'map((data: T[]) => data.map(item => this.adapter.fromDto(item) as S)));'
- en: '}'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'public post(body: S, extraHttpRequestParams?: Partial<HttpHeaders>): Observable<S>
    {'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'public post(body: S, extraHttpRequestParams?: Partial<HttpHeaders>): Observable<S>
    {'
- en: return this.httpClient.post(`${this.url}`, this.adapter.toDto(body), this.prepareRequestOptions(extraHttpRequestParams)).pipe(map(data
    => this.adapter.fromDto(data as T) as S)) as Observable<S>;
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: return this.httpClient.post(`${this.url}`, this.adapter.toDto(body), this.prepareRequestOptions(extraHttpRequestParams)).pipe(map(data
    => this.adapter.fromDto(data as T) as S)) as Observable<S>;
- en: '}'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: public prepareRequestOptions(extraHttpRequestParams = {}) {
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: public prepareRequestOptions(extraHttpRequestParams = {}) {
- en: return {
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: return {
- en: 'headers: Object.assign(this.defaultHeaders, extraHttpRequestParams)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'headers: Object.assign(this.defaultHeaders, extraHttpRequestParams)'
- en: '};'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '@Injectable({ providedIn: ''root'' })'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '@Injectable({ providedIn: ''root'' })'
- en: 'export class models inside the lib folder of the finance data-access library
    and added a expenses.interfaces.ts file in the models folder. In this expenses.interfaces.ts
    file, I will create the expense model and DTO interfaces:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在金融数据访问库的lib文件夹中创建了一个名为`models`的新文件夹，并在`models`文件夹中添加了一个`expenses.interfaces.ts`文件。在这个`expenses.interfaces.ts`文件中，我将创建费用模型和DTO接口：
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, you can create a new folder named `adapters`. The `adapters` folder is
    located in the same place as the `models` and `HTTP` folders. Inside the `adapters`
    folder, create an `expense.adapter.ts` file, which will contain the model adapter
    for the expense DTO and model:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以创建一个名为`adapters`的新文件夹。`adapters`文件夹位于`models`和`HTTP`文件夹相同的目录下。在`adapters`文件夹内，创建一个`expense.adapter.ts`文件，它将包含费用DTO和模型的模型适配器：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, the model adapter maps the expense DTO to the expense model
    and the expense model to the expense DTO. We will provide this model adapter to
    the constructor of the generic HTTP service so that our models will automatically
    be mapped when we receive them from or send them to the API. The last step is
    to inherit the generic HTTP service in your expenses HTTP service. You inherit
    by using the `extends` keyword and adding the class name of the generic HTTP service:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模型适配器将费用DTO映射到费用模型，并将费用模型映射到费用DTO。我们将把这个模型适配器提供给泛型HTTP服务的构造函数，这样我们的模型在从API接收或发送时将自动映射。最后一步是在你的费用HTTP服务中继承泛型HTTP服务。你通过使用`extends`关键字并添加泛型HTTP服务的类名来继承：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we also call a `super()` method and provide it with some arguments.
    The `super()` method is used to call the `constructor` method of the inherited
    class – in our case, `GenericHttpService`. You provide the `super()` method with
    the properties that the constructor of the `GenericHttpService` expects to receive,
    the `endpoint`, `baseUrl`, and model adapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们还调用了一个`super()`方法，并给它提供了一些参数。`super()`方法用于调用继承类的`constructor`方法——在我们的例子中是`GenericHttpService`。你向`super()`方法提供`GenericHttpService`构造函数期望接收的属性，即`endpoint`、`baseUrl`和模型适配器。
- en: 'You might also notice we use the `arrow` syntax after the `GenericHttpService`
    and provide the `ExpenseDto` and `ExpenseModel` inside:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会注意到我们在`GenericHttpService`之后使用了`箭头`语法，并在其中提供了`ExpenseDto`和`ExpenseModel`：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using the before-mentioned syntax provides the generic HTTP service with the
    generic types we added in the `GenericHttpService` class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的语法，为`GenericHttpService`类中添加的泛型类型提供了泛型HTTP服务：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By using generic types, we make sure the generic HTTP service remains type-safe,
    and we receive typed objects when we use the methods of our HTTP services. After
    inheriting the generic HTTP service inside the expenses HTTP service, you are
    ready to use the expenses HTTP service. All the methods, such as `get`, `get by
    id`, `post`, `delete`, and so forth, are inherited by the generic HTTP service
    and don’t have to be implemented again.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用泛型类型，我们确保泛型HTTP服务保持类型安全，当我们使用HTTP服务的各种方法时，我们会收到类型化的对象。在继承费用HTTP服务内部的泛型HTTP服务后，你就可以开始使用费用HTTP服务了。所有的方法，如`get`、`get
    by id`、`post`、`delete`等，都是继承自泛型HTTP服务，无需再次实现。
- en: 'If you want to use the expenses HTTP service, you `inject` it as you would
    with any other HTTP service or dependency:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用费用HTTP服务，你可以像使用任何其他HTTP服务或依赖项一样`注入`它：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After injecting the HTTP service, you can call any method the service exposes:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入HTTP服务后，你可以调用服务公开的任何方法：
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we make the `get` request, you might notice the request is failing; this
    is because we don’t have an actual API running and the request to `/api/expenses`
    returns a `404 not found` error code. Let’s resolve this issue and provide some
    mock data when we make our API requests.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发起`get`请求时，你可能会注意到请求失败；这是因为我们没有实际运行的API，对`/api/expenses`的请求返回了一个`404 not
    found`错误代码。让我们解决这个问题，并在发起API请求时提供一些模拟数据。
- en: Providing mock data for our API requests
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的API请求提供模拟数据
- en: There are many ways to provide mock data; we will use an HTTP interceptor to
    get our mock data from the assets folder. This is just a simple implementation,
    and it has some flaws, but for demonstration purposes, it works very well, and
    it doesn’t take much effort to set up.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 提供模拟数据的方法有很多；我们将使用HTTP拦截器从资源文件夹中获取我们的模拟数据。这只是一个简单的实现，它有一些缺陷，但出于演示目的，它工作得非常好，并且设置起来并不费力。
- en: We start by creating an interceptors folder with a `mock.interceptor.ts` file
    inside the `generic-http` library in our Nx monorepo. Inside the `mock.interceptor.ts`
    file, we will create an interceptor that returns the HTTP request untouched if
    we are not in development mode.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在Nx monorepo中的`generic-http`库内创建一个包含`mock.interceptor.ts`文件的`interceptors`文件夹。在`mock.interceptor.ts`文件中，我们将创建一个拦截器，如果不在开发模式，则返回未修改的HTTP请求。
- en: If we are in development mode, the interceptor will adjust the request URL and
    request method so that all requests are `GET` requests, and it will try to get
    a JSON file to place in the `assets` folder of our applications (in our case,
    the *expenses-registration application*).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于开发模式，拦截器将调整请求URL和请求方法，使得所有请求都是`GET`请求，并且它会尝试从我们的应用程序的`assets`文件夹（在我们的例子中，是*费用登记应用程序*）中获取一个JSON文件。
- en: We will also intercept the HTTP response, and if we do not make a `GET` request,
    we will return the request body instead of the data from our JSON file in the
    assets folder of the project.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将拦截HTTP响应，如果我们没有发出`GET`请求，我们将返回请求体而不是来自项目`assets`文件夹中的JSON文件的数据。
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we first check that we are not in development mode, and if that
    is the case, we directly return the request. If we are in development mode, we
    clone the request and adjust the request URL and method. The method is set to
    a `GET`, regardless of what request we try to make. The URL is prefixed with `assets`,
    so we target the `assets` folder of our application and postfix it with `.json`
    because we will fetch a JSON file from the `assets` folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们首先检查我们是否不在开发模式，如果是这样，我们就直接返回请求。如果我们处于开发模式，我们将克隆请求并调整请求URL和方法。方法被设置为`GET`，无论我们尝试发出什么请求。URL以`assets`为前缀，因此我们针对应用程序的`assets`文件夹，并以`.json`结尾，因为我们将从`assets`文件夹中获取一个JSON文件。
- en: Adjusting the URL in this manner makes sure that a request to the following
    API URL `/api/expenses` will be transformed to `/assets/api/expenses.json`. Next,
    we use the RxJS pipe and map operator to listen for the HTTP response and simply
    return the request body if the original request method wasn’t a `GET` request.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式调整URL确保对以下API URL `/api/expenses` 的请求将被转换为 `/assets/api/expenses.json`。接下来，我们使用RxJS管道和map操作符来监听HTTP响应，如果原始请求方法不是`GET`请求，则简单地返回请求体。
- en: 'Next, you have to create an `api` folder inside the assets folder of the *expenses-registration
    application*, and in this `api` folder, you need to create an `expenses.json`
    file with your mock data:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您必须在*费用登记应用程序*的`assets`文件夹内创建一个`api`文件夹，并在该`api`文件夹中创建一个包含您的模拟数据的`expenses.json`文件：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Lastly, you need to register the interceptor in your `ApplicationConfig` object:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在您的`ApplicationConfig`对象中注册拦截器：
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
