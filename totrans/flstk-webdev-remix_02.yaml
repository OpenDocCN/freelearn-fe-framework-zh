- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a New Remix App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting started with a new framework means familiarizing yourself with its primitives,
    conventions, and levers. This book uses a demo application that we will build
    from start to finish. Each chapter focuses on one specific topic of full stack
    web development with Remix. In this chapter, we will explore explore the breadth
    of Remix’s `create-remix` CLI script, introduce Remix’s file and folder structure,
    and familiarize ourselves with Remix’s runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a “Hello World!” Remix app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Remix’s file and folder structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the client and server environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting Remix applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we will walk through the setup of a new Remix project using the `create-remix`
    CLI script. The chapter then introduces you to Remix’s folder structure. We will
    investigate each file and learn about its function. Next, we will discuss Remix’s
    two environments: the client and the server. You will learn how to manage client
    and server code in Remix. Finally, we will introduce a troubleshooting guide that
    will help us debug Remix applications.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to create a Remix project and
    will have familiarized yourself with Remix’s file and folder structure. You will
    also learn more about Remix’s client and server environments and how to troubleshoot
    Remix applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need a computer that can run Node.js. All
    common operation systems should suffice. Please install both Node.js and `npm`
    on your machine. An editor such as VS Code is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Node.js and `npm` here: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this chapter can be found here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app).
    Try to read through this chapter first before peeking at the final code.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a “Hello World!” Remix app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section walks you through the creation of a new Remix application using
    the `create-remix` CLI script. The script is maintained by the Remix team and
    used to bootstrap new Remix projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal window and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `npx` to execute the `create-remix` script. `npm` and stands for `create-remix`
    v2\. The examples in this book are based on Remix v2\. By adding the `@2` postfix
    to the package name, we ensure that our first demo application installs a Remix
    v2 application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For projects outside of this book, we recommend using the following command
    instead to work with the latest stable version of Remix:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are asked by `npx` to install `create-remix`, enter `y` to answer with
    yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After installing the `create-remix` script, we are prompted to provide a valid
    location for our Remix project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pick an install location on your machine or use the default install location
    offered by the CLI tool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After hitting *Enter*, the script informs us that it selected the basic template,
    also called **Remix App Server**. The script defaults to the basic template if
    no other template is specified. We will learn more about templates in the next
    section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The script prompts us to initialize a new Git repository. Select **Yes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install dependencies with npm? npm install has finished. Next, use the terminal
    to navigate into the newly created project folder:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations on bootstrapping your first Remix project! Let’s start the local
    development server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following command starts our Remix application locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note how fast Remix builds. Built in 204 ms – that is the power of esbuild.
    The exact number of milliseconds varies based on your system, but it’s amazing
    that we can speak about build times in milliseconds!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the specified URL in your browser: `http://localhost:3000`. It should
    render a simple HTML page.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations on running your first Remix application locally! However, it
    wouldn’t be a “Hello World!” project without printing “Hello World” on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the Remix project in an editor of your choice. In the editor, open the
    `_index.tsx` file, located in `app/routes`. You will find it exports a React component.
    Remove the existing JSX code and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that Remix ships with TypeScript by default. Don’t be worried if you haven’t
    used TypeScript before. There are only a few instances where we will have to deal
    with TypeScript directly. Mostly, we can enjoy type inference and autocompletion
    without having to write types ourselves.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save the file changes. Your browser tab should now automatically reload and
    display the updated HTML: **Hello World!**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `create-remix` CLI script makes it easy to create new Remix applications.
    In this section, we bootstrapped a simple Remix application using the default
    template and rendered **Hello World!** to the screen. Next, let’s inspect the
    bootstrapped folder structure. We will inspect each file and study its function.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Remix’s file and folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remix takes on the responsibilities of a compiler, router, and runtime. It provides
    the foundations and framing for the application. As such, it proposes a skeleton
    folder structure for the application. Some files serve as entry points that you
    can hook into. Others can be used to configure Remix. Let’s review our bootstrapped
    Remix app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which files and folders are present depends on the selected configuration options
    during the creation process. However, most files are part of all setups. Selecting
    the basic Remix App Server template yields the following file and folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s have a look at each file and folder. Remix ships with a `.eslintrc` file,
    which configures ESLint to extend Remix’s ESLint extensions. You can adapt or
    remove this file based on your linting and formatting preferences.
  prefs: []
  type: TYPE_NORMAL
- en: When initializing a new Git repository, Remix also creates a `.gitignore` file.
    It is set up to ignore Remix’s build artifacts, temporary files such as the `.cache`
    folder, and other commonly ignored files and folders. You can update this file
    based on your application’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Every newly created project comes with a `README.md` file. The file contains
    important information on how to run and deploy your application. The documentation
    varies based on the selected template. Make sure to read through the `README.md`
    file whenever you bootstrap a new Remix application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s continue with the `package.json` file. If you have worked with
    Node.js-based projects before, you will be familiar with the content. Remix’s
    `package.json` file comes with all the sections you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scripts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dependencies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devDependencies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scripts` section includes a set of scripts to run your Remix application
    locally, build your application, and run your application in production. Usually,
    those scripts are named `dev`, `build`, and `start`. Your application might come
    with additional scripts depending on the selected template.
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to investigate the `dependencies` and `devDependencies` sections.
    You might notice that Remix is split into several packages. Some are dependencies,
    and others are `dev` dependencies. One dependency to highlight is the adapter
    in use.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in the previous chapter that Remix can run anywhere where JavaScript
    can be executed. Remix’s server-side HTTP request handler uses adapters to run
    on different JavaScript runtime and server environments. Each Remix application
    uses an adapter that sits between Remix and the web server.
  prefs: []
  type: TYPE_NORMAL
- en: The basic template uses the `@remix-run/serve` package to run on a Node.js server
    environment. The package implements the Remix App Server, a production-ready Express.js
    server. In contrast to other templates, the Remix App Server does not expose the
    Node.js server setup. Perfect to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a look at the `public` folder. The `public` folder contains
    static files and assets that are exposed over the internet. Currently, the folder
    includes a `favicon.ico` file.
  prefs: []
  type: TYPE_NORMAL
- en: After running the app locally (`npm run dev`), the folder should further include
    a `build` folder. The folder is one of two `build` folders that contain your bundled
    app code. To build your application, locate your terminal and run `npm run build`.
    This will generate the two bundles for production based on your latest code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Remix includes a client and a server application. When writing your Remix application,
    you write code for two different environments, runtimes, and applications. The
    client-side application code is bundled into the `public/build` folder. These
    files are exposed over the internet and can be fetched from a browser.
  prefs: []
  type: TYPE_NORMAL
- en: If you peek inside the `public/build` folder, you can notice that each JavaScript
    module filename ends with a hash. The hash is referred to as the file’s fingerprint.
    There cannot be two files with the same name and different content. This simplifies
    caching. Since a new version of a file means a new file is generated, we can cache
    each file forever without having to deal with cache invalidations. If the content
    of a module changes in a new version of your application, then it will have a
    different unique filename and will be freshly loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `public/build` folder, you can also locate a manifest file (`manifest-*.js`).
    Remix compiles an asset manifest, which is used to route requests and locate assets.
    Since the manifest must be accessed by the client, it is also part of the `public/build`
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the `remix.config.js` file. This JavaScript file exports
    an `AppConfig` configuration object. This file can be used to configure Remix,
    enable future flags, and override Remix's default behavior. Normally, you won’t
    need to touch this file. However, since its content might change depending on
    what template and adapter you choose, it may be relevant when switching between
    templates or adapters. We will learn more about switching adapters later in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s inspect the `remix.env.d.ts` file. This file includes information
    for the TypeScript compiler. The file contains triple-slash directives that declare
    packages that the application is dependent on. The declarations tell TypeScript
    that your application is dependent on Remix’s packages.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is the `tsconfig.json` file – or `jsconfig.json` file if you
    picked a template without TypeScript. These config files contain configuration
    options for the TypeScript compiler and are used to bundle and compile your Remix
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have visited all top-level files and folders, let’s have a look
    inside the `app` folder. This is where the Remix application lives and where we
    write our application code. Remix populates the folder with a set of starter files.
    The `entry.server.tsx` and `entry.client.tsx` files serve as entry points for
    the client and server frameworks, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `entry.client.ts` file contains the code that serves as an entry point for
    the client. Its responsibility is to hydrate React and, hence, initialize the
    SPA-like experience on the client. Remix exposes the entry file so that you can
    adapt it based on your use case. The file can serve as a great place for any code
    that has to be executed only once when the application first loads on the client.
    You can also delete the file, in which case Remix will fall back to the default
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `entry.server.tsx` file exports the `handleRequest` function as its default
    export. The `handleRequest` function is called on incoming requests and generates
    the HTTP response. The general flow of `handleRequest` looks as follows: `handleRequest`
    is invoked with a request object and some additional parameters. The function
    renders React on the server side. The rendered markup is returned, wrapped in
    a new `Response` object, and returned to the adapter code, which passes the response
    to the server to serve the response to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the `root.tsx` file and the `routes` folder. Remix utilizes
    a file-based routing solution. Every file inside the `routes` folder is considered
    a nested route module within the route tree. The file and folder hierarchy of
    the folder maps to the routing hierarchy. Every document/UI route must export
    a React component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `root.tsx` file contains the root document route module. As such, it also
    exports a React component as its default export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that Remix manages the full HTML document, including the `<html />` tag
    and the `<head />` tag in React. This gives us full control over the structure
    of our HTML document. With Remix, you can conditionally render meta tags, change
    the `lang` attribute, or add and remove client-side JavaScript (`<Scripts />`)
    conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The route component in `root.tsx` renders several of Remix’s built-in components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Meta`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Links`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Outlet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScrollRestoration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scripts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveReload`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Meta` component adds meta tags defined in `meta` exports to the HTML document.
    Similarly, the `Links` component adds links defined in `links` exports. You will
    learn more about the `Meta` and `Links` components in [*Chapter 9*](B17399_09.xhtml#_idTextAnchor137),
    *Assets and* *Metadata Handling*.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `{children}` – which you might have expected – Remix provides an
    `Outlet` component to specify where to render the child route. You will learn
    more about the `Outlet` component and nesting of child routes in [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057),
    *Routing* *in Remix*.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScrollRestoration` component manages scroll positions for all client-side
    navigations. SPAs avoid full page reloads and instead render a new page with JavaScript
    on the client. The `ScrollRestoration` component is used to emulate the browser’s
    default behavior and restore the scroll position when the browser’s back and forward
    buttons are used.
  prefs: []
  type: TYPE_NORMAL
- en: The `Scripts` component might be one of the most fascinating components that
    Remix exposes. The component adds all script tags of the bundled Remix application
    to the HTML document. By removing the `Scripts` component, we can remove all client-side
    JavaScript from our Remix application.
  prefs: []
  type: TYPE_NORMAL
- en: The `LiveReload` component triggers page reloads during development whenever
    the development server detects any file changes. `LiveReload` is part of Remix’s
    development server setup and is not used in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Remix offers us control over its inner workings by exposing when
    and how its built-in components are rendered. For instance, if we are not interested
    in live reloads during development, we can just remove the `LiveReload` component.
    If we want to develop static pages without client-side JavaScript, we can remove
    the `Scripts` component.
  prefs: []
  type: TYPE_NORMAL
- en: The `routes` folder contains all other routes of your Remix application. As
    of now, it only contains an `_index` route. An `_index` route is the default child
    of its parent route and shares the same URL. The present `_index` route maps to
    the `/` pathname. We will learn all about routing in [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057),
    *Routing* *in Remix*.
  prefs: []
  type: TYPE_NORMAL
- en: That was quite a few files! Remix acts as your compiler, router, and runtime.
    As such, Remix must be aware of your compiler configurations and the location
    of your code. Remix must further know about all your route modules. As your runtime,
    it also must own the entry points of your application. Since Remix is not a server,
    it must expose these entry points to the server environment. Most of the time,
    you don’t have to touch these entry points and configuration files. However, it
    is great that you can easily alter the content of those files and hook application
    logic into these places if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through Remix’s folder structure and investigated Remix’s
    configuration and project files, we will learn more about the two environments
    of your Remix application.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the client and server environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn about the two environments of every Remix application:
    the client and the server. First, we will learn more about how code is executed
    during runtime. Next, you will learn where to write your client and server code
    and how to help Remix’s compiler recognize what belongs in the client bundle and
    what belongs in the server bundle.'
  prefs: []
  type: TYPE_NORMAL
- en: The two bundles of your Remix application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Remix App Server does not expose its server setup, but most other templates
    do. In this section, we will use the Express.js template to review how Remix interacts
    with the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to bootstrap an Express.js Remix app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `create-remix` command in a terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pick a new folder location for this Remix application and follow the prompts
    as practiced in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the new Remix application. Compare the `package.json` file with the Remix
    App Server `package.json` file from the last section. How do the `dependencies`
    and `scripts` sections differ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open the `server.js` file. The file contains code to set up a new Express.js
    application. Let's go over the code together and discuss the most important aspects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that `createRequestHandler` is imported from Remix’s Express.js adapter
    (`@``remix-run/express`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, the server build of the Remix application is dynamically imported:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'app.all(  "*",  process.env.NODE_ENV === "development"    ? createDevRequestHandler()    :
    build folder to the createRequestHandler function, using the `initialBuild` object
    we defined earlier.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the server environment is informed about both the client and server
    bundle of the Remix application. The client bundle is exposed over the internet.
    The server bundle is passed to the Remix adapter and called on incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Remix is an HTTP request handler
  prefs: []
  type: TYPE_NORMAL
- en: Remix is not a web server but an HTTP request handler that runs on a server
    environment. Remix uses adapters to communicate with the underlying server.
  prefs: []
  type: TYPE_NORMAL
- en: Remix’s adapter code is used within the server environment. The adapter passes
    requests from the server environment to our Remix application and manages our
    HTTP handler’s response using the primitives of the server environment. Depending
    on the selected template and deployment target, the server code differs.
  prefs: []
  type: TYPE_NORMAL
- en: With Remix, we have full control over the `server.js` file. If necessary, we
    can hook into the server code and add additional logic. For instance, we could
    add a WebSocket server to our Express.js application and let it run next to our
    Remix application. Remix’s architecture offers full control over the runtime of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s write some application code inside the `app` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Client and server code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Remix, you can take advantage of the full stack of the web platform. In
    this section, we will learn more about how to write client and server code in
    Remix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we printed **Hello World!** on the home page of our
    first Remix application. We used the following code to render a React component
    onto the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s investigate Remix’s client and server runtimes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `Hello World!` Remix application in an editor and add a `console.log`
    statement into the `function` component in `app/_index.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the Remix application locally. In your terminal window, execute `npm run
    dev` at the root of the project. Can you guess how many times the `console.log`
    statement will be run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the application in a new browser tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, review the terminal where you executed npm run dev. You will see that
    Another hello to the world! is printed in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The terminal is connected to our server-side environment. Visiting the web page
    in a browser tab creates a `GET` request for the web server. `GET / 200` – the
    `GET` request to the `/` – path is responded to with status code `200`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, the request is received by the underlying server environment. The web
    server calls Remix’s adapter callback and the adapter forwards the request to
    Remix’s `handleRequest` function. Remix then renders the React application on
    the server. While our `Index` React component is executed, the `console.log` statement
    is called, printing the statement to the terminal. Conclusively, `console.log`
    is executed once on the server. But is that all?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to your browser window and open the developer tools in the tab that
    shows the Remix application. In the developer tools, navigate to the `entry.client.ts`
    file. Here, Remix rehydrates your React application. React re-renders on the client
    and renders the `Index` component again. Hence, the `console.log` statement is
    run once on the server and then also on the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The React code of your Remix application is run on the server and on the client.
    However, some code should only ever run on the server or the client. For instance,
    the `entry.client.tsx` module should only run on the client, and the `entry.server.tsx`
    module should only ever be executed on the server.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important that no server-side code makes it into the client bundle.
    The code in the client bundle is exposed over the internet. Think about your API
    tokens and other secrets that may be present in your backend logic. Moreover,
    the browser and server environments differ. Node.js APIs are not available on
    the client, and the browser’s global `window` object is not available in Node.js.
    Server-side code may throw errors when executed on the client, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Remix is your compiler and bundles your code into a server and a client bundle.
    But how do we tell Remix what to bundle for the server and what to bundle for
    the client? Most of the time, Remix can figure it out by itself. Remix uses “tree
    shaking” to filter your code and aims to infer which code belongs to which bundle.
    However, you can also explicitly tell the compiler – and developers working on
    your project – that code should only be executed in one of the two environments.
  prefs: []
  type: TYPE_NORMAL
- en: Remix offers a convention to mark files as purely server-side or client-side
    modules. Adding `.client.` or `.server.` to the end of the filename tells Remix’s
    compiler to avoid including these files in the server or client bundle, respectively.
    For instance, you can name your database setup file `db.server.ts` to explicitly
    exclude it from the client bundle. Similarly, you can name a file that imports
    client-only libraries `libs.client.ts` to explicitly avoid importing these packages
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that both entry files (`entry.server` and `entry.client`)
    follow this convention. Feel free to add `console.log` statements to both entry
    files and recognize where each statement is executed – the terminal window or
    the browser **Console** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some files cannot be declared as server or client files. For instance,
    route modules in the `/routes` folder must not be declared as client or server
    files as they may include both client and server code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned more about the code flow of a `GET` request through
    your Remix application. You learned that Remix receives `GET` requests on the
    server and renders your React application on both the client and the server. Some
    code in your Remix application is run on both environments, while other code should
    only run on one environment.
  prefs: []
  type: TYPE_NORMAL
- en: Remix runs on both the client and the server. Learning how to troubleshoot across
    the two environments is crucial. In the next section, you will learn more about
    how to interpret error messages in your Remix application and where to get help.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Remix applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn more about debugging Remix applications. First,
    we will provide you with a general process to approach issues while developing
    with Remix. Next, we will document how to best search for answers and get help
    from the community.
  prefs: []
  type: TYPE_NORMAL
- en: A Remix troubleshooting process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remix is not a server but runs on top of a web server and an underlying server
    runtime environment. Remix acts as an HTTP request handler, orchestrates your
    routes, executes your code during runtime, and acts as your compiler. Quite a
    few things can go wrong. That’s why it’s important to practice the process of
    debugging in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last section, we learned more about Remix’s two environments, the client
    and the server. Remix runs on the server and then executes logic inside the browser.
    Hence, when debugging your Remix application, we must investigate both the client
    and the server environment. Let’s break the `Hello` `World!` App:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following troublesome code to the `app/routes/_index.tsx` file in your
    `Hello` `World!` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run `npm run dev` to start the app if it is not already running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the Remix app in a new browser window or refresh an existing one. Unfortunately,
    you will notice that the application throws an error. The page should show the
    headline **Application Error**. Snap! Let’s start debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Trust the error message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If something goes wrong, the first thing you should do is inspect the terminal
    that is running Remix locally. You should be able to see the following error message
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You might have to scroll a bit to find the relevant line above the stack trace.
    Additionally, the error message should also be rendered in the browser tab. Remix
    displays a fallback error page in case something goes wrong. The error message
    on the page is more readable than on the terminal, but consider the terminal the
    source of truth when it comes to troubleshooting. In this case, both errors are
    matching. It seems like the `navigator` object is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Locate the line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s investigate the error message in the terminal in more detail. We can utilize
    the stack trace to learn which file threw the error and follow the stack trace
    downward across the stack of function calls. You should be able to see that the
    `app/routes/_index.tsx` file threw the error. Seems like that’s an application
    error and not an error with Remix or a dependency since it’s our code that broke.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Build time or runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, note that the error occurs only after we request a page from the web server.
    As `npm run dev` succeeded without throwing any errors, this is a runtime issue,
    not a build time issue. The server also started without throwing errors. This
    indicates that the error occurred within the request handlers and not in the server
    startup code.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The Console and Network tabs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s open the developer tools in the browser window. Click on the **Console**
    tab to view any logged client-side errors. The following error should show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A `GET` request failed with an internal server error. We investigate further
    by navigating to the **Network** tab, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Introducing the Network tab](img/Figure_2.01_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Introducing the Network tab
  prefs: []
  type: TYPE_NORMAL
- en: The `500`. In the **Response** tab (not shown in *Figure 2**.1*), we can further
    see that Remix returned an HTML document – the **Application Error** document
    we see on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: What happened? The web server attempted to handle the `GET` request but threw
    a `ReferenceError`. The error was caught by Remix. Remix returned an error response
    document to the browser. Remix uses the status code `500` – the status code for
    internal server errors – to tell us and the browser that the response is an error
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Turn it off and on again
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we can’t identify the error thus far, it is a good idea to clean up any
    temporary files that might affect our local development server. Stop the development
    server if it is still running. Then run the following command to clean up all
    temporary `build` artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This removes all temporary files and folders. Next, restart the development
    server by executing `npm run dev` in the terminal. This triggers a new build and
    results in a cleaned-up local environment. Does the error persist? In our case,
    it does, but we are able to verify that the error is not due to a broken build.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Google the issue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What would be your Google search query for this issue? Maybe see whether you
    can find the issue on Google. I would probably use one of the following searches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Navigator undefined` `server-rendered React`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Server throws with` `navigator undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remix throws navigator not defined on` `the server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The gotcha is that the `window` element and other browser globals do not exist
    in Node.js. Since we attempt to execute the React component on the server, it
    throws `ReferenceError` – not really a Remix issue but a common pitfall when rendering
    React code on the server. Case solved!
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick fix for this type of error is to wrap references to browser APIs in
    `useEffect` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`useEffect` only runs after the initial render. Since we only render once on
    the server, we know that `useEffect` is only executed on the client and never
    on the server. We can safely call browser APIs in `useEffect`.'
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of any disadvantages of this approach? Reload your application
    and have a look at the terminal. It logs `Another hello to the world!`. On the
    server, we do not have access to the `navigator` object and instead use the default
    value of the React state. We only re-render the appropriate greeting message on
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: What if JavaScript fails to load or is disabled? What if the request is made
    by a web crawler that doesn’t run JavaScript? On slow internet connections, the
    layout might flicker, and the user might first see the server value before it
    is updated once JavaScript is loaded. This is not a great user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix provides utilities to work with user data right on the server – no need
    to use `useEffect` at all. Most of the time, we can avoid client-server state
    mismatches. For now, we can be pleased that we fixed the issue and learned how
    to investigate errors in Remix. We can summarize the described troubleshooting
    process as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find and read the error message in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the file that produces the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand whether it’s a build time or runtime error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the browser developer tools to get more context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all build artifacts and retry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Google the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will focus on *step 6*. Successful debugging takes practice and experience.
    Often, you just have to use Google. In the next section, we document where to
    find answers when working with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Successful debugging takes practice. Once you encounter an issue once or twice,
    you will get faster at figuring out the root cause. Until then, it is good practice
    to search for a solution online. In this section, you will learn how to get help
    when working with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the troubleshooting process as laid out in the last section. It is important
    that you gather as much information as possible. Once you start formulating your
    issue or question, you will find that a thorough investigation might already yield
    the answer. At least it will help identify the right keywords for your online
    search.
  prefs: []
  type: TYPE_NORMAL
- en: Most issues we encounter during development are not related to Remix. Most errors
    occur because of rendering React on the server, accidentally running server code
    on the client, or because of issues with node packages. In these cases, Stack
    Overflow, GitHub, and other places might have the answers we seek.
  prefs: []
  type: TYPE_NORMAL
- en: If that is not the case, then I can only encourage you to join the Remix Discord
    server ([https://discord.com/invite/xwx7mMzVkA](https://discord.com/invite/xwx7mMzVkA)).
    The Remix community is very supportive.
  prefs: []
  type: TYPE_NORMAL
- en: Before asking a question, make sure to use Discord’s search feature to see whether
    the question has already been asked and answered. This saves everyone time. By
    following the troubleshooting process, you should be able to provide plenty of
    context that can help the community debug your code. Providing code snippets (or,
    better, a code sandbox or public repository) will also greatly improve the likelihood
    that the community can assist you. The Remix community is amazing, and Discord
    is a great place to seek help.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have issues with Remix primitives or conventions, refer to the Remix
    documentation. The following page compiles a list of common pitfalls: [https://remix.run/docs/en/2/guides/gotchas](https://remix.run/docs/en/2/guides/gotchas).
    These are issues that are harder to debug. Being aware of them ahead of time can
    save you costly debugging time.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to troubleshoot issues while working with Remix.
    You went through an example error and applied the proposed debugging process to
    uncover the root cause. You further learned more about how to search for answers
    and where to ask questions online.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created our first Remix application. We used Remix’s `create-remix`
    CLI script to bootstrap one Remix app with the basic template and one using Remix’s
    Express.js template.
  prefs: []
  type: TYPE_NORMAL
- en: By following this chapter, you have learned how to build and run Remix applications
    locally using `npm run dev` and `npm run build`. More importantly, you understand
    where to find all available scripts (`package.json`) and additional information
    for running a specific template (`README.md`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We reviewed Remix’s file and folder structure. After reading this chapter,
    you know about the client and server entry points: `entry.client.tsx` and `entry.server.tsx`.'
  prefs: []
  type: TYPE_NORMAL
- en: We also spent some time investigating the `root.tsx` file. The `root.tsx` file
    acts as the root of the route tree. Remix utilizes React to render the full HTML
    document, including the head, bundled scripts, links, and meta tags. This provides
    full control over what is rendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We changed the code of the `_index` route and rendered `Hello World!` to the
    screen. Next, we studied Remix’s two environments: the client and the server.
    You learned that Remix runs in the browser and on a web server. Remix compiles
    the application code into a client and a server build. The web server exposes
    the client code as static files while calling the server bundle during runtime
    to handle incoming requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Remix uses adapters to run on different web servers and server runtimes. The
    adapter manages the communication between our Remix app and the underlying server
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we practiced troubleshooting Remix applications by solving an example
    error. You learned how to investigate errors by looking both at the server’s terminal
    and the **Console** tab in the browser. You also practiced searching for issues
    online, and you found out where to ask the Remix community for help.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about different templates, deployment
    targets, adapters, and Remix stacks. We will compare different server runtimes
    and deployment environments so you can pick the right one for your Remix apps.
    You will also be introduced to `Bee-Rich`, the demo application of this book.
    Get ready to build a Remix application start to finish following the chapters
    of this book!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You don’t need to use `create-remix` to bootstrap a new Remix project. You
    can also start from scratch by installing Remix’s dependencies and setting up
    the file and folder structure yourself. If you are curious about this approach,
    follow the 5-minute tutorial from the Remix documentation: [https://remix.run/docs/en/2/start/quickstart](https://remix.run/docs/en/2/start/quickstart).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduced you to the Remix App Server. You can read more about the Remix’s
    basic template here: [https://remix.run/docs/en/2/other-api/serve](https://remix.run/docs/en/2/other-api/serve).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier in the chapter, refer to Remix’s own troubleshooting guide
    to get help with common gotchas: [https://remix.run/docs/en/2/guides/gotchas](https://remix.run/docs/en/2/guides/gotchas).'
  prefs: []
  type: TYPE_NORMAL
