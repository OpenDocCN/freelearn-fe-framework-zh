<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Keeping up with Activities</h1>
                </header>
            
            <article>
                
<p>In this chapter, we'll build an activity log in our task management system, using <strong>Scalable Vector Graphics</strong> (<strong>SVG</strong>) to build graphical components with Angular. SVG is the perfect candidate when it comes to complex graphical content, and by using Angular components, we can easily build encapsulated and reusable content.</p>
<p>Since we want to log all of the activities within our application, such as adding comments or renaming tasks, we are going to create a central repository for activities. We can then display these activities and render them as an activity timeline by using SVG.</p>
<p>To add an overview of all of the activities and to provide user input to narrow the range of activities displayed, we're going to create an interactive slider component. This component will use a projection to render timestamps, in the form of ticks and activities, directly on the slider's background. We'll also use SVG to render the elements within the component.</p>
<p>We'll cover the following topics in this chapter:</p>
<ul>
<li>A basic introduction to SVG</li>
<li>Making SVG composable with Angular components</li>
<li>Using namespaces in component templates</li>
<li>Creating a simple pipe to format calendar times using Moment.js</li>
<li>Using the <kbd>@HostListener</kbd> decorator to handle user input events, to create an interactive slider element</li>
<li>Making use of Shadow DOM using <kbd>ViewEncapsulation.Native</kbd>, in order to create native style encapsulation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a service for logging activities</h1>
                </header>
            
            <article>
                
<p>The goal of this chapter is to provide a way to keep track of all user activities within a task management application. For that purpose, we'll need a system that will allow us to log activities within components and access previously logged activities.</p>
<p>Within this chapter, we'll only track activities on projects. However, the activity tracker can be used in any feature within our application. We're going to use TypeScript discriminated unions to describe our activities. Let's jump right into it and start by creating the model used within our new activities feature.</p>
<p>Let's open our model file, located in <kbd>src/app/model.ts</kbd>, and add the following changes:</p>
<pre>…<br/>export type ActivityAlignment = 'left' | 'right';<br/><br/>export interface ActivitySliderSelection {<br/>  start: number;<br/>  end: number;<br/>}<br/><br/>export interface ActivityBase {<br/>  kind: string;<br/>  id?: number;<br/>  user: User;<br/>  time: number;<br/>  category: string;<br/>  title: string;<br/>  message: string;<br/>}<br/><br/>export interface ProjectActivity extends ActivityBase {<br/>  kind: 'project';<br/>  projectId: number;<br/>}<br/><br/>export type Activity = ProjectActivity;</pre>
<p>Activities, as entities, should be quite generic, and should have the following fields with their respective purposes:</p>
<ul>
<li><kbd>user</kbd>: The user object of the user that is responsible for this activity.</li>
<li><kbd>time</kbd>: The timestamp of the activity. We will format this timestamp to a readable display format, but will also use it for our projection math when we draw our activity slider.</li>
<li><kbd>category</kbd>: This field provides an additional way of tagging the activity. For projects, we will currently use two categories; <strong>comments</strong> and <strong>tasks</strong>.</li>
<li><kbd>title</kbd>: This refers to the title of the activity, which will provide a very brief summary of what the activity is about. This could be something such as <em>New task was added</em> or <em>Comment was added</em>.</li>
<li><kbd>message</kbd>: This is the field where the real beef of the activity goes. It should contain enough information to provide good traceability of what happened during the activity.</li>
</ul>
<p>Additionally, we're creating an interface, <kbd>ActivitySliderSelection</kbd>, which we're going to use when communicating selection changes within our custom slider UI component.</p>
<p>The custom type, <kbd>ActivityAlignment</kbd>, will be used to store information about the positioning of activities on a timeline.</p>
<p>Let's also update our in-memory database with some initial data, so that we have something to work with when creating our UI components for the activities view. Open up the file located in <kbd>src/app/database.ts</kbd>, and apply the following changes:</p>
<pre>import {InMemoryDbService} from 'angular-in-memory-web-api';<br/>import {<strong>Activity,</strong> Project, Task, User} from './model';<br/><br/>export class Database implements InMemoryDbService {<br/>  createDb() {<br/>    …<br/><br/>    <strong>const now = +new Date();</strong><br/><br/><strong>    const activities: Activity[] = [{</strong><br/><strong>      id: 1,</strong><br/><strong>      kind: 'project',</strong><br/><strong>      user: users[0],</strong><br/><strong>      time: now - 1000 * 60 * 60 * 8,</strong><br/><strong>      projectId: 1,</strong><br/><strong>      category: 'tasks',</strong><br/><strong>      title: 'A task was updated',</strong><br/><strong>      message: 'The task \'Task 1\' was updated on #project-1.'</strong><br/><strong>    }, {</strong><br/><strong>      id: 2,</strong><br/><strong>      kind: 'project',</strong><br/><strong>      user: users[0],</strong><br/><strong>      time: now - 1000 * 60 * 60 * 5,</strong><br/><strong>      projectId: 2,</strong><br/><strong>      category: 'tasks',</strong><br/><strong>      title: 'A task was updated',</strong><br/><strong>      message: 'The task \'Task 1\' was updated on #project-2.'</strong><br/><strong>    }, {</strong><br/><strong>      id: 3,</strong><br/><strong>      kind: 'project',</strong><br/><strong>      user: users[0],</strong><br/><strong>      time: now - 1000 * 60 * 60 * 2,</strong><br/><strong>      projectId: 2,</strong><br/><strong>      category: 'tasks',</strong><br/><strong>      title: 'A task was updated',</strong><br/><strong>      message: 'The task \'Task 2\' was updated on #project-2.'</strong><br/><strong>    }];</strong><br/><br/>    return {users, projects, tasks<strong>, activities</strong>};<br/>  }<br/>}<br/><br/></pre>
<p>Now, we can go ahead and create a service to load activities and log new activities. Let's use the Angular CLI to create the stub of our service:</p>
<pre><strong>ng generate service --spec false activities/activities</strong></pre>
<p>This will generate a new service class on the path <kbd>src/app/activities/activities.service.ts</kbd>. Let's open that file and add the necessary code to implement our service:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {HttpClient} from '@angular/common/http';<br/>import {BehaviorSubject} from 'rxjs';<br/>import {Activity, ProjectActivity, User} from '../model';<br/>import {UserService} from '../user/user.service';<br/>import {map, mergeMap, take} from 'rxjs/operators';<br/><br/>@Injectable()<br/>export class ActivitiesService {<br/>  private activities = new BehaviorSubject&lt;Activity[]&gt;([]);<br/><br/>  constructor(private http: HttpClient, private userService: UserService) {<br/>    this.loadActivities();<br/>  }<br/><br/>  private loadActivities() {<br/>    this.http.get&lt;Activity[]&gt;('/api/activities')<br/>      .subscribe((activities) =&gt; this.activities.next(activities));<br/>  }<br/><br/>  getActivities() {<br/>    return this.activities<br/>      .asObservable().pipe(<br/>        map(activities =&gt; activities.sort((a, b) =&gt; b.time - a.time))<br/>      );<br/>  }<br/><br/>  logProjectActivity(projectId: number, category: string, title: string, message: string) {<br/>    this.userService.getCurrentUser()<br/>      .pipe(<br/>        take(1),<br/>        mergeMap((user: User) =&gt; this.http<br/>          .post('/api/activities', &lt;ProjectActivity&gt;{<br/>            kind: 'project',<br/>            time: +new Date(),<br/>            projectId,<br/>            user,<br/>            category,<br/>            title,<br/>            message<br/>          })<br/>        )<br/>      ).subscribe(() =&gt; this.loadActivities());<br/>  }<br/>}</pre>
<p>There's not much that we need to discuss here. Our service is very similar to the task list or project service that we already created. Additionally, when obtaining an observable of our activities behavior subject, we're performing a sort on the emitted activity list. We always want to emit the activity list sorted by activity time.</p>
<p>Since activities can't be edited or deleted, we only need to be concerned with newly added activities. </p>
<p>In the <kbd>logProjectActivity</kbd> method, we're simply posting a new activity into our in-memory web database, using the Angular HTTP client. The user service will provide us with information on the currently logged-in user.</p>
<p>That's it on the data front. We have created a simple platform that will help us keep track of activities within our application. Later in this book, we can use the activities service to track all sorts of activities. For now, we're just concerned with project-related activities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging activities</h1>
                </header>
            
            <article>
                
<p>We have created a nice system to log activities. Now, let's go ahead and use it within our components, to keep an audit of all of the activities happening within the context of projects.</p>
<p>First, let's use our activities service to log activities when project tasks get updated and created. Logging activities can be viewed as an application side effect, and we don't want to cause side effects within our pure UI components. Instead, the container components are the perfect places to perform these kinds of operations.</p>
<p>Let's open the container component for our task list on the path <kbd>src/app/container/task-list-container/task-list-container.component.ts</kbd>, and apply the following changes:</p>
<pre>…<br/><strong>import {ActivitiesService} from '../../activities/activities.service';</strong><br/><strong>import {limitWithEllipsis} from '../../utilities/string-utilities';</strong><br/><br/>@Component({<br/>  selector: 'mac-task-list-container',<br/>  templateUrl: './task-list-container.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskListContainerComponent {<br/>  …<br/><br/>  constructor(private taskService: TaskService,<br/>              private projectService: ProjectService,<br/>              private route: ActivatedRoute<strong>,</strong><br/><strong>              private activitiesService: ActivitiesService</strong>) {<br/>    …<br/>  }<br/><br/>  activateFilterType(type: TaskListFilterType) {<br/>    this.activeTaskFilterType.next(type);<br/>  }<br/><br/>  addTask(title: string) {<br/>    this.selectedProject<br/>      .pipe(<br/>        take(1)<br/>      )<br/>      .subscribe((project) =&gt; {<br/>        const task: Task = {<br/>          projectId: project.id, title, done: false<br/>        };<br/>        this.taskService.addTask(task);<br/><strong>        this.activitiesService.logProjectActivity(</strong><br/><strong>          project.id,</strong><br/><strong>          'tasks',</strong><br/><strong>          'A task was added',</strong><br/><strong>          `A new task "${limitWithEllipsis(title, 30)}" was added to #project-${project.id}.`</strong><br/><strong>        );</strong><br/>      });<br/>  }<br/><br/>  updateTask(task: Task) {<br/>    this.taskService.updateTask(task);<br/><strong>    this.activitiesService.logProjectActivity(</strong><br/><strong>      task.projectId,</strong><br/><strong>      'tasks',</strong><br/><strong>      'A task was updated',</strong><br/><strong>      `The task "${limitWithEllipsis(task.title, 30)}" was updated on #project-${task.projectId}.`</strong><br/><strong>    );</strong><br/>  }<br/>}<br/><br/></pre>
<p>Using the <kbd>logProjectActivity</kbd> method of our activities service, we can easily log an activity for creating and updating tasks.</p>
<p>In the message body of our activities, we've used a new utility function, <kbd>limitWithEllipsis</kbd>, which we're importing from a new module, called <kbd>string-utilities</kbd>. This function truncates an input string and cuts it off at a position specified with a second parameter. In addition, it appends an ellipsis character (<kbd>…</kbd>) at the end of the truncated string. This is a nice utility for when we want to create a preview of text that might be lengthy.</p>
<p>Let's quickly craft this little helper function and create a new file on the path <kbd>src/app/utilities/string-utilities.ts</kbd>. Open up the file and add the following code:</p>
<pre>export function limitWithEllipsis(str: string, limit: number): string {<br/>  if (str.length &gt; limit) {<br/>    return str.slice(0, limit - 1) + '…';<br/>  } else {<br/>    return str;<br/>  }<br/>}</pre>
<p>That's it for now. We're successfully logging activities upon task creation and updates. We're also going to use the activity service within the project comments container component to create logs for added and edited comments. Since the steps involved are very similar to what we've just done for the task list container component, we're going to skip over this. You can always take a look at the final code base for this chapter to add activity logs for the project comments container component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveraging the power of SVG</h1>
                </header>
            
            <article>
                
<p>SVG has been a part of the Open web platform standards since 1999, and was first recommended in 2001, under the SVG 1.0 standard. SVG is a consolidation of two independent proposals for an XML-based vector image format. <strong>Precision Graphics</strong> <strong>Markup Language</strong> (<strong>PGML</strong>), mainly developed by Adobe and Netscape, and <strong>Vector Markup Language</strong> (<strong>VML</strong>), which was mainly represented by Microsoft and Macromedia, were both different XML formats that served the same purpose. The W3C consortium declined both of the proposals in favor of the newly developed SVG standard, which unified the best of both worlds into a single standard:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b6273a34-2e1c-4c5b-8b3c-da7f8ed8cef9.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Timeline showing the development of the SVG standard</div>
<p>All three standards had a common goal, which was to provide a format for the web to display vector graphics in the browser. SVG is a declarative language that specifies graphical objects using XML elements and attributes.</p>
<p>Let's look at a simple example of how to create an SVG image with a black circle, using SVG:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;   
&lt;svg version="1.1"   
     width="20px" height="20px"&gt; 
  &lt;circle cx="10" cy="10" r="10" fill="black" /&gt; 
&lt;/svg&gt; </pre>
<p>This rather simple example represents an SVG image with a black circle, whose center is located at <kbd>cx="10"</kbd> px and <kbd>cy="10"</kbd> px. The radius of the circle is <kbd>10</kbd> px, which makes this circle <kbd>20</kbd> px in width and height.</p>
<p>The origin of the coordinate system in SVG sits on the top-left corner, where the <em>y</em>-axis faces the south direction and the <em>x</em>-axis eastward:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eba7f085-0746-49c7-af8f-b924daa109e1.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The coordinate system within SVG</div>
<p>Using not only primitive shapes, such as circles, lines, and rectangles, but also complex polygons, the possibilities for creating graphical content are nearly unlimited.</p>
<p>SVG is not only used within the web, but has also become a very important intermediate format for exchanging vector graphics between different applications. Almost any application that supports vector graphics also supports the import and export of SVG files.</p>
<p>The real power of SVG comes to the surface when we do not include an SVG file as an HTML image element, but rather, include the SVG content directly within our DOM. Since HTML5 directly supports the SVG namespace within an HTML document and will render the graphics that we define within our HTML, a whole bunch of new possibilities spring up. We can now style our SVG with CSS, manipulate the DOM with JavaScript, and easily make our SVG interactive.</p>
<p>Taking the previous example of our circle image to the next level, we could make it interactive by changing the circle color (by clicking on it). First, let's create a minimal HTML document and include our SVG elements directly within the DOM:</p>
<pre>&lt;!doctype html&gt; 
&lt;title&gt;Minimalistic Circle&lt;/title&gt; 
&lt;svg width="20px" height="20px"&gt; 
  &lt;circle id="circle" cx="10" cy="10" r="10" fill="black"&gt; 
&lt;/svg&gt; 
&lt;script&gt; 
  document 
    .getElementById('circle') 
    .addEventListener('click', function(event) { 
      event.target.setAttribute('fill', 'red'); 
    }); 
&lt;/script&gt; </pre>
<p>As you can see, we can get rid of the version and the XML namespace declaration when we use SVG directly within the DOM of our HTML document. What's interesting here is that we can treat SVG very much like regular HTML. We can assign an ID, and even classes, to SVG elements, and access them from JavaScript.</p>
<p>Within the <kbd>script</kbd> tag of our HTML document, we can directly access our <kbd>circle</kbd> element using the ID we've previously assigned to it. We can add event listeners to SVG elements the same way as with regular HTML elements. In this example, we added a <kbd>click</kbd> event listener and changed the color of our circle to red.</p>
<p>For the sake of simplicity, we used an inline <kbd>script</kbd> tag in this example. It would, of course, be much cleaner to have a separate JavaScript file to do the scripting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Styling SVG</h1>
                </header>
            
            <article>
                
<p>I'm a purist when it comes to the separation of concerns within the web. I still strongly believe in the separation of structure (HTML), appearance (CSS), and behavior (JavaScript), as well as producing the most maintainable applications when following this practice.</p>
<p>First, it seems weird to have SVG in your HTML, and you might think that this breaks the contract of a clean separation. Why is this graphical content, consisting of only appearance-relevant data, sitting in my HTML, which is supposed to contain only raw information? After dealing with a lot of SVGs within a DOM, I have come to the conclusion that we can establish a clean separation when using SVG by dividing our appearance responsibilities into the two following subgroups:</p>
<ul>
<li><strong>Graphical structure</strong>: This subgroup deals with the process of defining the basic structure of your graphical content. This is about shapes and layout.</li>
<li><strong>Visual appearance</strong>: This subgroup deals with the process of defining the look and feel of our graphical structures, such as colors, line widths, line styles, and text alignment.</li>
</ul>
<p>If we separate the concerns of SVG into these groups, we can actually gain great maintainability. The graphical structure is defined by the SVG shapes themselves. They are directly written within our HTML, but don't have a particular look and feel. We only store the basic structural information within HTML.</p>
<p>Luckily, instead of using attributes on SVG elements, all the properties for visual appearance, such as color, can also be specified with corresponding CSS properties. That allows us to offload all of the look-and-feel relevant aspects of the structure to CSS.</p>
<p>Let's go back to the example where we drew a black circle; we'll tweak this a bit, to fit our demands of separation of concerns, so that we can distinguish graphical structure from graphical appearance:</p>
<pre>&lt;!doctype html&gt; 
&lt;title&gt;Minimalistic Circle&lt;/title&gt; 
&lt;svg width="20px" height="20px"&gt; 
  &lt;circle class="circle" cx="10" cy="10" r="10"&gt; 
&lt;/svg&gt; </pre>
<p>Styling our graphical structures can now be achieved by using CSS, including a style sheet with the following content:</p>
<pre>.circle { 
  fill: black; 
} </pre>
<p>This is fantastic, as we can not only reuse some graphical structures, but can also apply different visual appearance parameters using CSS, similar to those enlightening moments when we managed to reuse some semantic HTML by only changing some CSS.</p>
<p>Let's look at the most important CSS properties that we can use to style SVG shapes:</p>
<ul>
<li><kbd>fill</kbd>: When working with solid SVG shapes, there's always a shape fill and stroke option available; the <kbd>fill</kbd> property specifies the color of the shape fill.</li>
<li><kbd>stroke</kbd>: This property specifies the color of the SVG shape's outline.</li>
<li><kbd>stroke-width</kbd>: This property specifies the width of the SVG shape's outline on solid shapes. For non-solid shapes, such as lines, this can be thought of as the line width.</li>
<li><kbd>stroke-dasharray</kbd>: This specifies a dash pattern for strokes. Dash patterns are space-separated values that define a pattern.</li>
<li><kbd>stroke-dashoffset</kbd>: This specifies an offset for the dash pattern, which is specified with the <kbd>stroke-dasharray</kbd> property.</li>
<li><kbd>stroke-linecap</kbd>: This property defines how line caps should be rendered. They can be rendered as square, butt, or rounded caps.</li>
<li><kbd>stroke-linejoin</kbd>: This property specifies how lines are joined together within a path.</li>
<li><kbd>shape-rendering</kbd>: Using this property, you can override the shape-rendering algorithm that, as the name suggests, is used to render shapes. This is particularly useful if you need crispy edges on your shapes.</li>
</ul>
<p>For a complete reference of the available appearance-relevant SVG attributes, visit the Mozilla Developer website at <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute"><span class="URLPACKT">https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute</span></a>.</p>
<p>I hope that this brief introduction gave you a better feeling about SVG and the great power it comes with. In this chapter, we're going to use some of that power to create nice, interactive graphical components. If you would like to learn more about SVG, I strongly recommend that you go through the great articles by Sara Soueidan.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building SVG components</h1>
                </header>
            
            <article>
                
<p>When building Angular components with SVG templates, there are a couple of things that you need to be aware of. The first and most obvious one is XML namespaces. Modern browsers are very intelligent when parsing HTML. Besides being probably the most fault-tolerant parsers in the history of computer science, DOM parsers are very smart in recognizing markup, and then deciding how to treat it. They will automatically decide the correct namespaces for us, based on element names, so we don't need to deal with them when writing HTML.</p>
<p>If you've messed around with the DOM API a bit, you've probably recognized that there are two methods for creating new elements. In the document object, for example, there's a <kbd>createElement</kbd> function, but there's also <kbd>createElementNS</kbd>, which accepts an additional namespace URI parameter. Also, every element created has a <kbd>namespaceURI</kbd> property that tells you the namespace of the specific element. That is important, since HTML5 is a standard that consists of at least three namespaces:</p>
<ul>
<li><strong>HTML</strong>: This is the standard HTML namespace, with the <a href="http://www.w3.org/1999/xhtml"><span class="URLPACKT">http://www.w3.org/1999/xhtml</span></a> URI.</li>
<li><strong>SVG</strong>: This embraces all SVG elements and attributes and uses the <a href="http://www.w3.org/2000/svg"><span class="URLPACKT">http://www.w3.org/2000/svg</span></a> URI. You can sometimes see this namespace URI in an <kbd>xmlns</kbd> attribute of the <kbd>svg</kbd> elements. In fact, this is not really required, as the browser is smart enough to decide on the correct namespace itself.</li>
<li><strong>MathML</strong>: This is an XML-based format to describe mathematical formulas, and it is supported in most modern browsers. It uses the <a href="http://www.w3.org/1998/Math/MathML"><span class="URLPACKT">http://www.w3.org/1998/Math/MathML</span></a> namespace URI.</li>
</ul>
<p class="mce-root">We can mix all of these elements from different standards and namespaces within a single document, and our browser will figure out the correct namespace itself, when it creates elements within the DOM.</p>
<div class="packt_tip">If you want more information on namespaces, I recommend that you go through the <em>Namespaces</em> <em>Crash Course</em> article on the Mozilla Developer Network at <a href="https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course"><span class="URLPACKT">https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course</span></a>.</div>
<p>As Angular will compile templates for us and render elements into the DOM using the DOM API, it needs to be aware of the namespaces when doing so. Similar to the browser, Angular provides some intelligence for deciding the correct namespace when creating elements. However, there will be some situations where you will need to help Angular recognize the correct namespace.</p>
<p>To illustrate some of this behavior, let's transform the circle example that we've been working on into an Angular component:</p>
<pre>@Component({ 
  selector: 'awesome-circle', 
  template: ` 
    &lt;svg [attr.width]="size" [attr.height]="size"&gt; 
      &lt;circle [attr.cx]="size/2" [attr.cy]="size/2" 
              [attr.r]="size/2" fill="black" /&gt; 
    &lt;/svg&gt; 
  ` 
}) 
export class AwesomeCircle { 
  @Input() size; 
} </pre>
<p>We've wrapped our circle SVG graphics into a simple Angular component. The <kbd>size</kbd> input parameter determines the actual width and height of the circle by controlling the SVG's <kbd>width</kbd> and <kbd>height</kbd> attributes and the circle's <kbd>cx</kbd>, <kbd>cy</kbd>, and <kbd>r</kbd> attributes.</p>
<p>To use our circle component, simply use the following template within another component:</p>
<pre>&lt;awesome-circle [size]="20"&gt;&lt;/awesome-circle&gt;</pre>
<div class="packt_infobox"><span>It's important to note that we need to use attribute bindings on SVG elements, and we can't set DOM element properties directly. This is due to the nature of SVG elements that have special property types (for example, </span><kbd>SVGAnimatedLength</kbd><span>) that can be animated with </span><strong>Synchronized Multimedia Integration</strong><span> </span><strong>Language</strong><span> (</span><strong>SMIL</strong><span>). Instead of interfering with these rather complex</span> <span>element properties, we can simply use attribute bindings to set the attribute values of the DOM element.</span></div>
<p>Let's go back to our namespace discussion. Angular will know that it needs to use the SVG namespace to create the elements within this template. It will function in this way simply because we're using the <kbd>svg</kbd> element as a root element within our component, and it can switch the namespace within the template parser for any child elements automatically.</p>
<p>However, there are certain situations where we need to help Angular determine the correct namespace for the elements we'd like to create. This strikes us if we're creating nested SVG components that don't contain a root <kbd>svg</kbd> element:</p>
<pre>@Component({ 
  selector: '[awesomeCircle]', 
  template: ` 
      <strong>&lt;svg:circle [attr.cx]="size/2" [attr.cy]="size/2" 
                  [attr.r]="size/2" fill="black" /&gt;</strong> 
  ' 
}) 
export class AwesomeCircle { 
  @Input('awesomeCircle') size; 
} 
 
@Component({ 
  selector: 'app' 
  template: ` 
   &lt;svg width="20" height="20"&gt; 
    &lt;g [awesomeCircle]="20"&gt;&lt;/g&gt; 
   &lt;/svg&gt; 
  `, 
  directives: [AwesomeCircle] 
}) 
export class App {} </pre>
<p>In this example, we're nesting SVG components, and our awesome circle component does not have an <kbd>svg</kbd> root element to tell Angular to switch the namespace. That is why we've created the <kbd>svg</kbd> element within our app component, and then included the awesome circle component in an SVG group.</p>
<p>We need to explicitly tell Angular to switch to the SVG namespace within our circle component, and we can do this by including the namespace name as a prefix separated by a colon, as you can see in the highlighted section of the preceding code excerpt.</p>
<p>If you have multiple elements that need to be created <span>explicitly </span>within the SVG namespace, you can rely on the fact that Angular does apply the namespace for child elements, too, and groups all of your elements with an SVG group element. So, you only need to prefix the group element with <kbd>&lt;svg:g&gt; ... &lt;/svg:g&gt;</kbd>, but none of the contained SVG elements.</p>
<p>That is enough to know about Angular internals when dealing with SVG. Let's move on and create some real components!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building an interactive activity slider component</h1>
                </header>
            
            <article>
                
<p>In the previous topics, we covered the basics of working with SVG and dealing with SVG in Angular components. Now, it's time to apply our knowledge to the task management application and create some awesome components using SVG.</p>
<p>The first component we'll be creating in this context is an interactive slider that allows the user to select the time range of activities that he or she is interested in checking out. Displaying a simple HTML5 range input could be a solution, but since we've gained some SVG superpower, we can do better! We'll use SVG to render our own slider that will show existing activities as ticks on the slider. Let's look at a mock-up of the slider component that we're going to create:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/82660348-4ed9-4955-9650-845f2152666f.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A mock-up of the activity slider component</div>
<p>Our slider component will actually serve two purposes. It should be a user control, and should provide a way to select a time range for filtering activities. However, it should also provide an overview of all of the activities, so that a user can filter the range more intuitively. By drawing vertical bars that represent activities, we can already give the user a feeling of the range he or she is interested in.</p>
<p>Let's create our new activity slider component using the Angular CLI tool:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush activities/activity-slider</strong></pre>
<p>Open the generated component class on the path <kbd>src/app/activities/activity-slider/activity-slider.component.ts</kbd>, and add the following code:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostListener,<br/>  Input, OnChanges, Output, SimpleChanges, ViewEncapsulation<br/>} from '@angular/core';<br/>import {Activity, ActivitySliderSelection} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity-slider',<br/>  templateUrl: './activity-slider.component.html',<br/>  styleUrls: ['./activity-slider.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.Native<br/>})<br/>export class ActivitySliderComponent {<br/>  @Input() activities: Activity[];<br/>  @Output() outSelectionChange = new EventEmitter&lt;ActivitySliderSelection&gt;();<br/>  constructor(private elementRef: ElementRef) {}<br/>}</pre>
<p>The first thing we should mention, which differs from all of the other components we've written about so far, is that we're using <kbd>ViewEncapsulation.Native</kbd> for this component. As we learned from the <em>Creating our application component</em> section in <a href="11f96942-6e99-46c5-b152-1af3b2579d44.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Ready, Set, Go!</em>, when we use <kbd>ViewEncapsulation.Native</kbd> for our component encapsulation, Angular actually uses Shadow DOM to create the component. We briefly looked at this in the <em>Shadow DOM</em> section in <a href="72fc993e-43db-48eb-8797-c65ea9226b87.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Component-Based User Interfaces,</em> as well.</p>
<p>Using Shadow DOM for our component will give us this advantage: Our component will be fully encapsulated, from the CSS side of things. This not only means that none of the global CSS will leak into our component; it also means that we'll need to create local styles, in order to style our component.</p>
<p>So far, we've used styles coming from a global style sheet, which has been prepared for the book. We're using a component CSS naming convention within that file, in order to avoid name clashes with CSS classes. However, when using Shadow DOM, we can forego prefixes and other naming conventions to avoid name clashes, since we're only applying styles locally, within the component.</p>
<div class="packt_tip"><span>Chrome supports Shadow DOM natively, from Version 35. Within Firefox, Shadow DOM can be enabled by visiting the </span><kbd>about:config</kbd><span> page and turning on the </span><kbd>dom.webcomponents.enabled</kbd><span> flag. IE, Edge, and Safari don't support this standard at all; however, we can set things up in a way that they can deal with Shadow DOM, by including a polyfill named </span><kbd>webcomponents.js</kbd><span>. You can find more information on this polyfill at </span><a href="https://github.com/webcomponents/webcomponentsjs"><span class="URLPACKT">https://github.com/webcomponents/webcomponentsjs</span></a><span>.</span></div>
<p>Now, let's add the local CSS styles that we're going to use within our activity slider component. Open the file <kbd><span>src/app/activities/activity-slider/activity-slider.component.css</span></kbd>, and add the following code:</p>
<pre>:host {<br/>  display: block;<br/>}<br/><br/>.slide {<br/>  fill:#f9f9f9;<br/>}<br/><br/>.activity {<br/>  fill:#3699cb;<br/>}<br/><br/>.time {<br/>  fill:#bbb;<br/>  font-size:14px;<br/>}<br/><br/>.tick {<br/>  stroke:#bbb;<br/>  stroke-width:2px;<br/>  stroke-dasharray:3px;<br/>}<br/><br/>.selection-overlay {<br/>  fill:#d9d9d9;<br/>}<br/> </pre>
<p>Usually, such short class names would probably lead to name clashes within our project, but since the styles will be local to the Shadow DOM of our component, we don't need to worry about name clashes anymore.</p>
<p>You can see that we're using a special pseudo-selector, <kbd>:host</kbd>, within our styles. This selector is part of the Shadow DOM specification for CSS, and it allows us to style the host element of a shadow root. This becomes very handy, since we can treat the host element as a part of our component internals when styling.</p>
<p>Let's go back to the rest of the code inside of our activity slider component. As an input parameter, we define the list of activities that will be used, not only to determine the available range in the slider, but also to render activities on the background of the slider.</p>
<p>Once a selection is made by the user, our component will use the <kbd>outSelectionChange</kbd> output to notify the outside world about the change.</p>
<p>Within the constructor, we're injecting the host element for later use. We will need that to access the native DOM elements of our slider, in order to do some width calculations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Projection of time</h1>
                </header>
            
            <article>
                
<p>Our slider component needs to be able to project timestamps into the coordinate system of SVG. Also, when a user clicks on the timeline to select a range, we'll need to be able to project coordinates back into timestamps. For this purpose, we need to create two projection functions within our component, which will use a few helper functions and states to calculate the values, from coordinates to time, and vice-versa:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/67be855a-4b2d-4263-a26b-549231cf0f4d.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Visualization of important variables and functions for our calculations</div>
<p>While we will use percentages to position our SVG elements on the slider component, the padding on the sides will need to be specified in pixels. The <kbd>totalWidth</kbd> function will return the total width of the area in pixels; this is where we'll draw the activity indicators. The <kbd>timeFirst</kbd>, <kbd>timeLast</kbd>, and <kbd>timeSpan</kbd> variables will also be used by the calculations, and are specified in milliseconds.</p>
<p>Let's add some code to our slider to deal with the projection of our activities on the slider:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, ViewEncapsulation<br/>} from '@angular/core';<br/>import {Activity, ActivitySliderSelection} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity-slider',<br/>  templateUrl: './activity-slider.component.html',<br/>  styleUrls: ['./activity-slider.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.Native<br/>})<br/>export class ActivitySliderComponent {<br/>  @Input() activities: Activity[];<br/>  @Output() outSelectionChange = new EventEmitter&lt;ActivitySliderSelection&gt;();<br/> <strong> padding = 20;</strong><br/><strong>  timeFirst: number;</strong><br/><strong>  timeLast: number;</strong><br/><strong>  timeSpan: number;</strong><br/><br/>  constructor(private elementRef: ElementRef) {}<br/><br/><strong>  totalWidth() {</strong><br/><strong>    return this.elementRef.nativeElement.clientWidth - this.padding * 2;</strong><br/><strong>  }</strong><br/><br/><strong>  projectTime(time: number) {</strong><br/><strong>    const position = this.padding +</strong><br/><strong>      (time - this.timeFirst) / this.timeSpan * this.totalWidth();</strong><br/><strong>    return position / this.elementRef.nativeElement.clientWidth * 100;</strong><br/><strong>  }</strong><br/><br/><strong>  projectLength(length: number) {</strong><br/><strong>    return this.timeFirst + (length - this.padding) / this.totalWidth() * this.timeSpan;</strong><br/><strong>  }</strong><br/>}</pre>
<p>Since we have put aside the reference to the host element, we can use its <kbd>clientWidth</kbd> property to get the full width of the component and subtract the padding. This will give us the full width of the area where we'd like to draw activity indicators, in pixels.</p>
<p>In the <kbd>projectTime</kbd> function, we will first transform the timestamp into a position by a simple rule of three. Because we have access to the timestamp of the first activity, as well as the total time span, this will be a quite simple task. Once we do this, we can convert our position value, which is of unit pixels, into a percentage, by dividing it by the total component width and then multiplying it by 100.</p>
<p>To project a pixel value back to a timestamp, we can more or less perform the reverse of <kbd>projectTime</kbd>, except that we're not dealing with percentages here, but assuming that the length parameter of the <kbd>projectLength</kbd> function is in a pixel unit.</p>
<p>We've used some member variables (<kbd>timeFirst</kbd>, <kbd>timeLast</kbd>, and <kbd>timeSpan</kbd>) within our projection code, but how do we set these member variables? Since we have an <kbd>activities</kbd> component input, which is expected to be a list of relevant activities, we can observe the input for changes and set the values based on the input. To observe that component input for changes, we can use the <kbd>OnChanges</kbd> life cycle hook:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostListener,<br/>  Input, Output, <strong>OnChanges, SimpleChanges</strong>, ViewEncapsulation<br/>} from '@angular/core';<br/>import {Activity, ActivitySliderSelection} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity-slider',<br/>  templateUrl: './activity-slider.component.html',<br/>  styleUrls: ['./activity-slider.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.Native<br/>})<br/>export class ActivitySliderComponent<strong> implements OnChanges</strong> {<br/>  @Input() activities: Activity[];<br/>  @Output() outSelectionChange = new EventEmitter&lt;ActivitySliderSelection&gt;();<br/>  padding = 20;<br/>  timeFirst: number;<br/>  timeLast: number;<br/>  timeSpan: number;<br/><br/>  constructor(private elementRef: ElementRef) {}<br/><br/>  <strong>ngOnChanges(changes: SimpleChanges) {</strong><br/><strong>    if (changes.activities &amp;&amp; this.activities) {</strong><br/><strong>      if (this.activities.length === 1) {</strong><br/><strong>        this.timeFirst = this.timeLast = this.activities[0].time;</strong><br/><strong>      } else if (this.activities.length &gt; 1) {</strong><br/><strong>        this.timeFirst = this.activities[this.activities.length - 1].time;</strong><br/><strong>        this.timeLast = this.activities[0].time;</strong><br/><strong>      } else {</strong><br/><strong>        this.timeFirst = this.timeLast = new Date().getTime();</strong><br/><strong>      }</strong><br/><br/><strong>      this.timeSpan = Math.max(1, this.timeLast - this.timeFirst);</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/><br/>  …<br/>}</pre>
<p>First, we need to check whether the changes include changes to the <kbd>activities</kbd> input and that the current value of the input is valid. After checking for the input value, we can determine our member variables, namely <kbd>timeFirst</kbd>, <kbd>timeLast</kbd>, and <kbd>timeSpan</kbd>. We limit the <kbd>timeSpan</kbd> variable to at least <kbd>1</kbd>, as our projection calculations would be messed up otherwise.</p>
<p>The preceding code will ensure that we will always recalculate our member variables when the <kbd>activities</kbd> input changes, and that we'll be using the most recent data-rendering activities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering activity indicators</h1>
                </header>
            
            <article>
                
<p>We've already implemented the basics of the component and laid the groundwork for drawing time information into the coordinate system of our component. It's time to use our projection functions and draw our activities as indicators on the slider using SVG.</p>
<p>Let's open the template of our activity slider in <kbd>src/app/activities/activity-slider/activity-slider.component.html</kbd>, and add the following code:</p>
<pre>&lt;svg width="100%" height="70px"&gt;<br/>  &lt;rect x="0" y="30" width="100%" height="40" class="slide"&gt;&lt;/rect&gt;<br/>  &lt;rect *ngFor="let activity of activities"<br/>        [attr.x]="projectTime(activity.time) + '%'"<br/>        height="40" width="2px" y="30" class="activity"&gt;&lt;/rect&gt;<br/>&lt;/svg&gt;</pre>
<p>Since we need to create an indicator for every activity within our activities list, we can simply use the <kbd>ngFor</kbd> directive to repeat the rectangle that represents our activity indicator.</p>
<p>As we know from building our activity service class in a previous topic, <em>Creating a service for logging activities</em>, activities always contain a <kbd>time</kbd> field with the timestamp of the activity. Within our component, we have already created a projection function that converts time into a percentage, relative to our component width. We can simply use the <kbd>projectTime</kbd> function within our attribute binding for the <kbd>x</kbd> attribute of the <kbd>rect</kbd> element, to position our activity indicators at the correct positions.</p>
<p>By only using an SVG template and our backing function to project time, we have created a nice little chart that displays activity indicators on a timeline.</p>
<p>You can imagine that if we have a lot of activities, our slider will actually look pretty stuffed, and it will be hard to get a feeling for when those activities may have occurred. We need to have some sort of a grid that will help us associate the chart with a timeline.</p>
<p>As already shown in the mock-up of our slider component, now, we're going to introduce some ticks on the slider background that will divide the slider into sections. We'll also label each tick with a calendar time. This will give our users a rough sense of time, when looking at the activity indicators on the slider.</p>
<p>Let's look at the code changes within our activity slider class that will enable the rendering of our ticks:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, ElementRef, EventEmitter,<br/>  Input, OnChanges, Output, SimpleChanges, ViewEncapsulation<br/>} from '@angular/core';<br/>import {Activity, ActivitySliderSelection} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity-slider',<br/>  templateUrl: './activity-slider.component.html',<br/>  styleUrls: ['./activity-slider.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.Native<br/>})<br/>export class ActivitySliderComponent implements OnChanges {<br/>  @Input() activities: Activity[];<br/>  @Output() outSelectionChange = new EventEmitter&lt;ActivitySliderSelection&gt;();<br/>  padding = 20;<br/>  timeFirst: number;<br/>  timeLast: number;<br/>  timeSpan: number;<br/><strong>  ticks: number[];</strong><br/><br/>  constructor(private elementRef: ElementRef) {}<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    if (changes.activities &amp;&amp; this.activities) {<br/>      if (this.activities.length === 1) {<br/>        this.timeFirst = this.timeLast = this.activities[0].time;<br/>      } else if (this.activities.length &gt; 1) {<br/>        this.timeFirst = this.activities[this.activities.length - 1].time;<br/>        this.timeLast = this.activities[0].time;<br/>      } else {<br/>        this.timeFirst = this.timeLast = new Date().getTime();<br/>      }<br/><br/>      this.timeSpan = Math.max(1, this.timeLast - this.timeFirst);<br/>      <strong>this.computeTicks();</strong><br/>    }<br/>  }<br/><br/>  <strong>computeTicks() {</strong><br/><strong>    const count = 5;</strong><br/><strong>    const timeSpanTick = this.timeSpan / count;</strong><br/><strong>    this.ticks = Array.from({length: count}).map((element, index) =&gt; {</strong><br/><strong>      return this.timeFirst + timeSpanTick * index;</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/><br/>  …<br/>}</pre>
<p>First of all, we need to create a function that computes some ticks for us, which we can place onto the timeline. For this purpose, we need to create the <kbd>computeTicks</kbd> method, which will divide the whole timeline into five equal segments and generate timestamps that represent the positions in time for individual ticks. We will store these ticks in a new <kbd>ticks</kbd> member variable. With the help of these timestamps, we can easily render the ticks within our view.</p>
<div class="packt_tip"><span>We use the </span><kbd>Array.from</kbd><span> ES6 function to create a new array with the desired length, and use the functional array extra function </span><kbd>map</kbd><span> to generate tick model objects from this array. Using </span><kbd>Array.from</kbd><span> is a nice trick to create an initial array of a given length, which can be used to establish a </span>functional<span> style.</span></div>
<p>Let's look at the template of our activity slider component, and how we can use our array of timestamps to render ticks on our slider component:</p>
<pre>&lt;svg width="100%" height="70px"&gt;<br/>  &lt;rect x="0" y="30" width="100%" height="40" class="slide"&gt;&lt;/rect&gt;<br/><strong>  &lt;g *ngFor="let tick of ticks"&gt;</strong><br/><strong>    &lt;text [attr.x]="projectTime(tick) + '%'" y="14" class="time"&gt;</strong><br/><strong>      {{tick | calendarTime}}</strong><br/><strong>    &lt;/text&gt;</strong><br/><strong>    &lt;line [attr.x1]="projectTime(tick) + '%'" [attr.x2]="projectTime(tick) + '%'"</strong><br/><strong>          y1="30" y2="70" class="tick"&gt;&lt;/line&gt;</strong><br/><strong>  &lt;/g&gt;</strong><br/>  &lt;rect *ngFor="let activity of activities"<br/>        [attr.x]="projectTime(activity.time) + '%'"<br/>        height="40" width="2px" y="30" class="activity"&gt;&lt;/rect&gt;<br/>&lt;/svg&gt;</pre>
<p>To render our ticks, we've used an SVG group element to place our <kbd>ngFor</kbd> directive that repeats the tick timestamps we've stored in the <kbd>ticks</kbd> member variable.</p>
<p>For each tick, we need to place a label, as well as a line, that spans over the slider background. We can use the SVG text element to render our label with the timestamp on top of the slider. Within the attribute binding for the <kbd>x</kbd> attribute of our <kbd>text</kbd> element, we've used our <kbd>projectTime</kbd> projection function to receive the projected percentage value from our timestamp. The <kbd>y</kbd> coordinate of our <kbd>text</kbd> element is fixed at a position where the labels will just sit on top of our slider.</p>
<p>SVG lines consist of four coordinates: <kbd>x1</kbd>, <kbd>x2</kbd>, <kbd>y1</kbd>, and <kbd>y2</kbd>. Together, they define two coordinate points, where a line will be drawn from one point to the other.</p>
<p>Now, we are getting closer to the final slider that we specified in the mock-up at the beginning of this topic. The last missing piece of the puzzle is to make our slider interactive, so a user can select a range of activities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bringing it to life</h1>
                </header>
            
            <article>
                
<p>So far, we've covered the rendering of the slider background, as well as the rendering of the activity indicators. We've also generated ticks and displayed them with a grid line and a label, to display the calendar time of each tick.</p>
<p>Well, that does not really make a slider, does it? Of course, we also need to handle user input, and make the slider interactive, so that users can select a time range that they want to display the activities for.</p>
<p>To do this, add the following changes to the component class:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostListener,<br/>  Input, OnChanges, Output, SimpleChanges, ViewEncapsulation<br/>} from '@angular/core';<br/>import {Activity, ActivitySliderSelection} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity-slider',<br/>  templateUrl: './activity-slider.component.html',<br/>  styleUrls: ['./activity-slider.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.Native<br/>})<br/>export class ActivitySliderComponent implements OnChanges {<br/>  @Input() activities: Activity[];<br/>  @Output() outSelectionChange = new EventEmitter&lt;ActivitySliderSelection&gt;();<br/>  padding = 20;<br/>  timeFirst: number;<br/>  timeLast: number;<br/>  timeSpan: number;<br/>  ticks: number[];<br/><strong>  selection: ActivitySliderSelection;</strong><br/><br/>  constructor(private elementRef: ElementRef) {}<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    if (changes.activities &amp;&amp; this.activities) {<br/>      if (this.activities.length === 1) {<br/>        this.timeFirst = this.timeLast = this.activities[0].time;<br/>      } else if (this.activities.length &gt; 1) {<br/>        this.timeFirst = this.activities[this.activities.length - 1].time;<br/>        this.timeLast = this.activities[0].time;<br/>      } else {<br/>        this.timeFirst = this.timeLast = new Date().getTime();<br/>      }<br/><br/>      this.timeSpan = Math.max(1, this.timeLast - this.timeFirst);<br/>      this.computeTicks();<br/><br/><strong>      this.selection = {</strong><br/><strong>        start: this.timeFirst,</strong><br/><strong>        end: this.timeLast</strong><br/><strong>      };</strong><br/><strong>      this.outSelectionChange.next(this.selection);</strong><br/>    }<br/>  }<br/>  <br/>  …<br/>}</pre>
<p>When we detect a change in the <kbd>activities</kbd> input property within the <kbd>OnChanges</kbd> life cycle hook, we initialize a <kbd>ActivitySliderSelection</kbd> object for the user selection in our slider component. It consists of a <kbd>start</kbd> and <kbd>end</kbd> property, both containing timestamps that represent the selected range on our activity slider.</p>
<p>Once we've set our initial selection, we need to use the <kbd>outSelectionChange</kbd> output property to emit an event. That way, we can let our parent component know that the selection within the slider has changed.</p>
<p>To display the selected range, we use an overlay rectangle within our template, which will be placed above the slider background. If you look at the mock-up image of the slider again, you'll notice that this overlay is painted in grey:</p>
<pre>&lt;svg width="100%" height="70px"&gt;<br/>  &lt;rect x="0" y="30" width="100%" height="40" class="slide"&gt;&lt;/rect&gt;<br/>  <strong>&lt;rect *ngIf="selection"</strong><br/><strong>        [attr.x]="projectTime(selection.start) + '%'"</strong><br/><strong>        [attr.width]="projectTime(selection.end) - projectTime(selection.start) + '%'"</strong><br/><strong>        y="30" height="40" class="selection-overlay"&gt;&lt;/rect&gt;</strong><br/>  &lt;g *ngFor="let tick of ticks"&gt;<br/>    &lt;text [attr.x]="projectTime(tick) + '%'" y="14" class="time"&gt;<br/>      {{tick | calendarTime}}<br/>    &lt;/text&gt;<br/>    &lt;line [attr.x1]="projectTime(tick) + '%'" [attr.x2]="projectTime(tick) + '%'"<br/>          y1="30" y2="70" class="tick"&gt;&lt;/line&gt;<br/>  &lt;/g&gt;<br/>  &lt;rect *ngFor="let activity of activities"<br/>        [attr.x]="projectTime(activity.time) + '%'"<br/>        height="40" width="2px" y="30" class="activity"&gt;&lt;/rect&gt;<br/>&lt;/svg&gt;</pre>
<p>This rectangle will be placed just above our slider background, and will use our projection function to calculate the <kbd>x</kbd> and <kbd>width</kbd> attributes. As we need to wait for change detection to initialize our selection within the <kbd>OnChanges</kbd> life cycle hook, we'll just check for a valid selection object by making use of the <kbd>ngIf</kbd> directive.</p>
<p>Now, we need to start tackling user input in our activity slider component. The mechanics for storing the state and rendering our selection are already in place, so we can implement the required host listeners to handle user input. Since we've applied quite a few changes progressively, let's look at the final, full version of the component class. The missing changes to add user interactions are marked in bold:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, ElementRef, EventEmitter, <strong>HostListener</strong>,<br/>  Input, OnChanges, Output, SimpleChanges, ViewEncapsulation<br/>} from '@angular/core';<br/>import {Activity, ActivitySliderSelection} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity-slider',<br/>  templateUrl: './activity-slider.component.html',<br/>  styleUrls: ['./activity-slider.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.Native<br/>})<br/>export class ActivitySliderComponent implements OnChanges {<br/>  @Input() activities: Activity[];<br/>  @Output() outSelectionChange = new EventEmitter&lt;ActivitySliderSelection&gt;();<br/>  padding = 20;<br/>  timeFirst: number;<br/>  timeLast: number;<br/>  timeSpan: number;<br/>  ticks: number[];<br/>  selection: ActivitySliderSelection;<br/> <strong> modifySelection: boolean;</strong><br/><br/>  constructor(private elementRef: ElementRef) {}<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    if (changes.activities &amp;&amp; this.activities) {<br/>      if (this.activities.length === 1) {<br/>        this.timeFirst = this.timeLast = this.activities[0].time;<br/>      } else if (this.activities.length &gt; 1) {<br/>        this.timeFirst = this.activities[this.activities.length - 1].time;<br/>        this.timeLast = this.activities[0].time;<br/>      } else {<br/>        this.timeFirst = this.timeLast = new Date().getTime();<br/>      }<br/><br/>      this.timeSpan = Math.max(1, this.timeLast - this.timeFirst);<br/>      this.computeTicks();<br/><br/>      this.selection = {<br/>        start: this.timeFirst,<br/>        end: this.timeLast<br/>      };<br/>      this.outSelectionChange.next(this.selection);<br/>    }<br/>  }<br/><br/>  computeTicks() {<br/>    const count = 5;<br/>    const timeSpanTick = this.timeSpan / count;<br/>    this.ticks = Array.from({length: count}).map((element, index) =&gt; {<br/>      return this.timeFirst + timeSpanTick * index;<br/>    });<br/>  }<br/><br/>  totalWidth() {<br/>    return this.elementRef.nativeElement.clientWidth - this.padding * 2;<br/>  }<br/><br/>  projectTime(time: number) {<br/>    const position = this.padding +<br/>      (time - this.timeFirst) / this.timeSpan * this.totalWidth();<br/>    return position / this.elementRef.nativeElement.clientWidth * 100;<br/>  }<br/><br/>  projectLength(length: number) {<br/>    return this.timeFirst + (length - this.padding) / this.totalWidth() * this.timeSpan;<br/>  }<br/><br/><strong>  @HostListener('mousedown', ['$event'])</strong><br/><strong>  onMouseDown(event) {</strong><br/><strong>    this.selection.start = this.selection.end = this.projectLength(event.offsetX);</strong><br/><strong>    this.outSelectionChange.next(this.selection);</strong><br/><strong>    this.modifySelection = true;</strong><br/><strong>    event.stopPropagation();</strong><br/><strong>    event.preventDefault();</strong><br/><strong>  }</strong><br/><br/><strong>  @HostListener('mousemove', ['$event'])</strong><br/><strong>  onMouseMove(event) {</strong><br/><strong>    if (this.modifySelection) {</strong><br/><strong>      this.selection.end = Math.max(this.selection.start, this.projectLength(event.offsetX));</strong><br/><strong>      this.outSelectionChange.next(this.selection);</strong><br/><strong>      event.stopPropagation();</strong><br/><strong>      event.preventDefault();</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/><br/><strong>  @HostListener('mouseup')</strong><br/><strong>  onMouseUp() {</strong><br/><strong>    this.modifySelection = false;</strong><br/><strong>  }</strong><br/><br/><strong>  @HostListener('mouseleave')</strong><br/><strong>  onMouseLeave() {</strong><br/><strong>    this.modifySelection = false;</strong><br/><strong>  }</strong><br/>}</pre>
<p>In the preceding code excerpt, we handled a total of four events on the slider host element:</p>
<ul>
<li><kbd>onMouseDown</kbd>: We set our selection model's <kbd>start</kbd> and <kbd>end</kbd> properties with the same value. Since we're using timestamps for these properties, we projected the mouse position into the timespace first. The mouse position comes in pixels, relative to the slider component's origin. Since we know the slider's width and the total time duration displayed, we can easily convert this into timestamps. We're using the <kbd>projectLength</kbd> method for this purpose. By passing a second argument to the <kbd>@HostListener</kbd> decorator, we specified that we'd like to pass the DOM event to our <kbd>onMouseDown</kbd> method. We also set a state flag, <kbd>modifySelection</kbd>, in our component, to indicate that a selection is in progress.</li>
<li><kbd>onMouseMove</kbd>: If the component is in selection mode (the <kbd>modifySelection</kbd> flag is <kbd>true</kbd>), you can adjust the end property of the <kbd>selection</kbd> object. Here, we also made sure that we ruled out the possibility of creating a negative selection, by using <kbd>Math.max</kbd> and limiting the end of the selection to not be smaller than the start.</li>
<li><kbd>onMouseUp</kbd>: When the user releases the mouse button, the component exits the selection mode. This can be done by setting the <kbd>modifySelection</kbd> flag to <kbd>false</kbd>.</li>
<li><kbd>onMouseLeave</kbd>: This is the same as the <kbd>onMouseUp</kbd> event; the difference is that here, the component will just exit the selection mode.</li>
</ul>
<p>Using the <kbd>@HostListener</kbd> decorator, we were able to handle all of the necessary user input to complete our component with the interactive elements that were still missing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>In this topic, we learned how to use SVG in order to create graphical and interactive components with Angular. By creating attribute bindings on our SVG elements and controlling the instantiation of graphical elements using the <kbd>ngFor</kbd> and <kbd>ngIf</kbd> directives, we built a custom slider component that provides a nice overview of our activities. At the same time, we also learned how to handle user input using the <kbd>@HostListener</kbd> decorator, in order to make our component interactive:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6441d4ab-9f66-4b56-b90f-af09ac9bc02d.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A screenshot of the finished activity slider component</div>
<p>To sum things up, we learned about the following concepts:</p>
<ul>
<li>Encapsulating component views using <kbd>ViewEncapsulation.Native</kbd> and importing local styles</li>
<li>Covering some basic projections of timestamps onto screen coordinates, to be used with SVG elements</li>
<li>Handling user input and creating a custom selection mechanism using the <kbd>@HostListener</kbd> decorator</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the activity timeline</h1>
                </header>
            
            <article>
                
<p>So far, we've built a service to log activities and a slider component to select a time range and provide an overview using activity indicators. Since we needed to perform a lot of drawing tasks within the slider component, SVG was a perfect fit for this use case. To complete our activities component tree, we still need to render the activities that were selected using the activity slider component.</p>
<p>Let's continue to work on our activities component tree. We will create a new component that is responsible for rendering an individual activity within an activity timeline. Let's use the Angular CLI to create our activity component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush activities/activity</strong></pre>
<p>Now, let's start with the component template. Open the file <kbd>src/app/activities/activity/activity.component.html</kbd>, and add the following code:</p>
<pre>&lt;img [attr.src]="activity.user.pictureUrl"<br/>     [attr.alt]="activity.user.name"<br/>     class="user-image"&gt;<br/>&lt;div class="info" [class.info-align-right]="isAlignedRight()"&gt;<br/>  &lt;h3 class="title"&gt;{{activity.title}}&lt;/h3&gt;<br/>  &lt;p class="author"&gt;by {{activity.user.name}} {{activity.time | fromNow}}&lt;/p&gt;<br/>  &lt;p&gt;{{activity.message}}&lt;/p&gt;<br/>&lt;/div&gt;</pre>
<p>Each activity will consist of a user image, as well as an information box that will contain the activity title, message, and authoring details.</p>
<p>Our activity will use an input to determine its alignment. This allows us to align the activity from outside of the component. The <kbd>isAlignedRight</kbd> method helps us set an additional CSS class, <kbd>info-align-right</kbd>, on the activity information box.</p>
<p>Let's create our component class within the file <kbd>src/app/activities/activity/activity.component.ts</kbd>:</p>
<pre>import {Component, Input, HostBinding, ChangeDetectionStrategy} from '@angular/core';<br/>import {Activity, ActivityAlignment} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity',<br/>  templateUrl: './activity.component.html',<br/>  styleUrls: ['./activity.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ActivityComponent {<br/>  @Input() activity: Activity;<br/>  @Input() alignment: ActivityAlignment;<br/>  @Input() @HostBinding('class.start-mark') startMark;<br/>  @Input() @HostBinding('class.end-mark') endMark;<br/><br/>  isAlignedRight() {<br/>    return this.alignment === 'right';<br/>  }<br/>}</pre>
<p>Our activity component expects four inputs:</p>
<ul>
<li><kbd>activity</kbd>: This property takes the data model of the activity that needs to be rendered with the component. This is the activity that we created using the activity service.</li>
<li><kbd>alignment</kbd>: This input property should be set to a string containing the word <kbd>left</kbd> or <kbd>right</kbd>. We used this to determine whether we needed to add an additional CSS class to our template, in order to align the activity information box to the right.</li>
<li><kbd>startMark</kbd>: This input property acts as an input and a host binding at the same time. If this input is set to <kbd>true</kbd>, the activity will get an additional CSS class, <kbd>start-mark</kbd>, which will cause a small mark on top of the timeline, to indicate the timeline termination.</li>
<li><kbd>endMark</kbd>: In the same way as <kbd>startMark</kbd>, this input uses a host binding to set an additional CSS class, <kbd>end-mark</kbd>, which will cause a small mark on the bottom of the timeline, to indicate the timeline termination.</li>
</ul>
<p>The <kbd>isAlignedRight</kbd> method is used within the template, to determine whether we need to add an additional CSS class to the information box, in order to align it to the right.</p>
<p>We formatted the timestamp of the activity using the <kbd>FromNow</kbd> pipe, which we created in <a href="1682edec-f2b3-4b02-afd8-ed7ef586b712.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Thinking in Projects</em>.</p>
<p>We now have almost all of the components to display our activities. Still, there's something missing, which is the glue to combine the activity slider with our activity components. For this, we'll create a new component, called <kbd>activities</kbd>:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush activities/activities</strong></pre>
<p>After the Angular CLI has generated the component files, let's open the component class in <kbd>src/app/activities/activities/activities.component.ts</kbd>, and add the following code:</p>
<pre>import {Component, Input, ChangeDetectionStrategy, EventEmitter, Output} from '@angular/core';<br/>import {Activity, ActivitySliderSelection} from '../model';<br/><br/>@Component({<br/>  selector: 'mac-activities',<br/>  templateUrl: './activities.component.html',<br/>  styleUrls: ['./activities.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ActivitiesComponent {<br/>  @Input() activities: Activity[];<br/>  @Input() selectedActivities: Activity[];<br/>  @Output() outSelectionChange = new EventEmitter&lt;ActivitySliderSelection&gt;();<br/><br/>  selectionChange(selection: ActivitySliderSelection) {<br/>    this.outSelectionChange.emit(selection);<br/>  }<br/>}</pre>
<p>Since this component will just act as a compositional component for arranging the slider and rendering all activities, we don't have a lot of logic in it. This is a pure component, and it relies on a parent container component to determine which of the activities should be displayed/selected. We're also re-emitting the <kbd>outSelectionChange</kbd> event originated at the activity slider.</p>
<p>Let's also take a look at the template located in <kbd><span>src/app/activities/activities/activities.component.ts</span></kbd>:</p>
<pre>&lt;mac-activity-slider [activities]="activities"<br/>                     (outSelectionChange)="selectionChange($event)"&gt;<br/>&lt;/mac-activity-slider&gt;<br/>&lt;div class="l-container"&gt;<br/>  &lt;mac-activity *ngFor="let activity of selectedActivities, let odd = odd; let first = first; let last =  <br/>                        last"<br/>                [activity]="activity"<br/>                [alignment]="odd ? 'left' : 'right'"<br/>                [startMark]="first"<br/>                [endMark]="last"&gt;<br/>  &lt;/mac-activity&gt;<br/>&lt;/div&gt;</pre>
<p>Again, that's just simple composition. We're rendering our activity slider, and we use the <kbd>ngFor</kbd> directive to render our activity timeline. With the help of the local view variables <kbd>odd</kbd>, <kbd>first</kbd>, and <kbd>last</kbd>, we can set all of the necessary formatting inputs required on our activity component.</p>
<p>Alright! We are almost there. We have all of our activity UI components ready. However, we still need to create a container component for our activities and add the necessary route configuration, so that the user can navigate to the project activities tab.</p>
<p>Let's use the Angular CLI tool again, to create the files for our activities container component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush container/project-activities-container</strong></pre>
<p>Open the component class file located in <kbd>src/app/container/project-activities-container/project-activities-container.component.ts</kbd>, and apply the following code:</p>
<pre>import {Component, ViewEncapsulation, ChangeDetectionStrategy} from '@angular/core';<br/>import {ProjectService} from '../../project/project.service';<br/>import {Observable, combineLatest, BehaviorSubject} from 'rxjs';<br/>import {Activity, ActivitySliderSelection} from '../../model';<br/>import {map} from 'rxjs/operators';<br/>import {ActivatedRoute} from '@angular/router';<br/>import {ActivitiesService} from '../../activities/activities.service';<br/><br/>@Component({<br/>  selector: 'mac-project-activities-container',<br/>  templateUrl: './project-activities-container.component.html',<br/>  styleUrls: ['./project-activities-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectActivitiesContainerComponent {<br/>  activities: Observable&lt;Activity[]&gt;;<br/>  selection = new BehaviorSubject&lt;ActivitySliderSelection | null&gt;(null);<br/>  selectedActivities: Observable&lt;Activity[]&gt;;<br/><br/>  constructor(private projectService: ProjectService,<br/>              private activitiesService: ActivitiesService,<br/>              private route: ActivatedRoute) {<br/>    this.activities = combineLatest(<br/>      this.activitiesService.getActivities(),<br/>      route.parent.params<br/>    ).pipe(<br/>      map(([activities, routeParams]) =&gt;<br/>        activities<br/>          .filter(activity =&gt; activity.kind === 'project' &amp;&amp;<br/>            activity.projectId === +routeParams.projectId)<br/>      )<br/>    );<br/><br/>    this.selectedActivities = combineLatest(<br/>      this.activities,<br/>      this.selection<br/>    ).pipe(<br/>      map(([activities, selection]) =&gt; {<br/>        if (selection) {<br/>          return activities.filter(<br/>            (activity) =&gt; activity.time &gt;= selection.start &amp;&amp; activity.time &lt;= selection.end<br/>          );<br/>        } else {<br/>          return activities;<br/>        }<br/>      })<br/>    );<br/>  }<br/><br/>  selectionChange(selection: ActivitySliderSelection) {<br/>    this.selection.next(selection);<br/>  }<br/>}</pre>
<p>Although this looks like a lot of code, it should actually look very familiar. Our other container components look almost the same as this. We're accessing the activities observable from our activities service and combining the observable with the parent route parameter to obtain the selected project ID.</p>
<p>What's special about this container is that we're storing a behavior subject, <kbd>selection</kbd>, which is used to emit the latest selection that we receive from our activity slider component. Within the <kbd>selectedActivities</kbd> observable, we're then using this selection together with a mapping function, in order to filter for only the activities that are within the range of our selection.</p>
<p>As is usual with container components, the template for this one is really simple. We're just rendering our activities component and create bindings using the async pipe on our container observables. Open the file <kbd>src/app/container/project-activities-container/project-activities-container.component.html</kbd><span>, and apply the following changes:</span></p>
<pre>&lt;mac-activities [activities]="activities | async"<br/>                [selectedActivities]="selectedActivities | async"<br/>                (outSelectionChange)="selectionChange($event)"&gt;<br/>&lt;/mac-activities&gt;</pre>
<p><span>Okay; that's it for our container. Now, we only need to add our newly created activities container component into the route configuration. Let's open our router configuration file, <kbd>src/app/routes.ts</kbd>, and apply the following changes:</span></p>
<pre>import {Route} from '@angular/router';<br/>import {ProjectContainerComponent} from './container/project-container/project-container.component';<br/>import {TaskListContainerComponent} from './container/task-list-container/task-list-container.component';<br/>import {ProjectCommentsContainerComponent} from './container/project-comments-container/project-comments-container.component';<br/>import {ProjectContainerGuard} from './guards/project-container.guard';<br/><strong>import {ProjectActivitiesContainerComponent} from './container/project-activities-container/project-activities-container.component';</strong><br/><br/>export const routes: Route[] = [{<br/>  path: 'projects/:projectId',<br/>  component: ProjectContainerComponent,<br/>  canActivate: [ProjectContainerGuard],<br/>  children: [{<br/>    path: 'tasks',<br/>    component: TaskListContainerComponent<br/>  }, {<br/>    path: 'comments',<br/>    component: ProjectCommentsContainerComponent<br/>  },<strong> {</strong><br/><strong>    path: 'activities',</strong><br/><strong>    component: ProjectActivitiesContainerComponent</strong><br/><strong>  },</strong> {<br/>    path: '**',<br/>    redirectTo: 'tasks'<br/>  }]<br/>}, {<br/>  path: '',<br/>  pathMatch: 'full',<br/>  redirectTo: '/projects/1'<br/>}];</pre>
<p>That's it for our activities page! We've created three components that are composed together and display an activity stream, which provides a slider to filter activities for dates. Preview your changes in the browser, and you should now be able to navigate to the <span class="packt_screen">ACTIVITIES</span> tab on your projects. Also, try to cause some activities to be logged, by adding new tasks or updating them. Click and drag on the activity slider to change your selections:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bc042898-071e-4c7b-a9e1-d03dfe7ab031.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A screenshot of the finished activities view</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we created an interactive slider component using SVG. While doing this, we learned about some SVG basics and the power of SVG within the DOM. Using Angular, we were able to make SVG composable, which it isn't by nature. We learned about namespaces, how Angular handles them, and how we can tell Angular that we'd like to use namespaces explicitly.</p>
<p>Besides using SVG for our slider component, we also learned how to use Shadow DOM to create native view encapsulation. As a result of this, we were able to use local styles for our component. We don't need to worry about CSS name clashes, specificity, and global CSS side effects when using local styles.</p>
<p>In the next chapter, we're going to enhance what we've built so far. We will create some components to enrich the user experience within our application.</p>


            </article>

            
        </section>
    </body></html>