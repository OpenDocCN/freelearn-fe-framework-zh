- en: Time Will Tell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间会证明一切
- en: Our task-management system is shaping up. However, we have not been concerned
    about one crucial aspect of managing our projects so far. Time plays a major role
    in all projects, and it's probably the aspect that is often the most complicated
    to manage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理系统正在成形。然而，到目前为止，我们还没有关注到管理项目的一个关键方面。时间在所有项目中都起着重要作用，这可能是最复杂的管理方面。
- en: In this chapter, we will add a few features to our task management system that
    will help our users to manage time more efficiently. Reusing some components that
    we created earlier, we will be able to provide a consistent user experience to
    manage time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向我们的任务管理系统添加一些功能，帮助用户更有效地管理时间。通过重用我们之前创建的一些组件，我们将能够提供一致的用户体验来管理时间。
- en: 'On a higher level, we will develop the following features to enable time management
    in our application:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次上，我们将开发以下功能，以在我们的应用程序中实现时间管理：
- en: '**Task details**: So far, we did not include a details page of tasks because
    all the necessary information about tasks could be displayed on the task list
    of our project page. As our time management will increase the complexity of our
    tasks quite a bit, we will create a new detail view of project tasks that will
    also be accessible through routing.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务详情**：到目前为止，我们没有包括任务详情页面，因为所有关于任务的信息都可以在我们的项目页面上的任务列表中显示。由于我们的时间管理将大大增加任务的复杂性，我们将创建一个新的项目任务详情视图，该视图也将通过路由访问。'
- en: '**Efforts management**: We will include some new data on our tasks to manage
    efforts on tasks. Efforts are always represented by an estimated duration of time
    and an effective duration of spent time. We will make both properties of efforts
    optional so that they can exist independently. We will create new components to
    enable users to provide time duration input easily.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**努力管理**：我们将包括一些新的任务数据来管理任务上的努力。努力总是由估计的时间持续和实际花费的时间来表示。我们将使努力的这两个属性都是可选的，以便它们可以独立存在。我们将创建新的组件，使用户能够轻松地提供时间持续时间输入。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a project task detail component to edit task details and enable a new
    route
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个项目任务详情组件来编辑任务详情并启用新的路由
- en: Modifying our tag management system to include task tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改我们的标签管理系统以包括任务标签
- en: Creating new pipes to deal with formatting time durations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的管道来处理格式化时间持续时间
- en: Creating task information components to display task overview information on
    the existing task components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务信息组件，在现有的任务组件上显示任务概述信息
- en: Creating a time duration component that enables users to easily input time durations
    using a no-UI user interaction approach
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个时间持续时间组件，使用户能够通过无UI用户交互方法轻松输入时间持续时间
- en: Implementing time effort tracking on tasks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任务上实施时间努力跟踪
- en: Creating an SVG component to display progress on tasks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 SVG 组件来显示任务进度
- en: Task details
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务详情
- en: So far, our task list was sufficient enough to display all details of tasks
    directly in the listing. However, as we will add more details to tasks in this
    chapter, it's time to provide a detailed view where users can edit the task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的任务列表足以直接在列表中显示所有任务的详细信息。然而，由于在本章中我们将向任务添加更多详细信息，现在是时候提供一个详细视图，让用户可以编辑任务。
- en: We already laid the groundwork for project navigation using the router in [Chapter
    5](237031a7-f616-4811-8486-08b5113d316f.xhtml), *Component-Based Routing*. Adding
    a new routable component that we'll use in the context of our projects will be
    a breeze.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第5章](237031a7-f616-4811-8486-08b5113d316f.xhtml) 中为项目导航打下了基础，*基于组件的路由*。添加一个新路由组件，我们将在项目上下文中使用它，将是一件轻而易举的事情。
- en: Before we start creating a new task details component, let's introduce a new
    state within our task model. Users should have the additional option to provide
    a task description in addition to the task title. This description will be editable
    on the task details view.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建新的任务详情组件之前，让我们在我们的任务模型中引入一个新的状态。用户应该有额外的选项，除了任务标题外，还可以提供任务描述。这个描述将在任务详情视图中可编辑。
- en: 'Let''s open our model file, located in `src/app/model.ts`, and add an optional
    description field to our task interface:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于 `src/app/model.ts` 的模型文件，并给我们的任务接口添加一个可选的描述字段：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Okay, so now we can store a description with each of our tasks. When new tasks
    are created on the task list, however, we will still only store the title of the
    task. A user needs to access the new detail view in order to update the description
    of a task.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以现在我们可以为每个任务存储一个描述。然而，当在任务列表中创建新任务时，我们仍然只会存储任务的标题。用户需要访问新的详情视图来更新任务的描述。
- en: 'Alright, let''s create a new component for our task detail view using the Angular
    CLI:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们使用Angular CLI创建一个用于任务详细视图的新组件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s open the generated component class file in `src/app/tasks/task-details/task-details.component.ts`
    and add the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`src/app/tasks/task-details/task-details.component.ts`中打开生成的组件类文件，并添加以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Within the task details, we're enabling the user to edit both the title and
    description of tasks. We're working on a simple UI component to represent the
    task details view. Therefore, we're expecting the task object to be set as a component
    input. The `outUpdateTask` output is used to communicate task updates to our parent
    component. We've also added two methods to be used within our view in order to
    update the task title and description.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务详情中，我们允许用户编辑任务的标题和描述。我们正在开发一个简单的UI组件来表示任务详情视图。因此，我们期望将任务对象设置为组件输入。`outUpdateTask`输出用于将任务更新通知给我们的父组件。我们还添加了两个方法，用于在我们的视图中更新任务标题和描述。
- en: We'd also like to support tag selection when a user edits the description of
    a task. For this purpose, we're adding a `tags` input, which can be provided by
    the parent component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望支持用户编辑任务描述时的标签选择。为此目的，我们添加了一个`tags`输入，它可以由父组件提供。
- en: 'Alright, let''s now take a look at the template of our component, and see how
    we''ll deal with the task data to provide an interface to edit the details. Open
    the template file located in `src/app/tasks/task-details/task-details.component.html`
    and add the following content:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们看看我们组件的模板，看看我们将如何处理任务数据以提供一个编辑详情的界面。打开位于`src/app/tasks/task-details/task-details.component.html`的模板文件，并添加以下内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By reusing the editor component that we created in [Chapter 4](1682edec-f2b3-4b02-afd8-ed7ef586b712.xhtml),
    *Thinking in Projects*, we can rely on simple UI composition to make the title
    and description of our tasks editable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重用我们在[第4章](1682edec-f2b3-4b02-afd8-ed7ef586b712.xhtml)中创建的编辑器组件，*项目思维*，我们可以依赖简单的UI组合来使我们的任务标题和描述可编辑。
- en: As we stored the task data into the `task` member variable on our component,
    we can reference the `title` and `description` fields to create a binding to the
    `content` input property of our editor components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将任务数据存储到我们组件的`task`成员变量中时，我们可以引用`title`和`description`字段来创建与我们的编辑器组件的`content`输入属性的绑定。
- en: While the title should only consist of plaintext, we can support the tagging
    functionality that we created in [Chapter 7](70aeeb16-2a1e-4d20-b523-00df06a8398a.xhtml),
    *Components for User Experience*, on the description field of the task. For this,
    we simply pass the list of available tags into the editor component.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标题应该只包含纯文本，但我们可以支持在任务的描述字段中我们创建的[第7章](70aeeb16-2a1e-4d20-b523-00df06a8398a.xhtml)中，*用户体验组件*的标签功能。为此，我们只需将可用标签的列表传递给编辑器组件。
- en: We are using the editor components' `outSaveEdit` output property to call our
    update functions for updating the title or description, respectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用编辑器组件的`outSaveEdit`输出属性来调用我们的更新函数，分别用于更新标题或描述。
- en: So far, so good. We created a task details component that makes it easy to edit
    the title and description of tasks using our editor UI component. Now, we need
    to create a container component for our task details view and enable it as a child
    route within our application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们创建了一个任务详情组件，使用我们的编辑器UI组件可以轻松地编辑任务的标题和描述。现在，我们需要创建一个任务详情视图的容器组件，并在我们的应用程序中将其启用为子路由。
- en: 'Let''s use the Angular CLI to create a task details container component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Angular CLI创建一个任务详情容器组件：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As always, the view of our container components is dead simple. We''re simply
    rendering a UI component and passing down the required data. Let''s do that by
    editing the template of our task details container component, which is located
    in `src/app/container/task-details-container/task-details-container.component.html`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们容器组件的视图非常简单。我们只是渲染一个UI组件并传递所需的数据。让我们通过编辑位于`src/app/container/task-details-container/task-details-container.component.html`的任务详情容器组件的模板来实现这一点：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The task details UI component required a task object to be passed as input
    as well as the list of tags supported by our application. We''ll obtain this data
    using the observables provided from the respective services. When a task is updated
    we''ll receive the `outUpdateTask` output event and call a method `updateTask`
    on our container component. Let''s open the component class located in `src/app/container/task-details-container/task-details-container.component.ts`
    and add the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任务详情UI组件需要传递一个任务对象作为输入，以及我们应用程序支持的标签列表。我们将使用从相应服务提供的可观察对象获取这些数据。当任务更新时，我们将收到`outUpdateTask`输出事件，并在我们的容器组件上调用`updateTask`方法。让我们打开位于`src/app/container/task-details-container/task-details-container.component.ts`的组件类，并添加以下代码：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's nothing new here. We're using a route parameter called `taskId` to obtain
    a specific task from the task list coming from our task service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新内容。我们正在使用一个名为`taskId`的路由参数来从我们的任务服务中获取特定的任务。
- en: 'The only thing left to enable our new task details view is to create a child
    route within our route configuration. Let''s open our route configuration, located
    in `src/app/routes.ts`, to make the necessary modifications:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用我们的新任务详情视图，我们只需在路由配置中创建一个子路由。让我们打开位于`src/app/routes.ts`的路由配置，进行必要的修改：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We added a new child route on our project view, which is now accessible with
    the URL `/projects/:projectId/tasks/:taskId`. By including the parameter `:taskId`
    in the route configuration, we can pass the concerned task ID into the task details
    container component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的项目视图中添加了一个新的子路由，现在可以通过URL `/projects/:projectId/tasks/:taskId`访问。通过在路由配置中包含参数`:taskId`，我们可以将相关的任务ID传递给任务详情容器组件。
- en: 'Fantastic! We''ve created a new task details view and enabled it within our
    router. You can preview your changes within the browser and access the details
    view of a task by entering the following URL into your browser: `http://localhost:4200/projects/1/tasks/1`.
    You should now see the details view of the first task within our first project.
    Try editing the title and description before we move on with the integration of
    our task details view.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经创建了一个新的任务详情视图，并在我们的路由器中启用了它。您可以在浏览器中预览您的更改，并通过在浏览器中输入以下URL来访问任务的详情视图：`http://localhost:4200/projects/1/tasks/1`。现在您应该可以看到我们第一个项目中的第一个任务的详情视图。在我们继续集成任务详情视图之前，尝试编辑标题和描述。
- en: Navigating to task details
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到任务详情
- en: 'In order to make our task details route navigable, we need to modify our task
    component within the task list. We would like to add a small button to our task
    component that will navigate to the details view. Let''s start with the template
    changes; open our task component template, located in `src/app/tasks/task/task.component.html`,
    and apply the following changes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的任务详情路由可导航，我们需要修改任务列表中的任务组件。我们希望在任务组件中添加一个小的按钮，以便导航到详情视图。让我们从模板更改开始；打开我们的任务组件模板，位于`src/app/tasks/task/task.component.html`，并应用以下更改：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s move right into our component class and implement the new `showDetails`
    method. Open the file `src/app/tasks/task/task.component.html` and apply the following
    changes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入组件类并实现新的`showDetails`方法。打开文件`src/app/tasks/task/task.component.html`并应用以下更改：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Alright, now we need to make sure that we're carrying the event to show task
    details all the way up to the task list container component. Our next step is
    the task list UI component, where we need to delegate the `outShowDetails` output
    of our task component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们需要确保将显示任务详情的事件一路传递到任务列表容器组件。我们的下一步是任务列表UI组件，我们需要委派我们的任务组件的`outShowDetails`输出。
- en: 'Let''s start with the template changes in `src/app/tasks/task-list/task-list.component.html`
    and apply the following change:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`src/app/tasks/task-list/task-list.component.html`中的模板更改开始，并应用以下更改：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That was easy! Now, let''s add the changes to the task list component class
    located in `src/app/tasks/task-list/task-list.component.ts`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！现在，让我们将更改添加到位于`src/app/tasks/task-list/task-list.component.ts`的任务列表组件类中：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Great, the next stop in our component tree is the task list container, which
    is where we''ll implement the logic to navigate to the details view. Let''s open
    the template of the task list container, located in `src/app/container/task-list-container/task-list-container.component.html`,
    and create the necessary binding:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们组件树中的下一个停靠点是任务列表容器，我们将在这里实现导航到详情视图的逻辑。让我们打开位于`src/app/container/task-list-container/task-list-container.component.html`的任务列表容器模板，并创建必要的绑定：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we need to implement the `showDetails` method within the container
    component class located in `src/app/container/task-list-container/task-list-container.component.ts`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在位于 `src/app/container/task-list-container/task-list-container.component.ts`
    的容器组件类中实现 `showDetails` 方法：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Hurray! We have finally made our task details view navigable using a new navigation
    button on our task component!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼！我们终于通过在任务组件上添加一个新的导航按钮使任务详情视图可导航了！
- en: Now, you might ask yourself, why have we implemented such a crazy output delegation
    path, just to trigger a navigation? Wouldn't it be much easier to just use a `routerLink`
    directive within the task UI component and be done?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道，为什么我们要实现这样一个疯狂的输出委托路径，只是为了触发导航？直接在任务 UI 组件中使用 `routerLink` 指令不是更容易吗？
- en: 'Of course, that would be much easier. However, there''s a slight problem with
    using router links within simple UI components. By doing so, we rely on a specific
    route configuration being present in our system. Using router links directly within
    UI components restricts them to a very specific context. We''d like to avoid this,
    so we can reuse our components in many different contexts. The only meaningful
    way to solve this issue is to use output delegation and control your navigation
    within container components programmatically:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，那会更容易。然而，在简单 UI 组件中使用路由链接存在一个小问题。这样做，我们依赖于系统中存在特定的路由配置。在 UI 组件中直接使用路由链接将它们限制在一个非常特定的上下文中。我们希望避免这种情况，以便在不同的上下文中重用我们的组件。解决这个问题的唯一有意义的方法是使用输出委托，并在容器组件中程序化地控制导航：
- en: '![](img/5de1ef3b-662b-4706-b963-ca0504b9dc22.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5de1ef3b-662b-4706-b963-ca0504b9dc22.png)'
- en: Newly created task detail view with editable title and description
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的任务详情视图，具有可编辑的标题和描述
- en: Enabling tags for tasks
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为任务启用标签
- en: So far, the tag-management system that we created in [Chapter 7](70aeeb16-2a1e-4d20-b523-00df06a8398a.xhtml),
    *Components for User Experience*, only supports project tags. As we have now created
    a detail view for tasks, it would be nice to also support task tags directly in
    our tagging system. Our tagging system is quite flexible, and we can implement
    new tags with very little effort.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在第 7 章 [70aeeb16-2a1e-4d20-b523-00df06a8398a.xhtml]，*用户体验组件* 中创建的标签管理系统仅支持项目标签。既然我们已经为任务创建了一个详情视图，那么在标签系统中直接支持任务标签也会很棒。我们的标签系统非常灵活，我们可以以非常少的努力实现新的标签。
- en: 'Let''s modify our tags service, located in `src/app/tags/tags.service.ts`,
    in order to enable tags for our tasks:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改位于 `src/app/tags/tags.service.ts` 的标签服务，以便为我们的任务启用标签：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In addition to the project service, we're also injecting the task service within
    the constructor of our tags service. Very similar to what we already do for projects,
    we need to create a tag object for every single task within our application. We're
    using the observable provided by the task service and use the `map` operator to
    convert all tasks to tags.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了项目服务外，我们还在标签服务的构造函数中注入了任务服务。这与我们为项目所做的工作非常相似，我们需要为应用中的每个任务创建一个标签对象。我们使用任务服务提供的可观察对象，并使用
    `map` 操作符将所有任务转换为标签。
- en: Finally, we're using the `combineLatest` observable helper to merge both project
    tags and task tags into a single observable stream. Within a final map operator,
    we're concatenating those two tag lists into a single array.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `combineLatest` 可观察对象辅助工具将项目标签和任务标签合并为单个可观察流。在最终的 `map` 操作符中，我们将这两个标签列表连接成一个数组。
- en: 'This wasn''t too complicated, right? This relatively simple change results
    in a huge improvement for our users. They can now reference individual tasks everywhere
    in our system where we have enabled tags. By clicking a task tag, we are navigating
    to our newly created task details view:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不复杂，对吧？这个相对简单的更改为我们用户带来了巨大的改进。现在，他们可以在我们系统中任何启用了标签的地方引用单个任务。通过点击任务标签，我们正在导航到我们新创建的任务详情视图：
- en: '![](img/eecd6862-a29c-4085-a312-6bba0a1ea149.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eecd6862-a29c-4085-a312-6bba0a1ea149.png)'
- en: The editor component of the project comments tab displaying the newly added
    task tags
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 项目评论标签页的编辑组件显示新添加的任务标签
- en: Managing efforts
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理努力
- en: In this section, we will create some components that help us keep track of work
    efforts. Primarily, we will use this to manage efforts on tasks, but this could
    be applied to any part of our application where we need to keep track of time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一些组件，帮助我们跟踪工作努力。主要，我们将使用这些组件来管理任务上的努力，但这也可以应用于我们应用中需要跟踪时间的任何部分。
- en: 'Efforts in our context always consist of two things:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的语境中，努力总是包括两个方面：
- en: '**Estimated duration**: This is the duration that is initially estimated for
    the task'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Estimated duration**：这是任务最初估计的持续时间'
- en: '**Effective duration**: This is the duration of time that is spent on a given
    task'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Effective duration**：这是在给定任务上花费的时间长度'
- en: 'For time durations, we assume some time units and rules that will simplify
    the processing of time and align to some working standards. The goal here is not
    to provide razor sharp time management but something that is accurate enough to
    bring value. For this purpose, we define the following working time units:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间持续时间，我们假设一些时间单位和规则，这将简化时间的处理并符合某些工作标准。这里的目的是不提供锐利的时管理，而是提供足够准确以带来价值的东西。为此，我们定义以下工作时间单位：
- en: '**Minute**: One minute is a regular 60 seconds'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Minute**：一分钟是常规的60秒'
- en: '**Hour**: One hour always represents 60 minutes'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hour**：一小时总是代表60分钟'
- en: '**Day**: One day represents a regular workday of eight hours'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Day**：一天代表八小时的常规工作日'
- en: '**Week**: One week is equivalent to five working days (5 * 8 hours)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Week**：一周相当于五个工作日（5 * 8小时）'
- en: 'When working with durations and efforts we would like to have some type safety,
    and for this reason, we''re introducing a few new interfaces to our model. Let''s
    open our model, located in `src/app/model.ts`, and add the following two interfaces:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理持续时间时，我们希望有一些类型安全，因此我们向我们的模型引入了一些新的接口。让我们打开位于`src/app/model.ts`的模型，并添加以下两个接口：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `short` property on the `TimeUnit` interface will be used to recognize time
    entry by the user. We will use the letters m, h, d, and w for the different time
    units and store how many milliseconds each time frame contains.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeUnit`接口上的`short`属性将用于识别用户的时间输入。我们将使用字母m、h、d和w来表示不同的时间单位，并存储每个时间框架包含的毫秒数。'
- en: 'Since we''d like to keep track of the time and efforts spent on tasks, let''s
    also modify our task model. Find the `Task` interface within our model file and
    add the following property:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望跟踪在任务上花费的时间和精力，让我们也修改一下我们的任务模型。在我们的模型文件中找到`Task`接口，并添加以下属性：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have added a new optional `efforts` property to our task interface, which
    is storing the efforts spent working on our tasks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的任务接口中添加了一个新的可选的`efforts`属性，用于存储在任务上花费的精力。
- en: Alright, we have prepared our model for the upcoming time tracking features.
    In the next section, we're going to implement our first UI component to enter
    time durations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经为即将到来的时间跟踪功能准备好了我们的模型。在下一节中，我们将实现我们的第一个UI组件来输入时间持续时间。
- en: No-UI time duration input
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无UI时间持续时间输入
- en: We could now start to write a complex user interface component, where users
    can enter individual time units in different input elements. However, I believe
    it's much more convenient to treat time duration input with a no-UI approach.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写一个复杂的用户界面组件，用户可以在不同的输入元素中输入单独的时间单位。然而，我相信用无UI方法处理时间持续时间输入会更加方便。
- en: Put very simply, no-UI means that we use regular text input to provide user
    interactions. Well, that's nothing new right? Text input is where it all started.
    However, there's a significant trend in providing no-UI interactions lately. By
    combining intelligence in how we process the text input of users, no-UI interactions
    can actually be surprisingly efficient, and outperform complex user interfaces
    by far.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，无UI意味着我们使用常规文本输入来提供用户交互。嗯，这没什么新奇的？文本输入是一切开始的地方。然而，最近有一个显著的趋势是提供无UI交互。通过结合我们对用户文本输入的处理智能，无UI交互实际上可以非常高效，并且远远超过复杂的用户界面。
- en: Instead of building a complex user interface to enter time duration, we can
    simply agree on a textual short form to write durations. We can let the user write
    something, such as `1.5d` or `5h 30m`, in order to provide input. Sticking to
    the convention that we established at the beginning of this section, *Managing
    Efforts*, we can build a simple parser that can handle this sort of input.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是构建一个复杂的用户界面来输入时间持续时间，我们可以简单地约定一个文本简写形式来编写持续时间。我们可以让用户输入一些内容，例如`1.5d`或`5h
    30m`，以提供输入。按照我们在本节开头建立的约定，*管理精力*，我们可以构建一个简单的解析器来处理这种输入。
- en: This approach has several advantages. Besides that, this is one of the most
    efficient ways to enter time durations, and it's also easy for us to implement.
    We can simply reuse our editor component to gather text input from the user. Then,
    we use a conversion process to parse the entered time duration.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个优点。除了这些，这也是输入时间长度最有效的方法之一，并且也易于我们实现。我们可以简单地重用我们的编辑器组件来从用户那里收集文本输入。然后，我们使用转换过程来解析输入的时间长度。
- en: Let's spin up a new utility module that helps us deal with these conversions.
    Let's start by creating a new empty file on the path `src/app/utilities/time-utilities.ts`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个新的实用模块，帮助我们处理这些转换。让我们首先在路径`src/app/utilities/time-utilities.ts`上创建一个新的空文件。
- en: 'First, we need to have a constant that defines all the units we need for the
    conversion process. Add this first code excerpt to our newly created file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个常量来定义我们转换过程中需要的所有单位。将以下代码片段添加到我们新创建的文件中：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We make use of the `TimeUnit` interface which we've created in our model.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们在模型中创建的`TimeUnit`接口。
- en: These are all the units that we need to deal with for now. You can see the milliseconds
    being calculated at run-time. We can also write the milliseconds as number literals,
    but calculating them in place provides us with some transparency on how we get
    to these values and we can spear on some comments.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们目前需要处理的全部单位。您可以看到运行时计算的毫秒数。我们也可以将毫秒数写成数字字面量，但就地计算它们可以让我们更清晰地了解我们如何得到这些值，并且我们可以添加一些注释。
- en: 'Let''s look at our parsing function, which we can use to parse text input into
    time durations. Append the following code to our file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的解析函数，我们可以用它将文本输入解析成时间长度。将以下代码添加到我们的文件中：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s analyze the preceding code briefly to explain what we do here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要分析一下前面的代码，解释我们在这里做了什么：
- en: First, we define a regular expression that helps us dissect the text representation
    of a duration. This pattern will extract chunks from the text input that are important
    to calculate the duration behind the text representation. These chunks always
    consist of a number, followed by either `w`, `d`, `h`, or `m`. Therefore, the
    text `10w 3d 2h 30m` will be split into the chunks `10w`, `3d`, `2h`, and `30m`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个正则表达式，帮助我们分解时间长度的文本表示。这个模式将提取文本输入中的重要部分，以计算文本表示背后的时间长度。这些块总是由一个数字，后跟`w`、`d`、`h`或`m`组成。因此，文本`10w
    3d 2h 30m`将被分割成`10w`、`3d`、`2h`和`30m`这些块。
- en: We initialize a `timeSpan` variable with `0`, so we can add all the milliseconds
    from discovered chunks together and later return this sum.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`0`初始化`timeSpan`变量，这样我们可以将发现的块中的所有毫秒数加在一起，然后稍后返回这个总和。
- en: For each of the previously-extracted chunks, we now extract the number component
    into a variable called `amount`, and the unit (`w`, `d`, `h`, or `m`) into a variable
    called `unitShortName`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于之前提取的每个块，我们现在将数字组件提取到一个名为`amount`的变量中，将单位（`w`、`d`、`h`或`m`）提取到一个名为`unitShortName`的变量中。
- en: Now, we can look up the data in the `UNITS` constant for the unit of the chunk
    that we will process, multiply the amount of milliseconds of the unit by the amount
    we extract from the chunk, and then add that result to our `timeSpan` variable.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以查找`UNITS`常量中我们将要处理的块的单位，将单位毫秒数乘以我们从块中提取的数量，然后将这个结果添加到我们的`timeSpan`变量中。
- en: 'Well, this is quite a neat function we have built here. It accepts a formatted
    time duration string and converts it into milliseconds. This is already half of
    what we need to deal with the textual representation of time durations. The second
    piece is the opposite of what just built. We need a function to convert a duration
    in milliseconds into a formatted duration string. Let''s append another piece
    of code to our file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是我们在这里构建的一个相当整洁的函数。它接受一个格式化的时间长度字符串，并将其转换为毫秒。这已经是我们需要处理时间长度文本表示的一半了。第二部分是刚刚构建内容的相反。我们需要一个函数将毫秒数的时间长度转换为格式化的时间长度字符串。让我们将另一段代码添加到我们的文件中：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s also explain briefly what the `formatDuration` function does:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也简要解释一下`formatDuration`函数做了什么：
- en: We use the `Array.prototype.reduce` function to format a string that contains
    all time units and their amount. We iterate over all available time units in the
    `UNITS` constant, starting with the largest unit for weeks.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`Array.prototype.reduce`函数来格式化一个包含所有时间单位和它们数量的字符串。我们遍历`UNITS`常量中所有可用的单位，从最大的单位“周”开始。
- en: We then divide the `timeSpan` variable, which is in milliseconds, by the milliseconds
    of the unit, which gives us the amount of the given unit.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们然后将 `timeSpan` 变量（以毫秒为单位）除以单位的毫秒数，得到给定单位的金额。
- en: If the amount is greater than or equal to 1, we can add the unit with the given
    amount and unit short name to our formatted string.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果金额大于或等于 1，我们可以将给定金额和单位简称添加到我们的格式化字符串中。
- en: As we could be left with some fractions after the comma in the amount, which
    we will need to encode in smaller units, we subtract the floored version of our
    amount from the `timeSpan` before we return to the `reduce` function again.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于金额的小数部分可能留下一些分数，这些分数我们需要编码成更小的单位，我们在返回到 `reduce` 函数之前，从 `timeSpan` 中减去金额的向下取整版本。
- en: This process is repeated for every unit, where each unit will only provide a
    formatted output if the amount is greater than or equal to 1.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个过程会为每个单元重复，其中每个单元只有在金额大于或等于 1 时才会提供格式化的输出。
- en: This is all we need to convert back and forth between formatted time duration
    and time duration represented in milliseconds.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的，可以在格式化的时间长度和以毫秒表示的时间长度之间相互转换。
- en: 'We''ll do one more thing before we create the actual component to enter time
    durations. We will create a simple pipe that basically just wraps our `formatTime`
    function. For this, we will create a new pipe using the Angular CLI:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建实际组件以输入时间长度之前，我们还将做一件事。我们将创建一个简单的管道，它基本上只是包装我们的 `formatTime` 函数。为此，我们将使用
    Angular CLI 创建一个新的管道：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s open the generated file `src/app/pipes/format-duration.pipe.ts` and
    add the following content:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开生成的文件 `src/app/pipes/format-duration.pipe.ts` 并添加以下内容：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the `formatTime` function of our new time utility module, we now have
    the ability to format durations in milliseconds directly in our component templates.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新时间实用模块的 `formatTime` 函数，我们现在能够在组件模板中直接格式化时间长度（毫秒）。
- en: Components to manage efforts
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理努力的组件
- en: Okay, this is enough time-math for the moment. Let's now use the elements that
    we've created to shape some components that will help us gather user input.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，目前的时间数学就到这里。现在让我们使用我们创建的元素来构建一些组件，这些组件将帮助我们收集用户输入。
- en: 'In this section, we will create two components to manage efforts:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建两个组件来管理努力：
- en: '**Duration component**: The duration component is a simple UI component, enabling
    user input of time durations using the formatted time strings we dealt with in
    the previous topics. It uses an editor component to enable user input and makes
    use of the time formatting pipe as well as the `parseDuration` utility function.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Duration 组件**：Duration 组件是一个简单的 UI 组件，它使用我们在前一个主题中处理过的格式化时间字符串，允许用户输入时间长度。它使用编辑器组件来启用用户输入，并使用时间格式化管道以及
    `parseDuration` 实用函数。'
- en: '**Efforts component**:The efforts component is just a composition of two duration
    components that represent the estimated effort and the effective effort spent
    on a given task. Following a strict rule of composition, this component is important
    for us so that we don''t repeat ourselves and instead compose a larger component.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Efforts 组件**：Efforts 组件只是两个表示估计努力和实际在给定任务上花费的努力的持续时间组件的组合。遵循严格的组合规则，这个组件对我们来说很重要，这样我们就不需要重复自己，而是组合一个更大的组件。'
- en: 'Let''s start with the duration component and use the Angular CLI to scaffold
    our initial component structure:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从时间组件开始，并使用 Angular CLI 来构建我们的初始组件结构：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alright, let''s now open the component class located in `src/app/ui/duration/duration.component.ts`
    and apply the following changes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们打开位于 `src/app/ui/duration/duration.component.ts` 的组件类，并应用以下更改：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's nothing fancy about this component really, because we created the bulk
    of the logic already and we simply compose a higher component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这个组件并没有什么特别之处，因为我们已经创建了大部分逻辑，我们只是组合了一个高级组件。
- en: For the `duration` input, we expect a time duration in milliseconds, while the
    `outDurationChange` output property will emit the updated duration in milliseconds
    when the user provides some input.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `duration` 输入，我们期望以毫秒为单位的时间长度，而 `outDurationChange` 输出属性将在用户输入一些内容时发出更新后的时间长度（毫秒）。
- en: The `editSaved` method serves in the binding to the underlying editor component.
    Whenever the user saves his edits on the editor component, we'll take this input,
    convert the formatted time duration into milliseconds using the `parseDuration`
    function, and re-emit the converted value using the `outDurationChange` output
    property.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`editSaved` 方法用于绑定到底层的编辑组件。每当用户在编辑组件上保存他的编辑时，我们将这个输入，使用 `parseDuration` 函数将格式化的时间持续时间转换为毫秒，并使用
    `outDurationChange` 输出属性重新发射转换后的值。'
- en: 'Let''s look at the template of our component in `src/app/ui/duration/duration.component.ts`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的组件模板 `src/app/ui/duration/duration.component.ts`：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Surprised with how simple our template is? Well, this is exactly what we should
    achieve with higher order components, once we establish a good foundation of base
    components. Well-organized composition radically simplifies our code. The only
    thing that we deal with here is our good old editor component.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们模板的简单性感到惊讶吗？嗯，这正是我们通过建立良好的基础组件，使用高阶组件应该达到的效果。良好的组织结构极大地简化了我们的代码。我们在这里处理的就是我们那熟悉的编辑组件。
- en: We bind the `duration` input property of our duration component to the `content`
    input property of the editor component. As we'd like to pass the formatted time
    duration and not the duration in milliseconds, we use the `formatDuration` pipe
    to convert within the binding expression.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的持续时间组件的 `duration` 输入属性绑定到编辑组件的 `content` 输入属性。由于我们希望传递格式化的时间持续时间而不是毫秒数，我们在绑定表达式中使用
    `formatDuration` 管道进行转换。
- en: If the editor component notifies us about a saved edit, we call the `editSaved`
    method on our duration component, which will parse the entered duration and re-emit
    the resulting value a s milliseconds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编辑组件通知我们关于保存的编辑，我们在我们的持续时间组件上调用 `editSaved` 方法，这将解析输入的持续时间并将结果值重新发射为毫秒。
- en: As we initially defined all efforts to consist of an estimated and an effective
    duration, we would now like to create another component that combines these two
    durations within a single component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最初定义所有努力都由估计和有效持续时间组成，我们现在想创建另一个组件，该组件将这两个持续时间结合在一个组件中。
- en: 'Let''s create a new efforts component by using the Angular CLI tool:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 工具创建一个新的努力组件：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open up the template file of the generated component, located in `src/app/efforts/efforts/efforts.component.html`,
    and add the following content:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开生成的组件的模板文件，位于 `src/app/efforts/efforts/efforts.component.html`，并添加以下内容：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we add two duration components, where the first one is used to gather
    input for the estimated time and the later one for effective time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加两个持续时间组件，第一个用于收集估计时间的输入，后者用于有效时间。
- en: In addition to this, we provide three small buttons to increase the effective
    duration by a simple click. In this way, the user can quickly add one or four
    hours (half a working day) or a complete working day (which we defined as eight
    hours).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提供了三个小按钮，通过简单的点击来增加有效持续时间。这样，用户可以快速添加一到四小时（半个工作日）或完整的工作日（我们定义为八小时）。
- en: 'Let''s open the file `src/app/efforts/efforts/efforts.component.ts` and implement
    the component class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件 `src/app/efforts/efforts/efforts.component.ts` 并实现组件类：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The component provides an input named `efforts` to provide a `TimeEfforts` object.
    If you take a look at the component template again, the `estimated` and `effective`
    properties of the efforts object are directly bound to the input properties of
    the duration components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 组件提供了一个名为 `efforts` 的输入，以提供 `TimeEfforts` 对象。如果你再次查看组件模板，努力对象的 `estimated` 和
    `effective` 属性直接绑定到持续时间组件的输入属性。
- en: The `estimatedChange` and `effectiveChange` methods are used to create bindings
    to the `outDurationChange` output properties of the respective duration components.
    All we do here is emit an aggregated data object that contains the effective and
    estimated time in milliseconds using the `outEffortsChange` output property.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`estimatedChange` 和 `effectiveChange` 方法用于创建到相应持续时间组件的 `outDurationChange`
    输出属性的绑定。我们在这里所做的一切就是发射一个包含有效和估计时间（以毫秒为单位）的聚合数据对象，使用 `outEffortsChange` 输出属性。'
- en: The `addEffectiveHours` method is used for our quick buttons within the template
    of our efforts component. We calculate the effective property by multiplying the
    number of milliseconds for a working hour with the number of hours passed to the
    function. We use our `UNITS` constant from the time utility module in order to
    get the number of milliseconds for an hour. After we've calculated the new effective
    duration, we're using the `outEffortsChange` output to propagate the update.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEffectiveHours` 方法用于模板中的快速按钮。我们通过将工作小时数的毫秒数乘以传递给函数的小时数来计算有效属性。我们使用来自时间实用模块的
    `UNITS` 常量来获取每小时毫秒数。在计算了新的有效持续时间后，我们使用 `outEffortsChange` 输出来传播更新。'
- en: That's all we need in order to provide a user input to manage efforts on our
    tasks. To complete this topic, we will add our newly-created efforts component
    to the task details component in order to manage efforts on tasks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们提供用户输入以管理任务努力所需的所有内容。为了完成这个主题，我们将把新创建的努力组件添加到任务详情组件中，以便管理任务的努力。
- en: 'Let''s first look at the code changes in the task details component template
    located in `src/app/tasks/task-details/task-details.component.html`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看位于 `src/app/tasks/task-details/task-details.component.html` 的任务详情组件模板中的代码更改：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We're simply including our new efforts component in the task details template.
    Since we have the efforts object already present on our task objects, we can create
    the necessary binding without additional changes in the component class. However,
    for updating the efforts when a user changes the estimated or effective durations,
    we will need to implement a new method `updateEfforts`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是简单地将新的努力组件包含在任务详情模板中。由于我们已经在任务对象上有了努力对象，我们可以创建必要的绑定，而无需在组件类中进行任何额外更改。然而，当用户更改估计或实际持续时间时更新努力，我们需要实现一个新的方法
    `updateEfforts`。
- en: 'Let''s open our component class, located in `src/app/tasks/task-details/task-details.component.html`,
    and implement the new method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于 `src/app/tasks/task-details/task-details.component.html` 的组件类，并实现新的方法：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We added a new `updateEfforts` method that deals with the output provided by
    the efforts component. Because the efforts property is part of the task object,
    we can simply reuse the `outUpdateTask` output to delegate the update. Our container
    component is already prepared to deal with task updates.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的 `updateEfforts` 方法，用于处理由努力组件提供的输出。因为努力属性是任务对象的一部分，我们可以简单地重用 `outUpdateTask`
    输出来委派更新。我们的容器组件已经准备好处理任务更新。
- en: 'Awesome stuff! We have successfully implemented a no-UI component and used
    the concept of composition to it''s best. You should now be able to preview the
    changes in your browser and manage efforts on the task details view:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！我们已经成功实现了一个无 UI 组件，并最好地使用了组合的概念。你现在应该能够在浏览器中预览更改并管理任务详情视图中的努力：
- en: '![](img/47a486de-e505-4bcf-a5a8-1565bd0b6aad.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47a486de-e505-4bcf-a5a8-1565bd0b6aad.png)'
- en: Our new Efforts component that consists of two duration input components
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由两个持续时间输入组件组成的新 Efforts 组件
- en: The visual efforts timeline
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 努力时间线视觉表示
- en: Although the components that we have created so far to manage efforts provide
    a good way to edit and display effort and time durations, we can still improve
    this with some visual indication.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们迄今为止创建的用于管理努力的组件提供了编辑和显示努力和时间持续期的良好方式，但我们仍然可以通过一些视觉指示来改进这一点。
- en: 'In this section, we will create a visual efforts timeline using SVG. This timeline
    should display the following information:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 SVG 创建一个视觉努力时间线。这个时间线应显示以下信息：
- en: The total estimated duration as a grey background bar
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为灰色背景条的总体估计持续时间
- en: The total effective duration as a green bar that overlays on the total estimated
    duration bar
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为绿色条覆盖在总估计持续时间条上的总有效持续时间
- en: A yellow bar that shows any overtime (if the effective duration is greater than
    the estimated duration)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个黄色条表示任何加班（如果实际持续时间大于估计持续时间）
- en: 'The following two figures illustrate the different visual states of our efforts
    timeline component:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个图示说明了我们的努力时间线组件的不同视觉状态：
- en: '![](img/ca97d17f-6145-460b-b300-3596098de1fd.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca97d17f-6145-460b-b300-3596098de1fd.png)'
- en: The visual state if the estimated duration is greater than the effective duration
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当估计持续时间大于实际持续时间时的视觉状态
- en: 'If a task''s effective time will be more than the originally estimated time,
    we can show that overtime in a different colour:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务的实际时间将超过最初估计的时间，我们可以用不同的颜色显示加班时间：
- en: '![](img/0f7283c6-c29b-4f24-9832-0e91848239b2.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f7283c6-c29b-4f24-9832-0e91848239b2.png)'
- en: The visual state if the effective duration exceeds the estimated duration (the
    overtime is displayed as a yellow bar)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当实际持续时间超过估计持续时间时的视觉状态（加班以黄色条形图显示）
- en: 'Let''s start fleshing out our visual timeline component by using Angular CLI
    to create our component stubs:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 Angular CLI 创建我们的组件占位符来具体化我们的视觉时间线组件：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alright, let''s first look at the component class located in `src/app/efforts/efforts-timeline/efforts-timeline.component.ts`
    and implement the necessary logic to render our SVG timeline:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们首先来看位于 `src/app/efforts/efforts-timeline/efforts-timeline.component.ts`
    的组件类，并实现必要的逻辑来渲染我们的 SVG 时间线：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our component has only one input. The `efforts` input is a `TimeEfforts` object
    which we're supposed to render on a graphical timeline. All the other properties
    that we need to render our timeline are derived from this efforts object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件只有一个输入。`efforts` 输入是一个 `TimeEfforts` 对象，我们应在图形时间线上渲染它。我们需要的其他所有属性都来自这个努力对象。
- en: 'In the `OnChanges` lifecycle hook, we set two component member fields, which
    are based on the estimated and effective time:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnChanges` 生命周期钩子中，我们设置了两个基于估计和实际时间的组件成员字段：
- en: '**done**: This contains the width of the green bar in percent, which displays
    the effective duration without overtime that exceeds the estimated duration'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成度**：这包含绿色条的宽度百分比，显示没有超过估计时间的有效持续时间'
- en: '**overtime**: This contains the width of the yellow bar in percent that displays
    any overtime, which is any time duration that exceeds the estimated duration'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加班**：这包含黄色条的宽度百分比，显示任何超过估计时间的加班时间'
- en: Let's look at the template of the efforts timeline component and see how we
    can now use the `done` and `overtime` member fields to draw our timeline.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看努力时间线组件的模板，看看我们现在如何使用 `done` 和 `overtime` 成员字段来绘制我们的时间线。
- en: 'Open the template file located in `src/app/efforts/efforts-timeline/efforts-timeline.component.ts`
    and apply the following changes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `src/app/efforts/efforts-timeline/efforts-timeline.component.ts` 的模板文件，并应用以下更改：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our template is SVG-based, and it contains three rectangles for each of the
    bars that we want to display. The background bar of our efforts timeline will
    always be displayed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板是基于 SVG 的，它包含我们想要显示的每个条形图的三个矩形。我们努力时间线的背景条始终会显示。
- en: Above the remaining bar, we conditionally display the done and the overtime
    bar using the calculated widths from our component class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余条形图上方，我们根据计算出的宽度有条件地显示完成度和加班条形图。
- en: That's all we need for representing our efforts timeline. We can now go ahead
    and include the efforts timeline component in our efforts component. This way,
    our users will have visual feedback when they edit the estimated or effective
    duration, and it provides them with a sense of overview.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们表示努力时间线所需的所有内容。现在，我们可以将努力时间线组件包含在我们的努力组件中。这样，当用户编辑估计或实际持续时间时，他们将获得视觉反馈，并有一个概览感。
- en: 'Let''s open the template of the efforts component, located in `src/app/efforts/efforts/efforts.component.html`,
    and apply the following changes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于 `src/app/efforts/efforts/efforts.component.html` 的努力组件模板，并应用以下更改：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we have the efforts object readily available in our component, we can simply
    create a binding to the efforts timeline component `efforts` input property.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在组件中已经有了努力对象，我们可以简单地创建一个绑定到努力时间线组件的 `efforts` 输入属性。
- en: 'Congratulations! You''ve just put the cherry on the cake with this last change.
    Our users can now not only enter estimations and effective working hours using
    our efforts component, they also have a visual feedback of time available, spent,
    and overtime. Spin up the application in your browser and mess around with the
    new efforts component a bit. I''m sure you''ll enjoy the text-based no-UI input
    elements we''ve just created. Let''s take a look at a screenshot of our efforts
    timeline in action:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚用这个最后的更改给蛋糕加上了樱桃。现在，我们的用户不仅可以通过我们的努力组件输入估计和实际工作时间，还能看到时间的可用性、已花费时间和加班的视觉反馈。在浏览器中启动应用程序，并稍微尝试一下新的努力组件。我相信你会喜欢我们刚刚创建的基于文本的无
    UI 输入元素。让我们看看我们的努力时间线在实际操作中的截图：
- en: '![](img/89446e4a-15ca-42e2-97a5-e838cf2c95ed.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89446e4a-15ca-42e2-97a5-e838cf2c95ed.png)'
- en: The Efforts component displaying our newly-created efforts timeline component
    (the overtime of six hours is visualized with the yellow bar)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们新创建的努力时间线组件的 Efforts 组件（六小时加班以黄色条形图可视化）
- en: Recapitulating on efforts management
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 努力管理回顾
- en: 'In this section, we have created components that allow users to manage efforts
    easily and add a simple but powerful time tracking to our tasks. We''ve done the
    following to achieve this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了允许用户轻松管理努力并添加简单但强大的时间跟踪到我们的任务的组件。为了实现这一点，我们做了以下工作：
- en: We implemented some utility functions to deal with the time math in order to
    convert time durations in milliseconds into formatted time durations and vice
    versa
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了一些实用函数来处理时间数学，以便将时间时长从毫秒转换为格式化时间时长，反之亦然
- en: We created a pipe to format time durations in milliseconds using our utility
    functions
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个管道，使用我们的实用函数格式化以毫秒为单位的时间时长
- en: We created a duration UI component, which wraps an editor component and uses
    our time utilities to provide a no-UI kind of input element to enter durations
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个时长 UI 组件，它封装了一个编辑器组件，并使用我们的时间工具来提供一个无 UI 的输入元素以输入时长
- en: We created an efforts component that acts as a composition of two duration components
    for estimated and effective time, and provides additional buttons to add effective
    spent time quickly
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个努力组件，它作为两个时长组件的组合，用于估计和有效时间，并提供额外的按钮以快速添加有效花费时间
- en: We integrated the efforts component into the task details component in order
    to manage efforts on tasks
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将努力组件集成到任务详情组件中，以便管理任务上的努力
- en: We created a visual efforts timeline component using SVG, which displays the
    overall progress on a task
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 SVG 创建了一个可视化的努力时间线组件，它显示任务的整体进度
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented some components that help our users keep track
    of time. They can now log efforts on tasks and manage milestones on projects.
    We created a new task detail view that can be accessed using a navigation link
    on our task list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一些组件，帮助我们的用户跟踪时间。他们现在可以在任务上记录努力并管理项目上的里程碑。我们创建了一个新的任务详情视图，可以通过任务列表上的导航链接访问。
- en: Isn't it nice how easy it suddenly seems to implement new functionality when
    using components with proper encapsulation? The great thing about component-oriented
    development is that your development time for new functionality is decreased with
    the number of reusable components that you already created.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有适当封装的组件实现新功能时，突然变得如此简单，这不是很好吗？面向组件的开发的好处在于，你为新的功能开发时间随着你已创建的可重用组件数量的增加而减少。
- en: Once more, we experienced the power of composition using components, and reusing
    existing components, we were able to easily implement higher components that provide
    more complex functionality.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 再次体验了使用组件和重用现有组件的力量，我们能够轻松实现提供更复杂功能的高级组件。
- en: In the next chapter, we will look at how to use the charting library Chartist
    and create some wrapper components that allow us to build reusable charts. Additionally,
    we will build a dashboard for our task management system, where we will see our
    chart components in action.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用图表库 Chartist 并创建一些包装组件，使我们能够构建可重用的图表。此外，我们还将为我们的任务管理系统构建一个仪表板，在那里我们将看到我们的图表组件在行动。
