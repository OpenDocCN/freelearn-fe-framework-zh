<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer045">
<h1 class="chapter-number" id="_idParaDest-237"><a id="_idTextAnchor277"/>14</h1>
<h1 id="_idParaDest-238"><a id="_idTextAnchor278"/>Building a Logo Interpreter</h1>
<p>Logo is a programming environment created in the 1960s. It was, for many decades, a popular way to teach children how to code—I have fond memories of writing Logo programs back in high school. At its core, it is a method for building graphics via imperative instructions.</p>
<p>In this part of the book, we’ll build an application called <strong class="bold">Spec Logo</strong>. The starting point is an already-functioning interpreter and a barebones UI. In the following chapters, we’ll bolt on additional features to this codebase.</p>
<p>This chapter provides a second opportunity to test-drive Redux. It covers the following topics:</p>
<ul>
<li>Studying the <strong class="bold">Spec Logo</strong> user interface</li>
<li>Undoing and redoing user actions in Redux</li>
<li>Saving to local storage via Redux middleware</li>
<li>Changing keyboard focus</li>
</ul>
<p>By the end of the chapter, you’ll have learned how to test-drive complex Redux reducers and middleware.</p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor279"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter14">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter14</a></p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor280"/>Studying the Spec Logo user interface</h1>
<p>The interface<a id="_idIndexMarker1277"/> has two panes: the left pane is the drawing pane, which is where the output from the Logo script appears. On the right side is a prompt where the user can edit instructions:</p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 14.1: The Spec Logo interface " height="968" src="image/Figure_14.01_B18423.jpg" width="1409"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1: The Spec Logo interface</p>
<p>Look at the screenshot. You can see the following:</p>
<ul>
<li>The <strong class="bold">script name</strong> in the top-left corner. This is a text field that the user can click on to change the name of the current script.</li>
<li>The <strong class="bold">display</strong>, which shows script output on the left-hand side of the page. You can see a shape has been drawn here, which is the result of the Logo statements entered at the prompt.</li>
<li>The <strong class="bold">turtle</strong>, shown in the middle of the screen. This is a little green triangle that marks where drawing commands originate. The turtle has an <em class="italic">x</em> and <em class="italic">y</em> position, starting at <em class="italic">0,0</em>, which is the middle of the screen. The viewable drawing is 600x600 in size, and the turtle can move throughout this area. The turtle also has an angle, initially zero, which is pointing directly right.</li>
<li>The <strong class="bold">prompt</strong> in the bottom right-hand corner, marked with a <strong class="bold">&gt;</strong> symbol. This is where you enter your statements, which can be multiline. Hitting <em class="italic">Enter</em> will send the current prompt text to the interpreter. If it makes a complete statement, it will be executed, and the prompt cleared ready for your next statement.</li>
<li>The <strong class="bold">statement history</strong> above the prompt. It lists all the previously executed statements. Each is given a number so you can refer back to the statement.</li>
<li>A <strong class="bold">menu bar</strong> in the top-right corner, containing <strong class="bold">Undo</strong>, <strong class="bold">Redo</strong>, and <strong class="bold">Reset</strong> buttons. It is this menu bar that we’ll be building out in this chapter.</li>
</ul>
<p>Although we <a id="_idIndexMarker1278"/>won’t be writing any Logo code in this chapter, it’s worth spending some time playing around and making your own drawings with the interpreter. Here’s a list of instructions that you can use:</p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="" height="649" src="image/B18423_Table_14.1.jpg" width="1650"/>
</div>
</div>
<p>It’s also worth looking through the codebase. The <strong class="source-inline">src/parser.js</strong> file and the <strong class="source-inline">src/language</strong> directory contain the Logo interpreter. There are also corresponding test files in the test directory. We won’t be modifying these files, but you may be interested in seeing how this functionality has been tested.</p>
<p>There is a single Redux reducer in <strong class="source-inline">src/reducers/script.js</strong>. Its <strong class="source-inline">defaultState</strong> definition neatly encapsulates everything needed to represent the execution of a Logo program. Almost all the app’s React components use this state in some way.</p>
<p>In this chapter, we’ll be adding two more reducers into this directory: one for undo/redo and one for<a id="_idIndexMarker1279"/> prompt focus. We’ll be making modifications to three React components: <strong class="source-inline">MenuButtons</strong>, <strong class="source-inline">Prompt</strong>, and <strong class="source-inline">ScriptName<a id="_idTextAnchor281"/></strong>.</p>
<p>Let’s start by building a new reducer, named <strong class="source-inline">withUndoRedo</strong>.</p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor282"/>Undoing and redoing user actions in Redux</h1>
<p>In this <a id="_idIndexMarker1280"/>section, we’ll add undo and redo buttons at the top of the page, which allow the user to undo and redo statements that they’ve previously run. They’ll work like this:</p>
<ol>
<li>Initially, both buttons will be disabled.</li>
<li>Once the user executes a statement, the <strong class="bold">Undo</strong> button will become enabled.</li>
<li>When the user clicks the <strong class="bold">Undo</strong> button, the last statement will be undone.</li>
<li>At that point, the <strong class="bold">Redo</strong> button becomes available, and the user can choose to redo the last statement.</li>
<li>Multiple actions can be undone and then redone, in sequence.</li>
<li>If the user performs a new action while <strong class="bold">Redo</strong> is available, the redo sequence is cleared, and the <strong class="bold">Redo</strong> button becomes unavailable again.</li>
</ol>
<p>Aside from adding button elements, the work<a id="_idIndexMarker1281"/> involved here is building a new reducer, <strong class="source-inline">withUndoRedo</strong>, which will <em class="italic">decorate</em> the script reducer. This reducer will return the same state as the script reducer, but with two additional properties: <strong class="source-inline">canUndo</strong> and <strong class="source-inline">canRedo</strong>. In addition, the reducer stores <strong class="source-inline">past</strong> and <strong class="source-inline">future</strong> arrays within it that record the past and future states. These will never be returned to the user, just stored, and will replace the current state should the user <a id="_idIndexMarker1282"/>choose to undo or re<a id="_idTextAnchor283"/>do.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor284"/>Building the reducer</h2>
<p>The reducer <a id="_idIndexMarker1283"/>will be a higher-order function that, when called with an existing reducer, returns a new reducer that returns the state we’re expecting. In our production code, we’ll replace this store code:</p>
<pre class="source-code">
combineReducers({
  script: scriptReducer
})</pre>
<p>We’ll replace it with this decorated reducer, which takes exactly the same reducer and wraps it in<a id="_idIndexMarker1284"/> the <strong class="source-inline">withUndoRedo</strong> reducer that we’ll build in this section:</p>
<pre class="source-code">
combineReducers({
  script: withUndoRedo(scriptReducer)
})</pre>
<p>To test this, we’ll need to use a spy to act in place of the script reducer, which we’ll call <strong class="source-inline">decoratedReduce<a id="_idTextAnchor285"/>rSpy</strong>.</p>
<h3>Setting the initial state</h3>
<p>Let’s make a <a id="_idIndexMarker1285"/>start by building the reducer itself, before adding buttons to exercise the new functionality:</p>
<ol>
<li value="1">Create a new file named <strong class="source-inline">test/reducers/withUndoRedo.test.js</strong> and add the following setup and test, which specifies what should happen when we pass an undefined state to the reducer. This is equivalent to how we began testing our other<a id="_idIndexMarker1286"/> reducers, but in this case, we pass the call through to the decorated reducer. The test passes an <strong class="source-inline">undefined</strong> state to the reducer, which is the required mechanism for initializing a reducer:<p class="source-code">import {</p><p class="source-code">  withUndoRedo</p><p class="source-code">} from "../../src/reducers/withUndoRedo";</p><p class="source-code">describe("withUndoRedo", () =&gt; {</p><p class="source-code">  let decoratedReducerSpy;</p><p class="source-code">  let reducer;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    decoratedReducerSpy = jest.fn();</p><p class="source-code">    reducer = withUndoRedo(decoratedReducerSpy);</p><p class="source-code">  });</p><p class="source-code">  describe("when initializing state", () =&gt; {</p><p class="source-code">    it("calls the decorated reducer with undefined state and an action", () =&gt; {</p><p class="source-code">      const action = { type: "UNKNOWN" };</p><p class="source-code">      reducer(undefined, action);</p><p class="source-code">      expect(decoratedReducerSpy).toBeCalledWith(</p><p class="source-code">        undefined,</p><p class="source-code">        action);</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Create <a id="_idIndexMarker1287"/>a new <strong class="source-inline">src/reducers/withUndoRedo.js</strong> file and make the test pass with the following code:<p class="source-code">export const withUndoRedo = (reducer) =&gt; {</p><p class="source-code">  return (state, action) =&gt; {</p><p class="source-code">    reducer(state, action);</p><p class="source-code">  };</p><p class="source-code">};</p></li>
<li>Add the next test to the <strong class="source-inline">describe</strong> block, as shown. This uses the <strong class="source-inline">toMatchObject</strong> matcher, which <a id="_idIndexMarker1288"/>we first encountered in <a href="B18423_06.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Test Doubles</em>:<p class="source-code">it("returns a value of what the inner reducer returns", () =&gt; {</p><p class="source-code">  decoratedReducerSpy.mockReturnValue({ a: 123 });</p><p class="source-code">  expect(reducer(undefined)).toMatchObject(</p><p class="source-code">    { a : 123 }</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Make<a id="_idIndexMarker1289"/> that <a id="_idIndexMarker1290"/>pass by adding the <strong class="source-inline">return</strong> keyword:<p class="source-code">export const withUndoRedo = (reducer) =&gt; {</p><p class="source-code">  return (state, action) =&gt; {</p><p class="source-code"><strong class="bold">    return </strong>reducer(state, action);</p><p class="source-code">  };</p><p class="source-code">}</p></li>
<li>Initially, both <strong class="source-inline">canUndo</strong> and <strong class="source-inline">canRedo</strong> should be <strong class="source-inline">false</strong>, as there are no previous or future states that we can move to. Let’s add those two tests as a pair, still in the same <strong class="source-inline">describe</strong> block:<p class="source-code">it("cannot undo", () =&gt; {</p><p class="source-code">  expect(reducer(undefined)).toMatchObject({</p><p class="source-code">    canUndo: false</p><p class="source-code">  });</p><p class="source-code">});</p><p class="source-code">it("cannot redo", () =&gt; {</p><p class="source-code">  expect(reducer(undefined)).toMatchObject({</p><p class="source-code">    canRedo: false</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make these <a id="_idIndexMarker1291"/>tests pass, we need to create a new object with those properties added:<p class="source-code">export const withUndoRedo = (reducer) =&gt; {</p><p class="source-code">  return (state, action) =&gt; {</p><p class="source-code">    return <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">      canUndo: false,</strong></p><p class="source-code"><strong class="bold">      canRedo: false,</strong></p><p class="source-code"><strong class="bold">      ...</strong>reducer(state, action)</p><p class="source-code"><strong class="bold">    };</strong></p><p class="source-code">  };</p><p class="source-code">}</p></li>
<li>Let’s move on to the meat of the reducer. After performing an action, we want to be able to perform an <strong class="bold">Undo</strong> action to revert to the previous state. We’ll use the <strong class="source-inline">present</strong> and <strong class="source-inline">future</strong> constants to denote those states:<p class="source-code">describe("performing an action", () =&gt; {</p><p class="source-code">  const innerAction = { type: "INNER" };</p><p class="source-code">  const present = { a: 123 };</p><p class="source-code">  const future = { b: 234 };</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    decoratedReducerSpy.mockReturnValue(future);</p><p class="source-code">  });</p><p class="source-code">  it("can undo after a new present has been provided", () =&gt; {</p><p class="source-code">    const result = reducer(</p><p class="source-code">      { canUndo: false, present },</p><p class="source-code">      innerAction</p><p class="source-code">    );</p><p class="source-code">    expect(result.canUndo).toBeTruthy();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that <a id="_idIndexMarker1292"/>pass with the following code. Since we’re no longer dealing with an undefined state, this is the moment that we need to wrap our existing code in a conditional block:<p class="source-code">export const withUndoRedo = (reducer) =&gt; {</p><p class="source-code">  return (state, action) =&gt; {</p><p class="source-code">    <strong class="bold">if (state === undefined)</strong></p><p class="source-code">      return {</p><p class="source-code">        canUndo: false,</p><p class="source-code">        canRedo: false,</p><p class="source-code">        ...reducer(state, action)</p><p class="source-code">      };</p><p class="source-code"><strong class="bold">    return {</strong></p><p class="source-code"><strong class="bold">      canUndo: true</strong></p><p class="source-code"><strong class="bold">    };</strong></p><p class="source-code">  };</p><p class="source-code">};</p></li>
<li>Next, we make <a id="_idIndexMarker1293"/>sure we call the reducer again since, for<a id="_idIndexMarker1294"/> this new block, it won’t happen. Write the following test:<p class="source-code">it("forwards action to the inner reducer", () =&gt; {</p><p class="source-code">  reducer(present, innerAction);</p><p class="source-code">  expect(decoratedReducerSpy).toBeCalledWith(</p><p class="source-code">    present,</p><p class="source-code">    innerAction</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that pass, simply call the reducer before the <strong class="source-inline">return</strong> value:<p class="source-code">if (state === undefined)</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">reducer(state, action);</strong></p><p class="source-code">return {</p><p class="source-code">  canUndo: true</p><p class="source-code">};</p></li>
<li>The next test shows that this object also needs to return the new state:<p class="source-code">it("returns the result of the inner reducer", () =&gt; {</p><p class="source-code">  const result = reducer(present, innerAction);</p><p class="source-code">  expect(result).toMatchObject(future);</p><p class="source-code">});</p></li>
<li>Make that pass <a id="_idIndexMarker1295"/>by saving the reducer value in a variable<a id="_idIndexMarker1296"/> named <strong class="source-inline">newPresent</strong> and returning it as part of the returned object:<p class="source-code"><strong class="bold">const newPresent = </strong>reducer(state, action);</p><p class="source-code">return {</p><p class="source-code"><strong class="bold">  ...newPresent,</strong></p><p class="source-code">  canUndo: true</p><p class="source-code">};</p></li>
<li>The script reducer holds a special value named <strong class="source-inline">nextInstructionId</strong>. We can use this to determine whether the script instruction was processed or whether an error occurred. When a statement is valid, it is executed and <strong class="source-inline">nextInstructionId</strong> is incremented. But when a statement can’t be processed, <strong class="source-inline">nextInstructionId</strong> remains the same. We can use that fact to avoid saving history if a statement contains an error. To do that, modify the <strong class="source-inline">present</strong> and <strong class="source-inline">future</strong> constants to include this parameter, and add the new test, as shown next:<p class="source-code"><strong class="bold">const present = { a: 123, nextInstructionId: 0 };</strong></p><p class="source-code"><strong class="bold">const future = { b: 234, nextInstructionId: 1 };</strong></p><p class="source-code">...</p><p class="source-code">it("returns the previous state if nextInstructionId does not increment", () =&gt; {</p><p class="source-code">  decoratedReducerSpy.mockReturnValue({</p><p class="source-code">    nextInstructionId: 0</p><p class="source-code">  });</p><p class="source-code">  const result = reducer(present, innerAction);</p><p class="source-code">  expect(result).toBe(present);</p><p class="source-code">});</p></li>
<li>Make that pass by wrapping our new <strong class="source-inline">return</strong> block in a conditional, and returning the<a id="_idIndexMarker1297"/> old state if the condition doesn’t pass:<p class="source-code">const newPresent = reducer(state, action);</p><p class="source-code"><strong class="bold">if (</strong></p><p class="source-code"><strong class="bold">  newPresent.nextInstructionId !=</strong></p><p class="source-code"><strong class="bold">  state.nextInstructionId</strong></p><p class="source-code"><strong class="bold">) {</strong></p><p class="source-code">  return {</p><p class="source-code">    ...newPresent,</p><p class="source-code">    canUndo: true </p><p class="source-code">  };</p><p class="source-code"><strong class="bold">}</strong></p><p class="source-code"><strong class="bold">return state;</strong></p></li>
</ol>
<p>This covers all the functionality for performing any actions <em class="italic">other than</em> <strong class="bold">Undo</strong> and <strong class="bold">Redo</strong>. The next se<a id="_idTextAnchor286"/>ction covers <strong class="bold">Undo</strong>.</p>
<h3>Handling the undo action</h3>
<p>We’ll create a<a id="_idIndexMarker1298"/> new Redux action, of type <strong class="source-inline">UNDO</strong>, which <a id="_idIndexMarker1299"/>causes us to push the current state into a new array called <strong class="source-inline">past</strong>:</p>
<ol>
<li value="1">For this test, we can reuse the <strong class="source-inline">present</strong> and <strong class="source-inline">innerAction</strong> properties, so push those up into the outer <strong class="source-inline">describe</strong> block now. Also, define a new <strong class="source-inline">undoAction</strong> Redux action. We’ll use it within our first test:<p class="source-code">describe("withUndoRedo", () =&gt; {</p><p class="source-code"><strong class="bold">  const undoAction = { type: "UNDO" };</strong></p><p class="source-code"><strong class="bold">  const innerAction = { type: "INNER" };</strong></p><p class="source-code"><strong class="bold">  const present = { a: 123, nextInstructionId: 0 };</strong></p><p class="source-code"><strong class="bold">  const future = { b: 234, nextInstructionId: 1 };</strong></p><p class="source-code">  ...</p><p class="source-code">});</p></li>
<li>Add a new nested <strong class="source-inline">describe</strong> block with the following test and setup. The <strong class="source-inline">beforeEach</strong> block<a id="_idIndexMarker1300"/> sets up a scenario where we’ve already performed an action that will have stored a previous state. We’re then ready to undo it within the test:<p class="source-code">describe("undo", () =&gt; {</p><p class="source-code"> let newState;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    decoratedReducerSpy.mockReturnValue(future);</p><p class="source-code">    newState = reducer(present, innerAction);</p><p class="source-code">  });</p><p class="source-code">  it("sets present to the latest past entry", () =&gt; {</p><p class="source-code">    const updated = reducer(newState, undoAction);</p><p class="source-code">    expect(updated).toMatchObject(present);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Performing an action within a beforeEach block</p>
<p class="callout">Notice the call to the <strong class="source-inline">reducer</strong> function in the <strong class="source-inline">beforeEach</strong> setup. This function is the function under test, so it could<a id="_idIndexMarker1301"/> be considered part of the <strong class="bold">Act</strong> phase that we usually keep within the test itself. However, in this case, the first call to <strong class="source-inline">reducer</strong> is part of the test setup, since all these tests rely on having performed at least one action that can then be undone. In this way, we can consider this <strong class="source-inline">reducer</strong> call to be part of the <strong class="bold">Assert</strong> phase.</p>
<ol>
<li value="3">Make that pass by modifying the function as follows. We use a <strong class="source-inline">past</strong> variable to store the previous state. If we receive an <strong class="source-inline">UNDO</strong> action, we return that value. We <a id="_idIndexMarker1302"/>also <a id="_idIndexMarker1303"/>use a <strong class="source-inline">switch</strong> statement <a id="_idIndexMarker1304"/>since we’ll be adding a case for <strong class="source-inline">REDO</strong> later:<p class="source-code">export const withUndoRedo = (reducer) =&gt; {</p><p class="source-code"><strong class="bold">  let past;</strong></p><p class="source-code">  return (state, action) =&gt; {</p><p class="source-code">    if (state === undefined)</p><p class="source-code">      ...</p><p class="source-code"><strong class="bold">    switch(action.type) {</strong></p><p class="source-code"><strong class="bold">      case "UNDO":</strong></p><p class="source-code"><strong class="bold">        return past; </strong></p><p class="source-code"><strong class="bold">      default:</strong></p><p class="source-code">        const newPresent = reducer(state, action);</p><p class="source-code">        if (</p><p class="source-code">          newPresent.nextInstructionId !=</p><p class="source-code">          state.nextInstructionId</p><p class="source-code">        ) {</p><p class="source-code"><strong class="bold">          past = state;</strong></p><p class="source-code">          return {</p><p class="source-code">            ...newPresent,</p><p class="source-code">            canUndo: true</p><p class="source-code">          };</p><p class="source-code">        }</p><p class="source-code">        return state;</p><p class="source-code">    }</p><p class="source-code">  };</p><p class="source-code">};</p></li>
<li>Next, let’s <a id="_idIndexMarker1305"/>adjust this so<a id="_idIndexMarker1306"/> that we can undo any number of levels deep. Add the next test:<p class="source-code">it("can undo multiple levels", () =&gt; {</p><p class="source-code">  const futureFuture = {</p><p class="source-code">    c: 345, nextInstructionId: 3</p><p class="source-code">  };</p><p class="source-code">  decoratedReducerSpy.mockReturnValue(futureFuture);</p><p class="source-code">  newState = reducer(newState, innerAction);</p><p class="source-code">  const updated = reducer(</p><p class="source-code">    reducer(newState, undoAction),</p><p class="source-code">    undoAction</p><p class="source-code">  );</p><p class="source-code">  </p><p class="source-code">  expect(updated).toMatchObject(present);</p><p class="source-code">});</p></li>
<li>For this, we’ll <a id="_idIndexMarker1307"/>need to <a id="_idIndexMarker1308"/>upgrade <strong class="source-inline">past</strong> to an array:<p class="source-code">export const withUndoRedo = (reducer) =&gt; {</p><p class="source-code">  let past =<strong class="bold"> []</strong>;</p><p class="source-code">  return (state, action) =&gt; {</p><p class="source-code">    if (state === undefined)</p><p class="source-code">      ... </p><p class="source-code">    switch(action.type) {</p><p class="source-code">      case "UNDO":</p><p class="source-code">        <strong class="bold">const lastEntry = past[past.length - 1];</strong></p><p class="source-code"><strong class="bold">        past = past.slice(0, -1);</strong></p><p class="source-code"><strong class="bold">        return lastEntry;</strong></p><p class="source-code">      default:</p><p class="source-code">        const newPresent = reducer(state, action);</p><p class="source-code">        if (</p><p class="source-code">          newPresent.nextInstructionId !=</p><p class="source-code">          state.nextInstructionId</p><p class="source-code">        ) {</p><p class="source-code">          past = <strong class="bold">[ ...past, state ];</strong></p><p class="source-code">          return {</p><p class="source-code">            ...newPresent,</p><p class="source-code">            canUndo: true</p><p class="source-code">          };</p><p class="source-code">        }</p><p class="source-code">        return state;</p><p class="source-code">    }</p><p class="source-code">  };</p><p class="source-code">};</p></li>
<li>There’s one<a id="_idIndexMarker1309"/> final test we<a id="_idIndexMarker1310"/> need to do. We need to check that after undoing, we can also redo:<p class="source-code">it("sets canRedo to true after undoing", () =&gt; {</p><p class="source-code">  const updated = reducer(newState, undoAction);</p><p class="source-code">  expect(updated.canRedo).toBeTruthy();</p><p class="source-code">});</p></li>
<li>To make that pass, return a new object comprised of <strong class="source-inline">lastEntry</strong> and the new <strong class="source-inline">canRedo</strong> property:<p class="source-code">case "UNDO":</p><p class="source-code">  const lastEntry = past[past.length - 1];</p><p class="source-code">  past = past.slice(0, -1);</p><p class="source-code">  return <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">    ...la<a id="_idTextAnchor287"/>stEntry,</strong></p><p class="source-code"><strong class="bold">    canRedo: true</strong></p><p class="source-code"><strong class="bold">  };</strong></p></li>
</ol>
<p>That’s <a id="_idIndexMarker1311"/>all <a id="_idIndexMarker1312"/>there is to the <strong class="source-inline">UNDO</strong> action. Next, let’s add the <strong class="source-inline">REDO</strong> action.</p>
<h3>Handling the redo action</h3>
<p>Redo is <a id="_idIndexMarker1313"/>very<a id="_idIndexMarker1314"/> similar to undo, just reversed:</p>
<ol>
<li value="1">First, add a new definition for the Redux action of type <strong class="source-inline">REDO</strong>, in the top-level <strong class="source-inline">describe</strong> block:<p class="source-code">describe("withUndoRedo", () =&gt; {</p><p class="source-code">  const undoAction = { type: "UNDO" };</p><p class="source-code"><strong class="bold">  const redoAction = { type: "REDO" };</strong></p><p class="source-code">  ...</p><p class="source-code">});</p></li>
<li>Underneath the undo <strong class="source-inline">describe</strong> block, add the following redo <strong class="source-inline">describe</strong> block with the first test. Be careful with the setup for the spy; the call is <strong class="source-inline">mockReturnValueOnce</strong> here, not <strong class="source-inline">mockReturnValue</strong>. The test needs to ensure it takes its value from the stored <strong class="source-inline">redo</strong> state:<p class="source-code">describe("redo", () =&gt; {</p><p class="source-code">  let newState;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    decoratedReducerSpy.mockReturnValueOnce(future);</p><p class="source-code">    newState = reducer(present, innerAction);</p><p class="source-code">    newState = reducer(newState, undoAction);</p><p class="source-code">  });</p><p class="source-code">  it("sets the present to the latest future entry", () =&gt; {</p><p class="source-code">    const updated = reducer(newState, redoAction);</p><p class="source-code">    expect(updated).toMatchObject(future);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make <a id="_idIndexMarker1315"/>this pass, in your <a id="_idIndexMarker1316"/>production code, declare a <strong class="source-inline">future</strong> variable, next to the declaration for <strong class="source-inline">past</strong>:<p class="source-code">let past = []<strong class="bold">, future</strong>;</p></li>
<li>Set this within the <strong class="source-inline">UNDO</strong> action:<p class="source-code">  case "UNDO":</p><p class="source-code">    const lastEntry = past[past.length - 1];</p><p class="source-code">    past = past.slice(0, -1);</p><p class="source-code"><strong class="bold">    future = state;</strong></p></li>
<li>Now that it’s saved, we can handle the <strong class="source-inline">REDO</strong> action. Add the following <strong class="source-inline">case</strong> statement, between the <strong class="source-inline">UNDO</strong> clause and the <strong class="source-inline">default</strong> clause:<p class="source-code">case "UNDO":</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">case "REDO":</strong></p><p class="source-code"><strong class="bold">  return future;</strong></p><p class="source-code">default:</p><p class="source-code">  ...</p></li>
<li>The next test is for multiple levels of redo. This is slightly more complicated than the same case in the <strong class="source-inline">undo</strong> block—we’ll have to modify the <strong class="source-inline">beforeEach</strong> block to take us back <em class="italic">twice</em>. First, pull out the <strong class="source-inline">futureFuture</strong> value from the undo test and bring it into the outer scope, next to the other values, just below <strong class="source-inline">future</strong>:<p class="source-code">const future = { b: 234, nextInstructionId: 1 };</p><p class="source-code"><strong class="bold">const futureFuture = { c: 345, nextInstructionId: 3 };</strong></p></li>
<li>Now, update <strong class="source-inline">beforeEach</strong> to<a id="_idIndexMarker1317"/> take<a id="_idIndexMarker1318"/> two steps forward and then two back:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  decoratedReducerSpy.mockReturnValueOnce(future);</p><p class="source-code">  decoratedReducerSpy.mockReturnValueOnce(</p><p class="source-code">    futureFuture</p><p class="source-code">  );</p><p class="source-code"><strong class="bold">  newState = reducer(present, innerAction);</strong></p><p class="source-code"><strong class="bold">  newState = reducer(newState, innerAction);</strong></p><p class="source-code"><strong class="bold">  newState = reducer(newState, undoAction);</strong></p><p class="source-code"><strong class="bold">  newState = reducer(newState, undoAction);</strong></p><p class="source-code">});</p></li>
<li>Finally, add the test:<p class="source-code">it("can redo multiple levels", () =&gt; {</p><p class="source-code">  const updated = reducer(</p><p class="source-code">    reducer(newState, redoAction),</p><p class="source-code">    redoAction</p><p class="source-code">  );</p><p class="source-code">  expect(updated).toMatchObject(futureFuture);</p><p class="source-code">});</p></li>
<li>To make this pass, start by initializing the <strong class="source-inline">future</strong> variable to be an empty array:<p class="source-code">let past = [], future<strong class="bold"> = [];</strong></p></li>
<li>Update the <strong class="source-inline">UNDO</strong> clause to push the current value to it:<p class="source-code">case "UNDO":</p><p class="source-code">  const lastEntry = past[past.length - 1];</p><p class="source-code">  past = past.slice(0, -1);</p><p class="source-code"><strong class="bold">  future = [ ...future, state ];</strong></p></li>
<li>Update<a id="_idIndexMarker1319"/> the <strong class="source-inline">REDO</strong> clause to <a id="_idIndexMarker1320"/>pull out that value we just pushed. After this change, the test should be passing:<p class="source-code">case "REDO":</p><p class="source-code"><strong class="bold">  const nextEntry = future[future.length - 1];</strong></p><p class="source-code"><strong class="bold">  future = future.slice(0, -1);</strong></p><p class="source-code"><strong class="bold">  return nextEntry;</strong></p></li>
<li>There’s one final test we need to write for our barebones implementation, which checks that a redo followed by an undo brings us back to the original state:<p class="source-code">it("returns to previous state when followed by an undo", () =&gt; {</p><p class="source-code">  const updated = reducer(</p><p class="source-code">    reducer(newState, redoAction),</p><p class="source-code">    undoAction</p><p class="source-code">  );</p><p class="source-code">  expect(updated).toMatchObject(present);</p><p class="source-code">});</p></li>
<li>Make that pass by setting the <strong class="source-inline">past</strong> property in the <strong class="source-inline">REDO</strong> case:<p class="source-code">case "REDO":</p><p class="source-code">  const nextEntry = future[future.length - 1];</p><p class="source-code"><strong class="bold">  past = [ ...past, state ];</strong></p><p class="source-code">  future = future.slice(0, -1);</p><p class="source-code">  return nextEntry;</p></li>
<li>This completes our reducer. However, our implementation has a memory leak! We never clear out the <strong class="source-inline">future</strong> array when we generate new states. If the user repeatedly hit <strong class="bold">Undo</strong> and then performed new actions, all their old actions would <a id="_idIndexMarker1321"/>remain in <strong class="source-inline">future</strong> but become inaccessible, due to <strong class="source-inline">canRedo</strong> being <strong class="source-inline">false</strong> in<a id="_idIndexMarker1322"/> the latest state.</li>
</ol>
<p>To test for this scenario, you can simulate the sequence and check that you expect to return <strong class="source-inline">undefined</strong>. This test isn’t <em class="italic">great</em> in that we really shouldn’t be sending a <strong class="source-inline">REDO</strong> action when <strong class="source-inline">canRedo</strong> returns <strong class="source-inline">false</strong>, but that’s what our test ends up doing:</p>
<p class="source-code">it("return undefined when attempting a do, undo, do, redo sequence", () =&gt; {</p>
<p class="source-code">  decoratedReducerSpy.mockReturnValue(future);</p>
<p class="source-code">  let newState = reducer(present, innerAction);</p>
<p class="source-code">  newState = reducer(newState, undoAction);</p>
<p class="source-code">  newState = reducer(newState, innerAction);</p>
<p class="source-code">  newState = reducer(newState, redoAction);</p>
<p class="source-code">  expect(newState).not.toBeDefined();</p>
<p class="source-code">});</p>
<ol>
<li value="15">To make that pass, simply clear <strong class="source-inline">future</strong> when setting a new state, as shown:<p class="source-code">if (</p><p class="source-code">  newPresent.nextInstructionId !=</p><p class="source-code">  state.nextInstructionId</p><p class="source-code">) {</p><p class="source-code">  past = [ ...past, state ];</p><p class="source-code"><strong class="bold">  future = [];</strong></p><p class="source-code">  return {</p><p class="source-code">    ...newPresent,</p><p class="source-code">    canUndo: true</p><p class="source-code">  };</p><p class="source-code">}</p></li>
<li>We are <a id="_idIndexMarker1323"/>now <a id="_idIndexMarker1324"/>done with the reducer. To finish this off, hook it into our Redux store. Open <strong class="source-inline">src/store.js</strong> and make<a id="_idIndexMarker1325"/> the following changes:<p class="source-code"><strong class="bold">import {</strong></p><p class="source-code"><strong class="bold">  withUndoRedo</strong></p><p class="source-code"><strong class="bold">} from "./reducers/withUndoRedo";</strong></p><p class="source-code">export const configureStore = (</p><p class="source-code">  storeEnhancers = [],</p><p class="source-code">  initialState = {}</p><p class="source-code">) =&gt; {</p><p class="source-code">  return createStore(</p><p class="source-code">    combineReducers({</p><p class="source-code">      script: <strong class="bold">withUndoRedo(</strong>scriptReducer<strong class="bold">)</strong></p><p class="source-code">    }),</p><p class="source-code">    initialState,</p><p class="source-code">    compose(...storeEnhancers)</p><p class="source-code">  );</p><p class="source-code">};</p></li>
</ol>
<p>Your tests should all be passing and the app should still run.</p>
<p>However, the<a id="_idIndexMarker1326"/> undo and redo<a id="_idIndexMarker1327"/> functionality is still not accessible. For th<a id="_idTextAnchor288"/>at, we need to add some buttons to the menu bar.</p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor289"/>Building buttons</h2>
<p>The final piece <a id="_idIndexMarker1328"/>to this puzzle is adding buttons to trigger the new behavior by adding <strong class="bold">Undo</strong> and <strong class="bold">Redo</strong> buttons to the menu bar:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/MenuButtons.test.js</strong> and add the following <strong class="source-inline">describe</strong> block at the bottom of the file, nested inside the <strong class="source-inline">MenuButtons</strong> <strong class="source-inline">describe</strong> block. It uses a couple of helper functions that have already been defined with the <strong class="source-inline">renderWithStore</strong> file and button:<p class="source-code">describe("undo button", () =&gt; {</p><p class="source-code">  it("renders", () =&gt; {</p><p class="source-code">    renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">    expect(buttonWithLabel("Undo")).not.toBeNull();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by modifying the implementation for <strong class="source-inline">MenuButtons</strong> as shown, in the <strong class="source-inline">src/MenuButtons.js</strong> file:<p class="source-code">export const MenuButtons = () =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  return (</p><p class="source-code"><strong class="bold">    &lt;&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;button&gt;Undo&lt;/button&gt;</strong></p><p class="source-code">      &lt;button</p><p class="source-code">        onClick={() =&gt; dispatch(reset())}</p><p class="source-code">        disabled={!canReset}</p><p class="source-code">      &gt;</p><p class="source-code">        Reset</p><p class="source-code">      &lt;/button&gt;</p><p class="source-code"><strong class="bold">    &lt;/&gt;</strong></p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Add the <a id="_idIndexMarker1329"/>next test, which checks that the button is initially disabled:<p class="source-code">it("is disabled if there is no history", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  expect(</p><p class="source-code">    buttonWithLabel("Undo").hasAttribute("disabled")</p><p class="source-code">  ).toBeTruthy();</p><p class="source-code">});</p></li>
<li>Make that pass by adding a hardcoded <strong class="source-inline">disabled</strong> attribute, as shown:<p class="source-code">&lt;button<strong class="bold"> disabled={true</strong>}&gt;Undo&lt;/button&gt;</p></li>
<li>Now, we add in the code that will require us to connect with Redux:<p class="source-code">it("is enabled if an action occurs", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  dispatchToStore({</p><p class="source-code">    type: "SUBMIT_EDIT_LINE",</p><p class="source-code">    text: "forward 10\n"</p><p class="source-code">  });</p><p class="source-code">  expect(</p><p class="source-code">    buttonWithLabel("Undo").hasAttribute("disabled")</p><p class="source-code">  ).toBeFalsy();</p><p class="source-code">});</p></li>
<li>Modify <strong class="source-inline">MenuButtons</strong> to pull out <strong class="source-inline">canUndo</strong> from the store. It already uses the <strong class="source-inline">script</strong> state<a id="_idIndexMarker1330"/> for the <strong class="bold">Reset</strong> button behavior, so in this case, we just need to destructure it further:<p class="source-code">export const MenuButtons = () =&gt; {</p><p class="source-code">  const {</p><p class="source-code"><strong class="bold">    canUndo,</strong> nextInstructionId</p><p class="source-code">  } = useSelector(({ script }) =&gt; script);</p><p class="source-code">  ...</p><p class="source-code">  const canReset = nextInstructionId !== 0;</p><p class="source-code">  return (</p><p class="source-code">    &lt;&gt;</p><p class="source-code">      &lt;button<strong class="bold"> disabled={!canUndo}</strong>&gt;Undo&lt;/button&gt;</p><p class="source-code">      &lt;button</p><p class="source-code">        onClick={() =&gt; dispatch(reset())}</p><p class="source-code">        disabled={!canReset}</p><p class="source-code">      &gt;</p><p class="source-code">        Reset</p><p class="source-code">      &lt;/button&gt;</p><p class="source-code">    &lt;/&gt;</p><p class="source-code">  );</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>The final test <a id="_idIndexMarker1331"/>for the <strong class="bold">Undo</strong> button is to check that it dispatches an <strong class="source-inline">UNDO</strong> action when it is clicked:<p class="source-code">it("dispatches an action of UNDO when clicked", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  dispatchToStore({</p><p class="source-code">    type: "SUBMIT_EDIT_LINE",</p><p class="source-code">    text: "forward 10\n"</p><p class="source-code">  });</p><p class="source-code">  click(buttonWithLabel("Undo"));</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "UNDO" });</p><p class="source-code">});</p></li>
<li>Make that pass by adding the lines highlighted next. We add the new <strong class="source-inline">undo</strong> action helper<a id="_idIndexMarker1332"/> and then use that to call <strong class="source-inline">dispatch</strong>:<p class="source-code">const reset = () =&gt; ({ type: "RESET" });</p><p class="source-code"><strong class="bold">const undo = () =&gt; ({ type: "UNDO" });</strong></p><p class="source-code">export const MenuButtons = () =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;&gt;</p><p class="source-code">      &lt;button</p><p class="source-code"><strong class="bold">        onClick={() =&gt; dispatch(undo())}</strong></p><p class="source-code">        disabled={!canUndo}</p><p class="source-code">      &gt;</p><p class="source-code">        Undo</p><p class="source-code">      &lt;/button&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Repeat from <em class="italic">Step 2</em> to <em class="italic">Step 8</em> for the <strong class="bold">Redo</strong> button. This time, you’ll need to pull out the <strong class="source-inline">canRedo</strong> property from the script state.</li>
</ol>
<p>That’s the last change needed. The undo and redo functionality is now complete.</p>
<p>Next up, we’ll move from b<a id="_idTextAnchor290"/>uilding a Redux reducer to building Redux middleware.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor291"/>Saving to local storage via Redux middleware</h1>
<p>In this<a id="_idIndexMarker1333"/> section, we’ll update our app to save the current state to <em class="italic">local storage</em>, a persistent data store managed by the user’s web browser. We’ll do that by way of Redux middleware.</p>
<p>Each time a statement is executed in<a id="_idIndexMarker1334"/> the <strong class="bold">Spec Logo</strong> environment, the entire set of parsed tokens will be saved via the<a id="_idIndexMarker1335"/> browser’s <strong class="source-inline">LocalStorage</strong> API. When the user next opens the app, the tokens will be read and replayed through the parser.</p>
<p class="callout-heading">The parseTokens function</p>
<p class="callout">As a reminder, the parser (in <strong class="source-inline">src/parser.js</strong>) has a <strong class="source-inline">parseTokens</strong> function. This is the function we’ll call from within our middleware, and in this section, we’ll build tests to assert that we’ve called this function.</p>
<p>We’ll write a new<a id="_idIndexMarker1336"/> piece of Redux middleware for the task. The middleware will pull out two pieces of the script state: <strong class="source-inline">name</strong> and <strong class="source-inline">parsedTokens</strong>.</p>
<p>Before we begin, let’s review<a id="_idIndexMarker1337"/> the browser <strong class="source-inline">LocalStorage</strong> API:</p>
<ul>
<li><strong class="source-inline">window.localStorage.getItem(key)</strong> returns the value of an item in local storage. The value stored is a string, so if it’s a serialized object, then we need to call <strong class="source-inline">JSON.parse</strong> to deserialize it. The function returns <strong class="source-inline">null</strong> if no value exists for the given key.</li>
<li><strong class="source-inline">window.localStorage.setItem(key, value)</strong> sets the value of an item. The value is serialized as a string, so we need to make sure to call <a id="_idTextAnchor292"/><strong class="source-inline">JSON.stringify</strong> on any <a id="_idIndexMarker1338"/>objects before we pass them in here.</li>
</ul>
<h2 id="_idParaDest-245"><a id="_idTextAnchor293"/>Building middleware</h2>
<p>Let’s test-drive <a id="_idIndexMarker1339"/>our middleware:</p>
<ol>
<li value="1">Create<a id="_idIndexMarker1340"/> the <strong class="source-inline">src/middleware</strong> and <strong class="source-inline">test/middleware</strong> directories, and then open the <strong class="source-inline">test/middleware/localStorage.test.js</strong> file. To make a start, define two spies, <strong class="source-inline">getItemSpy</strong> and <strong class="source-inline">setItemSpy</strong>, which will make up the new object. We have to use <strong class="source-inline">Object.defineProperty</strong> to set these spies because the <strong class="source-inline">window.localStorage</strong> property is write protected:<p class="source-code">import {</p><p class="source-code">  save</p><p class="source-code">} from "../../src/middleware/localStorage";</p><p class="source-code">describe("localStorage", () =&gt; {</p><p class="source-code">  const data = { a: 123 };</p><p class="source-code">  let getItemSpy = jest.fn();</p><p class="source-code">  let setItemSpy = jest.fn();</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    Object.defineProperty(window, "localStorage", {</p><p class="source-code">      value: {</p><p class="source-code">        getItem: getItemSpy,</p><p class="source-code">        setItem: setItemSpy</p><p class="source-code">      }});</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Let’s write our first test for the middleware. This test simply asserts that the middleware does what all middleware should, which is to call <strong class="source-inline">next(action)</strong>. Redux middleware functions have complicated semantics, being functions that return functions <a id="_idIndexMarker1341"/>that return functions, but our tests will make short work of that:<p class="source-code">describe("save middleware", () =&gt; {</p><p class="source-code">  const name = "script name";</p><p class="source-code">  const parsedTokens = ["forward 10"];</p><p class="source-code">  const state = { script: { name, parsedTokens } };</p><p class="source-code">  const action = { type: "ANYTHING" };</p><p class="source-code">  const store = { getState: () =&gt; state };</p><p class="source-code">  let next;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    next = jest.fn();</p><p class="source-code">  });</p><p class="source-code">  const callMiddleware = () =&gt;</p><p class="source-code">    save(store)(next)(action);</p><p class="source-code">  it("calls next with the action", () =&gt; {</p><p class="source-code">    callMiddleware();</p><p class="source-code">    expect(next).toBeCalledWith(action);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make that pass, create the <strong class="source-inline">src/middleware/localStorage.js</strong> file and add the following definition:<p class="source-code">export const save = store =&gt; next =&gt; action =&gt; {</p><p class="source-code">  next(action);</p><p class="source-code">};</p></li>
<li>The next test checks that we return that value:<p class="source-code">it("returns the result of next action", () =&gt; {</p><p class="source-code">  next.mockReturnValue({ a : 123 });</p><p class="source-code">  expect(callMiddleware()).toEqual({ a: 123 });</p><p class="source-code">});</p></li>
<li>Update<a id="_idIndexMarker1342"/> the <strong class="source-inline">save</strong> function to return that value:<p class="source-code">export const save = store =&gt; next =&gt; action =&gt; {</p><p class="source-code"><strong class="bold">  return </strong>next(action);</p><p class="source-code">};</p></li>
<li>Now, check that we add the stringified value to local storage:<p class="source-code">it("saves the current state of the store in localStorage", () =&gt; {</p><p class="source-code">  callMiddleware();</p><p class="source-code">  expect(setItemSpy).toBeCalledWith("name", name);</p><p class="source-code">  expect(setItemSpy).toBeCalledWith(</p><p class="source-code">    "parsedTokens",</p><p class="source-code">    JSON.stringify(parsedTokens)</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that pass, complete the implementation of the <strong class="source-inline">save</strong> middleware:<p class="source-code">export const save = store =&gt; next =&gt; action =&gt; {</p><p class="source-code">  <strong class="bold">const result = next(action);</strong></p><p class="source-code"><strong class="bold">  const {</strong></p><p class="source-code"><strong class="bold">    script: { name, parsedTokens }</strong></p><p class="source-code"><strong class="bold">  } = store.getState();</strong></p><p class="source-code"><strong class="bold">  localStorage.setItem("name", name);</strong></p><p class="source-code"><strong class="bold">  localStorage.setItem(</strong></p><p class="source-code"><strong class="bold">    "parsedTokens",</strong></p><p class="source-code"><strong class="bold">    JSON.stringify(parsedTokens)</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">  return result;</strong></p><p class="source-code">};</p></li>
<li>Let’s move <a id="_idIndexMarker1343"/>on to the <strong class="source-inline">load</strong> function, which isn’t middleware but there’s no harm in placing it in the same file. Create a new <strong class="source-inline">describe</strong> block with the following test, ensuring <strong class="source-inline">import</strong> is updated as well:<p class="source-code">import {</p><p class="source-code"><strong class="bold">  load, </strong>save</p><p class="source-code">} from "../../src/middleware/localStorage";</p><p class="source-code">...</p><p class="source-code">describe("load", () =&gt; {</p><p class="source-code">  describe("with saved data", () =&gt; {</p><p class="source-code">    beforeEach(() =&gt; {</p><p class="source-code">      getItemSpy.mockReturnValueOnce("script name");</p><p class="source-code">      getItemSpy.mockReturnValueOnce(</p><p class="source-code">        JSON.stringify([ { a: 123 } ])</p><p class="source-code">      );</p><p class="source-code">    });</p><p class="source-code">    it("retrieves state from localStorage", () =&gt; {</p><p class="source-code">      load();</p><p class="source-code">      expect(getItemSpy).toBeCalledWith("name");</p><p class="source-code">      expect(getItemSpy).toHaveBeenLastCalledWith(</p><p class="source-code">        "parsedTokens"</p><p class="source-code">      );</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that <a id="_idIndexMarker1344"/>pass by defining a new function in the production code, by adding <strong class="source-inline">load</strong>, just below the definition of <strong class="source-inline">save</strong>:<p class="source-code">export const load = () =&gt; {</p><p class="source-code">  localStorage.getItem("name");</p><p class="source-code">  localStorage.getItem("parsedTokens");</p><p class="source-code">};</p></li>
<li>Now to send this data to the parser. For this, we’ll need a <strong class="source-inline">parserSpy</strong> spy function that we use to spy on the parser’s <strong class="source-inline">parseTokens</strong> function:<p class="source-code">describe("load", () =&gt; {</p><p class="source-code">  let parserSpy;</p><p class="source-code">  describe("with saved data", () =&gt; {</p><p class="source-code">    beforeEach(() =&gt; {</p><p class="source-code">      parserSpy = jest.fn();</p><p class="source-code">      parser.parseTokens = parserSpy;</p><p class="source-code">      ...</p><p class="source-code">    });</p><p class="source-code">    it("calls to parsedTokens to retrieve data", () =&gt; {</p><p class="source-code">      load();</p><p class="source-code">      expect(parserSpy).toBeCalledWith(</p><p class="source-code">        [ { a: 123 } ],</p><p class="source-code">        parser.emptyState</p><p class="source-code">      );</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Add the<a id="_idIndexMarker1345"/> following production code to make that pass:<p class="source-code">import * as parser from "../parser";</p><p class="source-code">export const load = () =&gt; {</p><p class="source-code">  localStorage.getItem("name");</p><p class="source-code">  <strong class="bold">const parsedTokens = JSON.parse(</strong></p><p class="source-code">    localStorage.getItem("parsedTokens")</p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">  parser.parseTokens(parsedTokens, parser.emptyState);</strong></p><p class="source-code">};</p></li>
<li>The next test makes sure the data is returned in the right format:<p class="source-code">it("returns re-parsed draw commands", () =&gt; {</p><p class="source-code">  parserSpy.mockReturnValue({ drawCommands: [] });</p><p class="source-code">  expect(</p><p class="source-code">    load().script</p><p class="source-code">  ).toHaveProperty("drawCommands", []);</p><p class="source-code">});</p></li>
<li>Make that<a id="_idIndexMarker1346"/> pass by returning an object with the parsed response:<p class="source-code">export const load = () =&gt; {</p><p class="source-code">  localStorage.getItem("name");</p><p class="source-code">  const parsedTokens = JSON.parse(</p><p class="source-code">    localStorage.getItem("parsedTokens")</p><p class="source-code">  );</p><p class="source-code">  <strong class="bold">return {</strong></p><p class="source-code"><strong class="bold">    script:</strong> parser.parseTokens(</p><p class="source-code">      parsedTokens, parser.emptyState</p><p class="source-code">    )</p><p class="source-code"><strong class="bold">  };</strong></p><p class="source-code">};</p></li>
<li>Next, let’s add the name to that data structure:<p class="source-code">it("returns name", () =&gt; {</p><p class="source-code">  expect(load().script).toHaveProperty(</p><p class="source-code">    "name",</p><p class="source-code">    "script name"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that pass, first, we need to save the name that’s returned from local storage, and<a id="_idIndexMarker1347"/> then we need to insert it into the <strong class="source-inline">present</strong> object:<p class="source-code">export const load = () =&gt; {</p><p class="source-code"><strong class="bold">  const name = localStorage.getItem("name");</strong></p><p class="source-code">  const parsedTokens = JSON.parse(</p><p class="source-code">    localStorage.getItem("parsedTokens")</p><p class="source-code">  );</p><p class="source-code">  return {</p><p class="source-code">    script: {</p><p class="source-code">      ...parser.parseTokens(</p><p class="source-code">        parsedTokens, parser.initialState</p><p class="source-code">      )<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">      name</strong></p><p class="source-code">    }</p><p class="source-code">  };</p><p class="source-code">};</p></li>
<li>Finally, we need to deal with the case where no state has been saved yet. The <strong class="source-inline">LocalStorage</strong> API gives us <strong class="source-inline">null</strong> back in that case, but we’d like to return <strong class="source-inline">undefined</strong>, which <a id="_idIndexMarker1348"/>will trigger Redux to use the default state. Add this test to the outer <strong class="source-inline">describe</strong> block, so that it won’t pick up the extra <strong class="source-inline">getItemSpy</strong> mock values:<p class="source-code">it("returns undefined if there is no state saved", () =&gt; {</p><p class="source-code">  getItemSpy.mockReturnValue(null);</p><p class="source-code">  expect(load()).not.toBeDefined();</p><p class="source-code">});</p></li>
<li>Make that <a id="_idIndexMarker1349"/>pass by wrapping the <strong class="source-inline">return</strong> statement in an <strong class="source-inline">if</strong> statement:<p class="source-code"><strong class="bold">if (parsedTokens &amp;&amp; parsedTokens !== null) {</strong></p><p class="source-code">  return {</p><p class="source-code">    ...</p><p class="source-code">  };</p><p class="source-code"><strong class="bold">}</strong></p></li>
<li>Open <strong class="source-inline">src/store.js</strong> and modify it to include the new middleware. I’m defining a new function, <strong class="source-inline">configureStoreWithLocalStorage</strong>, so that our tests can continue using <strong class="source-inline">configureStore</strong> without interacting with local storage:<p class="source-code">...</p><p class="source-code"><strong class="bold">import {</strong></p><p class="source-code"><strong class="bold">  save, load</strong></p><p class="source-code"><strong class="bold">} from "./middleware/localStorage";</strong></p><p class="source-code">export const configureStore = (</p><p class="source-code">  storeEnhancers = [],</p><p class="source-code">  initialState = {}</p><p class="source-code">) =&gt; {</p><p class="source-code">  return createStore(</p><p class="source-code">    combineReducers({</p><p class="source-code">      script: withUndoRedo(scriptReducer)</p><p class="source-code">    }),</p><p class="source-code">    initialState,</p><p class="source-code">    compose(</p><p class="source-code">      <strong class="bold">...[</strong></p><p class="source-code"><strong class="bold">        applyMiddleware(save),</strong></p><p class="source-code"><strong class="bold">        ...storeEnhancers</strong></p><p class="source-code"><strong class="bold">      ]</strong></p><p class="source-code">    )</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code"><strong class="bold">export const configureStoreWithLocalStorage = () =&gt;</strong></p><p class="source-code"><strong class="bold">  configureStore(undefined, load());</strong></p></li>
<li>Open <strong class="source-inline">src/index.js</strong> and replace<a id="_idIndexMarker1350"/> the call to <strong class="source-inline">configureStore</strong> with a call to <strong class="source-inline">configureStoreWithLocalStorage</strong>. You’ll also need to update <strong class="source-inline">import</strong> for this new function:<p class="source-code">import {</p><p class="source-code">  <strong class="bold">configureStoreWithLocalStorage</strong></p><p class="source-code">} from "./store";</p><p class="source-code">ReactDOM.createRoot(</p><p class="source-code">  document.getElementById("root")</p><p class="source-code">).render(</p><p class="source-code">  &lt;Provider store={<strong class="bold">configureStoreWithLocalStorage()</strong>}&gt;</p><p class="source-code">    &lt;App /&gt;</p><p class="source-code">  &lt;/Provider&gt;</p><p class="source-code">);</p></li>
</ol>
<p>That’s it. If you like, this is a great time to run the app for a manual test and try it. Open the browser window, type a few commands, and try it out!</p>
<p>If you’re stuck for commands to run a manual test, you can use these:</p>
<pre class="source-code">
forward 100
right 90
to drawSquare
  repeat 4 [ forward 100 right 90 ]
end
drawSquare</pre>
<p>These commands exercise most of the functionality within the interpreter and display. They’ll come in handy in <a href="B18423_15.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>, <em class="italic">Adding Animation</em>, when you’ll want to be manually testing as you make changes.</p>
<p>You’ve learned<a id="_idIndexMarker1351"/> how to<a id="_idIndexMarker1352"/> test-drive Redux middleware. For the final part of the chapter, we will write another redu<a id="_idTextAnchor294"/>cer, this time one that helps us manipulate the browser’s keyboard focus.</p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor295"/>Changing keyboard focus</h1>
<p>The user of our <a id="_idIndexMarker1353"/>application will, most of the time, be typing in the prompt at the bottom right of the screen. To help them out, we’ll move the keyboard focus to the prompt when the app is launched. We should also do this when another element—such as the name text field or the menu buttons—has been used but has finished its job. Then, the focus should revert back to the prompt, ready for another instruction.</p>
<p>React doesn’t support setting focus, so we need to use a <strong class="bold">React ref</strong> on our components and then drop it into the DOM API.</p>
<p>We’ll do this via a Redux reducer. It will have two actions: <strong class="source-inline">PROMPT_FOCUS_REQUEST</strong> and <strong class="source-inline">PROMPT_HAS_FOCUSED</strong>. Any of the React components in our application will be able to <a id="_idIndexMarker1354"/>dispatch the first action. The <strong class="source-inline">Prompt</strong> comp<a id="_idTextAnchor296"/>onent will listen for it and then dispatch the second, once it has focused.</p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor297"/>Writing the reducer</h2>
<p>We’ll<a id="_idIndexMarker1355"/> start, as ever, with the reducer:</p>
<ol>
<li value="1">Create a new <a id="_idIndexMarker1356"/>file named <strong class="source-inline">test/reducers/environment.test.js</strong> and add the following <strong class="source-inline">describe</strong> block. This covers the basic case of the reducer needing to return the default state when <strong class="source-inline">undefined</strong> is passed to it:<p class="source-code">import {</p><p class="source-code">  environmentReducer as reducer</p><p class="source-code">} from "../../src/reducers/environment";</p><p class="source-code">describe("environmentReducer", () =&gt; {</p><p class="source-code">  it("returns default state when existing state is undefined", () =&gt; {</p><p class="source-code">    expect(reducer(undefined, {})).toEqual({</p><p class="source-code">      promptFocusRequest: false</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make the test pass with the following code, in a file named <strong class="source-inline">src/reducers/environment.js</strong>. Since we’ve built reducers before, we know where we’re going with this one:<p class="source-code">const defaultState = {</p><p class="source-code">  promptFocusRequest: false</p><p class="source-code">};</p><p class="source-code">export const environmentReducer = (</p><p class="source-code">  state = defaultState,</p><p class="source-code">  action) =&gt; {</p><p class="source-code">  return state;</p><p class="source-code">};</p></li>
<li>Add the<a id="_idIndexMarker1357"/> next <a id="_idIndexMarker1358"/>test, which checks that we set the <strong class="source-inline">promptFocusRequest</strong> value:<p class="source-code">it("sets promptFocusRequest to true when receiving a PROMPT_FOCUS_REQUEST action", () =&gt; {</p><p class="source-code">  expect(</p><p class="source-code">    reducer(</p><p class="source-code">      { promptFocusRequest: false},</p><p class="source-code">      { type: "PROMPT_FOCUS_REQUEST" }</p><p class="source-code">    )</p><p class="source-code">  ).toEqual({</p><p class="source-code">    promptFocusRequest: true</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by adding in a <strong class="source-inline">switch</strong> statement, as shown:<p class="source-code">export const environmentReducer = (</p><p class="source-code">  state = defaultState,</p><p class="source-code">  action</p><p class="source-code">) =&gt; {</p><p class="source-code"><strong class="bold">  switch (action.type) {</strong></p><p class="source-code"><strong class="bold">    case "PROMPT_FOCUS_REQUEST":</strong></p><p class="source-code"><strong class="bold">      return { promptFocusRequest: true };</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">  return state;</p><p class="source-code">};</p></li>
<li>Add the <a id="_idIndexMarker1359"/>final test for this reducer:<p class="source-code">it("sets promptFocusRequest to false when receiving a PROMPT_HAS_FOCUSED action", () =&gt; {</p><p class="source-code">  expect(</p><p class="source-code">    reducer(</p><p class="source-code">      { promptFocusRequest: true},</p><p class="source-code">      { type: "PROMPT_HAS_FOCUSED" }</p><p class="source-code">    )</p><p class="source-code">  ).toEqual({</p><p class="source-code">    promptFocusRequest: false</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Finally, make that pass by adding another <strong class="source-inline">case</strong> statement:<p class="source-code">export const environmentReducer = (...) =&gt; {</p><p class="source-code">  switch (action.type) {</p><p class="source-code">    ...,</p><p class="source-code"><strong class="bold">    case "PROMPT_HAS_FOCUSED":</strong></p><p class="source-code"><strong class="bold">      return { promptFocusRequest: false };</strong></p><p class="source-code">  }</p><p class="source-code">  ...</p><p class="source-code">}</p></li>
<li>Before we can use the new reducer in our tests, we’ll need to add it to the store. Open up <strong class="source-inline">src/store.js</strong> and<a id="_idIndexMarker1360"/> modify it as follows:<p class="source-code">...</p><p class="source-code"><strong class="bold">import {</strong></p><p class="source-code"><strong class="bold">  environmentReducer</strong></p><p class="source-code"><strong class="bold">} from "./reducers/environment";</strong></p><p class="source-code">export const configureStore = (</p><p class="source-code">  storeEnhancers = [],</p><p class="source-code">  initialState = {}</p><p class="source-code">) =&gt; {</p><p class="source-code">  return createStore(</p><p class="source-code">    combineReducers({</p><p class="source-code">      script: withUndoRedo(logoReducer),</p><p class="source-code"><strong class="bold">      environment: environmentReducer</strong></p><p class="source-code">    }),</p><p class="source-code">    ...</p><p class="source-code">  );</p><p class="source-code">};</p></li>
</ol>
<p>That gives <a id="_idTextAnchor298"/>us<a id="_idIndexMarker1361"/> a new reducer that’s hooked into the Redux store. Now, let’s make use of that.</p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor299"/>Focusing the prompt</h2>
<p>Let’s move on<a id="_idIndexMarker1362"/> to the most difficult part of this: focusing the actual prompt. For this, we’ll need to introduce a React ref:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/Prompt.test.js</strong> and add the following <strong class="source-inline">describe</strong> block at the bottom, nested within the <strong class="source-inline">Prompt</strong> <strong class="source-inline">describe</strong> block. The test uses the <strong class="source-inline">document.activeElement</strong> property, which is the element that currently has focus. It’s also using the <strong class="source-inline">renderInTableWithStore</strong> function, which is the same as the <strong class="source-inline">renderWithStore</strong> helper you’ve seen already, except that the component is first wrapped in a table:<p class="source-code">describe("prompt focus", () =&gt; {</p><p class="source-code">  it("sets focus when component first renders", () =&gt; {</p><p class="source-code">    renderInTableWithStore(&lt;Prompt /&gt;);</p><p class="source-code">    expect(</p><p class="source-code">      document.activeElement</p><p class="source-code">    ).toEqual(textArea());</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Let’s make that pass. We define a new ref <a id="_idIndexMarker1363"/>using the <strong class="source-inline">useRef</strong> hook and add a <strong class="source-inline">useEffect</strong> hook to focus when the component mounts. Make sure to pull out the new constants from the React constant, which is at the top of the file:<p class="source-code">import</p><p class="source-code">  React, { <strong class="bold">useEffect, useRef,</strong> useState }</p><p class="source-code">from "react";</p><p class="source-code">export const Prompt = () =&gt; {</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  const inputRef = useRef();</strong></p><p class="source-code"><strong class="bold">  useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">    inputRef.current.focus();</strong></p><p class="source-code"><strong class="bold">  }, [inputRef]);</strong></p><p class="source-code">  return (</p><p class="source-code">    ...</p><p class="source-code">    &lt;textarea</p><p class="source-code"><strong class="bold">      ref={inputRef}</strong></p><p class="source-code">    /&gt;</p><p class="source-code">    ...</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>For the next test, we’ll<a id="_idIndexMarker1364"/> dispatch an action to the Redux store. Since this test suite hasn’t yet got a test that dispatches actions, we’ll need to add all the plumbing. Start by importing the <strong class="source-inline">dispatchToStore</strong> function into the test suite:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  dispatchToStore,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Now, we need a new helper function that will clear focus. Because focus will be set as soon as the component mounts, we need to unset it again so we can verify the behavior of our focus request. Once we have that helper, we can add the next test:<p class="source-code">const jsdomClearFocus = () =&gt; {</p><p class="source-code">  const node = document.createElement("input");</p><p class="source-code">  document.body.appendChild(node);</p><p class="source-code">  node.focus();</p><p class="source-code">  node.remove();</p><p class="source-code">}</p><p class="source-code">it("calls focus on the underlying DOM element if promptFocusRequest is true", async () =&gt; {</p><p class="source-code">  renderInTableWithStore(&lt;Prompt /&gt;);</p><p class="source-code">  jsdomClearFocus();</p><p class="source-code">  dispatchToStore({ type: "PROMPT_FOCUS_REQUEST" });</p><p class="source-code">  expect(document.activeElement).toEqual(textArea());</p><p class="source-code">});</p></li>
<li>To make<a id="_idIndexMarker1365"/> that pass, first, create a new call to <strong class="source-inline">useSelector</strong> to pull out the <strong class="source-inline">promptFocusRequest</strong> value from the store:<p class="source-code">export const Prompt = () =&gt; {</p><p class="source-code">  const nextInstructionId = ...</p><p class="source-code"><strong class="bold">  const promptFocusRequest = useSelector(</strong></p><p class="source-code"><strong class="bold">    ({ environment: { promptFocusRequest } }) =&gt;</strong></p><p class="source-code"><strong class="bold">      promptFocusRequest</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>Then, add a new effect that will run when <strong class="source-inline">promptFocusRequest</strong> changes. This uses the ref to call the <a id="_idIndexMarker1366"/>DOM’s <strong class="source-inline">focus</strong> method on the HTML element:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  inputRef.current.focus();</p><p class="source-code">}, [promptFocusRequest]);</p></li>
<li>For the next <a id="_idIndexMarker1367"/>test, dispatch an action when the focus has occurred:<p class="source-code">it("dispatches an action notifying that the prompt has focused", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Prompt /&gt;);</p><p class="source-code">  dispatchToStore({ type: "PROMPT_FOCUS_REQUEST" });</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "PROMPT_HAS_FOCUSED" });</p><p class="source-code">});</p></li>
<li>To make that pass, start by adding a new action helper function that we can call within the <strong class="source-inline">Prompt</strong> component:<p class="source-code">const submitEditLine = ...</p><p class="source-code"><strong class="bold">const promptHasFocused = () =&gt; (</strong></p><p class="source-code"><strong class="bold">  { type: "PROMPT_HAS_FOCUSED" }</strong></p><p class="source-code"><strong class="bold">);</strong></p></li>
<li>Finally, call <strong class="source-inline">promptHasFocused</strong> within the <strong class="source-inline">useEffect</strong> hook:<p class="source-code">useEffect(() =&gt;<a id="_idTextAnchor300"/> {</p><p class="source-code">  inputRef.current.focus();</p><p class="source-code"><strong class="bold">  dispatch(promptHasFocused());</strong></p><p class="source-code">}, [promptFocusRequest]);</p></li>
</ol>
<p>There is a slight issue with this last code snippet. The dispatched <strong class="source-inline">PROMPT_HAS_FOCUSED</strong> action will set <strong class="source-inline">promptFocusRequest</strong> back to <strong class="source-inline">false</strong>. That then causes the <strong class="source-inline">useEffect</strong> hook to run a second time, with the component re-rendering. This is clearly not intended, nor is it necessary. However, since it has no discernable <a id="_idIndexMarker1368"/>effect on the user, we can skip fixing it at this time.</p>
<p>This completes the <strong class="source-inline">Prompt</strong> component, which now steals focus anytime the <strong class="source-inline">promptFocusRequest</strong> variable changes value.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor301"/>Requesting focus in other components</h2>
<p>All that’s left is <a id="_idIndexMarker1369"/>to call the request action when required. We’ll do this for <strong class="source-inline">ScriptName</strong>, but you could also do it for the buttons in the menu bar:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/ScriptName.test.js</strong>, find the <strong class="source-inline">describe</strong> block named <strong class="source-inline">when the user hits Enter</strong>:, and add the following test:<p class="source-code">it("dispatches a prompt focus request", () =&gt; {</p><p class="source-code">   return expectRedux(store)</p><p class="source-code">     .toDispatchAnAction()</p><p class="source-code">     .matching({ type: "PROMPT_FOCUS_REQUEST" });</p><p class="source-code">});</p></li>
<li>In <strong class="source-inline">src/ScriptName.js</strong>, modify the component to define an action helper named <strong class="source-inline">promptFocusRequest</strong>:<p class="source-code">const submitScriptName = ...</p><p class="source-code"><strong class="bold">const promptFocusRequest = () =&gt; ({</strong></p><p class="source-code"><strong class="bold">  type: "PROMPT_FOCUS_REQUEST",</strong></p><p class="source-code"><strong class="bold">});</strong></p></li>
<li>Call that from within the edit completion handler:<p class="source-code">const completeEditingScriptName = () =&gt; {</p><p class="source-code">  if (editingScriptName) {</p><p class="source-code">    toggleEditingScriptName();</p><p class="source-code">    dispatch(submitScriptName(updatedScriptName));</p><p class="source-code"><strong class="bold">    dispatch(promptFocusRequest());</strong></p><p class="source-code">  }</p><p class="source-code">};</p></li>
</ol>
<p>That’s it! If you <a id="_idIndexMarker1370"/>build and run now, you’ll see how focus is automatically given to the <strong class="source-inline">prompt</strong> textbox, and if you edit the script name (by clicking on <a id="_idTextAnchor302"/>it, typing something, and then hitting <em class="italic">Enter</em>), you’ll see that focus returns to the prompt.</p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor303"/>Summary</h1>
<p>You should now have a good understanding of test-driving complex Redux reducers and middleware.</p>
<p>First, we added support undo/redo with a Redux decorator reducer. Then, we built Redux middleware to save and load existing states via the browser’s <strong class="source-inline">LocalStorage</strong> API. And finally, we looked at how to test-drive changing the browser’s focus.</p>
<p>In <a id="_idTextAnchor304"/>the next chapter, we’ll look at how to test-drive something much more intricate: animation.</p>
<h1 id="_idParaDest-251"><a id="_idTextAnchor305"/>Further reading</h1>
<p>Wikipedia entry on the Logo programming language:</p>
<p><a href="https://en.wikipedia.org/wiki/Logo_(programming_language)">https://en.wikipedia.org/wiki/Logo_(programming_language)</a></p>
</div>
<div>
<div id="_idContainer046">
</div>
</div>
</div></body></html>