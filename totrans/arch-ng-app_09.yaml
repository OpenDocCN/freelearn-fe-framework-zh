- en: NgRx – Reduxing that Angular App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the last chapter of this book. The time has come to understand
    the NgRx library. So far, different topics have been covered, making you as a
    reader more used to thinking about things such as immutable data structures and
    reactive programming. We did all this so it would be easier for you to digest
    what is to come in this chapter. NgRx is an implementation of Redux made for Angular,
    so concepts such as store, action creators, actions, selectors, and reducers are
    well used. What you have hopefully picked up on by reading the past chapters is
    how Redux works. By reading the previous chapter, you will have discovered how
    what you learned about Redux translates to NgRx and its principles on how to organize
    your code. This chapter aims to describe the core library `@ngrx-store`, how to
    handle side effects with `@ngrx-effects`, and how to debug like a pro with `@ngrx/store-devtools`,
    among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: State management with `@ngrx/store`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling side effects with `@ngrx/effects`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to debug with `@ngrx/store-devtools`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to capture and transform the router state with `@ngrx/router-store`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgRx overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NgRx consists of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ngrx/store`: This is the core that contains a way for us to maintain state
    and dispatch actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ngrx/effects`: This will handle side effects such as, AJAX requests, for
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ngrx/router-store`: This ensures we can integrate NgRx with the Angular routing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ngrx/store-devtools`: This will install a tool that gives us the opportunity
    to debug NgRx by, for example, giving us a time travel debugging functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ngrx/entity`: This is a library that helps us manage record collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ngrx/schematics`: This is a scaffolder library that helps you when using
    NgRx.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A word on state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some components must have state. When there is a need for another component
    to know about that very same state, the first component needs to find a way to
    communicate that to the other component. There are many ways to achieve this.
    One way is to ensure that all state that should be shared lives in a centralized
    store. Think of this store as a single source of truth, from which all components
    can read. Every state does not necessarily need to end up in the centralized store,
    as the state may only concern a specific component. Before NgRx and Redux, one
    way of solving this was to put everything in a globally accessible object or service.
    The store, as we mentioned, is just that. It is globally accessible in the sense
    that it can be injected into any component that might need it. A word of caution;
    even though it is tempting to put all of our state in our store, we really shouldn't.
    State that we notice needs to be shared between components is worth putting there.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit we get from having a centralized store is that it is very easy
    to save down the application's state for later recovery. If state only lives in
    one place, a user, or the system, can easily persist that state to a backend so
    that next time, if they want to continue from where they left off, they can easily
    do so by querying the backend for that state. So, there does exist another reason
    for wanting a centralized store other than wanting to share the data between many
    components.
  prefs: []
  type: TYPE_NORMAL
- en: '@ngrx/store – state management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the files in this section points to `Chapter9/State` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the moment we have been waiting for. How do we actually get started?
    It''s really easy. Let''s first ensure we have installed Angular CLI. We do so
    by typing the following in our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we need an Angular project. We use the Angular CLI for that,
    and scaffold ourselves a new project using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the scaffolding process is done, we navigate to our newly created director
    project with a simple `cd <project dir>`.We want to use the core functionality
    provided in the `@ngrx/store` library, therefore we install it by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now open up the `app.module.ts` file in our scaffolded project. The
    time has come to import and register NgRx with `AppModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we''ve highlighted the important part, which is importing
    `StoreModule` and registering it with `AppModule` by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are telling the store what state should exist, which is `counter`,
    and that `counterReducer` is the reducer meant to take care of that slice of state.
    As you can see, the code doesn''t quite work yet because we haven''t created `counterReducer`
    yet, let''s do that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Hopefully, you have read [Chapter 8](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml),
    *Redux*, and understand why we write the reducer file as we have done. Let''s
    recap a bit, and declare that a reducer is just a function that takes a state
    and produces a new state given an action. It''s also important to stress that
    reducers are so called pure functions that do not change the state, but produce
    a new state, given the old state plus the incoming action. Let''s show here how
    we would theoretically use our reducer if we wanted to use it outside of Redux.
    We do this just to demonstrate how reducers work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from this, we start off with an initial value of `0`, and it
    computes a new value that results in `1`. Upon the second execution of the function,
    we provide it with the existing state, which has the value `0`. This results in
    our state now being `2`. This may look simple, but this is pretty much as complicated
    as a reducer can get. Normally, you wouldn''t execute the reducer function yourself
    but rather register it with the store and dispatch actions towards the store.
    This will lead to the reducer being invoked. So, how do we tell the store to dispatch?
    Simple, we use the function `dispatch()` on the store. For this code, let''s move
    to the `app.component.ts` file. We also need to create a file called `app-state.ts`,
    which is an interface, a typed representation of our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can see from the preceding code is how we inject a store service into
    the constructor, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, we call `store.select("count")`, which means we are asking our
    store for the `count` property part of its state as that''s all this component
    cares about. A call `store.select()` returns an `Observable` that when resolved
    contains a value. We can easily show this value by adding it to the template markup,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That takes care of getting and displaying the state. What about dispatching
    an action? The store instance has a method on it called `dispatch()`, which takes
    an object containing the property type. So the following is perfectly good input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build out our component a little, and create some methods and markup
    that will allow us to dispatch actions and see the end result of doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We added the `increment()` and `decrement()` methods to the class body, and
    also added two buttons to the markup that invoke said functions. Trying this out,
    we can see how our UI is updated for every press of the button. The reason for
    this working is, of course, that each dispatched action calls our `counterReducer`
    implicitly, and also because we hold a reference to our state in the form of the
    `counter$` variable. As this is an `Observable`, it means it will be updated when
    a change happens. The change is then pushed out to our `counter$` variable when
    an action is dispatched. It's simple, but powerful.
  prefs: []
  type: TYPE_NORMAL
- en: A more complex example – a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have so far learned how to set up NgRx by importing and registering its module.
    We have also been taught about the `select()` function that gives us a slice of
    state, and the `dispatch()` function that allows us to dispatch an action. These
    are the basics, we will use these very same basics and create a new reducer to
    reinforce what we already know, while introducing the concept payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tell the store we have a new state, `jedis`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `jediListReducer` and register it with the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a component that supports showing our `jediList`, but is also able to
    dispatch actions that will change our slice of state `jedis`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s get down to business by defining our reducer, `jediListReducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain what goes on here for each case in our switch. First off, we
    have `ADD_JEDI`. We take our `action.payload` and add it to the list. Or technically,
    we take our existing list and construct a new list based on the old list, plus
    our new list item found in `action.payload`. Secondly we have `REMOVE_JEDI` that
    uses the `filter()` function to take away the list item that we don''t want to
    see. Lastly we have `LOAD_JEDIS` that takes in an existing list and replaces our
    state. Now, let''s demo this reducer by invoking it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s register this reducer with the store. We will therefore return
    to `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we just added a new state to our store, we should make the `app-state.ts`
    file aware of it, and we should also create a `Jedi` model so we can use that
    in our component later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that `jediListReducer`, as well as the
    state `jediList`, is added to the object that serves as input to the `StoreModule.forRoot()`
    function. This means that NgRx is aware of this state and will let us retrieve
    it and dispatch actions to it. To do so, let''s build a component with just that.
    We need to create the `jedi-list.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is to register this component with our module,
    and we should have a working application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following files points to the demo project `Chapter9/BestPractices`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have created some working code, but it could look a lot better,
    and be less error prone as well. There are steps we can take to improve the code,
    those are:'
  prefs: []
  type: TYPE_NORMAL
- en: Get rid of so-called magic strings and rely on constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a default state to your reducer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create so-called action creators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move everything into a dedicated module and split up it up into several components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at our first bullet point. Given the type of actions we
    perform on our `jediList`, we can create a `constants.ts` file for them, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we refer to these actions we can instead import this file and use
    these constants instead, decreasing the risk of us mistyping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we can do is to simplify the creation of actions by creating
    the so-called action creator. We are so far used to typing the following to create
    an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A better habit here is to create a function that does this for us. For the
    case with the list reducer, there are three possible actions that can take place,
    so let''s put all these in a `actions.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The point of creating the `actions.ts` file was so that we would have to write
    less code when we dispatch actions. Instead of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now write this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A cleanup example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following scenario can be found in the **`Chapter9/BestPractices`** folder
    of the code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain where we are coming from, and why there might be a need to clean
    up your code. If you are starting out with a very simple app, you might add the
    reducer, the actions, and components in the root module of your project. This
    might create a mess as soon as you want to add another component. Let''s illustrate
    what our file structure might look like before we start cleaning up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From this, it's pretty clear that this will only hold up if our app will only
    consist of that one component. As soon as we add more components, things will
    start to look messy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list what we need to do to create a better file structure, but also
    utilize the action creator, constants, and reducers in the best way possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a dedicated feature module and directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create action constants that the reducer and actions file can use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an action creator file with all the actions we mean to perform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a reducer that handles dispatches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `JediList` component that is able to handle all actions we mean to
    use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register our reducer and state with the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a dedicated directory and feature module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For that reason, we want to place everything in a dedicated directory, `jedi`.
    The easiest way to do that is to use the Angular CLI and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Place yourself in your newly created `jedi` directory and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the following structure to your `jedi` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we have created the `jedi-list.component` and its belonging files
    in a previous section, so we will remove those scaffolded files for now and just
    move in the already created files under the `jedi-list` directory. So, your directory
    should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Add reducer and constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our reducer, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next order of business is our constants file, which has already been created
    and just need to move, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A general tip is if you find the number of components and files growing, consider
    creating a dedicated directory for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the action creator file that we have also already created, and that
    we just need to move to our `jedi` directory, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our directory should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Moving the component to our jedi directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next point is about moving our `JediListComponent` to our `jedi` directory,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After moving our `jedi-list` component, our directory should now look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Registering our reducer with the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, we just need to do a slight update to the `app.module.ts` file to have
    it point correctly to our `JediListReducer`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Leveraging types and feature modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following files is pointing to the demo project `Chapter9/FeatureModules`.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, one thing we can definitely improve is how we tell the `StoreModule` about
    what state and reducers exist in our app. Let''s do a quick recap and look at
    its current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we are essentially feeding the `forRoot()` method an object. What''s wrong
    with that? Well, imagine you have ten different feature modules and every feature
    module may have three to four states, then the object you pass to `forRoot()`
    will grow in size and the number of imports that you need to do in your `app.module.ts`
    will grow. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Going from forRoot() to forFeature()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To solve the mess we are creating in `app.module.ts,` we will now use a method
    called `forFeature()` on `StoreModule` that will allow us to set up the states
    we need per feature module. Let''s take the existing setup and refactor that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We move our two reducer entries to their respective feature modules, `counter.module.ts`
    and `jedi.module.ts`. That would now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We left out the implementation on purpose here because we need to take a step
    back. Remember when we called `StoreModule.forRoot()`, we could just pass it an
    object. It doesn''t look quite the same with `forFeature()`. There is a little
    bit of difference, so let''s try to explain what that difference is. We are used
    to setting up our store by passing it an object, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Setting up forFeature() from string to selection function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can set it up in pretty much the same way, but we need to pass it the name
    of a feature as well. Let''s take our `counter.module.ts` and add a little code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will change how we select our state, though. Imagine we are inside of
    `counter.component.ts` with the current implementation looking like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we changed what the state looked like in `counter.module.ts`, we now
    need to reflect that in `counter.component.ts`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Introducing NgRx types for setting up the state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we have learned how we move the store state declaration from
    `app.module.ts` and register it in each feature module instead. This will provide
    us with a little more order. Let''s take a close look at the types used for registering
    state. `ActionReducerMap` is a type we have been using implicitly so far. We have
    been using it every time we call `StoreModule.forRoot()` or `StoreModule.forFeature()`.
    We have been using it in the sense that, the object we pass containing state and
    their reducers consists of this type. Let''s prove that is the case by turning
    to our `counter.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change that a bit, to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see that we are leveraging `ActionReducerMap`, which is a generic
    that forces us to provide it with a type. In this case, the type is `CounterState`.
    Running this code should just work. So, why use `ActionReducerMap` explicitly
    like this?
  prefs: []
  type: TYPE_NORMAL
- en: Giving forFeature() a type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, the `forFeature()` method is a generic as well, and we can specify this
    one explicitly like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This protects us from adding a state mapping object that it does not expect
    to the `forFeature()` method. For instance, the following would render an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that we are providing the wrong type to the `forFeature()`
    method. It expects a reducer parameter to be something of type `ActionReducerMap<CounterState>`,
    which it clearly is not, as we are sending in `ActionReducerMap<State>`.
  prefs: []
  type: TYPE_NORMAL
- en: Several states in the same feature module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following scenario can be found in the `Chapter9/TypesDemo` folder of the
    code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so now we know about the `ActionReducerMap` type, and we also know that
    we can provide a type to the `forFeature()` method and make it safer to use. What
    happens if we''ve got several states in our feature module, what then? The answer
    is quite simple, but let''s first have a closer look at what we mean exactly by
    several states. Our counter module contains the `counter.value` state. This is
    displayed in our `counter.component.ts`. If we want to add a `counter.list` state,
    we need to add the supporting constants, reducers, actions, and a component file
    so we can properly display it. Our file structure should therefore look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We need to add implementation for all of these bold files.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the counter-list reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off with the reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This reducer supports two types, `ADD_COUNTER_ITEM` and `REMOVE_COUNTER_ITEM`,
    which will let us add and remove items from the list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This one comes in two parts, the HTML template and the class file. Let''s start
    with the class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML template file is quite simple, and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are supporting the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing a list of counter objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an item to the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an item from the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up is adding the constants. Constants are a nice thing to have; they protect
    us from making mistakes due to us mistyping when we deal with action creators
    as well as reducers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Adding the action methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also need to define the action methods. These are just functions that will
    help us create our actions, so it''s less for us to type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Adding the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to type what our counter-list should contain. For that we need to create
    a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Register our reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We do need to add and implement all the files in bold, but we also need to
    update the `counter.module.ts` file so we are able to handle the added state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We need to add a `CombinedState` interface that represents all of our reducers
    with their state. Lastly, we change the call to `StoreModule.forFeature()`. That
    concludes how we deal with several states and reducers within the same module.
  prefs: []
  type: TYPE_NORMAL
- en: Component architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different kinds of components. Two types of components are of interest
    in the context of NgRx: smart components and dumb components.'
  prefs: []
  type: TYPE_NORMAL
- en: Smart components are also called container components. They should be on the
    highest level of your application, and handle routes. For example, `ProductsComponent`
    should be a container component if it handles the `route/products`. It should
    also know about the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a dumb component is that it has no knowledge of a store and
    relies solely on the `@Input` and `@Output` properties—it''s all about presentation,
    which is why it is also called a presentational component. A presentational component
    in this context can therefore be a `ProductListComponent` or a `ProductCreateComponent`.
    A quick overview of a feature module could therefore look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a small code example so you get the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Our `ProductsComponent` is responsible for handling the route to `/products`.
    `ProductsListComponent` is a dumb component and just gets a list assigned to it
    that it is more than happy to render to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '@ngrx/store-devtools – debugging'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following scenario can be found in the code repository under `Chapter9/DevTools`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three things we need to do to get DevTools to work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the NPM package: `` npm install @ngrx/store-devtools --save`.` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install the Chrome extension: `http://extension.remotedev.io/`. This is called
    the Redux DevTools extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set it up in your Angular module: this requires us to import DevTools into
    our Angular project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Providing we have done the two first steps, we should only have the set up
    stage left, so we need to open up the `app.module.ts` file for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, so now everything is set up and we are ready to take our application for
    a spin and see what our debug tool can tell us. Let''s start up our application
    with `ng serve` and surf to `http://localhost:4200/`. First thing we want to do
    is open developer tools in Chrome and click on a tab called Redux. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7818d9f-9121-49c7-af28-4e4f4524deae.png)'
  prefs: []
  type: TYPE_IMG
- en: Redux tab
  prefs: []
  type: TYPE_NORMAL
- en: 'To the left we have our application UI, and to the right we have our Redux
    plugin. At this point, no actions have been carried out other than the initialization
    of the store, which we can see under the plugin part marked as Inspector. There
    is but one log entry, `@ngrx/store/init`. Let''s interact with the UI by clicking
    on the Increment button and see what happens with our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb2388fa-38d0-4a20-b48d-2b8c23239336.png)'
  prefs: []
  type: TYPE_IMG
- en: Increment button
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have a new entry called INCREMENT. Two things are of interest
    now from a debug perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: What actions were dispatched?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What impact did these actions have on the store?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We learn the answer to both these questions by interacting with the tab buttons
    on the right-hand side of our plugin. The button called Action will tell us what
    action was dispatched and what payload it had, if any:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95fceeaa-999a-406f-b37f-a47dce810345.png)'
  prefs: []
  type: TYPE_IMG
- en: Action button
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, it is clearly stated that an action with type value Increment was dispatched.
    Now to our second question; what was the impact to our store? To find that out,
    we simply click the State button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae545d45-0bca-445c-9082-09af2a3d29c8.png)'
  prefs: []
  type: TYPE_IMG
- en: State button
  prefs: []
  type: TYPE_NORMAL
- en: 'Our state tells us it consists of three properties, `count`, `todos` and `jediList`.
    Our `count` property has the value 1, and is the one affected by us clicking the
    Increment button. Let''s hit the Increment button a few more times to see that
    really is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54f3ef2f-6319-4ab2-88c4-1612837dbb4a.png)'
  prefs: []
  type: TYPE_IMG
- en: Increment button
  prefs: []
  type: TYPE_NORMAL
- en: We now see that our `count` property has the value `3`, and we have three entries
    of Increment actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s talk about a really cool feature, time-travel debugging. Yes, you
    read that correctly, we can control time in our store by replaying dispatched
    actions, and even change history by removing dispatched actions, all in the name
    of debugging. The Redux plugin gives us several ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on a specific dispatched action on your left, and choose to skip dispatching
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a slider to control and replay all the events, and traverse back and forth
    in time as you see fit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s investigate the first way — click on a specific action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/536749d5-d146-47c5-b158-b4e21df2aa0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on a specific action
  prefs: []
  type: TYPE_NORMAL
- en: Here we've clicked on the Skip button for one dispatch action and the end result
    is that this dispatched action is removed, which is indicated by the action being
    overstricken. We can also see that our `count` property now has the value `2`,
    as the action never took place. We can easily toggle this back if we want to by
    hitting Skip again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned there was another way to control the flow of dispatched actions,
    namely by using a slider. There is a button called Slider that toggles the slider.
    Clicking it results in us being shown a slider control with a Play button, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0997df04-8a9a-47f8-a426-0e765c7139d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Play button
  prefs: []
  type: TYPE_NORMAL
- en: If you press the Play button, it will simply play all the dispatched actions.
    However, if you choose to interact with the cursor on the slider itself you are
    able to pull it both to the left, to move back in time, and to the right, to move
    forward in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the Redux plugin is a truly powerful tool to use in order to
    quickly gain an understanding of the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: What your app's state is at a given point in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What part of the UI leads to what effects in the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '@ngrx/effects – working with side effects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have a basic understanding of NgRx. We know how to set up
    our state and create all the artifacts that go with it such as actions, action
    creators, and reducers. Additionally, we have also gained familiarity with the
    Redux plugin for Chrome and understood what a valuable tool it can be to help
    us quickly gain an understanding of the state in our app, and most importantly
    how it can aid us in debugging any problems we may have related to NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the time has come to talk about something that doesn't quite fit in to
    our organized and synchronous world of reducers and actions. I am talking about
    something called side effects. Side effects are operations such as accessing files
    or network resources, and is not really related to our applications state even
    though they may be the vessels that contain the data we want, or be the place
    we persist data to. As we just said, a dispatched action is dispatched in a synchronous
    way and the change to our state happens straight away. A side effect is something
    that may take time. Imagine that we access a large file or ask for a resource
    over the network using AJAX. This request will finish sometime in the future and,
    when done, it may affect our state. How do we make these time consuming and asynchronous
    operations fit in with our synchronous and momentary world? The answer in NgRx
    is a library called `@ngrx/effects`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing it is as easy as performing the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to set it up. The setup can be seen as consisting of two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create our effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the effect with the `EffectsModule`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An effect is just an injectable service that listens for a specific action.
    Once the effect is in focus, it can carry out a number of operations and transformations
    before leaving over control. It leaves over control by dispatching an action.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first effect – a realistic scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following scenario can be found in the code repository under `Chapter9/DemoEffects`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sounds a bit cryptic, so let''s take a realistic scenario. You want to
    fetch products using AJAX from an endpoint. If you think about what you are about
    to undertake in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch a `FETCHING_PRODUCTS`, this sets up our state so we can see that an
    AJAX request is under way and we can thereby use this to display a spinner for
    as long as the AJAX request is waiting to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform an AJAX call and retrieve your products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If successfully retrieving the products, then dispatch `FETCHING_PRODUCTS_SUCCESSFULLY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an error, then dispatch `FETCHING_PRODUCTS_ERROR`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s solve this task in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a reducer for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create actions and action creators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the preceding effect with our effects module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To perform all of this, we will create a feature module. To do so, we create
    the `product/` directory with the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`product.component.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.actions.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.constants.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.reducer.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.selectors.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.module.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.effect.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these files are known to us before, except for `product.effect.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with our constants file. What we need are constants that will
    support us firing away an AJAX request. We also need a constant for when we get
    our data back successfully, but we also need to cater to any error that might
    occur. This means we need the following three constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Action creators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to expose a number of functions that can build objects for us containing
    a type and a payload property. Depending on what function we invoke, we will assign
    it with a different constant, and of course a different payload, if using one.
    The action creator `fetchProducts()` will create an object where only the type
    is set. This is followed by a `fetchSuccessfully()` action creator, which will
    be invoked once the data comes back from an endpoint. Lastly, we have the `fetchError()`
    action creator, which we will invoke if an error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Reducer with a new type of default state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first glance, the following reducer is just like any reducer you have written
    before. It is a function that takes a parameters'' state and action, and it contains
    a switch construct that switches between different actions. So far, everything
    is familiar. The `initialState` variable is different though. It contains the
    `loading`, `list`, and `error` properties. `loading` is simply a Boolean that
    indicates whether our AJAX request is still pending. `list` is our data property
    that will contain our list of products once they are are returned. The `error`
    property is simply a property that contains the error if any comes back from the
    AJAX request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The effect – listening to a specific dispatched action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we come to the effect. Our effect acts like a listener to a dispatched action.
    This gives us the opportunity to carry out a unit of work, but also to dispatch
    an action once that work is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created all the usual bits that we are used to, so now it is time to
    create our effect that will handle the entire workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect is just a class decorated with the `@Injectable` decorator. It also
    contains two members: one member of `Actions` type and another of the `Observable<Action>`
    type. Actions come from the `@ngrx/effects` module and are nothing more than a
    specialized `Observable` with the `ofType()` method on it. `ofType()` is the method
    that takes a string constant, which is the event we are listening for. In the
    previous code, the `products$` is the `Observable` that we decorate with the `@Effect`
    decorator. Our next step is to connect `products$` with `actions$`, and define
    how our effect should work. We do that with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Ok, so we have set up our effect a little more. The call to `ofType()` ensures
    we set ourselves up to listen to a specific dispatched action. The call to `switchMap()`
    ensures we are able to take the current `Observable` that we are currently on,
    and turn it into something completely different, such as a call to an AJAX service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now return back to our example and see how we can fit in some product-related
    logic in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: What we do in the preceding code is listen to our `FETCHING_PRODUCTS` action
    and carry out a call to an AJAX service. We added a call to the `delay()` operator
    so as to simulate that our AJAX call takes some time to carry out. This will give
    us a chance to show a loading spinner. The `map()` operator ensures we dispatch
    an action when we get the AJAX response back. We can see that we call the action
    creator, `fetchProductsSuccessfully()`, which implicitly calls the reducer and
    sets a new state on the products property.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to register the effect before moving on. We can do so
    in the root module or in the feature module. It''s a very similar call, so let''s
    describe both ways of doing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a feature module, on the other hand, we could be using the `forFeature()`
    method on the `EffectsModule` and call that in our feature module like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Adding a component – introducing selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it, thats all you need to create an effect. We're not done here though,
    we need a component to display our data, as well as a spinner, while we are waiting
    for the AJAX request to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, first things first: what do we know of components that should be using
    NgRx? The obvious answer is that they should be injecting the store so we can
    listen to a slice of state from the store. The way we listen to a slice of state
    is by calling the stores `select()` function. This will return an `Observable`.
    We know we can easily show Observables in the template through the use of the
    async pipe. So let''s start sketching our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This part of our component here shouldn''t come as too much of a surprise;
    we inject the store into the constructor, call `select()`, and get an Observable
    back. But, there is a *but* here, we are calling the `select()` method differently.
    We used to pass a string to the `select()` function, and now we pass it a function.
    Why is that? Well, because we changed how our state looked. Let''s show our new
    state again, for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows that we can''t just do `store.select("products")`
    because that would give us the whole object back. So we need a way to dig into
    the previous object in order to get a hold of the list property that should contain
    our list of products. The way to do that is to use the variant of the `select`
    method that takes a function instead. We do just that with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, but will this really be type safe? Won''t the `AppState` interface complain?
    Does it know of our changed state structure? Well, we can tell it knows about
    it, but we need to ensure that our reducer exports an interface that represents
    our new state structure. We therefore change the reducer to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, we need to update the `AppState` interface to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, this made our `AppState` know what kind of beast our `products` property
    really is, and is thereby what makes the `store.select(<Fn>)` call possible. The
    function we gave the `select` method is called a selector, and is actually something
    that doesn''t have to live inside the component. The reason for this is that we
    might want to access that slice of state somewhere else. Let''s therefore create
    a `product.selectors.ts` file. We will add to this later as we keep supporting
    CRUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, so now we have created our selectors file, and we can immediately start
    improving our components code and clean it up a bit before we continue to add
    things to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code looks much better. It''s time to start caring about the other aspect
    of this; what if our HTTP service takes a few seconds, or even one second to return?
    This is a real concern especially with our users being potentially on a 3G connection.
    To take care of this, we grab the `loading` property from our products state and
    use that as a conditional in our template. We will basically say that if the HTTP
    call is still pending, show some text or an image that indicates to the user that
    something is loading. Let''s add that piece of functionality to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also ensure that we show any errors by subscribing to `products.error`.
    We simply update the component with the following alterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, we fire up our application at this point. There is just one teeny tiny
    problem; we don''t see any products at all. Why is that? The explanation is simple.
    We don''t actually dispatch an action that will lead to the AJAX call being made.
    Let''s fix that by adding the following code to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This will of course trigger our effect, which will lead to our HTTP call, which
    will lead to `fetchProductsSuccessfully()` being called, and thereby our state
    will be updated and `products.list` will no longer be an empty array, meaning
    our UI will show a list of products. Success!
  prefs: []
  type: TYPE_NORMAL
- en: Extending our example with the create effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have gone through the full flow of adding an effect, building a
    component, and improved the code with selectors. To make sure we really understand
    how to work with effects and how the application scales with it, let''s add another
    effect, this time let''s add an effect to support an HTTP POST call. What we want
    to happen from an application standpoint is that we add another product to the
    list. This should update the UI and show our added product. What happens data-wise
    is that our store should reflect that change and, as a side effect, a HTTP POST
    should be carried out. We need the following to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: A reducer that supports adding a product to our products list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An effect that listens to a product being added action and that carries out
    a HTTP POST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to register the created effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the constants file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like with the fetching of products, we need to support one action that
    triggers everything. We need another action for when the HTTP request succeeds
    and one last action to support error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Updating the reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point we take our existing `reducer.ts` file and add what we need to
    support adding a product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting how we create the help function, `addProduct()`, which allows
    us to create a new list containing the old content and our new product. It's also
    worth noting that we can group `FETCHING_PRODUCTS_ERROR` and `ADD_PRODUCT_ERROR`
    actions, and also `ADD_PRODUCT` and `ADD_PRODUCT_SUCCESSFULLY`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next order of business is to update our `products.actions.ts` file with
    the new methods that we need to support the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: What is worth noting with the created actions is that the `addProduct()` method
    takes a product as a parameter. The reason for that is that we want the side effect
    to use that as body data for the forthcoming HTTP POST.
  prefs: []
  type: TYPE_NORMAL
- en: Adding another effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are finally ready to construct our effect. It''s going to look very
    similar to the existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do here is to reuse our `ProductEffects` class and add a
    new member `productsAdd$` to it. While at it, we rename `products$` to `productsGet$`.
    As long as we are dealing with products we can keep on adding to this class.
  prefs: []
  type: TYPE_NORMAL
- en: The similarities we see with the existing effect is that we set up our `ofType()`
    operator to listen for a dispatched action of our choice. Thereafter, we continue
    with our side effect, that is the call to the `HttpClient` service that ends up
    being an HTTP POST call.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the effect in our component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We don''t need to do much in our component. Of course, we need to add some
    things in the template to support adding a product. In terms of NgRx, we just
    need to dispatch the `ADD_PRODUCT` action. Let''s have a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Ok, from this code we set up an input control and a button to be able to handle
    the user inputting a new product. For the class, we added the `newProduct` field
    and we also added the `addNewProduct()` method that, in its body, invokes the
    `addProduct()`, method and thereby passes an `ADD_PRODUCT` action. We really don't
    need to do more. Our product addition sets the loading state before carrying out
    the HTTP call, so we can show a spinner if we want, and our error state picks
    up on any errors that might occur and presents them in the UI. Lastly, don't forget
    to add the `FormsModule` to the `import` property in the `product.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Running a demo of the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try out our app, we can simply run the `ng serve` command in the terminal.
    What we expect to see is a screen that for three seconds states it is loading,
    just to be replaced by the fetched data. This will demonstrate both the dispatch
    of the loaded state, as well as us dispatching the data to the store once it arrives.
    The following is the initial screen when our data is yet to arrive. We fire off
    the `FETCHING_PRODUCTS` action, which makes our loading text appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/322941c2-5f58-4f91-97a7-e8c27e8e020b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screen is when our data arrives. Subsequently, we fire off `ADD_PRODUCT_SUCCESSFULLY`
    to ensure that the fetched data is placed in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c69a9eb-ebef-413a-b7f5-47e5509acea2.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through a lot in this chapter. Among the things covered have been
    installing and using the store. To that knowledge, we have added some sound best
    practices to organize your code. It's important to note that consistency is key.
    There are many ways to organize code, so as long as that chosen way remains consistent
    throughout the app, that is the most important factor. With that said, organizing
    your code by domain is what is prescribed for most things Angular. Whether that
    holds true for NgRx is up to you, dear reader. See best practices as a guide rather
    than a rule. Furthermore, we covered side effects and how to handle those with
    `@ngrx/effects`. `@store-devtools` was another thing we covered, which lets us
    use our browser to easily debug our store. In the next, and final, chapter, we
    will cover `@ngrx/schematics` and `@ngrx/entity`, so we really cover everything
    NgRx has to offer us. Also, we will showcase how you can build NgRx yourself to
    gain further understanding on what goes on under the hood. If knowing what goes
    on under the hood isn't exciting to you, then you are in the wrong profession!
    Everything is really set up to make the final chapter a very interesting one.
  prefs: []
  type: TYPE_NORMAL
