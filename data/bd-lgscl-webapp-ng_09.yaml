- en: Create a Local Weather Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地天气 web 应用程序
- en: We will be designing and building a simple Local Weather app with Angular and
    a third-party web API, using an iterative development methodology. You will focus
    on delivering value first while learning about the nuances and optimal ways of
    using Angular, TypeScript, Visual Studio Code, Reactive Programming, and RxJS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计并构建一个简单的使用 Angular 和第三方 web API 的本地天气应用程序，使用迭代式开发方法。您将专注于首先提供价值，同时学习如何使用
    Angular、TypeScript、Visual Studio Code、响应式编程和 RxJS 的微妙之处和最佳方式。
- en: 'In this chapter, you will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Planning out your roadmap using Waffle as a GitHub-connected Kanban board
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Waffle 作为连接到 GitHub 的看板进行路线规划
- en: Crafting a new UI element to display current weather information using components
    and interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作新的 UI 元素来显示当前天气信息，使用组件和接口。
- en: Using Angular Services and HttpClient to retrieve data from OpenWeatherMap APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 服务和 HttpClient 从 OpenWeatherMap API 检索数据
- en: Leveraging observable streams to transform data using RxJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用可观察流使用 RxJS 转换数据
- en: 'The code samples provided in this book require Angular version 5 and 6\. Angular
    5 code is runtime compatible with Angular 6\. Angular 6 will be supported in LTS
    until October 2019\. The most up-to-date versions of the code repositories may
    be found at the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码示例需要 Angular 5 和 6\. Angular 5 代码与 Angular 6 兼容。 Angular 6 将在 2019 年
    10 月之前得到长期支持。最新版本的代码存储库可以在以下找到：
- en: LocalCast Weather, at: [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LocalCast 天气，位置：[Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
- en: LemonMart, at: [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LemonMart，位置：[Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: Planning a feature road map using Waffle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Waffle 规划功能路线图
- en: Building a rough plan of action before you start coding is very important so
    that you and your colleagues or clients are aware of the road map you're planning
    to execute. Whether you're building an app for yourself or for someone else, a
    living backlog of features will always serve as a great reminder when you get
    back to a project after a break or serve as an information radiator that prevents
    constant requests for status updates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，制定一个粗略的行动计划非常重要，这样您和您的同事或客户就知道您计划执行的路线图。无论您是为自己还是为别人构建应用程序，功能的实时备用库将始终作为在休息之后重返项目时的良好提醒，或作为信息辐射器，防止不断请求状态更新。
- en: In Agile development, you may have used various ticketing systems or tools that
    surface or Kanban boards. My favorite tool is Waffle.io, [https://waffle.io/](https://waffle.io/),
    because it directly integrates with your GitHub repository's issues and keeps
    track of the status of issues via labels. This way, you can keep using the tool
    of your choice to interact with your repository and still, effortlessly, radiate
    information. In the next section, you will set up a Waffle project to achieve
    this goal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷开发中，您可能已经使用过各种票务系统或工具，例如看板或看板。我的最爱工具是 Waffle.io，[https://waffle.io/](https://waffle.io/)，因为它直接集成了您的
    GitHub 存储库的问题，并通过标签跟踪问题的状态。这样，您可以继续使用您选择的工具与您的存储库进行交互，并且轻松地发布信息。在接下来的部分中，您将设置一个
    Waffle 项目以实现这个目标。
- en: Setting up a Waffle project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个 Waffle 项目
- en: 'We will now set up our Waffle project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置我们的 Waffle 项目：
- en: Go to Waffle.io [https://waffle.io/](https://waffle.io/).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 Waffle.io [https://waffle.io/](https://waffle.io/)。
- en: Click on Login or Get Started for Free.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击登录或免费开始。
- en: Select Public & Private Repos to allow access to all of your repositories.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择公共和私有存储库，以允许访问您的所有存储库。
- en: Click on Create Project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建项目。
- en: Search for the local-weather-app repository and select it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索本地天气应用程序存储库并选择它。
- en: Hit Continue.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击继续。
- en: 'You will get two starter layout templates, as shown in the following image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得两个初始布局模板，如下图所示：
- en: '![](img/81040eee-bfed-4822-8449-2037e1cbe44e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81040eee-bfed-4822-8449-2037e1cbe44e.png)'
- en: Waffle.io Default Board Layouts
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Waffle.io 默认的看板布局
- en: For this simple project, you will be selecting Basic. However, the Advanced
    layout demonstrates how you can modify the default setup of Waffle, by adding
    additional columns such as Review, to account for testers or product owners participating
    in the process. You can further customize any board to fit your existing process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的项目，您将选择基本。但是，高级布局演示了如何修改 Waffle 的默认设置，通过添加额外的列，如审查，以便测试人员或产品所有者参与过程。您可以进一步定制任何看板以适应您现有的流程。
- en: Select the Basic layout and click on Create Project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择基本布局并点击创建项目。
- en: You will see a new board created for you.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到为您创建的新看板。
- en: '![](img/ae7f8ef6-e282-4468-a474-71e05feab25b.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae7f8ef6-e282-4468-a474-71e05feab25b.png)'
- en: Empty Waffle Board
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 空的Waffle看板
- en: By default, Waffle will serve as a Kanban board. Allowing you to move a task
    from one state to another. However, the default view will show all the issues
    that are present on the repository. To use Waffle as a Scrum board, you need to
    assign issues to GitHub milestones that will represent sprints. You can then use
    the filtering functionality to only display issues from that milestone, or put
    another way from the current sprint.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Waffle将作为看板服务。它允许你将一个任务从一个状态移动到另一个状态。然而，默认视图将显示存储库中存在的所有问题。要将Waffle用作Scrum板，您需要为GitHub里程碑分配问题，这些里程碑将代表迭代。然后，您可以使用过滤功能仅显示来自该里程碑的问题，或者说来自当前迭代。
- en: On Waffle, you can attach story points to issues by clicking on the ![](img/98c10b6b-b94d-4cca-b7aa-8992281c2ce6.jpg) scale
    icon. The columns will automatically show totals and card orders, which represent
    priority, and they will be retained from session to session. Furthermore, you
    can switch to the Metrics view to get Milestone Burndown and Throughput graphs
    and statistics.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Waffle上，您可以通过点击 ![](img/98c10b6b-b94d-4cca-b7aa-8992281c2ce6.jpg) 比例图标给问题附上故事点。列将自动显示总数和卡片顺序，表示优先级，并且将从一个会话保留到另一个会话。此外，您可以切换到度量视图以获取里程碑燃尽图和吞吐量图表和统计信息。
- en: Creating issues for your Local Weather app
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的Local Weather应用程序创建问题
- en: We will now create a backlog of issues that you will use to keep track of your
    progress as you implement the design of your application. When creating issues,
    you should focus on delivering functional iterations that bring some value to
    the user. The technical hurdles you must clear to achieve those results are of
    no interest to your users or clients.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建问题的积压，您将使用这些问题来跟踪在实现应用程序设计时的进度。在创建问题时，您应该专注于提供一些价值给用户的功能迭代。您必须克服的技术障碍对您的用户或客户来说没有任何意义。
- en: 'Here are the features we plan to be building in our first release:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们计划在我们的第一个发布版本中构建的功能：
- en: Display Current Location weather information for the current day
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前位置的当天天气信息
- en: Display forecast information for current location
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前位置的天气预报信息
- en: Add city search capability so that users can see weather information from other
    cities
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加城市搜索功能，使用户可以查看其他城市的天气信息
- en: Add a preferences pane to store the default city for the user
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个首选项窗格，用于存储用户的默认城市
- en: Improve the UX of the app with Angular Material
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular Material改善应用程序的用户体验
- en: 'Go ahead with creating your issues on Waffle or on GitHub; whichever you prefer
    is fine. While creating the scope for Sprint 1, I had some other ideas for features,
    so I just added those issues, but I did not assign them to a person or a milestone.
    I also went ahead and added story points to the issues I intended to work on.
    The following is what the board looks like, as I''m to begin working on the first
    story:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 随意在Waffle或GitHub上创建问题；无论你喜欢哪种方式都可以。在创建第一个迭代的范围时，我对功能有一些其他想法，所以我只是添加了这些问题，但没有指定给某个人或一个里程碑。我还继续为我打算处理的问题添加了故事点。以下是看起来像的看板，因为我将开始处理第一个故事：
- en: '![](img/c0baf628-599c-43ba-92f0-fb70250dff89.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0baf628-599c-43ba-92f0-fb70250dff89.png)'
- en: A snapshot of the initial state of the board at [https://waffle.io/duluca/local-weather-app](https://waffle.io/duluca/local-weather-app)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 板的初始状态快照位于 [https://waffle.io/duluca/local-weather-app](https://waffle.io/duluca/local-weather-app)
- en: Ultimately, Waffle provides an easy-to-use GUI so that non-technical people
    can easily interact with GitHub issues. By allowing non-technical people to participate
    in the development process on GitHub, you unlock the benefit of GitHub becoming
    the single source of information for your entire project. Questions, answers,
    and discussions around features and issues are all tracked as part of GitHub issues,
    instead of being lost in emails. You can also store wiki type documentation on
    GitHub, so by centralizing all project-related information, data, conversations,
    and artifacts on GitHub, you are greatly simplifying a potentially complicated
    interaction of multiple systems that require continued maintenance, at a high
    cost. For private repositories and on-premise Enterprise installations, GitHub
    has a very reasonable cost. If you're sticking with open source, as we are in
    this chapter, all these tools are free.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Waffle 提供了一个易于使用的 GUI，以便非技术人员可以轻松地与 GitHub 问题进行交互。通过允许非技术人员参与 GitHub 上的开发过程，你可以让
    GitHub 成为整个项目的单一信息来源的好处得以发挥。关于功能和问题的问题、答案和讨论都将作为 GitHub 问题的一部分进行跟踪，而不会在电子邮件中丢失。你还可以在
    GitHub 上存储维基类型的文档，因此通过在 GitHub 上集中所有与项目相关的信息、数据、对话和工件，你正在极大地简化可能涉及多个需要持续维护、成本高昂的系统的交互。对于私有知识库和本地企业安装，GitHub
    的费用非常合理。如果你坚持使用开源，就像我们在本章中所做的那样，所有这些工具都是免费的。
- en: As a bonus, I created a rudimentary wiki page on my repository at [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki).
    Note that you can't upload images to `README.md` or wiki pages. To get around
    this limitation, you can create a new issue, upload an image in a comment, and
    copy and paste the URL for it to embed images to `README.md` or wiki pages. In
    the sample wiki, I followed this technique to embed the wireframe design into
    the page.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个额外的福利，我在我的知识库 [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki) 上创建了一个初级的维基页面。请注意，你不能在
    `README.md` 或维基页面上上传图片。为了解决这个限制，你可以创建一个新的问题，上传图片作为评论，然后复制并粘贴它的 URL 来在 `README.md`
    或维基页面上嵌入图片。在示例维基中，我使用了这种技术将线框设计嵌入到页面中。
- en: With a concrete road map in place, you're now ready to start implementing your
    application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个明确的路线图，你现在准备开始实施你的应用程序。
- en: Crafting UI elements using components and interfaces
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件和接口来构建 UI 元素
- en: You will be leveraging Angular components, interfaces, and services to build
    the current weather feature in a decoupled, cohesive, and encapsulated manner.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你将利用 Angular 组件、接口和服务以一种解耦、内聚和封装的方式来构建当前天气功能。
- en: The landing page of an Angular app, by default, resides in `app.component.html`.
    So, start by editing the template of `AppComponent` with rudimentary HTML, laying
    out the initial landing experience for the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用的默认起始页位于`app.component.html`。因此，首先要编辑`AppComponent`的模板，使用基本的 HTML
    布局应用程序的初始起始体验。
- en: We are now beginning the development of Feature 1: Display Current Location
    weather information for the current day, so, you can move the card in Waffle to
    the In Progress column.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始开发 Feature 1：显示当前位置的当天天气信息，所以你可以将 Waffle 中的卡片移动到“进行中”列。
- en: 'We will add a header as an `h1` tag, followed by the tagline of our app as
    a `div` and placeholders for where we may want to display the current weather,
    as demonstrated as shown in the following code block:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个标题作为`h1`标签，接着是我们应用的标语作为`div`，以及为显示当前天气的地方设置的占位符，如下面的代码块演示的那样：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this point, you should run `npm start` and navigate to `http://localhost:5000` on your
    browser so that you can observe the changes you're making in real time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该运行`npm start`，然后在浏览器中导航到`http://localhost:5000`，这样你就可以实时观察到你所做的更改。
- en: Adding an Angular component
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个 Angular 组件
- en: We need to display the current weather information, where `<div>current weather</div>`
    is located. In order to achieve this, you need to build a component that will
    be responsible for displaying the weather data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要显示当前的天气信息，它位于`<div>current weather</div>`的位置。为了实现这一点，你需要构建一个负责显示天气数据的组件。
- en: 'The reason behind creating a separate component is an architectural best practice
    that is codified in the **Model-View-ViewModel** (**MVVM**) design pattern. You
    may have heard of the **Model-View-Controller** (**MVC**) pattern before. Vast
    majority of web-based code written circa 2005-2015 has been written following
    the MVC pattern. MVVM differs, in important ways, from the MVC pattern. As I have
    explained in my 2013 article on DevPro:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单独组件的原因是一个在**模型-视图-ViewModel**（**MVVM**）设计模式中被规范化的架构最佳实践。你可能之前听说了**模型-视图-控制器**（**MVC**）模式。大部分于2005年至2015年之间编写的基于
    web 的代码都是按照 MVC 模式编写的。MVVM 与 MVC 模式在重要方面有所不同。正如我在 2013 年的 DevPro 文章中所解释的：
- en: '[An effective implementation of MVVM] inherently enforces proper separation
    of concerns. Business logic is clearly separated from presentation logic. So when
    a View is developed, it stays developed, because fixing a bug in one View''s functionality
    doesn''t impact other views. On the flip side, if [you use] visual inheritance
    effectively and [create] reusable user controls, fixing a bug in one place can
    fix issues throughout the application.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[MVVM 的高效实现](https://wiki.example.org/mvvm_implementation) 自然强制实现了良好的关注点分离。业务逻辑与呈现逻辑清晰地分开。因此，当一个视图被开发时，它就会保持开发完成，因为修复一个视图功能中的错误不会影响其他视图。另一方面，如果您有效地使用可视化继承并创建可重用的用户控件，修复一个地方的错误可以解决整个应用程序中的问题。'
- en: Angular provides an effective implementation of MVVM.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了 MVVM 的有效实现。
- en: ViewModels neatly encapsulate any presentation logic and allow for simpler View
    code by acting as a specialized version of the model. The relationship between
    a View and ViewModel is straightforward, allowing for more natural ways to wrap
    UI behavior in reusable user controls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModels 精巧地封装了任何呈现逻辑，并充当模型的专门版本，通过分隔逻辑，使视图代码更简单。视图和 ViewModel 之间的关系很直接，允许将
    UI 行为以更自然的方式封装在可重用的用户控件中。
- en: You can read further about the architectural nuance, with illustrations, at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC)上阅读更多关于架构细微差别的内容，包含插图。
- en: 'Next, you will create your very first Angular component, which will include
    the View and the ViewModel, using Angular CLI''s `ng generate` command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将使用 Angular CLI 的 `ng generate` 命令创建您的第一个 Angular 组件，其中将包括视图和 ViewModel：
- en: In the terminal, execute `npx ng generate component current-weather`
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行 `npx ng generate component current-weather`
- en: Ensure that you are executing `ng` commands under the `local-weather-app` folder,
    and not under the `root` project folder. In addition, note that `npx ng generate
    component current-weather` can be rewritten as `ng g c current-weather`. Going
    forward, this book will utilize the shorthand format and expect you to prepend `npx`,
    if necessary.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在`local-weather-app`文件夹下执行 `ng` 命令，而不是在`根`项目文件夹下。另外，注意 `npx ng generate component
    current-weather` 可以重写为 `ng g c current-weather`。今后，本书将使用简写格式，并期望您必要时在前面加上 `npx`。
- en: 'Observe the new files created in your `app` folder:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察您的 `app` 文件夹中创建的新文件：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A generated component has four parts:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个生成的组件由四个部分组成：
- en: '`current-weather.component.css` contains any CSS that is specific to the component
    and is an optional file'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.css` 包含任何特定于组件的 CSS，是一个可选的文件'
- en: '`current-weather.component.html` contains the HTML template that defines the
    look of the component and rendering of the bindings, and can be considered the
    View, in combination with any CSS styles used'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.html` 包含了定义组件外观和绑定渲染的 HTML 模板，可以被视为与任何使用的 CSS 样式结合起来的视图'
- en: '`current-weather.component.spec.ts` contains Jasmine-based unit tests that
    you can extend to test your component functionality'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.spec.ts` 包含了基于 Jasmine 的单元测试，您可以扩展以测试组件的功能'
- en: '`current-weather.component.ts` contains the `@Component` decorator above the class
    definition and is the glue that ties together the CSS, HTML, and JavaScript code
    together. The class itself can be considered the ViewModel, pulling data from
    services and performing any necessary transformations to expose sensible bindings
    for the View, as shown as follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.ts` 中包含了 `@Component` 装饰器，位于类定义的顶部，它是将 CSS、HTML
    和 JavaScript 代码绑定在一起的粘合剂。这个类本身可以被视为 ViewModel，从服务中获取数据并执行必要的转换，以公开视图的合理绑定，如下所示：'
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the component you're planning to write is a simple one, you can rewrite it
    using inline styles and an inline template, to simplify the structure of your
    code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划编写的组件很简单，可以使用内联样式和内联模板重写它，以简化代码的结构。
- en: 'Update `CurrentWeatherComponent` with an inline template and styles:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用内联模板和样式更新`CurrentWeatherComponent`：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you executed the generate command, in addition to creating the component,
    the command also added the new module you created to `app.module.ts`, avoiding
    an otherwise tedious task of wiring up components together:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行生成命令时，除了创建组件外，命令还将新创建的模块添加到`app.module.ts`，避免了繁琐的组件连接任务：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The bootstrap process of Angular is, admittedly, a bit convoluted. This is the
    chief reason Angular CLI exists. `index.html` contains an element named `<app-root>`.
    When Angular begins execution, it first loads `main.ts`, which configures the
    framework for browser use and loads the app module. App module then loads all
    its dependencies and renders within the aforementioned `<app-root>` element. In
    [Chapter 12](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml), *Create a Router-First
    Line-of-Business App*, when we build a line-of-business app, we will create our
    own feature modules to take advantage of the scalability features of Angular.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的引导过程，不可否认，有点复杂。这也是Angular CLI存在的主要原因。`index.html`包含一个名为`<app-root>`的元素。当Angular开始执行时，首先加载`main.ts`，它配置了用于浏览器的框架并加载应用程序模块。然后应用程序模块加载所有依赖项并在上述的`<app-root>`元素内呈现。在[第12章](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml)，*创建一个路由优先的业务应用程序*，当我们构建一个业务应用程序时，我们将创建自己的特性模块以利用Angular的可扩展性功能。
- en: 'Now, we need to display our new component on the initial `AppComponent` template,
    so it is visible to the end user:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在初始`AppComponent`模板上显示我们的新组件，以便最终用户看到：
- en: 'Add the `CurrentWeatherComponent` to `AppComponent` by replacing `<div>current
    weather</div>` with `<app-current-weather></app-current-weather>`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CurrentWeatherComponent`添加到`AppComponent`中，用`<app-current-weather></app-current-weather>`替换`<div>current
    weather</div>`：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If everything worked correctly, you should see this:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常工作，你应该看到这个：
- en: '![](img/73cfd796-6a00-4c6a-b790-4a736c7fa508.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73cfd796-6a00-4c6a-b790-4a736c7fa508.png)'
- en: Initial render of your local weather app
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本地天气应用程序的初始渲染
- en: Note the icon and name in the tab of the browser window. As a web development
    norm, in the `index.html` file, update the `<title>` tag and the `favicon.ico`
    file with the name and icon of your application to customize the browser tab information.
    If your favicon doesn't update, append the `href` attribute with a unique version
    number, such as `href="favicon.ico?v=2"`. As a result, your app will start looking
    like a real web app, instead of a CLI-generated starter project.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意浏览器窗口标签中的图标和名称。作为 Web 开发的惯例，在`index.html`文件中，使用应用程序的名称和图标更新`<title>`标签和`favicon.ico`文件，以自定义浏览器标签信息。如果您的网站图标没有更新，请向`href`属性附加一个唯一版本号，例如`href="favicon.ico?v=2"`。因此，您的应用程序将开始看起来像一个真正的
    Web 应用程序，而不是一个由 CLI 生成的初学者项目。
- en: Define your model using interfaces
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口定义您的模型
- en: 'Now that your `View` and `ViewModel` are in place, you need to define your
    `Model`. If you look back on the design, you will see that the component needs
    to display:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的`View`和`ViewModel`就位了，您需要定义您的`Model`。如果回顾设计，您将看到组件需要显示：
- en: City
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市
- en: Country
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国家
- en: Current date
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期
- en: Current image
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前图片
- en: Current temperature
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前温度
- en: Current weather description
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前天气描述
- en: 'You will first create an interface that represents this data structure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个表示这个数据结构的接口：
- en: In the terminal, execute `npx ng generate interface ICurrentWeather`
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端执行`npx ng generate interface ICurrentWeather`
- en: 'Observe a newly generated file named `icurrent-weather.ts` with an empty interface
    definition that looks like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察一个新生成的名为`icurrent-weather.ts`的文件，其中包含一个空接口定义，看起来像这样：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is not an ideal setup, since we may add numerous interfaces to our app
    and it can get tedious to track down various interfaces. Over time, as you add
    concrete implementations of these interfaces as classes, then it will make sense
    to put classes and their interfaces in their own files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个理想的设置，因为我们可能会向我们的应用程序添加许多接口，跟踪各种接口可能会变得繁琐。随着时间的推移，当你将这些接口的具体实现作为类添加时，将有意义地将类和它们的接口放在自己的文件中。
- en: Why not just call the interface `CurrentWeather`? This is because later on we
    may create a class to implement some interesting behavior for `CurrentWeather`.
    Interfaces establish a contract, establishing the list of available properties
    on any class or interface that implements or extends the interface. It is always
    important to be aware of when you're using a class versus an interface. If you
    follow the best practice to always start your interface names with a capital `I`,
    you will always be conscious of what type of an object you are passing around.
    Hence, the interface is named `ICurrentWeather`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接将接口命名为`CurrentWeather`？因为稍后我们可能会创建一个类来实现`CurrentWeather`的一些有趣的行为。接口建立了一个契约，确定了任何实现或扩展接口的类或接口上可用属性的列表。始终意识到您正在使用类还是接口是非常重要的。如果您遵循始终以大写字母
    `I` 开头命名接口的最佳实践，您将始终意识到您正在传递的对象的类型。因此，接口被命名为`ICurrentWeather`。
- en: Rename `icurrent-weather.ts` to `interfaces.ts`
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`icurrent-weather.ts`重命名为`interfaces.ts`
- en: Correct the capitalization of the interface name to `ICurrentWeather`
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口名称的大写进行更正为`ICurrentWeather`
- en: 'Also, implement the interface as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，按照以下方式实现接口：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This interface and its eventual concrete representation as a class is the Model
    in MVVM. So far, I have highlighted how various parts of Angular fit the MVVM
    pattern; going forward, I will be referring to these parts with their actual names.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口及其最终的具体表示形式作为一个类是MVVM中的模型。到目前为止，我已经强调了Angular的各个部分如何符合MVVM模式；在接下来，我将用它们的实际名称来指代这些部分。
- en: Now, we can import the interface into the component and start wiring up the
    bindings in the template of `CurrentWeatherComponent`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将接口导入到组件中，并开始在`CurrentWeatherComponent`模板中连接绑定。
- en: Import `ICurrentWeather`
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ICurrentWeather`
- en: Switch back to the `templateUrl` and ``styleUrls``
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回`templateUrl`和``styleUrls``
- en: Define a local variable called `current` with type `ICurrentWeather`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `current` 的本地变量，类型为 `ICurrentWeather`
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you just type `current: ICurrentWeather`, you can use the auto-fixer to
    automatically insert the import statement.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您只键入`current: ICurrentWeather`，您可以使用自动修复程序自动插入导入语句。'
- en: In the constructor, you will temporarily populate the current property with
    dummy data to test your bindings.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，您将用虚拟数据临时填充当前属性以测试绑定。
- en: 'Implement dummy data as a JSON object and declare its adherence to `ICurrentWeather`
    using the as operator:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以JSON对象的形式实现虚拟数据，并使用`as`运算符声明它遵循`ICurrentWeather`：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `src/assets` folder, create a subfolder named `img` and place an image
    of your choice to reference in your dummy data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/assets`文件夹中，创建一个名为`img`的子文件夹，并放置您选择的图像以在虚拟数据中引用。
- en: 'You may forget the exact properties in the interface you created. You can get
    a quick peek at them by holding *Ctrl* + hover-over the interface name with your
    mouse, as shown:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会忘记您创建的接口中的确切属性。通过*Ctrl* + 鼠标悬停在接口名称上，您可以快速查看它们，如下所示：
- en: '![](img/e15b7ab5-9e57-4aff-a18d-c38830c6e75a.png)*Ctrl* + hover-over the interface'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/e15b7ab5-9e57-4aff-a18d-c38830c6e75a.png)*Ctrl* + 鼠标悬停在接口'
- en: Now you update the template to wire up your bindings with a rudimentary HTML-based
    layout.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以更新模板，将您的绑定与基本的基于HTML的布局进行连接。
- en: 'Implement the template:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现模板：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To change the display formatting of `current.date`, we used the `DatePipe` above,
    passing in `'fullDate'` as the format option. In Angular, various out-of-the-box
    and custom pipe `|` operators can be used to change the appearance of data without
    actually changing the underlying data. This is a very powerful, convenient, and
    flexible system to share such user interface logic without writing repetitive
    boilerplate code. In the preceding example, we could pass in `'shortDate'` if
    we wanted to represent the current date in a more compact form. For more information
    on various `DatePipe` options, refer to the documentation at [https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe). To
    format `current.temperature` so that no fractional values are shown, you can use
    `DecimalPipe`. The documentation is at [https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改 `current.date` 的显示格式，我们使用了上面的 `DatePipe` ，将`'fullDate'`作为格式选项传入。在Angular中，可以使用各种内置和自定义`|`操作符来更改数据的外观，而不改变实际的数据。这是一个非常强大、方便和灵活的系统，可以在不编写重复代码的情况下共享用户界面逻辑。在上面的示例中，如果我们想要以更紧凑的形式表示当前日期，我们可以传入`'shortDate'`。有关各种`DatePipe`选项的更多信息，请参阅[https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe)的文档。要格式化`current.temperature`，以便不显示小数值，您可以使用`DecimalPipe`。文档在[https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe)中。
- en: Note that you can render ℃ and ℉ using their respective HTML codes: ![](img/b5a76f73-bb93-4f1a-a344-5f20edef7312.png) for
    ℃ and ![](img/a4b2101d-64f9-4302-a885-efa078718e12.png) for ℉.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用其各自的HTML代码来呈现℃和℉： ![](img/b5a76f73-bb93-4f1a-a344-5f20edef7312.png) 代表℃， ![](img/a4b2101d-64f9-4302-a885-efa078718e12.png) 代表 ℉。
- en: 'If everything worked correctly, you app should be looking similar to this screenshot:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，您的应用应该看起来类似于该截图：
- en: '![](img/b0c66fef-99c4-4b07-b2e6-0040f481527b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0c66fef-99c4-4b07-b2e6-0040f481527b.png)'
- en: App after wiring up bindings with dummy data
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到虚拟数据的 App
- en: Congratulations, you have successfully wired up your first component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已成功连接了第一个组件。
- en: Using Angular Services and HttpClient to retrieve data
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 服务和 HttpClient 获取数据
- en: 'Now you need to connect your `CurrentWeather` component to the `OpenWeatherMap`
    APIs. In the upcoming sections, we will go over the following steps to accomplish
    this goal:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要将您的`CurrentWeather`组件连接到`OpenWeatherMap` APIs。在接下来的章节中，我们将重点介绍以下步骤以实现这个目标：
- en: Create a new Angular Service
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Angular 服务
- en: Import `HttpClientModule` and inject it into the service
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `HttpClientModule` 并将其注入服务中
- en: Discover the `OpenWeatherMap` API
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现`OpenWeatherMap` API
- en: Create a new interface that conforms to the shape of the API
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建符合 API 结构的新接口
- en: Write a `get` request
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`get`请求
- en: Inject the new service into the `CurrentWeather` component
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新服务注入到`CurrentWeather`组件中
- en: Call the service from the `init` function of the `CurrentWeather` component
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CurrentWeather` 组件的`init`函数中调用该服务
- en: Finally, map the API data to the local `ICurrentWeather` type using RxJS functions
    so that it can be consumed by your component
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用RxJS函数将API数据映射到本地的`ICurrentWeather`类型，以便组件可以使用
- en: Creating a new Angular Service
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的 Angular 服务
- en: Any code that touches outside of the boundaries of a component should exist
    in a service; this includes inter-component communication, unless there's a parent-child
    relationship, and API calls of any kind and any code that cache or retrieve data
    from a cookie or the browser's localStorage. This is a critical architectural
    pattern that keeps your application maintainable in the long term. I expand upon
    this idea in my DevPro MVVM article at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 任何超出组件边界的代码应存在于服务中；这包括组件间通信，除非存在父子关系，并且任何类型的API调用，以及缓存或从cookie或浏览器的localStorage中检索数据的任何代码。这是一个在长期内保持您的应用可维护性的重要架构模式。我在我的DevPro
    MVVM文章中详细介绍了这个想法，链接在[http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC)。
- en: 'To create an Angular service, do this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Angular 服务，请执行以下操作：
- en: In the terminal, execute `npx ng g s weather --flat false`
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行`npx ng g s weather --flat false`
- en: 'Observe the new `weather` folder created:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察新创建的`weather`文件夹：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A generated service has two parts:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的服务有两个部分：
- en: '`weather.service.spec.ts` contains Jasmine-based unit tests that you can extend
    to test your service functionality.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather.service.spec.ts`包含基于Jasmine的单元测试，您可以扩展以测试服务功能。'
- en: '`weather.service.ts` contains the `@Injectable` decorator above the class definition,
    which makes it possible to inject this service into other components, leveraging
    Angular''s provider system. This will ensure that our service will be a singleton,
    meaning only instantiated once, no matter how many times it is injected elsewhere.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather.service.ts`中包含了类定义之前的`@Injectable`装饰器，这使得可以将该服务注入到其他组件中，利用Angular的提供者系统。这将确保我们的服务将是单例的，意味着无论它在其他地方被实例化多少次，它都只会被实例化一次。'
- en: 'The service is generated, but it''s not automatically provided. To do this,
    follow these steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 服务已生成，但并未自动提供。要执行此操作，请按照以下步骤进行：
- en: Open `app.module.ts`
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`
- en: Type in `WeatherService` inside the providers array
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在providers数组中输入`WeatherService`
- en: 'Use the auto-fixer to import the class for you:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自动修复程序为您导入类：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you installed the recommended extension TypeScript Hero, the import statement
    will be automatically added for you. You won't have to use the auto-fixer to do
    it. Going forward, I will not call out the need to import modules.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装了推荐的扩展 TypeScript Hero，则导入语句将自动为您添加。您无需使用自动修复程序来执行此操作。接下来，我将不再强调需要导入模块的需要。
- en: Inject dependencies
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入依赖项
- en: 'In order to make API calls, you will be leveraging the `HttpClient` module
    in Angular. The official documentation ([https://angular.io/guide/http](https://angular.io/guide/http))
    explains the benefits of this module succinctly:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行API调用，您将使用Angular中的`HttpClient`模块。官方文件([https://angular.io/guide/http](https://angular.io/guide/http))简洁地解释了这个模块的好处：
- en: '"With HttpClient, @angular/common/http provides a simplified API for HTTP functionality
    for use with Angular applications, building on top of the XMLHttpRequest interface
    exposed by browsers. Additional benefits of HttpClient include testability support,
    strong typing of request and response objects, request and response interceptor
    support, and better error handling via APIs based on Observables."'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “通过 HttpClient，@angular/common/http为Angular应用程序提供了一个简化的用于HTTP功能的API，构建在浏览器暴露的XMLHttpRequest接口之上。HttpClient的额外好处包括支持可测试性，强类型化的请求和响应对象，请求和响应拦截器支持以及基于可观察对象的更好的错误处理。”
- en: 'Let''s start with importing the `HttpClientModule` in to our app, so we can
    inject the `HttpClient` within the module into the `WeatherService`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始导入`HttpClientModule`到我们的应用程序中，以便我们可以在`WeatherService`中注入模块中的`HttpClient`：
- en: 'Add `HttpClientModule` to `app.module.ts`, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.module.ts`中添加`HttpClientModule`，如下所示：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inject `HttpClient` provided by the `HttpClientModule` in the  `WeatherService`, as
    follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入由`HttpClientModule`提供的`HttpClient`到`WeatherService`，如下所示：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, `httpClient` is ready for use in your service.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`httpClient`已经准备好在您的服务中使用。
- en: Discover OpenWeatherMap APIs
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索OpenWeatherMap API
- en: Since `httpClient` is strongly typed, we need to create a new interface that
    conforms to the shape of the API we'll call. To be able to do this, you need to
    familiarize yourself with the Current Weather Data API.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`httpClient`是强类型的，因此我们需要创建一个符合我们将要调用的API形状的新接口。为了能够做到这一点，您需要熟悉当前天气数据API。
- en: 'Read documentation by navigating to [http://openweathermap.org/current](http://openweathermap.org/current):'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到[http://openweathermap.org/current](http://openweathermap.org/current)阅读文档：
- en: '![](img/771e0150-f856-43e5-9da5-0704544cd618.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/771e0150-f856-43e5-9da5-0704544cd618.png)'
- en: OpenWeatherMap Current Weather Data API Documentation
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeatherMap当前天气数据API文档
- en: 'You will be using the API named By city name, which allows you to get current
    weather data by providing the city name as a parameter. So, your web request will
    look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用名为“按城市名称”的API，它允许您通过提供城市名称作为参数来获取当前的天气数据。因此，您的网络请求将如下所示：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the documentation page, click on the link under Example of API calls, and
    you will see a sample response like the following:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档页面上，点击“API调用示例”的链接，您将看到以下示例响应：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Given the existing `ICurrentWeather` interface that you have already created,
    this response contains more information than you need. So you will write a new
    interface that conforms to the shape of this response, but only specify the pieces
    of data you will use. This interface will only exist in the `WeatherService` and
    we won't export it, since the other parts of the application don't need to know
    about this type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于您已经创建的现有`ICurrentWeather`接口，此响应包含的信息比您所需的要多。因此，您将编写一个新的接口，符合此响应的形状，但只指定您将要使用的数据片段。这个接口将只存在于`WeatherService`中，我们不会导出它，因为应用程序的其他部分不需要知道这种类型。
- en: Create a new interface named `ICurrentWeatherData` in `weather.service.ts` between
    the `import` and `@Injectable` statements
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`weather.service.ts`中的`import`语句和`@Injectable`语句之间创建一个名为`ICurrentWeatherData`的新接口
- en: 'The new interface should like this:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新接口应该像这样：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the `ICurrentWeatherData` interface, we are defining new anonymous types
    by adding children objects to the interface with varying structures. Each of these
    objects can be individually extracted out and defined as their own named interface.
    Especially, note that `weather` will be an array of the anonymous type that has
    the `description` and `icon` properties.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ICurrentWeatherData`接口，我们通过向接口添加具有不同结构的子对象来定义新的匿名类型。这些对象中的每一个都可以被单独提取出来并定义为它们自己的命名接口。特别要注意的是，`weather`将是一个具有`description`和`icon`属性的匿名类型数组。
- en: Storing environment variables
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储环境变量
- en: 'It''s easy to miss, but the sample URL from previous sections contains a required `appid` parameter.
    You must store this key in your Angular app. You can store it in the weather service,
    but in reality, applications need to be able to target different sets of resources
    as they move from development to testing, staging, and production environments.
    Out of the box, Angular provides two environments: one `prod` and the other one
    as the default.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易被忽视的是，之前章节示例的URL包含一个必需的`appid`参数。你必须在你的Angular应用中存储这个键。你可以将它存储在天气服务中，但实际上，应用程序需要能够在从开发到测试、分段和生产环境的移动过程中针对不同的资源集。Angular
    提供了两个环境：一个为`prod`，另一个为默认。
- en: Before you can continue, you need to sign up for a free `OpenWeatherMap` account
    and retrieve your own `appid`. You can read the documentation for `appid` at [http://openweathermap.org/appid ](http://openweathermap.org/appid)for
    more detailed information.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要注册一个免费的`OpenWeatherMap`账户并获取自己的`appid`。你可以阅读[http://openweathermap.org/appid ](http://openweathermap.org/appid)上`appid`的文档以获取更详细的信息。
- en: Copy your `appid`, which will have a long string of characters and numbers
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你的`appid`，它将有一长串字符和数字
- en: Store your `appid `in `environment.ts`
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的`appid`存储在`environment.ts`中
- en: 'Configure `baseUrl` for later use:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为后续使用配置`baseUrl`：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In code, we use a camel-case `appId` to keep our coding style consistent. Since
    URL parameters are case-insensitive, `appId` will work as well as `appid`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们使用驼峰写法`appId`以保持我们的编码风格一致。由于 URL 参数是大小写不敏感的，`appId`和`appid`都可以使用。
- en: Implementing an HTTP GET operation
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个 HTTP GET 操作
- en: 'Now, we can implement the GET call in the Weather service:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在天气服务中实现 GET 调用：
- en: Add a new function to the `WeatherService` class named `getCurrentWeather`
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WeatherService`类中添加一个名为`getCurrentWeather`的新函数
- en: Import the `environment` object
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`environment`对象
- en: Implement the `httpClient.get` function
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`httpClient.get`函数
- en: 'Return the results of the HTTP call:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 HTTP 调用的结果：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the use of ES2015's String Interpolation feature. Instead of building your
    string by appending variables to one another like `environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`, you can use the backtick
    syntax to wrap ``your string``. Inside the backticks, you can have newlines and
    also directly embed variables into the flow of your string by wrapping them with
    the `${dollarbracket}` syntax. However, when you introduce a newline in your code,
    it will be interpreted as a literal newline—`\n`. In order to break up the string
    in your code, you may add a backslash `\`, but then the next line of your code
    can have no indentation. It is easier to just concatenate multiple templates,
    as shown in the preceding code sample.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用 ES2015 的字符串插值功能。不必像`environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`那样将变量追加到一起来构建字符串，你可以使用反引号语法包裹``你的字符串``。在反引号内，你可以有换行，还可以直接使用`${dollarbracket}`语法将变量嵌入到字符串的流中。但是，在代码中引入换行时，它将被解释为字面换行—`\n`。为了在代码中分割字符串，你可以添加一个反斜杠`\`，但接下来的代码行不能有缩进。如前面的代码示例所示，将多个模板连接起来会更容易些。
- en: Note the use TypeScript Generics with the get function using the caret syntax
    like `<TypeName>`. Using generics is development-time quality of life feature.
    By providing the type information to the function, input and/or return variables
    types of that function will be displayed as you write your code and validated
    during development and also at compile time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: Retrieving service data from a component
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: 'To be able to use the `getCurrentWeather` function in the `CurrentWeather`
    component, you need to inject the service into the component:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: Inject the `WeatherService` into the constructor of the `CurrentWeatherComponent`
    class
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: 'Remove the existing code that created the dummy data in the constructor:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Call the `getCurrentWeather` function inside the `ngOnInit` function:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Fair warning, do not expect this code to be working just yet. You should see
    an error, so let's understand what's going in the next segment.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: Angular components have a rich collection of lifecycle hooks that allow you
    to inject your custom behavior when a component is being rendered, refreshed,
    or destroyed. `ngOnInit()` is the most common lifecycle hook you will be using.
    It is only called once when a component is first instantiated or visited. This
    is where you will want to perform your service calls. For a deeper understanding
    of component lifecycle hooks, check out the documentation at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: Note that the anonymous function you have passed to `subscribe` is an ES2015
    arrow function. If you're not familiar with arrow functions, it may be confusing
    at first. Arrow functions are actually quite elegant and simple.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: 'Consider the following arrow function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: '`(data) => { this.current = data }`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: 'You can rewrite it simply as:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: '`function(data) { this.current = data }`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: 'There''s a special condition—when you write an arrow function that simply transforms
    a piece of data, such as this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: '`(data) => { data.main.temp }`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: 'This function effectively takes `ICurrentWeatherData` as an input and returns
    the temp property. The return statement is implicit. If you rewrite it as a regular
    function, it will look like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: '`function(data) { return data.main.temp }`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: When the `CurrentWeather` component loads, `ngOnInit` will fire once, which
    will call the `getCurrentWeather` function that returns an object with a type
    of `Observable<ICurrentWeatherData>`. An Observable, as described in the official
    documentation, *is the most basic building block of RxJS* that represents an event
    emitter, which will emit any data received over time with the type of `ICurrentWeatherData`.
    The `Observable` object by itself is benign and will not cause a network event
    to be fired unless it is being listened to. You can read more about Observables
    at [reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将在第一次触发时，这将调用`getCurrentWeather`函数，该函数返回一个包含`ICurrentWeatherData`类型对象的Observable。Observable是一种RxJS中最基本的事件监听器构建块，代表事件发射器，它将随着时间的推移接收任何数据类型为`ICurrentWeatherData`的数据。Observable本身是无害的，除非它被监听。您可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)中阅读更多关于Observables的信息。
- en: By calling `.subscribe` on the Observable, you're essentially attaching a listener
    to the emitter. You've implemented an anonymous function within the `subscribe`
    method, which will get executed whenever a new piece of data is received and an
    event is emitted. The anonymous function takes a data object as a parameter, and,
    the specific implementation in this case, assigns the piece of data to the local
    variable named current. Whenever current is updated, the template bindings you
    implemented earlier will pull in the new data and render it on the view. Even
    though `ngOnInit` executes only once, the subscription to the Observable persists.
    So whenever there's new data, the current variable will be updated and the view
    will re-render to display the latest data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Observable 上调用 `.subscribe`，从本质上说，你将侦听器附加到发射器上。在 `subscribe` 方法中实现了一个匿名函数，每当接收到新的数据并发出事件时，该函数都将被执行。匿名函数以数据对象作为参数，并且在本例中的具体实现中，将数据块分配给了名为
    current 的本地变量。每当 current 被更新时，你之前实现的模板绑定将拉取新数据并在视图上渲染。即使 `ngOnInit` 只执行一次，对 Observable
    的订阅仍然持续。因此，每当有新数据时，当前变量将被更新，并且视图将重新渲染以显示最新数据。
- en: The root cause of the error at hand is that the data that is being emitted is
    of type `ICurrentWeatherData`; however, our component only understands data that
    is shaped as described by the `ICurrentWeather` interface. In the next section,
    you will need to dig deeper into RxJS to understand how best to accomplish that
    task.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前错误的根本原因是正在传送的数据属于 `ICurrentWeatherData` 类型，但是，我们的组件只能理解由 `ICurrentWeather`
    接口描述的形式的数据。在下一部分，你需要更深入地了解 RxJS，以便最好地完成这项任务。
- en: 'Beware, VS Code and CLI sometimes stop working. As previously noted, as you
    code, the `npm start` command is running in the integrated terminal of VS Code.
    Angular CLI, in combination with the Angular Language Service plug-in, continuously
    watches for code changes and transpiles your TypeScript code to JavaScript, so
    you can observe your changes with live-reloading in the browser. The great thing
    is that when you make coding errors, in addition to the red underlining in VS
    Code, you will also see some red text in the terminal or even the browser, because
    the transpilation has failed. In most cases, when correcting the error, the red
    underlining will go away and Angular CLI will automatically retranspile your code
    and everything will work. However, under certain scenarios, you will note that
    VS Code will fail to pick typing changes in the IDE, so you won''t get autocompletion
    help or the CLI tool will get stuck with message saying webpack: Failed to compile.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，VS Code 和 CLI 有时会停止工作。如前所述，在编写代码时，`npm start` 命令正在 VS Code 的集成终端中运行。Angular
    CLI 与 Angular 语言服务插件一起，不断地监视代码更改，将你的 TypeScript 代码转译成 JavaScript，这样你就能在浏览器中实时查看你的更改。最棒的是，当你出现编码错误时，除了在
    VS Code 中的红色下划线外，在终端或者浏览器中也会看到一些红色文字，因为转译失败了。在大多数情况下，在纠正错误后，红色下划线会消失，Angular CLI
    会自动重新转译你的代码，一切都会正常工作。然而，在某些情况下，你会发现 VS Code 未能在 IDE 中捕捉到输入更改，所以你将得不到自动补全帮助或者 CLI
    工具会卡在消息“webpack：编译失败”上。
- en: 'You have two main strategies to recover from such conditions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种主要策略来从这种情况中恢复：
- en: Click on the terminal and hit *Ctrl* + *C*to stop running the CLI task and restart
    by executing `npm start`
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击终端，然后按下 *Ctrl* + *C* 停止运行 CLI 任务，并通过执行 `npm start` 重新启动
- en: If **#1** doesn't work, quit VS Code with *Alt* + *F4* for Windows or ⌘ + *Q*
    for macOS and restart it
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **#1** 不起作用，用 *Alt* + *F4*（Windows）或 ⌘ + *Q*（macOS）退出 VS Code，然后重新启动它
- en: Given Angular and VS Code's monthly releases cycles, I'm confident that in time
    the tooling can only improve.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 Angular 和 VS Code 每月的发布周期，我相信工具只会不断改进。
- en: Transform data using RxJS
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 转换数据
- en: RxJS stands for Reactive Extensions, which is a modular library that enables
    reactive programming, which itself is an asynchronous programming paradigm and
    allows for manipulation of data streams through transformation, filtering, and
    control functions. You can think of reactive programming as an evolution of event-based
    programming.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 代表着响应式扩展，这是一个模块化的库，能够实现响应式编程，它本身是一种异步编程范式，并允许通过转换、过滤和控制函数来操纵数据流。你可以将响应式编程看作是事件驱动编程的一种进化。
- en: Understanding Reactive programming
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解响应式编程
- en: In Event-Driven programming, you would define an event handler and attach it
    to an event source. In more concrete terms, if you had a save button, which exposes
    an `onClick` event, you would implement a `confirmSave` function, which when triggered,
    would show a popup to ask the user Are you sure?. Look at the following figure
    for a visualization of this process.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动编程中，您将定义一个事件处理程序并将其附加到事件源。更具体地说，如果您有一个保存按钮，该按钮公开`onClick`事件，您将实现一个`confirmSave`函数，当触发时，会显示一个弹出窗口询问用户“您确定吗？”。查看以下图示可可视化此过程。
- en: '![](img/1958996b-696a-4b00-971d-12e7f8537bf2.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1958996b-696a-4b00-971d-12e7f8537bf2.png)'
- en: Event-Driven Implementation
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动实现
- en: In short, you would have an event firing once per user action. If the user clicks
    on the save button many times, this pattern would gladly render as many popups
    as there are clicks, which doesn't make much sense.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您将有一个事件在每次用户操作时触发。如果用户多次点击保存按钮，此模式将乐意呈现与点击次数相同的弹出窗口，这并没有太多意义。
- en: The publish-subscribe (pub/sub) pattern is a different type of event-driven
    programming. In this case, we can write multiple handlers to act on the result
    of a given event all simultaneously. Let's say that your app just received some
    updated data. The publisher will go through its list of subscribers and pass on
    the updated data to each of them. Refer to the following diagram, how can updated
    data event trigger an `updateCache` function that can update your local cache
    with new data, a `fetchDetails` function that can retrieve further details about
    the data from the server, and also a `showToastMessage` function that can inform
    the user that the app just received new data. All these events can happen asynchronously;
    however, the `fetchDetails` and `showToastMessage` functions will be receiving
    more data than they really need, and it can get really convoluted to try to compose
    these events in different ways to modify application behavior.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅（pub/sub）模式是一种不同类型的事件驱动编程。在这种情况下，我们可以编写多个处理程序来同时对给定事件的结果进行操作。假设您的应用刚刚收到了一些更新的数据。发布者将遍历其订阅者列表，并将更新的数据传递给每个订阅者。参考以下图表，更新的数据事件如何触发`updateCache`函数，该函数可以使用新数据更新您的本地缓存，`fetchDetails`函数可以从服务器检索有关数据的更多详细信息，并且`showToastMessage`函数可以通知用户应用程序刚刚收到了新数据。所有这些事件都可以异步发生;但是，`fetchDetails`和`showToastMessage`函数将收到比他们实际需要的更多数据，尝试以不同方式组合这些事件以修改应用程序行为可能会变得非常复杂。
- en: '![](img/3526531c-0a8d-4901-887b-2128cf2c4451.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3526531c-0a8d-4901-887b-2128cf2c4451.png)'
- en: Pub/Sub Pattern Implementation
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅模式实现
- en: In reactive programming, everything is treated as a stream. A stream will contain
    events that happen over time and these events can contain some data or no data.
    The following diagram visualizes a scenario where your app is listening for mouse
    clicks from the user. Uncontrolled streams of user clicks are meaningless. You
    exert some control over this stream by applying the `throttle` function to it,
    so you only get updates every 250 **milliseconds** (**ms**). If you subscribe
    to this new event, every 250 ms, you will receive a list of click events. You
    may try to extract some data from each click event, but in this case, you're only
    interested in the number of click events that happened. We can shape the raw event
    data into number of clicks using the `map` function.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，一切都被视为流。一个流将包含随时间发生的事件，这些事件可以包含一些数据或没有数据。下图可视化了一个场景，您的应用正在监听用户的鼠标点击。不受控的用户点击流是毫无意义的。通过将`throttle`函数应用于它，您可以对此流施加一些控制，以便每250
    **毫秒**（**ms**）仅获得更新。如果订阅此新事件，则每250毫秒，您将收到一系列点击事件。您可以尝试从每次点击事件中提取一些数据，但在这种情况下，您只对发生的点击事件数量感兴趣。我们可以使用`map`函数将原始事件数据转化为点击次数。
- en: Further down the stream, we may only be interested in listening for events with
    two or more clicks in it, so we can use the `filter` function to only act on what
    is essentially a double-click event. Every time our filter event fires, it means
    that the user intended to double-click, and you can act on that information by
    popping up an alert. The true power for streams comes from the fact that you can
    choose to act on the event at any time as it passes through various control, transformation,
    and filter functions. You can choose to display click data on an HTML list using
    `*ngFor` and Angular's `async` pipe, so the user can monitor the types of click
    data being captured every 250ms.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下游,我们可能只对带有两个或多个点击的事件感兴趣,所以我们可以使用 `filter` 函数只对本质上是双击事件的事件采取行动。每当我们的过滤器事件触发时,这意味着用户打算双击,你可以根据这个信息弹出一个警告。流的真正力量在于,你可以选择在它通过各种控制、转换和过滤函数时的任何时候采取行动。你可以选择使用
    `*ngFor` 和 Angular 的 `async` 管道在 HTML 列表上显示点击数据,这样用户就可以监视每250毫秒捕获的点击数据类型。
- en: '![](img/c16581a0-78ed-4c3c-87a6-903d7bca41d0.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c16581a0-78ed-4c3c-87a6-903d7bca41d0.png)'
- en: A Reactive Data Stream Implementation
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个响应式数据流实现
- en: Implementing Reactive transformations
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现响应式转换
- en: 'To avoid future mistakes in returning the unintended type of data from your
    service, you need to update the `getCurrentWeather` function to define the return
    type to be `Observable<ICurrentWeather>` and import the `Observable` type, as
    shown:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '为了避免将来从服务中返回意外类型的数据的错误,你需要更新 `getCurrentWeather` 函数,将返回类型定义为 `Observable<ICurrentWeather>`,并导入
    `Observable` 类型,如下所示:'
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, VS Code will let you know that Type `Observable<ICurrentWeatherData>` is
    not assignable to type `Observable<ICurrentWeather>`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '现在,VS Code 会告诉你,类型 `Observable<ICurrentWeatherData>` 不可分配给类型 `Observable<ICurrentWeather>`:'
- en: Write a transformation function named `transformToICurrentWeather` that can
    convert `ICurrentWeatherData` to `ICurrentWeather`
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `transformToICurrentWeather` 的转换函数,可以将 `ICurrentWeatherData` 转换为 `ICurrentWeather`
- en: 'Also, write a helper function named `convertKelvinToFahrenheit` that converts
    the API provided Kelvin temperature to Fahrenheit:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '此外,编写一个名为 `convertKelvinToFahrenheit` 的助手函数,将 API 提供的开尔文温度转换为华氏度:'
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that you need to be converting the icon property to an image URL at this
    stage. Doing this in the service helps preserve encapsulation, binding the icon
    value to the URL in the view template will break the **Separation of concerns**
    (**SoC**) principle. If you wish to create truly modular, reusable, and maintainable
    components, you must remain vigilant and strict in terms of enforcing SoC. The
    documentation for Weather Icons and details of how the URL should be formed, including
    all the available icons can be found at [http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意,你需要在此阶段将图标属性转换为图像 URL。在服务中执行此操作有助于保持封装,在视图模板中绑定图标值到 URL 会违反**关注点分离** (**SoC**)
    原则。如果你希望创建真正模块化、可重用和可维护的组件,你必须保持警惕并严格执行 SoC。有关天气图标的文档以及如何形成 URL 的详细信息,包括所有可用的图标,可以在
    [http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions)
    找到。
- en: On a separate note, the argument can be made that Kelvin to Fahrenheit conversion
    is actually a view concern, but we have implemented it in the service. This argument
    holds water, especially considering that we have a planned feature to be able
    to toggle between Celsius and Fahrenheit. A counter argument would be that at
    this time, we only need to display in Fahrenheit and it is part of the job of
    the weather service to be able to convert the units. This argument makes sense
    as well. The ultimate implementation will be to write a custom Angular Pipe and
    apply it in the template. A pipe can easily bind with the planned toggle button
    as well. However, at this time, we only need to display in Fahrenheit and I would
    err on the side of *not*over-engineering a solution.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面,可以论证说,开尔文到华氏温度的转换实际上是一个视图关注点,但我们在服务中实现了它。这个论点是有道理的,特别是考虑到我们计划有一个功能可以在摄氏度和华氏度之间切换。反对的论点是,目前我们只需要以华氏度显示,这是天气服务的一部分,能够转换单位。这个论点也很有道理。最终的实现将是编写一个自定义的
    Angular Pipe,并在模板中应用它。一个管道也可以很容易地与计划的切换按钮绑定。但是,现在我们只需要以华氏度显示,我会倾向于*不*过度设计一个解决方案。
- en: Update `ICurrentWeather.date` to the `number` type
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ICurrentWeather.date` 更新为 `number` 类型
- en: While writing the transformation function, you will note that the API returns
    the date as a number. This number represents time in seconds since the UNIX epoch
    (timestamp), which is January 1st, 1970 00:00:00 UTC. However, `ICurrentWeather`
    expects a `Date` object. It is easy enough to convert the timestamp by passing
    it into the constructor of the `Date` object like `new Date(data.dt)`. This is
    fine, but also unnecessary, since Angular's `DatePipe` can directly work with
    the timestamp. In the name of relentless simplicity and maximally leveraging the
    functionality of the frameworks we use, we will update `ICurrentWeather` to use
    `number`. There's also a performance and memory benefit to this approach if you're
    transforming massive amounts of data, but that concern is not applicable here. There's
    one caveat—JavaScript's timestamp is in milliseconds, but the server value is
    in seconds, so a simple multiplication during the transformation is still required.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写转换函数时，你会注意到API返回的日期是一个数字。这个数字代表自UNIX纪元（时间戳）以来的秒数，即1970年1月1日00:00:00 UTC。然而，`ICurrentWeather`期望一个`Date`对象。通过将时间戳传递给`Date`对象的构造函数`new Date(data.dt)`来转换时间戳非常简单。这没有问题，但也是没必要的，因为Angular的`DatePipe`可以直接使用时间戳。在追求简单和最大程度利用我们使用的框架功能的名义上，我们将更新`ICurrentWeather`以使用`number`。如果你正在转换大量数据，这种方法还有性能和内存方面的好处，但这个问题在这里并不适用。这里有一个注意事项—JavaScript的时间戳是以毫秒为单位的，但服务器的值是以秒为单位的，因此在转换过程中仍然需要简单的乘法运算。
- en: 'Import the RxJS `map` operator right below the other import statements:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他导入语句的下面导入RxJS的`map`操作符：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It may seem odd to have to manually import the `map` operator. RxJS is a very
    capable framework with a wide API surface. Observable alone has over 200 methods
    attached to it. Including all of these methods by default creates development
    time issues with too many functions to choose from and also, it negatively impacts
    the size of the final deliverable, including app performance and memory use. So
    you must add each operator you intend to use individually.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 手动导入 `map` 操作符可能看起来很奇怪。RxJS是一个功能强大的框架，具有广泛的API表面。单独的Observable就有超过200个附加方法。默认包含所有这些方法会在开发时创建太多的功能选择问题，同时也会对最终交付的大小、应用程序性能和内存使用产生负面影响。因此，你必须单独添加要使用的每个操作符。
- en: Apply the `map` function to data stream returned by  `httpClient.get` method
    through a `pipe`
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`httpClient.get`方法返回的数据流上应用`map`函数通过一个`pipe`
- en: 'Pass the `data` object into the `transformToICurrentWeather` function:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`data`对象传递给`transformToICurrentWeather`函数：
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now incoming data can be transformed as it flows through the stream, ensuring
    that the `OpenWeatherMap` Current Weather API data is in the correct shape, so
    it can be consumed by the `CurrentWeather` component.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当数据进入时，可以在数据流中对其进行转换，确保`OpenWeatherMap`的当前天气API数据具有正确的格式，这样可以被`CurrentWeather`组件消费。
- en: Ensure that your app compiles successfully
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的应用程序成功编译
- en: 'Inspect the results in the browser:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中检查结果：
- en: '![](img/9d3b92ed-4580-464f-ba40-4eb4f8b2121d.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d3b92ed-4580-464f-ba40-4eb4f8b2121d.png)'
- en: Displaying Live Data from OpenWeatherMap
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 显示来自OpenWeatherMap的实时数据
- en: Finally, you should see that your app is able to pull live data from `OpenWeatherMap`
    and correctly transform server data into the format you expect.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该看到你的应用程序能够从`OpenWeatherMap`中获取实时数据，并正确地将服务器数据转换为你期望的格式。
- en: You have completed the development of Feature 1: Display Current Location weather
    information for the current day. Commit your code and move the card in Waffle
    to the Done column.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了Feature 1的开发：显示当前位置的当天天气信息。提交你的代码并将卡片移到Waffle的“已完成”列。
- en: 'Finally, we can move this task to the Done column:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将这个任务移到完成列：
- en: '![](img/fa81e672-d175-49db-a89c-67b6acb67a98.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa81e672-d175-49db-a89c-67b6acb67a98.png)'
- en: Waffle.io Kanban Board Status
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Waffle.io 看板状态
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations, in this chapter, you created your first Angular application
    with a flexible architecture while avoiding over-engineering. This was possible
    because we first built a road map and codified it in a Kanban board that is visible
    to your peers and colleagues. We stayed focused on implementing the first feature
    we put in progress and didn't deviate from the plan.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，在这一章中，你创建了你的第一个具有灵活架构的Angular应用程序，同时避免了过度设计。这是可能的，因为我们首先建立了一个路线图，并将其编码在一个可见于你的同行和同事的看板中。我们专注于实施我们放在进行中的第一个功能，没有偏离计划。
- en: You can now use Angular CLI and an optimized VS Code development environment
    to help you reduce the amount of coding you need to do. You can leverage TypeScript
    anonymous types and observable streams to accurately reshape complicated API data
    into a simple format without having to create one-use interfaces.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用Angular CLI和优化的VS Code开发环境来帮助您减少编码量。您可以利用TypeScript匿名类型和可观察流来准确地将复杂的API数据重塑为简单的格式，而无需创建一次性接口。
- en: You learned to avoid coding mistakes by proactively declaring input and return
    types of functions and working with generic functions. You used the date and decimal
    pipes to ensure that the data is formatted as desired, while keeping formatting-related
    concerns mostly in the template, where this kind of logic belongs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过主动声明函数的输入和返回类型，并使用通用函数来避免编码错误。您使用了日期和十进制管道来确保数据按预期格式化，同时将与格式相关的问题大部分留在模板中，因为这种逻辑属于模板的范围。
- en: Finally, you used interfaces to communicate between components and services
    without leaking the external data structure to internal components. By applying
    all these techniques in combination, which Angular, RxJS, and TypeScript have
    allowed us to do, you have ensured proper separation of concerns and encapsulation.
    As a result, the `CurrentWeather` component is now a truly reusable and composable
    component; this is not an easy feat to achieve.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您使用接口在组件和服务之间进行通信，而不会将外部数据结构泄露给内部组件。通过结合应用Angular、RxJS和TypeScript允许我们执行的所有这些技术，您已确保了关注点的正确分离和封装。因此，`CurrentWeather`组件现在是一个真正可重用和可组合的组件；这不是一件容易的事情。
- en: If you don't ship it, it never happened. In the next chapter, we will prepare
    this Angular app for a production release by troubleshooting application errors,
    and containerizing the Angular app with Docker, so it can be published on the
    web.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不发布它，它就永远不会发生。在下一章中，我们将通过解决应用程序错误和使用Docker对Angular应用程序进行容器化，为其生产发布做准备，以便可以在web上发布。
