- en: '*Chapter 9*: Testing Next.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*: 测试Next.js'
- en: Testing is an essential part of the whole development workflow. It gives you
    more assurance that you're not introducing bugs into your code, as well as that
    you're not breaking any existing features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是整个开发工作流程的重要组成部分。它使您更有信心，您不会将错误引入代码，也不会破坏任何现有功能。
- en: 'Testing Next.js specifically is not different from testing any other React
    app or Express.js, Fastify, or Koa application. In fact, we can divide the testing
    phases into three different stages:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 专门测试Next.js与测试任何其他React应用程序或Express.js、Fastify或Koa应用程序并无不同。实际上，我们可以将测试阶段分为三个不同的阶段：
- en: Unit testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: End-to-end testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Integration testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: We will look at those concepts in detail in this chapter's sections.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的各个部分中详细探讨这些概念。
- en: If you already have previous experience in writing a React application, you're
    likely to re-utilize your knowledge for testing a Next.js-based website.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经具备编写React应用程序的先前经验，您很可能会将您的知识重新用于测试基于Next.js的网站。
- en: 'In this chapter, we will look in detail at the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨以下内容：
- en: An introduction to testing and testing frameworks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和测试框架简介
- en: Setting up a testing environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: How to use some of the most popular test runners, frameworks, and utility libraries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用一些最受欢迎的测试运行器、框架和实用库
- en: By the end of this chapter, you'll be able to set up a testing environment using
    a test runner and a testing library and run tests before sending the code to production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用测试运行器和测试库设置测试环境，并在将代码发送到生产之前运行测试。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地机器上安装Node.js和npm。
- en: 'If you prefer, you can use an online IDE such as https://repl.it or https://codesandbox.io;
    they both support Next.js, and you don''t need to install any dependency on your
    computer. As with the other chapters, you can find the code base for this chapter
    on GitHub: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以使用在线IDE，例如https://repl.it或https://codesandbox.io；它们都支持Next.js，并且您不需要在您的计算机上安装任何依赖项。与其他章节一样，您可以在GitHub上找到本章的代码库：[https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js)。
- en: An introduction to testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试简介
- en: 'As we''ve seen during this chapter''s introduction, testing is an essential
    part of any development workflow and can be divided into three separate testing
    phases:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章引言中所见，测试是任何开发工作流程的重要组成部分，可以分为三个独立的测试阶段：
- en: '*Unit testing*: These tests aim to make sure that every single function in
    your code is working. They do that by testing the codebase''s functions individually
    against correct and incorrect inputs, asserting their results and possible errors
    to ensure they''re working expected.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试*：这些测试旨在确保您的代码中的每个函数都在正常工作。它们通过针对正确和错误的输入单独测试代码库中的函数，断言其结果和可能的错误，以确保它们按预期工作。'
- en: '*End-to-end testing*: This testing strategy reproduces a typical user interaction
    with your application, ensuring that the app responds with a specific output once
    a given action occurs, just like we would do by testing the website manually on
    a web browser. For instance, if we build a form, we want to automatically guarantee
    that it is working correctly, validating the input, and performing a specific
    action on the form''s submission. Also, we want to test that the user interface
    is rendering as we intended by using particular CSS classes, mounting certain
    HTML elements, and so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*端到端测试*：这种测试策略重现了用户与应用程序的典型交互，确保在给定动作发生时，应用程序会以特定的输出响应，就像我们在浏览器上手动测试网站一样。例如，如果我们构建了一个表单，我们希望自动确保它能够正确工作，验证输入，并在表单提交时执行特定的操作。此外，我们还想通过使用特定的CSS类、挂载某些HTML元素等方式来测试用户界面是否按预期渲染。'
- en: '*Integration testing*: In this case, we want to ensure that separate parts
    of our application, such as functions and modules, are cohesively working together.
    For instance, we want to assert that composing two functions results in a certain
    output, and so on. Unlike unit tests, where we test our functions individually,
    with integration tests, we ensure that a whole group of aggregated functions and
    modules are producing a correct output when given a different set of inputs.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成测试*：在这种情况下，我们想要确保我们应用程序的各个部分，如函数和模块，能够协同工作。例如，我们想要断言组合两个函数会产生特定的输出，等等。与单元测试不同，在单元测试中我们单独测试我们的函数，而在集成测试中，我们确保当给定不同的输入集时，整个聚合函数和模块组能够产生正确的输出。'
- en: There might be other testing phases and philosophies, but in the following sections,
    we will be concentrating on the ones we've mentioned here, as they are the essential
    parts of the testing workflow, and I strongly encourage you to adopt all of those
    phases when shipping your code to production.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他测试阶段和哲学，但在接下来的章节中，我们将专注于我们在这里提到的那些，因为它们是测试工作流程的基本部分，我强烈建议你在将代码部署到生产环境时采用所有这些阶段。
- en: As said in the introduction for this chapter, testing Next.js is not different
    than testing a React application or an **Express.js/Fastify/Koa** web server.
    We need to choose the proper test runner and libraries and ensure that our code
    is working as expected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，测试 Next.js 与测试 React 应用程序或 **Express.js/Fastify/Koa** 网络服务器没有区别。我们需要选择合适的测试运行器和库，并确保我们的代码按预期工作。
- en: When talking about test runners, we refer to tools responsible for executing
    every test found in the code base, collecting the coverage, and displaying the
    test results in the console. If the test runner process fails (and exits with
    a non-zero exit code), the tests are considered to have failed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到测试运行器时，我们指的是负责执行代码库中找到的每个测试、收集覆盖率并在控制台显示测试结果的工具。如果测试运行器进程失败（并以非零退出代码退出），则认为测试失败。
- en: 'The Node.js and JavaScript ecosystems offer a large set of choices for test
    runners, but starting from the next section, we will be concentrating on the two
    most popular alternatives out there: **Jest** (for unit and integration tests)
    and **Cypress** (for **e2e**, short for **end-to-end**, tests).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 和 JavaScript 生态系统为测试运行器提供了大量的选择，但从下一节开始，我们将专注于两个最受欢迎的替代方案：**Jest**（用于单元和集成测试）和**Cypress**（用于**e2e**，即**端到端**测试）。
- en: Running unit and integration tests
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行单元和集成测试
- en: 'In this section, we will write some integration and unit tests by using one
    of the most popular test runners in the JavaScript ecosystem: Jest.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 JavaScript 生态系统中最受欢迎的测试运行器之一：Jest，编写一些集成和单元测试。
- en: 'Before installing all the dependencies we need, clone the following repository,
    which already contains a small web application that we''ll be using as an example
    for writing our te[sts: https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/boiler](https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/boilerplate)plate.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装所有需要的依赖项之前，克隆以下存储库，它已经包含了一个小型网络应用程序，我们将用它作为编写测试的示例：[https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/boilerplate](https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/boilerplate)。
- en: 'It''s a simple website with the following features:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有以下功能的简单网站：
- en: 'Two pages: a home page containing all the articles in our blog and a single
    article page.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个页面：一个包含我们博客中所有文章的主页和一个单独的文章页面。
- en: 'The article page URL implements the following format: `<article_slug>-<article-id>`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章页面 URL 实现了以下格式：`<article_slug>-<article-id>`。
- en: There are some utility functions that create the page's URL, retrieve the article
    ID from the article URL, and so on.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些实用函数用于创建页面的 URL、从文章 URL 中检索文章 ID 等。
- en: 'Two REST APIs: one for getting all the articles and one for getting a specific
    article given an ID.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 REST API：一个用于获取所有文章，另一个用于根据 ID 获取特定文章。
- en: 'Now let''s enter the project we''ve cloned and install the following dependency:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入我们克隆的项目，并安装以下依赖项：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Jest is the only dependency that we'll need for our tests, as it acts both as
    a testing framework and as a test runner. It provides an extensive set of features
    that will make our development (and testing) experience pleasant.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是我们测试所需的唯一依赖项，因为它既充当测试框架，也充当测试运行器。它提供了一套广泛的功能，将使我们的开发（和测试）体验变得愉快。
- en: 'Given that we''re writing our functions and components using ESNext" features,
    we want to tell Jest to use the default Next.js babel preset for transpiling those
    modules correctly. We can do that by creating a `.babelrc` file in our project''s
    root and adding the following content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 ESNext 特性编写函数和组件，我们希望告诉 Jest 使用默认的 Next.js babel 预设来正确转换这些模块。我们可以在项目的根目录中创建一个
    `.babelrc` 文件，并添加以下内容：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `next/babel` preset comes pre-installed with Next.js, so we don't need to
    install anything, and we're ready to go.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`next/babel` 预设是 Next.js 预先安装的，所以我们不需要安装任何东西，我们已经准备好开始使用了。'
- en: We can start using it without any other configuration, as it comes pre-configured
    for running every file ending with `.test.js` or `.spec.js`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始使用它而无需任何其他配置，因为它已经预先配置为运行所有以 `.test.js` 或 `.spec.js` 结尾的文件。
- en: 'Still, there are different approaches for how to write and where to place those
    files. For example, some people prefer to have a test file close to the source
    file, and others prefer to have all the tests inside a `tests/` directory. Of
    course, neither of those approaches is wrong: it''s up to your taste.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，关于如何编写和放置这些文件的方法有很多种。例如，有些人喜欢将测试文件放在源文件附近，而有些人则喜欢将所有测试放在 `tests/` 目录中。当然，这些方法都没有错：这取决于你的喜好。
- en: Pay Attention When Writing Next.js Pages' Tests
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Next.js 页面测试时请注意
- en: Next.js serves every `.js`, `.jsx`, `.ts`, and `.tsx` file placed inside of
    the `pages/` directory as an application page. Therefore, *you should never place
    any test file inside that directory*, or Next.js will try to render it as an application
    page. We will see how to test Next.js pages in the next section while writing
    end-to-end tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 将放置在 `pages/` 目录内的所有 `.js`、`.jsx`、`.ts` 和 `.tsx` 文件作为应用程序页面提供服务。因此，*你不应该在那个目录中放置任何测试文件*，否则
    Next.js 将尝试将其渲染为应用程序页面。我们将在下一节中编写端到端测试时看到如何测试 Next.js 页面。
- en: 'Let''s write our first test, starting from the easiest part of our code base:
    the utility functions. We can create a new file, `utils/tests/index.test.js`,
    and start by importing all the functions that we can find in our `utils/index.js`
    file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的第一个测试，从代码库中最简单的一部分开始：实用函数。我们可以创建一个新文件，`utils/tests/index.test.js`，并首先导入我们可以在
    `utils/index.js` 文件中找到的所有函数：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now write the first test for the `trimTextToLength` function. This function
    takes two arguments: a string and the length under which we will be cutting it,
    adding an ellipsis at its end. We use this function to show a sneak peek of the
    article body to tempt the reader to read the whole article.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写 `trimTextToLength` 函数的第一个测试。这个函数接受两个参数：一个字符串和我们将要切割的长度，并在其末尾添加省略号。我们使用这个函数来展示文章内容的预览，以诱使读者阅读整篇文章。
- en: 'For instance, pretend we have the following string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个以下字符串：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we apply `trimTextToLength` to it, we should see the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `trimTextToLength` 应用到它上面，我们应该看到以下输出：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can translate the preceding function description into code as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的函数描述翻译成以下代码：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we''re using some of Jest''s built-in functions, such as `describe`,
    `test`, and `expect`. They all have their specific function, and we can summarize
    them as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用 Jest 的内置函数，例如 `describe`、`test` 和 `expect`。它们各自都有其特定的功能，我们可以总结如下：
- en: '`describe`: Creates a group of related tests. For example, we should include
    tests regarding the same functions or modules inside of that function.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`: 创建一个相关测试的组。例如，我们应该在该函数内部包含与相同函数或模块相关的测试。'
- en: '`test`: Declares a test and runs it.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 声明一个测试并运行它。'
- en: '`expect`: This is the function that we use to compare our function''s outputs
    against a fixed number of results.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`: 这是我们将用于将我们的函数输出与固定数量的结果进行比较的函数。'
- en: 'As we''ve seen, we can add several tests into the `describe` group so that
    we can test our function against multiple values:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们可以在 `describe` 组中添加多个测试，以便我们可以针对多个值测试我们的函数：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Moving on to the `slugify` function, let''s try to write its own tests:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `slugify` 函数，让我们尝试为其编写自己的测试：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, try to implement the tests for the remaining functions on your own. If
    you have any doubt, you can find the complete test implemen[tation here: https://github.com/PacktPublishing/Real-World-Next.js/blob/main/09-testing-nextjs/unit-integration-tests/utils/tests/](https://github.com/PacktPublishing/Real-World-Next.js/blob/main/09-testing-nextjs/unit-integration-tests/utils/tests/index.test.js)index.test.js.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试自己实现剩余函数的测试。如果你有任何疑问，可以在以下链接中找到完整的测试实现：[https://github.com/PacktPublishing/Real-World-Next.js/blob/main/09-testing-nextjs/unit-integration-tests/utils/tests/index.test.js](https://github.com/PacktPublishing/Real-World-Next.js/blob/main/09-testing-nextjs/unit-integration-tests/utils/tests/index.test.js)。
- en: 'Once we''ve written all the remaining tests, we''re finally ready to run our
    test suite. To make it easier and standard, we can create a new script inside
    of our `package.json` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了所有剩余的测试，我们就可以最终运行我们的测试套件。为了使其更简单和标准化，我们可以在 `package.json` 文件中创建一个新的脚本：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And that''s all we need! We can now type `yarn test` in the console and admire
    the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！现在我们可以在控制台中输入 `yarn test` 并欣赏以下输出：
- en: '![Figure 9.1 – Unit test output'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – 单元测试输出'
- en: '](img/Figure_9.01_B16985.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B16985.jpg)'
- en: Figure 9.1 – Unit test output
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 单元测试输出
- en: We can now move on to writing a more complex test. If you open the `components/ArticleCard/index.js`
    file, you will see a simple React component that creates a link to a Next.js page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续编写更复杂的测试。如果你打开 `components/ArticleCard/index.js` 文件，你会看到一个简单的 React
    组件，它创建了一个指向 Next.js 页面的链接。
- en: In that case, we want to test that our `composeArticleSlug` and `trimTextToLength`
    functions (used in that component) integrate correctly by producing the expected
    output. We also want to test that the displayed text will match a fixed result
    when given an article as input.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们想要测试我们的 `composeArticleSlug` 和 `trimTextToLength` 函数（在该组件中使用）是否正确集成，并产生预期的输出。我们还想测试当给定一个文章作为输入时，显示的文本将匹配一个固定的结果。
- en: Sadly, Jest alone is not enough for testing React components. We will need to
    mount and render them to test their output, and specific libraries do that incredibly
    well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，Jest 单独不足以测试 React 组件。我们需要挂载和渲染它们来测试它们的输出，而特定的库在这方面做得非常好。
- en: The most popular options out there are `react-testing-library`, but feel free
    to experiment with Enzyme and see which approach you prefer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最受欢迎的选项是 `react-testing-library`，但你可以自由地尝试使用 Enzyme，看看哪种方法更符合你的喜好。
- en: 'Let''s install the `react-testing-library` package by running this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来安装 `react-testing-library` 包：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's move on to create a new file named `components/ArticleCard/tests/index.test.js`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建一个名为 `components/ArticleCard/tests/index.test.js` 的新文件。
- en: Before moving on to the test implementation, let's consider something. We now
    need to test our `ArticleCard` component against a REST API, but we won't be running
    the server during the test's execution. Right now, we're not testing that our
    API is responding with the correct JSON containing the article, we're just testing
    that given an article as input, the component will produce a fixed output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续测试实现之前，让我们考虑一下。我们现在需要测试我们的 `ArticleCard` 组件与 REST API 的兼容性，但在测试执行期间我们不会运行服务器。目前，我们不是测试我们的
    API 是否以正确的 JSON 格式响应包含文章，我们只是在测试给定一个文章作为输入时，组件是否会生成固定的输出。
- en: That said, we can easily create a mock containing all the information we expect
    an article to contain, and give it as an input to our component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们可以轻松地创建一个包含我们期望文章包含的所有信息的模拟，并将其作为输入提供给我们的组件。
- en: 'Let''s create a new file, `components/ArticleCard/tests/mock.js`, with the
    following content (or just copy it from this book''s GitHub repository under `09-testing-nextjs/unit-integration-tests/components/ArticleCard/tests/mock.js`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件，`components/ArticleCard/tests/mock.js`，并包含以下内容（或者直接从本书的 GitHub 仓库中的
    `09-testing-nextjs/unit-integration-tests/components/ArticleCard/tests/mock.js`
    复制过来）：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you try to run the Next.js server, you will see that the APIs inside of `pages/api/`
    will return either an array of articles or a single article in the same format
    we used for the mock.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行 Next.js 服务器，你会看到 `pages/api/` 内部的 API 将返回一个文章数组或单个文章，格式与我们用于模拟的相同。
- en: 'We''re finally ready to write our tests. Open the `components/ArticleCard/tests/index.test.js`
    file and start by importing the react-testing-library functions, the components,
    mocks, and utilities we want to test:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好编写测试了。打开 `components/ArticleCard/tests/index.test.js` 文件，并首先导入我们想要测试的
    react-testing-library 函数、组件、模拟和实用工具：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now let's write our first test case. If we open the `ArticleCard` component,
    we will see that there's a Next.js Link component wrapping the entire card. This
    link's `href` should be in the format `/articles/<article-title-slugified>-id`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写第一个测试用例。如果我们打开`ArticleCard`组件，我们会看到整个卡片都被Next.js链接组件包裹。这个链接的`href`应该遵循`/articles/<article-title-slugified>-id`的格式。
- en: 'As a first test case, we will test that there''s one link, where the `href`
    attribute is equal to /`articles/healthy-summer-meloncarrot-soup-u12w3o0d` (which
    is the title we can see in our mock, plus the article ID):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个测试用例，我们将测试是否存在一个链接，其中`href`属性等于`/articles/healthy-summer-meloncarrot-soup-u12w3o0d`（这是我们模拟中可以看到的标题加上文章ID）：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We're using the react-testing-library `render` method to mount and render the
    component, then we get the link and extract its `href` attribute. We eventually
    test this attribute value against a fixed string, which is the expected value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用react-testing-library的`render`方法来挂载和渲染组件，然后获取链接并提取其`href`属性。我们最终将这个属性值与一个固定字符串进行比较，这是预期的值。
- en: 'Still, there is a problem with our test. If we try to run it, we will see the
    following error appearing in the console:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的测试还存在一个问题。如果我们尝试运行它，我们将在控制台看到以下错误：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's because react-testing-library relies on the browser's document global
    variable, which is unavailable in Node.js.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为react-testing-library依赖于浏览器文档的全局变量，而在Node.js中不可用。
- en: 'We can quickly solve this problem by changing the Jest environment for this
    test file to JSDOM, a library that emulates a large part of the browser''s features
    for testing purposes. We don''t need to install anything; we can just add the
    following comment at the top of our testing file, right before the `import` statements,
    and Jest will do the rest:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将此测试文件的Jest环境更改为JSDOM（一个用于测试目的模拟浏览器大部分功能的库）来快速解决这个问题。我们不需要安装任何东西；我们只需在测试文件顶部添加以下注释，在`import`语句之前，Jest就会完成剩余的工作：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we now run `yarn test` in the terminal, the tests will succeed as expected.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在终端中运行`yarn test`，测试将如预期那样成功。
- en: Inside the `ArticleCard` component, we show a brief extract of the article body
    to tempt the reader to read the entire piece. It uses the `trimTextToLength` function
    to trim the article body to a maximum length of 100 characters, so we expect to
    see those first 100 chapters inside the rendered component.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArticleCard`组件内部，我们展示文章内容的简要摘录，以诱使读者阅读整篇文章。它使用`trimTextToLength`函数将文章内容截断到最大长度为100个字符，因此我们期望在渲染的组件中看到前100个章节。
- en: 'We can proceed with writing a test as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式编写测试：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, we render the whole component, then generate the article summary
    and expect it to exist inside our document.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们渲染整个组件，然后生成文章摘要，并期望它存在于我们的文档中。
- en: That was an elementary example of how we can test our code base by using Jest
    and react-testing-library. When writing a real-world application, we also want
    to test our components against incorrect data to see if they can handle any errors
    correctly, either by throwing an error, showing a message on the screen, and so
    on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个如何使用Jest和react-testing-library测试我们的代码库的基本示例。在编写实际应用时，我们也想测试我们的组件对错误数据的处理能力，看看它们是否可以正确处理任何错误，无论是抛出错误、在屏幕上显示消息等等。
- en: 'Testing is not an easy topic, but it must be taken seriously as it can help
    us avoid shipping broken code or introducing regressions (for example, breaking
    a component that was previously working fine) into the existing code base. It
    is such a complex matter that there''s also an entire book on how to test React
    components using react-testing-library: *Simplify Testing with React Testing Library*
    by Scottie Crump, published by Packt.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不是一个容易的话题，但我们必须认真对待，因为它可以帮助我们避免发布损坏的代码或引入回归（例如，破坏之前工作良好的组件）到现有的代码库中。这是一个如此复杂的问题，以至于还有一本关于如何使用react-testing-library测试React组件的整本书：由Scottie
    Crump所著，Packt出版社出版的《使用React Testing Library简化测试》。
- en: If you're interested in learning more and digging deep into React testing, I
    strongly suggest reading this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此感兴趣并想深入了解React测试，我强烈建议阅读这本书。
- en: That said, there is still one piece missing in our tests. We're not testing
    the full-page renders, whether the APIs send back correct data, and whether we
    can navigate correctly between pages. But that's what end-to-end tests are all
    about, and we will discuss this in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们的测试中仍然缺少一部分。我们没有测试完整页面的渲染，API是否发送了正确数据，以及我们是否可以在页面之间正确导航。但这正是端到端测试的全部内容，我们将在下一节中讨论这一点。
- en: End-to-end testing with Cypress
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行端到端测试
- en: Cypress is a powerful testing tool that can test anything that runs on a web
    browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 是一个强大的测试工具，可以测试在网页浏览器上运行的任何内容。
- en: It enables you to write and run unit, integration, and end-to-end tests efficiently
    by running them on Firefox and Chromium-based browsers (for example, Google Chrome).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许您通过在基于 Firefox 和 Chromium 的浏览器（例如 Google Chrome）上运行测试来高效地编写和运行单元、集成和端到端测试。
- en: So far, we have written tests for understanding whether our functions and components
    are working as expected. Now it's time to test whether the entire application
    is working correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了测试来了解我们的函数和组件是否按预期工作。现在，我们需要测试整个应用程序是否正确工作。
- en: 'To get started with Cypress, we just need to install it as a `dev` dependency
    in our project. We will be using the same project as the latest section, but if
    you want to get started from a clean project, you can clone the following repository
    [and get started from there: https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-](https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/unit-integration-tests)nextjs/unit-integration-tests.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Cypress，我们只需将其作为项目的 `dev` 依赖项安装。我们将使用与最新部分相同的同一个项目，但如果您想从一个干净的项目开始，您可以克隆以下存储库
    [并从这里开始：https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-](https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/unit-integration-tests)nextjs/unit-integration-tests。
- en: 'Let''s install Cypress by typing the following command into the terminal:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中输入以下命令来安装 Cypress：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once Cypress is installed, we can edit our main `package.json` file by adding
    the following script:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Cypress，我们就可以通过添加以下脚本来编辑我们的主 `package.json` 文件：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now need to create a Cypress configuration file. Let's write a `cypress.json`
    file in the project root containing the follo[wing content:](http://localhost:3000)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个 Cypress 配置文件。让我们在项目根目录中编写一个 `cypress.json` 文件，包含以下内容：[http://localhost:3000](http://localhost:3000)
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we're telling Cypress where to look when running tests; in our case, `localhost:3000`.
    Now that we're all set, let's move on to writing our first tests!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 Cypress 在运行测试时查找的位置；在我们的案例中，`localhost:3000`。现在我们已经准备好了，让我们继续编写我们的第一个测试！
- en: By convention, we will be putting our end-to-end tests inside a folder called
    `cypress/`, placed at the root level of the repository.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们将把我们的端到端测试放在一个名为 `cypress/` 的文件夹中，该文件夹位于存储库的根级别。
- en: We will start with an easy test to verify that our REST APIs are working correctly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一项简单的测试开始，以验证我们的 REST API 是否正确工作。
- en: 'If you open the `pages/api/` folder, you will see two different APIs:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开 `pages/api/` 文件夹，您将看到两个不同的 API：
- en: '`articles.js`, which returns a list of articles:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`articles.js`，它返回一系列文章：'
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`article/index.js`, which takes an article ID as a query string parameter and
    returns the single article with that ID:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`article/index.js`，它接受一个文章 ID 作为查询字符串参数，并返回具有该 ID 的单个文章：'
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s create our first Cypress test file, named `cypress/integration/api.spec.js`,
    and add the following content:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个 Cypress 测试文件，命名为 `cypress/integration/api.spec.js`，并添加以下内容：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The APIs are slightly different from the Jest ones, but we can still see that
    they share the same philosophy. We use them to describe the response coming from
    the server, testing it against a fixed value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: API 与 Jest 的略有不同，但我们仍然可以看出它们共享相同的理念。我们使用它们来描述来自服务器的响应，并对其进行固定值的测试。
- en: In the preceding example, we're just testing that the HTTP headers include the
    `content-type=application/json header`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是在测试 HTTP 头部是否包含 `content-type=application/json` 头部。
- en: 'We can proceed by testing the status code, which should be equal to `200`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过测试状态码来继续操作，该状态码应等于 `200`：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Moving on to a more complex test case, we can test the API output to be an
    array of objects, where each object must contain a minimum set of properties.
    The test implementation would look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行一个更复杂的测试案例，测试 API 输出是否为对象的数组，其中每个对象必须包含一组最小属性。测试实现将如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we're using the `.to.have.keys` method to test that returning
    object contains all the keys specified in the function argument.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用 `.to.have.keys` 方法来测试返回的对象是否包含函数参数中指定的所有键。
- en: Another thing to notice is that we're doing that in an `each` loop. For that
    reason, we will need to call the `done` method (highlighted in the code snippet)
    once we've tested all the desired properties, as Cypress cannot control when the
    code inside of the `each` callback has returned.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是我们正在 `each` 循环中这样做。因此，一旦我们测试了所有期望的属性，我们就需要调用 `done` 方法（代码片段中突出显示），因为
    Cypress 无法控制 `each` 回调内部的代码何时返回。
- en: 'We can proceed by writing another couple of tests to see if we can get a single
    article given a fixed article ID:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续编写另外几个测试，看看我们是否可以给定一个固定的文章 ID 获取单个文章：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And we can also test that the server returns a `404` status code when the article
    is not found. To do that, we will need to change our request method a bit as Cypress,
    by default, throws an error when a status code greater than or equal to 400 is
    encountered:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试当文章未找到时，服务器返回的 `404` 状态码。为此，我们需要稍微更改我们的请求方法，因为 Cypress 默认情况下，在遇到大于或等于
    400 的状态码时会抛出错误：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have written the tests, we''re ready to run them, but there''s
    still a problem. If we try to run `yarn cypress`, we will see the following error
    on the console:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了测试，我们准备运行它们，但仍然存在问题。如果我们尝试运行 `yarn cypress`，我们将在控制台看到以下错误：
- en: '![Figure 9.2 – Cypress cannot connect to the server'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – Cypress 无法连接到服务器'
- en: '](img/Figure_9.02_B16985.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B16985.jpg)'
- en: Figure 9.2 – Cypress cannot connect to the server
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – Cypress 无法连接到服务器
- en: 'In fact, Cypress runs our tests against a real server, which is not reachable
    at the moment. We can quickly solve that by adding the following dependency:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Cypress 是在针对一个真实的服务器运行我们的测试，但目前这个服务器是不可访问的。我们可以通过添加以下依赖项快速解决这个问题：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will help us by building and starting the server, and once it''s reachable,
    it will run Cypress. To do that, we will need to edit our `package.json` file
    too:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们通过构建和启动服务器，一旦它可访问，它将运行 Cypress。为此，我们还需要编辑我们的 `package.json` 文件：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we now try to run `yarn e2e`, we will see that the tests are passing correctly!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行 `yarn e2e`，我们将看到测试正在正确通过！
- en: 'Let''s create one last test file where we''ll be testing the navigation between
    pages. We can call it `cypress/integration/navigation.spec.js`, and we can add
    the following content:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个最后的测试文件，我们将在这里测试页面之间的导航。我们可以将其命名为 `cypress/integration/navigation.spec.js`，并添加以下内容：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the first test case, we're asking Cypress to visit our website's home page.
    Then, we look for all the links where the `href` property contains `/articles`.
    We then click on the first occurrence and expect the new URL to be equal to a
    fixed value (`http://localhost:3000/articles/healthy-summer-meloncarrot-soup-u12w3o0d`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试用例中，我们要求 Cypress 访问我们网站的首页。然后，我们查找所有 `href` 属性包含 `/articles` 的链接。然后我们点击第一个出现的链接，并期望新的
    URL 等于一个固定的值（`http://localhost:3000/articles/healthy-summer-meloncarrot-soup-u12w3o0d`）。
- en: We also test that the `<h1>` HTML element contains the correct title. But what
    does this test tell us?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还测试了 `<h1>` HTML 元素包含正确的标题。但这个测试告诉我们什么？
- en: We can navigate between pages; links aren't broken. Then, of course, we should
    add more and more tests for links, but we just want to look at the concept right
    now.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在页面之间导航；链接没有损坏。当然，我们接下来应该为链接添加更多的测试，但我们现在只想看看这个概念。
- en: The Next.js server correctly asks and serves the correct data, since we can
    spot the right title inside the rendered page.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js 服务器正确地请求并提供了正确数据，因为我们可以在渲染的页面中找到正确的标题。
- en: In the second test case, we ask Cypress to visit a single article page, then
    click on a link to go back to the home page. Again, we test the new URL is correct,
    and the `<h1>` HTML element contains the right title for the home page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试用例中，我们要求 Cypress 访问单个文章页面，然后点击链接返回主页。我们再次测试新的 URL 是否正确，以及 `<h1>` HTML
    元素包含主页的正确标题。
- en: Of course, these are not complete tests, as we might want to check whether the
    behavior of the website is consistent between browsers (especially if we do a
    lot of client-side rendering), that an existing form gets validated correctly,
    giving accurate feedback to the user, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些测试并不完整，因为我们可能还想检查网站的行为在不同浏览器之间是否一致（特别是如果我们做了很多客户端渲染），现有的表单是否得到正确验证，为用户提供准确的反馈，等等。
- en: Like unit and integration testing, end-to-end testing is a vast and complex
    topic that we must deal with before shipping code to production, as it can ensure
    greater quality for our product, with fewer bugs and more control over regressions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单元测试和集成测试一样，端到端测试是一个庞大且复杂的主题，在我们将代码部署到生产环境之前必须处理，因为它可以确保我们的产品拥有更高的质量，更少的错误，并对回归有更多的控制。
- en: If you're interested in learning more about Cypress, I suggest you read the
    book *End-to-End Web Testing with Cypress*, by Waweru Mwaura, published by Packt.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于 Cypress 的信息，我建议你阅读由 Waweru Mwaura 撰写并由 Packt 出版的书籍《使用 Cypress 进行端到端
    Web 测试》。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've seen how to write unit, integration, and end-to-end tests
    using some of the most popular libraries and test runners out there, such as Cypress,
    Jest, and react-testing-library.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用一些最受欢迎的库和测试运行器来编写单元、集成和端到端测试，例如 Cypress、Jest 和 react-testing-library。
- en: As mentioned multiple times during the chapter, testing is essential for any
    application development and release process. It should be taken seriously as it
    can be the difference between a successful and an unsuccessful product.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章多次提到的，测试对于任何应用程序的开发和发布过程都是至关重要的。它应该被认真对待，因为它可能是成功产品与失败产品之间的区别。
- en: 'In the next chapter, we will focus on a different yet crucial topic: SEO and
    performance. Even if our code base is 100% tested, well-designed, and working
    great, we need to consider its SEO score and performance. In many cases, we want
    as many people as possible to be browsing our applications, and we must take care
    of search engine optimization to reach a large audience to validate our product.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注一个不同但同样关键的主题：SEO 和性能。即使我们的代码库已经100%经过测试、设计良好且运行出色，我们也需要考虑其 SEO 分数和性能。在许多情况下，我们希望尽可能多的人浏览我们的应用程序，我们必须注意搜索引擎优化，以吸引大量受众来验证我们的产品。
