- en: 2\. Working with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will expand on what you learned in the previous chapter
    by introducing more ways to control data inside Vue components. You will learn
    how to set up advanced watchers to observe data changes inside your components,
    and utilize Vue's powerful reactive data feature, computed data properties, to
    concisely output just the data you need in your template. You will also be able
    to utilize asynchronous methods to fetch data for your Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to watch, manage, and manipulate
    data from various sources in your Vue.js components.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you were introduced to the concepts of single-file
    components and the Vue API, which provides access to methods, directives, and
    data properties. Building on these foundations, we will be introducing computed
    properties, which, like data properties, are reactive in the UI but can perform
    powerful calculations, and their results are cacheable, increasing the performance
    of your project. When building e-commerce stores, you will usually want to calculate
    pricing and cart items reactively as users interact with your UI, which in the
    past would need to be achieved without a page reload using something like `jQuery`.
    Vue.js makes short work of these common frontend tasks by introducing computed
    properties that react immediately to frontend user input.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by introducing reactive data that can be computed on the fly and
    understanding how to call and manipulate asynchronous data.
  prefs: []
  type: TYPE_NORMAL
- en: Computed Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computed properties are a unique data type that will reactively update when
    source data used within the property is updated. They may look like a Vue method,
    but they are not. In Vue, we can track changes to a data property by defining
    them as a computed property, add custom logic within this property, and use it
    anywhere within the component to return a value. Computed properties are cached
    by Vue, making them more performant for returning data than a data prop or using
    a Vue method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances where you may use a computed property include but are not limited
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`total` data property is less than `1`. The computed property for `total` will
    update every time a new piece of data is added to the `items` array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will generate the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`formalName`, that can be used within your component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will generate the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`post`. You will use the simplified and semantic computed properties to output
    the information into your components template. The computed properties in this
    example make it easier to identify and use the author''s full name, see how many
    posts they have produced, and have the data to display their featured post:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will generate the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.1: The computed name output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.1: The computed name output'
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties are very valuable to a Vue developer when creating performant components.
    In the next exercise, we will explore how to use this inside of a Vue component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.01: Implementing Computed Data into a Vue Component'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will use a computed property to help cut down the amount
    of code you need to write inside your Vue templates by concisely outputting basic
    data. To access the code files for this exercise, refer to [https://packt.live/3n1fQZY](https://packt.live/3n1fQZY).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal, navigate into the `Exercise 2.01` folder, and
    run the following commands in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to `https://localhost:8080`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an input field for the first name, use `v-model` to bind the data prop
    `firstName` to this field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a second input field for the last name, and use `v-model` to bind the
    data prop `lastName` to this field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include these new `v-model` data props in the Vue instance by returning them
    in the `data()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a computed data variable called `fullName`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Underneath your input fields, using `heading` tags, output the computed data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will generate the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.2: Output of the computed data will show the first and last name'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.2: Output of the computed data will show the first and last name'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can write an expression inside a computed data
    property using data from the `v-model` and combine the first name and last name
    into a single output variable that can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Computed Setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last exercise, you saw how to write maintainable and declarative computed
    properties that are reusable and reactive and can be called anywhere within your
    component. In some real-world cases when a computed property is called, you may
    need to call an external API to correspond with that UI interaction or mutate
    data elsewhere in the project. The thing that performs this function is called
    a setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computed setters are demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, computed data is a getter only, which means it will only output
    the outcome of your expression. In this example, the computed `myComputedDataProp`
    data prop will output `1` in your Vue component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then, using a setter in a computed property allows you to reactively listen
    to data and run a callback (setter) that contains the returned value from the
    getter, which can optionally be used in the setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the setter will update the data prop count to its new value
    (reflected in the getter) and then call a method within the component called `callAnotherApi`.
    Here, we pass in the count data prop to mimic sending this information somewhere
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You will find out exactly how to use computed data as both getters and setters
    in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.02: Using Computed Setters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will use a computed prop as a setter and a getter, which
    will both output expressions and set data when triggered by a user's input.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/2GwYapA](https://packt.live/2GwYapA).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal, navigate into the `Exercise 2.02` folder, and
    run the following commands in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to `https://localhost:8080`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an input field with a `v-model` value bound to a computed data value
    called `incrementOne`, return the value of a Vue data variable called `count`
    in the getter, and set the `count` variable in the setter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.3: First steps of a computed setter and getter'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.3: First steps of a computed setter and getter'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s utilize the setter again. We will divide whatever the new `val`
    argument is by `2`, and save that to a new data variable called `divideByTwo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the setter to divide `val` by `2`, and bind this new value to the `divideByTwo`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the `divideByTwo` value should generate an outcome from the value
    entered in the input field, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.4: The outcome of the divideByTwo value'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.4: The outcome of the divideByTwo value'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can use computed data to both get and set data
    reactively in our template by binding computed variables to the `v-model`.
  prefs: []
  type: TYPE_NORMAL
- en: Watchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue `oldVal` and `newVal`. This can help you when writing expressions to compare
    data before writing or binding new values. Watchers can observe objects as well
    as `string`, `number`, and `array` types. When observing objects, it will only
    trigger the handler if the whole object changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *Starting Your First Vue Project*, we introduced life cycle
    hooks that run at specific times during a component''s lifespan. If the `immediate`
    key is set to `true` on a watcher, then when this component initializes it will
    run this watcher on creation. You can watch all keys inside of any given object
    by including the key and value `deep: true` (default is `false`) To clean up your
    watcher code, you can assign a handler argument to a defined Vue method, which
    is best practice for large projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Watchers complement the usage of computed data since they can passively observe
    values and cannot be used like normal Vue data variables, while computed data
    must always return a value and can be looked up. Remember not to use arrow functions
    unless you do not require the Vue context of `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following watcher example demonstrates the `immediate` and `deep` optional
    keys; if any key inside of the `myDataProperty` object were to change it would
    trigger a console log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's set some new values with the help of watchers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.03: Using Watchers to Set New Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will use watcher arguments to watch data properties for
    changes, then use this watcher to set variables via a method.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/350ORI4](https://packt.live/350ORI4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal, navigate into the `Exercise 2.03` folder, and
    run the following commands in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to `https://localhost:8080`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up the document by adding a discount and an `oldDiscount` data variable
    with some styling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe the `discount` property by adding it to the `watch` object. Trigger
    a method called `updateDiscount`. Inside the method, set the `oldDiscount` data
    prop to be `this.discount + 5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include a method that will augment the `discount` variable and trigger the watcher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add a line break, and an anchor element with the `@click` directive bound
    to the `updateDiscount` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding command will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.5: A shop watcher page should look something like this'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.5: A shop watcher page should look something like this'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can use watchers to observe and reactively manipulate
    data when data is changed by other methods in the Vue component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about deep watching concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Deep Watching Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using Vue.js to watch a data property, you can purposefully observe keys
    inside an object for changes, rather than changes to the object itself. This is
    done by setting the optional `deep` property to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This example will watch all available keys inside the organization data object
    for changes, so if the `name` property inside the organization changes, the organization
    watcher will trigger.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not need to observe every key inside of an object, it can be more
    performant to just watch a specific key inside an object for changes by specifying
    it as a `myObj.value` string. For example, you may allow a user to edit their
    company name and have that data sent to an API only when that key has been modified.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the watcher is specifically observing the `name` key
    of the `organization` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We saw how deep watching works. Now, let's try the next exercise and watch the
    nested properties of a data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Watching Nested Properties of a Data Object'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will use watchers to observe keys within an object, which
    will update when a user triggers a method within the UI.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/353m59N](https://packt.live/353m59N).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal, navigate to the `Exercise 2.04` folder, and run
    the following commands in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to `https://localhost:8080`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start by defining a `product` object that contains a `price` and `label` and
    a `discount` key. Output these values into the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up a button that will modify the price of the product. Do this by adding
    a button element with a `click` event bound to an `updatePrice` method that decrements
    the value of price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you click the button, it should reduce the price as seen in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.6: Screen displaying the reduced price of Blue juice'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.6: Screen displaying the reduced price of Blue juice'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Time for the nested watcher. We will watch the `product` object''s `price`,
    and increment the `discount` data prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as you reduce the `price`, the `discount` value will go up because of
    the watcher:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.7 Output displaying an increased discount value'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.7 Output displaying an increased discount value
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used watchers to observe a key inside an object and then
    set new data with or without using the optional arguments parsed by the watcher.
  prefs: []
  type: TYPE_NORMAL
- en: Methods versus Watchers versus Computed Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Vue.js toolbox, we have access to methods, watchers, and computed properties.
    When should you use one or the other?
  prefs: []
  type: TYPE_NORMAL
- en: Methods are best used to react to an event occurring in the `date.now()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Vue, you would compose an action denoted by `@click`, and reference a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Computed props are best used when reacting to data updates or for composing
    complicated expressions for us in your template. In this instance, if the `animalList`
    data changes, the `animals` computed prop will also update by slicing the second
    item from the array and returning the new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Their reactive nature makes computed properties perfect for composing new data
    variables from existing data, such as when you are referencing specific keys of
    a larger, more complicated object, helping to simplify readability of your template.
    In this example, we output the authors twice in two different ways. However, notice
    in the `authorName` computed prop, you can compose conditional logic cleanly without
    bloating the HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Data watchers should be used when you need to listen to a data property change
    or a specific data property inside an object, and then perform an action. Because
    of the unique `newVal` and `oldVal` arguments of a watcher, you can watch a variable
    until a certain value is reached, and only then perform an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this in mind, we will build a simple search functionality using a method,
    computed props, and a watcher to achieve a similar outcome and demonstrate the
    ability of each method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.05: Handling Search Functionality Using a Vue Method, a Watcher,
    and Computed Props'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create a component that allows users to search data
    arrays using three different methods in Vue. By the end of the exercise, you will
    be able to see firsthand how each different method works.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/32iDJVe](https://packt.live/32iDJVe).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the command-line terminal, navigate to the `Exercise 2.05` folder, and run
    the following commands in order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to `https://localhost:8080`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `data` object, add a list of frameworks in an array, assigned to the
    `frameworkList` value. Include an empty string with the key to input and an empty
    array with a key of `methodFilterList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the template, include a `div` container, a `title`, and a `column` container.
    Inside this `column` container, create an input that is bound to the `v-model`
    input, and bind the `keyup` event on the input to the `searchMethod` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.8: Console should output the key input'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.8: Console should output the key input'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside our `searchMethod` method, write a filter expression that binds the
    `methodFilterList` data prop to a filtered `frameworkList` array based on the
    input value. Trigger `searchMethod` on the `created()` life cycle hook so that
    when the component loads, a list is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On running the preceding code, you will be able to filter the list as shown
    in *Figure 2.9*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.9: You should now be able to filter the list using a Vue method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.9: You should now be able to filter the list using a Vue method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s make a filter using computed props. Include a new data prop called `input2`
    and create a `computed` prop called `computedList` that returns the same filter
    as the `searchMethod` but does not need to bind to another data prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now be able to filter the second column of frameworks with the help
    of computed props, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.10: Filtering the second column of frameworks using computed props'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.10: Filtering the second column of frameworks using computed props'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let''s filter the same list using a watcher. Include an `input3` prop
    with an empty string and `watchFilterList` prop with an empty array. Also create
    a third column `div`, which contains an input bound to the `input3` `v-model`,
    and a list outputting the `watchFilterList` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a watcher that watches the `input3` prop for changes and binds the result
    of the `frameworkList` filter to the `watchFilterList` array. Set the immediate
    key of `input3` to `true` so it will run when the component is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the help of a watcher, you should now be able to filter the third column,
    as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.11: Filtering the list using a watcher in the third column'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.11: Filtering the list using a watcher in the third column'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have seen how we can achieve a filtered list using a method,
    computed props, and a watcher. Each has their own pros, cons, and use cases depending
    on what you are trying to achieve in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Async Methods and Data Fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous functions in JavaScript are defined by the async function syntax
    and return an `AsyncFunction` object. These functions operate asynchronously via
    the event loop, using an implicit promise, which is an object that may return
    a result in the future. Vue.js uses this JavaScript behavior to allow you to declare
    asynchronous blocks of code inside methods by including the `async` keyword in
    front of a method. You can then chain `then()` and `catch()` functions or try
    the `{}` syntax inside these Vue methods and return the results.
  prefs: []
  type: TYPE_NORMAL
- en: '`Axios` is a popular JavaScript library that allows you to make external requests
    for data using Node.js. It has wide browser support making it a versatile library
    when doing `HTTP` or API requests. We will be using this library in the next exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.06: Using Asynchronous Methods to Retrieve Data from an API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will asynchronously fetch data from an external API source
    and display it in the frontend using computed props.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/353md9h](https://packt.live/353md9h).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command-line terminal, navigate to the `Exercise 2.06` folder, and run
    the following commands to install `axios`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to `https://localhost:8080`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s start by importing `axios` into our component and creating a method
    called `getApi()`. Use `axios` to call a response from [https://api.adviceslip.com/advice](https://api.adviceslip.com/advice)
    and `console.log` the result. Include a button that has a `click` event bound
    to the `getApi()` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.12: Screen displaying a very large object in the console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.12: Screen displaying a very large object in the console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We are only interested in the data object inside the `response` object. Assign
    this data object to a Vue data prop called `response` that we can reuse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output the `quote` from inside the `response` prop object using a computed
    prop that will update every time the `response` prop changes. Use a ternary operator
    to perform a conditional statement to check whether the `response` prop contains
    the `slip` object to avoid errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Figure 2.13* displays the output generated by the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.13: Screen displaying the quote output in your template'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_02_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.13: Screen displaying the quote output in your template'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a final touch, include a `loading` data prop so the user can see when the
    UI is loading. Set `loading` to `false` by default. Inside the `getApi` method,
    set `loading` to `true`, and in the `then()` chain, set it back to `false` after
    4 seconds using the `setTimeout` function. You can use a ternary operator to change
    the button text between the loading state and its default state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14: Screen displaying the loading button state output in your template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_02_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.14: Screen displaying the loading button state output in your template'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can fetch data from an external source, assign
    it to a computed prop, display it in our template, and apply a loading state to
    our content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Creating a Blog List Using the Contentful API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will build a blog that lists articles from an API source.
    This will test your knowledge of Vue by using all the basic functions of a `async`
    methods to fetch remote data from an API and use computed properties to organize
    deep nested object structures.
  prefs: []
  type: TYPE_NORMAL
- en: '`Contentful` is a headless **content management system** (**CMS**) that allows
    you to manage content separately to your code repository. You can consume this
    content using the API inside as many code repositories as you need. For example,
    you may have a blog website that acts as a primary source of information, but
    your clients want a standalone page on a different domain that only pulls in the
    most recent featured articles. Using a headless CMS inherently allows you to develop
    these two separate code bases and use the same updated data source.'
  prefs: []
  type: TYPE_NORMAL
- en: This activity will be using the headless CMS `Contentful`. The access keys and
    endpoints will be listed in the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Vue CLI to create a new project that uses `babel` presets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `contentful` dependency into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use computed properties to output the deeply nested data from the API response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `data` props to output the user's `name`, `job title`, and `description`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `SCSS` to style the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected outcome is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: Expected outcome with Contentful blog posts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_02_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15: Expected outcome with Contentful blog posts'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor383).
  prefs: []
  type: TYPE_NORMAL
- en: After the activity has been completed, you should be able to use `async` methods
    to pull remote data from an API source into your Vue components. You will find
    that computed props are a sophisticated way of breaking down the information into
    smaller chunks of reusable data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to Vue.js computed and watch properties,
    which allow you to observe and control reactive data. You also saw how to use
    methods to asynchronously fetch data from an API using the `axios` library and
    how to flatten the data to be more usable within the Vue template using computed
    props. The differences between using methods and computed and watch properties
    were demonstrated by building search functionality using each method.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover the Vue CLI and show you how to manage and debug
    your Vue.js applications that use these computed properties and events.
  prefs: []
  type: TYPE_NORMAL
