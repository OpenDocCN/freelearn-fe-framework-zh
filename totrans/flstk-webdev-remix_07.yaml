- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling in Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error handling is an important part of building resilient user experiences.
    We can distinguish two kinds of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected errors, such as network timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expected failures (exceptions) thrown on purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remix provides primitives and conventions to handle both unexpected and expected
    errors uniformly. This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with unexpected errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling thrown responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling page-not-found (404) errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will fabricate some unexpected errors and learn how to handle them.
    Next, we will review the difference between returning and throwing `Response`
    objects in `loader` and `action` functions. We will see how we can handle thrown
    responses with Remix’s `ErrorBoundary`. Finally, we will add not-found error handling
    to BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand how to manage both unexpected
    and expected failures in Remix declaratively using Remix’s `ErrorBoundary` component.
    You will also know how throwing responses fits into Remix’s exception-handling
    story and know the difference between throwing and returning responses. Finally,
    you will know how to handle not-found errors with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can go ahead and use the solution from the previous chapter. No additional
    setup steps are required for this chapter. If you get stuck, you can find the
    solution code for this chapter here: https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/07-error-handling-in-remix.'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with unexpected errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During runtime, a Remix application is executed both in the browser and on the
    server. A lot can go wrong, and unexpected errors can happen both on the client
    and server. It is important to consider the error case to provide a resilient
    user experience. In this section, we will investigate how to handle unexpected
    errors in Remix both at the root level and in nested routes.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking client and server errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030), *Creating a New Remix App*,
    we provided a troubleshooting guide and investigated how Remix handles errors
    on both the client and server uniformly. Let’s review Remix’s default error handling
    again by invoking some “unexpected” errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your BeeRich application in an editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `dashboard.tsx` route module inside the `app/routes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code inside the `loader` function body before the return
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By throwing an error in a `loader` function, we prevent the application from
    handling incoming requests. This creates an unexpected failure on the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute `npm run dev` in a terminal to run the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the BeeRich dashboard by opening [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    in a new browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Throwing an error in a `loader` function renders Remix’s error page, as visible
    in *Figure 7**.1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Application error in the loader function](img/Figure_07.1_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Application error in the loader function
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.1* showcases Remix’s default behavior when handling unexpected
    errors. We can see our error message stating “Something went wrong!” on the screen
    and the stack trace of the `loader` function that failed to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s throw an error in a route component. Move the error from the `loader`
    function inside the `dashboard.tsx` route component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By reloading the page, we trigger a full-page reload. Remix handles initial
    document requests on the server. Hence, the dashboard route module component is
    first called on the server, and we again throw an error on the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The error stack trace changes, but Remix still displays “Something went wrong!”
    on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, wrap the error inside a `useEffect` hook to ensure that the error is executed
    on the client instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: React’s `useEffect` hook only executes on the client, not the server. This is
    because the hook is executed after the initial render, and on the server, we only
    render once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refresh the browser window one more time. You should see yet another stack trace
    on the page. This time, the stack trace originates from client-side scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As visible in *Figure 7**.2*, notice that the filenames in the stack trace
    include hashes. This means the files have been bundled and are part of the client
    bundle:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Application error on the client](img/Figure_07.2_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Application error on the client
  prefs: []
  type: TYPE_NORMAL
- en: This experiment tells us that Remix provides the same default experience for
    both browser and server errors. Next, let’s replace Remix’s default error page
    with custom UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors with the root error boundary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In React, failures during rendering can be handled through error boundaries.
    Error boundaries are class components that implement the error boundary life cycle
    methods. Remix builds on top of React’s error boundaries and extends its capabilities
    to handle server-side errors. Instead of nesting React error boundaries inside
    our component tree, we declare them through Remix’s route module API by exporting
    an `ErrorBoundary` component in our route modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ErrorBoundary` component in the `root.tsx` route module is the topmost
    error boundary of our application. To replace Remix’s default error page, we need
    to export an `ErrorBoundary` component from `root.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `app/root.tsx` route module in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `useRouteError` hook from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import { H1 } from './components/headings';import { ButtonLink } from './components/links';export
    function ErrorBoundary() {  ErrorBoundary component is part of Remix’s route API
    and replaces the route module component in case of an error. We can access the
    error that caused the failure by calling useRouteError. We further use the error
    object to display an error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fabricate an unexpected error and refresh the browser window to inspect the
    updated error page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Custom root ErrorBoundary component](img/Figure_07.3_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Custom root ErrorBoundary component
  prefs: []
  type: TYPE_NORMAL
- en: As visible in *Figure 7**.3*, we now render a custom error page for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Investigate the code of the `ErrorBoundary` component in `root.tsx`. Notice
    that we render our styled `H1` and `ButtonLink` components. Why are our custom
    styles not applied to the page?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the `Meta`, `Links`, and `Scripts` components to append our meta and
    link tags and the client-side JavaScript scripts to the HTML document. This happens
    in the route module component in `root.tsx`. However, on error, we do not render
    the route module component but the `ErrorBoundary` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remix wraps the content of our error boundary in an HTML body tag by default.
    However, we can also provide a custom HTML document. Let’s update the code so
    that we render the `Meta`, `Links`, and `Scripts` components in the `root.tsx`
    file’s `ErrorBoundary` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `Document` component in `root.tsx` so that we can reuse code between
    the `App` and `ErrorBoundary` components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `App` component so that it uses `Document`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, wrap the content of the error boundary inside the `Document` component
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 7.4 – Styled root ErrorBoundary component](img/Figure_07.4_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Styled root ErrorBoundary component
  prefs: []
  type: TYPE_NORMAL
- en: Amazing! Now, we can utilize client-side JavaScript and our custom styles in
    the root `ErrorBoundary` component. One thing that we must keep in mind when reusing
    components for our `ErrorBoundary` component is that we can’t call the `useLoaderData`
    hook. Be sure not to render components that access loader data, as loader data
    is not defined when the `ErrorBoundary` component is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Error boundaries don’t have access to useLoaderData
  prefs: []
  type: TYPE_NORMAL
- en: An error boundary is rendered if an error occurs within the `loader` or `action`
    function of the route module. Conclusively, loader data is not available in the
    error boundary.
  prefs: []
  type: TYPE_NORMAL
- en: The top-level `ErrorBoundary` component in BeeRich does not render any navigation
    bar or other layout components. Keeping the top-level `ErrorBoundary` component
    simple ensures that it renders even in the case of an unexpected failure.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can improve error handling further by declaring nested
    error boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Nested error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Error boundaries can be nested. When an error is thrown, it bubbles upward through
    the route hierarchy until Remix finds the nearest error boundary. Nested error
    boundaries let us contain errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a nested error boundary to the dashboard route module:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `dashboard.tsx` route module inside the `app/routes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a simple `ErrorBoundary` export to the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, throw an error in the `dashboard.tsx` route module’s `loader` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app and visit the dashboard by opening [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    in a new browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we are not rendering the root error boundary but the one nested in
    `dashboard.tsx`. Remix uses the closest error boundary available and renders it
    within the parent route component’s `Outlet`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s make the error boundary look nice. Like we did in `root.tsx`, we want
    to share markup between the `ErrorBoundary` component and the route component.
    Refactor the route component so that it’s a reusable `Layout` component. First,
    remove `export default` from the function definition and add a `LayoutProps` type
    to specify the properties the component expects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `useLoaderData` call from the `Layout` function body. Since error
    boundaries cannot call `useLoaderData`, we must pass the loader data as optional
    props. As visible in `LayoutProps`, we ensure that the `Layout` component also
    accepts `null` as a value for `firstExpense` and `firstInvoice`. This can be the
    case if we don’t find any expenses or invoices in our database or when the error
    boundary is rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the rendering of `Outlet` with `children`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: export default function Component() {  const { firstExpense, firstInvoice }
    = useLoaderData<typeof loader>();  return (    <Layout firstExpense={firstExpense}
    firstInvoice={firstInvoice}>      <Outlet />    </Layout>  );}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the `ErrorBoundary` component in `dashboard.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the app and visit the [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without throwing an error, we should see the expense overview page. If you can’t
    remember why this is happening, look inside the `dashboard._index.tsx` route module.
    If the dashboard’s index route is active, it redirects to the expense overview
    page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, throw an error in any `loader` function or React component that is active
    inside the dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The browser window should now render the styled nested error boundary. As visible
    in *Figure 7**.5*, adding an error boundary to the dashboard route lets us isolate
    the error and render all parent routes correctly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Nested dashboard ErrorBoundary component](img/Figure_07.5_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Nested dashboard ErrorBoundary component
  prefs: []
  type: TYPE_NORMAL
- en: Nested error boundaries allow us to contain errors within a subset of the route
    hierarchy. This ensures that the parent routes render as expected. The closer
    the error boundary is to the error that occurred, the more contained the error
    will be.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to handle unexpected errors in Remix using
    Remix’s `ErrorBoundary` component. Next, let’s look at how to use the `ErrorBoundary`
    component to handle expected exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling thrown responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already take advantage of throwing `Response` objects in BeeRich. For instance,
    in [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057), *Routing in Remix,* we added
    the following `loader` function to the `dashboard.expenses.$id.tsx` route module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the `loader` function, we throw a `Response` object if we cannot find the
    expense for the `id` route parameter. This creates an expected failure during
    `loader` function execution. Let’s investigate Remix’s default behavior when an
    expected exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, the `throw` statement is used to throw user-defined exceptions.
    A `catch` block can then catch the thrown exception. We can throw any value, including
    `Response` objects. Remix takes advantage of this, offering a convention to stop
    `action` and `loader` functions early with exception responses. Let’s invoke the
    not-found response that was thrown in the expense details `loader`:'
  prefs: []
  type: TYPE_NORMAL
- en: Run BeeRich on localhost by executing `npm` `run dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the expense overview page by opening [http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)
    in a new browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on an expense in the overview list. This will redirect us to the
    expense details page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `id` route parameter in the URL with a fake one: [http://localhost:3000/dashboard/expenses/fake-id](http://localhost:3000/dashboard/expenses/fake-id).
    Then, reload the browser window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should render our dashboard error boundary to the page.
  prefs: []
  type: TYPE_NORMAL
- en: Remix lets us handle unexpected errors and thrown responses uniformly with the
    `ErrorBoundary` component. Any `Response` object thrown in a `loader` or `action`
    function triggers the `ErrorBoundary` component.
  prefs: []
  type: TYPE_NORMAL
- en: Thrown responses allow us to retrieve additional information, such as the status
    code from the error in the `ErrorBoundary` component. For that, we need to check
    whether the thrown error object is a `Response` object or an unexpected error.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions with error boundaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add a third error boundary, this time for the nested expense details
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `dashboard.expenses.$id.tsx` route module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import Remix’s `useRouteError` and `isRouteErrorResponse` helpers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `ErrorBoundary` export and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, test the implementation. Navigate to an expense details page and use a
    fake `id` route parameter in the URL. You should now see the nested `ErrorBoundary`
    component rendered on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how we still render the expense overview list; this is the power of nested
    error handling!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Nested expense details ErrorBoundary component](img/Figure_07.6_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Nested expense details ErrorBoundary component
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve implemented a nested error boundary for the expense details page,
    go ahead and implement the same experience for the income details page.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished working on the income details page, we’ll revisit the unpleasant
    experience from [*Chapter 6*](B17399_06.xhtml#_idTextAnchor090), *Enhancing the*
    *User Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a resilient experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do you remember that we created an unpleasant experience in [*Chapter 6*](B17399_06.xhtml#_idTextAnchor090),
    *Enhancing the User Experience,* when introducing the expense deletion form? If
    you are on an expense details page (`dashboard/expenses/$id`) and quickly delete
    all expenses in one go, you may end up on a not-found page. This is because of
    our redirect logic in the `dashboard/expenses/$id` `deleteExpense` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We use the `referer` header, if available, to redirect the user back to the
    current route after deletion. This is meant to improve the user experience. If
    the user is currently on the details page, `/dashboard/expenses/1`, and deletes
    the expense with `id` `2`, then we do not want to redirect the user away from
    `/dashboard/expenses/1`. However, we also have an `if` condition in the `deleteExpense`
    function to make sure that we do redirect the user if the user is currently on
    the details page of the expense that is being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: This logic fails when we quickly delete several expenses. Triggering many expense
    deletions simultaneously creates a race condition between the different action
    requests. It is going to be the response of the last triggered `action` that decides
    where the user is going to be redirected. However, by that time, we might have
    already deleted the expense that we currently have in the details view.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we are on the details page, `/dashboard/expenses/1`, and quickly delete
    the expenses with `id` `1` and then also with `id` `2`. In the `deleteExpense`
    function handling the deletion of expense `1`, we return a redirect to `/dashboard/expenses`
    since we know that expense `1` has been deleted. However, in the `deleteExpense`
    function handling the deletion of expense `2`, we will return a redirect to `/dashboard/expenses/1`
    (the current page). Remix takes the response of the last user action and commits
    to the redirect to `/dashboard/expenses/1`. We throw a 404 not-found error in
    the `loader` function as the expense with `id` `1` cannot be found (it has been
    deleted).
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7**.6*, we've enhanced the user experience by introducing
    the nested `ErrorBoundary` component for expense details. Nice! Now, if there's
    a 404 error, the user stays on the expenses overview page, and the error is contained
    in the nested `ErrorBoundary`. We avoid showing the user a full-screen error message
    and instead gracefully display the not-found error as part of the dashboard UI.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative error handling
  prefs: []
  type: TYPE_NORMAL
- en: Remix’s error boundaries let us handle errors and exceptions declaratively.
    By adding nested error boundaries, we can handle edge cases gracefully for a resilient
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve ensured a resilient user experience with nested error boundaries,
    let’s enhance the root error boundary with custom error messages for common HTTP
    status codes. In the next section, we will handle page-not-found errors.
  prefs: []
  type: TYPE_NORMAL
- en: Handling page-not-found (404) errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also handle thrown responses in the root `ErrorBoundary` component.
    One special case that can only be handled in the root `ErrorBoundary` component
    is the page-not-found exception thrown by Remix. Let’s revisit the root error
    boundary to handle thrown responses at the root level:'
  prefs: []
  type: TYPE_NORMAL
- en: Run BeeRich on localhost by executing `npm` `run dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit a non-existing page such as [http://localhost:3000/cheesecake](http://localhost:3000/cheesecake)
    in a new browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When visiting a non-existing route, Remix throws a response with HTTP status
    code 404 at the root level. We can use `isRouteErrorResponse` to render a 404
    page using the root error boundary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `root.tsx` file in an editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import `isRouteErrorResponse` from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'const error = useRouteError();let heading = ''Unexpected Error'';let message
    =  ''We are very sorry. An unexpected error occurred. Please try again or contact
    us if the problem persists.'';if (H1 and p texts with the heading and message
    values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Revisit [http://localhost:3000/cheesecake](http://localhost:3000/cheesecake).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now see the 404 not-found page shown in *Figure 7**.7*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Screenshot of BeeRich’s 404 page](img/Figure_07.7_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Screenshot of BeeRich’s 404 page
  prefs: []
  type: TYPE_NORMAL
- en: Great! We’ve added root and nested error boundaries to BeeRich. Note that we
    can throw custom 404 responses in `loader` and `action` functions. Nested error
    boundaries can handle these thrown exceptions. Remix throws a root-level 404 response
    if the requested URL does not match any routes. Since the exception is thrown
    at the root level, we use the root error boundary to handle the global 404 not-found
    page in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that Remix lets us handle both expected and unexpected
    failures declaratively using Remix’s `ErrorBoundary` component.
  prefs: []
  type: TYPE_NORMAL
- en: The root `ErrorBoundary` export handles thrown responses and errors if no other
    nested error boundary has handled them yet. Both errors and thrown responses bubble
    upward through the route hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned that error boundaries do not have access to loader data. It
    is important not to render any components in the boundaries that access the `useLoaderData`
    hook.
  prefs: []
  type: TYPE_NORMAL
- en: Using error boundaries makes the application more resilient toward errors. Tight
    error boundaries keep parts of our application functional if an unexpected error
    only affects a nested route module.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will throw some more responses – 401 responses, to be
    precise – as we implement an authentication flow and learn more about state management
    with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find a list of all HTTP status codes on MDN: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about exception and error handling, I recommend that
    you check out Shawn Wang''s (`@swyx`) blog post *Errors Are Not* *Exceptions*:
    [https://www.swyx.io/errors-not-exceptions](https://www.swyx.io/errors-not-exceptions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the `ErrorBoundary` route module export
    in the Remix documentation: [https://remix.run/docs/en/2/route/error-boundary](https://remix.run/docs/en/2/route/error-boundary).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remix docs also contain a guide with more information about not-found error
    handling, which you can find here: [https://remix.run/docs/en/2/guides/not-found](https://remix.run/docs/en/2/guides/not-found).'
  prefs: []
  type: TYPE_NORMAL
