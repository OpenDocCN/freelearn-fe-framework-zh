["```js\nexport interface Tag {\n  type: string;\n  hashTag: string;\n  title: string;\n  link: string;\n}\n```", "```js\nng generate service --spec false tags/tags\n```", "```js\nimport {Injectable} from '@angular/core';\nimport {ProjectService} from '../project/project.service';\nimport {Project, Tag} from '../model';\nimport {Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\nimport {limitWithEllipsis} from '../utilities/string-utilities';\n\n@Injectable()\nexport class TagsService {\n  tags: Observable<Tag[]>;\n\n  constructor(private projectService: ProjectService) {\n    this.tags = this.projectService.getProjects().pipe(\n      map((projects: Project[]) => projects.map(project => ({\n        type: 'project',\n        hashTag: `#project-${project.id}`,\n        title: limitWithEllipsis(project.title, 20),\n        link: `/projects/${project.id}/tasks`\n      })))\n    );\n  }\n}\n```", "```js\nexport function replaceAll(\n  target: string,\n  search: string,\n  replacement: string): string {\n  return target.split(search).join(replacement);\n}\n```", "```js\nimport {Injectable} from '@angular/core';\nimport {ProjectService} from '../project/project.service';\nimport {Project, Tag} from '../model';\nimport {Observable, of} from 'rxjs';\nimport {map} from 'rxjs/operators';\nimport {limitWithEllipsis, replaceAll} from '../utilities/string-utilities';\n\n@Injectable()\nexport class TagsService {\n  tags: Observable<Tag[]>;\n\n  constructor(private projectService: ProjectService) {\n    this.tags = this.projectService.getProjects().pipe(\n      map((projects: Project[]) => projects.map(project => ({\n        type: 'project',\n        hashTag: `#project-${project.id}`,\n        title: limitWithEllipsis(project.title, 20),\n        link: `/projects/${project.id}/tasks`\n      })))\n    );\n  }\n\n  parse(textContent: string): Observable<string> {\n const hashTags: string[] = textContent.match(/#[\\w\\/-]+/g);\n if (!hashTags) {\n return of(textContent);\n }\n\n return this.tags.pipe(\n map((tags: Tag[]) => {\n hashTags.forEach(hashTag => {\n const tag = tags.find(t => t.hashTag === hashTag);\n if (tag) {\n textContent = replaceAll(\n textContent,\n hashTag,\n `<a class=\"tag tag-${tag.type}\" \n              href=\"${tag.link}\">${tag.title}</a>`\n );\n }\n });\n return textContent;\n })\n );\n }\n}\n```", "```js\nng generate pipe --spec false pipes/tags\n```", "```js\nimport {Pipe, PipeTransform} from '@angular/core';\nimport {TagsService} from '../tags/tags.service';\nimport {DomSanitizer} from '@angular/platform-browser';\nimport {map} from 'rxjs/operators';\n\n@Pipe({\n  name: 'tags',\n  pure: false\n})\nexport class TagsPipe implements PipeTransform {\n  constructor(private tagsService: TagsService,\n              private sanitizer: DomSanitizer) {}\n\n  transform(value) {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    return this.tagsService.parse(value).pipe(\n      map(parsed => this.sanitizer.bypassSecurityTrustHtml(parsed))\n    );\n  }\n}\n```", "```js\n<div #editableContentElement\n     class=\"editable-content\"\n     contenteditable=\"true\"></div>\n<div class=\"output\" [innerHTML]=\"content ? (content | tags | async) : '-'\"></div>\n<div *ngIf=\"showControls && !editMode\"\n     class=\"controls\">\n  <button (click)=\"beginEdit()\" class=\"icon-edit\"></button>\n</div>\n<div *ngIf=\"showControls && editMode\"\n     class=\"controls\">\n  <button (click)=\"saveEdit()\" class=\"icon-save\"></button>\n  <button (click)=\"cancelEdit()\" class=\"icon-cancel\"></button>\n</div>\n\n```", "```js\nexport interface InputPosition {\n  top: number;\n  left: number;\n  caretOffset: number;\n}\n\nexport interface HashTagInput {\n  hashTag: string;\n  position: InputPosition;\n}\n```", "```js\nimport {InputPosition} from '../model';\n\nexport function getRangeBoundingClientRect(): InputPosition | null {\n  if (window.getSelection) {\n    const selection = window.getSelection();\n    if (!selection.rangeCount) {\n      return null;\n    }\n\n    const range = selection.getRangeAt(0);\n    const rect = range.getBoundingClientRect();\n\n    if (!range.collapsed) {\n      return {\n        top: rect.top,\n        left: rect.left,\n        caretOffset: range.startOffset\n      };\n    }\n\n    const dummy = document.createElement('span');\n    range.insertNode(dummy);\n    const pos: InputPosition = {\n      top: rect.top,\n      left: rect.left,\n      caretOffset: range.startOffset\n    };\n    dummy.parentNode.removeChild(dummy);\n    return pos;\n  }\n\n  if (document['selection']) {\n    return document['selection']\n      .createRange()\n      .getBoundingClientRect();\n  }\n}\n```", "```js\nng generate directive --spec false tags/tags-input\n```", "```js\nimport {Directive, HostListener} from '@angular/core';\nimport {getRangeBoundingClientRect} from '../utilities/dom-utilities';\nimport {HashTagInput} from '../model';\nimport {BehaviorSubject} from 'rxjs';\n\n@Directive({\n  selector: '[macTagsInput]'\n})\nexport class TagsInputDirective {\n  private hashTagInput: HashTagInput | null = null;\n  private hashTagSubject = new BehaviorSubject<HashTagInput>(this.hashTagInput);\n  hashTagChange = this.hashTagSubject.asObservable();\n}\n```", "```js\nreset() {\n  this.hashTagInput = null;\n  this.hashTagSubject.next(this.hashTagInput);\n}\n```", "```js\n  private updateHashTag(hashTag, position = this.hashTagInput.position) {\n    this.hashTagInput = {hashTag, position};\n    this.hashTagSubject.next(this.hashTagInput);\n  }\n```", "```js\nupdateTextTag(textTag, position = this.position) { \n  this.textTag = textTag; \n  this.position = position; \n} \n```", "```js\n@HostListener('keydown', ['$event'])\nkeyDown(event: KeyboardEvent) {\n  if (this.hashTagInput && event.which === 8) {\n    this.updateHashTag(this.hashTagInput.hashTag.slice(0, -1));\n  }\n}\n```", "```js\n@HostListener('keypress', ['$event'])\nkeyPress(event: KeyboardEvent) {\n  const char = String.fromCharCode(event.which);\n  if (char === '#') {\n    this.updateHashTag('#', getRangeBoundingClientRect());\n  } else if (!/[\\w-]/i.test(char)) {\n    this.reset();\n  } else if (this.hashTagInput) {\n    this.updateHashTag(this.hashTagInput.hashTag + char);\n  }\n}\n```", "```js\nexport interface TagSelection {\n  tag: Tag;\n  hashTagInput: HashTagInput;\n}\n```", "```js\nng generate component --spec false -cd onpush tags/tags-select\n```", "```js\nimport {ChangeDetectionStrategy, Component, EventEmitter, HostBinding, Input, OnChanges, Output} from '@angular/core';\nimport {HashTagInput, Tag, TagSelection} from '../../model';\n\nconst tagListLimit = 4;\n\n@Component({\n  selector: 'mac-tags-select',\n  templateUrl: './tags-select.component.html',\n  styleUrls: ['./tags-select.component.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class TagsSelectComponent implements OnChanges {\n  @Input() tags: Tag[];\n  @Input() hashTagInput: HashTagInput | null;\n  @Output() outSelectTag = new EventEmitter<TagSelection>();\n\n  filteredTags: Tag[];\n\n  filterTags() {\n    const filter = this.hashTagInput.hashTag.slice(1).toLowerCase();\n    this.filteredTags = this.tags\n      .filter(tag =>\n        tag.hashTag.toLowerCase().includes(filter) ||\n        tag.title.toLowerCase().includes(filter)\n      )\n      .slice(0, tagListLimit);\n  }\n\n  selectTag(tag: Tag) {\n    this.outSelectTag.next({\n      tag,\n      hashTagInput: this.hashTagInput\n    });\n  }\n\n  ngOnChanges(changes) {\n    if ((changes.hashTagInput || changes.tags) && this.hashTagInput) {\n      this.filterTags();\n    }\n  }\n}\n```", "```js\n  @HostBinding('style.display')\n  get hasFilteredTags() {\n    return this.filteredTags && this.filteredTags.length > 0 ? 'block' : 'none';\n  }\n```", "```js\n  @HostBinding('style.top')\n  get topPosition() {\n    return this.hashTagInput && this.hashTagInput.position ?\n      `${this.hashTagInput.position.top}px` : 0;\n  }\n\n  @HostBinding('style.left')\n  get leftPosition() {\n    return this.hashTagInput && this.hashTagInput.position ?\n      `${this.hashTagInput.position.left}px` : 0;\n  }\n```", "```js\n<ul class=\"list\">\n  <li *ngFor=\"let tag of filteredTags\"\n      (click)=\"selectTag(tag)\"\n      class=\"item\">{{tag.title}}</li>\n</ul>\n```", "```js\n…\nexport function splice(\n  target: string,\n  index: number,\n  deleteCount: number,\n  content: string): string {\n  return target.slice(0, index) +\n    content +\n    target.slice(index + deleteCount);\n}\n```", "```js\n<div #editableContentElement\n     class=\"editable-content\"\n     contenteditable=\"true\"\n macTagsInput></div>\n<mac-tags-select\n *ngIf=\"tags && tagsInput.hashTagChange | async\"\n [hashTagInput]=\"tagsInput.hashTagChange | async\"\n [tags]=\"tags\"\n (outSelectTag)=\"selectTag($event)\">\n</mac-tags-select>\n<div class=\"output\" [innerHTML]=\"content ? (content | tags | async) : '-'\"></div>\n<div *ngIf=\"showControls && !editMode\"\n     class=\"controls\">\n  <button (click)=\"beginEdit()\" class=\"icon-edit\"></button>\n</div>\n<div *ngIf=\"showControls && editMode\"\n     class=\"controls\">\n  <button (click)=\"saveEdit()\" class=\"icon-save\"></button>\n  <button (click)=\"cancelEdit()\" class=\"icon-cancel\"></button>\n</div>\n```", "```js\n…\nimport {TagsInputDirective} from '../../tags/tags-input.directive';\nimport {Tag, TagSelection} from '../../model';\nimport {splice} from '../../utilities/string-utilities';\n\n@Component({\n  selector: 'mac-editor',\n  templateUrl: './editor.component.html',\n  styleUrls: ['./editor.component.css'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class EditorComponent implements OnChanges, AfterViewInit {\n  @ViewChild('editableContentElement') editableContentElement: ElementRef;\n  @ViewChild('editableContentElement', {\n read: TagsInputDirective\n }) tagsInput: TagsInputDirective;\n  …\n\n  saveEdit() {\n    this.editMode = false;\n    this.tagsInput.reset();\n    this.outSaveEdit.emit(this.getEditableContent());\n  }\n\n  cancelEdit() {\n    this.editMode = false;\n this.tagsInput.reset();\n    this.setEditableContent(this.content);\n    this.outCancelEdit.emit();\n  }\n  …\n\n  selectTag(tagSelection: TagSelection) {\n this.setEditableContent(\n splice(\n this.getEditableContent(),\n tagSelection.hashTagInput.position.caretOffset,\n tagSelection.hashTagInput.hashTag.length,\n tagSelection.tag.hashTag\n ));\n this.tagsInput.reset();\n }\n}\n```", "```js\n…\nimport {Comment, CommentUpdate, Project, Tag, User} from '../../model';\n…\nimport {TagsService} from '../../tags/tags.service';\n\n@Component({\n  …\n})\nexport class ProjectCommentsContainerComponent {\n  …\n  tags: Observable<Tag[]>;\n\n  constructor(private projectService: ProjectService,\n              private userService: UserService,\n              private route: ActivatedRoute,\n              private activitiesService: ActivitiesService,\n private tagsService: TagsService) {\n    …\n    this.tags = this.tagsService.tags;\n  }\n  …\n}\n```", "```js\n<mac-comments [user]=\"user | async\"\n              [comments]=\"projectComments | async\"\n              [tags]=\"tags | async\"\n              (outCreateComment)=\"createComment($event)\"\n              (outUpdateComment)=\"updateComment($event)\">\n</mac-comments>\n```", "```js\n…\nimport {Comment, CommentUpdate, Tag, TagSelection, User} from '../../model';\nimport {TagsInputDirective} from '../../tags/tags-input.directive';\nimport {splice} from '../../utilities/string-utilities';\n\n@Component({\n  …\n})\nexport class CommentsComponent {\n  …\n  @Input() tags: Tag[];\n @ViewChild('commentContentEditable', {\n read: TagsInputDirective\n }) tagsInput: TagsInputDirective;\n  …\n\n  selectTag(tagSelection: TagSelection) {\n this.commentContentEditable.nativeElement.textContent =\n splice(\n this.commentContentEditable.nativeElement.textContent,\n tagSelection.hashTagInput.position.caretOffset,\n tagSelection.hashTagInput.hashTag.length,\n tagSelection.tag.hashTag\n );\n this.tagsInput.reset();\n }\n}\n```", "```js\n<div class=\"title\">Add new comment</div>\n<div class=\"add-comment-section\">\n  <div #commentContentEditable\n       class=\"add-comment-box\"\n       contenteditable=\"true\"\n       macTagsInput>\n  </div>\n <mac-tags-select\n *ngIf=\"tags && tagsInput.hashTagChange | async\"\n [hashTagInput]=\"tagsInput.hashTagChange | async\"\n [tags]=\"tags\"\n (outSelectTag)=\"selectTag($event)\">\n </mac-tags-select>\n  <button (click)=\"createComment()\"\n          class=\"button\" >Add comment</button>\n</div>\n\n<ng-container *ngIf=\"comments.length > 0\">\n  <div class=\"title\">All comments</div>\n  <mac-comment *ngFor=\"let comment of comments; let index = index\"\n               [comment]=\"comment\"\n               [user]=\"user\"\n               [tags]=\"tags\"\n               (outUpdateComment)=\"updateComment(index, $event)\">\n  </mac-comment>\n</ng-container>\n```", "```js\n…\nimport {Comment, Tag, User} from '../../model';\n\n@Component({\n  …\n})\nexport class CommentComponent {\n  …\n  @Input() tags: Tag[];\n  …\n}\n```", "```js\n…\n<div class=\"main\">\n  <div class=\"content\">\n    <mac-editor [content]=\"comment.content\"\n                [showControls]=\"comment.user.id === user.id\"\n                [tags]=\"tags\"\n                (outSaveEdit)=\"updateComment($event)\">\n    </mac-editor>\n  </div>\n</div>\n```", "```js\nexport interface Task {\n  readonly id?: number;\n  readonly projectId?: number;\n  readonly title: string;\n  readonly done: boolean;\n  readonly order: number;\n}\n…\n\nexport type DraggableType = 'task';\n```", "```js\n…\n\nexport class Database implements InMemoryDbService {\n  createDb() {\n    …\n\n    const tasks: Task[] = [\n      {id: 1, projectId: 1, title: 'Task 1', done: false, order: 1},\n      {id: 2, projectId: 1, title: 'Task 2', done: false, order: 2},\n      {id: 3, projectId: 1, title: 'Task 3', done: true, order: 3},\n      {id: 4, projectId: 1, title: 'Task 4', done: false, order: 4}\n    ];\n\n    …\n  }\n}\n```", "```js\n…\n\n@Component({\n  selector: 'mac-task-list-container',\n  templateUrl: './task-list-container.component.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class TaskListContainerComponent {\n  …\n\n  constructor(private taskService: TaskService,\n              private projectService: ProjectService,\n              private route: ActivatedRoute,\n              private activitiesService: ActivitiesService) {\n    …\n\n    this.tasks = this.selectedProject.pipe(\n      switchMap((project) => this.taskService.getProjectTasks(project.id)),\n map(tasks => tasks.sort((a: Task, b: Task) => b.order - a.order))\n    );\n\n    …\n  }\n\n  …\n\n  addTask(title: string) {\n    combineLatest(this.selectedProject, this.tasks)\n      .pipe(\n        take(1)\n      )\n      .subscribe(([project, tasks]) => {\n        const position = tasks.reduce(\n (max, t: Task) => t.order > max ? t.order : max, 0\n ) + 1;\n        const task: Task = {\n          projectId: project.id, title, done: false, order: position\n        };\n        this.taskService.addTask(task);\n        this.activitiesService.logProjectActivity(\n          project.id,\n          'tasks',\n          'A task was added',\n          `A new task \"${limitWithEllipsis(title, 30)}\" was added to \n         #project-${project.id}.`\n        );\n      });\n  }\n\n  …\n}\n```", "```js\nng generate directive --spec false draggable/draggable\n```", "```js\nimport {Directive, HostBinding, HostListener, Input} from '@angular/core';\nimport {DraggableType} from '../model';\n\n@Directive({\n  selector: '[macDraggable]'\n})\nexport class DraggableDirective {\n  @HostBinding('draggable') draggable = 'true';\n  @Input() draggableData: any;\n  @Input() draggableType: DraggableType;\n  @HostBinding('class.dragging') dragging = false;\n}\n```", "```js\nimport {Directive, HostBinding, HostListener, Input} from '@angular/core';\nimport {DraggableType} from '../model';\n\n@Directive({\n  selector: '[macDraggable]'\n})\nexport class DraggableDirective {\n  @HostBinding('draggable') draggable = 'true';\n  @Input() draggableData: any;\n  @Input() draggableType: DraggableType;\n  @HostBinding('class.dragging') dragging = false;\n\n @HostListener('dragstart', ['$event'])\n dragStart(event) {\n event.dataTransfer.effectAllowed = 'move';\n event.dataTransfer.setData('application/json', JSON.stringify(this.draggableData));\n event.dataTransfer.setData(`draggable-type:${this.draggableType}`, '');\n this.dragging = true;\n }\n}\n```", "```js\nimport {Directive, HostBinding, HostListener, Input} from '@angular/core';\nimport {DraggableType} from '../model';\n\n@Directive({\n  selector: '[macDraggable]'\n})\nexport class DraggableDirective {\n  …\n\n @HostListener('dragend')\n onDragEnd() {\n this.dragging = false;\n }\n}\n\n```", "```js\nng generate directive --spec false draggable/draggable-drop-zone\n```", "```js\nimport {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';\nimport {DraggableType} from '../model';\n\n@Directive({\n  selector: '[macDraggableDropZone]'\n})\nexport class DraggableDropZoneDirective {\n  @Input() dropAcceptType: DraggableType;\n  @Output() outDropDraggable = new EventEmitter<any>();\n  @HostBinding('class.over') over = false;\n\n  dragEnterCount = 0;\n}\n```", "```js\nimport {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';\nimport {DraggableType} from '../model';\n\n@Directive({\n  selector: '[macDraggableDropZone]'\n})\nexport class DraggableDropZoneDirective {\n  @Input() dropAcceptType: DraggableType;\n  @Output() outDropDraggable = new EventEmitter<any>();\n  @HostBinding('class.over') over = false;\n\n  dragEnterCount = 0;\n\n private typeIsAccepted(event: DragEvent) {\n const draggableType = Array.from(event.dataTransfer.types).find((key) =>\n key.indexOf('draggable-type') === 0);\n return draggableType && draggableType.split(':')[1] === this.dropAcceptType;\n }\n}\n```", "```js\nimport {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';\nimport {DraggableType} from '../model';\n\n@Directive({\n  selector: '[macDraggableDropZone]'\n})\nexport class DraggableDropZoneDirective {\n  @Input() dropAcceptType: DraggableType;\n  @Output() outDropDraggable = new EventEmitter<any>();\n  @HostBinding('class.over') over = false;\n\n  dragEnterCount = 0;\n\n  private typeIsAccepted(event: DragEvent) {\n    const draggableType = Array.from(event.dataTransfer.types).find((key) =>\n      key.indexOf('draggable-type') === 0);\n    return draggableType && draggableType.split(':')[1] === this.dropAcceptType;\n  }\n\n  @HostListener('dragenter', ['$event'])\n dragEnter(event: DragEvent) {\n if (this.typeIsAccepted(event)) {\n this.over = true;\n this.dragEnterCount++;\n }\n }\n\n @HostListener('dragleave', ['$event'])\n dragLeave(event: DragEvent) {\n if (this.typeIsAccepted(event) && --this.dragEnterCount === 0) {\n this.over = false;\n }\n }\n}\n```", "```js\nimport {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';\nimport {DraggableType} from '../model';\n\n@Directive({\n  selector: '[macDraggableDropZone]'\n})\nexport class DraggableDropZoneDirective {\n  …\n\n @HostListener('dragover', ['$event'])\n dragOver(event: DragEvent) {\n if (this.typeIsAccepted(event)) {\n event.preventDefault();\n event.dataTransfer.dropEffect = 'move';\n }\n }\n}\n```", "```js\nimport {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';\nimport {DraggableType} from '../model';\n\n@Directive({\n  selector: '[macDraggableDropZone]'\n})\nexport class DraggableDropZoneDirective {\n  …\n\n  @HostListener('dragover', ['$event'])\n  dragOver(event: DragEvent) {\n    if (this.typeIsAccepted(event)) {\n      event.preventDefault();\n      event.dataTransfer.dropEffect = 'move';\n    }\n  }\n  @HostListener('drop', ['$event'])\n drop(event: DragEvent) {\n if (this.typeIsAccepted(event)) {\n const data = JSON.parse(event.dataTransfer.getData('application/json'));\n this.over = false;\n this.dragEnterCount = 0;\n this.outDropDraggable.next(data);\n }\n }\n}\n```", "```js\n<mac-toggle [buttonList]=\"taskFilterTypes\"\n            [activeButton]=\"activeTaskFilterType\"\n            (outActivate)=\"activateFilterType($event)\">\n</mac-toggle>\n<mac-enter-task (outEnterTask)=\"addTask($event)\"></mac-enter-task>\n<div class=\"tasks\">\n  <mac-task *ngFor=\"let task of tasks\"\n            [task]=\"task\"\n            (outUpdateTask)=\"updateTask($event)\"\n            macDraggable\n draggableType=\"task\"\n [draggableData]=\"task\"\n macDraggableDropZone\n dropAcceptType=\"task\"\n (outDropDraggable)=\"dropTask(task, $event)\"></mac-task>\n</div>\n```", "```js\n…\n\n@Component({\n  selector: 'mac-task-list',\n  templateUrl: './task-list.component.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class TaskListComponent {\n  …\n\n  dropTask(target: Task, source: Task) {\n if (target.id === source.id) {\n return;\n }\n\n this.outUpdateTask.emit({\n ...target,\n order: source.order\n });\n this.outUpdateTask.emit({\n ...source,\n order: target.order\n });\n }\n}\n```"]