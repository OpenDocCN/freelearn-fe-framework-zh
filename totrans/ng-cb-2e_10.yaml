- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Unit Tests in Angular with Jest
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*“It works on my machine”* is a phrase that won’t lose its beauty with time.
    It is a shield for many engineers and a nightmare for the quality assurance professionals.
    But honestly, what’s a better way for your application’s robustness than writing
    tests? And when it comes to writing unit tests, my personal favorite is **Jest**.
    That is because it is super-fast, lightweight, and has an easy API to write tests.
    More importantly, it is faster than the Karma and Jasmine setup that comes out
    of the box with Angular. In this chapter, you’ll learn how to configure Jest with
    Angular to run these tests in parallel. You’ll learn how to test components, services,
    and pipes with Jest. You’ll also learn how to mock dependencies for these tests.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests in Angular with Jest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing global mocks for Jest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking Angular services using stubs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spies on an injected service in a unit test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking child components and directives using the `ng-mocks` package
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing even easier tests with Angular CDK component harnesses
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing components with observables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing Angular pipes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter10](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter10).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests in Angular with Jest
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a new Angular project comes bundled with a lot of goodness, including
    the configuration and tooling in which to run unit tests with Karma and Jasmine.
    While working with Karma is relatively convenient, many developers find that in
    large-scale projects, the whole testing process becomes much slower if there are
    a lot of tests involved. This is mainly because you can’t run tests in parallel.
    In this recipe, we’ll set up Jest for unit testing in an Angular app. Additionally,
    we’ll migrate existing tests from the Karma syntax to the Jest syntax.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Starting with v16, Angular comes with a developer preview for Jest, and the
    process has become much easier. This recipe targets apps up to Angular v15 and
    covers what we can do in v16 at the end of the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-jest-setup`
    inside the cloned repository:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command in *step 2* is different from the rest of the recipes’ commands
    in this book. This is because the project for this recipe is *not* part of the
    NX workspace we have. It is a standalone Angular app itself; hence, it has different
    commands.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_01.png)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.1: The ng-jest-setup app running on http://localhost:4200'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, try to run the test and monitor how much time it takes for the entire
    process to run. Run the command `npm run test:ng-jest-setup` from the workspace
    `root`; within a few seconds, a new Chrome window should open, as follows:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_02.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.2: The tests’ results with Karma and Jasmine'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Looking at the preceding screenshot, you might say *“Pfffttt, Ahsan, it says
    ‘finished in 0.033s (or something close to it)!’ What else do you want?”* Well,
    that time only covers how long it took Karma to run the tests *in the browser
    after the Chrome window was created*. It doesn’t count the time it took to start
    the process, start the Chrome window, and then load the tests. This could be improved
    by running the Chrome Headless browser for Karma, which requires some configuration.
    However, it is still slower compared to the alternative (Jest). Also, at the time
    of writing this recipe, I’m running this on a Macbook Pro with the M2 Chip, *which
    is fast*. That’s why we’re going to replace it with Jest. Now that you understand
    the issue, in the next section, let’s take a look at the steps of the recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have an Angular app with a simple `Counter` component. It shows the
    value of the counter and has three action buttons: one of the buttons is to increase
    the value of the counter, one of them is to decrease the value, and another is
    to reset the value. Additionally, there are some tests written with Karma and
    Jasmine, and all of the tests will pass if you run the tests. We’ll start by setting
    up Jest instead. Perform the following steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new Terminal window/tab, and make sure you’re inside the `start/apps/chapter10/ng-jest-setup`
    folder. Once inside, run the following command to install the packages that are
    required to test with Jest:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now uninstall Karma and the unwanted dependencies. Now, run the following
    command in your Terminal:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, update the test configuration in the `angular.json` file, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will now create a file to configure Jest for our project. Create a file
    named `jestSetup.ts` inside the project’s folder, and paste the following content
    inside:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s modify `tsconfig.spec.json` to use Jest instead of Jasmine. After
    the modification, your entire file should appear as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll now modify `package.json` to add the `npm` scripts that’ll run the Jest
    tests:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, let’s wrap up the entire configuration for our Jest tests by adding
    the Jest configuration in the `package.json` file, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have set everything up, simply run the `test` command from within
    the `ng-jest-setup` folder, as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the tests are finished, you should be able to see the following output:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_03.png)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.3: The results of the tests with Jest'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Kaboom! You will notice that the entire process of running the tests with Jest
    takes about 6 seconds. It might take longer when you run it for the first time,
    but the subsequent runs should be faster. Now that you know how to configure an
    Angular app to use Jest for unit tests, please refer to the next section for resources
    in which to learn more.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Bonus: Migrating to Jest in Angular v16'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from Angular v16, all you need to do to migrate to Jest (considering
    your project currently uses Karma) is to update the `angular.json` file in the
    project with the following configuration object property hierarchy `your-app >
    architect > test` settings:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Web Frameworks with Jest: [https://jestjs.io/docs/en/testing-frameworks](https://jestjs.io/docs/en/testing-frameworks)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting Started with Jest: [https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moving Angular CLI to Jest: [https://blog.angular.io/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca](https://blog.angular.io/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing global mocks for Jest
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to set up Jest for Angular unit tests.
    There might be some scenarios in which you’d want to use a browser API that might
    not be part of your actual Angular code – for instance, using `LocalStorage` or
    `alert`. In such cases, we need to provide some global mocks for the functions
    that we want to return mock values from. This is so that we can perform tests
    involving them as well. In this recipe, you’ll learn how to provide global mocks
    to Jest.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-jest-global-mocks`
    inside the cloned repository:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_04.png)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.4: The ng-jest-global-mocks app running on http://localhost:4200'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we’re using for this recipe uses two global APIs: `window.localStorage`
    and `window.alert`. Note that when the app starts, we get the counter value from
    `LocalStorage`, and then upon increment, decrement, and reset, we store it in
    `LocalStorage`. When the counter value becomes greater than the `MAX_VALUE` or
    lower than the `MIN_VALUE`, we show the alert using the `alert` method. Let’s
    begin the recipe by writing some cool unit tests:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll write our test cases to show the alert when the counter value
    goes beyond `MAX_VALUE` and `MIN_VALUE`. Modify the `counter.component.spec.ts`
    file as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写测试用例以显示当计数器的值超过 `MAX_VALUE` 和 `MIN_VALUE` 时会弹出警告。修改 `counter.component.spec.ts`
    文件，如下所示：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you can see that the tests pass but with a bunch of console errors. And
    what if we wanted to check whether the value from `LocalStorage` is being saved
    and retrieved properly?
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以看到测试通过了，但伴随着大量的控制台错误。那么，如果我们想检查从 `LocalStorage` 保存和检索的值是否正确呢？
- en: 'We’ll create a new test to make sure the `localStorage.getItem` method is called
    to retrieve the last saved value from the `LocalStorageAPI`. Add the test to the
    `counter.component.spec.ts` file, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的测试来确保 `localStorage.getItem` 方法被调用以从 `LocalStorageAPI` 获取最后保存的值。将测试添加到
    `counter.component.spec.ts` 文件中，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that we’re using `it.only` for this test case. This is to ensure that
    we’re only running this test (for now). If you run the tests, you should be able
    to see something like the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们在这个测试用例中使用了 `it.only`。这是为了确保我们现在只运行这个测试。如果你运行测试，你应该能看到以下截图中的内容：
- en: '![](img/B18469_10_05.png)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B18469_10_05.png](img/B18469_10_05.png)'
- en: 'Figure 10.5: The test that covers the LocalStorageAPI has failed'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.5：覆盖 LocalStorageAPI 的测试失败了
- en: 'Notice the **Matcher error: received value must be a mock or a spy function**
    message. This is what we’re going to do next, that is, provide a mock.'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 **匹配器错误：接收到的值必须是一个模拟或间谍函数** 的消息。这就是我们接下来要做的，也就是提供一个模拟。
- en: 'Create a file inside the project’s `src` folder, and name the file `jest-global-mocks.ts`.
    Then, add the following code to mock the `LocalStorageAPI`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的 `src` 文件夹内创建一个文件，并将其命名为 `jest-global-mocks.ts`。然后，添加以下代码来模拟 `LocalStorageAPI`：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, import this file into the `src/test-setup.ts` file, as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此文件导入到 `src/test-setup.ts` 文件中，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, if you rerun the tests, they should pass.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你重新运行测试，它们应该会通过。
- en: 'Let’s add another test to ensure we retrieve the last saved value from `LocalStorage`
    in the component initiation. Modify the `counter.component.spec.ts` file, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试以确保在组件初始化时从 `LocalStorage` 中检索最后保存的值。修改 `counter.component.spec.ts`
    文件，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, let’s make sure that we save the counter value to `LocalStorage` whenever
    we trigger the `increment`, `decrement`, or `reset` methods. Update the `counter.component.spec.ts`
    as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们确保在触发 `increment`、`decrement` 或 `reset` 方法时，将计数器的值保存到 `LocalStorage` 中。更新
    `counter.component.spec.ts` 文件，如下所示：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Awesomesauce! You’ve just learned how to provide global mocks to Jest for testing.
    Please refer to the next section to understand how this works.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经学会了如何为 Jest 测试提供全局模拟。请参考下一节了解这是如何工作的。
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Jest provides a way to define global mocks for tests. It comes with a lot of
    built-in functions to define test suites and test cases, along with assertion
    functions. Here is an example of a simple Jest test suite for a `sum` function
    that adds two numbers:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 提供了一种为测试定义全局模拟的方法。它自带了许多内置函数来定义测试套件和测试用例，以及断言函数。以下是一个简单的 Jest 测试套件示例，用于测试一个
    `sum` 函数，该函数用于将两个数字相加：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Jest also has a way to use a particular file to set up Jest in projects. When
    working with different frameworks, the file (or the filename) can be different,
    but the purpose would still be the same, that is, to define global configuration
    via this Jest setup file. In our NX workspace, we already have the Jest files
    in each project under the `src` folder, and the filename is usually `test-setup.ts`.
    One of the common approaches to define global mocks is to create a new file containing
    the mocks and then import it into the `test-setup.ts` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 还有一种方法可以在项目中使用特定的文件来设置 Jest。当与不同的框架一起工作时，文件（或文件名）可能不同，但目的仍然是相同的，即通过这个 Jest
    设置文件定义全局配置。在我们的 NX 工作区中，我们已经在每个项目的 `src` 文件夹下创建了 Jest 文件，文件名通常是 `test-setup.ts`。定义全局模拟的一种常见方法是为模拟创建一个新的文件，然后将其导入到
    `test-setup.ts` 文件中。
- en: Notice that we use the `Object.defineProperty` method in the `window` object
    to provide a mock implementation for the `LocalStorage` object, and we do similar
    for the `window.alert` mock. This is actually the same for any API that is not
    implemented in the **JSDOM**(**JavaScript Document Object Model**). Similarly,
    you can provide a global mock for each API that you use in your tests. Notice
    that in the `value` property, we create a new instance of the `LocalStorageMock`
    class using the `new` keyword. Essentially, this is one way to define mocks. We
    create the `LocalStorageMock` class, and in that, we have a private property named
    `storage` that mimics the `localStorage` object. We have also defined the `getItem`
    and `setItem` methods in there so that we can set values to this storage and get
    values from it. Notice that we do not have the implementations of the `removeItem`
    and `clear` methods that we have in the actual `localStorage` API. We don’t have
    to have them because we’re not using these methods in our actual code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`Object.defineProperty`方法在`window`对象中为`LocalStorage`对象提供模拟实现，并且我们对`window.alert`模拟也做了类似处理。这实际上适用于任何未在**JSDOM**（**JavaScript
    Document Object Model**）中实现的自定义API。同样，你可以为你在测试中使用的每个API提供一个全局模拟。注意，在`value`属性中，我们使用`new`关键字创建`LocalStorageMock`类的新实例。本质上，这是定义模拟的一种方法。我们创建了`LocalStorageMock`类，在其中有一个名为`storage`的私有属性，它模拟了`localStorage`对象。我们还在其中定义了`getItem`和`setItem`方法，以便我们可以向此存储设置值并从中获取值。注意，我们没有实现`removeItem`和`clear`方法，这些方法在实际的`localStorage`
    API中是有的。我们不需要它们，因为我们实际上没有使用这些方法。
- en: In the `should call the localStorage.getItem method on component init` test,
    we simply spy on the `localStorage` object’s `getItem` method, call the `ngOnInit`
    method ourselves, and then expect it to have been called. *Easy peasy!*
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`should call the localStorage.getItem method on component init`测试中，我们简单地监视`localStorage`对象的`getItem`方法，自己调用`ngOnInit`方法，然后期望它已经被调用。*简单易行!*
- en: In the `should retrieve the last saved value from localStorage on component
    init` test, we save a value in the `localStorage` object for the counter value
    as `12`, using the `setItem` method. Essentially, calling the `setItem` method
    calls our mock implementation method and not the actual `localStorage` API’s `setItem`
    method. Notice that, here, we *do not* spy on the `getItem` method; this is because,
    later on, we want the value of the component’s `counter` property to be `12`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`should retrieve the last saved value from localStorage on component init`测试中，我们使用`setItem`方法在`localStorage`对象中为计数器的值保存`12`。本质上，调用`setItem`方法调用的是我们的模拟实现方法，而不是实际的`localStorage`
    API的`setItem`方法。注意，在这里，我们没有对`getItem`方法进行监视；这是因为，稍后我们希望组件的`counter`属性的值为`12`。
- en: IMPORTANT NOTE
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Whenever we spy on a method, remember that any statements in the actual function
    will no longer be executed. This is why we do not spy on the `getItem` method
    in the preceding test. If we do so, the `getItem` method from the mock implementation
    will not return anything. Therefore, our expected value for the counter property
    will not be `12`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们监视一个方法时，请记住，实际函数中的任何语句将不再执行。这就是为什么我们不会在先前的测试中监视`getItem`方法。如果我们这样做，模拟实现中的`getItem`方法将不会返回任何内容。因此，我们对计数器属性的预期值将不会是`12`。
- en: Put simply, if you have to rely on the outcome of a function’s implementation,
    or the statements executed within a function, do not spy on that function and
    replace such a function with `jest.fn().mockReturnValue(123);`. This ensures we
    can check if the function is called but also with a return value that can be used
    by the actual code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你必须依赖于函数实现的输出，或者函数内部执行的语句，不要监视该函数，并用`jest.fn().mockReturnValue(123);`替换该函数。这确保了我们不仅可以检查函数是否被调用，还可以使用实际的代码使用返回值。
- en: 'PS: I always end up learning this the hard way after debugging and bashing
    my head for a while.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PS：我总是在调试和敲打了一段时间的头之后，才艰难地学到这一点。
- en: The final test is an easy one. In the `should save the new counterValue to localStorage
    on increment, decrement and reset` test, we spy on the `setItem` method. Then,
    we manually set the value of the counter property each time before we run the
    `increment`, `decrement`, and `reset` methods respectively. Additionally, we expect
    the `setItem` method to have been called with the right arguments to save the
    value to the store. Note that we do not check the store’s value after saving it.
    As I mentioned earlier, since we have spied on the `setItem` method, its internal
    statement won’t trigger and the value won’t be saved; therefore, we can’t retrieve
    the saved value afterward.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Jest documentation for `setupFiles`: [https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manual Mocks with Jest: [https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking Angular services using stubs
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s rarely an Angular app that doesn’t have a **Service** created inside
    it. And where overall business logic is concerned, services hold a great deal,
    particularly when it comes to interacting with APIs. In this recipe, you’ll learn
    how to mock services using stubs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-services-stubs`
    inside the cloned repository:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_06.png)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.6: The ng-test-services-stubs app running on http://localhost:4200'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let’s take a
    look at the steps of the recipe.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the same application as the previous recipe; however, we’ve moved the
    logic of saving and retrieving data from `localStorage` to the `CounterService`
    we’ve created. Now, all the tests are passing. However, what if we wanted to hide/encapsulate
    the logic of where the counter value is stored? Perhaps we want to send a backend
    API call for it. To do this, it makes more sense to test that our `CounterService`''s
    methods are being called instead of checking `localStorage` methods. Let’s follow
    the recipe to provide a mock stub for our service:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a folder inside the `src` folder, named `__mocks__`. Inside
    it, create another folder named `services`. Then, again inside this folder, create
    the `counter.service.mock.ts` file with the following content:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, provide the mock service instead of the actual service in the `counter.component.spec.ts`,
    as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the preceding change, you should see the following error that says the
    `localStorage.getItem` hasn’t been called. This is because we’re now spying on
    the methods on our mock stub for the service:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_07.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.7: localStorage.getItem is not called because of the methods being
    spied on'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, instead of expecting the `localStorage` object’s methods to be called,
    let’s expect our service’s methods to be called in our tests. Update the `counter.component.spec.ts`
    file using the snippet at [https://ng-cookbook.com/s/services-stub-tests](https://ng-cookbook.com/s/services-stub-tests)
    to replace all the tests below the following comment:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Great! You now know how to mock services to test components with service dependencies.
    Please refer to the next section to understand how it all works.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Providing stubs for Angular services is already a breeze. This is thanks to
    Angular’s out-of-the-box methods and tooling from the `@angular/core` package,
    especially `@angular/core/testing`. First, we create the stub for our `CounterService`
    and use `jest.fn` for every method within `CounterService`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `jest.fn` returns a new, unused mock function that Jest automatically
    spies upon as well. Optionally, we can also pass a mock implementation method
    as a parameter for `jest.fn`. View the following example from the official documentation
    for `jest.fn`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once we create the stub, we pass it to the `TestBed` configuration in the provider’s
    array against the `CounterService` – but with the `useValue` property set to the
    `counterServiceMock`. This tells Angular to use our stub as it is for `CounterService`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the test where we expect `CounterService.getFromStorage` method to
    be called when the component initiates, we use the following statement:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that in the preceding code, we are able to directly use `expect` on `counterServiceMock.getFromStorage`.
    While this isn’t possible in Karma and Jasmine, it is possible with Jest, since
    we’re using `jest.fn` for each underlying method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for a test in which we want to check whether the `getFromStorage` method
    is called and returns a saved value, we first use the `counterServiceMock.getFromStorage.mockReturnValue(12);`
    statement. This ensures that when the `getFromStorage` method is called, it returns
    the value of `12`. Then, we just run the `ngOnInit` method in the test and expect
    that our component’s counter property has now been set to `12`. This means that
    the following things happen:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnInit` calls the `getFromStorage` method.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getFromStorage` returns the previously saved value (in our case, that’s `12`,
    but in reality, it’ll be fetched from `localStorage`).'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The component’s counter property is set to the retrieved value, which, in our
    case, is `12`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, for the final test, we just expect that the `saveToStorage` method of
    our `CounterService` is called in each necessary case. For this, we use the following
    types of `expect` statements:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That’s pretty much about it. Unit tests are fun, aren’t they? Now that you’ve
    understood how it all works, please refer to the next section for some helpful
    resources that you can use for further reading.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The official documentation for `jest.fn`: [https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.fn`的官方文档：[https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation)'
- en: 'Angular’s *Component testing scenarios*: [https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的*组件测试场景*：[https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios)
- en: Using spies on an injected service in a unit test
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单元测试中监视注入的服务
- en: While you can provide stubs for your services in the unit tests with Jest, sometimes,
    it might feel like an overhead creating a mock for every new service. Let’s suppose
    that if the service’s usage is limited to one test file, it might make more sense
    to just use spies on the actual injected service. In this recipe, that’s exactly
    what we’re going to do.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在单元测试中使用Jest为你的服务提供存根，但有时，为每个新的服务创建存根可能会感觉像是一种负担。让我们假设，如果服务的使用仅限于一个测试文件，那么在注入的实际服务上使用间谍可能更有意义。在这个配方中，我们正是要这么做。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-services`
    inside the cloned repository:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的应用位于克隆的仓库中的`start/apps/chapter10/ng-test-services`：
- en: Open the code repository in your code editor.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE25]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_10_08.png)'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_08.png)'
- en: 'Figure 10.8: ng-test-services app running on http://localhost:4200'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.8：ng-test-services应用在http://localhost:4200上运行
- en: Now that we have the app running, in the next section, let’s go through the
    steps of the recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了运行中的应用，在下一节中，让我们通过配方的步骤。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We have an application that has a `Counter` component. We can increment, decrement,
    and reset the counter, and the value for the counter changes. The value is also
    stored in the `localStorage`. We have the logic of saving and retrieving data
    from `localStorage` to the `CounterService`. Now, all the tests are passing, but
    we are checking the values in our tests directly from the `localStorage`. What
    if we decided to change the logic of where the counter value is stored? Perhaps
    we want to send a backend API call for it. To do this, it makes more sense to
    test that our `CounterService`''s methods are being called instead of checking
    `localStorage` methods. However, unlike the previous recipe, where we provided
    stubs for our services, we’re going to inject the service directly and will create
    jest spies for the functions from the Angular Service that we want to ensure are
    being called. Let’s follow the recipe to do that:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含`Counter`组件的应用。我们可以增加、减少和重置计数器，计数器的值也会改变。这个值也存储在`localStorage`中。我们有从`localStorage`到`CounterService`保存和检索数据的逻辑。现在，所有的测试都通过了，但我们直接从`localStorage`检查测试中的值。如果我们决定改变计数器值存储的逻辑呢？也许我们想要为它发送后端API调用。为此，测试我们的`CounterService`的方法是否被调用比检查`localStorage`方法更有意义。然而，与之前提供的为我们的服务提供存根的配方不同，我们将直接注入服务，并为我们要确保被调用的Angular服务中的函数创建jest间谍。让我们按照配方来做：
- en: 'Open the `counter.component.spec.ts` file. You’ll see a comment that says `//
    replace the tests below`. Let’s replace the first test `should call the localStorage.getItem
    method on component init` below that comment with the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`counter.component.spec.ts`文件。你将看到一个注释说`// 替换下面的测试`。让我们在那个注释下面替换第一个测试`should
    call the localStorage.getItem method on component init`，替换为以下内容：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you run `npm run test` again, you should still see all the tests passing.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你再次运行`npm run test`，你应该仍然看到所有测试都通过了。
- en: 'Now, let’s replace the test that says `should retrieve the last saved value
    from localStorage on component init` with the following test:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将测试替换为“在组件初始化时从localStorage检索最后保存的值”的测试，替换为以下测试：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, replace the last test that says `should save the new counterValue
    to localStorage on increment, decrement and reset` with the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将最后一个测试“在增加、减少和重置时将新的counterValue保存到localStorage”替换为以下代码：
- en: '[PRE28]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Awesome! With this change, you should see all eight tests passing. Let’s take
    a look at the next section to understand how it works.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过这个更改，你应该看到所有八个测试都通过了。让我们看看下一节，了解它是如何工作的。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe contained a lot of knowledge from the previous recipes of this chapter.
    However, the key highlight is the fact that the `CounterService` class that is
    injected in the component can only be directly mocked using the `jest.spyOn` method.
    This method removes the need to mock every single service separately. In the first
    (replaced) test, we spy on the `getFromStorage` method of the `component.counterService`
    property. This makes it a Jest spy that we can provide to the `expect` block and
    that can run the `expect(component.counterService.getFromStorage).toHaveBeenCalled();`
    statement. In the second test, notice that we not only spy on the `getFromStorage`
    method but also return a mock value, `12`, so that when the `component.ngOnInit`
    method is called, the value returned from the `CounterService` is this mocked
    value, `12`. Hence, the `counter` property is set to 12 and the test passes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last test, we spy on the `saveToStorage` method. Then, every
    time we click `Increment`, `Decrement`, or `Reset`, we expect the spied function
    to be called with the correct value. *Easy peasy!*
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Angular Services: [https://angular.io/guide/testing-services](https://angular.io/guide/testing-services)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking child components and directives using the ng-mocks package
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests mostly revolve around testing components, directives, pipes, or services
    in isolation. However, what if your component depends completely on another component
    or directive to work properly, especially in a non-standalone application/component?
    In such cases, you usually provide a mock implementation for the component, but
    that is a lot of work. However, with the `ng-mocks` package, it is super-easy.
    In this recipe, we’ll learn an advanced example of how to use `ng-mocks` for a
    parent component that depends on a child component to work properly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-ng-mocks`
    inside the cloned repository:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_09.png)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.9: ng-test-ng-mocks app running on http://localhost:4200'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you run the command `npm run test ng-test-ng-mocks` from the workspace root,
    you’ll see that not all of our tests pass. Additionally, there are a bunch of
    errors on the console, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18469_10_10.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Error during unit tests mentioning app-version-control component'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are using an app with `NgModule`, i.e., *not a standalone app*.
    This is to demonstrate how to work in such situations. Let’s go through the recipe
    to mock the respective components using the `ng-mocks` package:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s install the `ng-mocks` package within our project. To do this,
    run the following command from your project root in the Terminal:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we’ll try to fix the tests for the `App` component. To only run specific
    tests based on a string regex, we can use the -`t` parameter with the test command.
    Run the following command, and after it runs, press the -`t` key to provide the
    regex `"``App"`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, you can see that we only run the tests for `AppComponent`, and they fail
    as follows:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_11.png)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.11: Only running specific tests'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the error shown in *Figure 10.10*, we’ll import `VersionControlComponent`
    into the `TestBed` definition inside the `app.component.spec.ts` file. This is
    so that our test environment also knows the missing `<app-version-control>` component.
    To do this, modify the file as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you rerun the tests for `AppComponent`, you’ll see some fresher and newer
    errors. Progress! But since we have the `Version Control` component dependent
    on another component, the tests don’t pass. We’ll discuss why this is in more
    detail in the *How it works...* section. However, to fix this, let’s follow the
    next steps.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead of providing the `VersionControlComponent` directly, we need to mock
    it, since we don’t really care about it for the tests for `AppComponent`. One
    way would be to use `CUSTOM_ELEMENT_SCHEMA` in the `TestBed`''s configuration
    to tell the test bed that we don’t really care about the `VersionControlComponent`
    inside the tests for `AppComponent`. However, we’re going to use a `MockComponent`
    from `ng-mocks` to mock the component, achieving the same outcome. To do this,
    update the `app.component.spec.ts` file as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Boom! Problem solved. Run the tests again, just for the `AppComponent`, and
    you should see them all pass as follows:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_12.png)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.12: Passing all of the tests for App component'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the *a* key in the terminal to run all tests again.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s talk about the tests for the `Version Control` component. This depends
    on the `VC Logs` component. Let’s mock the `VCLogsComponent` class like a pro
    this time, using the `MockBuilder` and `MockRender` methods, so we can get rid
    of the errors during the tests. After the update, the `version-control.component.spec.ts`
    file should appear as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you run `npm run test` now, you should see all of the tests passing. Let’s
    write another test in the next step.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`VersionControlComponent` uses `VCLogsComponent` as a child component in the
    template. Additionally, it provides the `vName` property as `@Input()` to `VCLogsComponent`,
    via the `[vName]` attribute. We can check whether the input’s value is set correctly.
    To do so, update the `version-control.component.spec.ts` file, as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are now going to modify the `vc-logs.component.spec.ts` file to make sure
    that when the `vName` changes inside the `VCLogsComponent`, we have a new log
    created inside the `logs` array. To do so, modify the file as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Boom! We have implemented some interesting tests by using the `ng-mocks` package.
    I absolutely love it every time I use it (mostly with components that are part
    of an `NgModule`, as `standalone` components don’t have this issue). Now that
    we’ve finished the recipe, in the next section, let’s take a look at how it all
    works.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of interesting things that we have covered in this recipe.
    First, to avoid any errors on the console complaining about unknown components,
    we use the `MockComponent` method from the `ng-mocks` package, declaring the components
    we’re dependent on as mocks. Notice that when a component is mocked, it loses
    its functionality, as all the methods become `spy` functions. That is absolutely
    the simplest thing we can achieve with the `ng-mocks` package. However, we will
    move on to an advanced situation, which I will admit is sort of an unconventional
    approach, that is, testing the `@Input` properties and `@Output` emitters of the
    child components in the parent component in order to test an entire flow. This
    is what we do for the tests of `VersionControlComponent` by checking the value
    of an `@Input` property `vName`. Again, this is mostly useful for non-standalone
    components.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we removed the usage of the `@angular/core/testing` package completely
    from the `version-control.component.spec.ts` file. This is because we’re no longer
    using `TestBed` to create the test environment. Instead, we use the `MockBuilder`
    method from the `ng-mocks` package to build the test environment for our `VersionControlComponent`.
    The `MockBuilder` method has several overloads, the one we used to take the target
    component as the first argument, and the `NgModule` this component is a part of
    as the second argument. The module and everything inside it are mocked. This makes
    it so much easier to test the component in isolation. You also have methods like
    `exclude` that you can chain, like `MockBuilder(MyComponent, MyModule).exclude(OtherComponent)`,
    to not mock specific components. However, we didn’t need to do that in this recipe.
    We also wrote an interesting test for the `VersionControlComponent`, that is,
    getting a child component (`VCLogsComponent`) using the `ngMocks.find` method
    and checking if the child component’s `@Input()` is set appropriately when the
    respective property in the parent changes. I call this interesting because now
    we’re getting away from the entire notion of “testing components in isolation,”
    as we are now checking a property of another component than the component we’re
    actually testing. In general, you would want to mock the child components or any
    dependency that a component has. With that said, the approach in your team might
    be different. If you have a strong case for not mocking the child component and
    then checking its properties as shown in the recipe, now you know how. Please
    refer to the next section for further resources to read.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don’t use a spy on the `VersionControlComponent.addNewReleaseLog`
    method. This is because if we do so, that function will become a Jest spy function.
    Therefore, it’ll lose its internal functionality. In return, it’ll never add the
    new log to the `releaseLogs` array, and none of our tests will pass. You can try
    it out for fun.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ng-mocks` package’s `mock` method: [https://ng-mocks.sudo.eu/api/MockBuilder#mock](https://ng-mocks.sudo.eu/api/MockBuilder#mock)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ng-mocks` official documentation: [https://ng-mocks.sudo.eu](https://ng-mocks.sudo.eu)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing even easier tests with Angular CDK component harnesses
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing tests for components, there might be scenarios where you’d want
    to interact with the DOM elements. Now, this can already be achieved by using
    the `fixture.debugElement.query` method to find the element, using a selector
    and then triggering events on it. However, that means maintaining the DOM queries
    for different platforms, knowing the identifiers of all the selectors, and then
    exposing all of that in the tests. And this is even worse if we’re talking about
    an Angular library. It certainly isn’t necessary for each developer who interacts
    with my library to know all the element selectors in order to write tests. Only
    the author of the library should know that much to respect encapsulation. Luckily,
    we have the component harnesses from the Angular CDK team, which were released
    with Angular 9 along with the IVY compiler. And they’ve led by example, by providing
    component harnesses for the Angular material components as well. In this recipe,
    you’ll learn how to create your own component harnesses.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-cdk-harness`
    inside the cloned repository:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_13.png)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.13: The ng-test-cdk-harness app running on http://localhost:4200'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have the app running, let’s move on to the next section to follow
    the recipe.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have our favorite Angular version control app that allows us to create release
    logs. Also, we have tests written already, including tests that interact with
    the DOM element to validate a few use cases. Let’s follow the recipe to use component
    harnesses instead, discovering how easy it becomes to use in the actual tests:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following command to run the tests:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we’ll create a `component harness` for the `VersionControlComponent`.
    Let’s create a new file inside the `version-control` folder, and name it `version-control.component.harness.ts`.
    Then, add the following code inside it:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we need to set up the harness environment for our tests for `VersionControlComponent`.
    For this, we’ll use `TestbedHarnessEnvironment` from the Angular CDK. Update the
    `version-control.component.spec.ts` file as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let’s write some methods in our `VersionControlComponentHarness` class
    to get the relevant information. We’ll use these methods in the later steps. Update
    the `version-control.component.harness.ts` file as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we’ll work on our first test, named `should show error on wrong version
    number input`, with the component harness. Update the `version-control.component.spec.ts`
    file as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, if you run `npm run test`, you should see all of the tests passing, which
    means our first test with the component harness works. Woo-hoo!
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the final test, we also need a component harness for `VCLogsComponent`.
    Let’s quickly create it. Add a new file inside the `vc-logs` folder, named `vc-logs.component.harness.ts`,
    and add the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, let’s modify our final tests in the `version-control.component.spec.ts`
    file as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Voilà! That’s some amazing testing right there using the Angular CDK component
    harnesses. If you run the tests now, you should see them all passing. Now that
    you’ve finished the recipe, please refer to the next section to learn how this
    works.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All right! That was a cool recipe, and I enjoyed writing it too. The key factor
    of this recipe is the `@angular/cdk/testing` package. If you have worked with
    `e2e` tests using Protractor before, this is a similar concept to the **Pages**
    or **Page Objects** (**POs**) in Protractor. The first thing we do is to create
    a component harness for both the `VCLogsComponent` and the `VersionControlComponent`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we import the `ComponentHarness` class from `@angular/cdk/testing`
    for both component harnesses. Then, we extend our custom classes, called `VersionControlComponentHarness`
    and `VCLogsComponentHarness`, from the `ComponentHarness` class. Essentially,
    this is the correct way to author component harnesses. Did you notice the static
    property called `hostSelector`? We need this property for every component harness
    class that we create, and the value is always the selector of the target element/component.
    This ensures that when we load this harness into the test environment, the environment
    can find the host element in the DOM – for which we’re creating the component
    harness. In our component harness class, we use the `this.locatorFor` method to
    find elements within the host component. The `locateFor` method takes a single
    argument as the **CSS selector** of the element to be found, returning an `AsyncFactoryFn`.
    This means the returned value is a function that we can use later to get the required
    elements.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In the `VersionControlComponentHarness` class, we find the submit button and
    the version number input using the *protected* methods `getSubmitButton` and `getAppVersionInput`,
    respectively. All of these are of the `AsyncFactoryFn` type, as mentioned earlier.
    We have these methods set as *protected* because we don’t want the developers
    who write the unit tests to access or care about the information of the DOM elements.
    This makes it much easier for everyone to write tests without worrying about the
    internal implementation of accessing the DOM.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to mention here is that when we call the `locatorFor` method
    or the `locatorForAll` method, we get back a `Promise` with the `TestElement`
    item or a `Promise` with a list of `TestElement` items, respectively. Each `TestElement`
    item has a bunch of handy methods, such as `click`, `sendKeys`, `focus`, `blur`,
    `getProperty`, `text`, and more. These methods are what we’re interested in, since
    we use them behind the scenes to interact with the DOM elements.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about configuring the test environment. In the `version-control.component.spec.ts`
    file, we set up the environment to use component harnesses for both `VCLogsComponent`
    and `VersionControlComponent`. The `TestbedHarnessEnvironment` element is the
    key element here. We use the `TestbedHarnessEnvironment.harnessForFixture` method
    first. This is because we are writing tests for the `VersionControlComponent`,
    and we also want the harness of the same component as root. Therefore, the `harnessForFixture`
    method makes sense here. This method takes the `fixture` as the first argument
    and the `harness` class as the second. Then, we also use the `loader` method of
    the `TestbedHarnessEnvironment` class to get an instance of the `HarnessLoader`.
    This loader can then get the harness of the `VCLogsComponent`, i.e., get the instance
    of the `VCLogsComponentHarness` class. Note that the fixture is what we get in
    the test environment using the `TestBed.createComponent(VersionControlComponent)`
    statement.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the tests, we use the `harnessLoader.getHarness` method by providing
    the harness class as an argument. This enables the test environment to find the
    DOM element associated with the `hostSelector` property of the harness class.
    Additionally, we get back the instance of the component harness that we can use
    further in the test.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding components in the DOM with component harnesses: [https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom](https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API for component harness authors: [https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors](https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing responses from HTTP calls
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re building an Angular application, it is very likely that you’ll work
    with HTTP calls inside the app at some point. For instance, you could be fetching
    data from a third-party API or just making APIs to your own server. In either
    case, it becomes slightly difficult to test applications that have HTTP calls
    in action. In this recipe, we’re going to learn how to create unit-tests with
    HTTP calls.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-http-resp`
    inside the cloned repository:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_14.png)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.14: The ng-test-http-resp app running on http://localhost:4200'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s also run the tests. Right now, the test for the `UserService`, which
    fetches the `HTTP` response, doesn’t pass. You should see an output similar to
    *Figure 10.15*:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_15.png)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.15: Test failing for the UserService'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app and tests running locally, in the next section, let’s
    take a look at the steps of the recipe.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll write one single test that checks if the service’s `getUser` method returns
    the correct data. If you open the `UserService`, you’ll notice that the service
    fetches the users using an HTTP call and then modifies the data to add the `fullAddress`
    property. Our test should expect the same to happen. Let’s get started:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we’ll fix the failing test. We’ll add the `HttpClientModule`
    class to the test in the `imports` array. Update the `user.service.spec.ts` as
    follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, as soon as you run the `npm run test` command, you’ll see that the tests
    pass now as follows:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_16.png)'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.16: Tests passing for the UserService as well'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll import the `HttpClientTestingModule` in the `user.service.spec.ts`
    file to be able to use it to intercept HTTP calls. Modify the file as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s create a controller using the `HttpTestingController` class from the
    same `@angular/common/http/testing` package. We’ll use this controller later to
    expect and intercept the HTTP calls. Update the `user.service.spec.ts` file as
    follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we’ll write a test (finally). We’ll intercept the HTTP call to `/assets/users.json`
    using the `httpTestingController`, and then we will compare the result with our
    expected data. Update the `user.service.ts` file by adding a test, as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We’ll add an `afterEach` hook in the tests to verify that there are no pending
    requests after our test. Let’s add it to the `user.service.spec.ts` file as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, let’s populate the mock data (the `mockUsers` array) with two users. Since
    we’re using `req.flush(mockUsers)`, the HTTP call will be intercepted, and this
    data (`mockUsers` array) will be returned from it as a response. Replace the test
    `it('should return expected user data (HttpClient called once)'` in the file `user.service.spec.ts`
    with the snippet from [https://ng-cookbook.com/s/ng-test-http-mock-users](https://ng-cookbook.com/s/ng-test-http-mock-users).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, update the test further to make the http call, using the `getUsers`
    method, and see if we can expect the transformed data. Update the `user.service.spec.ts`
    file, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you run the tests, you should see them all pass as follows:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_17.png)'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.17: All of the tests pass'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! You now know how to work with `HttpTestingController` to test services
    that have methods, using HTTP calls. Although there’s still a lot to learn about
    testing HTTP calls and Observables in Angular, the purpose of this recipe was
    to keep everything simple and sweet.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have finished the recipe, please refer to the next section to understand
    how it works.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hero of this recipe is the `HttpClientTestingModule`, which allows us to
    use an instance of `HttpTestingController`. The `HttpTestingController` makes
    it easy to intercept the HTTP calls in our code and allows us to return a specific
    response. This makes it easier for us to not have our Angular services tested
    with real HTTP calls, which can be expensive. Another benefit of this approach
    to mocking the response is always having the same response object to work with.
    In our case, our `getUsers` method not only made an HTTP call but also transformed
    data, using the `map` operator from `RxJs`. Therefore, we used an array of mocked
    users and expected the result from the `getUsers` method to have the transformed
    data, i.e., including the `fullAddress` property containing the right data. You
    can see in the test that we use the `HttpTestingController.expectOne` method,
    telling our test that there should be only one request when we run the test. We
    expect the method of that request to be `GET`. Then, we expect that the returned
    value from the `getUsers` method has an array of users containing the `fullAddress`
    property.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular testing component scenarios: [https://docs.angular.lat/guide/testing-components-scenarios](https://docs.angular.lat/guide/testing-components-scenarios)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpTestingController` docs: [https://angular.io/api/common/http/testing/HttpTestingController](https://angular.io/api/common/http/testing/HttpTestingController)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing Angular pipes
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, pipes are the easiest thing to test in an Angular application.
    Why? Well, this is because they’re (supposed to be) pure functions that return
    the same result based on the same set of inputs. In this recipe, we’ll write some
    tests for a simple pipe in an Angular application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-pipes`
    inside the cloned repository:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_10_18.png)'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 10.18: The ng-test-pipes app running on http://localhost:4200'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have a simple recipe that takes two inputs – the digit and the max
    factor value. Based on these inputs, we show a multiplication table. We already
    have the `MultTablePipe` that is working fine according to our business logic.
    We’ll now write some unit tests to validate our inputs and expected outputs, as
    follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write our first custom test for `MultTablePipe`. We’ll make sure it returns
    an empty array when we have an invalid value for the `digit` input. Replace the
    whole `mult-table.pipe.spec.ts` file with the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s write another test to validate the `limit` input so that we also return
    an empty array if it is invalid:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we’ll write a test to validate the output of the pipe’s `transform` method
    when both the `digit` and `limit` inputs are valid. In this scenario, we should
    get back the array containing the multiplication table. Write another test as
    follows:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Right now, within the app, we have the possibility to provide decimal digits
    for the `limit` input. For instance, we can write `2.5` as the max factor in the
    input. To handle this, we use a `Math.floor` in `MultTablePipe` to round it down
    to the lower number. Let’s write a test to make sure this works:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Easy peasy!* Writing tests for Angular pipes is so straightforward that I
    love it. We could call this the power of pure functions. Now that you’ve finished
    the recipe, please refer to the next section for more informative links.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing Angular pipes official documentation: [https://angular.io/guide/testing-pipes](https://angular.io/guide/testing-pipes)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test Angular Pipes With Services: [https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576](https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularCookbook2e](Chapter_10.xhtml)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
