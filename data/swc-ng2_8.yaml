- en: Chapter 8. Development Experience and Server-Side Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。开发体验和服务器端渲染
- en: We are already familiar with all the core concepts of Angular 2\. We know how
    to develop a component-based user interface, taking advantage of all the building
    blocks that the framework provides—directives, components, dependency injections,
    pipes, forms, and the brand new component-based router.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了Angular 2的所有核心概念。我们知道如何开发基于组件的用户界面，利用框架提供的所有构建模块——指令、组件、依赖注入、管道、表单和全新的基于组件的路由器。
- en: 'For the next step, we''ll look at where to begin when we want to build a **single-page
    application** (**SPA**) from scratch. This chapter describes how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看从头开始构建**单页应用程序**（**SPA**）时应该从哪里开始。本章描述了如何执行以下操作：
- en: Use Web Workers for performance-sensitive applications.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于性能敏感的应用程序，请使用Web Workers。
- en: Build SEO-friendly applications with server-side rendering.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务器端渲染构建友好的SEO应用程序。
- en: Bootstrap a project as quickly as possible.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快启动项目。
- en: Enhance our experience as developers.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强我们作为开发者的体验。
- en: So, let's begin!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: Running applications in Web Workers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web Workers中运行应用程序
- en: When talking about performance in the context of frontend web development, we
    can either mean network, computational, or rendering performance. In this section,
    we'll concentrate on rendering and computational performance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论前端Web开发的性能时，我们可以指的是网络、计算或渲染性能。在本节中，我们将集中讨论渲染和计算性能。
- en: First, let's make a parallel between a web application and a video, and between
    a browser and a video player. The biggest difference between the web application
    running in the browser and the video file playing in the video player is that
    the web page needs to be generated dynamically, in contrast to the video which
    has been recorded, encoded, and distributed. However, in both the cases, the user
    of the application sees a sequence of frames; the core difference is how these
    frames are being generated. In the world of video processing, when we play a video,
    we have it already recorded; it is the responsibility of the video decoder to
    extract the individual frames based on the compression algorithm. In contrast
    to this, on the Web, JavaScript, and CSS are in charge of producing frames, rendered
    by the browser's rendering engine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将Web应用程序和视频，以及浏览器和视频播放器进行对比。在浏览器中运行的Web应用程序和视频播放器中播放的视频文件之间最大的区别是，Web页面需要动态生成，而视频已经被录制、编码和分发。然而，在这两种情况下，应用程序的用户都会看到一系列帧；核心区别在于这些帧是如何生成的。在视频处理领域，当我们播放视频时，视频已经被录制；视频解码器的责任是根据压缩算法提取单个帧。与此相反，在Web上，JavaScript和CSS负责生成由浏览器渲染引擎渲染的帧。
- en: In the context of the browser, we can think of each frame as a snapshot of the
    web page at a given moment. The different frames are rendered fast one after another,
    so in theory, the end user of the application should see them smoothly incorporated
    together, just like a video played in a video player.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器的上下文中，我们可以将每一帧视为在给定时刻的网页快照。不同的帧快速地一个接一个地渲染，因此理论上，应用程序的最终用户应该看到它们平滑地结合在一起，就像在视频播放器中播放视频一样。
- en: On the Web, we are trying to reach 60 fps (frames per second), which means that
    each frame has about 16 ms to be computed and rendered on the screen. This duration
    includes the time required by the browser to make all the necessary calculations
    for the layout and the rendering of the page, and also the time that our JavaScript
    needs to execute.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web上，我们试图达到60帧每秒（每秒帧数），这意味着每帧大约有16毫秒在屏幕上计算和渲染。这段时间包括浏览器进行布局和页面渲染所需的时间，以及我们的JavaScript需要执行的时间。
- en: In the end, we have less than 16 ms (because of the browser rendering functionality
    that takes time depending on the calculations it needs to perform) for our JavaScript
    to finish execution. If it doesn't fit in this duration, the frame rate will drop
    by half. Since JavaScript is a single-threaded language, all the calculations
    need to happen in the main UI thread that, in the case of computationally-intensive
    applications (such as image or video processing, marshaling and unmarshaling big
    JSON strings, and so on), can lead to very poor user experience because of the
    frames being dropped.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只有不到16毫秒的时间（因为浏览器渲染功能需要时间，取决于它需要执行的计算）来完成JavaScript的执行。如果超过这个持续时间，帧速率将下降一半。由于JavaScript是单线程语言，所有计算都需要在主UI线程中进行，这在计算密集型应用程序（如图像或视频处理、大型JSON字符串的编组和解组等）的情况下，可能会导致用户体验非常差，因为帧会被丢弃。
- en: HTML5 introduced an API called **Web Workers**, which allows the execution of
    client-side code in the browser environment into multiple threads. For simplicity,
    the standard doesn't allow shared memory between individual threads, but instead
    allows communication with message passing. The messages exchanged between Web
    Workers and the main UI thread must be strings, which often requires the serialization
    and deserialization of JSON strings.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5引入了一个名为**Web Workers**的API，它允许在浏览器环境中执行客户端代码到多个线程中。简单起见，标准不允许个别线程之间共享内存，而是允许通过消息传递进行通信。Web
    Workers和主UI线程之间交换的消息必须是字符串，这经常需要对JSON字符串进行序列化和反序列化。
- en: 'The lack of shared memory between the individual workers, and the workers and
    the main UI thread brings a couple of limitations, such as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 个别工作线程之间以及工作线程和主UI线程之间缺乏共享内存带来了一些限制，比如：
- en: Disabled access to the DOM by the worker threads.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作线程无法访问DOM。
- en: Global variables cannot be shared among the individual computational units (that
    is, worker threads and main UI threads and vice versa).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量不能在个别计算单元（即工作线程和主UI线程以及反之）之间共享。
- en: Web Workers and Angular 2
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Workers和Angular 2
- en: Because of the platform agnostic design of Angular 2, the core team decided
    to take advantage of this API, and during the summer of 2015, Google embedded
    Web Workers support into the framework. This feature allows most of the Angular
    2 applications to be run on a separate thread, making the main UI thread responsible
    only for rendering. This helps us achieve the goal of 60 fps much easily than
    running the entire application in a single thread.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular 2的平台不可知设计，核心团队决定利用这个API，在2015年夏天，谷歌将Web Workers支持嵌入到了框架中。这个特性使得大多数Angular
    2应用程序可以在单独的线程上运行，使得主UI线程只负责渲染。这有助于我们更容易地实现60帧每秒的目标，而不是在单个线程中运行整个应用程序。
- en: The Web Workers support is not enabled by default. When enabling it, we need
    to keep something in mind—in a Web Workers-ready application, the components are
    not going to be run in the main UI thread, which does not allow us to directly
    manipulate the DOM. In this case, we need to use bindings, such as inputs, outputs,
    and a combination of both with `NgModel`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers支持默认情况下是未启用的。启用它时，我们需要记住一些事情——在一个准备好使用Web Workers的应用程序中，组件不会在主UI线程中运行，这不允许我们直接操作DOM。在这种情况下，我们需要使用绑定，比如输入、输出，以及`NgModel`的组合。
- en: Bootstrapping an application running in Web Worker
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Web Worker中引导运行应用程序。
- en: Let's make the to-do application that we developed in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives* work in Web Workers. You can
    find the example that we'll explore at `ch8/ts/todo_webworkers/`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives")中开发的待办事项应用程序，在
    Web Workers 中运行。您可以在 `ch8/ts/todo_webworkers/` 找到我们将要探索的示例。
- en: First of all, let's discuss the changes that we need to make. Take a look at
    `ch4/ts/inputs-outputs/app.ts`. Notice that inside of `app.ts`, we included the
    `bootstrap` function from the `angular2/platform/browser` module. This is the
    first thing we need to modify! The `bootstrap` process of an application running
    in a background process is different.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论需要进行的更改。看一下 `ch4/ts/inputs-outputs/app.ts`。注意，在 `app.ts` 中，我们包含了来自 `angular2/platform/browser`
    模块的 `bootstrap` 函数。这是我们需要修改的第一件事！在后台进程中运行的应用程序的 `bootstrap` 过程是不同的。
- en: 'Before refactoring our code, let''s take a look at a diagram that illustrates
    the `bootstrap` process of a typical Angular 2 application running in Web Workers:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构我们的代码之前，让我们看一下一张图表，说明了在 Web Workers 中运行的典型 Angular 2 应用程序的 `bootstrap` 过程：
- en: '![Bootstrapping an application running in Web Worker](../images/00033.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![在 Web Worker 中运行应用程序的引导过程](../images/00033.jpeg)'
- en: '*Jason Teplitz*, who implemented the Web Worker support in Angular 2, presented
    this diagram during his talk on *AngularConnect 2015*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jason Teplitz* 在 *AngularConnect 2015* 上介绍了在 Angular 2 中实现 Web Worker 支持的这张图表。'
- en: 'The diagram has two parts: **UI** and **Web Worker**. UI shows the actions
    performed during initialization in the main UI thread; the **Web Worker** part
    of the diagram shows how the application gets bootstrapped in the background thread.
    Now, let''s explain the `bootstrap` process step by step.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该图分为两部分：**UI** 和 **Web Worker**。UI 显示了在主 UI 线程初始化期间执行的操作；图表的 **Web Worker**
    部分显示了应用程序在后台线程中如何启动。现在，让我们逐步解释 `bootstrap` 过程。
- en: 'First, the user opens the `index.html` page, which triggers the download of
    the following two files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户打开 `index.html` 页面，触发以下两个文件的下载：
- en: The UI bundle of Angular 2 used for applications running in Web Worker.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在 Web Worker 中运行的 Angular 2 的 UI 捆绑包。
- en: The `system.js` bundle (we talked about the global object System in [Chapter
    3](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582 "Chapter 3. TypeScript
    Crash Course"), *TypeScript Crash Course*. We can think of the `system.js` bundle
    as a polyfill for the module loader).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.js` 捆绑包（我们在[第3章](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 3. TypeScript Crash Course")中讨论了全局对象 System，*TypeScript Crash Course*。我们可以将
    `system.js` 捆绑包视为模块加载器的 polyfill）。'
- en: Using `system.js`, we download the script used for the initialization of the
    part of the application running in the main UI thread. This script starts `loader.js`
    in Web Worker. This is the first script that is running in a background thread.
    Once the worker is started, `loader.js` will download `system.js` and the bundle
    of Angular 2, which is meant to be run in the background thread. The first request
    will usually hit the cache because `system.js` is already requested by the main
    thread. Using the module loader, we download the script that is responsible for
    bootstrapping the background app `background_bootstrap.js`, which will finally
    start the functionality of our application in the background.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`system.js`，我们下载了用于初始化在主UI线程中运行的应用程序部分的脚本。此脚本在Web Worker中启动了`loader.js`。这是在后台线程中运行的第一个脚本。一旦工作线程启动，`loader.js`将下载`system.js`和Angular
    2的捆绑包，这些捆绑包旨在在后台线程中运行。第一个请求通常会命中缓存，因为主线程已经请求了`system.js`。使用模块加载器，我们下载了负责引导后台应用程序`background_bootstrap.js`的脚本，最终将在后台启动我们应用程序的功能。
- en: From now on, the entire application that we built will be run in Web Worker
    and will exchange messages with the main UI thread for responding to user events
    and rendering instructions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们构建的整个应用程序将在Web Worker中运行，并将与主UI线程交换消息，以响应用户事件和渲染指令。
- en: Now that we are aware of the basic flow of events during initialization when
    using workers, let's refactor our to-do application to take advantage of them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在使用工作线程时初始化期间事件的基本流程，让我们重构我们的待办事项应用程序以利用它们。
- en: Migrating an application to Web Worker
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用程序迁移到Web Worker
- en: 'Inside of `index.html`, we need to add the following scripts:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`中，我们需要添加以下脚本：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding snippet, we've included references to `system.js`, `angular2-polyfills`
    that includes `zone.js` and the others used by Angular libraries, and `ui.dev.js`
    which is the bundle that needs to be run in the main UI thread.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述片段中，我们包括了对`system.js`、`angular2-polyfills`（包括`zone.js`）和Angular库使用的其他文件的引用，以及需要在主UI线程中运行的捆绑包`ui.dev.js`。
- en: Right after this, we will configure `system.js` by setting the `baseURL` property
    of the module loader. For the next step, we will explicitly import the `bootstrap.js`
    file, which contains the logic used for starting the `loader.js` script in Web
    Worker.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将通过设置模块加载器的`baseURL`属性来配置`system.js`。接下来，我们将显式导入包含用于在Web Worker中启动`loader.js`脚本的逻辑的`bootstrap.js`文件。
- en: 'Let''s explore `bootstrap.js`, which is the original of the transpiled `bootstrap.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`bootstrap.js`，这是经过转译的`bootstrap.js`的原始文件：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this file, we set the platform to the type `WORKER_RENDER_PLATFORM` and the
    application type to `WORKER_RENDER_APPLICATION`. We configured the provider used
    for injecting the `WORKER_SCRIPT` token to use the value `'loader.js'`. As we
    said, `loader.js` is going to run in a background thread. The script is located
    in the application's root.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将平台设置为`WORKER_RENDER_PLATFORM`类型，将应用程序类型设置为`WORKER_RENDER_APPLICATION`。我们配置了用于注入`WORKER_SCRIPT`令牌的提供程序，以使用值`'loader.js'`。正如我们所说，`loader.js`将在后台线程中运行。该脚本位于应用程序的根目录中。
- en: 'Now, we can move to the right of the diagram given in the *Bootstrapping an
    application running in a Web Worker* section. The logic in `loader.js` is quite
    simple:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以移动到*在Web Worker中运行应用程序的引导*部分中给出的图表的右侧。`loader.js`中的逻辑非常简单：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As the first step, we import `system.js`, the Web Workers bundle of Angular
    2 (`worker.dev.js`), and all the required `polyfills`. Then, we configure the
    background instance of the module loader and import the `background_app` file,
    which contains the logic of our application as well as the Web Workers bootstrap
    call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们导入`system.js`，Angular 2的Web Workers捆绑包（`worker.dev.js`）以及所有必需的`polyfills`。然后，我们配置模块加载器的后台实例并导入`background_app`文件，该文件包含我们应用的逻辑以及Web
    Workers的引导调用。
- en: 'Now, let''s explore how we bootstrap the application inside Web Worker:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何在Web Worker中引导应用程序：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just like in the bootstrap in the main UI thread, we specify the type of the
    platform and the type of the application that we want to bootstrap. In the final
    step, we set the root component just like we did in the standard bootstrap process.
    The `TodoApp` component is defined between the imports and the initialization
    calls in the `background_app` file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在主UI线程中引导一样，我们指定平台的类型和我们要引导的应用程序的类型。在最后一步中，我们设置根组件，就像在标准引导过程中所做的那样。`TodoApp`组件在`background_app`文件的导入和初始化调用之间定义。
- en: Making an application compatible with Web Workers
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使应用程序与Web Workers兼容
- en: As we said, the code that runs in the context of Web Worker does not have access
    to the DOM. Let's see what changes we need to make in order to address this limitation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，运行在Web Worker上下文中的代码无法访问DOM。让我们看看我们需要做哪些更改来解决这个限制。
- en: 'This is the original implementation of the `InputBox` component:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`InputBox`组件的原始实现：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that inside the template, we named the input element `todoInput` and
    used its reference within the expression set as the handler of the click event.
    This code will not be able to run in Web Worker, since we directly access a DOM
    element inside the template. In order to take care of this, we need to refactor
    the snippet, so it uses Angular 2 bindings instead of directly touching any elements.
    We can either use inputs when a single direction binding makes sense or `NgModel`
    for achieving two-way data-binding, which is more computationally-intensive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在模板内部，我们将输入元素命名为`todoInput`并在表达式集中使用它的引用作为单击事件的处理程序。由于我们直接在模板内部访问DOM元素，这段代码将无法在Web
    Worker中运行。为了解决这个问题，我们需要重构代码片段，使其使用Angular 2绑定而不是直接触摸任何元素。我们可以在单向绑定有意义时使用输入，或者使用`NgModel`来实现双向数据绑定，这需要更多的计算资源。
- en: 'Let''s use `NgModel`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`NgModel`：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this version of the `InputBox` component, we will create a two-way data-binding
    between the input element and the input property of the `InputBox` component.
    Once the user clicks on the button, the `emitText` method will be invoked, which
    will trigger a new event emitted by `inputText EventEmitter`. In order to reset
    the value of the input element, we take advantage of the two-way data-binding
    that we declared and set the value of the input property to the empty string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`InputBox`组件中，我们将在输入元素和`InputBox`组件的输入属性之间创建双向数据绑定。一旦用户点击按钮，将调用`emitText`方法，这将触发由`inputText
    EventEmitter`发出的新事件。为了重置输入元素的值，我们利用了我们声明的双向数据绑定，并将输入属性的值设置为空字符串。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Moving the entire logic from the templates of the components to their controllers
    brings a lot of benefits, such as improved testability, maintainability, code
    reuse, and clarity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件模板中的整个逻辑移动到它们的控制器中带来了许多好处，比如改进了可测试性、可维护性、代码重用和清晰度。
- en: The preceding code is compatible with the Web Workers environment, since the
    `NgModel` directive is based on an abstraction that does not manipulate the DOM
    directly, but instead, under the hood, exchanges messages asynchronously with
    the main UI thread.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与Web Workers环境兼容，因为`NgModel`指令基于一个不直接操作DOM的抽象，在幕后与主UI线程异步交换消息。
- en: 'To recap, we can say that while running applications in the context of Web
    Workers, we need to keep the following two things in mind:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以说，在Web Workers的上下文中运行应用程序时，我们需要牢记以下两点：
- en: We need to use a different bootstrap process.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用不同的引导过程。
- en: We should not access the DOM directly.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应直接访问DOM。
- en: 'Typical scenarios that violate the second point are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 违反第二点的典型情况如下：
- en: Changing the DOM of the page by selecting an element and manipulating it directly
    with the browser's native APIs or a third-party library.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过选择元素并直接使用浏览器的原生API或第三方库来操作页面的DOM。
- en: Accessing native elements injected by using `ElementRef`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问使用`ElementRef`注入的原生元素。
- en: Creating a reference to an element in the template and passing it as an argument
    to methods.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中创建对元素的引用并将其作为参数传递给方法。
- en: Directly manipulating an element referenced within the template.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接操作模板中引用的元素。
- en: In all these scenarios, we need to use the APIs provided by Angular. If we build
    our applications according to this practice, we will benefit not only from being
    able to run them in Web Workers, but also from increasing the code reuse in case
    we want to use them across different platforms.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，我们需要使用Angular提供的API。如果我们根据这种做法构建我们的应用程序，我们不仅将从能够在Web Workers中运行它们中受益，而且在我们希望在不同平台上使用它们时，还将增加代码重用。
- en: Keeping this in mind will allow us to take advantage of server-side rendering.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点将使我们能够利用服务器端渲染。
- en: Initial load of a single-page application
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序的初始加载
- en: In this section, we will explore what server-side rendering is, why we need
    it in our applications, and how we can use it with Angular 2.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨服务器端渲染是什么，为什么我们需要在我们的应用程序中使用它，以及我们如何在Angular 2中使用它。
- en: For our purposes, we'll explain the typical flow of events when a user opens
    a SPA implemented in Angular 2\. First, we'll trace the events with the server-side
    rendering disabled, and after that, we'll see how we can benefit from this feature
    by enabling it. Our example will be illustrated in the context of HTTP 1.1.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将解释用户打开在Angular 2中实现的SPA时的典型事件流程。首先，我们将跟踪禁用服务器端渲染时的事件，然后，我们将看到如何通过启用它来从这个功能中受益。我们的示例将在HTTP
    1.1的上下文中进行说明。
- en: '![Initial load of a single-page application](../images/00034.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![单页应用程序的初始加载](../images/00034.jpeg)'
- en: This image shows the first request by the browser and the corresponding server's
    response when loading a typical SPA. The result that the client will see initially
    is the initial content of the HTML page without any rendered components.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片展示了浏览器的第一个请求以及加载典型SPA时相应的服务器响应。客户端最初将看到的结果是HTML页面的初始内容，没有任何渲染的组件。
- en: Let's suppose that we deploy the to-do application we built in [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives* to a web server that has the
    `https://example.com` domain associated with it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们部署了我们在[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。使用Angular 2组件和指令入门")构建的待办事项应用程序到一个具有`https://example.com`域关联的Web服务器上。
- en: 'Once the user navigates to `https://example.com/`, the browser will open a
    new HTTP `GET` request, fetching the root resource (`/`). When the server receives
    the request, it will respond with an HTML file that, in our case, will look something
    like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户导航到`https://example.com/`，浏览器将打开一个新的HTTP GET请求，获取根资源（/）。当服务器收到请求时，它将用一个HTML文件作为响应，而在我们的情况下，它将看起来像这样：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The browser will receive this content as the body of the response. When the
    markup is rendered onto the screen, all that the user will see is the label: **Loading…**.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将接收此内容作为响应的主体。当标记呈现到屏幕上时，用户将只看到标签：**加载中...**。
- en: In the next step, the browser will find all the references in the HTML file's
    external resources, such as styles and scripts, and start downloading them. In
    our case, some of them are `bootstrap.css`, `es6-shim.min.js`, `Reflect.js`, `system.src.js`,
    and `angular2-polyfills.js`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，浏览器将查找HTML文件中外部资源的所有引用，比如样式和脚本，并开始下载它们。在我们的情况下，其中一些是bootstrap.css，es6-shim.min.js，Reflect.js，system.src.js和angular2-polyfills.js。
- en: Once all the referenced resources are available, there still won't be any significant
    visual progress for the user (except if the styles from the downloaded `CSS` file
    are applied to the page). This won't change until the JavaScript virtual machine
    processes all the referenced scripts related to the application's implementation.
    At this point, Angular will know which component needs to be rendered based on
    the current URL and bootstrap's configuration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有引用的资源都可用，用户将看不到任何显著的视觉进展（除非已经将下载的CSS文件中的样式应用到页面上）。这种情况直到JavaScript虚拟机处理了与应用程序实现相关的所有引用脚本之后才会改变。在这一点上，Angular将根据当前URL和引导程序的配置知道需要渲染哪个组件。
- en: If the component associated with the page is defined in a separate file outside
    of our main application bundle, the framework will need to download it together
    with its entire dependency graph. In case the template and the styles of the component
    are externalized, Angular will need to download them as well before it is able
    to render the requested page.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与页面相关联的组件在我们的主应用程序包之外的单独文件中定义，那么框架将需要下载它以及其整个依赖图。如果组件的模板和样式是外部化的，Angular还需要下载它们，然后才能渲染请求的页面。
- en: Right after this, the framework will be able to compile the template associated
    with the target component and render the page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，框架将能够编译与目标组件相关联的模板并渲染页面。
- en: 'In the previous scenario, there are the following two main pitfalls:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的情景中，存在以下两个主要问题：
- en: Search engines are not that good at indexing dynamic content generated by JavaScript.
    This means that the **SEO** (**Search Engine Optimization**) of our SPA will suffer.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索引擎不擅长索引JavaScript生成的动态内容。这意味着我们的SPA的SEO（搜索引擎优化）将受到影响。
- en: In case of large applications and/or poor Internet connection, the user experience
    will be poor.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型应用程序和/或网络连接差的情况下，用户体验将很差。
- en: In the past, we solved the SEO issue in the applications built with AngularJS
    1.x with different workarounds, such as using headless browser for rendering the
    requested page, caching it onto the disk, and later providing it to search engines.
    However, there's a more elegant solution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们通过不同的变通方法解决了使用AngularJS 1.x构建的应用程序中的SEO问题，比如使用无头浏览器来渲染请求的页面，将其缓存到磁盘上，然后提供给搜索引擎。然而，有一个更加优雅的解决方案。
- en: Initial load of a SPA with server-side rendering
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用服务器端渲染的SPA的初始加载
- en: A couple of years ago, libraries such as `Rendr`, `Derby`, `Meteor`, and the
    others introduced the concept of isomorphic JavaScript applications, which were
    later renamed to universal. In essence, universal applications could be run on
    the client as well as on the server. Such portability is only possible in the
    case of low coupling between the SPA and the browser's APIs. The greatest benefit
    of this paradigm is that the application can be rerendered on the server and later
    sent to the client.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，诸如`Rendr`、`Derby`、`Meteor`等库引入了同构JavaScript应用程序的概念，后来被重命名为通用应用程序。实质上，通用应用程序可以在客户端和服务器上运行。只有在SPA与浏览器API之间耦合较低的情况下，才能实现这种可移植性。这种范式的最大好处是应用程序可以在服务器上重新渲染，然后发送到客户端。
- en: Universal applications are not framework-specific; we can take advantage of
    them in any framework that can be run outside of the environment of the browser.
    Conceptually, the practice of server-side rendering is very similar across platforms
    and libraries; only its implementation details may differ. For instance, the Angular
    2 Universal module, which implements server-side rendering, has support for node.js
    as well as ASP.NET that, at the moment of this writing, is still work in progress.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通用应用程序不是特定于框架的；我们可以在任何可以在浏览器环境之外运行的框架中利用它们。从概念上讲，服务器端渲染的实践在各个平台和库中都非常相似；只是其实现细节可能有所不同。例如，Angular
    2 Universal模块实现了服务器端渲染，支持node.js以及ASP.NET，在我撰写本文时，后者仍在进行中。
- en: '![Initial load of a SPA with server-side rendering](../images/00035.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用服务器端渲染加载SPA的初始加载](../images/00035.jpeg)'
- en: The preceding image shows the response by the server to the initial browser
    `GET` request. This time, in contrast to the typical scenario of loading a SPA,
    the browser will get the rendered content of the HTML page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图片显示了服务器对初始浏览器`GET`请求的响应。这一次，与加载SPA的典型情景相比，浏览器将获得HTML页面的渲染内容。
- en: Let's trace the flow of the events in the same application with the server-side
    rendering feature enabled. In this case, once the server receives the HTTP `GET`
    request by the browser, it will run the SPA on the server in the node.js environment.
    All the DOM calls are going to be redirected to a server-side DOM implementation
    and be executed in the context of the used platform. Similarly, all the AJAX calls
    with the `http` module will be handled by the server-side implementation of the
    module. This way, the application will not make any difference, whether it is
    running in the context of the browser or the server.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们追踪具有启用服务器端渲染功能的相同应用程序中事件的流程。在这种情况下，一旦服务器接收到浏览器的HTTP `GET`请求，它将在node.js环境中在服务器上运行SPA。所有的DOM调用都将被重定向到服务器端的DOM实现，并在所使用的平台的上下文中执行。同样，所有使用`http`模块的AJAX调用都将由模块的服务器端实现处理。这样，应用程序无论是在浏览器还是服务器的上下文中运行，都不会有任何区别。
- en: Once the rendered version of the SPA is available, it can be serialized to HTML
    and sent to the browser. This time, during the application's initialization, instead
    of the **Loading…** label, the user will see the page they requested right away.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦SPA的渲染版本可用，就可以将其序列化为HTML并发送到浏览器。这一次，在应用程序初始化期间，用户将立即看到他们请求的页面，而不是**加载中...**标签。
- en: Note that at this point, the client will have the rendered version of the application,
    but all the referenced external resources, such as scripts and styles, still need
    to be available. This means that, initially, none of the CSS styles declared in
    the external files will be applied and the application will not be responsive
    to any user-related interactions, such as the mouse and keyboard events.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此时，客户端将拥有应用程序的渲染版本，但所有引用的外部资源，如脚本和样式，仍然需要可用。这意味着最初，外部文件中声明的CSS样式将不会应用，并且应用程序将不会对任何与用户相关的交互做出响应，如鼠标和键盘事件。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in case the scripts are inlined into the server-side rendered page,
    the application will be responsive to user events. However, inlining big chunks
    of JavaScript is generally considered as a bad practice, since it will increase
    the page's size dramatically and prevent the scripts from caching. Both will influence
    the network performance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果脚本被内联到服务器端渲染的页面中，应用程序将对用户事件做出响应。然而，内联大块的JavaScript通常被认为是一种不良实践，因为它会大幅增加页面的大小，并阻止脚本缓存。这两者都会影响网络性能。
- en: When the JavaScript virtual machine processes the JavaScript associated with
    the page, our SPA will be ready to use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript虚拟机处理与页面相关的JavaScript时，我们的SPA将准备就绪。
- en: Server-side rendering with Angular 2
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2的服务器端渲染
- en: In the first half of 2015, Patrick Stapleton and Jeff Whelpley announced that
    they started the development of the module, **Universal**. Universal is a library
    that allows us to build universal (also called **isomorphic**) JavaScript applications
    with Angular 2; in other words, it provides server-side rendering support.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年上半年，Patrick Stapleton和Jeff Whelpley宣布他们开始开发**Universal**模块。Universal是一个库，允许我们使用Angular
    2构建通用（也称为**同构**）JavaScript应用程序；换句话说，它提供了服务器端渲染支持。
- en: Applications built with Angular 2 and Universal will not be responsive until
    all the JavaScript belonging to the requested page is processed. This is a drawback
    that we already mentioned, which is valid for all the server-side rendered applications.
    However, Patrick and Jeff introduced **preboot.js**, which is a lightweight library
    that will be inlined on the page rendered by the server and available after the
    initial client request.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular 2和Universal构建的应用程序在处理完所请求页面的所有JavaScript之前将无法响应。这是一个我们已经提到过的缺点，对所有服务器端渲染的应用程序都适用。然而，Patrick和Jeff引入了**preboot.js**，这是一个轻量级的库，将被内联到服务器渲染的页面中，并在初始客户端请求后可用。
- en: 'Preboot.js has several strategies for the management of the received client
    events before the application has been completely initialized. They are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Preboot.js有几种策略来管理应用程序完全初始化之前接收到的客户端事件。它们如下：
- en: Record and play back events.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录并回放事件。
- en: Respond immediately to events.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即响应事件。
- en: Maintain focus when a page is rerendered.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面重新渲染时保持焦点。
- en: Buffer client-side re-rendering for smoother transition.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲客户端重新渲染以实现更平滑的过渡。
- en: Freeze page until the bootstrap is complete if a user clicks on a button.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户点击按钮，冻结页面直到引导程序完成。
- en: At the moment of this writing, the Universal module is still being actively
    developed. However, you can give it a try using the Angular 2 universal starter
    at [https://github.com/angular/universal-starter](https://github.com/angular/universal-starter).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Universal模块仍在积极开发中。但是，您可以尝试使用Angular 2通用启动器[https://github.com/angular/universal-starter](https://github.com/angular/universal-starter)。
- en: Enhancing our development experience
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强我们的开发体验
- en: Our experience as developers can be enhanced in terms of productivity or by
    allowing us to have more fun while working on our projects. This can be achieved
    with all the tools, IDEs, text editors, and more that we use on a daily basis.
    In this section, we'll briefly take a look at popular IDEs and text editors that
    we can use for taking advantage of the static code analysis features that Angular
    2 provides.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们的经验可以通过提高生产力或允许我们在项目上更有乐趣来增强。这可以通过我们日常使用的所有工具、IDE、文本编辑器等来实现。在本节中，我们将简要介绍一些流行的IDE和文本编辑器，以便利用Angular
    2提供的静态代码分析功能。
- en: In the second part of this section, we'll see what hot reloading is and how
    we can take advantage of it during the development of Angular 2 applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第二部分，我们将看到热重载是什么，以及在开发Angular 2应用程序时如何利用它。
- en: Text editors and IDEs
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本编辑器和IDE
- en: 'As we already mentioned at the beginning of the book, the core team put great
    effort into enhancing the tooling support in Angular 2\. First of all, the framework
    is built with TypeScript, which naturally allows us to use static typing during
    our development process. Some of the text editors and IDEs that have great TypeScript
    support are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书开头已经提到的，核心团队在增强Angular 2的工具支持方面付出了很大的努力。首先，该框架是用TypeScript构建的，这自然地允许我们在开发过程中使用静态类型。一些具有很好TypeScript支持的文本编辑器和IDE如下：
- en: '**IntelliJ Idea**: A general-purpose IDE by JetBrains.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ Idea**：由JetBrains开发的通用IDE。'
- en: '**WebStorm**: An IDE specialized for web development by JetBrains.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebStorm**：JetBrains专门为Web开发开发的IDE。'
- en: '**VSCode**: A cross-platform text editor written in TypeScript and developed
    by Microsoft.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**：一款由微软开发的跨平台文本编辑器，使用TypeScript编写。'
- en: '**Sublime Text**: A cross-platform text editor.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sublime Text**：一款跨平台文本编辑器。'
- en: '**Atom**: A cross-platform text editor.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Atom**：一款跨平台文本编辑器。'
- en: Recently, JetBrains announced advanced Angular 2 support in IntelliJ Idea and
    WebStorm, which supports autocompletion for components and bindings.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，JetBrains宣布在IntelliJ Idea和WebStorm中提供了先进的Angular 2支持，支持组件和绑定的自动完成。
- en: Although not all the mentioned IDEs and text editors have Angular 2-specific
    support at the moment of this writing, Angular 2 comes with a great design. It
    allows us to perform advanced static code analysis on the application's codebase
    for the development of sophisticated refactoring and productivity tools in the
    near future. Until then, Angular 2 at least provides tooling support as good any
    other JavaScript framework in the market.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在撰写本文时，并非所有提到的IDE和文本编辑器都具有针对Angular 2的支持，但Angular 2具有出色的设计。它允许我们对应用程序的代码库进行高级静态代码分析，以便在不久的将来开发复杂的重构和生产工具。在那之前，Angular
    2至少提供了与市场上任何其他JavaScript框架一样好的工具支持。
- en: Hot reloading
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热重载
- en: Hot reloading (or hot loading) is a practice that got popular in the world of
    purely functional user interfaces in libraries such as Om (used with ClojureScript)
    and React.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 热重载（或热加载）是在纯函数式用户界面的世界中变得流行的一种实践，例如在ClojureScript中使用的Om和React中。
- en: 'When developing a SPA, it is quite annoying to refresh your browser after each
    small change of a style, view, or even a component. That''s why a couple of years
    ago, a tool was developed called **livereload**. Livereload watches the files
    of our application, and when it detects a change in any of them, it sends a message
    to the browser to refresh the page. Usually, the connection established between
    the livereload server and the client is through WebSockets, since the server needs
    to send push notifications. Although this tool works great in some cases, it has
    one big disadvantage: once the page is refreshed, all of the state collected during
    the developer''s interaction will be lost.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发单页应用程序时，每次对样式、视图甚至组件进行小的更改后都需要刷新浏览器是非常恼人的。这就是为什么几年前开发了一个叫做**livereload**的工具。Livereload监视我们应用程序的文件，当它检测到任何文件的变化时，就会发送消息给浏览器以刷新页面。通常，livereload服务器和客户端之间建立的连接是通过WebSockets，因为服务器需要发送推送通知。尽管这个工具在某些情况下效果很好，但它有一个很大的缺点：一旦页面刷新，开发者交互期间收集的所有状态都将丢失。
- en: For instance, imagine a scenario where you're working on an application with
    a complex view. You navigate through a few pages, fill in forms, and set the values
    to input fields, and then, unexpectedly, you find an issue. You go to your text
    editor or IDE and fix the issue; the livereload server detects a change in your
    project's root and sends a notification to the browser in order to refresh the
    page. Now, you're back to the initial state of the application and you need to
    go through all these steps in order to reach the same point before the refresh.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，想象一种情况，你正在开发一个视图复杂的应用程序。你浏览了几个页面，填写表单，设置输入字段的值，然后突然发现了一个问题。你去你的文本编辑器或者IDE修复了这个问题；livereload服务器检测到了项目根目录的变化，并发送通知给浏览器以刷新页面。现在，你回到了应用程序的初始状态，需要经过所有这些步骤才能达到刷新之前的同样状态。
- en: In contrast to livereloading, in most cases, hot reloading can eliminate the
    state lost. Let's take a brief look at how it works.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与livereloading相比，在大多数情况下，热重载可以消除状态丢失。让我们简要看一下它是如何工作的。
- en: 'A typical implementation of a hot reloader has two main modules: a client and
    a server. In contrast to the server in livereloading, the hot reloader server
    not only watches the file system for changes, but also takes the content of the
    changed file and sends it to the browser. Once the browser receives the message
    sent by the server, it can swap the previous implementation of the changed unit
    with the new one. After this, the view affected by the change can be rerendered
    in order to visually reflect the change. Since the application doesn''t lose its
    state, we can continue from the point we''ve reached with the new version of the
    changed code unit.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 热重载的典型实现有两个主要模块：客户端和服务器。与livereloading中的服务器相比，热重载服务器不仅监视文件系统的变化，还会获取变化文件的内容并发送给浏览器。一旦浏览器接收到服务器发送的消息，它就可以用新的实现替换之前的实现。之后，受到变化影响的视图可以重新渲染以直观地反映变化。由于应用程序不会丢失其状态，我们可以从已经达到的点继续使用变化后的代码单元的新版本。
- en: Unfortunately, it is not always possible to dynamically swap the implementations
    of all your components using this strategy. If you update a piece of code that
    holds that holds application state, you may need to refresh the page manually.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并不总是可能使用这种策略动态交换所有组件的实现。如果你更新了保存应用程序状态的代码片段，可能需要手动刷新页面。
- en: Hot reloading in Angular 2
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular 2中的热重载
- en: At the time of writing, there is a working prototype of Angular 2 hot reloader
    that can be tested with the angular2-seed described in the *Angular 2 quick starters*
    section. The project is in active development, so there are a lot of improvements
    on the roadmap. But it already provides its core functionality, which can ease
    the development experience significantly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，有一个可以在*Angular 2快速入门*部分中使用的angular2-seed中测试的Angular 2热重载器的工作原型。该项目正在积极开发中，因此在路线图上有很多改进。但它已经提供了核心功能，可以显著简化开发体验。
- en: Bootstrapping a project with angular-cli
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用angular-cli引导项目
- en: During AngularConnect 2015, Brad Green and Igor Minar, part of the Angular team,
    announced `angular-cli`—a CLI (command-line interface) tool to ease starting and
    managing Angular 2 applications. For those who have used Ruby on Rails, the idea
    behind the CLI tool might be familiar. The basic purpose of the tool is to allow
    the quick bootstrapping of new projects and scaffolding of new directives, components,
    pipes, and services.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularConnect 2015期间，Angular团队的Brad Green和Igor Minar宣布了`angular-cli`——一个CLI（命令行界面）工具，用于简化启动和管理Angular
    2应用程序。对于那些使用过Ruby on Rails的人来说，CLI工具背后的想法可能很熟悉。该工具的基本目的是允许快速引导新项目和搭建新指令、组件、管道和服务。
- en: At the time of writing, the tool is still in the early stage of development,
    so we'll demonstrate only its basic usage.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，该工具仍处于早期开发阶段，因此我们只会演示其基本用法。
- en: Using angular-cli
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用angular-cli
- en: 'In order to install the CLI tool, run the following command in your terminal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装CLI工具，请在终端中运行以下命令：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Right after this, the global `ng` command will appear in your `$PATH`. For
    creating a new Angular 2 project, use the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，全局的`ng`命令将出现在您的`$PATH`中。要创建一个新的Angular 2项目，请使用以下命令：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding commands will do the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将执行以下操作：
- en: Create a new Angular 2 project and install all of its node.js dependencies.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Angular 2项目并安装其所有node.js依赖项。
- en: Enter your project's directory.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入您的项目目录。
- en: Start a development web server that will let you open the application you just
    created in your web browser.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动开发Web服务器，让您在Web浏览器中打开刚创建的应用程序。
- en: For further reading, take a look at the project's repository located at [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步阅读，请查看项目的存储库，位于[https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)。
- en: Angular 2 quick starters
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2快速入门
- en: Although Angular 2 CLI is going to be amazing, at the moment of this writing,
    it is still at a very early stage of development. It's build-tool agnostic, which
    means that it doesn't provide any build system. Luckily, there are a lot of starter
    projects developed by the community that can provide a great starting point for
    our next Angular 2 project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Angular 2 CLI将会是令人惊叹的，但在撰写本文时，它仍处于早期开发阶段。它是构建工具不可知的，这意味着它不提供任何构建系统。幸运的是，社区开发了许多起始项目，可以为我们的下一个Angular
    2项目提供一个很好的起点。
- en: Angular 2 seed
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 seed
- en: 'In case you enjoy Gulp and static typing, you can give a try to the angular2-seed
    project. It is hosted on GitHub at the following URL: [https://github.com/mgechev/angular2-seed](https://github.com/mgechev/angular2-seed).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢Gulp和静态类型，可以尝试angular2-seed项目。它托管在GitHub上的以下URL：[https://github.com/mgechev/angular2-seed](https://github.com/mgechev/angular2-seed)。
- en: 'The Angular 2 seed provides the following key features:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 seed提供以下关键功能：
- en: Advanced, ready-to-go, easy-to-extend, modular, and statically typed build system
    using Gulp.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gulp构建的高级、即插即用、易于扩展、模块化和静态类型的构建系统。
- en: Production and development builds.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产和开发构建。
- en: Sample unit tests with Jasmine and Karma.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine和Karma进行示例单元测试。
- en: End-to-end tests with Protractor.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Protractor进行端到端测试。
- en: A development server with Livereload.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Livereload的开发服务器。
- en: Experimental hot reloading support.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验性的热重载支持。
- en: Following the best practices for your applications' and files' organization.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循应用程序和文件组织的最佳实践。
- en: Manager for the TypeScript-related type definitions.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与TypeScript相关的类型定义的管理器。
- en: The code distributed with the book is based on this seed project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该书中分发的代码基于这个种子项目。
- en: 'For angular2-seed, you need to have node.js, npm, and Git installed, and you
    need to run the following list of commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于angular2-seed，您需要安装node.js、npm和Git，并且需要运行以下命令列表：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After you run these commands, your browser will be automatically opened with
    the home page of the seed. On the change of any of the TypeScript files, the code
    will be automatically transpiled to JavaScript and your browser will be refreshed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令后，您的浏览器将自动打开种子的主页。在任何TypeScript文件发生更改时，代码将自动转译为JavaScript，并且浏览器将被刷新。
- en: The production build is configurable, but by default, it produces a single bundle
    that contains a minified version of the application and all the referenced libraries.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 生产构建是可配置的，默认情况下，它会生成一个包含应用程序的缩小版本和所有引用库的单个捆绑包。
- en: Angular 2 Webpack starter
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 Webpack起始程序
- en: 'If you prefer declarative and minimalistic builds with Webpack, you can use
    *angular2-webpack-starter*. It is a starter project developed by *AngularClass*
    and hosted on GitHub. You can find it at the following URL: [https://github.com/AngularClass/angular2-webpack-starter](https://github.com/AngularClass/angular2-webpack-starter).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢使用Webpack进行声明性和极简主义构建，您可以使用*angular2-webpack-starter*。这是一个由*AngularClass*开发并托管在GitHub上的起始项目。您可以在以下URL找到它：[https://github.com/AngularClass/angular2-webpack-starter](https://github.com/AngularClass/angular2-webpack-starter)。
- en: 'This starter provides the following features:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该起始程序提供以下功能：
- en: The best practices in file and application organization for Angular 2.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 2文件和应用程序组织的最佳实践。
- en: Ready-to-go build system using Webpack for working with TypeScript.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webpack构建系统，用于处理TypeScript。
- en: Testing Angular 2 code with Jasmine and Karma.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine和Karma测试Angular 2代码。
- en: Coverage with Istanbul and Karma.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istanbul和Karma进行覆盖。
- en: End-to-end Angular 2 code using Protractor.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Protractor进行端到端的Angular 2代码。
- en: Type manager with Typings.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Typings的类型管理器。
- en: 'In order to give it a try, you need to have node.js, npm, and git installed,
    and you need to run the following commands:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试一下，您需要安装node.js、npm和git，并且需要运行以下命令：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this book by introducing the reasons behind the development of Angular
    2, which was followed by a conceptual overview that gave us a general idea about
    the building blocks that the framework provides for application development. In
    the next step, we did a TypeScript crash course that prepared us for [Chapter
    4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting
    Started with Angular 2 Components and Directives"), *Getting Started with Angular
    2 Components and Directives* where we went deep into Angular's directives, components,
    and change detection.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过介绍开发Angular 2的原因开始了这本书，接着是一个概念概述，让我们对框架为应用程序开发提供的构建块有了一个大致的了解。接下来，我们进行了一个TypeScript速成课程，为我们准备了[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。开始使用Angular 2组件和指令")，*开始使用Angular 2组件和指令*，在这里我们深入研究了Angular的指令、组件和变更检测。
- en: In [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2* we explained the dependency injection mechanism and saw how we can manage the
    relations between the different components by using it. The next chapters explained
    to us how we can build forms and pipes, and take advantage of Angular 2's component-based
    router.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582 "第5章.
    Angular 2中的依赖注入")中，我们解释了Angular 2中的依赖注入机制，并看到了我们如何可以通过使用它来管理不同组件之间的关系。接下来的章节向我们解释了如何构建表单和管道，并利用Angular
    2的基于组件的路由。
- en: By completing the current chapter, we finished our journey into the framework.
    At the moment of this writing, the design decisions and the ideas behind Angular
    2's core are solid and finalized. Although the framework is still brand new, in
    the past couple of months its ecosystem reached a level that we can develop production-ready,
    high-performance, SEO-friendly applications, and on top of this, have a great
    development experience exploiting static typing and hot reloading.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成当前章节，我们完成了对这个框架的探索。在撰写本文时，Angular 2核心背后的设计决策和思想已经稳固并最终确定。尽管这个框架仍然是全新的，但在过去几个月里，它的生态系统已经达到了一个水平，使我们能够开发出生产就绪、高性能、SEO友好的应用，并且在此基础上，利用静态类型和热重载获得良好的开发体验。
