- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hooks: Bring State and Other Features into Function Components'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hooks were introduced in function components to reap the benefits of React features
    without writing any classes and life cycle methods. Most developers use Redux,
    Recoil, Mobx, and other third-party libraries to manage the global state in large-scale
    applications. But when you use React Hooks such as `useContext` and `useReducer`
    together, it becomes a better alternative for external state management. Hooks
    are much easier to use than complex external libraries that involve excessive
    amounts of boilerplate code, repetitive files, and folders across the application.
    React also provides numerous other built-in Hooks that can be useful for various
    use cases in React applications. If there is no specific built-in Hook available
    to handle your use case, you can create your own Hook to fulfill your business
    needs. Some common use cases (or cross-cutting concerns) for Hooks are authentication,
    logging, caching, data fetching, and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to React Hooks, their benefits, and
    various built-in Hooks that add React features to function components. The built-in
    Hooks will be explained in depth through examples to understand their usage in
    React applications. Additionally, you will gain the knowledge and confidence to
    answer questions related to third-party Hooks, create your own Hooks, and troubleshoot
    Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Hooks and their purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local state management using Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global state management using Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing side effects in React applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing DOM nodes using Ref Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the application performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about popular third-party Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting and debugging Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Hooks and their purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, React was mainly used with class components, but over the years the
    components became complex with the usage of various patterns to reuse the component
    logic. Subsequently, Hooks were introduced to simplify the code without writing
    any patterns, such as render props and **higher-order components** (**HOCs**).
    Since Hooks play an important role in building React applications nowadays, you
    can expect a couple of questions on Hooks in a React interview. This section will
    give you detailed answers about what Hooks are and what their purpose is.
  prefs: []
  type: TYPE_NORMAL
- en: What are Hooks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hooks are simple JavaScript functions that allow components to use the local
    state and execute side effects (or cross-cutting concerns) and other React features
    without writing classes. The Hooks API has been introduced in React 16.8 to isolate
    the stateful logic from the components.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the Hooks feature is a way for your function components to *Hook*
    into React’s life cycle and state.
  prefs: []
  type: TYPE_NORMAL
- en: What is the motivation behind Hooks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hooks can solve a wide variety of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Difficulty in reusing stateful logic between components*: By default, React
    didn’t provide a way to reuse the component logic. Programming patterns such as
    **render props** and **HOCs** tried to solve this problem. But those patterns
    require modifying the structure of the component hierarchy, which makes the application
    cumbersome with the several layers of wrappers and makes it harder to follow the
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, Hooks were introduced to separate stateful logic from the components
    without modifying the component hierarchy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Difficulty in understanding the complex components*: As an application grows,
    the components become much more complex with a full set of stateful logic and
    side effects. The life cycle methods become occupied with a mix of unrelated logic
    such as data fetching, adding event listeners, or removing event listeners in
    one place. For example, the `componentDidMount` life cycle method can perform
    data fetching for the component and add the event listeners too. At the same time,
    the related event listener logic, such as cleanup, needs to be added in the `componentWillUnmount`
    life cycle method. Ultimately, it becomes difficult to split the larger components
    into small components and, at the same time, difficult to test them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooks can split the larger components into smaller functions with the related
    piece of code rather than splitting the code based on the life cycle methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Confusion created by classes*: Classes are not specific to React, but they
    belong to JavaScript. If you would like to work on class components, first you
    should have a clear idea about **the** keyword behavior called **this**, which
    is different from that in other languages. Also, if you are not familiar with
    using ES2022 public class fields syntax, you need to remember about binding event
    listeners in the constructor. All these concepts created a lot of confusion among
    the developers about the proper usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooks are helpful for creating React features without writing the classes and
    to avoid confusion within the developer community.
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe the rules of Hook usage?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two main rules to be followed while using Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useState` and `useEffect` Hooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Call Hooks from React functions only**: You shouldn’t call Hooks from regular
    JavaScript functions. Instead, you can call them from either React function components
    or custom Hooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `eslint` plugin named `eslint-plugin-react-Hooks` ([https://www.npmjs.com/package/eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks))
    can be used to enforce the two rules described in the *Can you describe the rules
    of Hook* *usage?* section.
  prefs: []
  type: TYPE_NORMAL
- en: Can I use Hooks inside class components?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You cannot write Hooks inside class components. In other words, Hooks have been
    created for the function components only. However, you can mix class components,
    and function components with Hooks in a single component tree without causing
    any problems.
  prefs: []
  type: TYPE_NORMAL
- en: React components hold the data and keep track of data changes using an updatable
    structure called the **state**. In real-world applications, most components use
    the state to process and display the data in their UI. In the next section, we
    will be covering questions and their answers related to local state management
    using state Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Local state management using Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two Hooks to achieve local state management inside React applications.
    The first Hook, named `useState`, can be used for simple state transformations,
    and the other Hook, `useReducer`, is used for complex state logic. Basically,
    `useState` uses `useReducer` internally. This means that the entire component
    state can be managed through the `useReducer` Hook itself. Since the state is
    a core building block of a React component, every developer should have a clear
    idea about managing the state using Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: What is the useState Hook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useState` Hook is used to add the state to a function component. This
    is one of the most used built-in Hooks from React. This Hook takes the initial
    state as an argument and the same initial state can be either a value or a function
    type (i.e., initializer function). If the initial state is derived from an expensive
    computation, it is suggested to use the initializer function, which will be executed
    only on the initial render. The `useState` Hook returns an array that contains
    two values: the state variable and the setter function to update the state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntactic representation of `useState` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take an example of a counter component that preserves the state of a
    counter using the `useState` Hook. The setter function is used to update the `count`
    state variable and re-render the UI for any changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Upon clicking the counter button each time, the `count` state variable will
    be incremented by one and the respective UI updated with the latest state variable's
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The state setter function doesn’t update the current state in the already executing
    code. It will be available only in the next render.
  prefs: []
  type: TYPE_NORMAL
- en: Is it always recommended to use an updater function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might hear about the recommendation from the developer community to always
    use an updater function to update the state if the new state is calculated from
    the previous state. This rule is helpful to avoid an unpredictable state after
    doing some state calculation logic. Even though there is no harm in following
    this rule, it is not always necessary. In most cases, React will update the state
    variable before the next event happens. That is, there is no risk of stale data
    for the state in the beginning of the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you are doing multiple state updates in the same event handler, then
    it is suggested to use an updater function to receive the expected data result.
    The usage of an updater function inside an event handler is coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `a => a + 1` is an updater function. React puts your updater functions
    in a queue and as a result, updates on same state variables are batched. During
    the next render, React will call them in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: What is a useReducer Hook? How do you use it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useReducer` Hook is an alternative to the `useState` Hook. It is used to
    separate the custom state logic (e.g., add, update, and delete items of a state)
    from the rendering logic. In other words, it is helpful for extracting the state
    management out of the component.
  prefs: []
  type: TYPE_NORMAL
- en: This Hook accepts three arguments. The first argument is a reducer function
    that specifies how to update the state, the second argument is for the initial
    state, and the third argument is an optional initializer function to determine
    the initial state. In contrast, `useState` just accepts the initial state.
  prefs: []
  type: TYPE_NORMAL
- en: The `useReducer` Hook returns an array with two values, current state and dispatch
    function, which is used to modify the state and trigger re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand the usage of this Hook with a counter example. Here, you can
    update the counter state value with increment, decrement, and reset actions using
    a reducer function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: React will save the initial state once and ignore it for the next renders. So,
    you need to avoid recreating the initial state for each render if you are deriving
    the state through a function call. Instead, you can use an initializer function
    as a third argument for the reducer function.
  prefs: []
  type: TYPE_NORMAL
- en: In the third argument in the preceding code, the `init` function has been used
    to process the initial state based on a default value mentioned as the second
    argument within the Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important phases of the preceding code are described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When any of the button-click events are triggered, the respective event handler
    will be dispatched with an action to the reducer function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thereafter, the reducer function will update the state to a new state based
    on the requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state update will trigger the component to re-render to update the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The flow diagram in *Figure 3**.1* depicts the `useReducer` Hook’s behavior
    in a step-by-step manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Behavior of the useReducer Hook](img/Figure_03.01_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Behavior of the useReducer Hook'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `useReducer` Hook won’t re-render the children if there is no change in
    state compared to the previous state.
  prefs: []
  type: TYPE_NORMAL
- en: When should you use the useReducer Hook over the useState Hook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both the `useReducer` and `useState` Hooks are helpful in managing the application
    state, but the `useReducer` Hook provides a well-controlled and powerful state
    management solution for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The `useReducer` Hook is preferred over `useState` when you need to manage complex
    state logic. For example, when the state contains multiple nested values or the
    next state depends on the previous one, the `useReducer` Hook is a better choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `useReducer` Hook can handle multiple actions in a single function rather
    than creating separate functions for each action using the `useState` Hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `useReducer` Hook is also helpful in optimizing the performance of components
    that trigger deep or nested updates, because you can pass down a dispatch function
    of the `useReducer` Hook at any nested level via context instead of passing callbacks
    to every level of a component tree. In other words, it helps in avoiding the prop
    drilling issue mentioned in [*Chapter 2*](B18603_02.xhtml#_idTextAnchor055). Moreover,
    the dispatch function won’t change between re-renders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since `useState` itself is derived from the `useReducer` Hook under the hood,
    you can cover all the state use cases with `useReducer`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to share the component state with multiple child components that
    exist in the deeper level of a component tree, it is preferred to use the in-built
    context Hook from React. This Hook is mainly used to maintain application-wide
    data, which is known as global state management.
  prefs: []
  type: TYPE_NORMAL
- en: Global state management using Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useContext` Hook is commonly used along with the `useState` Hook for global
    state management. The major advantage of the `useContext` Hook is that it solves
    the prop drilling issue.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed common use cases of the `useContext` Hook were already explained in
    [*Chapter 2*](B18603_02.xhtml#_idTextAnchor055). Hence, this section will mainly
    focus on specific use case questions related to global state management using
    the `useContext` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: How do you override context for a specific part of the component tree?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you may need to override the context with a different value for a
    certain part of the component tree. It is possible to override the context value
    by wrapping that part in a provider with a different value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following code applies a blue background to all the pages
    except for the contact page, where a white background will be applied using a
    context provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is no restriction on the nesting level or number of times you override
    the context using a provider.
  prefs: []
  type: TYPE_NORMAL
- en: What would the context value be for no matching provider?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there is no matching provider above the calling component of the `useContext`
    Hook, the default value mentioned in the context creation will be returned – that
    is, the default value used in `createContext(defaultValue)`.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify a default value, you can avoid unexpected errors on the page
    for any missing providers in the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: In class components, the side effects are handled in different life cycle methods
    such as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`
    based on the requirement. On the other hand, in function components, effect Hooks
    simplify the handling of side effects based on rendering in a single place. The
    next section will cover frequently asked questions about performing side effects
    in React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Performing side effects in React applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Effects are an escape hatch in React programming. React provides a few effect
    Hooks that are used to implement side effects such as data fetching, subscriptions,
    timers, logging, DOM manipulations, and so on within function components. These
    Hooks should be used only when you are synchronizing with external systems. There
    are three types of Hooks available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**useEffect**: This is a frequently used Hook to connect a component to an
    external system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useEffect` Hook except that it fires before the browser repaints the screen
    to measure the layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**useInsertionEffect**: This Hook fires before React makes changes to the DOM,
    such as adding dynamic CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s thoroughly discuss the various effect Hooks and their features to answer
    the questions asked in the interview.
  prefs: []
  type: TYPE_NORMAL
- en: How do reactive dependencies impact the logic inside the useEffect Hook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useEffect` Hook accepts an optional dependencies argument that accepts
    an array of reactive values. You cannot choose dependencies for your effect and
    every reactive value should be declared as a dependency to avoid any kinds of
    bugs. There are different scenarios for passing the reactive dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the dependency array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you pass the reactive values in a dependency array, the effect should run
    the logic after the initial render and also after each re-render with the changed
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of passing name and status reactive dependencies
    to understand the syntax of `useEffect` with an array of dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Passing the empty dependency array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your effect doesn’t use any reactive values, it only runs after the initial
    render. In this case, the effect Hook looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Not passing the dependency array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you skip passing the dependency array, itself the effect runs after every
    re-render of your component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: React will compare each reactive value from the dependency array with its previous
    value using `Object.is` comparison to verify the changes.
  prefs: []
  type: TYPE_NORMAL
- en: How often are setup and cleanup functions invoked inside the useEffect Hook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, effects should have a cleanup function to clear or undo the
    changes created by their respective setup code. React invokes setup and cleanup
    functions in the following different phases of the component life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mounting**: The logic inside the setup function runs whenever the component
    is added to the DOM or view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Re-rendering**: After every re-rendering of a component along with its dependency
    change, the cleanup (if it is defined) and setup functions will be invoked in
    an order. Here, the cleanup function runs with the old props and state, and the
    setup code runs with the latest props and state thereafter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unmounting**: The cleanup code runs one final time after the component is
    removed from the DOM or view. This cleanup function helps to avoid unwanted behaviors
    such as memory leaks and to improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If strict mode is turned on in your React application, there will be an extra
    development-only **setup and cleanup cycle** before the first actual setup call.
    This is to ensure the cleanup logic mirrors the setup logic to avoid any discrepancies
    with the setup code.
  prefs: []
  type: TYPE_NORMAL
- en: When should you remove an object or a function from dependencies?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There might be a situation where your effect might re-run more frequently than
    necessary if that effect depends on an object or a function created during rendering.
    This is because the object or function created is different for every render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand this concept in a better way using an example. The following
    is an example of fetching a list of users inside the `useEffect` Hook based on
    the `Url` and `name` query parameter dependencies. Here, the query object has
    been created during rendering to build the absolute URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `userQueryOptions` object has been recreated for
    every re-rendering due to the `message` state changes. Also, this `message` data
    is not related to reactive elements inside the effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This issue can be fixed by moving the object inside the effect and replacing
    the object dependency with a `name` string, because `name` is the only reactive
    value the effect depends on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, you can avoid creating the function during the rendering phase
    by moving it inside the effect Hook. After that, you can replace the function
    dependency with the direct reactive dependency value.
  prefs: []
  type: TYPE_NORMAL
- en: What is the useLayoutEffect Hook? How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useLayoutEffect` Hook is a special type of effect Hook that is invoked
    before the browser repaints the screen. This Hook is mainly used for scenarios
    where the component flickers when the state is updated. Imagine a pop-over component
    on the web page. The component first needs to determine the position of the element
    in the viewport before rendering it correctly on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main purpose of the `useLayoutEffect` Hook is to provide the layout information
    to the component for rendering. It works in three simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Render the initial content without layout information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the layout size before the browser repaints the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-render the component using the correct layout information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: The component is going to be rendered twice and will block the browser before
    it repaints the screen. This impacts the application performance. Therefore, it
    is recommended to use the `useLayoutEffect` Hook only where it is required.
  prefs: []
  type: TYPE_NORMAL
- en: Since effects will run after every render, one of the major ways to improve
    performance in React applications is to avoid unnecessary re-renders. There are
    a few in-built Hooks created in React to optimize the performance. Let’s dive
    deep into those details in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the application performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The performance optimizations have a massive impact on the customer experience.
    Even though React applications have a very fast UI by default, there might be
    performance issues when the size of the application increases. This section will
    focus on the questions related to performance optimization Hooks, which you could
    expect to be asked by interviewers to gauge your skill from a broader perspective.
  prefs: []
  type: TYPE_NORMAL
- en: What is memoization? How can it be implemented in React?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Memoization** is an optimization technique for speeding up web applications
    by caching the results of expensive function calls. It returns the cached result
    when the same input arguments have been passed again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, this optimization can be implemented through two Hooks: `useMemo`
    and `useCallback`. These Hooks improve the performance, skipping the unnecessary
    re-rendering by returning the cached result when the same input is given.'
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe the useMemo() Hook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useMemo()` Hook is used to cache the result of an expensive calculation
    between re-renders. The syntax of this Hook looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This Hook returns the value of the expensive calculation by accepting two arguments.
    The first argument is a function to do the expensive calculation, and the second
    is an array of dependencies that are reactive values used in the calculation.
    In other words, the cached result (or stored value from the last render) will
    be returned when there are no changes to the dependency values. Otherwise, the
    calculation will be performed again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand this concept with an example. Consider a factorial calculation
    function of a number and apply the `useMemo` Hook around it. The component also
    performs an increment action that is independent of the calculation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if you increment the counter value, there won’t be any
    re-rendering related to the factorial function because the respective reactive
    number was not updated. That is, the factorial function will only be called where
    there is a change in the input number, but not when the counter value is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: What are the possible use cases of the useMemo() Hook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memoization is helpful in optimizing the application performance, and some of
    the developers even think that there is no harm in memoizing almost all the components
    as much as possible. However, this technique is unnecessary for simple calculations
    within the functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few common cases where memoization is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: When there are expensive calculations, such as sorting, filtering, changing
    the format, and so on while rendering the content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are passing a prop to a component wrapped within the `useMemo` Hook
    and want to skip re-renderings when there is no change in the prop – that is,
    when pure components can be wrapped within `useMemo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the value passing to the wrapped component has been used as a dependency
    of some other Hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **profiler** section of **React DevTools** will be helpful in identifying
    the components that are laggy and require memoization to add.
  prefs: []
  type: TYPE_NORMAL
- en: What are common mistakes with the usage of useMemo? How do you rectify them?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The usage of the `useMemo` Hook is quite straightforward, and this Hook might
    be used extensively to optimize the rendering performance. However, you need to
    be careful with some of the following common mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to return an object from the `useMemo` Hook, then either wrap it
    with parentheses or write an explicit return statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following `useMemo` Hook returns an undefined value because
    the opening brace ({) is part of an arrow function but not the object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This can be fixed by an explicit return statement for the object, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you forget to specify the dependencies, then the calculation will re-render
    every time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The reactive values used in the calculation are to be passed in the dependencies
    array to avoid unnecessary renders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You shouldn’t call `useMemo` inside loops. Instead, wrap it or extract it under
    a new component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This can be solved by extracting the `useMemo` calculation inside a child component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The aforementioned points can be treated as best practices while working with
    the `useMemo` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: When should you use the useCallback Hook instead of the useMemo Hook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a top-level component re-renders, by default, React re-renders all its
    children recursively. This situation will impact the performance of the application
    if the child component has heavy calculation. In this case, the child component
    needs to be optimized using the Memo API or the `useMemo` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you pass the callback function as a prop to the child component,
    React will always re-render the children because either the function definition
    or arrow function is treated as a new function every time re-rendering occurs.
    This defeats the purpose of memoization. In this case, `useCallback` is helpful
    in optimizing the performance.
  prefs: []
  type: TYPE_NORMAL
- en: The `useCallback` Hook is like the `useMemo` Hook, but it caches the callback
    function instead of a value. You can still use the `useMemo` Hook but the calculation
    function would have to return another function; that is, it requires an extra
    nested function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss this concept with an example that contains `TaxCalculation` as
    the parent component and `TaxPayer` as the child component. In the child component,
    you need to skip re-rendering considering when the same props are sent and re-rendering
    is slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To skip re-rendering, first, you need to wrap the child component (`TaxPayer`)
    with the memo function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the parent component re-renders with a change in the `income` prop, then
    this change leads to the re-rendering of the child component as well. This won’t
    be a big problem when the child component doesn’t have any big calculations and
    changes from the `income` prop are minimal.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you pass a callback function to a child component as a prop, it
    creates a new function every time. This specific case should be avoided all the
    time, irrespective of the performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'To skip the re-render because of a new prop every time, let’s apply the `useCallback`
    Hook for the `handleSubmit` callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the callback function is going to be memoized until or
    unless there is a change in dependency reactive values.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the Ref API that exists in class components, some Hooks have been
    created in function components especially to interact with DOM nodes. The next
    section talks about important concepts related to accessing the DOM nodes using
    Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing DOM nodes using ref Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refs are useful when you need to work with external systems (or non-React systems)
    such as built-in browser APIs. There are two built-in ref Hooks available in function
    components. The `useRef` Hook is used to declare a ref to hold any kind of value
    but is mainly used for DOM nodes. `useImperativeHandle` is used to expose the
    customized ref with only the required methods.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that an introduction to refs has already been covered in [*Chapter
    2*](B18603_02.xhtml#_idTextAnchor055). In this section, we will go beyond what
    we have already discussed about refs in [*Chapter 2*](B18603_02.xhtml#_idTextAnchor055).
  prefs: []
  type: TYPE_NORMAL
- en: How do you avoid recreating the Ref contents?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useRef` Hook accepts the initial value (or default value) as an argument,
    like the `useState` Hook. The declaration of this Hook should be placed at the
    top of the enclosed component.
  prefs: []
  type: TYPE_NORMAL
- en: React saves this initial value at the first render and ignores it for the next
    renders, but if you create an expensive object for the initial value of the ref,
    it might be called for every render unnecessarily. This will impact the performance
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of the initial ref value and how the ref content is recreated
    can be explained in a better way with the use of the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `CreateBlogArticle()` function is always invoked
    to create the expensive object, even though React ignores this object from the
    second render onward.
  prefs: []
  type: TYPE_NORMAL
- en: 'This issue can be resolved by restricting the invocation of the `CreateBlogArticle()`
    function for the subsequent renders, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now the blog article object is calculated only once during the initial rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to access a ref in the render method?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, you can access the current value of a ref inside the render method, but
    it is not recommended to read or write the `ref.current` value during the render
    process. This is because the ref value appearing on the screen may not be updated
    for any events by knowing the fact that changing a ref doesn’t trigger re-rendering,
    unlike the state variable.
  prefs: []
  type: TYPE_NORMAL
- en: How do you expose a subset of methods from a ref instance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useImperativeHandle` Hook is used to expose customized methods or only
    a subset of existing methods of a DOM node from a child component to a parent
    component. This is useful to restrict a parent ref to access only certain functions
    or properties without giving access to the entire ref. The common use case is
    creating a component to share it under a library and consumers can access only
    the exposed API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you are planning to create a dialog component and want to share some
    basic features of the dialog in some top-level parent component. In this case,
    you can expose `open`, `close`, and `reset` methods inside child component instead
    of giving access to the entire dialog DOM node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The component which uses the `useImperativeHandle` Hook needs to be wrapped
    with forwardRef and the ref received as a second argument from the `forwardRef`
    render function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more built-in Hooks, such as `useId`, `useDeferred`, `useTransition`,
    and `useSyncExternalStore`, that are not covered because of their minimal usage.
    Let’s learn about them quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useId`: This Hook is used to generate unique IDs for the HTML accessibility
    attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useDeferred`: This Hook is used to defer updating a part of the UI until the
    latest data is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useTransition`: This Hook is helpful to improve user responsiveness by marking
    some of the state modifications as low-priority'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useSyncExternalStore`: This Hook is used to subscribe to an external data
    store that exists outside the React system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several built-in Hooks provided by React, but you can go beyond the
    usage of these Hooks and use third-party Hooks created by the React community
    to cover specific use cases based on your business needs. In the next section,
    we will cover questions related to third-party Hooks and their respective answers.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about popular third-party Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Hooks API is quite popular among the developer community, and built-in Hooks
    have existed since 2019\. The developers tried to create many third-party Hooks,
    such as `useImmer`, `useFetch`, `useDebounce`, `useForm`, `useLocalStorage`, Redux
    Hooks, and so on, to solve common use cases observed in web development. If you
    would like to master the Hooks concepts then you should have a good understanding
    of third-party Hooks and how they are useful to solve some common problems.
  prefs: []
  type: TYPE_NORMAL
- en: What is the useImmer Hook? What is its purpose?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useImmer` Hook is just like the `useState` Hook but it provides advantages
    while managing the complex state with nested levels of data. It updates the state
    as if it were directly mutable, similar to regular JavaScript. This Hook is based
    on the Immer library by creating a new copy of the state that can be mutated.
  prefs: []
  type: TYPE_NORMAL
- en: This Hook can be installed through the `use-immer` npm library. Like `useState`,
    it returns a tuple. The first value of the tuple is the current state, and the
    second is the updater function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of the `UserProfile` component and update the address
    details directly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, `Immer` creates a temporary draft object and all the changes
    are applied to it. Once all the mutations are completed, `Immer` will produce
    the next state object.
  prefs: []
  type: TYPE_NORMAL
- en: If your use case is not fulfilled by built-in Hooks or by any third-party Hook,
    then you can build your own Hook to provide the solution for your needs. After
    the next section, you will be in a position to answer questions related to custom
    Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though React provides some built-in Hooks such as `useState`, `useEffect`,
    `useContext`, and so on for common use cases, you may sometimes need to use Hooks
    for specific requirements that cannot be solved by built-in Hooks or third-party
    libraries. By the end of this section, you will be able to answer questions related
    to custom Hooks and their purpose, and how to avoid traditional approaches to
    share the component logic.
  prefs: []
  type: TYPE_NORMAL
- en: What are custom Hooks? How do you create them?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React comes with several built-in Hooks, but it won’t restrict you from using
    Hooks for limited scenarios. It is also possible to create your own Hooks by extracting
    the component logic into separate reusable functions known as **custom Hooks**.
    These Hooks are helpful in hiding the complex logic from the components. They
    cover a wide range of use cases such as data fetching, form handling, online or
    offline status subscriptions, connecting to a chat room, animations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of custom Hooks and their usage can be explained in a better way
    with the demonstration of a real-time example. Let’s consider a blogging site
    application where you list all the posts of a particular user and at the same
    time display the comments on a particular post. Here, you need to create two components
    named **Posts** and **Comments**. Both of these components need to fetch the data
    from the server based on a given URL with an optional query parameter. Once the
    response is received, both the components display the data on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of having duplicated logic related to data fetching, loading, error
    handling, and so on in both components, the code can be moved to a separate reusable
    custom Hook prefixed with the word `use`. The data fetching Hook can be created
    with the name `useFetchData` inside the `useFetchData.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, the above custom Hook can be used in consumer components created
    as a part of the `Posts.jsx` files and `Comments.jsx`. The usage in the **Posts**
    component would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, you can reuse `useFetchData` in the **Comments** component
    as well. After these changes, the **Posts** and **Comments** components’ code
    became much simpler, more concise, and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of custom Hooks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main advantage of using custom Hooks is code reusability without writing
    the duplicated logic in many components. There are a few other advantages as well
    to considering custom Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability**: It is easier to maintain code with custom Hooks. In the
    future, if you need to change the logic of the Hook, you only need to change the
    code in one place without disturbing other parts of the code – that is, components
    or files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability**: The application code becomes cleaner and more readable using
    custom Hooks instead of wrapping layers of HOCs, providers and consumers, and
    render props around the actual presentation components shown in the UI. Moreover,
    the component code becomes much cleaner by moving out specific component logic
    into separate Hooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: You need to write separate tests for test containers and presentation
    components in React applications. This is challenging especially for integration
    tests if your containers use many HOCs. The complexity increases because you need
    to test the containers and the components together to perform integration tests.
    This issue can be eliminated with custom Hooks as they allow you to combine containers
    and components into a single component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, it is easier to write unit tests and mock Hooks compared to HOCs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Community-driven Hooks**: The React community is already popular and has
    created many Hooks for their specific use cases. The recommended approach is first
    to check whether the Hook you are looking for has already been created by someone
    or not before going to create your own Hook. Some community-driven Hooks are available
    at [https://usehooks.com/](https://usehooks.com/) and [https://github.com/imbhargav5/rooks](https://github.com/imbhargav5/rooks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages listed inspire many React developers to create custom Hooks for
    unique features encountered in their React applications. If any third-party open
    source library has already provided the Hook to cover your specific scenario,
    it is suggested to reuse the same Hook instead of reinventing the wheel by building
    a custom Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Should you still consider using render props and HOCs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both render props and HOCs are traditional advanced patterns used in the React
    ecosystem to share the component state logic between components. However, Hooks
    are somewhat simpler and sufficient to cover use cases compared to these two traditional
    patterns. Moreover, using Hooks, you don’t need to change the existing component
    structure and add more components to end up with a nested tree.
  prefs: []
  type: TYPE_NORMAL
- en: Do you recommend moving effects into custom Hooks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Effect Hooks are used to perform application side effects when you need to interact
    with the world outside of React’s scope. Some non-React systems can access web
    APIs, invoke external APIs, and so on. Over time, the number of effects in your
    code should be reduced by implementing specific solutions to your use cases. The
    standard guideline is to use effect Hooks when there are no built-in solutions
    available. This is because avoiding the effects makes your application simpler,
    faster to run, and less error-prone. By moving out your effects to custom Hooks,
    it becomes easier to upgrade the code related to effects when there are solutions
    available.
  prefs: []
  type: TYPE_NORMAL
- en: As your application grows with lots of custom Hooks to fulfill the business
    requirements, the application complexity increases and there is a high chance
    of encountering bugs in the application. The next section addresses how to debug
    React custom Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting and debugging Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditional debugging methods, such as debuggers with an IDE and browser DevTools,
    are not effective for debugging custom Hooks. React provides the `useDebugValue`
    Hook to allow developers to debug custom Hooks by assigning custom formatted labels
    to them. By the end of this section, you will have an idea about debugging custom
    Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: How do you debug custom Hooks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useDebugValue` Hook is used to extend the visualization of data related
    to the internal logic of custom Hooks within **React DevTools**. This information
    appears inside the **Component Inspector** tab of the **React** **DevTools** extension.
  prefs: []
  type: TYPE_NORMAL
- en: The current debug information is limited to displaying the information about
    in-built Hooks used inside of our custom Hook. It is hard for developers to read
    the information by counting each line in the output and identifying which entry
    map corresponds to Hooks called inside the code. This difficulty can be rectified
    by adding additional entries to the **React DevTools** output for our custom Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand this in a better way using an example. The required details
    can be logged in various places using the `useDebugValue` Hook inside the custom
    `useFetchData` Hook, as created in the *What are custom Hooks? How do you create*
    *them?* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the second and third debug calls use an *optional second
    argument* to format the displayed value.
  prefs: []
  type: TYPE_NORMAL
- en: '`FetchData` custom Hook. For example, if you hover over the **Posts** component,
    the **Hooks** section on the right side looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: DebugValue label in DevTools](img/Figure_03.02_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: DebugValue label in DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, when the API throws an error due to service unavailability,
    the respective root cause can be tracked through the **DebugValue** label.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed several questions related to built-in Hooks, followed
    by topics related to third-party Hooks and custom Hooks. All these topics have
    been covered in a specific order to understand the connection between various
    types of Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter offered a thorough understanding of Hooks in React applications.
    We began by providing an introduction to Hooks, which included the motivation
    behind Hooks and rules to be followed when using Hooks. We next looked at state
    management within components using the `useState` and `useReducer` Hooks, and
    global state management to share data across components using the `useContext`
    Hook. Thereafter, we covered how to perform side effects in applications with
    the help of effect Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the frequently used built-in Hooks, we discussed accessing DOM nodes
    using ref Hooks, doing performance optimizations through Hooks, using third-party
    Hooks, and creating your own custom Hooks for your business needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover an important navigation library known as
    React Router to navigate from one page to another, and learn about its rich features.
    Another important topic to be discussed in that chapter is supporting internationalization
    and creating dynamic localized messages by passing the arguments.
  prefs: []
  type: TYPE_NORMAL
