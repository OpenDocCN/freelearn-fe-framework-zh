<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Deploying to the Cloud with Kubernetes</h1>
                </header>
            
            <article>
                
<p>Kubernetes<span>, also known as </span>the<span> container orchestration tool. As we have seen in the previous chapter, it comes with many additional features and is much easier to configure and manage. This makes Kubernetes a default choice for any container orchestration. The ability to mask the lower-level details and provide out-of-the-box service discovery, self-healing, and health checks attracted many companies and organizations to switch to Kubernetes. Aside from that, Kubernetes is the evolution of Google's internal orchestration tool.</span></p>
<p><span>In this chapter, we will cover the following topics:</span></p>
<ul>
<li>Generating Kubernetes configuration files with JHipster</li>
<li>Walking through the generated files</li>
<li>Deploying the application to Google Cloud with Kubernetes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating Kubernetes configuration files with JHipster</h1>
                </header>
            
            <article>
                
<p>Knowing the components of Kubernetes and how it works is beyond the scope of this book. However, we will look at how JHipster simplifies microservices deployment with Kubernetes. Let's go ahead and generate the Kubernetes configuration file.</p>
<p>Similar to the <kbd>docker-compose</kbd> sub-generator, JHipster also comes bundled with a Kubernetes sub-generator. In order to use it, just like with <kbd>docker-compose</kbd>, we will create a new folder and name it Kubernetes. Then, we will go inside the folder to create the configuration files.</p>
<p><span>We can create Kubernetes configuration files with the following command and then answer the questions that the sub-generator asks us:</span></p>
<pre><strong>&gt; mkdir kubernetes &amp;&amp; cd kubernetes</strong></pre>
<p><span>To install </span>kubectl<span>, please follow the instructions at Kubernetes' website (</span><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">https://kubernetes.io/docs/tasks/tools/install-kubectl/</a><span>).</span></p>
<div class="packt_infobox">Kubernetes sub-generator needs kubectl (v1.2 or later) to be installed on your computer. kubectl is the command line interface for Kubernetes. </div>
<p>We can also install Cloud SDK from Google Cloud, which will also install kubectl. To set up gcloud:</p>
<ol>
<li>Download the binary (based on your operating system) from<a href="https://cloud.google.com/sdk/"> https://cloud.google.com/sdk/</a>.<a href="https://cloud.google.com/sdk/"/></li>
<li>Then, install the application by following the steps given on the website (make sure that you have python installed).</li>
<li>Once installed, set up Google Cloud. In order to set up Google Cloud, run <kbd>gcloud init</kbd>.</li>
<li>This will then ask you to log in to your Google account:</li>
</ol>
<pre><strong>&gt; jhipster kubernetes</strong></pre>
<div class="packt_infobox">As we have seen already, Kubernetes needs separate tools for running locally (that is for development purposes). Therefore, if you need to do things locally, please install minikube from Kubernetes.</div>
<p>The first question the sub-generator asks is which type of application we'd like to deploy. It provides two options, which are monolithic and microservices.  We will choose the microservices option:</p>
<p class="mce-root CDPAlignCenter"><img height="69" src="assets/6acdbc99-a5b2-4686-90cc-b9ab1a8e011d.png" width="500"/></p>
<p>Then, it asks us to enter the root directory. We will select the default option since our directories are present as the siblings of the Kubernetes folder:</p>
<p class="CDPAlignCenter"><img height="45" src="assets/6ae09d92-e019-4a61-97f1-46a76474ed2e.png" width="539"/></p>
<p>Then, the sub-generator will list all the folders with our JHipster generated application. Here, it will list all three applications that we need—<span class="packt_screen">gateway</span>, <span class="packt_screen">invoice</span>, and <span class="packt_screen">notification</span>. Select all three applications and hit enter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/67486104-8c87-44f7-9e81-9a43cfae4c46.png"/></p>
<p>Then, it will ask us to provide the password for the registry service. In our case, it is JHipster Registry. We will select the default one for now, but it is generally advisable to use a strong password here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3eef9433-a527-413c-ad49-fa4112840d75.png"/></p>
<p>Afterward, it will ask us for the namespace that we need to use in Kubernetes. So, what is a namespace? </p>
<p>We can consider namespaces as a group within which resources should be named uniquely. When the cluster is shared between different users or teams, namespaces can provide resource quotas for them. Ideally, namespaces should be used only for a larger team. For smaller teams, it is better to go with default options. Kubernetes, by default, provides three namespaces, which are as follows:</p>
<ul>
<li><kbd>Default</kbd>: When you start a container or pod without providing any namespaces, they will end up in the default namespace</li>
<li><kbd>Kube-system</kbd>: This namespace contains Kubernetes system-based objects</li>
<li><kbd>Kube-admin</kbd>: This is a public namespace, which will be shown to all the users publically without any authentication</li>
</ul>
<p>We will select the default namespace here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b8ac9f07-0185-4e74-af39-0d9169146467.png"/></div>
<p>Then, the sub-generator will ask for our Docker repository name so that Kubernetes can use this Docker repository to pull the images (the login username of the Docker repository):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/790e7e6e-b79a-4597-b13c-bf30de057917.png"/></div>
<p>Then, the sub-generator will ask for our command so that we can push the image to the Docker repository. We will select the default command here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/88656422-6281-4981-b5bd-97288393c255.png"/></div>
<p>Then, it will ask whether we need the JHipster-console for log aggregation, and we will select <span class="packt_screen">Yes</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ce7f95fc-1224-4c69-a2f7-7795416c4b4a.png"/></div>
<p>JHipster also comes with Prometheus integration, so the next question will be whether we would like to export our services to <span>Prometheus</span>. It needs a <span>Prometheus</span> operator in general to work. We will select <span class="packt_screen">No</span> for this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/567e9a6b-7e7f-4da7-a5d1-b3bc246ad0a5.png"/></div>
<p>Then, the generator will ask us to choose the Kubernetes service type. So, what is the service type?</p>
<p>In Kubernetes, everything that we deploy is a pod. These pods are managed by replication controllers, which can create and destroy any pods. Each pod needs an identifier, so they are tagged with an IP address. This dynamic nature of pods will lead to a lot of problems for other pods that depend on them. To come up with a solution for this problem, Kubernetes introduced services. Services are nothing but a logical grouping of unique pods which have policies attached to them. These policies are applicable for all the pods inside the services, but we need to publish these services to the external world to access them.</p>
<div class="packt_infobox">One of the most powerful features of Kubernetes is that they help to maintain the number of replicas of pods consistently.  The replication controller helps to maintain the pods count by automatically shutting down and booting up the pods.</div>
<p>Kubernetes gives us four different service types, as follows:</p>
<ul>
<li><kbd>Cluster IP</kbd>: This is the default type. This will assign the cluster's internal IP and make it visible within the cluster itself.</li>
<li><kbd>NodePort</kbd>: This will expose the service to a static port in the Node's IP. The port will be random and will be chosen between <kbd>30000</kbd>-<kbd>32767</kbd>.</li>
<li><kbd>LoadBalancer</kbd>: This will expose the service externally. Kubernetes will assign an IP automatically. This will create a route to the NodePort and Cluster IP internally.</li>
<li><kbd>Ingress</kbd>: An Ingress is a special option that Kubernetes provides. This will provide load-balancing, SSL termination, and name-based virtual hosting to the services.</li>
</ul>
<p>We will select the <kbd>LoadBalancer</kbd> option:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dce399ad-02ea-4fdc-9036-2275152bb2f0.png"/></div>
<p>That's it. This will generate the necessary configuration files for us to deploy the application with Kubernetes. Next up, we will check the files that have been generated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Walking through the generated files</h1>
                </header>
            
            <article>
                
<p>The files generated by JHipster are in the following structure. That is, each application will have its own folder and the files related to that service will be present inside it.</p>
<p>We will start with the gateway application. There will be three generated files, which will be the <kbd>gateway-service</kbd>, <kbd>gateway-mysql</kbd>, and <kbd>gateway-deployment.yml</kbd> files.</p>
<p>The following is the <kbd>gateway-service.yml</kbd> file:</p>
<pre>apiVersion: v1<br/>kind: Service<br/>metadata: <br/>    name: gateway<br/>    namespace: default<br/>    labels:<br/>        app: gateway<br/>spec:<br/>    selector:<br/>        app: gateway<br/>    type: LoadBalancer<br/>ports:<br/> - name: web<br/>   port: 8080</pre>
<p>The first line defines the API version of Kubernetes, followed by the kind of template or object that this template carries. This template will have a service inside of it. </p>
<p>Then, we will have the metadata information. Kubernetes uses this metadata information to group certain services together. In the metadata, we can define:</p>
<ul>
<li>The service name</li>
<li>The namespace it belongs to</li>
<li>The labels, which are key and value pairs</li>
</ul>
<p>Then, we will define the spec. The spec in the Kubernetes object will provide the state of the service. In the spec, we can define the number of replicas we need. We can also define the selector, within which we can specify the service with identifiers. We can also specify the type of the service. Kubernetes will take the information from this spec and then maintain the application in the state provided (we will have a look at the spec gateway in a while), followed by the ports in which port the application should run. This is similar to the Dockerfile, so we are exposing the <kbd>8080</kbd> port for the gateway service.</p>
<p>Then, we have the <kbd>gateway-mysql.yml</kbd> file, where we have defined our MySQL server for the gateway application. The difference here is that the spec points to <kbd>gateway-mysql</kbd>, which is defined in the same file and is exposed on port <kbd>3306</kbd>:</p>
<pre><span>apiVersion</span><span>: </span><span>v1<br/></span><span>kind</span><span>: </span><span>Service<br/></span><span>metadata</span><span>:<br/>    </span><span>name</span><span>: </span><span>gateway-mysql<br/>    </span><span>namespace</span><span>: </span><span>default<br/></span><span>spec</span><span>:<br/>    </span><span>selector</span><span>:<br/>        </span><span>app</span><span>: </span><span>gateway-mysql<br/></span><span>ports</span><span>:<br/>    </span><span>- </span><span>port</span><span>: </span><span>3306</span></pre>
<p>In the <kbd>gateway-mysql</kbd> app declaration, we have specified the database and environment properties that are needed for our application to run. Here, the <kbd>kind</kbd> is mentioned as <strong>deployment</strong>. The job of the deployment object is to change the state of the services to the state that is defined in the deployment object.</p>
<p>Here, we have defined a single replica of the MySQL server, followed by the spec, where we have mentioned the version of MySQL that we need (the container). This is then followed by the username, password, and then the database schema. We can also specify the volume information with volume mounts for persistent storage:</p>
<div class="packt_tip">Note: we can also define a spec inside a spec object (as shown in the following code):</div>
<pre><span>apiVersion</span><span>: </span><span>extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/>    ... // metadata<br/>spec:<br/>    replicas: 1<br/>    ... // metadata related information<br/>    spec:<br/>        ... //volumes and other information<br/>        containers:<br/>         - name: mysql<br/>           image: mysql:5.7.20<br/>        env:<br/>            ...  // environment details<br/>        ports:<br/>            ... // port<br/>        volumeMounts:<br/>            ... //Mapping the volume to the external persistent location<br/></span></pre>
<p>Similarly, we have <kbd>gateway-deployment.yml</kbd>, in which we have defined the gateway application and its environment properties along with the other details like ports, probes and so on.</p>
<p>A similar approach is done for both the invoice and notification services. You can find them in their respective folders.</p>
<p>In <kbd>JHipster-registry</kbd>, alongside <kbd>Service</kbd> and <kbd>Deployment</kbd>, we have defined Secret and StatefulSet.</p>
<p>The secret is used to handle passwords. It will be an opaque type and the password is base64 encoded.</p>
<p>Then, we have the StatefulSet, which are similar to pod except they have a sticky identity. Pods are dynamic in nature. These pods have a persistent identifier that is maintained throughout. It makes sense for a registry server to be defined as a StatefulSet, since it is essential that the registry server should be identified by a persistent identifier. This enables all services to connect to that single endpoint and get the necessary information. If the registry server is down, then communication between the services will also have problems, since the services connect to other services via the registry server.</p>
<p>There are various options that are available to set the controller, which are as follows:</p>
<ul>
<li><strong>Replica Set</strong>: Provides a replica of pods at any time with selectors</li>
<li><strong>Replica Controller</strong>: Provides a replica of pods without any selectors</li>
<li><strong>StatefulSet</strong>: Makes the pod unique by providing it with a persistent identifier</li>
<li><strong>DaemonSet</strong>: Provides a copy of the pod which is going to be run</li>
</ul>
<p>The JHipster Registry is configured in a cluster and with high availability. The UI access to the JHipster Registry is also restricted to the cluster for better security. </p>
<p>Similarly, configuration files are generated for the JHipster Console, and they are placed in a console folder, which is <kbd>jhipster-console.yml</kbd>, where the JHipster Console is also defined.</p>
<p>The JHipster Console runs on an ELK stack, so we need Elasticsearch, which is defined in <kbd>jhipster-elasticsearch.yml</kbd>, followed by Logstash in the <kbd>jhipster-logstash.yml</kbd> file. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the application to Google Cloud with Kubernetes</h1>
                </header>
            
            <article>
                
<p class="mce-root">We have created Kubernetes configuration files with the <kbd>jhipster kubernetes</kbd> command. The next step is to build the artifacts and deploy them into Google Cloud.</p>
<p>Kubernetes will use the image from the Docker Registry. We configured the Docker username when we generated the application, so the first step will be to tag those images and then push them to our Docker repository.</p>
<p>To do so, we will do the following:</p>
<p>We will open the terminal and go to the Kubernetes folder that we have generated:</p>
<pre><strong>&gt; docker image tag gateway sendilkumarn/gateway</strong></pre>
<p>And we will push this image into the Docker repository:</p>
<pre><strong>&gt; docker push sendilkumarn/gateway</strong></pre>
<div class="packt_quote packt_tip packt_infobox">Note: you have to log in to the Docker Hub before pushing the image. You can login to Docker using the <kbd>docker login</kbd> command followed by your username and password. If you don't have an account, you can create one at the following link: <a href="https://cloud.docker.com/">https://cloud.docker.com/</a>.</div>
<p class="mce-root">Similarly, push the invoice application to the Docker repository:</p>
<pre><strong>&gt; docker image tag invoice sendilkumarn/invoice</strong><br/><strong>&gt; docker push sendilkumarn/invoice</strong></pre>
<p>Do the same for notification:</p>
<pre><strong>&gt; docker image tag notification sendilkumarn/notification</strong><br/><strong>&gt; docker push sendilkumarn/notification</strong></pre>
<p>This will push gateway, invoice, and notification to the Docker repository. We can check this in the Docker console:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/87c9e9ec-e51d-4afd-babb-c1516fb83679.png"/></div>
<p>Now, we can connect to gcloud and deploy our containers with Kubernetes. </p>
<div class="packt_tip packt_infobox">This assumes that you have set up gcloud SDK and kubectl on your machine.</div>
<p class="mce-root">First, we will log in to the gcloud via the Terminal. In order to do that, open your Terminal:</p>
<pre><strong>&gt; gcloud init</strong>  // if this is the first time you are using gcloud (Ignore this step if you logged in already)</pre>
<p>Then, gcloud will ask you to log in to your google account. Once validated, this will list the projects that you might already have. </p>
<p>Here, we can choose <span class="packt_screen">[31] Create a new project</span><strong> </strong>by entering the number before creating a new project. Then, press enter. It will ask you to enter the project information and then configure a few Google services for that project. Then, gcloud will list all the available regions and you can choose a region that suits you.</p>
<p>If you have already logged in to the console and used it for other projects, then you can switch projects using the following command:</p>
<pre>&gt; gcloud config set project <strong>&lt;project-name&gt;</strong></pre>
<p><span>This will set the project, region, and the setting chosen as the default. </span></p>
<p>Then, you have to enable Kubernetes in our application. We can do this by logging in to our Google Cloud console via the browser. Then, select the project that we have just created and go to <a href="https://console.cloud.google.com/kubernetes/list">https://console.cloud.google.com/kubernetes/list</a>.<a href="https://console.cloud.google.com/kubernetes/list"/></p>
<p>This will create a cluster for your project. Instead, you can create a cluster using the <kbd>gcloud</kbd> command:</p>
<pre><strong>&gt; gcloud container clusters create online-store</strong></pre>
<p>The following is the output of the preceding command:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cdb14c70-6bc6-4eb2-b6f6-453e482c0ef0.png"/></div>
<p>Thus, the cluster is created with 3 nodes.</p>
<p>Then, we can go to our Kubernetes folder and start deploying the services using kubectl:</p>
<pre>&gt; kubectl apply -f <strong>&lt;project-name&gt;</strong></pre>
<p>The output will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="379" src="assets/d26a63b8-7c32-4fe8-9aab-f8ccb30161ab.png" width="362"/></div>
<p>This will create all the applications in the Google Cloud environment, under your project.</p>
<p>You can check the <kbd>pods</kbd> deployment process using the following command:</p>
<pre>&gt; kubectl get pods --watch</pre>
<p>This will list down the <kbd>pods</kbd> that are spinning up and shutting down:</p>
<div class="CDPAlignCenter CDPAlign"><img height="160" src="assets/d4332800-c6e5-4cba-b901-dcd6ff5c92e7.png" width="475"/></div>
<p>You can also get the logs of the application using the following command:</p>
<pre>&gt; kubectl logs <strong>&lt;name as shown above&gt;</strong><em><strong><br/></strong></em></pre>
<p>The following is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8f2ffa96-cec5-443b-9835-f62b3f23f5fb.png"/></div>
<p>You can get the application's external IP using this piece of code:</p>
<pre><strong> &gt; kubectl get svc gateway</strong></pre>
<p>This will list the application's name, type, IP address, external address, ports, and uptime:</p>
<div class="CDPAlignCenter CDPAlign"><img height="33" src="assets/4b2ec1cb-3981-4381-9115-a3f4d12a4920.png" width="475"/></div>
<p>We can find the same information on the Google Cloud console:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1f39f95d-c307-48c9-b277-f4e69cf3d4bc.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">The application can be accessed at the preceding <span class="packt_screen">External-IP</span>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/bfe0972c-578b-462a-8f83-d56110c76a89.png"/></div>
<p>You can also scale the application by using the following command:</p>
<pre>&gt;<span> kubectl scale deployment <strong>&lt;app-name&gt;</strong> --replicas <strong>&lt;number-of-replicas&gt;<em><br/></em></strong></span></pre>
<div class="packt_infobox">The JHipster-registry is deployed in headless mode. In order to check the JHipster registry, we can explicitly expose the service by using this command—<kbd><strong>kubectl expose service jhipster-registry --type=NodePort --name=exposed-registry</strong></kbd><span>—</span>and then we can access the application via <kbd>exposed-registry</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Orchestrating your containers is the most difficult task to perform in the microservices environment. Kubernetes, as a container orchestrator, stands out in solving this. We have seen how to generate the configuration file for Kubernetes with JHipster, followed by deploying the application to the Google Cloud.</p>
<p>So far, we've seen how we can develop and deploy an e-commerce application using JHipster. We started with a monolith and we successfully scaled it into a microservice architecture, all with the help of JHipster and the various tools and technologies it supports. With this chapter, our journey of developing the e-commerce web application comes to an end and we hope you had a wonderful experience following it though.</p>
<p>In the next chapter, we will see how you can use JHipster further to create an application with a React client-side application, so stay tuned.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>