- en: Building an Audio Recorder
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建音频录音机
- en: Recording audio is the most performance-intensive operation our app must handle.
    It is also the one feature where having access to native APIs will be the most
    rewarding. We want our users to be able to record with the lowest latency possible
    for the mobile device in order to achieve the highest fidelity of sound. Additionally,
    this recording should optionally happen over the top of an existing mix of pre-recorded
    tracks all playing in sync .
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 录制音频是我们的应用必须处理的性能最密集的操作。这也是唯一一个访问原生API将最有回报的功能。我们希望用户能够以移动设备可能的最低延迟录制，以实现最高保真度的声音。此外，这种录制应该可以选择地发生在现有预先录制的音轨的顶部，所有音轨都在同步播放。
- en: Since this phase of our app development will dive the deepest into platform-specific
    native APIs, we will split our implementations into two phases. We will first
    build out the iOS-specific details of the recording features, followed by Android.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用开发的这个阶段将深入到特定平台的原生API，我们将把我们的实现分为两个阶段。我们将首先构建出录音功能的iOS特定细节，然后是Android。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Building a feature rich cross-platform audio recorder for iOS and Android with
    a consistent API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为iOS和Android构建一个功能丰富的跨平台音频录音机，具有一致的API
- en: Integrating iOS framework libraries, such as AudioKit ([http://audiokit.io](http://audiokit.io)),
    which was built entirely with Swift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成iOS框架库，比如完全使用Swift构建的AudioKit（[http://audiokit.io](http://audiokit.io)）
- en: How to convert Swift/Objective C methods to NativeScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Swift/Objective C方法转换为NativeScript
- en: Building custom reusable NativeScript view components based on native APIs,
    as well as how to use them inside Angular
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于原生API构建自定义可重复使用的NativeScript视图组件，以及如何在Angular中使用它们
- en: Configuring a reusable Angular Component that can both be used via routing and opened
    via a popup modal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个可重复使用的Angular组件，既可以通过路由使用，也可以通过弹出式模态框打开
- en: Integrate Android Gradle libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Android Gradle库
- en: How to convert Java methods to NativeScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Java方法转换为NativeScript
- en: Using multiple item templates with NativeScript's ListView
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NativeScript的ListView和多个项目模板
- en: Phase 1 – Building an audio recorder for iOS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一阶段 - 为iOS构建音频录音机
- en: The audio capabilities of the iOS platform are impressive, to say the least.
    A group of wonderfully talented audiophiles and software engineers have collaborated
    on building an open source framework layer on top of the platform's audio stack. This
    world class engineering effort is the awe inspiring AudioKit ([http://audiokit.io/](http://audiokit.io/)),
    led by the fearless Aurelius Prochazka, a true pioneer in audio technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: iOS平台的音频功能令人印象深刻，不得不说。一群才华横溢的音频爱好者和软件工程师合作构建了一个开源框架层，位于该平台的音频堆栈之上。这个世界级的工程努力是令人敬畏的AudioKit（[http://audiokit.io/](http://audiokit.io/)），由无畏的Aurelius
    Prochazka领导，他是音频技术的真正先驱。
- en: The AudioKit framework is written entirely with Swift, which introduces a couple
    of interesting surface-level challenges when integrating with NativeScript.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AudioKit框架完全使用Swift编写，这在与NativeScript集成时引入了一些有趣的表面层挑战。
- en: Challenge detour – Integrate Swift based library into NativeScript
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战绕道 - 将基于Swift的库集成到NativeScript中
- en: "At the time of this writing, NativeScript can work with Swift if the codebase properly\
    \ exposes the classes and types to Objective-C via what's called a **bridging\
    \ header**, allowing both the languages to be mixed or matched. You can learn\
    \ more about what a bridging header is here: [https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html).\
    \ [](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)\
    \ This bridging header is auto generated when the Swift codebase is compiled into\
    \ a framework. Swift offers rich language features, some of which do not have\
    \ a direct correlation to Objective C. Full featured support for the latest Swift\
    \ language enhancements will likely come to NativeScript eventually however at\
    \ the time of this writing there are a couple considerations to keep in mind.\uFEFF"
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，如果代码库通过所谓的**桥接头文件**正确地将类和类型暴露给Objective-C，NativeScript可以与Swift一起工作，从而允许两种语言混合或匹配。您可以在这里了解有关桥接头文件的更多信息：[https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)。[](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)
    当Swift代码库编译为框架时，将自动生成此桥接头文件。Swift提供了丰富的语言功能，其中一些与Objective C没有直接对应关系。最新的Swift语言增强功能的全面支持可能最终会到NativeScript，但是在撰写本文时，有一些需要牢记的考虑。
- en: 'AudioKit utilizes the best of what the Swift language has to offer, including
    enriched **enum** capabilities. You can learn more about the expanded enum features
    in the Swift language here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AudioKit利用了Swift语言所提供的最佳功能，包括丰富的**枚举**功能。您可以在这里了解Swift语言中扩展的枚举功能：
- en: '[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html)'
- en: 'In particular, there is this from the documentation: "t*hey adopt many features
    traditionally supported only by classes, such as computed properties to provide
    additional information about the enumeration’s current value, and instance methods
    to provide functionality related to the values the enumeration represents.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，文档中有这样的内容："*它们采用了传统上仅由类支持的许多功能，例如计算属性以提供有关枚举当前值的附加信息，以及实例方法以提供与枚举表示的值相关的功能。*”
- en: Such *enums* are foreign to Objective C and, therefore, cannot be made available
    in the bridging header. Any code that uses Swift's exotic *enums* will be simply
    ignored when the bridging header is generated at compile time, resulting in Objective
    C not being able to interact with those sections of the code. This means you will
    not be able to use a method from a Swift codebase in NativeScript which utilizes
    these enhanced constructs out of the box (*at the time of this writing*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的*枚举*对Objective C来说是陌生的，因此无法在桥接头文件中使用。在编译时生成桥接头文件时，任何使用Swift的奇异*枚举*的代码都将被简单地忽略，导致Objective
    C无法与代码的这些部分进行交互。这意味着您将无法在NativeScript中使用Swift代码库中的方法，该方法使用了这些增强的构造（*在撰写本文时*）。
- en: 'To remedy this, we will fork the AudioKit framework and flatten the exotic
    enums used in the `AKAudioFile` extension files, which provide a powerful and
    convenient export method we will want to use to save our recorded audio files.
    The exotic *enum* we need to modify looks like this ([https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将fork AudioKit框架，并展平`AKAudioFile`扩展文件中使用的奇异枚举，这些文件提供了一个强大和方便的导出方法，我们将要用来保存我们录制的音频文件。我们需要修改的奇异*enum*看起来像这样（[https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)）：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is unlike any *enum* you may be familiar with; as you can see, it includes
    properties in addition to what enums have. When this code is compiled and the
    bridging header is generated to mix or match with Objective-C, the bridging header will
    then exclude any code that uses this construct. We will flatten this out to look
    like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您可能熟悉的任何*enum*都不同；正如您所看到的，它包括除枚举之外的属性。当这段代码被编译并生成桥接头文件以与Objective-C混合或匹配时，桥接头文件将排除使用此结构的任何代码。我们将将其展平，使其看起来像以下内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will then adjust the portions of the `AKAudioFile` extension to use our flattened
    properties. This will allow us to manually build `AudioKit.framework` we can use
    in our app, exposing the method we want to use: `exportAsynchronously`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将调整`AKAudioFile`扩展的部分，以使用我们展平的属性。这将允许我们手动构建`AudioKit.framework`，我们可以在我们的应用程序中使用，暴露我们想要使用的方法：`exportAsynchronously`。
- en: We won't go over the details of manually building `AudioKit.framework`, as it
    is well documented here: [https://github.com/audiokit/AudioKit/blob/master/Frameworks/INSTALL.md#building-universal-frameworks-from-scratch](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift).
    With our custom-built framework, we are now ready to integrate it into our app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍手动构建`AudioKit.framework`的细节，因为这在这里有很好的文档记录：[https://github.com/audiokit/AudioKit/blob/master/Frameworks/INSTALL.md#building-universal-frameworks-from-scratch](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)。有了我们定制的框架，我们现在可以将其集成到我们的应用程序中。
- en: Integrating a custom-built iOS framework into NativeScript
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义构建的iOS框架集成到NativeScript
- en: 'We can now create an internal plugin to integrate this iOS framework into our
    app. Take the custom `AudioKit.framework` we have built and create a `nativescript-audiokit` directory
    at the root of our app. We then add a `platforms/ios` folder inside to drop the
    framework into. This will let NativeScript know how to build these iOS-specific
    files into the app. As we want this internal plugin to be treated like any standard
    npm plugin, we will also add `package.json` directly inside the `nativescript-audiokit`
    folder with the following contents:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个内部插件，将这个iOS框架集成到我们的应用程序中。拿着我们构建的自定义`AudioKit.framework`，在我们应用程序的根目录下创建一个`nativescript-audiokit`目录。然后在里面添加一个`platforms/ios`文件夹，将框架放进去。这样就可以让NativeScript知道如何将这些iOS特定的文件构建到应用程序中。由于我们希望这个内部插件被视为任何标准的npm插件，我们还将在`nativescript-audiokit`文件夹内直接添加`package.json`，内容如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will now use the following command to add it to our app (NativeScript will
    look locally first and find the **nativescript-audiokit** plugin):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用以下命令将其添加到我们的应用程序中（NativeScript将首先在本地查找并找到**nativescript-audiokit**插件）：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will properly add the custom-built iOS framework into our app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正确地将自定义构建的iOS框架添加到我们的应用程序中。
- en: 'However, we need two more very important items:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们还需要两个非常重要的项目：
- en: 'Since AudioKit is a Swift-based framework, we want to ensure our app includes
    the proper supporting Swift libraries. Add a new file, `nativescript-audiokit/platforms/ios/build.xcconfig`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于AudioKit是一个基于Swift的框架，我们希望确保我们的应用程序包含适当的支持Swift库。添加一个新文件，`nativescript-audiokit/platforms/ios/build.xcconfig`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since we will be engaging with the user''s microphone, we will want to ensure
    the microphone usage is indicated in our app''s property list. We will also take
    this opportunity to add two additional property settings to enhance our app''s
    abilities. So, in total, we will add three property keys for the following purposes:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将要使用用户的麦克风，我们希望确保麦克风的使用在我们应用程序的属性列表中得到了指示。我们还将利用这个机会添加两个额外的属性设置来增强我们应用程序的能力。因此，总共我们将为以下目的添加三个属性键：
- en: Let the device know our app needs access to the microphone and ensure the user's
    permission is requested on first access.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让设备知道我们的应用程序需要访问麦克风，并确保在第一次访问时请求用户的权限。
- en: Continue playing audio if the app is placed into the background.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序被放入后台时继续播放音频。
- en: Provide the ability to see the app's `documents` folder in iTunes when the phone
    is connected to a computer. This will allow you to view recorded files right inside
    of iTunes via the app's Documents. This could be useful for integration into a
    desktop audio editing software.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供在连接到计算机时能够在iTunes中看到应用程序的`documents`文件夹的能力。这将允许您通过应用程序的文档在iTunes中直接查看录制的文件。这对于集成到桌面音频编辑软件中可能会有用。
- en: 'Add a new file, `nativescript-audiokit/platforms/ios/Info.plist`, with the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新文件，`nativescript-audiokit/platforms/ios/Info.plist`，其中包含以下代码：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is a screenshot to better illustrate the internal plugin structure in
    our app:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个屏幕截图，更好地说明了我们应用程序中的内部插件结构：
- en: '![](../images/00036.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: 'Now, when NativeScript builds the iOS app, it will ensure `AudioKit.framework`
    is included as a library and merge the contents of `build.xcconfig` and `Info.plist`
    into our app''s configuration. Any time we make changes to the files inside this
    internal plugin folder (`nativescript-audiokit`), we want to ensure our app picks
    up those changes. To do so, we can simply remove and add the plugin back, so let''s
    do that now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当NativeScript构建iOS应用程序时，它将确保`AudioKit.framework`被包含为一个库，并将`build.xcconfig`和`Info.plist`的内容合并到我们应用程序的配置中。每当我们对这个内部插件文件夹（`nativescript-audiokit`）中的文件进行更改时，我们希望确保我们的应用程序能够接收到这些更改。为了做到这一点，我们可以简单地删除并重新添加插件，所以现在让我们这样做：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are now ready to build our audio recorder using the AudioKit API for iOS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用iOS的AudioKit API构建我们的音频录制器。
- en: Setting up native API type checking and generate AudioKit TypeScript definitions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置本地API类型检查并生成AudioKit TypeScript定义。
- en: 'The first thing we want to do is install `tns-platform-declarations`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是安装`tns-platform-declarations`：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we create a new file in the root of the project called `references.d.ts`
    with the following contents:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在项目的根目录中创建一个名为`references.d.ts`的新文件，其中包含以下内容：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This provides us with full type checking and intellisense support for iOS and
    Android APIs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了对iOS和Android API的完整类型检查和智能感知支持。
- en: 'We now want to generate typings for the AudioKit framework itself. We can execute
    this command to generate the typings for the included `AudioKit.framework`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要为AudioKit框架本身生成类型定义。我们可以执行以下命令来为包含的`AudioKit.framework`生成类型定义：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are setting the environment variable `TNS_TYPESCRIPT_DECLARATIONS_PATH` to
    the present working directory (`pwd`) with a folder prefix of `typings`. When
    NativeScript creates the iOS build, it will also generate type definition files
    for all the native APIs available to our app, including third-party libraries.
    We will now see a `typings` folder appear in our project, containing two folders:
    `i386` and `x86_64`. One is for the Simulator architecture and the other the device.
    Both will contain the same output, so we can just focus on one. Open the `i386`
    folder and you will find an `objc!AudioKit.d.ts` file.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将环境变量`TNS_TYPESCRIPT_DECLARATIONS_PATH`设置为当前工作目录（`pwd`），并添加一个名为`typings`的文件夹前缀。当NativeScript创建iOS构建时，它还将为我们的应用程序提供的所有原生API以及第三方库生成类型定义文件。现在我们将在项目中看到一个`typings`文件夹，其中包含两个文件夹：`i386`和`x86_64`。一个是模拟器架构，另一个是设备。两者都将包含相同的输出，因此我们只需关注一个。打开`i386`文件夹，你会找到一个`objc!AudioKit.d.ts`文件。
- en: 'We want to use only that file, so move it to the root of the `typings` folder:
    `typings/objc!AudioKit.d.ts`. We can then remove both the `i386` and `x86_64` folders,
    as we will no longer need them (the other API definition files are provided via
    `tns-platform-declarations`). We just generated these typings to get TypeScript
    definitions for the AudioKit library. This is a one-time thing, done to integrate
    easily with this native library, so you are safe to add this custom `typings`
    folder to source control.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想使用那个文件，所以将它移动到`typings`文件夹的根目录：`typings/objc!AudioKit.d.ts`。然后我们可以删除`i386`和`x86_64`文件夹，因为我们将不再需要它们（其他API定义文件通过`tns-platform-declarations`提供）。我们只是生成这些类型定义文件以获得AudioKit库的TypeScript定义。这是一次性的事情，用于轻松集成这个本地库，所以您可以放心将这个自定义`typings`文件夹添加到源代码控制中。
- en: 'Double-check `tsconfig.json` and ensure you have the `"skipLibCheck": true`
    option enabled. We can now modify our `references.d.ts` file to include the additional
    types for the AudioKit library:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '仔细检查`tsconfig.json`，确保已启用`"skipLibCheck": true`选项。现在我们可以修改我们的`references.d.ts`文件，以包含AudioKit库的附加类型：'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our project structure should now look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目结构现在应该是这样的：
- en: '![](../images/00037.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: Build recorder with AudioKit
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AudioKit构建录音机
- en: We will begin by creating a model around our interaction with AudioKit's recording
    APIs. You could just start writing directly against these APIs right from your
    Angular component or service, but since we want to provide a consistent API across
    iOS and Android, there's a smarter way to architect this. Instead, we will abstract a
    simple API, usable across both platforms, which will tap into the correct native
    implementations under the hood.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个围绕与AudioKit录音API交互的模型。你可以直接从你的Angular组件或服务中开始直接编写针对这些API的代码，但是由于我们希望在iOS和Android上提供一致的API，因此有一种更聪明的方法来设计这个。相反，我们将抽象出一个简单的API，可在两个平台上使用，并在底层调用正确的本地实现。
- en: 'There will be a lot of interesting details related to AudioKit going on here,
    but create `app/modules/recorder/models/record.model.ts` with the following and
    we will explain some of the bits in a moment:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将会有很多与AudioKit相关的有趣细节，但是创建`app/modules/recorder/models/record.model.ts`并包含以下内容，我们将在稍后解释其中的一些部分：
- en: Later, we will add the `.ios.ts` suffix to this model, since it will contain
    iOS-specific implementation details. However, here in Phase 1, we will use the
    model directly (omitting the platform suffix) while we develop our iOS recorder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将在这个模型中添加`.ios.ts`后缀，因为它将包含iOS特定的实现细节。然而，在第一阶段，我们将直接使用模型（省略平台后缀）来开发我们的iOS录音机。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`RecordModel` will behave a bit like a state machine, where the only states
    it could be in are the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordModel`将表现得有点像一个状态机，它可能处于以下状态之一：'
- en: '`readyToRecord`: Default starting state. Must be in this state to enter the
    recording state.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readyToRecord`：默认的起始状态。必须处于此状态才能进入录音状态。'
- en: '`recording`: Quiet in the studio! Recording in process.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recording`：工作室安静！录音进行中。'
- en: '`readyToPlay`: User has stopped recording and now has a recorded file to play
    back with the mix.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readyToPlay`：用户已停止录音，现在有一个录制文件可以与混音一起播放。'
- en: '`playing`: User is playing back the recorded file with the mix.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playing`：用户正在用混音回放录制的文件。'
- en: '`saved`: User chose to save the recording, that should kick off actions to
    save the new track with the active composition.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saved`：用户选择保存录音，这应该启动保存新轨道与活动组合的操作。'
- en: '`finish`: Once the save actions are complete, the recorder should shut down.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish`：一旦保存操作完成，记录器应该关闭。'
- en: We then define the shape of the events the recorder will provide with `IRecordEvents`.
    In this case, we will have a single event, `stateChange`, which will notify any
    listeners when the state changes (*see the state setter*). Our model will extend
    NativeScript's `Observable` class (hence, `RecordModel extends Observable`), which
    will provide us with the notify API to dispatch our events.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`IRecordEvents`定义记录器将提供的事件的形状。在这种情况下，我们将有一个单一的事件`stateChange`，当状态改变时（*参见状态设置器*）将通知任何监听器。我们的模型将扩展NativeScript的`Observable`类（因此，`RecordModel
    extends Observable`），这将为我们提供通知API来分发我们的事件。
- en: 'We then set up several references to the various AudioKit bits we will use.
    Most of what is designed is directly from this AudioKit example on recording:
    [https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift](https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift).
    We even use the same state enum setup (with a few extras). In their example, AudioKit''s `AKAudioPlayer`
    is used for playback; but, with our design, we will load our recorded files into our
    multitrack player design to play them back with our mix. We could work `AKAudioPlayer`
    into `TrackPlayerModel` for iOS; but, `TNSPlayer` (from the **nativescript-audio**
    plugin) is cross-platform compatible and will work just fine. We''ll cover the
    details of how we load these new recorded files into our design shortly, but notifying
    listeners of the recorder''s state will provide us all the flexibility we need
    to handle all that when we get there.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了对我们将使用的各种AudioKit部分的几个引用。大部分设计直接来自于AudioKit的录音示例：[https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift](https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift)。我们甚至使用相同的状态枚举设置（带有一些额外的内容）。在他们的示例中，AudioKit的`AKAudioPlayer`用于播放；但是，根据我们的设计，我们将加载我们的录制文件到我们的多轨播放器设计中，以便用我们的混音回放它们。我们可以在iOS的`TrackPlayerModel`中使用`AKAudioPlayer`；但是，`TNSPlayer`（来自**nativescript-audio**插件）是跨平台兼容的，也可以正常工作。我们将很快介绍如何将这些新录制的文件加载到我们的设计中的细节，但是通知记录器状态的监听器将为我们提供处理所有这些的灵活性。
- en: 'You may wonder why we type-cast this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们要进行类型转换：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Good question. AudioKit provides Extensions to Core Foundation classes such
    as `AVAudioFile`. These were known as `Categories` in Objective C: [https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html);
    however, in Swift, they are referred to as `Extensions`: [https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。AudioKit提供了对Core Foundation类的扩展，比如`AVAudioFile`。在Objective C中，这些被称为`Categories`：[https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html)；然而，在Swift中，它们被称为`Extensions`：[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html)。
- en: If you recall, we generated TypeScript definitions for AudioKit; but, we only
    kept the `objc!AudioKit.d.ts` file to reference. If we had looked in the foundation
    definitions, we would have seen the extension to `AVAudioFile`. However, since
    we did not keep those definitions around and instead are relying on the default
    `tns-platform-declarations` definitions, this `Extension` is not known to our
    TypeScript compiler, so we simply type-cast it, as we know AudioKit provides this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们为AudioKit生成了TypeScript定义；但是，我们只保留了`objc!AudioKit.d.ts`文件来引用。如果我们查看了foundation的定义，就会看到对`AVAudioFile`的扩展。然而，由于我们没有保留这些定义，而是依赖于默认的`tns-platform-declarations`定义，这个`Extension`对我们的TypeScript编译器来说是未知的，所以我们只是简单地进行类型转换，因为我们知道AudioKit提供了这个功能。
- en: 'It''s also critical `RecordModel` sets the audio session to `PlayAndRecord`,
    as this will allow us to record while playing our mix at the same time:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordModel`设置音频会话为`PlayAndRecord`也很关键，这样我们就可以在播放混音的同时录制了：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may also be curious why some classes use `init()` and others `init(null)`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想知道为什么有些类使用`init()`而其他类使用`init(null)`：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Some of the initializers for AudioKit's classes take an optional argument, for
    example, `AKMixer` takes an optional `NSArray` of `AVAudioNode` to connect. However,
    our TypeScript definitions have those defined as required, so we are just passing
    `null` to that argument and instead using the `connect` node API directly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: AudioKit类的一些初始化器接受一个可选参数，例如，`AKMixer`接受一个可选的`NSArray`，用于连接`AVAudioNode`。然而，我们的TypeScript定义将其定义为必需的，所以我们只是将`null`传递给该参数，并直接使用`connect`节点API。
- en: How to convert Swift/ObjC methods to NativeScript
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将Swift/ObjC方法转换为NativeScript
- en: 'The last point of interest from `RecordModel` might be the `save` method, which
    will export our recording from the app''s `tmp` directory to the app''s `documents`
    folder while converting it to the smaller filesize `.m4a` audio format:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从`RecordModel`中可能引起兴趣的最后一点可能是`save`方法，它将把我们的录音从应用的`tmp`目录导出到应用的`documents`文件夹，并将其转换为更小的`.m4a`音频格式：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Long method name, right? Yes, indeed; some Swift/ObjC parameterized method
    names collapse to become very long. That particular method in Swift is defined
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名很长，对吧？是的，确实；一些Swift/ObjC参数化方法名会变得非常长。在Swift中，特定的方法定义如下：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we had the TypeScript definitions generated for AudioKit, they helped
    us out here. However, sometimes, you don't have that luxury. A Swift/ObjC method
    with various parameters for arguments collapse into each other while adding `With` in
    between the start of the method name and the start of the parameter argument names,
    while capitalizing the first character upon collapsing each.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为AudioKit生成了TypeScript定义，它们在这里帮了我们。然而，有时候你没有这种奢侈。一个具有各种参数的Swift/ObjC方法会在方法名称的开头和参数参数名称的开头之间添加`With`，在折叠时将第一个字符大写。
- en: Building custom reusable NativeScript view for native audio Waveform display
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为本机音频波形显示构建自定义可重用的NativeScript视图
- en: Instead of creating an Angular Component for our Waveform display, we will create
    a custom NativeScript view component, that taps into native APIs, that we can
    then register with Angular to use in our components. The reason for doing this
    is due to NativeScript's powerful `view` base class that we can extend, which
    provides a nice API when using underlying native APIs for the `view`. This Waveform
    display will work in tandem with the `RecordModel` we just created to bring to
    life our real-time Waveform feedback display of the device's microphone. It would
    also be amazing to reuse this Waveform display as a static audio file waveform
    rendering on our track list, as an alternate view for our main composition view.
    AudioKit provides classes and APIs to do all this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个自定义的NativeScript视图组件，而不是为我们的波形显示创建一个Angular组件，该组件可以利用本机API，然后我们可以在Angular中注册以在我们的组件中使用。这样做的原因是由于NativeScript强大的`view`基类，我们可以扩展它，它在使用底层本机API时提供了一个很好的API。这个波形显示将与我们刚刚创建的`RecordModel`一起工作，以实现设备麦克风的实时波形反馈显示。将这个波形显示作为我们主要组合视图的备用视图，作为静态音频文件波形渲染在我们的轨道列表上重复使用也是很棒的。AudioKit提供了执行所有这些操作的类和API。
- en: Since we want to be able to use this anywhere in our app, we will create it
    inside the shared module directory; however, keep in mind that it could live anywhere.
    It doesn't matter so much here, since this is not an Angular component that needs
    to be declared in `NgModule`. Additionally, since this will specifically work
    with native APIs, let's create it inside a new `native` folder to potentially
    house other NativeScript-specific view components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望能够在应用程序的任何地方使用它，我们将在共享模块目录中创建它；然而，请记住它可以存在于任何地方。这里并不那么重要，因为这不是一个需要在`NgModule`中声明的Angular组件。此外，由于这将专门与本机API一起工作，让我们将其创建在一个新的`native`文件夹中，以潜在地容纳其他特定于NativeScript的视图组件。
- en: 'Create `app/modules/shared/native/waveform.ts` with the following contents,
    which we will explain in a moment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`app/modules/shared/native/waveform.ts`，其中包含以下内容，我们将在稍后解释：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are creating several properties using NativeScript's `Property` class, which
    will add great conveniences when exposing native view properties through the view
    binding properties. One such convenience in defining these properties with the
    `Property` class, these setters will only be called when `nativeView` is defined,
    avoiding double invoked property setters (one via a pure JS property setter, which
    is the alternative, and potentially another for when the underlying `nativeView`
    is ready).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用NativeScript的`Property`类创建几个属性，这将在通过视图绑定属性公开本机视图属性时提供很大的便利。使用`Property`类定义这些属性的一个便利之处在于，这些setter只有在`nativeView`被定义时才会被调用，避免了双重调用属性setter（一个是通过纯JS属性setter，这是另一种选择，可能还有一个是在底层`nativeView`准备就绪时）。
- en: When wanting to expose native view properties that could be bound via your custom
    component, define several `Property` classes for them, referencing the name you'd
    like to use for the view binding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当想要公开可以通过自定义组件绑定的本机视图属性时，为它们定义几个`Property`类，引用您想要用于视图绑定的名称。
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By setting up these `Property` instances, we can now do this in our view component
    class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置这些`Property`实例，我们现在可以在我们的视图组件类中执行以下操作：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will only be invoked once `nativeView` is ready, which is exactly what
    we want. You can read more about this particular syntax and notation in this draft
    written by core team member Alex Vakrilov:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只在`nativeView`准备就绪时调用一次，这正是我们想要的。您可以在核心团队成员Alex Vakrilov撰写的这篇草案中阅读更多关于这种特定语法和符号的信息：
- en: '[https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property](https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property](https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property)。'
- en: 'Then, at the bottom of our class (after it''s defined), we register the class
    with the `Property` instances:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的类底部（在定义之后），我们使用`Property`实例注册类：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Okay, with that explained, let's look at some other elements to this implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，解释到这里，让我们看看这个实现的其他元素。
- en: 'We are also introducing a helpful interface here, which we will apply to `RecordModel`
    in a moment:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这里引入了一个有用的接口，我们将很快应用于`RecordModel`：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will help define a shape for other models to implement, ensuring they
    conform to an API the Waveform display expects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有助于为其他模型定义一个形状，以确保它们符合Waveform显示所期望的API：
- en: '`target`: Defines the key input to be used with the native class.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：定义要与本地类一起使用的关键输入。'
- en: '`dispose()`: Each model should provide this method to handle any clean up when
    the view is destroyed.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispose（）`：每个模型应提供此方法来处理视图销毁时的任何清理工作。'
- en: 'This is the custom NativeScript 3.x View Life cycle call execution order:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义的NativeScript 3.x视图生命周期调用执行顺序：
- en: '`createNativeView()`: `AnyNativeView;`  // Create your native view.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建本地视图（）：AnyNativeView; // 创建您的本地视图。
- en: '`initNativeView()`: `void;`  // Init your native view.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`initNativeView（）`：`void;` // 初始化您的本地视图。'
- en: '`disposeNativeView()`: `void;`  // Clean up your native view.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`disposeNativeView（）`：`void;` // 清理您的本地视图。'
- en: 'The `createNativeView` method overridden from NativeScript''s `View` class
    is likely the most interesting:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从NativeScript的`View`类中覆盖的`createNativeView`方法可能是最有趣的：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we allow the `type` property to determine which type of Waveform display
    it should render.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们允许`type`属性确定应该呈现哪种类型的波形显示。
- en: In the case of `mic`, we utilize AudioKit's `AKNodeOutputPlot` (which actually
    extends `EZAudioPlot` under the hood) to initialize a waveform (that is, `audioplot`)
    using our model's target, which will end up being our RecordModel's microphone.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mic`的情况下，我们利用AudioKit的`AKNodeOutputPlot`（实际上在底层扩展了`EZAudioPlot`）来使用我们模型的目标初始化波形（即`audioplot`），这将最终成为我们的RecordModel的麦克风。
- en: In the case of `file`, we utilize AudioKit's `EZAudioPlot` directly to create
    a static waveform representing an audio file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`file`的情况下，我们直接利用AudioKit的`EZAudioPlot`来创建表示音频文件的静态波形。
- en: The `initNativeView` method, also overridden from NativeScript's `View` class,
    is called second in its life cycle and provides a way to initialize your native
    view. You might find it interesting that we call the setters again here. The setters
    are called first when the component bindings are set via the XML and the class
    instantiates, which is *before* `createNativeView` and `initNativeView` are called.
    This why we cache the values in private references. However, we also want these
    setters to modify `nativeView` with Angular's view bindings (when changed dynamically),
    which is why we also have `if (this.nativeView)` inside the setters to change
    `nativeView` dynamically when available.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`initNativeView` 方法，也是从 NativeScript 的 `View` 类中重写而来，是在其生命周期中第二次被调用的，它提供了一种初始化原生视图的方式。你可能会发现有趣的是，我们在这里再次调用了
    setters。当组件绑定通过 XML 设置并且类实例化时，setters 首先被调用，这是在 `createNativeView` 和 `initNativeView`
    被调用之前。这就是为什么我们在私有引用中缓存这些值。然而，我们也希望这些 setters 在 Angular 视图绑定中修改 `nativeView`（在动态改变时），这就是为什么我们在
    setters 中也有 `if (this.nativeView)` 来在可用时动态改变 `nativeView`。'
- en: The `disposeNativeView` method (you guessed it, also overridden from the `{N}`
    of the `View` class) is called when `View` gets destroyed, which is where we call
    the model's `dispose` method if available.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`disposeNativeView` 方法（你猜对了，也是从 `View` 类的 `{N}` 中重写而来）在 `View` 被销毁时被调用，这是我们调用模型的
    `dispose` 方法的地方（如果可用）。'
- en: Integrate a custom NativeScript view into our Angular app
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义的 NativeScript 视图集成到我们的 Angular 应用中
- en: 'To use our NativeScript Waveform view within Angular, we need to first register
    it. You can do this in the root module, root app component, or another place that
    is initialized at boot time (usually, not in a lazy-loaded module). To be tidy,
    we will register it within `SharedModule` in the same directory, so add the following
    in `app/modules/shared/shared.module.ts`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Angular 中使用我们的 NativeScript 波形视图，我们首先需要注册它。你可以在根模块、根应用组件或者在启动时初始化的其他地方进行注册（通常不是在懒加载的模块中）。为了整洁，我们将在相同目录下的
    `SharedModule` 中注册它，所以在 `app/modules/shared/shared.module.ts` 中添加以下内容：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `registerElement` method allows us to define the name of the Component we
    want to use within Angular components as the first argument, and takes a resolver
    function that should return the NativeScript `View` class to use for it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerElement` 方法允许我们在 Angular 组件中定义要使用的组件的名称作为第一个参数，并且采用一个解析器函数，该函数应该返回要用于它的
    NativeScript `View` 类。'
- en: Let's now use our new `IWaveformModel` and clean up some of `RecordModel` to
    use it, as well as prepare to create our Android implementation next. Let's refactor
    a couple things out of `RecordModel` into a common file to share code between
    our iOS and Android (coming soon!) models.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们的新的 `IWaveformModel`，并清理一些 `RecordModel` 来使用它，同时准备创建我们的 Android 实现。让我们将一些
    `RecordModel` 中的东西重构到一个公共文件中，以便在我们的 iOS 和 Android（即将推出！）模型之间共享代码。
- en: 'Create `app/modules/recorder/models/record-common.ts`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `app/modules/recorder/models/record-common.ts`：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This contains most of what was at the top of `RecordModel`, with the addition
    of the `IRecordModel` interface, which extends `IWaveformModel`. Since we built
    out our iOS implementation, we now have a model shape we would like our Android
    implementation to adhere to. Abstracting that shape into an interface will provide
    us a clear path to follow when we move to Android momentarily.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了大部分 `RecordModel` 顶部的内容，还增加了 `IRecordModel` 接口，它扩展了 `IWaveformModel`。由于我们已经构建了我们的
    iOS 实现，现在我们有了一个我们希望我们的 Android 实现遵循的模型形状。将该形状抽象成一个接口将为我们提供一个清晰的路径，当我们转向 Android
    时，我们可以遵循这个路径。
- en: 'For convenience, let''s also create an index for our models, which would also
    expose this common file, in `app/modules/recorder/models/index.ts`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，让我们还为我们的模型创建一个索引，这也会在 `app/modules/recorder/models/index.ts` 中公开这个公共文件：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now modify `RecordModel` to import these common items, as well as implement
    this new `IRecordModel` interface. Since this new interface also *extends* `IWaveformModel`,
    it will immediately tell us we need to implement the `readonly target`getter and
    the `dispose()`method, as required to be used with our Waveform view:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改`RecordModel`来导入这些常见项，并实现这个新的`IRecordModel`接口。由于这个新接口还*扩展*了`IWaveformModel`，它会立即告诉我们需要实现`readonly
    target`getter和`dispose()`方法，以便与我们的Waveform视图一起使用：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `target` of `RecordModel` will be the microphone that the Waveform view
    will use. Our `dispose` method will stop the AudioKit engine while doing reference
    clean up, as well as ensuring to clean out any temporary files created while recording.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordModel`的`target`将是Waveform视图将使用的麦克风。我们的`dispose`方法将在清理引用的同时停止AudioKit引擎，同时确保清除录制过程中创建的任何临时文件。'
- en: Creating the Recorder View layout
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建录音机视图布局
- en: When the user taps on Record in the top right corner of the app, it prompts
    the user to authenticate, after which the app routes to the record view. Additionally,
    it would be nice to reuse this record view in a modal popup to show when the composition
    contains tracks, so the user doesn't feel like they are leaving the composition
    while recording. However, when the composition is new, it's fine to navigate to
    the record view via routing. We will show how this can be done, but let's first
    set up our layout using the new fancy Waveform view and our powerful new `RecordModel`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击应用程序右上角的“录制”时，它会提示用户进行身份验证，之后应用程序会路由到录制视图。此外，很好地重用这个录制视图作为模态弹出窗口显示，以便在录制时用户不会感觉离开作品。但是，当作品是新的时，通过路由导航到录制视图是可以的。我们将展示如何做到这一点，但首先让我们使用新的时髦Waveform视图和我们强大的新`RecordModel`来设置我们的布局。
- en: 'Add the following to `app/modules/recorder/components/record.component.html`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`app/modules/recorder/components/record.component.html`中：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are using `FlexboxLayout` because we want our Waveform view to stretch to
    cover the full available vertical space, leaving only the recorder's controls
    positioned at the bottom. `FlexboxLayout` is a very versatile layout container,
    which provides most of the same CSS styling attributes found with the the flexbox
    model on the web.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`FlexboxLayout`，因为我们希望我们的Waveform视图能够延伸到覆盖整个可用垂直空间，只留下底部定位的录音机控件。`FlexboxLayout`是一个非常多才多艺的布局容器，它提供了大部分在Web上使用的flexbox模型中找到的相同的CSS样式属性。
- en: Interestingly, we show a Cancel button inside a `GridLayout` container only
    when displayed as a modal, since we need a way to close the modal. ActionBars
    are ignored and not displayed when the view is opened via a modal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们只在显示为模态框时在`GridLayout`容器内显示取消按钮，因为我们需要一种关闭模态框的方式。当通过模态框打开视图时，操作栏将被忽略和不显示。
- en: ActionBars are ignored when the view is opened via a modal, so they are not
    displayed in the modal. `ActionBar` is shown on navigated views only.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过模态框打开视图时，操作栏将被忽略，因此在模态框中不显示。`ActionBar`仅在导航视图上显示。
- en: Furthermore, our `ActionBar` setup is rather interesting here and is one of
    the areas of NativeScript view layouts where iOS and Android differ the most.
    On iOS, `NavigationButton` has a default behavior, that automatically pops the
    view from the stack and animates back to the previous view. Additionally, any
    tap events on `NavigationButton` on iOS are completely ignored, whereas on Android,
    the tap event is triggered on `NavigationButton`. Because of this crucial difference,
    we want to completely ignore `NavigationButton` of `ActionBar` by using `visibility="collapsed"`
    to ensure it is never shown. Instead, we use `ActionItem` with an explicit tap
    event to ensure the correct logic is triggered on our component for both platforms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`ActionBar`设置在这里相当有趣，也是NativeScript视图布局中iOS和Android差异最大的领域之一。在iOS上，`NavigationButton`具有默认行为，会自动从堆栈中弹出视图，并动画返回到上一个视图。此外，在iOS上，对`NavigationButton`的任何点击事件都会被完全忽略，而在Android上，点击事件会在`NavigationButton`上触发。由于这个关键的差异，我们希望完全忽略`ActionBar`的`NavigationButton`，通过使用`visibility="collapsed"`来确保它永远不会显示。相反，我们使用`ActionItem`来确保在两个平台上都触发正确的逻辑。
- en: '`NavigationButton` behavior on iOS and Android is different:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: iOS和Android上的`NavigationButton`行为不同：
- en: '**iOS**: `NavigationButton` ignores (tap) events, and this button appears by
    default when navigating to a view.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**：`NavigationButton`会忽略（点击）事件，并且该按钮在导航到视图时会默认出现。'
- en: '**Android**: `NavigationButton` (tap) events are triggered.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**：`NavigationButton`（点击）事件会被触发。'
- en: You can see our Waveform (the custom NativeScript) view in use here. We use
    Angular's binding syntax when binding the model, since it's an object. For the
    other properties, we specify their values directly, since they are primitive values.
    We could, however, use Angular's binding syntax on those as well if we wanted
    to change those values dynamically via user interaction. For example, we could
    show a fun color picker, which would allow the user to change the color (`plotColor`)
    of the waveform on the fly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到我们使用的波形图（自定义NativeScript）视图。我们在绑定模型时使用Angular的绑定语法，因为它是一个对象。对于其他属性，我们直接指定它们的值，因为它们是原始值。然而，如果我们想通过用户交互动态地改变这些值，我们也可以在这些属性上使用Angular的绑定语法。例如，我们可以显示一个有趣的颜色选择器，允许用户实时更改波形图的颜色（`plotColor`）。
- en: 'We''ll provide a component-specific stylesheet for our record component, `app/modules/recorder/components/record.component.css`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的记录组件提供一个特定于组件的样式表，`app/modules/recorder/components/record.component.css`：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Some of these CSS properties may look familiar if you''ve used the flexbox
    model on the web. A great and fun resource to learn more about flexbox styling
    is Flexbox Zombies by Dave Geddes: [http://flexboxzombies.com](http://flexboxzombies.com.).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网页上使用了flexbox模型，那么其中一些CSS属性可能会看起来很熟悉。了解更多关于flexbox样式的有趣资源是Dave Geddes的Flexbox
    Zombies：[http://flexboxzombies.com](http://flexboxzombies.com)。
- en: At this point, our CSS is starting to grow and we could clean things up a lot
    with SASS. We will do exactly that, coming up soon, so hang in there!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的CSS开始增长，我们可以用SASS清理很多东西。我们很快就会这样做，所以请耐心等待！
- en: 'Now, let''s take a look at the Component at `app/modules/recorder/components/record.component.ts`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`app/modules/recorder/components/record.component.ts`中的组件：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Starting from the bottom of that file, you'll probably wonder what the heck
    `invokeOnRunLoop` is*.* This is a handy way to ensure thread safety in conditions
    where the thread might rear its ugly head. In this case, AudioKit's engine is
    started from the UI thread in `RecordModel`, since NativeScript marshals native
    calls on the UI thread. However, when our record view closes (whether it be from
    a modal our navigating back), some background threads are invoked. Wrapping our
    handling of closing this view with `invokeOnRunLoop` helps solve this transient
    exception. It's the answer to how to use iOS `dispatch_async(dispatch_get_main_queue(…))`
    with NativeScript.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从该文件底部开始，你可能会想知道`invokeOnRunLoop`到底是什么。这是一种方便的方法，可以确保在线程可能出现的情况下保持线程安全。在这种情况下，AudioKit的引擎是从UI线程在`RecordModel`中启动的，因为NativeScript在UI线程上调用本机调用。然而，当我们的记录视图关闭时（无论是从模态还是返回导航），会调用一些后台线程。用`invokeOnRunLoop`包装我们关闭这个视图的处理有助于解决这个瞬态异常。这就是如何在NativeScript中使用iOS
    `dispatch_async(dispatch_get_main_queue(…))`的答案。
- en: 'Working our way up the file, we''ll encounter `this.recorderService.state$.subscribe((state:
    number) => …`. In a moment, we''ll be implementing a way to observe the recording
    `state$` as an observable, so our view can simply react to its state changes.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '在文件中向上工作，我们会遇到`this.recorderService.state$.subscribe((state: number) => …`。一会儿，我们将实现一种观察录音`state$`作为可观察对象的方法，这样我们的视图就可以简单地对其状态变化做出反应。'
- en: Also of note, it is a handy way to collapse `RecordState enum` into properties
    we can use as view bindings to compare against the current state (`this.state
    = state;`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，将`RecordState enum`折叠成我们可以用作视图绑定的属性，以便与当前状态进行比较（`this.state = state;`）。
- en: When the component is constructed, `recorderService.setupNewRecording()` will
    prepare our service for a brand new recording each time this view appears.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被构建时，`recorderService.setupNewRecording()`将为每次出现该视图准备好全新的录音。
- en: 'Lastly, take note of the injection of `@Optional()private params: ModalDialogParams`*.*
    Earlier, we mentioned that *it would be nice to reuse this record view in a modal
    popup*. The interesting part is that `ModalDialogParams` is only provided to a
    component when it is opened in a modal. In other words, Angular''s dependency
    injection doesn''t know anything about a `ModalDialogParams` service unless the
    component is explicitly opened via NativeScript''s `ModalService`, so this would
    break our ability to route to this component as we had originally set up, since
    Angular''s DI would fail to recognize such a provider by default. In order to
    allow this component to continue working as a routing component, we will simply
    mark that argument as `@Optional()`, which will just set its value to null when
    not available instead of throwing a dependency injection error.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，注意注入`@Optional()private params: ModalDialogParams`。之前，我们提到*在模态弹出中重用这个记录视图会很好*。有趣的是，`ModalDialogParams`只在组件以模态方式打开时才提供。换句话说，Angular的依赖注入在默认情况下对`ModalDialogParams`服务一无所知，除非组件是通过NativeScript的`ModalService`明确打开的，因此这将破坏我们最初设置的路由到该组件的能力，因为Angular的DI将无法识别这样的提供者。为了让该组件继续作为路由组件工作，我们只需将该参数标记为`@Optional()`，这样当不可用时它的值将被设置为null，而不是抛出依赖注入错误。'
- en: This will allow our component to be routed to, as well as be opened in a modal!
    Reuse in full swing!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们的组件被路由到，并且以模态方式打开！重复使用正酣！
- en: In order to conditionally navigate to this component via routing, or open it
    in a modal, we can make a few small adjustments, bearing in mind that `RecorderModule`
    is lazy loaded, so we'll want to lazily load the module before opening it as a
    modal.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有条件地通过路由导航到该组件，或者以模态方式打开它，我们可以做一些小的调整，牢记`RecorderModule`是延迟加载的，所以我们希望在打开模态之前懒加载该模块。
- en: 'Open `app/modules/mixer/components/action-bar/action-bar.component.ts` and
    make the following modifications:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/modules/mixer/components/action-bar/action-bar.component.ts`并进行以下修改：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we conditionally emit an event using `EventEmitter` with a Component
    `Output` decorator if the composition contains tracks; otherwise we navigate to
    the record view. We then adjust `Button` in the view template to use the method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`EventEmitter`有条件地发出事件，如果组合包含轨道，则使用组件`Output`装饰器；否则，我们导航到录制视图。然后我们调整视图模板中的`Button`以使用该方法：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now modify `app/modules/mixer/components/mixer.component.html` to use
    `Output` by its name as a normal event:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改`app/modules/mixer/components/mixer.component.html`，通过其名称使用`Output`作为普通事件：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now for the fun part. Since we'd love to be able to open any component in a
    modal, whether it's part of a lazy loaded module or not, let's add a new method
    to `DialogService` that can be used anywhere.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。由于我们希望能够在模态框中打开任何组件，无论它是懒加载模块的一部分还是其他情况，让我们向`DialogService`添加一个新的方法，可以在任何地方使用。
- en: 'Make the following changes to `app/modules/core/services/dialog.service.ts`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对`app/modules/core/services/dialog.service.ts`进行以下更改：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we inject `ModalDialogService` and `NgModuleFactoryLoader` (which is actually `NSModuleFactoryLoader`,
    since, if you recall, we provided for in [Chapter 5](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d),
    *Routing and Lazy Loading*) to load any module on demand to open a Component (declared
    in that lazy loaded module) in a modal. *It also works for components that do
    not need to be lazy loaded*. In other words, it will optionally lazily load any
    module by its path, if provided, and then use its `NgModuleFactory` to get a module
    reference, which we can pass along as an option (via the `moduleRef` key) to `this.modalService.showModal`
    to open a Component declared in that lazily-loaded module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注入`ModalDialogService`和`NgModuleFactoryLoader`（实际上是`NSModuleFactoryLoader`，因为如果你还记得，我们在[第5章](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d)中提供了*路由和懒加载*）以按需加载任何模块以在模态框中打开一个组件（在该懒加载模块中声明）。*它也适用于不需要懒加载的组件*。换句话说，它将按需加载任何模块（如果提供了路径），然后使用其`NgModuleFactory`来获取模块引用，我们可以将其作为选项（通过`moduleRef`键）传递给`this.modalService.showModal`以打开在该懒加载模块中声明的组件。
- en: 'This will come in handy again later; however, let''s put it to use now by making
    the following changes to `app/modules/mixer/components/mixer.component.ts`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在以后再次派上用场；然而，让我们通过对`app/modules/mixer/components/mixer.component.ts`进行以下更改来立即使用它：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will lazily load `RecorderModule` and then open `RecordComponent` in a
    popup modal. Cool!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将懒加载`RecorderModule`，然后在弹出模态框中打开`RecordComponent`。酷！
- en: Finishing implementation with RecorderService
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RecorderService完成实现
- en: 'Now, let''s finish this implementation with `RecorderService` in `app/modules/recorder/services/recorder.service.ts`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`app/modules/recorder/services/recorder.service.ts`中完成对`RecorderService`的实现：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The pinnacle of our recording service is its ability to react to the model''s
    state changes. This, in turn, emits an Observable stream notifying observers (our
    `RecordComponent`) when the state changes, as well as internally doing the work
    necessary to control `RecordModel` along with `PlayerService`. The critical key
    to our design is we want our active composition''s tracks to play in the background
    while we record, so we can play along with the mix. This case is important:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们录制服务的顶峰是它能够对模型状态的变化做出反应。反过来，这会发出一个Observable流，通知观察者（我们的`RecordComponent`）状态的变化，同时在内部完成必要的工作来控制`RecordModel`以及`PlayerService`。我们设计的关键是，我们希望我们活跃的组合轨道在我们录制时能够在后台播放，这样我们就可以跟着混音一起演奏。这种情况很重要：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When `RecordModel` is `readyToPlay`, we know that a recording has been created
    and is now ready to play. We stop the playing mix, get a reference to the recorded
    file''s path. Then, we update `PlayerService` to queue up this new track to be
    played back. We will show the updated `PlayerService` in a moment, which handles
    adding the new file to the mix, but it adds a new `TrackPlayer` like everything
    else in our mix. However, the file points to a temporary recorded file at the
    moment, as we don''t want to save the composition until the user decides to officially
    commit and save the recording. The recording session will allow the user to re-record
    again if they are not happy with the recording. This is why we hold a reference
    to `_trackId`. If a recording had already been added to the mix, we use that `_trackId`
    to exclude it when re-recording, since we would not want to hear back the recording
    we are re-recording over:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当`RecordModel`准备好播放时，我们知道已经创建了一个录音并且现在可以播放。我们停止播放混音，获取录制文件路径的引用。然后，我们更新`PlayerService`以将这个新的音轨加入播放队列。我们将在稍后展示更新后的`PlayerService`，它处理将新文件添加到混音中，但它像混音中的其他所有内容一样添加了一个新的`TrackPlayer`。但是，该文件目前指向临时录制文件，因为我们不希望在用户决定正式提交和保存录音之前保存该组合。录音会话将允许用户在不满意录音时重新录制。这就是为什么我们保存对`_trackId`的引用。如果录音已经添加到混音中，我们将使用该`_trackId`来排除它，以便在重新录制时不播放该录音：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also use it to clean up after ourselves if the user chose to cancel instead
    of saving:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用它来在用户选择取消而不是保存时进行清理：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s take a look at the modifications to `PlayerService` we need to make
    in order to support our recording:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要对`PlayerService`进行的修改，以支持我们的录音：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These changes will support our recorder's ability to interact with the active
    composition.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将支持我们的录音机与活动组合进行交互的能力。
- en: 'Note: Considerations when reusing a Component to lazy load in a modal as well
    as allow lazy loading via routing.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在重用组件以通过路由进行惰性加载的同时，也允许在模态框中进行惰性加载时的考虑事项。
- en: 'Angular services must be provided *only* at the *root* level *if they are intended
    to be singletons* shared across all lazy loaded modules, as well as the root module.
    `RecorderService` is lazy loaded with `RecordModule` when it is navigated to,
    as well as being opened in a modal. Since we are now injecting `PlayerService`
    into our `RecorderService` (which is lazily loaded) and `PlayerService` now injects
    `MixerService` (which is also lazily loaded as the root route in our app), we
    will have to create a problem where our services are no longer singletons. In
    fact, you may even see an error like this if you were to try and navigate to `RecordComponent`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Angular服务必须仅在根级别提供，如果它们旨在成为单例并跨所有惰性加载模块以及根模块共享。`RecorderService`在导航到`RecordModule`时进行惰性加载，同时也在模态框中打开。由于我们现在将`PlayerService`注入到我们的`RecorderService`中（它是惰性加载的），并且`PlayerService`现在注入`MixerService`（它也是我们应用程序中根路由的惰性加载），我们将会遇到一个问题，即我们的服务不再是单例。实际上，如果您尝试导航到`RecordComponent`，您甚至可能会看到这样的错误：
- en: 'JS: ERROR Error: Uncaught (in promise): Error: No provider for PlayerService!'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JS：错误错误：未捕获的（在承诺中）：错误：PlayerService的无提供者！
- en: 'To solve this, we will drop the providers from `PlayerModule` and `MixerModule`
    (since those modules are both lazily loaded) and instead provide those services
    only in our `CoreModule`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将从`PlayerModule`和`MixerModule`中删除提供者（因为这些模块都是惰性加载的），并且只在我们的`CoreModule`中提供这些服务：
- en: 'The modified `app/modules/player/player.module.ts` is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的`app/modules/player/player.module.ts`如下：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The modified `app/modules/mixer/mixer.module.ts` is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的`app/modules/mixer/mixer.module.ts`如下：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Updated to provide these services as true singletons from `CoreModule` only,
    the code for `app/modules/core/core.module.ts` is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从`CoreModule`中提供这些服务作为真正的单例，`app/modules/core/core.module.ts`的代码如下：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is how you can solve these types of issues; but, this is exactly the reason
    why we recommend using Ngrx in  [Chapter 10](https://cdp.packtpub.com/mastering_nativescript_mobile_development/wp-admin/post.php?post=104&action=edit#post_361), *@ngrx/store
    + @ngrx/effects for State Management*, coming up soon, as it can help alleviate
    these dependency injection issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以解决这些问题的方法；但是，这正是我们建议在[第10章](https://cdp.packtpub.com/mastering_nativescript_mobile_development/wp-admin/post.php?post=104&action=edit#post_361)中使用Ngrx的原因，*@ngrx/store
    + @ngrx/effects for State Management*，即将到来，因为它可以帮助缓解这些依赖注入问题。
- en: At this point, our setup works nicely; but, it can be greatly improved and even
    simplified when we start integrating ngrx for a more Redux-style architecture.
    We have done a few reactive things here, such as our `RecordComponent` reacting
    to our service's `state$` observable; but, we needed to inject `MixerService`
    into `PlayerService`, which feels slightly wrong architecturally, since `PlayerModule`
    should not really have a dependency on anything `MixerModule` provides. Again,
    *this technically works just fine,* but when we start working with ngrx in [Chapter
    10](part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d), *@ngrx/store + @ngrx/effects
    for State Management*, you'll see how we can reduce our dependency mixing throughout
    the whole codebase.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的设置运行良好；但是，当我们开始集成ngrx以实现更简化的Redux风格架构时，它可以得到极大改进甚至简化。在这里，我们已经做了一些响应式的事情，比如我们的`RecordComponent`对我们服务的`state$`可观察对象做出反应；但是，我们需要将`MixerService`注入到`PlayerService`中，从架构上来说这有点不太对，因为`PlayerModule`实际上不应该依赖于`MixerModule`提供的任何东西。再次强调，*这在技术上是完全正常的*，但是当我们在[第10章](part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d)开始使用ngrx时，*@ngrx/store
    + @ngrx/effects for State Management*，您将看到我们如何在整个代码库中减少依赖混合。
- en: 'Let''s take a moment though, relax, and pat ourselves on the back, as this
    has been an impressive amount of work. Take a look at what the fruits of our labor
    are producing:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍作休息，为自己的工作感到自豪，因为这已经是一项令人印象深刻的工作量。看看我们的劳动成果产生了什么：
- en: '![](../images/00038.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00038.jpeg)'
- en: Phase 2 – Building an audio recorder for Android
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二阶段 - 为Android构建音频录制器
- en: 'Believe it or not we''ve actually done most of the heavy lifting to make this
    work on Android already! That''s the beauty of NativeScript. Designing an API
    that makes sense, as well as an architecture that can plug/play underlying native
    APIs, is key to NativeScript development. At this point, we just need to plug
    in the Android pieces into the shape we have designed. So, to summarize, we now
    have the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们实际上已经完成了让这项工作在Android上运行的大部分工作！这就是NativeScript的美妙之处。设计一个有意义的API，以及一个可以插入/播放底层原生API的架构，对于NativeScript的开发至关重要。在这一点上，我们只需要将Android部分插入到我们设计的形状中。因此，总结一下，我们现在有以下内容：
- en: '`RecorderService` that works in tandem with `PlayerService` to coordinate our
    multitrack handling abilities'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecorderService`与`PlayerService`协调我们的多轨处理能力'
- en: A Waveform view that is flexible and ready to provide an Android implementation
    under the hood
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个灵活且准备在幕后提供Android实现的波形视图
- en: '`RecordModel` that should tap into the appropriate underlying target platform
    APIs and be ready for Android details to be plugged into'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecordModel`应该与适当的底层目标平台API进行连接，并准备好插入Android细节'
- en: Built interfaces defining the shape of the model, for Android models to simply
    implement to know which API they should define
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建定义模型形状的接口，供Android模型简单实现以了解它们应该定义哪些API
- en: Let's get to work.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作吧。
- en: 'We want to rename `record.model.ts` to `record.model.ios.ts`, since it''s specific
    to iOS, but before doing so, we will want a TypeScript definition file (`.d.ts`)
    for it, so our codebase can continue importing as `''record.model''`. There are
    several ways this could be done, including just manually writing one out. However,
    the tsc compiler has a handy `-d` flag, which will generate definition files for
    us:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将`record.model.ts`重命名为`record.model.ios.ts`，因为它是特定于iOS的，但在这样做之前，我们希望为它生成一个TypeScript定义文件（`.d.ts`），以便我们的代码库可以继续导入为`'record.model'`。有几种方法可以做到这一点，包括手动编写一个。然而，tsc编译器有一个方便的`-d`标志，它将为我们生成定义文件：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will spit out a ton of TypeScript warnings and errors; but, it doesn't
    matter in this case, since our definition file will be generated correctly. We
    don't need to generate JavaScript, just the definition, so you can ignore the
    wall of issues that results.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生大量的TypeScript警告和错误；但在这种情况下并不重要，因为我们的定义文件将被正确生成。我们不需要生成JavaScript，只需要定义，因此您可以忽略产生的问题。
- en: 'We now have two new files:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个新文件：
- en: '`record-common.model.d.ts` (*you can delete this as we won''t need it*)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`record-common.model.d.ts`（*您可以删除这个文件，因为我们不需要它*）'
- en: '`record.model.d.ts`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`record.model.d.ts`'
- en: 'The `record-common.model` file is imported by `RecordModel`, which is why a
    definition was generated for it as well; but, you can *delete* that. Now, we have
    the definition file, but we want to modify it slightly. We don''t need any of
    the `private` declarations and/or any native types it included; you would notice
    it contained the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`record-common.model`文件被`RecordModel`导入，这就是为什么为它生成了一个定义；但是，您可以*删除*它。现在，我们有了定义文件，但我们希望稍微修改它。我们不需要任何`private`声明和/或任何包含的本地类型；您会注意到它包含了以下内容：'
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since those are iOS-specific, we''ll want to type those as *any*, so it''s
    applicable to both iOS and Android. This is what things look like with our modifications:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是特定于iOS的，我们希望将它们类型化为*any*，以便适用于iOS和Android。这就是我们修改后的样子：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Perfect, now rename `record.model.ts` to `record.model.ios.ts`. We have now
    finalized our iOS implementation, as well as ensured maximum code reuse to turn
    our focus to Android. NativeScript will use the target platform suffix files at
    build time, so you don't ever need to worry that iOS-only code would end up on
    Android and vice versa.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将`record.model.ts`重命名为`record.model.ios.ts`。我们现在已经完成了iOS的实现，并确保了最大程度的代码重用，以便将我们的重点转向Android。NativeScript将在构建时使用目标平台后缀文件，因此您永远不需要担心仅适用于iOS的代码会出现在Android上，反之亦然。
- en: The `.d.ts` definition file we generated previously will be used at JavaScript
    transpilation time by the TypeScript compiler, whereas the runtime will use the
    platform-specific JS files (without the extension).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前生成的`.d.ts`定义文件将在JavaScript转译时由TypeScript编译器使用，而运行时将使用特定于平台的JS文件（不带扩展名）。
- en: 'Okay, now create `app/modules/recorder/models/record.model.android.ts`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在创建`app/modules/recorder/models/record.model.android.ts`：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This may look a whole lot like the iOS side, and that's because it will be nearly
    the same! In fact, this setup works great, so now we just want to fill in the
    Android specifics.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能与iOS端非常相似，这是因为它几乎相同！事实上，这个设置非常好，所以现在我们只需要填写Android的具体内容。
- en: Using nativescript-audio's TNSRecorder for Android in our RecordModel
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的RecordModel中使用nativescript-audio的TNSRecorder来处理Android
- en: 'We could use some fancy Android APIs and/or libraries for our recorder, but
    in this case, the **nativescript-audio** plugin we''re using for our cross-platform
    multitrack player also provides a cross-platform recorder. We could have even
    used it with iOS, but we wanted to specifically work with AudioKit''s powerful
    APIs there. However, here on Android, let''s use the recorder from the plugin
    and make the following modifications to `record.model.android.ts`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些花哨的Android API和/或库来进行录制，但在这种情况下，我们用于跨平台多轨播放器的**nativescript-audio**插件也提供了跨平台的录音机。我们甚至可以在iOS上使用它，但我们想要专门在那里使用AudioKit强大的API。然而，在Android上，让我们使用插件中的录音机，并对`record.model.android.ts`进行以下修改：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Wow! Okay, a lot of interesting things going on here. Let''s get one necessary
    thing out of the way for Android and ensure for API level 23+ that permissions
    are properly handled. For this, you can install the permissions plugin:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！好的，这里发生了很多有趣的事情。让我们先为Android解决一个必要的问题，并确保在API级别23+上正确处理权限。为此，您可以安装权限插件：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We also want to ensure our manifest file contains the proper permission key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保我们的清单文件包含正确的权限键。
- en: 'Open `app/App_Resources/Android/AndroidManifest.xml` and add the following
    in the correct place:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/App_Resources/Android/AndroidManifest.xml`，并在正确的位置添加以下内容：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We use the nativescript-audio plugin's `TNSRecorder` as our implementation and
    wire things up accordingly to its API. `AudioRecorderOptions` provides a `metering`
    option, allowing the ability to monitor the microphone's meters via an interval.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用nativescript-audio插件的`TNSRecorder`作为我们的实现，并相应地连接它的API。`AudioRecorderOptions`提供了一个`metering`选项，允许通过间隔监视麦克风的仪表。
- en: What is most versatile about our overall design is that our model's target can
    literally be anything. In this case, we create a RxJS Subject observable as `_target$`,
    which is then returned as our target getter. This allows us to emit the microphone's
    meter value through the `Subject` observable for consumption by our Waveform.
    You will see in a moment how we will take advantage of this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整体设计最灵活的地方是我们的模型的目标可以是任何东西。在这种情况下，我们创建了一个RxJS Subject可观察对象作为`_target$`，然后将其作为我们的目标getter返回。这允许我们通过`Subject`可观察对象发出麦克风的仪表值，以供我们的波形消费。您很快就会看到我们将如何利用这一点。
- en: We are now ready to move on to our Waveform implementation for Android.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始为Android实现我们的波形。
- en: Just like we did for the model, we will want to refactor the common bits into
    a shared file and handle the suffix.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为模型做的那样，我们希望将共同的部分重构到一个共享文件中，并处理后缀。
- en: 'Create `app/modules/shared/native/waveform-common.ts`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`app/modules/shared/native/waveform-common.ts`：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, just adjust `app/modules/shared/native/waveform.ts` to use it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需调整`app/modules/shared/native/waveform.ts`来使用它：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Before renaming our waveform to contain an `.ios` suffix, let''s generate a
    TypeScript definition file for it first:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的波形重命名为`.ios`后缀之前，让我们首先为其生成一个TypeScript定义文件：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You may again see TypeScript errors or warnings, but we don''t need to worry
    about those, as it should have still generated a `waveform.d.ts` file. Let''s
    simplify it slightly to contain only the parts that are applicable to both iOS
    and Android:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会再次看到TypeScript错误或警告，但我们不需要担心这些，因为它应该仍然生成了一个`waveform.d.ts`文件。让我们稍微简化一下，只包含适用于iOS和Android的部分：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Okay, now, rename `waveform.ts` to `waveform.ios.ts` and create `app/modules/shared/native/waveform.android.ts`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，将`waveform.ts`重命名为`waveform.ios.ts`并创建`app/modules/shared/native/waveform.android.ts`：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Okay, excellent! This is the barebones setup we will need, *but what native
    Android view should we use?*
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太棒了！这是我们需要的基本设置，*但是我们应该使用什么原生Android视图？*
- en: 'If you''re looking around for open source Android libs, you may come across
    a group of very talented developers with **Yalantis**, a fantastic mobile development
    company based out of Ukraine. Roman Kozlov and his team created an open source
    project, **Horizon**, which provides beautiful audio visualizations:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找开源Android库，您可能会遇到一个来自乌克兰的**Yalantis**非常有才华的开发团队。Roman Kozlov和他的团队创建了一个名为**Horizon**的开源项目，提供了美丽的音频可视化：
- en: '[https://github.com/Yalantis/Horizon](https://github.com/Yalantis/Horizon)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Yalantis/Horizon](https://github.com/Yalantis/Horizon)'
- en: '[https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/](https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/](https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/)'
- en: 'Just like for iOS, we also want to prepare for a multifaceted Waveform view
    that can also render a static waveform for just a file. Looking further through
    the open source options, we may come across another wonderfully talented team
    with **Semantive**, based in Warsaw, the sprawling capital of Poland. They created
    an incredibly powerful Waveform view for Android:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在iOS上一样，我们还希望为多功能的波形视图做好准备，它还可以为单个文件渲染静态波形。在查看开源选项时，我们可能会遇到另一个位于波兰首都华沙的**Semantive**团队，他们创建了一个非常强大的Android波形视图：
- en: '[https://github.com/Semantive/waveform-android](https://github.com/Semantive/waveform-android)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Semantive/waveform-android](https://github.com/Semantive/waveform-android)'
- en: Let's integrate both of these libraries for our Android Waveform integration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的Android波形集成整合这两个库。
- en: 'Similar to how we integrated AudioKit for iOS, let''s create a folder in the
    root called `android-waveform-libs` with the following setup, that provides `include.gradle`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在iOS上集成AudioKit的方式类似，让我们在根目录下创建一个名为`android-waveform-libs`的文件夹，并进行以下设置，提供`include.gradle`：
- en: '![](../images/00039.jpeg)Why deviate from the `nativescript-` prefix when including
    native libs?'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00039.jpeg)在包含本地库时，为什么要偏离`nativescript-`前缀？'
- en: The prefix is a good way to go if you plan to refactor the internal plugin into
    an open source plugin published via npm for the community down the road, using
    [https://github.com/NathanWalker/nativescript-plugin-seed](https://github.com/NathanWalker/nativescript-plugin-seed)
    for instance.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划将内部插件重构为未来通过npm发布给社区的开源插件，例如使用[https://github.com/NathanWalker/nativescript-plugin-seed](https://github.com/NathanWalker/nativescript-plugin-seed)，那么前缀是一个不错的选择。
- en: Sometimes, you just need to integrate several native libs for a specific platform,
    as we are in this case, so we don't really need the `nativescript-` prefix on
    our folder.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您只需要为特定平台集成几个本地库，就像我们在这种情况下一样，因此我们实际上不需要在我们的文件夹上使用`nativescript-`前缀。
- en: 'We make sure to add `package.json`, so we can add these native libs like we
    would any other plugin:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保添加`package.json`，这样我们就可以像添加任何其他插件一样添加这些本地库：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we simply add them as a plugin to our project:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将它们作为插件添加到我们的项目中：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are now ready to integrate these libs into our Waveform view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将这些库整合到我们的波形视图中。
- en: 'Let''s make the following modifications to the `app/modules/shared/native/waveform.android.ts` file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`app/modules/shared/native/waveform.android.ts`文件进行以下修改：
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We begin our Android implementation by defining the `const` references to the
    various packaged classes we need to access, to alleviate having to reference the
    fully qualified package location each time in our Waveform. Just like on the iOS
    side, we design a dual-purpose Waveform by allowing the type (`'mic'` or `'file'`)
    to drive which rendering to use. This allows us to reuse this with our record
    view for real-time microphone visualization and the other to statically render
    our tracks as Waveforms (more on that soon!).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义对各种打包类的`const`引用来开始我们的Android实现，以减轻我们在Waveform中每次都需要引用完全限定的包位置。就像在iOS端一样，我们通过允许类型（`'mic'`或`'file'`）来驱动使用哪种渲染，设计了一个双重用途的Waveform。这使我们能够在实时麦克风可视化的录制视图中重用它，并在其他情况下静态地渲染我们的轨道作为Waveforms（很快会详细介绍更多！）。
- en: 'The Horizon lib utilizes Android''s `GLSurfaceView` as the primary rendering,
    hence:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Horizon库利用Android的`GLSurfaceView`作为主要渲染，因此：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: During development, we found that `GLSurfaceView` requires at least a height
    to constrain it, otherwise it would render at full screen height. Therefore, we
    explicitly set a reasonable `height` of `200` to the custom NativeScript view,
    which will automatically handle measuring the native view for us. Interestingly,
    we also found that sometimes our model setter would fire *before* `initNativeView`
    and other times *after*. Because the model is a critical binding for initializing
    our Horizon view, we designed a custom internal `_initView` method with the appropriate
    conditional, which could be called from `initNativeView`, as well as after our
    model setter fired. The condition (`!this._initialized && this.nativeView && this.model`)
    ensures it's only ever initialized once though. This is the way to handle any
    potential race conditions around the sequence of these method calls.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们发现`GLSurfaceView`至少需要一个高度来限制它，否则它会以全屏高度渲染。因此，我们明确地为自定义的NativeScript视图设置了一个合理的`height`为`200`，这将自动处理测量原生视图。有趣的是，我们还发现有时我们的模型setter会在`initNativeView`之前触发，有时会在之后触发。因为模型是初始化我们Horizon视图的关键绑定，我们设计了一个带有适当条件的自定义内部`_initView`方法，它可以从`initNativeView`中调用，也可以在我们的模型setter触发后调用。条件（`!this._initialized
    && this.nativeView && this.model`）确保它只被初始化一次。这是处理这些方法调用顺序可能存在的潜在竞争条件的方法。
- en: 'The native `Horizon.java` class provides an `update` method that expects a
    Java byte array with a signature:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本地的`Horizon.java`类提供了一个`update`方法，它期望一个带有签名的Java字节数组：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'What we do in NativeScript for this is retain a reference to a construct that
    will represent this native Java byte array with the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在NativeScript中，我们保留了一个代表这个本地Java字节数组的构造的引用，如下所示：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Utilizing Android's `android.media.AudioRecord` class, in conjunction with the
    various recorder settings that we set up, we are able to gather an initial `bufferSize`,
    that we use to initialize our byte array size.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Android的`android.media.AudioRecord`类，结合我们设置的各种录音机设置，我们能够收集一个初始的`bufferSize`，我们用它来初始化我们的字节数组大小。
- en: 'We then take advantage of our overall versatile design, wherein our model''s
    target in this implementation is an rxjs Subject Observable, allowing us to subscribe
    to its event stream. For the `''mic''` type, this stream will be the metering
    value changes from the recorder, which we use to fill our byte array and in turn
    update the `Horizon` view:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们利用我们全面多才多艺的设计，这个实现中我们模型的目标是一个rxjs Subject Observable，允许我们订阅其事件流。对于`'mic'`类型，这个流将是来自录音机的测量值变化，我们用它来填充我们的字节数组，进而更新`Horizon`视图：
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This provides our recorder a nice visualization, which will animate as the
    input level changes. Here''s a preview; however, the style is still a little ugly,
    since we have not applied any CSS polish just yet:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的录音机提供了一个很好的可视化，随着输入电平的变化而产生动画效果。这是一个预览；然而，由于我们还没有应用任何CSS样式，所以风格仍然有点丑陋：
- en: '![](../images/00040.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00040.jpeg)'
- en: For our static audio file waveform rendering, we initialize `WaveformView` with
    the Android context. We then use its API to configure it for our use during construction
    in `createNativeView`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的静态音频文件波形渲染，我们使用Android上下文初始化`WaveformView`。然后我们在`createNativeView`中使用其API来配置它以供我们使用。
- en: 'During initialization, we create an instance of `CheapSoundFile` as required
    by `WaveformView`, and interestingly, we use `setSoundFile` inside `setTimeout`,
    alongside a call to `this.nativeView.invalidate()`, which is calling invalidate
    on `WaveformView`. This causes the native view to update with the processed file,
    as follows (again, we will address the styling polish later):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化期间，我们根据`WaveformView`的要求创建一个`CheapSoundFile`的实例，有趣的是，我们在`setTimeout`中使用`setSoundFile`，并调用`this.nativeView.invalidate()`，这会在`WaveformView`上调用invalidate。这将导致本机视图使用处理后的文件进行更新，如下（同样，我们稍后将解决样式问题）：
- en: '![](../images/00041.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00041.jpeg)'
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced a wealth of powerful concepts and techniques on
    how to work with native APIs on iOS and Android. Knowing how to work with open
    source native libraries is fundamental to getting the most out of your app development
    and achieving the feature set you are after. Direct access to these APIs right
    from TypeScript gives you the luxury of never leaving your preferred development
    environment, as well as engaging with the languages you love in a fun and accessible
    way.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何在iOS和Android上使用本机API的丰富强大的概念和技术。了解如何使用开源本机库对于充分利用应用程序开发并实现所需的功能集是至关重要的。直接从TypeScript访问这些API使您可以在不离开首选开发环境的情况下，以有趣和易于访问的方式使用您喜爱的语言。
- en: Additionally, learning solid practices around how/when to create custom NativeScript
    views and interworking them throughout your Angular app are among the key elements
    to leverage the most of this tech stack.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，学习围绕何时/如何创建自定义NativeScript视图以及如何在整个Angular应用程序中进行交互的良好实践是利用这种技术栈的关键要素之一。
- en: In the next chapter, we will provide some extra goodies by empowering our track
    list view with more bells and whistles, leveraging some of what you've learned
    here.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过为我们的曲目列表视图提供更多功能，利用您在这里学到的一些内容，为您提供一些额外的好处。
