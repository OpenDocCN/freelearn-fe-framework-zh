- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start by understanding what TypeScript is and how it
    provides a much richer type system on top of JavaScript. We will learn about the
    basic types in TypeScript, such as numbers and strings, and then learn how to
    create our own types to represent objects and arrays using different TypeScript
    features. Finally, we will finish the chapter by understanding the TypeScript
    compiler and its key options in a React app.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll be ready to learn how to use TypeScript to
    build frontends with React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding JavaScript types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using basic TypeScript types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating TypeScript types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the TypeScript compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser**: A modern browser such as Google Chrome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeScript Playground**: This is a website at https://www.typescriptlang.org/play/
    that allows you to play around with and understand the features of TypeScript
    without installing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CodeSandbox**: We’ll briefly use this online tool to explore JavaScript’s
    type system. This can be found at [https://codesandbox.io/](https://codesandbox.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: We’ll need an editor to experience TypeScript’s benefits
    and explore the TypeScript compiler. This one can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    Other editors that could be used can be found at [https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js** and **npm**: TypeScript is dependent on these pieces of software.
    You can install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found online at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter2](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter2).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start by understanding what TypeScript is, how it relates
    to JavaScript, and how TypeScript enables teams to be more productive.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript was first released in 2012 and is still being developed, with new
    releases happening every few months. But what is TypeScript, and what are its
    benefits?
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is often referred to as a superset or extension of JavaScript because
    any feature in JavaScript is available in TypeScript. Unlike JavaScript, TypeScript
    can’t be executed directly in a browser – it must be transpiled into JavaScript
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth being aware that a proposal is being considered that *would* allow
    TypeScript to be executed directly in a browser without transpilation. See the
    following link for more information: [https://github.com/tc39/proposal-type-annotations](https://github.com/tc39/proposal-type-annotations).'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript adds a rich type system to JavaScript. It is generally used with
    frontend frameworks such as Angular, Vue, and React. TypeScript can also be used
    to build a backend with Node.js. This demonstrates how flexible TypeScript’s type
    system is.
  prefs: []
  type: TYPE_NORMAL
- en: When a JavaScript codebase grows, it can become hard to read and maintain. TypeScript’s
    type system solves this problem. TypeScript uses the type system to allow code
    editors to catch type errors as developers write problematic code. Code editors
    also use the type system to provide productivity features such as robust code
    navigation and code refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will step through an example of how TypeScript catches an error that
    JavaScript can’t.
  prefs: []
  type: TYPE_NORMAL
- en: Catching type errors early
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type information helps the TypeScript compiler catch type errors. In code
    editors such as Visual Studio Code, a type error is underlined in red immediately
    after the developer has made a type mistake. Carry out the following steps to
    experience an example of TypeScript catching a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio Code in a folder of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file called `calculateTotalPrice.js` by choosing the **New File**
    option in the **EXPLORER** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Creating a new file in Visual Studio Code](img/B19051_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Creating a new file in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the code snippets are available online to copy. The link to the
    previous snippet can be found at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section1-Understanding-TypeScript/calculateTotalPrice.js](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section1-Understanding-TypeScript/calculateTotalPrice.js).
  prefs: []
  type: TYPE_NORMAL
- en: There is a bug in the code that might be difficult to spot, and the error won’t
    be highlighted by Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Now create a copy of the file but with a `.ts` extension instead of `.js`. A
    file can be copied by right-clicking on the file in the **EXPLORER** panel and
    selecting the **Copy** option. Then right-click the **EXPLORER** panel again and
    select the **Paste** option to create the copied file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A `.ts` file extension denotes a TypeScript file. This means a TypeScript compiler
    will perform type checking on this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `calculateTotalPrice.ts` file, remove the `JS` from the end of the function
    name and make the following highlighted updates to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have added TypeScript `function` parameters. We will learn about type
    annotations in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point is that the type error is now highlighted by a red squiggly underline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Highlighted type error](img/B19051_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Highlighted type error
  prefs: []
  type: TYPE_NORMAL
- en: The bug is that the function references a `price` property in the product object
    that doesn’t exist. The property that should be referenced is `unitPrice`.
  prefs: []
  type: TYPE_NORMAL
- en: Catching these problems early in the development process increases the team’s
    throughput and is one less thing for quality assurance to catch. It could be worse
    – the bug could have gotten into the live app and given users a bad experience.
  prefs: []
  type: TYPE_NORMAL
- en: Keep these files open in Visual Studio Code because we will run through an example
    of TypeScript improving the developer experience next.
  prefs: []
  type: TYPE_NORMAL
- en: Improving developer experience and productivity with IntelliSense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IntelliSense** is a feature in code editors that gives useful information
    about elements of code and allows code to be quickly completed. For example, IntelliSense
    can provide the list of properties available in an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Carry out the following steps to experience how TypeScript works better with
    IntelliSense than JavaScript and how this positively impacts productivity. As
    part of this exercise, we will fix the price bug from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `calculateTotalPrice.js` and on line 2, where `product.price` is referenced,
    remove `price`. Then, with the cursor after the dot (`.`), click *Ctrl* + spacebar.
    This opens Visual Studio Code’s IntelliSense:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – IntelliSense in a JavaScript file](img/B19051_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – IntelliSense in a JavaScript file
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code can only guess the potential property name, so it lists variable
    names and function names it has seen in the file. Unfortunately, IntelliSense
    doesn’t help in this case because the correct property name, `unitPrice`, is not
    listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `calculateTotalPrice.ts`, remove `price` from `product.price`, and
    press *Ctrl* + spacebar to open IntelliSense again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – IntelliSense in a TypeScript file](img/B19051_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – IntelliSense in a TypeScript file
  prefs: []
  type: TYPE_NORMAL
- en: This time, Visual Studio Code lists the correct properties.
  prefs: []
  type: TYPE_NORMAL
- en: Select **unitPrice** from IntelliSense to resolve the type error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliSense is just one tool that TypeScript provides. It can also provide
    robust refactoring features, such as renaming React components, and helps with
    accurate code navigation, such as going to a function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap what we learned in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s type-checking feature helps catch problems earlier in the development
    process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript enables code editors to offer productivity features such as IntelliSense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advantages provide significant benefits when working in larger codebases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will learn about the type system in JavaScript. This will further underline
    the need for TypeScript in a large codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaScript types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before understanding the type system in TypeScript, let’s briefly explore the
    type system in JavaScript. To do this, open the CodeSandbox at [https://codesandbox.io/](https://codesandbox.io/)
    and carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new plain JavaScript project by choosing the **Vanilla** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `index.js`, remove its content, and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code assigns three variables to various values. The code also outputs the
    variable values to the console, along with their JavaScript type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Some JavaScript types](img/B19051_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Some JavaScript types
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t surprising that `firstName` is a string and `score` is a number. However,
    it is a little surprising that `date` is an object rather than something more
    specific such as a date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add another couple of lines of code after the existing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, the console output is a little surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Variable changing type](img/B19051_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Variable changing type
  prefs: []
  type: TYPE_NORMAL
- en: The `score` variable has changed from a `number` type to a `string` type! This
    is because JavaScript is loosely typed.
  prefs: []
  type: TYPE_NORMAL
- en: A key point is that JavaScript only has a minimal set of types, such as `string`,
    `number`, and `boolean`. It is worth noting that all of the JavaScript types are
    available in TypeScript because Typescript is a superset of Javascript.
  prefs: []
  type: TYPE_NORMAL
- en: Also, JavaScript allows a variable to change its type – meaning that the JavaScript
    engine won’t throw an error if a variable is changed to a completely different
    type. This loose typing makes it impossible for code editors to catch type errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on JavaScript types, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the limitations of the type system in JavaScript, we
    will learn about TypeScript’s type system, starting with basic types.
  prefs: []
  type: TYPE_NORMAL
- en: Using basic TypeScript types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll start by understanding how TypeScript types can be declared
    and how they are inferred from assigned values. We will then learn the basic types
    commonly used in TypeScript that aren’t available in JavaScript and understand
    helpful use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Using type annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript type annotations enable variables to be declared with specific types.
    These allow the TypeScript compiler to check that the code adheres to these types.
    In short, type annotations allow TypeScript to catch bugs where our code uses
    the wrong type much earlier than we would if we were writing our code in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the TypeScript Playground at [https://www.typescriptlang.org/play](https://www.typescriptlang.org/play)
    and carry out the following steps to explore type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove any existing code in the left-hand pane and enter the following variable
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The type annotation comes after the variable declaration. It starts with a colon
    followed by the type we want to assign to the variable. In this case, `unitPrice`
    is going to be a `number` type. Remember that `number` is a type in JavaScript,
    which means that it is available for us to use in TypeScript too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transpiled JavaScript appears on the right-hand side as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, notice that the type annotation has disappeared. This is because type
    annotations don’t exist in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may also see `"use strict";` at the top of the transpiled JavaScript. This
    means that the JavaScript will be executed in JavaScript strict mode, which will
    pick up more coding mistakes. For more information on JavaScript strict mode,
    see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a second line to the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that a red line appears under `unitPrice` on this line. If you hover
    over the underlined `unitPrice`, a type error is described:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – A type error being caught](img/B19051_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – A type error being caught
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add type annotations to function parameters and a function’s return
    value using the same syntax as annotating a variable. As an example, enter the
    following function in the TypeScript Playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve declared the `unitPrice`, `quantity`, and `discount` parameters, all with
    a `number` type. The return type annotation comes after the function’s parentheses,
    which is also a `number` type in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have used both `const` and `let` to declare variables in different examples.
    `let` allows the variable to change the value after the declaration, whereas `const`
    variables can’t change. In the preceding function, `priceWithoutDiscount` and
    `discountAmount` never change the value after the initial assignment, so we have
    used `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another line of code to call `getTotal` with an incorrect type for `quantity`.
    Assign the result of the call to `getTotal` to a variable with an incorrect type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Both errors are immediately detected and highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Both type errors being caught](img/B19051_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Both type errors being caught
  prefs: []
  type: TYPE_NORMAL
- en: This strong type checking is something that we don’t get in JavaScript, and
    it is very useful in large codebases because it helps us immediately detect type
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how TypeScript doesn’t always need type annotations in order
    to type-check code.
  prefs: []
  type: TYPE_NORMAL
- en: Using type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type annotations are really valuable, but they require additional code to be
    written. This extra code takes time to write. Luckily, TypeScript’s powerful **type
    inference** system means type annotations don’t need to be specified all the time.
    TypeScript infers the type of a variable when it is assigned a value from that
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore type inference by carrying out the following steps in the TypeScript
    Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, remove any previous code and then add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hover over the `flag` variable. A tooltip will appear showing the type that
    `flag` has been inferred to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Hovering over a variable reveals its type](img/B19051_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Hovering over a variable reveals its type
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another line beneath this to incorrectly set `flag` to an invalid value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A type error is immediately caught, just like when we used a type annotation
    to assign a type to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference is an excellent feature of TypeScript and prevents code bloat
    that lots of type annotations would bring. Therefore, it is common practice to
    use type inference and only revert to using type annotations where inference isn’t
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the `Date` type in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Date type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are already aware that a `Date` type doesn’t exist in JavaScript, but luckily,
    a `Date` type does exist in TypeScript. The TypeScript `Date` type is a representation
    of the JavaScript `Date` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following link for more information on the JavaScript `Date` object:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore the TypeScript `Date` type, carry out the following steps in the
    TypeScript Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, remove any previous code and then add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `today` variable is declared that is assigned a `Date` type and set to today’s
    date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor these two lines into the following single line that uses type inference
    rather than a type annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that `today` has been assigned the `Date` type by hovering over it and
    checking the tooltip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Confirmation that today has inferred the Date type](img/B19051_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Confirmation that today has inferred the Date type
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check IntelliSense is working by adding `today.` on a new line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – IntelliSense working nicely on a date](img/B19051_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – IntelliSense working nicely on a date
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove this line and add a slightly different line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An `addMonths` function doesn’t exist in the `Date` object, so a type error
    is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Type error caught on a date](img/B19051_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Type error caught on a date
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `Date` type has all the features we expect – inference, IntelliSense,
    and type checking – which are really useful when working with dates.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about an escape hatch in TypeScript’s type system.
  prefs: []
  type: TYPE_NORMAL
- en: Using the any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if we declare a variable with no type annotation and no value? What will
    TypeScript infer as the type? Let’s find out by entering the following code in
    the TypeScript Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, hover the mouse over `flag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Variable given the any type](img/B19051_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Variable given the any type
  prefs: []
  type: TYPE_NORMAL
- en: So, TypeScript gives a variable with no type annotation and no immediately assigned
    value the `any` type. It is a way of opting out of performing type checking on
    a particular variable and is commonly used for dynamic content or values from
    third-party libraries. However, TypeScript’s increasingly powerful type system
    means that we need to use `any` less often these days.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, there is a better alternative: the `unknown` type.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the unknown type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`unknown` is a type we can use when we are unsure of the type but want to interact
    with it in a strongly-typed manner. Carry out the following steps to explore how
    this is a better alternative to the `any` type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the TypeScript Playground, remove any previous code, and enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code fetches a Star Wars character from a web API. No type errors are raised,
    so the code appears okay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click on the **Run** option to execute the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.14 – firstName property has an undefined value](img/B19051_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – firstName property has an undefined value
  prefs: []
  type: TYPE_NORMAL
- en: The `firstName` property doesn’t appear to be in the fetched data because it
    is `undefined` when it is output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Why wasn’t a type error raised on line 4 where `firstName` was referenced? Well,
    `data` is of the type `any`, which means no type checking will occur on it. You
    can hover over `data` to confirm that it has been given the `any` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Give `data` the `unknown` type annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A type error is now raised where `firstName` is referenced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Type error on unknown data parameter](img/B19051_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Type error on unknown data parameter
  prefs: []
  type: TYPE_NORMAL
- en: The `unknown` type is the opposite of the `any` type, as it contains nothing
    within its type. A type that doesn’t contain anything may seem useless. However,
    a variable’s type can be widened if cheks are made to allow TypeScript to widen
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we give TypeScript information to widen `data`, change the property
    referenced within it from `firstName` to `name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`name` is a valid property, but a type error is still occurring. This is because
    `data` is still `unknown`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now make the highlighted changes to the code to widen the `data` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code snippet can be copied from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section2-Basic-types/Using-the-unknown-type/code.ts](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section2-Basic-types/Using-the-unknown-type/code.ts).
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement uses a function called `isCharacter` to verify that a `name`
    property is contained within the object. The result of this call is `true` in
    this example, so the logic will flow into the `if` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the return type of `isCharacter`, which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a `character` to `{ name: string }` if the function returns `true`.
    The type predicate is `true` in this example, so `character` is widened to an
    object with a `name` string property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover over the `data` variable on each line where it is referenced. `data`
    starts off with the `unknown` type where it is assigned with a type annotation.
    Then, it is widened to `{name: string}` inside the `if` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Widened type given to data](img/B19051_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Widened type given to data
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the type error has also disappeared. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: Next, run the code. You will see `Luke Skywalker` output to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In summary, the `unknown` type is an excellent choice for data whose type you
    are unsure about. However, you can’t interact with `unknown` variables – the variable
    must be widened to a different type before any interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about a type used for a function not returning a value.
  prefs: []
  type: TYPE_NORMAL
- en: Using the void type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `void` type is used to represent a function’s return type where the function
    doesn’t return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, enter the following function in the TypeScript Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Hovering over the function name confirms that the function return type is given
    a `void` type.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Return type confirmed as void](img/B19051_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Return type confirmed as void
  prefs: []
  type: TYPE_NORMAL
- en: 'You may think that you could use `undefined` as the return type for the preceding
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: However, this raises a type error because a return type of `undefined` means
    that the function is expected to return a value (of type `undefined`). The example
    function doesn’t return any value, so the return type is `void`.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `void` is a special type for a function’s return type where the
    function doesn’t have a return statement.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about the `never` type.
  prefs: []
  type: TYPE_NORMAL
- en: Using the never type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `never` type represents something that will never occur and is typically
    used to specify unreachable code areas. Let’s explore an example in the TypeScript
    Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove any existing code and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function invokes an infinite loop, meaning the function is never exited.
    So, we have given the function a return type annotation of `never` because we
    don’t expect the function to be exited. This is different from `void` because
    `void` means it *will* exit, but with no value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We used a JavaScript template literal to construct the string to output to
    the console in the preceding example. Template literals are enclosed by backticks
    (`` ` ` ``) and can include a JavaScript expression in curly braces prefixed with
    a dollar sign (`${expression}`). Template literals are great when we need to merge
    static text with variables. See this link for more information on template literals:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `foreverTask` function to break out of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'TypeScript quite rightly complains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Type error on the never return type](img/B19051_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Type error on the never return type
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `break` statement and remove the `never` return type annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hover over the `foreverTask` function name with your mouse. We can see that
    TypeScript has inferred the return type as `void`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Return type inferred as void](img/B19051_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Return type inferred as void
  prefs: []
  type: TYPE_NORMAL
- en: So, TypeScript is unable to infer the `never` type in this case. Instead, it
    infers the return type as `void`, which means the function will exit with no value,
    which isn’t the case in this example. This is a reminder to always check the inferred
    type and resort to using a type annotation where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `never` type is used in places where code never reaches.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let’s cover arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Using arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are structures that TypeScript inherits from JavaScript. We add type
    annotations to arrays as usual, but with square brackets `[]` at the end to denote
    that this is an array type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore an example in the TypeScript Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove any existing code, and enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, the `Array` generic type syntax can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We will learn about generics in TypeScript in [*Chapter 11*](B19051_11.xhtml#_idTextAnchor273),
    *Reusable Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `1` to the array by using the array’s `push` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add a string to the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A type error is raised as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Type error when adding a string type to a number array](img/B19051_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Type error when adding a string type to a number array
  prefs: []
  type: TYPE_NORMAL
- en: 'Now replace all the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hover over `numbers` to verify that TypeScript has inferred its type to be `number[]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Array type inference](img/B19051_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – Array type inference
  prefs: []
  type: TYPE_NORMAL
- en: Excellent – we can see that TypeScript’s type inference works with arrays!
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are one of the most common types used to structure data. In the preceding
    examples, we’ve only used an array with elements having a `number` type, but any
    type can be used for elements, including objects, which have their own properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a recap of all the basic types we have learned in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript adds many useful types to JavaScripts types, such as `Date`, and
    is capable of representing arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript can infer a variable’s type from its assigned value. A type annotation
    can be used where type inference doesn’t give the desired type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No type checking occurs on variables with the `any` type, so this type should
    be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unknown` type is a strongly-typed alternative to `any`, but `unknown` variables
    must be widened to be interacted with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void` is a return type for a function that doesn’t return a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `never` type can be used to mark unreachable areas of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array types can be defined using square brackets after the array item type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to create our own types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating TypeScript types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last section showed that TypeScript has a great set of standard types. In
    this section, we will learn how to create our own types. We will start by learning
    three different methods for creating object types. We will then learn about strongly-typing
    JavaScript classes. Lastly, we will learn two different methods for creating types
    for variables that hold a range of values.
  prefs: []
  type: TYPE_NORMAL
- en: Using object types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects are very common in JavaScript programs, so learning how to represent
    them in TypeScript is really important. In fact, we have already used an object
    type earlier in this chapter for the `product` parameter in the `calculateTotalPrice`
    function. Here is a reminder of the `product` parameter’s type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: An object type in TypeScript is represented a bit like a JavaScript object literal.
    However, instead of property values, property types are specified instead. Properties
    in the object definitions can be separated by semicolons or commas, but using
    a semicolon is common practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clear any existing code in the TypeScript Playground and follow this example
    to explore object types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following variable assignment to an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you hover over the `table` variable, you’ll see it is inferred to be the
    following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: So, type inference works nicely for objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the next line, try to set a `discount` property to `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `discount` property doesn’t exist in the type, though – only the `name` and
    `unitPrice` properties exist. So, a type error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to represent a `product` object containing the `name` and
    `unitPrice` properties, but we want `unitPrice` to be optional. Remove the existing
    code and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This raises a type error because `unitPrice` is a required property in the
    type annotation. We can use a `?` symbol as follows to make this optional rather
    than required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The type error disappears.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `?` symbol can be used in functions for optional parameters. For example,
    `myFunction(requiredParam: string,` `optionalParam``: string)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn a way to streamline object type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating type aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type annotation we used in the last example was quite lengthy and would
    be longer for more complex object structures. Also, having to write the same object
    structure to assign to different variables is a little frustrating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '**Type aliases** solve these problems. As the name suggests, a type alias refers
    to another type, and the syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the TypeScript Playground and follow along to explore type aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a type alias for the product object structure we used in
    the last example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now assign two variables to this `Product` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s much cleaner!
  prefs: []
  type: TYPE_NORMAL
- en: 'A type alias can extend another object using the `&` symbol. Create a second
    type for a discounted product by adding the following type alias:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DiscountedProduct` represents an object containing `name`, `unitPrice` (optional),
    and `discount` properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A type that extends another using the `&` symbol is referred to as an **intersection
    type**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following variable with the `DiscountedProduct` type as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A type alias can also be used to represent a function. Add the following type
    alias to represent a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding type represents a function containing a `number` parameter and
    doesn’t return anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `Purchase` type to create a `purchase` function property in the `Product`
    type as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Type errors will be raised on the `table`, `chair`, and `chairOnSale` variable
    declarations because the `purchase` function property is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `purchase` function property to the `table` variable declarations as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The type error is resolved on the `table` variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: A purchase property could be added in a similar way to the `chair` and `chairOnSale`
    variable declarations to resolve their type errors. However, ignore these type
    errors for this exploration and move on to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Run** option to run the code that purchases four tables. **“Purchased
    4 tables”** is output to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In summary, type aliases allow existing types to be composed together and improve
    the readability and reusability of types. We will use type aliases extensively
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore an alternative method of creating types. Leave the TypeScript
    Playground open with the code intact – we’ll use this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we created in the last example with type aliases, object types can be created
    using TypeScript’s `interface` keyword, followed by its name, followed by the
    bits that make up the `interface` in curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the TypeScript Playground that contains the code from the type alias
    exploration, and follow along to explore interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by replacing the `Product` type alias with a `Product` interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `table` variable assignment has a type error because the `purchase` property
    doesn’t exist yet – we’ll add this in *step 4*. However, the `chair` variable
    assignment compiles without error.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface can extend another interface using the `extends` keyword. Replace
    the `DiscountedProduct` type alias with the following interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `chairOnSale` variable assignment compiles without error.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface can also be used to represent a function. Add the following interface
    to represent a function, replacing the type alias version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The interface syntax for creating functions isn’t as intuitive as using a type
    alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Purchase` interface to the `Product` interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The type error on the `table` variable declarations is resolved now, but type
    errors are raised on the `chair` and `chairOnSale` variable declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Run** option to run the code that purchases four tables. **“Purchased
    4 tables”** is output to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding steps, we carried out the same tasks using an interface as
    we did using a type alias. So, the obvious question is, *when should I use a type
    alias instead of an interface and vice versa?* The capabilities of type aliases
    and interfaces for creating object types are very similar – so the simple answer
    is that it is down to preference for object types. Type aliases can create types
    that interfaces can’t, though, such as union types, which we shall cover later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following link for more information on the differences between type
    aliases and interfaces: [https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces).'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this book uses type aliases rather than interfaces to define types.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to use TypeScript with classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **class** is a standard JavaScript feature that acts as a template for creating
    an object. Properties and methods defined in the class are automatically included
    in objects created from the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the TypeScript Playground, remove any existing code, and carry out the
    following steps to explore classes in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a class to represent a product with properties
    for the name and unit price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you hover over the `name` and `unitPrice` properties, you’ll see that they
    have the `any` type. As we know, that means no type checking will occur on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following type annotations to the properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unfortunately, TypeScript raises the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Type errors on the class properties](img/B19051_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – Type errors on the class properties
  prefs: []
  type: TYPE_NORMAL
- en: The error is because when an instance of the class is created, those property
    values would be `undefined`, which isn’t within the `string` or `number` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'A solution would be to make the properties optional so that they can accept
    `undefined` as a value. Try this solution by adding a `?` symbol at the start
    of the type annotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we don’t want the values to initially be `undefined`, we can assign initial
    values like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you hover over the properties now, you will see that `name` has been inferred
    to be a `string` type, and `unitPrice` has been inferred to be a `number` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method of adding types to class properties is in a constructor. Remove
    the values assigned to the properties and add a constructor to the class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you hover over the properties, you’ll see that the correct types have been
    inferred.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the properties don’t need to be defined if the constructor parameters
    are marked as `public`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: TypeScript will automatically create properties for constructor parameters that
    are marked as `public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type annotations can be added to method parameters and return values, just
    like we have previously done for functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create an instance of the class and output its discounted price to the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the code, **40** is output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, class properties can be given a type in a constructor or by assigning
    a default value. Class methods can be strongly-typed just like regular JavaScript
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on classes, see the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to create a type to represent a range of values.
  prefs: []
  type: TYPE_NORMAL
- en: Creating enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`enum` keyword, followed by the name we want to give to it, and then its possible
    values in curly braces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore an example in the TypeScript Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the enumeration for `Level` containing `Low`, `Medium`, and
    `High` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a `level` variable and assign it to the values `Low` and then `High`
    from the `Level` enumeration. Also, output the `level` values to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that you get IntelliSense as you reference the enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Run** option to execute the code and observe the enumeration values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.23 – Output of enumeration values](img/B19051_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – Output of enumeration values
  prefs: []
  type: TYPE_NORMAL
- en: By default, enumerations are zero-based numbers (this means that the first enumeration
    value is 0, the next is 1, the next is 2, and so on). In the preceding example,
    `Level.Low` is `0`, `Level.Medium` is `1`, and `Level.High` is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the default values, custom values can be explicitly defined against
    each enumeration item after the equals (`=`) symbol. Explicitly set the values
    to be between `1` and `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can rerun the code to verify this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s do something interesting. Assign `level` to a number greater than
    3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that a type error *doesn’t* occur. This is a little surprising – number-based
    enumerations aren’t as type-safe as we would like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using number enumeration values, let’s try strings. Replace all
    of the current code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If this code is run, we see **L** and **H** output to the console as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another line that assigns `level` to the following strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We immediately see type errors raised on these assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Confirmation that string enumerations are type-safe](img/B19051_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – Confirmation that string enumerations are type-safe
  prefs: []
  type: TYPE_NORMAL
- en: In summary, enumerations are a way of representing a range of values with user-friendly
    names. They are zero-based numbers by default and not as type-safe as we would
    like. However, we can make enumerations string-based, which is more type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn about union types in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Creating union types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **union type** is the mathematical union of multiple other types to create
    a new type. Like enumerations, union types can represent a range of values. As
    mentioned earlier, type aliases can be used to create union types.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a union type is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: This `Level` type is similar to the enumeration version of the `Level` type
    we created earlier. The difference is that the union type only contains values
    (`"H"`, `"M"`, `"L"`) rather than a name (`"High"`, `"Medium"`, `"Large"`) and
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clear any existing code in the TypeScript Playground, and let’s have a play
    with union types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a type to represent `"red"`, `"green"`, or `"blue"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this type is a union of strings, but a union type can consist of any
    types – even mixed types!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable with the `RGB` type and assign a valid value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now try assigning a value outside the type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A type error occurs, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Type error on the union type](img/B19051_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 – Type error on the union type
  prefs: []
  type: TYPE_NORMAL
- en: Union types consisting of strings are great when a type can only hold a specific
    set of strings, as in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a recap of what we have learned about creating types:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects and functions can be represented using type aliases or interfaces. They
    have very similar capabilities, but the type alias syntax is a little more intuitive
    for representing functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `?` symbol can specify that an object property or function parameter is
    optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type annotations can be added to class properties and constructor and method
    parameters to make them type-safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like string-based union types, string-based enumerations are great for a specific
    set of strings. A string union type is the simplest approach if the strings are
    meaningful. If the strings aren’t meaningful, then a string enumeration can be
    used to make them readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have covered types, next, we will learn about the TypeScript compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using the TypeScript compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to use the TypeScript compiler to type check
    code and transpile it into JavaScript. First, we will use Visual Studio Code and
    create a simple TypeScript project containing code we have written in a previous
    section. We will then use the terminal within Visual Studio Code to interact with
    the TypeScript compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio Code in a blank folder of your choice, and carry out the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `package.json` containing the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The file defines a project name of `tsc-play` and sets TypeScript as the only
    dependency. The file also defines an npm script called `build` that will invoke
    the TypeScript compiler (`tsc`), passing it to the `product.ts` file in the `src`
    folder. Don’t worry that `product.ts` doesn’t exist – we will create it in *step
    3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the Visual Studio Code terminal by selecting **New Terminal** from
    the **Terminal** menu, then enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install all the libraries listed in the `dependencies` section of
    `package.json`. So, this will install TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `src` and then create a file called `product.ts` within
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `product.ts` and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will be familiar from the section on using classes. The code can be
    copied from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/src/product.ts](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/src/product.ts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will run the npm `build` script we defined in the first step.
  prefs: []
  type: TYPE_NORMAL
- en: After the command finishes, notice that a `product.js` file appears next to
    `product.ts` in the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the transpiled `product.js` file and read the content. It will look as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the type annotations have been removed because they aren’t valid
    JavaScript. Notice also that it has been transpiled to JavaScript, capable of
    running in very old browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration that the TypeScript compiler uses isn’t ideal. For
    example, we probably want the transpiled JavaScript in a completely separate folder,
    and are likely to want to target newer browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TypeScript compiler can be configured using a file called `tsconfig.json`.
    Add a `tsconfig.json` file at the root of the project, containing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code can be copied from [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/tsconfig.json](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/tsconfig.json).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an explanation of each setting in the `compilerOptions` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`outDir`: This is the folder that the transpiled JavaScript is placed in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`: This is the version of JavaScript we want to transpile to. The `esnext`
    target means the next version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Module`: This is the type of module used within the code. The `esnext` module
    means standard JavaScript modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lib`: Gives the standard library types included in the type checking process.
    `DOM` gives the browser DOM API types, and `esnext` are types for APIs in the
    next version of JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Strict`: When set to `true`, means the strictest level of type checking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jsx`: When set to `React`, allows the compiler to transpile React’s JSX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moduleResolution`: This is how dependencies are found. We want TypeScript
    to look in the `node_modules` folder, so we have chosen `node`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noEmitOnError`: When set to `true`, means the transpilation won’t happen if
    a type error is found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `include` field specifies the TypeScript files to compile, and the `exclude`
    field specifies the files to exclude.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the TypeScript compiler options, see the following
    link: [https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The TypeScript compiler configuration now specifies all files in the `src`
    folder to be compiled. So, remove the file path on the `build` script in `package.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the previous transpiled `product.js` in the `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rerun the `build` command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time the transpiled file is placed in a `build` folder. You will also notice
    that the transpiled JavaScript now uses classes that are supported in modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing we are going to try is a type error. Open `product.ts` and
    update the constructor to reference an incorrect property name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the `build` folder to remove the previously transpiled JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rerun the `build` command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The type error is reported in the terminal. Notice that the JavaScript file
    is not transpiled.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, TypeScript has a compiler, called `tsc`, that we can use to carry
    out type checking and transpilation as part of a continuous integration process.
    The compiler is very flexible and can be configured using a file called `tsconfig.json`.
    It is worth noting that Babel is often used to transpile TypeScript (as well as
    React), leaving TypeScript to focus on type checking.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will recap what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript complements JavaScript with a rich type system, and in this chapter,
    we experienced catching errors early using TypeScript’s type checking.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that JavaScript types, such as `number` and `string`, can be
    used in TypeScript, as well as types that only exist in TypeScript, such as `Date`
    and `unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: We explored union types and learned that these are great for representing a
    specific set of strings. We now understand that string enumerations are an alternative
    to string union types if the string values aren’t very meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: New types can be created using type aliases. We learned that type aliases could
    be based on objects, functions, or even union types. We now know that the `?`
    symbol in a type annotation makes an object property or function parameter optional.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned a fair bit about the TypeScript compiler and how it can work
    well in different use cases because it is very configurable. This will be important
    when we start to use TypeScript with React in the next chapter. There, we will
    learn different ways of setting up React and TypeScript projects before learning
    to strongly-type React props and state.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to check what you have learned about TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: What would the inferred type be for the `flag` variable in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the return type in the following function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the type annotation for an array of dates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Will a type error occur in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use a type alias to create a number that can only hold integer values between
    and including 1 and 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What TypeScript compiler option can be used to prevent the transpilation process
    when a type error is found?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code raises a type error because `lastSale` can’t accept `null`
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How can the `Product` type be changed to allow `lastSale` to accept `null` values?
  prefs: []
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `flag` variable would be inferred to be a `boolean` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The return type in the function is `void`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An array of dates can be represented as `Date[]` or `Array<Date>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A type error will not be raised on the `point` variable. It doesn’t need to
    include the `z` property because it is optional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A type for numbers 1-3 can be created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `noEmitOnError` compiler option (set to `true`) can be used to prevent the
    transpilation process when a type error is found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A union type can be used for the `lastSale` property to allow it to accept
    `null` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
