- en: '*Chapter 1*: Introducing the Function Component'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：介绍函数组件'
- en: 'In this chapter, we will first start with a brief history of *UI* components
    developed over the past two decades and get to know how *React* uses *UI* components
    to put together an application. You will learn what a function component is, with
    an explanation of its props and the basic parent/child relationship. You will
    then get some tips on how to write a function component. At the end, you will
    see a practical function component example, `Nav`. The chapter also includes one
    bonus topic in the *Appendix* section: *How many component types does React support?*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先简要介绍过去二十年中开发的*UI*组件的历史，并了解*React*如何使用*UI*组件来构建应用。你将学习函数组件是什么，以及它的props和基本的父子关系。然后，你将获得一些关于如何编写函数组件的技巧。最后，你将看到一个实际的函数组件示例，`Nav`。本章还包括附录部分的一个额外主题：*React支持多少种组件类型？*
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: History of *UI* components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*UI*组件的历史'
- en: Building an app with components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件构建应用
- en: Introducing the function component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍函数组件
- en: Writing a function component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数组件
- en: Example of a function component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组件的示例
- en: Questions and answers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答
- en: Appendix
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录
- en: History of UI components
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI组件的历史
- en: While we are fascinated by technology, it can also be intriguing to watch how
    slowly it evolves over time. In our case, it's *HTML*. On the surface, it doesn't
    appear to have changed for the past 20 years. You get that idea by comparing a
    typical web page written now with one written 20 years ago, and seeing that they
    look very similar, if not identical.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对技术感到着迷时，观察它随着时间的推移缓慢演变也可能很有趣。在我们的案例中，是*HTML*。从表面上看，它似乎在过去20年里没有发生变化。你可以通过比较现在编写的典型网页代码与20年前编写的代码，并看到它们看起来非常相似，如果不是完全相同的话，来得到这个想法。
- en: 'The following snippet shows what typical *HTML* page code looks like:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了典型的*HTML*页面代码的样子：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Those of us who have been in this industry long enough know that the web has
    been reshaped a couple of times. In particular, a tremendous amount of effort
    has been spent on how to generate the preceding *HTML*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这些在这个行业工作很长时间的人都知道，网络已经被重塑了几次。特别是，大量的努力被投入到如何生成前面的*HTML*。
- en: Web engineers have tried to divide the file up into multiple parts, including
    *HTML*, *JavaScript*, and *CSS*, and then put it back together upon rendering
    the file onscreen. They have also tried to load one or two parts on servers, and
    the rest on client computers. They have also tried various compilers or builders
    to autogenerate the file after each change to the source code. They have tried
    lots of things. Actually, almost anything you can think of regarding *HTML* has
    been tried a couple of times in the past, and people will not stop trying something
    just because someone else has tried it. In a sense, web technology gets re-invented
    every once in a while.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网页工程师们试图将文件分成多个部分，包括*HTML*、*JavaScript*和*CSS*，然后在文件在屏幕上渲染时将其重新组合。他们还尝试在服务器上加载一个或两个部分，其余部分在客户端计算机上加载。他们还尝试了各种编译器或构建器，在源代码每次更改后自动生成文件。他们尝试了很多事情。实际上，关于*HTML*的几乎所有你能想到的事情在过去都尝试过几次，而且人们不会因为别人尝试过而停止尝试。从某种意义上说，网络技术时不时地被重新发明。
- en: With so much new content being added to the web every day, engineers have found
    the *HTML* files a bit unmanageable. On the one hand, the demand is that users
    want to see more actionable items with quicker responses and, on the other hand,
    many of these actionable items on the screen create challenges for engineers to
    manage the workload and maintain the code base.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每天向网络添加大量新内容，工程师们发现*HTML*文件有点难以管理。一方面，需求是用户希望看到更多可操作的项目，并希望有更快的响应，另一方面，屏幕上的许多可操作项目给工程师管理工作量并维护代码库带来了挑战。
- en: So, engineers are on a constant lookout for better ways to organize *HTML* files.
    If this organization is done right, it can help them not get overwhelmed by a
    plethora of elements on the screen. At the same time, organizing files well means
    a scalable project, since the team can divide the project into smaller pieces
    and work on each in a divide-and-conquer way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，工程师们一直在寻找更好的方法来组织*HTML*文件。如果这种组织方式得当，它可以帮助他们不被屏幕上众多元素所淹没。同时，良好的文件组织意味着可扩展的项目，因为团队可以将项目分解成更小的部分，并以分而治之的方式逐一工作。
- en: Let's take a look at the history of how technologies using *JavaScript* assisted
    with these topics. We will choose four technologies for this conversation – *jQuery*,
    *Angular*, *React*, and *LitElement*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下使用 *JavaScript* 的技术是如何帮助这些主题的历史。我们将在这个对话中选择四种技术 – *jQuery*、*Angular*、*React*
    和 *LitElement*。
- en: jQuery
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery
- en: '*jQuery* is a library used to manipulate the **Document Object Model** (**DOM**)
    elements on the screen. It recognizes the challenges of working with the *DOM*
    directly, thereby providing a utility layer to simplify the syntax of finding,
    selecting, and manipulating *DOM* elements. It was developed in 2006 and has been
    used by millions of websites since then.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*jQuery* 是一个用于操作屏幕上 **Document Object Model** (**DOM**) 元素的库。它认识到直接与 *DOM*
    一起工作的挑战，因此提供了一个实用层来简化查找、选择和操作 *DOM* 元素的语法。它于 2006 年开发，自那时以来已被数百万个网站使用。'
- en: 'What''s great about jQuery is that it can work with an existing *HTML* by creating
    a wrapper around it using the famous `$` symbol, as you can see in the following
    code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 *jQuery* 的好处是，它可以通过使用著名的 `$` 符号在它周围创建包装器来与现有的 *HTML* 一起工作，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*jQuery* didn''t have much competition when it came to changing color, font,
    or any attribute of an element at runtime. It made it possible to organize large
    chunks of business logic code into functions stored in multiple files. It also
    provided a modular way to create reusable UI widgets through one of its plugins
    at the time.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*jQuery* 在改变元素的颜色、字体或任何运行时属性方面没有太多竞争。它使得将大量业务逻辑代码组织成存储在多个文件中的函数成为可能。它还通过当时的某个插件提供了一种模块化的方式来创建可重用的
    UI 小部件。'
- en: Complete separation between *HTML* and *JavaScript* was strongly favored back
    then. At that time, people believed that this way of doing things helped to raise
    productivity, since people who work with website styles and behaviors can be from
    two departments. Theming, the word describing the application of style to a site,
    was gaining popularity and some jobs were looking for developers who could make
    a site look as beautiful as a Photoshop design.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在当时，强烈倾向于在 *HTML* 和 *JavaScript* 之间实现完全分离。当时，人们认为这种方式做事有助于提高生产力，因为处理网站样式和行为的人可以来自两个部门。主题化，这个词描述了将样式应用于网站的方式，正在变得流行，一些工作正在寻找能够使网站看起来像
    Photoshop 设计的开发者。
- en: Angular
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular
- en: '*Angular* is a web framework used to develop a **Single-Page Application**
    (**SPA**). It was invented by *Google* in 2010\. It was quite revolutionary at
    the time, because you could build a frontend application with it. This means that
    the code written in *Angular* could take over the body of *HTML* and apply logic
    to all elements within it at runtime. All code was run at the browser level, resulting
    in the word "frontend" starting to appear in job résumés. Since then, web developers
    have been roughly categorized as "backend," "frontend," and "full stack" (which
    means both frontend and backend).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Angular* 是一个用于开发 **Single-Page Application** (**SPA**) 的网络框架。它由 *Google* 于
    2010 年发明。在当时，它相当革命性，因为你可以用它来构建前端应用程序。这意味着在 *Angular* 中编写的代码可以在运行时接管 *HTML* 的主体，并对其中所有元素应用逻辑。所有代码都在浏览器级别运行，导致“前端”这个词开始在简历上出现。从那时起，网络开发者大致分为“后端”、“前端”和“全栈”（这意味着前端和后端）。'
- en: 'The code that *Angular* uses continues to be built on existing *HTML* by attaching
    additional tags to it like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*Angular* 使用的代码继续通过附加额外的标签来构建在现有的 *HTML* 上，如下所示：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The controller and module introduced by *Angular* can imbue business logic
    to sections of *HTML* with unique scopes. *Angular* supports components and directives
    out of the box, which allows us to reference all relevant *HTML* and *JavaScript*
    together in a single file (although the *HTML* file still needs to be written
    in a separate file):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*Angular* 引入的控制器和模块可以为具有独特作用域的 *HTML* 部分注入业务逻辑。*Angular* 默认支持组件和指令，这使得我们可以在单个文件中引用所有相关的
    *HTML* 和 *JavaScript*（尽管 *HTML* 文件仍然需要单独编写）：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The component created via Angular can be reused afterward in an HTML file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Angular 创建的组件可以在之后在 HTML 文件中重用。
- en: React
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React
- en: '*React*, also known as *React.js*, was developed by *Facebook* and released
    in 2013 as a *JavaScript* library for building *UI* components. Although it wasn''t
    specifically marketed as a web framework, it has been used by developers to build
    single-page or mobile applications, and has been favored by start-up companies
    in particular ever since.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*React*，也称为 *React.js*，由 *Facebook* 开发并于2013年发布，是一个用于构建 *UI* 组件的 *JavaScript*
    库。尽管它并没有被特别宣传为一个网络框架，但开发者们已经用它来构建单页或移动应用，特别是受到了初创公司的青睐。'
- en: 'What was controversial at the time was how it treated *HTML* statements. Instead
    of leaving them in a *HTML* file, it actually asked to take them out and put under
    a `render` function of a component, like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当时的争议在于它如何处理 *HTML* 语句。它并没有将它们留在 *HTML* 文件中，而是实际上要求将它们移出，并放在组件的 `render` 函数下，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This unique approach favors the component design much more than the integrity
    of the *HTML* file. This was (almost) the first time you could put *HTML* and
    *JavaScript* together under the same file. We call it *HTML* here because it looks
    like *HTML*, but actually *React* creates a wrapper to transform the *HTML* into
    *JavaScript* statements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种独特的方法比 *HTML* 文件的完整性更倾向于组件设计。这几乎是第一次你可以在同一个文件下将 *HTML* 和 *JavaScript* 一起使用。我们在这里称之为
    *HTML*，因为它看起来像 *HTML*，但实际上 *React* 创建了一个包装器，将 *HTML* 转换为 *JavaScript* 语句。
- en: 'When *React* was introduced, it came with a class component and in 2015, it
    added support for a function component, so you can write the logic under a function
    instead of a class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *React* 被引入时，它附带了一个类组件，并在2015年增加了对函数组件的支持，因此你可以将逻辑写在函数而不是类中：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With *React*, the *HTML* files don't get touched as often as they used to be;
    in fact, they don't get changed at all, since the *HTML* content is all relocated
    to *React* components. This approach can still be controversial today because
    people who don't care about the location of the *HTML* would get onboard very
    easily, whereas people who care about the classical way of writing *HTML* would
    stay away. There's also a mentality shift here; with *React*, *JavaScript* becomes
    the focus of web development.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *React*，*HTML* 文件不像以前那样经常被修改；事实上，它们根本就没有改变，因为所有的 *HTML* 内容都被重新定位到了 *React*
    组件中。这种做法今天仍然可能引起争议，因为那些不关心 *HTML* 位置的人会很容易地接受，而那些关心传统 *HTML* 编写方式的人则会保持距离。这里也有一个心态的转变；使用
    *React*，*JavaScript* 成为了网络开发的焦点。
- en: LitElement
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LitElement
- en: '*Polymer* was developed by *Google* and released in 2015, designed to build
    web applications using web components. In 2018, the *Polymer* team announced that
    any future development would be shifted to *LitElement* to create fast and lightweight
    web components:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*Polymer* 由 *Google* 开发并于2015年发布，旨在使用网络组件构建网络应用。2018年，*Polymer* 团队宣布任何未来的开发都将转移到
    *LitElement* 以创建快速和轻量级的网络组件：'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are quite a few similarities between *React* and *LitElement* since it
    allows you to define a class component with a `render` function. What''s unique
    about *LitElement* is that once the element is registered, it can behave like
    a DOM element:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 和 *LitElement* 之间有很多相似之处，因为它允许你使用 `render` 函数定义一个类组件。*LitElement* 的独特之处在于，一旦元素被注册，它可以像DOM元素一样行为：'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's no apparent entry point for integrating *LitElement* into *HTML* since
    it doesn't need to gain control of a `body` element before using it. We can design
    the element somewhere else, and when it comes to its use, it's more like using
    an `h1` element. Therefore, it perfectly preserves the integrity of the HTML file
    while outsourcing the additional capability to the custom element, which can be
    designed by others.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *LitElement* 集成到 *HTML* 中没有明显的入口点，因为它在使用之前不需要控制 `body` 元素。我们可以在其他地方设计该元素，当它被使用时，它更像是一个
    `h1` 元素。因此，它在保持HTML文件完整性的同时，将额外的功能外包给其他可以设计的自定义元素。
- en: The goal of *LitElement* is to have the web component work in any web page within
    any framework.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*LitElement* 的目标是让网络组件在任何框架中的任何网页上都能工作。'
- en: '20 years ago, we didn''t know what the web would become. From this brief historical
    review of *jQuery*, *Angular*, *React*, and *LitElement*, it''s clear that an
    idea of having *UI* components has emerged. A component, like a block of LEGO,
    can do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 20年前，我们不知道网络会变成什么样。从对 *jQuery*、*Angular*、*React* 和 *LitElement* 的简要历史回顾中可以看出，一个拥有
    *UI* 组件的想法已经出现。一个组件，就像一块乐高积木，可以做到以下事情：
- en: Encapsulate functionalities inside
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能封装在内
- en: Be reused in other places
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在其他地方重用
- en: Not jeopardize the existing site
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会损害现有网站
- en: 'Thus, when we use the component, it takes the following syntax:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们使用组件时，它采用以下语法：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Essentially, this isn''t too different from where we started with writing *HTML*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这与我们开始编写 *HTML* 的地方并没有太大的不同：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's a hidden requirement for a component here. While the components can
    be designed separately, in the end, they have to be put together to serve a higher
    purpose, to finish building a site. Therefore, as atomic as each component is,
    there still needs to be a communication layer to allow blocks to talk to one another.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对组件有一个隐藏的要求。虽然组件可以单独设计，但最终它们必须组合起来以实现更高的目的，即完成网站的构建。因此，尽管每个组件都是原子的，但仍需要一个通信层来允许块之间进行通信。
- en: As long as components are functioning and there is communication between them,
    the app can function as a whole. This is actually the assumption of a component
    design along with building a site.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 只要组件正常工作并且它们之间有通信，应用程序就可以作为一个整体运行。这实际上是组件设计和构建网站时的一个假设。
- en: So, into what category does our book fall? Our book is about building components
    under *React*, especially building smart components that can serve as a reusable
    block and are able to fit in an app. The technology we have chosen here is hooks
    inside a function component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的书属于哪个类别呢？我们的书是关于在 *React* 下构建组件，特别是构建可以作为可重用块使用的智能组件，并且能够适应应用程序。我们在这里选择的技术是函数组件内部的
    hooks。
- en: Before we get into the details of components and hooks, let's first take a brief
    look at how components can be put together to build an application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入组件和 hooks 的细节之前，让我们先简要地看看组件是如何组合起来构建一个应用程序的。
- en: Building an app with components
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件构建应用程序
- en: 'To start building an application, here''s a block of *HTML* you can start with:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建应用程序，以下是一个你可以开始的 *HTML* 块：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These days, we have more and more **SPAs** that update parts of pages on the
    fly, which makes using the website feel like a native application. A quick response
    time is what we are aiming for. JavaScript is the language to deliver this goal,
    from displaying the user interface to running application logic and communicating
    with the web server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们越来越多地使用 **SPAs** 来动态更新页面的一部分，这使得使用网站的感觉就像是一个原生应用程序。我们追求的是快速响应时间。JavaScript
    是实现这个目标的语言，从显示用户界面到运行应用程序逻辑以及与网络服务器通信。
- en: 'To add logic, React takes over one section of the HTML to start a component:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加逻辑，React 会接管 HTML 的一部分来启动一个组件：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `render` function in the preceding code, provided by `ReactDOM`, accepts
    two input arguments, which are a *React* element and a *DOM* element, `rootEl`.
    `rootEl` is where you want *React* to render, in our case, a *DOM* node tagged
    with the `root` ID. What *React* renders to `rootEl` can be found defined in a
    function component, `App`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，由 `ReactDOM` 提供的 `render` 函数接受两个输入参数，这两个参数是一个 *React* 元素和一个 *DOM* 元素
    `rootEl`。`rootEl` 是你希望 *React* 渲染的地方，在我们的例子中，是一个带有 `root` ID 的 *DOM* 节点。*React*
    在 `rootEl` 上渲染的内容可以在一个函数组件 `App` 中找到定义。
- en: 'It''s important to tell the difference between `App` and `<App />` in *React*.
    `App` is a component, and there has to be a definition out there to describe what
    it can do:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *React* 中区分 `App` 和 `<App />` 是很重要的。`App` 是一个组件，必须有一个定义来描述它能做什么：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Whereas `<App />` is one instance of the `App` component. A component can have
    lots of instances created from it, quite similar to the instance of a class in
    most programming languages. Creating an instance out of a component is the first
    step to reusability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`<App />` 是 `App` 组件的一个实例。一个组件可以创建很多实例，这与大多数编程语言中类的实例非常相似。从组件中创建实例是可重用的第一步。'
- en: 'If we launch the preceding code in a browser, we should see it display the
    following **Hello World** title:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行前面的代码，我们应该看到它显示以下 **Hello World** 标题：
- en: '![Figure 1.1 – Hello World'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.1 – Hello World'
- en: '](img/Figure_1.01_B17963.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.01_B17963.jpg](img/Figure_1.01_B17963.jpg)'
- en: Figure 1.1 – Hello World
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Hello World
- en: Playground – Hello World
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Playground – Hello World
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/ExvYPEX](https://codepen.io/windmaomao/pen/ExvYPEX).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地在这个例子上在线玩耍：[https://codepen.io/windmaomao/pen/ExvYPEX](https://codepen.io/windmaomao/pen/ExvYPEX)。
- en: To have a fully functional application, normally we would need more than one
    page. Let's take a look at a second page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个完全功能的应用程序，通常我们需要多个页面。让我们看看第二个页面。
- en: Multiple pages
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多页面
- en: Building a `"Hello World"` component is the first step. But how does a single
    component like that support multiple pages so that we can navigate from one page
    to another?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个 `"Hello World"` 组件是第一步。但这样一个单独的组件是如何支持多个页面，以便我们可以从一个页面导航到另一个页面的呢？
- en: 'Say we have two pages, both defined in components, `Home` and `Product`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个页面，都在组件中定义，分别是 `Home` 和 `Product`：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To display either `Home` or `Product`, we can create a helper component:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示 `Home` 或 `Product`，我们可以创建一个辅助组件：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding `Route` component is a bit different; it carries an input argument,
    `home`, from the function definition. `home` holds a Boolean value and based on
    it, the `Route` component can switch between displaying `<Home />` or `<Product
    />`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `Route` 组件略有不同；它携带一个从函数定义中传入的输入参数 `home`。`home` 包含一个布尔值，根据它，`Route` 组件可以在显示
    `<Home />` 或 `<Product />` 之间切换。
- en: 'Now it''s a matter of determining what the value for `home` in `App is`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是要确定 `App` 中的 `home` 的值：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, the `App` component is amended to include a `home` variable,
    which gets passed to the `Route` component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`App` 组件被修改以包含一个 `home` 变量，该变量被传递给 `Route` 组件。
- en: You might have noticed that the current code will only display the Home page
    because we have set `home` to `true`. Don't worry. This whole book is about teaching
    you how to set the `home` value. For now, just imagine the value would be flipped
    from `true` to `false` based on a user mouse click, and for the time being, you
    can manually change the `home` value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当前的代码只会显示首页，因为我们已经将 `home` 设置为 `true`。不用担心，整本书都是关于教你如何设置 `home` 值的。现在，只需想象根据用户的鼠标点击，`home`
    的值会从 `true` 切换到 `false`，暂时你可以手动更改 `home` 的值。
- en: The `App` component can grow bigger as more and more components are added underneath
    it with this routing mechanism. This is partly why the first component in a *React*
    application is named `App`. Although you can name it whatever you want, just remember
    to use a capitalized letter for the first letter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `App` 组件下添加越来越多的组件以及这种路由机制，`App` 组件可以变得更大。这也是为什么在 *React* 应用程序中第一个组件被命名为
    `App` 的部分原因。虽然你可以随意命名，但请记住，第一个字母要大写。
- en: Playground – Home Page
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 首页
- en: Feel free to play with the example online at [https://codepen.io/windmaomao/pen/porzgOy](https://codepen.io/windmaomao/pen/porzgOy).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试这个示例：[https://codepen.io/windmaomao/pen/porzgOy](https://codepen.io/windmaomao/pen/porzgOy)。
- en: Now we can see how *React* puts together an app, so without further ado, let's
    get to the component in *React*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到 *React* 是如何组合一个应用的，所以无需多言，让我们直接进入 *React* 的组件。
- en: There are mainly two component types that *React* supports – a class component
    and a function component. This book will focus on a function component. If you
    are interested in other component types, please check out the *Appendix A – How
    many component types does React support?* section at the end of this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 主要支持两种组件类型——类组件和函数组件。本书将专注于函数组件。如果你对其他组件类型感兴趣，请查看本章末尾的 *附录 A – React
    支持多少种组件类型？* 部分。'
- en: Introducing the function component
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍函数组件
- en: '"This pattern is designed to encourage the creation of these simple components
    that should comprise large portions of your apps." – Sophie Alpert'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: “这种模式旨在鼓励创建这些简单的组件，这些组件应该构成你应用程序的大部分。” – Sophie Alpert
- en: 'In this section, we are going to introduce you to the function component. When
    the function component was first introduced in React 0.14 in August 2015, it was
    named as a stateless pure function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍函数组件。当函数组件首次在 2015 年 8 月的 React 0.14 版本中引入时，它被命名为无状态纯函数：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The main intention was that "stateless pure-function components give us more
    opportunity to make performance optimizations."
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目的是“无状态的纯函数组件给我们提供了更多的性能优化机会。”
- en: 'A function component with no state, by default, is designed to take the following
    function form:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，没有状态的函数组件被设计成以下函数形式：
- en: '![Figure 1.2 – Function component definition'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 函数组件定义'
- en: '](img/Figure_1.02_B17963.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.02_B17963.jpg)'
- en: Figure 1.2 – Function component definition
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 函数组件定义
- en: We are going to explore parts of a function component in detail in the next
    subsections.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中详细探讨函数组件的各个部分。
- en: Function props
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数属性
- en: The input argument of this function is referred to as a prop. Props take an
    object format under which we can define any property. Each property is referred
    to as a prop. For instance, *Figure 1.2* defines a `Title` component with a `text`
    prop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的输入参数被称为道具。道具采用一个对象格式，我们可以定义任何属性。每个属性都被称为道具。例如，*图 1.2* 定义了一个带有 `text` 道具的
    `Title` 组件。
- en: 'Because props are objects, there''s no limitation to how many props can be
    defined under that object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为道具是对象，所以没有限制可以定义多少个道具在该对象下：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The job of a prop, similar to an input argument, is to pass a value to the
    function. There is also no limitation in terms of the type of prop. Since each
    prop is a property of an object, it can be a string, a number, an object, a function,
    an array, or anything that can be assigned using a *JavaScript* expression, as
    in the following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 道具（prop）的工作，类似于输入参数，是将一个值传递给函数。在道具的类型上也没有限制。由于每个道具都是对象的属性，它可以是一个字符串、一个数字、一个对象、一个函数、一个数组，或者任何可以用
    *JavaScript* 表达式赋值的任何东西，如下面的例子所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, the first case passes an `obj` prop carrying a `text`
    property, while the second case passes an `fn` prop that gets invoked inside.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一种情况传递了一个带有 `text` 属性的 `obj` 道具，而第二种情况传递了一个在内部调用的 `fn` 道具。
- en: 'Once a function component has been defined, it can be used as many times as
    you want in other places via its instances:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了一个函数组件，就可以通过其实例在其他地方多次使用：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, a `Title` component instance is used in the definition
    of an `App` component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在 `App` 组件的定义中使用了 `Title` 组件实例。
- en: And when the `App` component is updated, a string, `"Hello World"`, is assigned
    to the `text` prop of the `Title` component. The usage of the `Title` component
    reminds us of the *HTML* statement, and the `text` prop reminds us of the attribute
    of the *DOM* element.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `App` 组件更新时，一个字符串 `"Hello World"` 被分配给 `Title` 组件的 `text` 道具。`Title` 组件的使用让我们想起了
    *HTML* 语句，而 `text` 道具让我们想起了 *DOM* 元素的属性。
- en: 'We have actually seen the usage of an `App` component instance as well at the
    beginning:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在开始时也看到了 `App` 组件实例的使用：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In short, you can define a component, but to see what it displays on the screen,
    its instance needs to be used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你可以定义一个组件，但要看到它在屏幕上显示的内容，需要使用其实例。
- en: Children prop
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子道具
- en: 'All the props of a function component should be defined explicitly, just like
    input arguments. But, there''s a prop worth knowing early on that isn''t apparent
    to follow this rule. This is called a `children` prop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件的所有道具都应该像输入参数一样明确定义。但是，有一个值得早期了解的道具，它并不遵循这个规则。这被称为 `children` 道具：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You might be using the preceding code without knowing how exactly the `"Hello
    World"` string is put under the `Title` component. Interestingly, the string is
    wired to the component via a `children` prop. This will become clear when we get
    to the definition of the `Title` component:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在使用前面的代码时并不知道 `"Hello World"` 字符串是如何被连接到 `Title` 组件的。有趣的是，这个字符串是通过 `children`
    道具连接到组件的。当我们到达 `Title` 组件的定义时，这会变得清楚：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Essentially, the `App` component takes `"Hello World"` and assigns it to the
    `children` prop before invoking the `Title` component instance. You might wonder
    what happens if we forget to include the `children` prop when defining the `Title`
    component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`App` 组件在定义之前将 `"Hello World"` 分配给 `children` 道具，然后调用 `Title` 组件实例。你可能想知道如果我们忘记在定义
    `Title` 组件时包含 `children` 道具会发生什么：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In that case, `"Hello World"` is ignored and the `App` component reduces to
    the following case:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，`"Hello World"` 被忽略，`App` 组件简化为以下情况：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Apparently, this is not intended since, if you put children elements under a
    component, then a `children` prop has to be defined explicitly in the function
    definition. This means that a `children` prop still needs to be explicitly written
    on the function interface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是预期的，因为如果你在组件下放置子元素，那么在函数定义中必须明确定义 `children` 道具。这意味着 `children` 道具仍然需要在函数接口上明确写出。
- en: In fact, the `children` prop is the reason why a component can be nested under
    another component. *React* uses this `children` mechanism to reproduce how the
    *HTML* writes in general.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`children` 道具是组件可以嵌套在其他组件下的原因。*React* 使用这个 `children` 机制来重现 *HTML* 通常是如何编写的。
- en: Parent and child
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父亲和子组件
- en: 'In *React*, props are the mechanism for components talking to one another.
    We can generalize this idea by using two components normally involved in the communication
    to a parent and a child, as we have already seen in `App` and `Title`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *React* 中，props 是组件之间通信的机制。我们可以通过使用两个通常参与通信的组件——父组件和子组件——来概括这个想法，正如我们在 `App`
    和 `Title` 中已经看到的那样：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, a `Title` component accepts `text` as one of the props.
    An `App` component sends the `"Hello"` text to the `Title` component if the flag
    is `true`, otherwise, it sends the `"World"` text to `Title`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Title` 组件接受 `text` 作为其 props 之一。如果标志 `flag` 为 `true`，则 `App` 组件将 `"Hello"`
    文本发送到 `Title` 组件，否则，它将 `"World"` 文本发送到 `Title`。
- en: Who sends the `flag` info to the `App` component? That will be the parent of
    `App`. This can easily be constructed to form a tree, where we have branches and
    sub-branches, and it reaches the leaves at the ends. Notice that this formation
    is done solely through the usage of props on each node (component).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 谁将 `flag` 信息发送到 `App` 组件？那将是 `App` 的父组件。这可以很容易地构建成一个树，其中我们有分支和子分支，并且它延伸到末端的叶子。请注意，这种结构完全是通过在每个节点（组件）上使用
    props 来实现的。
- en: Once a piece of info gets into a component, the prop binds its value to a local
    scope variable. From then on, it's the child's job to continue managing its local
    variable. It can be used pretty flexibly with one limitation. It's not expected
    to be changed! Or, if you ever change it, the change would not be reflected in
    the parent component. This behavior is the same as how we use a function with
    input arguments and its inner scope. The information passing is a one-way ticket.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦信息进入一个组件，prop 就将其值绑定到一个局部作用域变量上。从那时起，管理局部变量的任务就落在了子组件身上。它可以相当灵活地使用，但有一个限制。它不应该被改变！或者，如果你改变了它，这个变化就不会反映在父组件中。这种行为与我们在使用带有输入参数和其内部作用域的函数时的行为相同。信息传递是一张单程票。
- en: So now comes a big question. What if we want to reflect the change to a parent
    component done by a child component? How can a one-way ticket get us the information
    back?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现了一个大问题。如果我们想反映子组件对父组件所做的更改，怎么办？如何让一张单程票带回来信息？
- en: 'This is also done through a prop. As I mentioned, a prop can take any format,
    hence we can use a function prop:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是通过一个 prop 来实现的。正如我提到的，prop 可以采用任何格式，因此我们可以使用一个函数 prop：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we sent a function defined in `Parent` through a `change`
    prop. Inside the `Child` component, when a user starts to type in any character
    to an `input` box, it fires an `onChange` event where we can invoke the `change`
    function. Whenever this happens, you will see the `child notify me` message in
    the `Parent` component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过 `change` prop 发送了在 `Parent` 中定义的函数。在 `Child` 组件内部，当用户开始在 `input`
    框中输入任何字符时，它会触发一个 `onChange` 事件，我们可以在其中调用 `change` 函数。每次发生这种情况时，你都会在 `Parent` 组件中看到“child
    notify me”的消息。
- en: Essentially, this technique is what we refer to as a callback in JavaScript.
    The parent provides a mechanism to notify that something has changed using a callback
    function. Once the callback function is created, it can be sent to any child to
    gain the ability of notification to the parent.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这种技术就是我们所说的 JavaScript 中的回调。父组件通过使用回调函数提供了一种通知更改的机制。一旦创建了回调函数，它就可以发送给任何子组件，以获得通知父组件的能力。
- en: In a typical parent/child relationship in *React*, it's recommended that a prop
    value should not be changed by the child. Instead, it should be done through a
    function prop. When comparing *React* to other libraries, a "one-way" ticket is
    what we use to refer to this behavior. In the *React* community, we rarely use
    this word because this is the behavior designed at its birth.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *React* 中的典型父/子关系中，建议子组件不应该更改 prop 的值。相反，应该通过函数 prop 来完成。当将 *React* 与其他库进行比较时，我们用“单程票”来指代这种行为。在
    *React* 社区中，我们很少使用这个词，因为这是从其诞生起就设计好的行为。
- en: Now that we know the definition of a function component and the role props play
    in building a component, let's take a look at how, in general, we write a function
    component.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了函数组件的定义以及 props 在构建组件中的作用，让我们看看通常我们是如何编写一个函数组件的。
- en: Writing a function component
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写函数组件
- en: The function, representing a component, defines what to update on the screen.
    It returns a value composed of some *HTML*-like code. You should be quite familiar
    with elements such as `<ul>` and `<li>`; *React* also allows the addition of *JavaScript*
    expressions under these elements. When used together, it requires the *JavaScript*
    expression to be wrapped in a pair of brackets, `{}`. The job of this expression
    is to provide dynamic *HTML* content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，代表一个组件，定义了屏幕上要更新的内容。它返回一个由一些类似 *HTML* 的代码组成的值。你应该非常熟悉 `<ul>` 和 `<li>` 等元素；*React*
    还允许在这些元素下添加 *JavaScript* 表达式。当它们一起使用时，需要将 *JavaScript* 表达式包裹在一对括号 `{}` 中。这个表达式的任务是提供动态
    *HTML* 内容。
- en: 'For instance, if we have a `text` variable and would like to display it, we
    could do the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个 `text` 变量并希望显示它，我们可以这样做：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or, if the text is returned from a function, we can do the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果文本是从函数返回的，我们可以这样做：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We know that this *JavaScript* expression is filled in the location where the
    `children` prop is.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这个 *JavaScript* 表达式是填充在 `children` 属性的位置。
- en: 'The children element does not have to be a single element; it can be an array
    of elements as well:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 子元素不一定要是一个单独的元素；它也可以是一个元素数组：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It seems a bit complicated in the preceding code, so let''s take a look at
    what the code tries to achieve by looking at the result first:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，这似乎有点复杂，所以让我们先看看代码试图通过查看结果来实现什么：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Basically, it wants to output two `li` elements. To get there, we create an
    array containing two elements with a *JavaScript* expression. Once it becomes
    a *JavaScript* expression wrapped in brackets, `{}`, anything in *JavaScript*
    can be refactored and programmed however we want. We can use `arr.map` to form
    this array:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，它想要输出两个 `li` 元素。为了达到这个目的，我们使用一个 *JavaScript* 表达式创建一个包含两个元素的数组。一旦它变成了括号 `{}`
    包裹的 *JavaScript* 表达式，任何 *JavaScript* 中的内容都可以被重构和编程，就像我们想要的那样。我们可以使用 `arr.map`
    来形成这个数组：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Well done in code refactoring!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构做得很好！
- en: There are just so many different brackets shown in the preceding statement,
    including `{}`, `[]`, and `()`. So, feel free to take a moment to understand what
    each pair does. It is hard to believe that one of the challenges of writing in
    *React* is brackets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的陈述中展示了如此多的不同括号，包括 `{}`, `[]` 和 `()`。因此，请随意花一点时间来理解每一对括号的作用。难以相信在 *React*
    中写作的一个挑战就是括号。
- en: 'This is a good example that shows you that once things are wrapped in a *JavaScript*
    expression, they can be refactored as we would normally program. In this case,
    we can take the `arr` outside the function since `arr` is a constant that doesn''t
    have to be defined inside the `Title` component:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，展示了当你将事物包裹在 *JavaScript* 表达式中时，它们可以被重构，就像我们通常编程那样。在这种情况下，由于 `arr`
    是一个常数，不需要在 `Title` 组件内部定义，我们可以将 `arr` 提取到函数外部：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once you get a feel for using the JavaScript expression along with HTML-like
    code, sooner or later, you will develop your own programming style because underlying
    this exercise is the JavaScript language.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你习惯了使用 JavaScript 表达式和类似 HTML 的代码，迟早你会发展出自己的编程风格，因为在这个练习背后是 JavaScript 语言。
- en: Now that you have gotten to know this process, let's code an example together.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这个过程，让我们一起来编写一个示例代码。
- en: Example of a function component
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组件示例
- en: A site is made up of pages, where each page contains a sidebar, a header, a
    content area, and a footer. All of them can be modeled with components. The layout
    component can sit at the top of the tree. When you zoom in, you find its children
    inside with a sub-structure. Just like a spider's web (see *Figure 1.3*) the tree
    structure cascades down from the outer level into the inner level.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网站由页面组成，其中每个页面包含一个侧边栏、一个页眉、一个内容区域和一个页脚。所有这些都可以用组件来建模。布局组件可以位于树的顶部。当你放大时，你会发现在其内部有子结构。就像蜘蛛网（参见
    *图 1.3*）一样，树结构从外层级级联到内层级。
- en: '![Figure 1.3 – Web application layout'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 网络应用程序布局'
- en: '](img/Figure_1.03_B17963.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.03_B17963.jpg)'
- en: Figure 1.3 – Web application layout
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 网络应用程序布局
- en: As *UI* engineers, we focus on the design of each component. Moreover, we pay
    close attention to the relationship between components. We want to know whether
    `Title` is built inside the main content or the sidebar. We want to know whether
    a header needs to be shared by multiple pages. You'll start to develop the skill
    to navigate between components among a tree.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*UI*工程师，我们专注于每个组件的设计。此外，我们非常关注组件之间的关系。我们想知道`Title`是否在主要内容或侧边栏内部构建。我们想知道是否需要多个页面共享标题。你将开始掌握在组件树之间导航的技能。
- en: 'Say we want to display a list of navigation links at the top of the page. Each
    link can be disabled if required. For enabled ones, we can click to navigate to
    its corresponding *URL*. See *Figure 1.4*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在页面顶部显示一组导航链接。如果需要，每个链接都可以被禁用。对于启用的链接，我们可以点击它导航到相应的*URL*。参见*图1.4*：
- en: '![Figure 1.4 – Nav component'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.4 – Nav component]'
- en: '](img/Figure_1.04_B17963.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.04_B17963.jpg]'
- en: Figure 1.4 – Nav component
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – Nav组件
- en: 'The navigation links can be predefined in an array of link objects:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 导航链接可以预先定义在一个链接对象的数组中：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In each of the preceding links, the `key` property provides an identifier, the
    `label` property specifies the displayed title, and the `disabled` property indicates
    whether the user is allowed to click on it or not.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的每个链接中，`key`属性提供了一个标识符，`label`属性指定了显示的标题，而`disabled`属性表示用户是否可以点击它。
- en: 'We also want to display a line below the currently selected link. Based on
    these requirements, we come up with the implementation with `selected` and `items`
    props:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望在当前选中的链接下方显示一条线。基于这些要求，我们提出了带有`selected`和`items`属性的实现：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding `Nav` component, the `items` prop holds the list of links,
    and the `selected` prop holds the current selected item''s key. The job of the
    `Nav` component is to display the list:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Nav`组件中，`items`属性包含链接列表，而`selected`属性包含当前选中项的键。`Nav`组件的职责是显示列表：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding `return` statement, `items` is iterated through one by one
    by following a loop and displaying links with a `ul/li` structure. Each link is
    displayed as a button supporting a `disabled` attribute. It also marks the link's
    *CSS* class as being `active` if it's the currently selected link.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`return`语句中，`items`通过循环逐个迭代，并使用`ul/li`结构显示链接。每个链接都显示为一个支持`disabled`属性的按钮。如果它是当前选中的链接，它还会标记链接的*CSS*类为`active`。
- en: Watch out for the `key` attribute for each item. This attribute is required
    for *React* to know the position of each `li` element among the lists. With the
    key provided as a unique identifier, *React* can quickly find the right element
    to perform the comparison and update the screen. `key` is a must-have attribute
    when returning an array of elements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个项目中的`key`属性。这个属性对于*React*来说，是必须的，因为它能知道列表中每个`li`元素的位置。有了提供的唯一标识符，*React*可以快速找到正确的元素来执行比较和更新屏幕。当返回一个元素数组时，`key`是一个必备的属性。
- en: Playground – Nav Component
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – Nav组件
- en: Feel free to play with the example online at [https://codepen.io/windmaomao/pen/porzQjV](https://codepen.io/windmaomao/pen/porzQjV).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试这个示例：[https://codepen.io/windmaomao/pen/porzQjV](https://codepen.io/windmaomao/pen/porzQjV)。
- en: 'Now we can display `Nav` with the following line. Voilà:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下行显示`Nav`。哇哦：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To make each menu item easy to develop and maintain, we can extract lines out
    to form a separate component:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使每个菜单项易于开发和维护，我们可以提取行以形成一个单独的组件：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding code, a `NavItem` component is created to accept `label`,
    `active`, `disabled`, and `onClick` props. We don''t need to overthink these prop
    names because they come in naturally, refactoring from the preceding `Nav` component.
    We can plug `NavItem` back to `Nav`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，创建了一个`NavItem`组件来接受`label`、`active`、`disabled`和`onClick`属性。我们不需要过度思考这些属性名，因为它们自然地来源于前面的`Nav`组件。我们可以将`NavItem`重新插入到`Nav`中：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This refactoring exercise is quite common and effective. This way, both `Nav`
    and `NavItem` components become easier to maintain in the future.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构练习相当常见且有效。这样，`Nav`和`NavItem`组件在未来的维护中都会变得更加容易。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first went over the history of UI components by looking
    at four libraries – *jQuery*, *Angular*, *React*, and *LitElement – t*o get an
    idea of having a component and how components are put together to build an application.
    Then, we learned what a function component is, with an introduction to its props
    and parent/child relationship. We then learned how to write a function component
    in general, and finally, we built a `Nav` component step by step.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先通过查看四个库——*jQuery*、*Angular*、*React*和*LitElement*——来回顾UI组件的历史，以了解组件的概念以及组件是如何组合在一起来构建应用的。然后，我们学习了函数组件是什么，以及对其属性和父子关系的介绍。接着，我们学习了如何一般性地编写函数组件，最后我们逐步构建了一个`Nav`组件。
- en: In the next chapter, we will craft a state of the function component from scratch
    and see how actions can benefit from it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从头开始构建函数组件的状态，并看看动作如何从中受益。
- en: Questions and answers
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题与答案
- en: 'Here are some questions and answers to refresh your knowledge:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题和答案来刷新你的知识：
- en: What is a function component?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函数组件？
- en: A function component is a function taking props as its input argument and returning
    elements. For an `App` component, we can display it by using its instance form,
    `<App />`. To build an application, it's about putting a component under another
    component as a child and refining this process until we end up with a tree of
    components.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数组件是一个函数，它以属性作为输入参数，并返回元素。对于一个`App`组件，我们可以通过其实例形式`<App />`来显示它。构建一个应用，就是将一个组件作为子组件放在另一个组件下面，并不断优化这个过程，直到我们最终得到一个组件树。
- en: How do you write a function component?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你该如何编写一个函数组件？
- en: The way to become adept at writing function components is quite similar to writing
    functions. Ask yourself what the props specification of the component is and what
    is returned for display. In a typical application, half of the components are
    designed for business requirements, but the other half normally comes from code
    refactoring. A study of **Functional Programming** (**FP**) can generally benefit
    you and take your UI skills to the next level.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要熟练编写函数组件的方法与编写函数的方法非常相似。问问自己组件的属性规范是什么，以及返回给显示的内容是什么。在一个典型的应用中，大约有一半的组件是为业务需求设计的，但另一半通常来自代码重构。对**函数式编程**（**FP**）的研究通常对你有益，并能将你的UI技能提升到下一个层次。
- en: Appendix
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Appendix A – How many component types does React support?
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A – React支持多少种组件类型？
- en: 'In the published *React* documentation, it supports two component types. One
    is a function component, and another one is a class component. *React* supported
    the class component from the beginning:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布的*React*文档中，它支持两种组件类型。一种是一个函数组件，另一种是一个类组件。*React*从一开始就支持类组件：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Although the `render` function of a class component looks quite similar to what
    a function component returns and, most of the time, we can convert them in between,
    the class and function components are treated differently inside the *React* update
    process. Therefore, this book intentionally avoids mentioning the class component
    so as not to confuse any newcomer to *React*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类组件的`render`函数看起来与函数组件返回的内容非常相似，而且大多数时候我们可以在它们之间进行转换，但在*React*的更新过程中，类组件和函数组件的处理方式是不同的。因此，这本书有意避免提及类组件，以免混淆任何新接触*React*的新手。
- en: In general, a function component can be written shorter and simpler, and it's
    also easier in terms of development and testing because it has plain inputs and
    outputs. Also, it doesn't have the `this` keyword, which can intimidate new developers
    or sometimes even senior developers. However, the downside of using a function
    component is that it's relatively new to the programming world, and there's also
    a mentality shift from **Object-Oriented Programming** (**OOP**) to **Functional
    Programming** (**FP**), which can consume you if you are not prepared. Not to
    mention, being new means there can be different approaches that we need to learn
    and absorb before we can address the old problems.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，函数组件可以写得更短、更简单，在开发和测试方面也更加容易，因为它只有简单的输入和输出。此外，它没有`this`关键字，这可能会让新开发者甚至有时是资深开发者感到畏惧。然而，使用函数组件的缺点是它在编程世界中相对较新，而且从**面向对象编程**（**OOP**）到**函数式编程**（**FP**）的心态转变可能会让你感到压力，如果你没有做好准备的话。更不用说，作为新事物，可能存在不同的方法，我们需要在解决旧问题之前学习和吸收这些方法。
- en: 'Other than the class and function components, internally, *React* actually
    supports more component types, as in the following example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类和函数组件之外，内部实际上*React*支持更多组件类型，如下例所示：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the `memo` function is applied to the `Title` component, it creates a component
    with a component type, `MemoComponent`. We don't need to go into the details of
    these component types, but just know that each component type gets its own update
    algorithm when updated to the screen.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当`memo`函数应用于`Title`组件时，它创建了一个具有组件类型`MemoComponent`的组件。我们不需要深入了解这些组件类型的细节，但只需知道，每个组件类型在更新到屏幕时都会获得自己的更新算法。
