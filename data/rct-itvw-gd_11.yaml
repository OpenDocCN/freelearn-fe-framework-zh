- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Building an App Based on React, Redux, Styled Components, and the Firebase Backend
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于React、Redux、Styled Components和Firebase后端构建应用程序
- en: As we progress through this book, we will cover many concepts and skills related
    to the React ecosystem, popular libraries, and the best practices to build robust
    React applications in the modern era of web apps. This chapter is dedicated to
    creating a full stack React application with the help of knowledge gained in the
    previous chapters. As part of the interview process, the interviewer might ask
    you to build a full-fledged React project based on certain functional and technical
    requirements, or assign a quick coding challenge to assess your abilities in a
    particular domain. This chapter will guide you on how to tackle the coding rounds,
    by creating a React project from scratch following standard guidelines and asking
    interview questions on the implemented project. In this chapter, we will build
    an e-commerce application by implementing various UI components, applying styles,
    verifying the identity of the registered users through an authentication mechanism,
    integrating with the Firebase backend, and deploying the application to make it
    available for public usage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续阅读本书，我们将涵盖与React生态系统、流行库以及构建现代Web应用时代稳健React应用程序的最佳实践相关的许多概念和技能。本章致力于利用前几章学到的知识创建一个全栈React应用程序。作为面试过程的一部分，面试官可能会要求你基于某些功能和技术要求构建一个完整的React项目，或者分配一个快速编码挑战来评估你在特定领域的技能。本章将指导你如何应对编码轮次，通过从头开始创建一个React项目，遵循标准指南，并对实施的项目提出面试问题。在本章中，我们将通过实现各种UI组件、应用样式、通过身份验证机制验证注册用户的身份、集成Firebase后端以及部署应用程序使其可供公众使用来构建一个电子商务应用程序。
- en: First, we will start with the process of scaffolding the project using an official
    `react-intl` library to support internationalization, and the Firebase package
    to implement the backend. Then, we will quickly introduce the Firebase backend
    and its services, integrating Firebase inside our React project and authentication
    features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用官方的`react-intl`库来支持国际化，以及Firebase包来实现后端，开始搭建项目的流程。然后，我们将快速介绍Firebase后端及其服务，将Firebase集成到我们的React项目中，并实现身份验证功能。
- en: Thereafter, we will build business logic following Redux standards to work with
    various actions triggered from a UI. To increase the user base from various regions,
    we will enhance the application with the support of an internationalization process.
    Then, we will write a couple of unit tests to make our code flawless and work
    as per business requirements. At the end of the chapter, we will host our Git
    repository on GitHub and make it available online to showcase our skills.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们将按照Redux标准构建业务逻辑，以处理从UI触发的各种动作。为了增加来自不同地区的用户基础，我们将通过国际化过程增强应用程序。然后，我们将编写几个单元测试，以确保我们的代码无瑕疵并符合业务要求。在本章结束时，我们将把我们的Git仓库托管在GitHub上，并使其在线上可用，以展示我们的技能。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Scaffolding and configuring a project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭建和配置项目
- en: Introducing Firebase services and configuring an application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Firebase服务和配置应用程序
- en: Implementing Firebase Authentication and its backend
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Firebase身份验证及其后端
- en: Building the Redux components for state management
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用于状态管理的Redux组件
- en: Building the presentation layer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建表示层
- en: Supporting internationalization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持国际化
- en: Implementing testing using the Vitest framework
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vitest框架实现测试
- en: Creating a Git repository with README documentation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有README文档的Git仓库
- en: Deploying the application for public access
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序以供公众访问
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before starting our project’s journey, your workstation should have the latest
    Node.js and npm ([https://nodejs.org/en](https://nodejs.org/en)) packages installed
    on it. You will also need to have a Netlify account ([https://www.netlify.com/](https://www.netlify.com/))
    for the deployment section while building this project and a GitHub ([https://github.com/](https://github.com/))
    account to host the Git repository. The code base of this project can be found
    online in the git Repository: [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始我们项目的旅程之前，你的工作站应该安装了最新的 Node.js 和 npm ([https://nodejs.org/en](https://nodejs.org/en))
    包。在构建此项目的同时，你还需要一个 Netlify ([https://www.netlify.com/](https://www.netlify.com/))
    账户用于部署部分，以及一个 GitHub ([https://github.com/](https://github.com/)) 账户来托管 Git 仓库。此项目的代码库可以在以下
    Git 仓库中找到：[https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics)。
- en: Let’s first talk about the scaffolding and project configuration to build a
    React application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈构建 React 应用程序所需的脚手架和项目配置。
- en: Scaffolding and configuring the project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚手架和配置项目
- en: In [*Chapter 6*](B18603_06.xhtml#_idTextAnchor209), we covered various topics
    about Redux and its workflow to build React web applications, based on a Redux
    state management solution. To reduce the boilerplate code involved with Redux
    logic, the Redux team recommends using **RTK** to simplify many common use cases,
    apply best practices, and prevent common mistakes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18603_06.xhtml#_idTextAnchor209)中，我们介绍了关于 Redux 及其工作流程的多个主题，这些主题基于
    Redux 状态管理解决方案来构建 React 网络应用程序。为了减少与 Redux 逻辑相关的样板代码，Redux 团队建议使用 **RTK** 来简化许多常见用例，应用最佳实践，并防止常见错误。
- en: If you create a project from scratch, doing so using the **Redux and TypeScript
    template for Vite** is one of the suggested approaches from the Redux team. So,
    we will use the same approach to build the project in this section. In this project,
    we will build an e-commerce application, named *One Stop Electronics*, where one
    can buy electronic devices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从头开始创建项目，使用 **Redux 和 TypeScript 模板 for Vite** 是 Redux 团队建议的方法之一。因此，在本节中，我们将使用相同的方法来构建项目。在这个项目中，我们将构建一个名为
    *One Stop Electronics* 的电子商务应用程序，用户可以购买电子设备。
- en: 'The following `degit` project scaffolding command is helpful for creating a
    project structure based on RTK:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `degit` 项目脚手架命令有助于创建基于 RTK 的项目结构：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This template creates a project based on TypeScript (`.tsx` or `.ts` files),
    with the required type definition dependencies for the `react`, `react-dom`, `and`
    `jest` packages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板基于 TypeScript（`.tsx` 或 `.ts` 文件）创建项目，并为 `react`、`react-dom` 和 `jest` 包提供了所需的类型定义依赖项。
- en: 'The project will use React Router to navigate the pages in the application
    and `FormatJS`, which is a modular collection of JavaScript libraries to support
    internationalization, using the `React Intl` library. The commands to install
    these packages are listed here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 项目将使用 React Router 在应用程序中导航页面，并使用 `FormatJS`，这是一个支持国际化的模块化 JavaScript 库集合，使用
    `React Intl` 库。以下列出安装这些包的命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are various approaches to styling React components. We will use styled-components
    for this project to write component-based styling. This package will be installed
    along with its type definition dependency, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种方法来为 React 组件添加样式。我们将在此项目中使用 styled-components 来编写基于组件的样式。此包将与其类型定义依赖项一起安装，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'styled-components was discussed in [*Chapter 7*](B18603_07.xhtml#_idTextAnchor239).
    You can also find more details and features on the official website: [https://styled-components.com](https://styled-components.com).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18603_07.xhtml#_idTextAnchor239)中讨论了 styled-components。你还可以在官方网站上找到更多详细信息和新功能：[https://styled-components.com](https://styled-components.com)。
- en: 'The Firebase cloud-based development platform will be used for this application
    to implement an authentication mechanism and backend data storage. So, let’s install
    the latest Firebase version with the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将使用 Firebase 基于云的开发平台来实现身份验证机制和后端数据存储。因此，让我们使用以下命令安装最新的 Firebase 版本：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the application folder structure is created and the aforementioned dependencies
    are installed, let’s create a few more folders to customize the project as per
    the tech stack. The important folders are listed as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了应用程序文件夹结构并安装了上述依赖项，让我们再创建几个文件夹来根据技术栈定制项目。以下列出了重要的文件夹：
- en: '`app/store`: The `store` folder is used to create various components of RTK,
    such as actions or action creators, reducers, and selectors'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/store`：`store` 文件夹用于创建 RTK 的各种组件，如 actions 或 action creators、reducers
    和 selectors'
- en: '`assets`: This folder holds all the image and icon files'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assets`：此文件夹包含所有图像和图标文件'
- en: '`backend`: This contains the Firebase-related API and e-commerce application
    data'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend`：此目录包含与 Firebase 相关的 API 和电子商务应用程序数据'
- en: '`features`: The folder is dedicated to the main pages for the web application'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`features`：此文件夹专门用于 Web 应用程序的主要页面'
- en: '`i18n`: This contains all the internationalization-specific files'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i18n`：此目录包含所有国际化特定文件'
- en: '**Visual Studio** (**VS**) Code is widely used and quite popular for React
    development. So, we will use it for this project and the folder structure, after
    adding all the aforementioned folders, as shown in the following figure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio**（**VS**）Code 广泛使用，并且对于 React 开发来说相当受欢迎。因此，我们将使用它来完成此项目，并在添加所有上述文件夹后，如图所示：'
- en: '![Figure 11.1: The application folder structure](img/Figure_11.01_B18603.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1：应用程序文件夹结构](img/Figure_11.01_B18603.jpg)'
- en: 'Figure 11.1: The application folder structure'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：应用程序文件夹结构
- en: VS Code provides a big list of extensions in its marketplace. In this project,
    the `vscode-styled-components` extension will be used to highlight the syntax
    of styled-components, and the `Prettier` code formatter extension will be used
    to format code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 在其市场提供大量扩展。在此项目中，将使用 `vscode-styled-components` 扩展来突出显示 styled-components
    的语法，并使用 `Prettier` 代码格式化扩展来格式化代码。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is no restriction to use a specific IDE. You can use any popular IDE based
    on your preference and required features.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用特定 IDE 的限制。您可以根据自己的偏好和所需功能使用任何流行的 IDE。
- en: In the following section, we will be introduced to Firebase’s services and required
    configuration and learn about Firebase Authentication and the backend, before
    proceeding with its implementation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍 Firebase 的服务、所需配置以及 Firebase 身份验证和后端，然后再进行其实施。
- en: Introducing Firebase services and configuring the application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Firebase 服务和配置应用程序
- en: Firebase is a comprehensive **backend as a service** (**BaaS**) provider offered
    by Google that provides database, authentication, cloud storage, analytics, and
    many other services on the fly. These backend services help developers to build
    apps faster and more securely without requiring much programming code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase 是由 Google 提供的全面的后端即服务（**BaaS**）提供商，它提供数据库、身份验证、云存储、分析以及许多其他即时服务。这些后端服务帮助开发者更快、更安全地构建应用程序，而无需编写大量编程代码。
- en: What are the main features of Firebase?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Firebase 的主要功能有哪些？
- en: 'To get a clearer idea of Firebase, we will look at some of its main features.
    They are listed as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地了解 Firebase，我们将查看其一些主要功能。它们如下列出：
- en: '**Realtime Database**: The Firebase Realtime Database is a cloud-hosted NoSQL
    database. The data is stored in the JSON format and synchronized in real time
    for every connected client. The database supports all types of platforms such
    as Android, iOS, and web platforms.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时数据库**：Firebase 实时数据库是一个云托管的 NoSQL 数据库。数据以 JSON 格式存储，并为每个连接的客户端实时同步。数据库支持所有类型的平台，如
    Android、iOS 和 Web 平台。'
- en: Here, *Realtime* means that any changes to data are reflected immediately across
    the platforms and devices within a few milliseconds. Moreover, the Realtime Database
    provides great offline support by caching all the data you have queried and retrieving
    it from the cache whenever there’s no internet connection. Once a device is connected
    back to the internet, the database synchronizes the local data changes to the
    original remote data to avoid any conflicts occurring with the internet outage.
    As a result, the apps remain responsive.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，*实时*意味着对数据的任何更改都会在几毫秒内立即反映在平台和设备上。此外，实时数据库通过缓存您查询的所有数据，并在没有互联网连接时从缓存中检索它，提供了出色的离线支持。一旦设备重新连接到互联网，数据库就会将本地数据更改同步到原始远程数据，以避免因互联网中断而发生的任何冲突。因此，应用程序保持响应。
- en: '`FirebaseUI` library as a complete ready-made UI authentication solution.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirebaseUI` 库作为一个完整的现成 UI 身份验证解决方案。'
- en: '**Cloud Storage**: Cloud Storage is a simple cost-effective storage service
    for application developers who need to store and process user-generated large-content
    files, such as images, audio, videos, and any other object type. You can use either
    the Firebase SDKs or Google Cloud Storage APIs to access those content files.
    The Firebase SDKs enable secure uploads and downloads from clients directly.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云存储**：云存储是针对需要存储和处理用户生成的大容量文件（如图像、音频、视频和其他任何对象类型）的应用程序开发者的简单且成本效益高的存储服务。您可以使用
    Firebase SDK 或 Google Cloud Storage API 访问这些内容文件。Firebase SDK 允许客户端直接进行安全上传和下载。'
- en: '**Google Analytics and Crashlytics**: Google Analytics for Firebase is a free
    app measurement solution that helps you get insights into app usage and user engagement.
    This service provides unlimited reporting of up to 500 distinct events, defined
    using the Firebase SDK. This analytics information can be used for business growth
    by retaining more users and making wise decisions for marketing and performance
    optimizations.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Analytics 和 Crashlytics**：Google Analytics for Firebase 是一款免费的应用程序测量解决方案，可以帮助您深入了解应用程序的使用情况和用户参与度。此服务提供使用
    Firebase SDK 定义的最多 500 个不同事件的无限量报告。这些分析信息可以通过保留更多用户和为营销和性能优化做出明智决策来促进业务增长。'
- en: Crashlytics is a real-time crash reporting tool that collects details about
    errors and crashes that occurred in your application. This is helpful to troubleshoot
    an issue by logging the error details, such as the line number where the error
    happened, the device name, the OS version, and when the issue happened.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Crashlytics 是一款实时崩溃报告工具，可以收集有关应用程序中发生的错误和崩溃的详细信息。这有助于通过记录错误详情（如错误发生的行号、设备名称、操作系统版本以及问题发生的时间）来解决问题。
- en: How do you set up and configure Firebase for authentication and data storage?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何设置和配置 Firebase 以进行身份验证和数据存储？
- en: 'If the project that you build is based on the Firebase backend, you need to
    take the following steps to create a Firebase app:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您构建的项目基于 Firebase 后端，您需要采取以下步骤来创建 Firebase 应用：
- en: Go to the official Firebase console at [https://console.firebase.google.com/](https://console.firebase.google.com/)
    and log in with your Google account.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请访问官方 Firebase 控制台 [https://console.firebase.google.com/](https://console.firebase.google.com/)
    并使用您的 Google 账户登录。
- en: Click on the `onestop-electronics`. After that, click on the **Continue** button
    to proceed with the configuration wizard.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `onestop-electronics`。然后，点击 **继续** 按钮以继续配置向导。
- en: You will get the option to enable Google Analytics for your project. This is
    optional and not required for this project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将获得启用项目 Google Analytics 的选项。这是可选的，并且对于此项目不是必需的。
- en: Then, click on **Create project**. You need to wait for a while to provision
    the resources and finish the setup of the project.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **创建项目**。您需要等待一段时间以配置资源并完成项目的设置。
- en: Click on the web icon on the home page of your project to create your web app.
    This opens a form to enter the web app name. Then click on the **Register App**
    button to integrate the web app with Firebase.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您项目主页上的网页图标以创建您的网络应用。这将打开一个输入网络应用名称的表单。然后点击 **注册应用** 按钮将网络应用与 Firebase 集成。
- en: Then, copy the web app’s Firebase-generated configuration, and save it for later
    usage in the project.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，复制网络应用的 Firebase 生成的配置，并将其保存以供项目中的后续使用。
- en: After that, add Firebase products named `Authentication` to build a secure authentication
    system and `Cloud Firestore` for the cloud-hosted NoSQL database used in the project.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加名为 `Authentication` 的 Firebase 产品以构建安全的身份验证系统，以及用于项目中云托管 NoSQL 数据库的 `Cloud
    Firestore`。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Authentication` product is used to store the authenticated user on sign-up,
    and update the user on every sign-in operation, whereas the Firestore database
    will store the application data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authentication` 产品用于在注册时存储已验证用户，并在每次登录操作中更新用户信息，而 Firestore 数据库将存储应用程序数据。'
- en: 'By default, Firestore doesn’t provide read or write permissions. This permission
    flag can be enabled inside the **Rules** tab. The updated security rule looks
    like this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Firestore 不提供读取或写入权限。此权限标志可以在 **规则** 选项卡中启用。更新的安全规则看起来如下：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `Authentication` product, you can choose sign-in methods such as *email/password*
    and *Google* providers. You can also find several other third-party providers
    under the sign-in provider section.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Authentication` 产品中，您可以选择如 *电子邮件/密码* 和 *Google* 提供商等登录方式。您还可以在登录提供商部分找到几个其他第三方提供商。
- en: You can create multiple projects under a single account, but there is a limit
    for the free plan.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在单个账户下创建多个项目，但免费计划有限制。
- en: Where do you put Firebase configuration securely in the project?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你在哪里安全地放置 Firebase 配置？
- en: 'It is not recommended to store the Firebase configuration in a repository that
    will be available on a public development platform, such as GitHub. You can keep
    the configuration in the following `.env.local` file in the key-value format,
    and add it to the `.gitignore` file of the project:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议将 Firebase 配置存储在将可在公共开发平台上公开的存储库中，例如 GitHub。你可以将配置保存在以下 `.env.local` 文件中，以键值格式，并将其添加到项目的
    `.gitignore` 文件中：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The keys should start with the `VITE` keyword in a Vite-based project, as shown
    in the preceding code. The same keys are accessible in the project through `import.meta.env.VITE`.
    For instance, this configuration is useful to instantiate the Firebase app in
    the `config.ts` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Vite 的项目中，密钥应以 `VITE` 关键字开头，如前述代码所示。相同的密钥可以通过 `import.meta.env.VITE` 在项目中访问。例如，此配置在
    `config.ts` 文件中实例化 Firebase 应用很有用：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The exported `firebaseApp` from the preceding code can be used anywhere in the
    project when it is required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码中导出的 `firebaseApp` 可以在任何需要的地方在项目中使用。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you create a React project based on the `REACT_APP` and be accessible through
    the `process.env` variables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你基于 `REACT_APP` 创建一个 React 项目，它将通过 `process.env` 变量可访问。
- en: Once the Firebase project is configured, we need to implement the Firebase authentication
    methods that will be invoked upon sign-up and sign-in form submission. Simultaneously,
    Cloud Firestore data operations should be implemented in the form of methods to
    store and retrieve product information. The following section will focus on this
    Firebase API implementation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 Firebase 项目，我们需要实现将在注册和登录表单提交时调用的 Firebase 身份验证方法。同时，应将 Cloud Firestore
    数据操作以方法的形式实现，用于存储和检索产品信息。以下部分将专注于此 Firebase API 实现。
- en: Implementing Firebase Authentication and its backend
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Firebase 身份验证及其后端
- en: Once the Firebase app is configured in the Firebase console, you can implement
    authentication for the One Stop Electronics application using the Firebase Authentication
    API. These API methods are helpful to authenticate legitimate users when they
    sign up and sign in to purchase products in this e-commerce application. Usually,
    we create all the API handlers inside a separate folder (in our case, `backend->firebase->api`)
    to keep it separate from the frontend code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 Firebase 控制台中配置了 Firebase 应用，你可以使用 Firebase Authentication API 实现One Stop
    Electronics 应用的身份验证。这些 API 方法在用户注册和登录以购买此电子商务应用中的产品时，有助于验证合法用户。通常，我们会在一个单独的文件夹内创建所有
    API 处理程序（在我们的例子中是 `backend->firebase->api`），以将其与前端代码分离。
- en: How do you implement Firebase authentication for sign-in, sign-up, and sign-out
    scenarios?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何实现 Firebase 身份验证的登录、注册和注销场景？
- en: 'We need to import several Firebase functions and utilities from the `Firebase/auth`
    package to work with the authentication mechanism. The Firebase package provides
    separate methods for sign-in, sign-up, and sign-out scenarios. Let’s start by
    importing all these API methods along with a Firebase instance inside the following
    `api/auth.ts` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从 `Firebase/auth` 包中导入几个 Firebase 函数和实用工具，以与身份验证机制一起工作。Firebase 包为登录、注册和注销场景提供了单独的方法。让我们从以下
    `api/auth.ts` 文件中导入所有这些 API 方法以及一个 Firebase 实例开始：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, the `auth` instance has been created based on the Firebase
    app instance. Also, the Google provider has been configured to prompt for Google
    account details to perform Google sign-in authentication.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，`auth` 实例是基于 Firebase 应用实例创建的。此外，Google 提供商已配置为提示 Google 账户详细信息以执行 Google
    登录身份验证。
- en: 'Using the preceding API utilities, write down the two sign-in methods in the
    same file mentioned above – one with an email address and a password, and another
    one using Google sign-in authentication. Similarly, the sign-up method can be
    created based on an email address and a password, along with a username. The sign-out
    method will be used to end the current user session. The following `auth.ts` file
    is updated with these authentication methods:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述 API 工具，在上述同一文件中写下两个登录方法——一个使用电子邮件地址和密码，另一个使用 Google 登录身份验证。同样，注册方法可以根据电子邮件地址和密码以及用户名创建。注销方法将用于结束当前用户会话。以下
    `auth.ts` 文件已更新为这些身份验证方法：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding exported methods will be integrated with UI screens, especially
    for sign-in or sign-up forms, in the upcoming section where we will build the
    presentation layer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的导出方法将在下一节中与UI屏幕集成，特别是对于登录或注册表单，我们将构建表示层。
- en: 'Lastly, it is also possible to listen to the authenticate state changes using
    the following method. This method is helpful to update the current user details
    in the application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还可以使用以下方法监听身份验证状态的变化。此方法有助于在应用程序中更新当前用户详情：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we are ready with all the backend authentication methods, which are helpful
    to create an active user session in the e-commerce application. Once the user
    is authenticated, they can usually perform **create, read, update, and delete**
    (**CRUD**) operations on the application data, based on business needs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了所有后端身份验证方法，这些方法有助于在电子商务应用程序中创建一个活跃的用户会话。一旦用户经过身份验证，他们通常可以根据业务需求在应用程序数据上执行**创建、读取、更新和删除**（**CRUD**）操作。
- en: How do you implement cloud store data operations? Can you explain data operations
    with any collection?
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您如何实现云存储数据操作？您能否用任何集合解释数据操作？
- en: Unlike a SQL database, there are no tables and rows within a cloud store database.
    Here, you store data as key-value pairs in the form of documents, which are organized
    into collections. The stored product information is displayed as a part of a landing
    page, which is crucial in this e-commerce application. So, let’s explain data
    operations with a product collection.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQL数据库不同，云存储数据库中没有表和行。在这里，您将数据以文档的形式存储为键值对，这些文档组织成集合。存储的产品信息作为着陆页的一部分显示，这对于这个电子商务应用程序至关重要。因此，让我们通过产品集合来解释数据操作。
- en: First, we need to create a product collection to store the electronic device
    data in Firebase’s *Cloud Firestore* database. If the collection does not exist
    in the database, it will be created automatically and insert the product data.
    In this application, the product records (or documents, using Firebase’s terminology)
    are uploaded to the database through a JSON file, available at `firebase/data/products-data.json`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在Firebase的*Cloud Firestore*数据库中创建一个产品集合来存储电子设备数据。如果集合在数据库中不存在，它将自动创建并插入产品数据。在这个应用程序中，产品记录（或文档，使用Firebase的术语）通过一个JSON文件上传到数据库，该文件位于`firebase/data/products-data.json`。
- en: 'Let’s start by importing all the required functions from the `firebase/firestore`
    package, along with the product type, inside the following `firebase/data/db-utils.ts`
    file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入`firebase/firestore`包中的所有必需函数开始，包括产品类型，在以下`firebase/data/db-utils.ts`文件中：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, the database instance is created through the
    `getFirestore()` function to perform database operations on the application collections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，数据库实例是通过`getFirestore()`函数创建的，以便在应用程序集合上执行数据库操作。
- en: 'Using the previously imported functions, you can create read and write operations
    for the product collection in the same file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前导入的函数，您可以在同一文件中为产品集合创建读取和写入操作：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, the product data is inserted with the help of the following
    four steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，产品数据通过以下四个步骤插入：
- en: First, create a collection reference, which is based on the database instance
    and unique key.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个基于数据库实例和唯一键的集合引用。
- en: Then, create a batch reference based on the database instance to insert multiple
    products at a time.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，基于数据库实例创建一个批次引用以一次插入多个产品。
- en: Iterate each product, and create a document reference to update the batch.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代每个产品，并为更新批次创建一个文档引用。
- en: Finally, commit the batch to insert multiple records simultaneously.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，提交批次以同时插入多个记录。
- en: 'Similarly, the product data is retrieved in four steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，产品数据通过以下四个步骤检索：
- en: First, create a collection reference for products.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为产品创建一个集合引用。
- en: Then, create a query reference based on the collection reference created in
    the previous step.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，基于上一步创建的集合引用创建一个查询引用。
- en: Fetch all the documents of the product collection using the `getDocs` method,
    and store them as a snapshot.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getDocs`方法获取产品集合的所有文档，并将它们存储为快照。
- en: Finally, iterate through the query snapshot and return the results.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，遍历查询快照并返回结果。
- en: All the preceding cloud store data functions are imported from the `firebase/firestore`
    package.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述云存储数据函数都是从`firebase/firestore`包中导入的。
- en: It is also possible to create a user collection based on each sign-up action,
    triggered through the new user. You can find this specific API handler within
    the code and extend the functionality of this project as per the requirements.
    However, this is out of the scope of this specific section and is the code snippet
    is only commented on for reference.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据每个注册动作创建用户集合也是可能的，这个动作是通过新用户触发的。你可以在代码中找到这个特定的 API 处理程序，并根据需求扩展这个项目的功能。然而，这超出了本节的范围，并且代码片段仅作为参考进行注释。
- en: Now, we have completed the backend code. In the following section, let’s create
    all the Redux components to implement a state management solution for this application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了后端代码。在下一节中，让我们创建所有 Redux 组件，以实现这个应用的状态管理解决方案。
- en: Building the Redux components for state management
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Redux 组件以进行状态管理
- en: The Redux store-related components cover most of the application actions, such
    as calculating the business logic, creating or updating the data inside the store,
    and fetching the latest data to display on the UI. In this project, the store
    components are categorized into product, cart, and user folders. Each folder contains
    files such as the entity type (`*.type.ts`), a slice that contains actions or
    a reducer (`*.slice.ts`), and a selector to retrieve the data (`*.selector.ts`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 存储相关的组件涵盖了应用的大部分动作，例如计算业务逻辑、在存储中创建或更新数据，以及获取最新数据以在 UI 上显示。在这个项目中，存储组件被分类到产品、购物车和用户文件夹中。每个文件夹包含实体类型（`*.type.ts`）、包含动作或还原器的切片（`*.slice.ts`），以及用于检索数据的选择器（`*.selector.ts`）。
- en: 'In our e-commerce application, the `Product` entity is required to display
    details such as product name, brand, price, and quantity to showcase all the available
    products. So, let’s create the store components for the product entity first.
    The following `product.type.ts` file creates the product and its relevant types,
    with all possible properties:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电子商务应用中，`Product` 实体需要显示产品名称、品牌、价格和数量等详细信息，以展示所有可用的产品。因此，让我们首先创建产品实体的存储组件。以下
    `product.type.ts` 文件创建了产品和相关的类型，包含所有可能的属性：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the product types are created, the product slice should be created to
    update the product list and product category in the store. RTK simplifies things
    by keeping these actions inside a reducer as a product slice. The following is
    a product slice with the name `product.slice.ts`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了产品类型，应该创建产品切片来更新存储中的产品列表和产品类别。RTK 通过将这些动作保持在一个名为产品切片的还原器内部来简化事情。以下是一个名为
    `product.slice.ts` 的产品切片：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding actions are exported in order to use them on the respective product
    UI page, in response to user actions, whereas the exported reducer is used to
    fetch the store state, such as the products, the category, and the product map,
    based on a category name using the `reselect` library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的动作被导出，以便在相应的产品 UI 页面上使用，以响应用户动作，而导出的还原器用于使用 `reselect` 库根据类别名称获取存储状态，例如产品、类别和产品映射。
- en: 'The following code is for the `product.selector.tsx` file. The code for this
    file is quite long, so let’s break it down into smaller code blocks. The first
    code block contains selectors to fetch products, the loading state of the products,
    and the product category:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `product.selector.tsx` 文件。这个文件的代码相当长，所以让我们将其分解成更小的代码块。第一个代码块包含用于获取产品、产品加载状态和产品类别的选择器：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following code block contains a product map with respect to each category:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含每个类别的产品映射：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The One Stop Electronics application uses the preceding `selectProductsMap`
    to filter the products based on a category. Our application has various categories
    such as all types of laptops, tabs, and mobiles.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: One Stop Electronics 应用使用前面的 `selectProductsMap` 根据类别过滤产品。我们的应用有各种类别，如所有类型的笔记本电脑、平板电脑和手机。
- en: Similarly, we can create store components for the `User` and `Cart` entities.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以为 `User` 和 `Cart` 实体创建存储组件。
- en: How do you work with multiple reducers in a Redux application?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何在 Redux 应用中处理多个还原器？
- en: 'Once you complete all the Redux entities for the project, all the reducers
    need to be combined in a single root reducer named the `root-reducer.ts` file.
    Here, we will use the `combineReducers` method from Redux, which accepts all the
    reducers as an object in a single argument:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成项目的所有 Redux 实体，所有还原器都需要在一个名为 `root-reducer.ts` 的单个根还原器文件中合并。在这里，我们将使用 Redux
    的 `combineReducers` 方法，它接受所有还原器作为一个对象的单个参数：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Thereafter, the store can be configured using the aforementioned root reducer
    inside the `store.ts` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，可以在 `store.ts` 文件中使用前面提到的根 reducer 来配置 store：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: RTK automatically calls the `combineReducers` method, so you don’t need to invoke
    it directly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: RTK 自动调用 `combineReducers` 方法，因此你不需要直接调用它。
- en: Now, the store is ready to be used for any `read` or `update` operations on
    the application data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，store 已准备好用于对应用程序数据进行任何 `read` 或 `update` 操作。
- en: The Redux development is now completed for the entire application using RTK.
    The next section is dedicated to building the presentation layer using UI components
    and web pages based on these reusable components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RTK，整个应用程序的 Redux 开发现已完成。下一节将专注于使用 UI 组件和基于这些可重用组件的网页构建表示层。
- en: Building the presentation layer
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建表示层
- en: It is a common practice to keep reusable components under the `components` folder.
    In this project, we will create customized form components such as button, input,
    select, and spinner, layout components such as header and footer, and reusable
    functional components such as products and categories inside the `components`
    folder.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将可重用组件保存在 `components` 文件夹下是一种常见做法。在本项目中，我们将在 `components` 文件夹内创建定制的表单组件，如按钮、输入、选择和旋转器，布局组件如页眉和页脚，以及可重用的功能组件如产品和类别。
- en: How do you implement a custom button using styled-components?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何使用 styled-components 实现自定义按钮？
- en: The HTML button element doesn’t come with different variations in terms of styling,
    but it is possible to create multiple button variations using React and styled-components.
    Let’s look at a button component and how it can be customized for the purposes
    of this project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 按钮元素在样式方面没有不同的变体，但可以使用 React 和 styled-components 创建多个按钮变体。让我们看看按钮组件以及它是如何根据本项目需求进行定制的。
- en: The project requires basic buttons that are bigger in size (mainly used for
    sign-up and sign-in pages), inverted buttons with constrasting colors for Google
    sign-in, and small buttons in scenarios where there is not a lot of space on screen
    (which are often used to add products to a cart). As a first step, the styled-component
    should be created with these different styles inside the `button.styles.tsx` file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目需要更大的基本按钮（主要用于注册和登录页面），具有对比颜色的反转按钮用于 Google 登录，以及屏幕空间有限的情况下的小按钮（通常用于添加产品到购物车）。作为第一步，应在
    `button.styles.tsx` 文件内创建具有这些不同样式的 styled-component。
- en: 'Let’s break down the code into small code blocks because of the large content
    in the file. The first code block contains the `BasicButton` styled-component:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件内容较多，让我们将代码分解成小的代码块。第一个代码块包含 `BasicButton` styled-component：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code block contains two more styled button components that extend
    the basic button. The inverted button inverts the background and text colors of
    the basic button, and while the small button appears to be similar to the basic
    button, it will actually be smaller in size:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含两个扩展基本按钮的 styled 按钮组件。反转按钮反转了基本按钮的背景和文字颜色，而小按钮看起来与基本按钮相似，但实际上会更小：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding styled-components, we have used the `rem` relative unit instead
    of an absolute unit such as `px` to have dynamic sizing or spacing, depending
    on screen size.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 styled-components 中，我们使用了 `rem` 相对单位而不是 `px` 这样的绝对单位，以便根据屏幕大小动态调整大小或间距。
- en: 'Then, we import these button styles into the following `button.tsx` file and
    dynamically render the respective button component, based on the button’s type
    prop value. The component also accepts children and other button props:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些按钮样式导入到下面的 `button.tsx` 文件中，并根据按钮的 `type` 属性值动态渲染相应的按钮组件。该组件还接受子元素和其他按钮属性：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding `MyButton` component is typed in such a way that it accepts only
    the `button` type and other built-in HTML button attributes as props. If you pass
    any other button prop that doesn’t belong to the button element, there will be
    a compile-time error due to `TypeScript` usage. The usage of the previously customized
    button appears on several pages of our application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `MyButton` 组件被类型化为仅接受 `button` 类型和其他内置 HTML 按钮属性作为属性。如果你传递任何不属于按钮元素的按钮属性，由于使用了
    TypeScript，将会出现编译时错误。之前定制的按钮的使用出现在我们应用程序的多个页面上。
- en: Implementing business-specific UI components
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现特定业务 UI 组件
- en: Similar to a button component, you can create a product box component. The product
    component should display the product image, name, brand, and price details in
    a particular style layout. Let’s apply all the required styles for each field
    inside the `product.styles.tsx` file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与按钮组件类似，你可以创建一个产品盒组件。产品组件应按照特定的样式布局显示产品图片、名称、品牌和价格详情。让我们在`product.styles.tsx`文件中应用每个字段所需的样式。
- en: 'The first code block contains the styled-components import and the type declaration
    for the image background prop:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码块包含styled-components的导入和图像背景属性的类型声明：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code block has a `ProductContainer` styled component, which is
    used to wrap the product image and other product details:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含一个用于包装产品图片和其他产品详情的`ProductContainer` styled组件：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code block contains a `Footer` styled-component, which is used
    to style and wrap around the product fields:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含一个用于样式化和包装产品字段的`Footer` styled-component：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we have the styled-component for each product field declared in order
    to give them a unique look:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为每个产品字段声明的styled-component以赋予它们独特的样式：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding styled-component, each product field has its own style. For
    example, the name of the product should be in a bigger font size, and the price
    should be in a different font color to highlight the important data while showcasing
    the products.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的styled-component中，每个产品字段都有自己的样式。例如，产品的名称应该使用更大的字体大小，而价格应该使用不同的字体颜色来突出显示重要数据，同时展示产品。
- en: The styled-components of the previously completed `product.styles.tsx` file
    will be used in the markup, as shown in the following `product.tsx` file. The
    component code is quite long, so let’s break it down into smaller code chunks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之前完成的`product.styles.tsx`文件中的styled-components将在以下`product.tsx`文件中的标记中使用，如下所示。组件代码相当长，所以让我们将其分解成更小的代码片段。
- en: 'First, define the imports of our page, the product’s prop type, and the utility
    function to verify the non-white background images:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义我们页面的导入、产品的prop类型和验证非白色背景图像的实用函数：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s add the `ProductItem` component, which accepts `product` as a prop
    without having any markup code. The component declares `currentUser` and `addCartProduct`
    to dispatch the product to the cart:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加`ProductItem`组件，该组件接受`product`作为prop，没有任何标记代码。组件声明了`currentUser`和`addCartProduct`来将产品派发到购物车：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, the rendered product markup is added, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加了渲染的产品标记，如下所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding `ProductItem` component hides the button to add a product to the
    cart if the application is not authenticated by the user.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`ProductItem`组件在应用程序未通过用户认证时隐藏将产品添加到购物车的按钮。
- en: Similarly, you can create other UI components to reuse them in the required
    pages. Now, let’s build the application pages based on all these reusable UI components.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以创建其他UI组件以在所需页面上重用。现在，让我们基于所有这些可重用UI组件构建应用程序页面。
- en: Implementing application pages using UI components
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现应用程序页面使用UI组件
- en: Each web page in a React application is composed of UI components. Our application
    requires product landing, add product to cart, sign-up, and sign-in pages. These
    pages should be created under the `features` folder as per the scaffolding structure.
    The product’s landing page is created by iterating the `Product` component with
    a list of products. The following code is for the `products.tsx` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个React应用程序中的网页都是由UI组件组成的。我们的应用程序需要产品着陆页、添加产品到购物车、注册和登录页面。根据脚手架结构，这些页面应该在`features`文件夹下创建。产品着陆页是通过迭代产品列表中的`Product`组件创建的。以下代码是`products.tsx`文件中的代码。
- en: 'This file code is quite long, so let’s break it down into smaller code blocks.
    This first code block has imports related to React Hooks, components, selectors,
    and styled-components, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件代码相当长，所以让我们将其分解成更小的代码块。第一个代码块包含与React Hooks、组件、选择器和styled-components相关的导入，如下所示：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following code block is updated with the components code, which has product
    information (i.e., `productsMap` and `category`) retrieved from the store using
    selectors. It also includes the `useEffect` Hook to set the latest products when
    there is a change in the category and product data:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块更新了组件代码，该代码从存储中检索产品信息（即`productsMap`和`category`），并包括`useEffect` Hook，在类别和产品数据发生变化时设置最新的产品：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, the rendered markup for our products page looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的产品页面的渲染标记如下所示：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, the `Products` screen displays a page loader until the
    data is retrieved. Once the data is ready, a list of products appears in the grid
    format.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Products` 屏幕在数据检索之前显示页面加载器。一旦数据准备就绪，产品列表将以网格格式显示。
- en: 'Conversely, the sign-in page can be created using input and button UI components
    to authenticate the Firebase backend. It follows the sign-in process through either
    regular email or the Google sign-in mechanism. The sign-in page to authenticate
    the user appears as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，可以使用输入和按钮 UI 组件创建登录页面以验证 Firebase 后端。它通过常规电子邮件或 Google 登录机制跟踪登录过程。用于验证用户的登录页面如下所示：
- en: '![Figure 11.2: The sign-in page](img/Figure_11.02_B18603.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2：登录页面](img/Figure_11.02_B18603.jpg)'
- en: 'Figure 11.2: The sign-in page'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：登录页面
- en: Authentication through the sign-in page is helpful for adding products to the
    cart. It also provides a link at the bottom for sign-up if there are new users.
    In a similar fashion, you can implement sign-up and cart pages.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过登录页面进行身份验证有助于将产品添加到购物车。如果存在新用户，它还提供了一个底部的注册链接。以类似的方式，您可以实现注册和购物车页面。
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is still possible to see the available products irrespective of whether a
    user signs in to the application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户未登录到应用程序，仍然可以查看可用的产品。
- en: 'Now, we have reached a position with all the required UI components and pages
    ready to use. As a last step, the application layout can be designed with the
    `Header` and `Footer` UI components, along with the previously implemented pages
    mapped for each route, inside the following `App.tsx` file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经到达了一个位置，所有必需的 UI 组件和页面都已准备好使用。作为最后一步，可以在以下 `App.tsx` 文件中使用 `Header` 和
    `Footer` UI 组件设计应用程序布局，以及为每个路由映射的先前实现的页面：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, the routes are configured for each page. The products
    page is configured as a default route. That means that this page will be displayed
    immediately after running the `npm run dev` command in the project root folder.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，为每个页面配置了路由。产品页面被配置为默认路由。这意味着在项目根目录中运行 `npm run dev` 命令后，将立即显示此页面。
- en: '![Figure 11.3: The product showcase](img/Figure_11.03_B18603.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3：产品展示](img/Figure_11.03_B18603.jpg)'
- en: 'Figure 11.3: The product showcase'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：产品展示
- en: Upon adding each product to the cart, the count of cart products will appear
    on the cart icon. If a user doesn’t log in to the application, the add to cart
    button will be hidden. Moreover, you can filter the product list based on the
    selected category, as an additional feature.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将产品添加到购物车时，购物车图标上都会显示产品数量。如果用户未登录到应用程序，则隐藏“添加到购物车”按钮。此外，您可以根据所选类别过滤产品列表，作为附加功能。
- en: Even though we have completed all the pages, the text messages are hardcoded
    in the English language. This means that it will be difficult for non-English
    readers to read the messages. In the following section, the application will be
    enhanced with internationalization support to increase our user base across the
    globe.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经完成了所有页面，但文本消息是硬编码在英语中的。这意味着非英语读者阅读消息将很困难。在下一节中，将通过国际化支持增强应用程序，以增加我们全球的用户基础。
- en: Supporting internationalization
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持国际化
- en: If you want to launch your current services in the international market, your
    web application should support internationalization to meet the needs of global
    users. In [*Chapter 4*](B18603_04.xhtml#_idTextAnchor150), we covered internationalization
    through the `FormatJS` library.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在国际市场上推出当前的服务，您的 Web 应用程序应支持国际化以满足全球用户的需求。在 [*第 4 章*](B18603_04.xhtml#_idTextAnchor150)
    中，我们通过 `FormatJS` 库介绍了国际化。
- en: This project mainly uses the same `FormatJS` library to translate the text messages
    and support the formatted currency amounts. The entire process of extending the
    application with internationalization involves just a few instructions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目主要使用相同的 `FormatJS` 库来翻译文本消息并支持格式化的货币金额。将国际化扩展到应用程序的过程仅涉及几个指令。
- en: 'First, create all the translations inside the `i18n->translations` folder in
    the form of JSON files. These translations will be loaded based on the respective
    locales defined inside the `i18n->locale.ts` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `i18n->translations` 文件夹中创建所有翻译，形式为 JSON 文件。这些翻译将根据 `i18n->locale.ts` 文件中定义的相应区域设置加载：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, you need to configure `IntlProvider` at the root of the application.
    This provider loads specific locale messages, as mapped in the previous step,
    using the `locale` value:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要在应用程序的根目录下配置`IntlProvider`。此提供者使用`locale`值加载特定区域的消息，如上一步映射所示：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, the current `locale` value is dynamic, and its value
    gets updated based on the locale dropdown that appears in the header section of
    the UI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当前的`locale`值是动态的，其值根据UI头部区域出现的区域选择下拉菜单进行更新。
- en: 'Now, you can start localizing the text messages and formatting the currency
    number using the `FormattedMessage` and `FormattedNumber` components, respectively,
    from `react-intl`, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始使用`react-intl`中的`FormattedMessage`和`FormattedNumber`组件分别本地化文本消息和格式化货币数字，如下所示：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding translation related to currency amounts not only includes the
    currency symbols but also adds comma separators. For instance, the following add
    to cart screen displays a list of added products with the page text in the German
    language and formatted currency amounts.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前与货币金额相关的翻译不仅包括货币符号，还添加了逗号分隔符。例如，以下添加到购物车屏幕显示了一个添加的产品列表，页面文本使用德语，并且格式化货币金额。
- en: '![Figure 11.4: Products added to the cart](img/Figure_11.04_B18603.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4：添加到购物车的产品](img/Figure_11.04_B18603.jpg)'
- en: 'Figure 11.4: Products added to the cart'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：添加到购物车的产品
- en: As you can see, the comma and decimal separators and the currency symbol position
    are modified based on the selected language. The product quantity and the amount
    values and their formats will be updated upon clicking the increment, decrement,
    and clear buttons on the page.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，逗号和十进制分隔符以及货币符号的位置根据所选语言进行修改。在页面上点击增加、减少和清除按钮时，产品数量和金额值及其格式将更新。
- en: How do you achieve internationalization through an imperative API?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何通过命令式API实现国际化？
- en: It is not always possible to use `react-intl` components such as `FormattedMessage`,
    `FormattedNumber`, or `FormattedDate` to format text messages, numbers, or dates
    – that is, you cannot use built-in components to format text messages inside text
    attributes such as `title` and `aria-label`, outside the markup area of React
    components and non-React ecosystems such as Node.js, a Redux store, and the testing
    section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是可以使用`react-intl`组件，如`FormattedMessage`、`FormattedNumber`或`FormattedDate`来格式化文本消息、数字或日期——也就是说，你无法使用内置组件在React组件的标记区域外或非React生态系统（如Node.js、Redux存储和测试部分）中的文本属性（如`title`和`aria-label`）内格式化文本消息。
- en: 'After you declare `IntlProvider`, you can get access to the `intl` object (with
    a type of `IntlShape`) by calling the `useIntl()` hook inside the React function
    component. For example, this Hook is used to support internationalization to prepare
    a category list outside the markup section:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在你声明`IntlProvider`之后，你可以在React函数组件内部调用`useIntl()`钩子来获取`intl`对象（类型为`IntlShape`）。例如，此钩子用于支持国际化，在标记区域外准备类别列表：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you want to support internationalization outside a React component, you need
    to use the `createIntl` API method by passing `locale` and `messages` properties
    in the form of an object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在React组件之外支持国际化，你需要通过传递对象形式的`locale`和`messages`属性来使用`createIntl` API方法。
- en: Currently, we have reached a stage with the completion of a full-fledged backend
    and frontend implementation. In the following section, we will see how to write
    unit tests to ensure that functionality works as per the business requirements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经完成了完整的后端和前端实现。在下一节中，我们将看到如何编写单元测试以确保功能符合业务需求。
- en: Implementing testing using the Vitest framework
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vitest框架实现测试
- en: Jest is quite a popular testing framework, with a full pack of testing features
    and an easy-to-use API, which makes it a standard testing framework in the web
    ecosystem. This project is based on Vite frontend tooling, and it is also possible
    to integrate Jest in Vite setups. However, this leads to a workspace where you
    have to configure and maintain two different pipelines, which is hard for developers.
    So, we will use **Vitest** for this project, which is a blazing-fast unit testing
    framework based on Jest and Vite tooling. This framework provides similar functionality
    and syntax to the Jest framework, using the existing configuration or plugins
    of Vite tooling.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Jest是一个非常流行的测试框架，拥有完整的测试功能和易于使用的API，这使得它成为Web生态系统中的标准测试框架。本项目基于Vite前端工具，也可以在Vite设置中集成Jest。然而，这会导致你需要配置和维护两个不同的工作区，这对开发者来说很困难。因此，我们将使用**Vitest**来处理这个项目，这是一个基于Jest和Vite工具的闪电般的单元测试框架。这个框架提供了与Jest框架类似的功能和语法，使用现有的Vite工具配置或插件。
- en: 'In this project, we will write unit tests for all the actions that exist under
    `cart.slice.ts`. First, let’s create the test suite with an initial cart state:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将为`cart.slice.ts`下存在的所有操作编写单元测试。首先，让我们创建一个带有初始购物车状态的测试套件：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, the initial state is available, with one cart product
    having a quantity of `2`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，初始状态是可用的，有一个购物车产品数量为`2`。
- en: 'Then, we will write a test case to verify the functionality of increasing quantity
    within the cart, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写一个测试用例来验证在购物车中增加数量的功能，如下所示：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding test case verifies that the quantity of products increased to
    `3` and the number of distinct products in the cart remains the same.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试用例验证了产品数量增加到`3`，而购物车中不同产品的数量保持不变。
- en: 'Similarly, the test case to decrease the product quantity in the cart is as
    follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，减少购物车中产品数量的测试用例如下：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding test case checks the quantity of products after decreasing the
    quantity in the cart. The quantity of products becomes `1` after decreasing or
    removing one item from the cart, which has an initial state quantity value of
    `2`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试用例检查在减少购物车中的数量后的产品数量。在减少或从购物车中移除一个项目后，产品数量变为`1`，其初始状态数量值为`2`。
- en: Similarly, we have test cases to clear and reset the cart actions. Once you
    run the `npm run test` command, you can see a summary of all the passed tests
    and failed tests for any incorrect code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还有测试用例来清除和重置购物车操作。一旦运行`npm run test`命令，你就可以看到所有通过测试和任何错误代码的失败测试的摘要。
- en: Now, our application is ready with full-fledged development code and covered
    with unit test cases to detect early flaws in the code. Let’s publish this code
    on GitHub as a Git repository to support version control and to make our app work
    smoothly online.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已经准备好，带有完整的开发代码，并覆盖了单元测试用例，以检测代码中的早期缺陷。让我们将此代码作为Git仓库发布到GitHub上，以支持版本控制和确保我们的应用程序在线上顺利运行。
- en: Creating a Git repository with README documentation
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有README文档的Git仓库
- en: 'Currently, the project is ready and able to run the application in a local
    system successfully. To enhance the project further, a hosting platform such as
    GitHub is required, as it provides storage and version control, deploys the project,
    and offers collaboration between various team members seamlessly. Let’s apply
    the following Git commands to push our local code to the GitHub platform:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，项目已经准备好，并且可以在本地系统中成功运行应用程序。为了进一步改进项目，需要一个托管平台，如GitHub，因为它提供存储和版本控制，部署项目，并使团队成员之间的协作无缝进行。让我们应用以下Git命令将本地代码推送到GitHub平台：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, our project is on GitHub, which enables us to easily deploy the application
    on Netlify.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的项目已托管在GitHub上，这使得我们能够轻松地将应用程序部署到Netlify。
- en: 'The final version of the One Stop Electronics GitHub project with `README.md`
    instructions is available in the Git repository for quick reference: [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`README.md`说明的One Stop Electronics GitHub项目的最终版本可在Git仓库中快速参考：[https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter11/one-stop-electronics)。
- en: The following section will discuss the deployment process to make the project
    accessible for the public.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将讨论部署过程，以便使项目对公众可访问。
- en: Deploying the application for public access
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署应用程序以供公众访问
- en: There are several options to deploy an app, such as Netlify, Vercel, GitHub
    Pages, and Firebase Hosting. We will use Netlify for the deployment by signing
    in through a GitHub account on the Netlify website. On the dashboard, you will
    have the option to select the repository and configure the site through settings.
    It is also possible to change a random site name to a new name. Since an environment
    variable file (e.g., `.env.local`) is not available in the root of the GitHub
    repository, you need to import the environment variable file into the dashboard
    before clicking the **Deploy** **site** button.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序有几种选择，例如Netlify、Vercel、GitHub Pages和Firebase Hosting。我们将通过在Netlify网站上通过GitHub账户登录来使用Netlify进行部署。在仪表板上，您可以选择仓库并通过设置配置网站。您还可以将随机网站名称更改为新名称。由于环境变量文件（例如，`.env.local`）在GitHub仓库的根目录中不可用，您需要在点击**部署**
    **网站**按钮之前将环境变量文件导入仪表板。
- en: 'By following all these steps, the application is now available online for everyone
    to access around the world. You can quickly go through all the screens, which
    are available at the Netlify domain for your reference: [https://onestop-electronics.netlify.app/](https://onestop-electronics.netlify.app/).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循所有这些步骤，应用程序现在已在线上对全球所有人开放。您可以快速浏览所有屏幕，这些屏幕在Netlify域名下可供您参考：[https://onestop-electronics.netlify.app/](https://onestop-electronics.netlify.app/)。
- en: Through continuous deployment, Netlify automatically updates your site when
    the code is updated on the GitHub repository.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续部署，Netlify会在GitHub仓库中的代码更新时自动更新您的网站。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have reached the end of the chapter and applied all the programming concepts
    learned in the previous chapters to build a robust full stack React application.
    At the beginning of the chapter, we had a quick introduction to scaffolding a
    React project using the standard templates of the Redux library. Later, we briefly
    covered Firebase services and provided step-by-step instructions to set up and
    configure authentication mechanisms, using the Firebase console. Then, we provided
    a detailed implementation of Firebase authentication and Cloud Firestore database
    operations for our One Stop Electronics application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本章的结尾，并将之前章节中学到的所有编程概念应用到构建一个健壮的全栈React应用程序中。在本章开始时，我们简要介绍了使用Redux库的标准模板来搭建React项目。后来，我们简要介绍了Firebase服务，并提供了使用Firebase控制台设置和配置身份验证机制的逐步说明。然后，我们为我们的One
    Stop Electronics应用程序提供了Firebase身份验证和Cloud Firestore数据库操作的详细实现。
- en: After the backend was ready to use, we moved on to building the UI layer by
    writing a few React UI components, building the application layout and pages for
    sign-in, sign-up, the product showcase, and cart items. This section was followed
    by implementing a business layer as per the RTK guidelines. Then, the project
    was further enhanced through internationalization support and writing unit tests.
    As the application reached the completion stage, the final step was creating a
    Git repository and making the application accessible online, with a deployment
    process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 后端准备就绪后，我们开始通过编写几个React UI组件来构建UI层，包括应用程序布局和登录、注册、产品展示和购物车页面的页面。这一部分之后，我们根据RTK指南实现了业务层。然后，通过国际化支持和编写单元测试进一步增强了项目。当应用程序达到完成阶段时，最后一步是创建Git仓库并使应用程序可通过网络访问，包括部署流程。
- en: After learning all these major milestones of application development, you should
    now be confident enough to showcase your skills in coding challenges and answer
    interview questions, especially armed with your practical working experience.
    In the following chapter, we will build another React app based on different skill
    sets, such as Next.js, GraphQL, SWR, and Vercel, for deployment. This will help
    you to enhance your knowledge of building various types of projects, with a different
    set of techniques and concepts that were not covered in this chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习所有这些应用程序开发的主要里程碑之后，您现在应该足够自信，可以在编码挑战中展示您的技能并回答面试问题，尤其是凭借您的实际工作经验。在下一章中，我们将基于不同的技能集（如Next.js、GraphQL、SWR和Vercel）构建另一个React应用程序以进行部署。这将帮助您增强对构建各种类型项目的知识，这些技术和概念在本章中没有涉及。
